From tomo at berlios.de  Wed Nov  2 17:38:09 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 2 Nov 2005 17:38:09 +0100
Subject: [Stgt-svn] r140 - trunk/kernel
Message-ID: <200511021638.jA2Gc9pP013027@sheep.berlios.de>

Author: tomo
Date: 2005-11-02 17:38:07 +0100 (Wed, 02 Nov 2005)
New Revision: 140

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
Log:
Add /sys/class/tgt_driver directory to route requests to correct
protocol libraries. I chose this way because it is the easiest
way. However, there are better alternatives. We will rewrite sysfs
code after the sysfs stuff in mainline settles.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-29 09:18:48 UTC (rev 139)
+++ trunk/kernel/tgt.c	2005-11-02 16:38:07 UTC (rev 140)
@@ -44,12 +44,6 @@
 #define	cmd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
 static struct list_head cmd_hash[1 << TGT_HASH_ORDER];
 
-struct target_type_internal {
-	struct list_head list;
-	struct tgt_target_template *tt;
-	struct tgt_protocol *proto;
-};
-
 static struct target_type_internal *target_template_get(const char *name)
 {
 	unsigned long flags;
@@ -77,8 +71,10 @@
 
 int tgt_target_template_register(struct tgt_target_template *tt)
 {
+	static int target_type_id;
 	unsigned long flags;
 	struct target_type_internal *ti;
+	int err;
 
 	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
 	if (!ti)
@@ -94,11 +90,22 @@
 		return -EINVAL;
 	}
 
+	err = tgt_sysfs_register_type(ti);
+	if (err)
+		goto proto_put;
+
 	spin_lock_irqsave(&target_tmpl_lock, flags);
 	list_add_tail(&ti->list, &target_tmpl_list);
+	ti->typeid = target_type_id++;
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
 
 	return 0;
+
+proto_put:
+	tgt_protocol_put(ti->proto);
+	kfree(ti);
+
+	return err;
 }
 EXPORT_SYMBOL_GPL(tgt_target_template_register);
 
@@ -112,12 +119,16 @@
 	list_for_each_entry(ti, &target_tmpl_list, list)
 		if (ti->tt == tt) {
 			list_del(&ti->list);
-			tgt_protocol_put(ti->proto);
-			kfree(ti);
-			break;
+			goto found;
 		}
-
+	ti = NULL;
+found:
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	if (ti) {
+		tgt_protocol_put(ti->proto);
+		tgt_sysfs_unregister_type(ti);
+	}
 }
 EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
 
@@ -154,6 +165,7 @@
 
 	target->tt = ti->tt;
 	target->proto = ti->proto;
+	target->typeid = ti->typeid;
 	target->tid = target_id++;
 	spin_lock_init(&target->lock);
 
@@ -861,44 +873,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
-static void tgt_start(void)
-{
-	struct tgt_event ev;
-	struct target_type_internal *ti;
-	unsigned long flags;
-	int n, err, done, rest = PAGE_SIZE;
-	char *p;
-
-	p = kzalloc(rest, GFP_KERNEL);
-	if (!p)
-		rest = 0;
-
-	n = done = 0;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-	list_for_each_entry(ti, &target_tmpl_list, list) {
-		dprintk("%s %s\n", ti->tt->name, ti->proto->name);
-		if (strlen(ti->tt->name) + strlen(ti->proto->name) + 2 > rest)
-			break;
-		err = snprintf(p + done, rest, "%s:%s,",
-			       ti->tt->name, ti->proto->name);
-		if (err < 0)
-			break;
-		rest -= err;
-		done += err;
-		n++;
-	}
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	memset(&ev, 0, sizeof(ev));
-	send_event_res(TGT_KEVENT_RESPONSE, &ev, p, done,
-		       GFP_KERNEL | __GFP_NOFAIL);
-
-	kfree(p);
-
-	eprintk("start %d target drivers\n", n);
-}
-
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;
@@ -912,7 +886,7 @@
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
 		tgtd_pid  = NETLINK_CREDS(skb)->pid;
-		tgt_start();
+		eprintk("start target drivers\n");
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
@@ -992,8 +966,7 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_START &&
-		    nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
 		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
 			struct tgt_event ev;
 

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-10-29 09:18:48 UTC (rev 139)
+++ trunk/kernel/tgt_sysfs.c	2005-11-02 16:38:07 UTC (rev 140)
@@ -9,56 +9,6 @@
 #include <tgt_target.h>
 #include <tgt_device.h>
 
-/*
- * Target files
- */
-#define tgt_target_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
-	return snprintf (buf, 20, format_string, target->field);	\
-}
-
-#define tgt_target_rd_attr(field, format_string)		\
-	tgt_target_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-#define tgt_target_template_show_fn(field, format_string)		\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
-	return snprintf (buf, 20, format_string, target->tt->field);	\
-}
-
-#define tgt_target_template_rd_attr(field, format_string)		\
-	tgt_target_template_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-tgt_target_rd_attr(queued_cmds, "%u\n");
-tgt_target_template_rd_attr(name, "%s\n");
-tgt_target_template_rd_attr(protocol, "%s\n");
-
-static struct class_device_attribute *tgt_target_attrs[] = {
-	&class_device_attr_queued_cmds,
-	&class_device_attr_name,
-	&class_device_attr_protocol,
-	NULL
-};
-
-static void tgt_target_class_release(struct class_device *cdev)
-{
-	struct tgt_target *target = cdev_to_tgt_target(cdev);
-	kfree(target->tt_data);
-	kfree(target);
-}
-
-static struct class tgt_target_class = {
-	.name = "tgt_target",
-	.release = tgt_target_class_release,
-};
-
 static struct class_device_attribute *class_attr_overridden(
 				struct class_device_attribute **attrs,
 				struct class_device_attribute *attr)
@@ -75,6 +25,7 @@
 }
 
 static int class_attr_add(struct class_device *classdev,
+			  struct class_device_attribute **attrs,
 			  struct class_device_attribute *attr)
 {
 	struct class_device_attribute *base_attr;
@@ -82,7 +33,7 @@
 	/*
 	 * Spare the caller from having to copy things it's not interested in.
 	*/
-	base_attr = class_attr_overridden(tgt_target_attrs, attr);
+	base_attr = class_attr_overridden(attrs, attr);
 	if (base_attr) {
 		/* extend permissions */
 		attr->attr.mode |= base_attr->attr.mode;
@@ -97,6 +48,109 @@
 	return class_device_create_file(classdev, attr);
 }
 
+#define cdev_to_tgt_type(cdev) \
+	container_of(cdev, struct target_type_internal, cdev)
+
+#define tgt_target_template_show_fn(field, format_string)		\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct target_type_internal *ti = cdev_to_tgt_type(cdev);	\
+	return snprintf (buf, 20, format_string, ti->tt->field);	\
+}
+
+#define tgt_target_template_rd_attr(field, format_string)		\
+	tgt_target_template_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_target_template_rd_attr(name, "%s\n");
+tgt_target_template_rd_attr(protocol, "%s\n");
+
+static struct class_device_attribute *tgt_type_attrs[] = {
+	&class_device_attr_name,
+	&class_device_attr_protocol,
+	NULL,
+};
+
+static void tgt_type_class_release(struct class_device *cdev)
+{
+	struct target_type_internal *ti = cdev_to_tgt_type(cdev);
+	kfree(ti);
+}
+
+static struct class tgt_type_class = {
+	.name = "tgt_type",
+	.release = tgt_type_class_release,
+};
+
+int tgt_sysfs_register_type(struct target_type_internal *ti)
+{
+	struct class_device *cdev = &ti->cdev;
+	int i, err;
+
+	cdev->class = &tgt_type_class;
+	snprintf(cdev->class_id, BUS_ID_SIZE, "driver%d", ti->typeid);
+
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	for (i = 0; tgt_type_attrs[i]; i++) {
+		err = class_device_create_file(&ti->cdev,
+					       tgt_type_attrs[i]);
+		if (err)
+			goto cleanup;
+	}
+
+	return 0;
+
+cleanup:
+	class_device_unregister(cdev);
+
+	return err;
+}
+
+void tgt_sysfs_unregister_type(struct target_type_internal *ti)
+{
+	class_device_unregister(&ti->cdev);
+}
+
+/*
+ * Target files
+ */
+#define tgt_target_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
+	return snprintf (buf, 20, format_string, target->field);	\
+}
+
+#define tgt_target_rd_attr(field, format_string)		\
+	tgt_target_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_target_rd_attr(queued_cmds, "%u\n");
+tgt_target_rd_attr(typeid, "%d\n");
+
+static struct class_device_attribute *tgt_target_attrs[] = {
+	&class_device_attr_queued_cmds,
+	&class_device_attr_typeid,
+	NULL
+};
+
+static void tgt_target_class_release(struct class_device *cdev)
+{
+	struct tgt_target *target = cdev_to_tgt_target(cdev);
+	kfree(target->tt_data);
+	kfree(target);
+}
+
+static struct class tgt_target_class = {
+	.name = "tgt_target",
+	.release = tgt_target_class_release,
+};
+
 int tgt_sysfs_register_target(struct tgt_target *target)
 {
 	struct class_device *cdev = &target->cdev;
@@ -112,9 +166,10 @@
 	if (target->tt->target_attrs) {
 		for (i = 0; target->tt->target_attrs[i]; i++) {
 			err = class_attr_add(&target->cdev,
+					     tgt_target_attrs,
 					     target->tt->target_attrs[i]);
-                        if (err)
-                                goto cleanup;
+			if (err)
+				goto cleanup;
 		}
 	}
 
@@ -203,6 +258,7 @@
 	if (device->dt->device_attrs) {
 		for (i = 0; device->dt->device_attrs[i]; i++) {
 			err = class_attr_add(&device->cdev,
+					     tgt_target_attrs,
 					     device->dt->device_attrs[i]);
                         if (err)
                                 goto cleanup;
@@ -237,18 +293,31 @@
 {
 	int err;
 
-	err = class_register(&tgt_target_class);
+	err = class_register(&tgt_type_class);
 	if (err)
 		return err;
 
+	err = class_register(&tgt_target_class);
+	if (err)
+		goto unregister_type;
+
 	err = class_register(&tgt_device_class);
 	if (err)
-		class_unregister(&tgt_target_class);
+		goto unregister_target;
+
+	return 0;
+
+unregister_target:
+	class_unregister(&tgt_target_class);
+unregister_type:
+	class_unregister(&tgt_type_class);
+
 	return err;
 }
 
 void tgt_sysfs_exit(void)
 {
+	class_unregister(&tgt_type_class);
 	class_unregister(&tgt_target_class);
 	class_unregister(&tgt_device_class);
 }

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-10-29 09:18:48 UTC (rev 139)
+++ trunk/kernel/tgt_target.h	2005-11-02 16:38:07 UTC (rev 140)
@@ -15,6 +15,14 @@
 struct tgt_target;
 struct tgt_cmd;
 
+struct target_type_internal {
+	int typeid;
+	struct list_head list;
+	struct tgt_target_template *tt;
+	struct tgt_protocol *proto;
+	struct class_device cdev;
+};
+
 enum {
 	TGT_CMD_XMIT_OK,
 	TGT_CMD_XMIT_FAILED,
@@ -69,6 +77,7 @@
 };
 
 struct tgt_target {
+	int typeid;
 	int tid;
 	struct tgt_target_template *tt;
 	void *tt_data;
@@ -97,7 +106,10 @@
 extern int tgt_target_destroy(struct tgt_target *target);
 extern int tgt_sysfs_register_target(struct tgt_target *target);
 extern void tgt_sysfs_unregister_target(struct tgt_target *target);
+
 extern int tgt_target_template_register(struct tgt_target_template *tt);
 extern void tgt_target_template_unregister(struct tgt_target_template *tt);
+extern int tgt_sysfs_register_type(struct target_type_internal *ti);
+extern void tgt_sysfs_unregister_type(struct target_type_internal *ti);
 
 #endif



From tomo at berlios.de  Wed Nov  2 17:40:37 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 2 Nov 2005 17:40:37 +0100
Subject: [Stgt-svn] r141 - trunk/usr
Message-ID: <200511021640.jA2Geb7C013359@sheep.berlios.de>

Author: tomo
Date: 2005-11-02 17:40:36 +0100 (Wed, 02 Nov 2005)
New Revision: 141

Modified:
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/netlink.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Changes in tgt user-space code for /sys/class/tgt_type directory.


Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-02 16:38:07 UTC (rev 140)
+++ trunk/usr/dl.c	2005-11-02 16:40:36 UTC (rev 141)
@@ -12,6 +12,7 @@
 #include <string.h>
 #include <fcntl.h>
 #include <dlfcn.h>
+#include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -22,11 +23,11 @@
 
 #include "log.h"
 #include "dl.h"
+#include "tgtd.h"
 
-#define	MAX_DL_HANDLES	32
-
 struct driver_info {
 	char *name;
+	char *proto;
 	void *dl;
 	void *pdl;
 };
@@ -46,62 +47,102 @@
 	return -ENOENT;
 }
 
+/* This function will be killed soon. */
 static int tid_to_did(int tid)
 {
-	char path[PATH_MAX], name[PATH_MAX];
-	int idx, fd, err;
+	char path[PATH_MAX], buf[PATH_MAX];
+	int fd, err;
 
-	memset(path, 0, sizeof(path));
-
-	sprintf(path, "/sys/class/tgt_target/target%d/name", tid);
+	sprintf(path, TGT_TARGET_SYSFSDIR "/target%d/typeid", tid);
 	fd = open(path, O_RDONLY);
 	if (fd < 0)
 		return fd;
 
-	err = read(fd, name, sizeof(name));
+	err = read(fd, buf, sizeof(buf));
 	close(fd);
 	if (err < 0)
 		return err;
 
-	idx = driver_find_by_name(name);
-	if (idx < 0)
-		eprintf("%d %s\n", idx, name);
+	return atoi(buf);
+}
 
-	return idx;
+static char *dlname(char *d_name, char *entry)
+{
+	int fd, err;
+	char *p, path[PATH_MAX], buf[PATH_MAX];
+
+	snprintf(path, sizeof(path),
+		 TGT_TYPE_SYSFSDIR "/%s/%s", d_name, entry);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		eprintf("%s\n", path);
+		return NULL;
+	}
+	memset(buf, 0, sizeof(buf));
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("%s %d\n", path, errno);
+		return NULL;
+	}
+
+	p = strchr(buf, '\n');
+	if (p)
+		*p = '\0';
+
+	return strdup(buf);
 }
 
-int dl_init(char *p)
+static int filter(const struct dirent *dir)
 {
-	int i;
-	char path[PATH_MAX], *driver, *proto;
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
 
-	for (i = 0; (driver = strsep(&p, ",")); i++) {
-		proto = strchr(driver, ':');
-		if (!proto)
+int dl_init(void)
+{
+	int i, nr, idx;
+	char path[PATH_MAX], *p;
+	struct dirent **namelist;
+	struct driver_info *di;
+
+	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
+	for (i = 0; i < nr; i++) {
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		idx = atoi(p);
+		if (idx > MAX_DL_HANDLES) {
+			eprintf("Cannot load %s %d\n",
+				namelist[i]->d_name, idx);
 			continue;
+		}
 
-		*proto++ = '\0';
-		dprintf("%s %s\n", driver, proto);
+		p = dlname(namelist[i]->d_name, "name");
+		if (!p)
+			continue;
 
-		memset(path, 0, sizeof(path));
-		strcpy(path, driver);
-		strcat(path, ".so");
-		dinfo[i].name = strdup(driver);
-		dinfo[i].dl = dlopen(path, RTLD_LAZY);
-		if (!dinfo[i].dl) {
-			fprintf(stderr, "%s %s\n", path, dlerror());
+		di = &dinfo[idx];
+
+		di->name = p;
+		snprintf(path, sizeof(path), "%s.so", p);
+		di->dl = dlopen(path, RTLD_LAZY);
+		if (!di->dl) {
+			eprintf("%s %s\n", path, dlerror());
 			continue;
 		}
 
-		memset(path, 0, sizeof(path));
-		strcpy(path, proto);
-		strcat(path, ".so");
-		dinfo[i].pdl = dlopen(path, RTLD_LAZY);
-		if (!dinfo[i].pdl)
-			fprintf(stderr, "%s %s\n", path, dlerror());
+		p = dlname(namelist[i]->d_name, "protocol");
+		if (!p)
+			continue;
+		di->proto = p;
+		snprintf(path, sizeof(path), "%s.so", p);
+		di->pdl = dlopen(path, RTLD_LAZY);
+		if (!di->pdl) {
+			eprintf("%s %s\n", path, dlerror());
+			continue;
+		}
 	}
 
-	return i;
+	return 0;
 }
 
 void dl_config_load(void)

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-11-02 16:38:07 UTC (rev 140)
+++ trunk/usr/dl.h	2005-11-02 16:40:36 UTC (rev 141)
@@ -1,7 +1,9 @@
 #ifndef __DL_H
 #define __DL_H
 
-extern int dl_init(char *data);
+#define	MAX_DL_HANDLES	16
+
+extern int dl_init(void);
 extern void dl_config_load(void);
 extern struct pollfd * dl_poll_init(int *nr);
 

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-02 16:38:07 UTC (rev 140)
+++ trunk/usr/netlink.c	2005-11-02 16:40:36 UTC (rev 141)
@@ -200,25 +200,22 @@
 {
 	int err;
 	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	char rbuf[8192];
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
 	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
-			  NLMSG_SPACE(sizeof(struct tgt_event)), rbuf);
+			  NLMSG_SPACE(sizeof(struct tgt_event)), NULL);
 
-	nlh = (struct nlmsghdr *) rbuf;
-	ev = (struct tgt_event *) NLMSG_DATA(nlh);
+	ev = (struct tgt_event *) NLMSG_DATA(nlmsg);
 
 	if (err < 0 || ev->k.event_res.err < 0) {
 		eprintf("%d %d\n", err, ev->k.event_res.err);
-		exit(-1);
+		return -EINVAL;
 	}
 
-	return dl_init((char *) ev->data);
+	return 0;
 }
 
-int nl_open(int *nr)
+int nl_open(void)
 {
 	int fd, err;
 
@@ -249,7 +246,9 @@
 	dest_addr.nl_pid = 0; /* kernel */
 	dest_addr.nl_groups = 0; /* unicast */
 
-	*nr = nl_start(fd);
+	err = nl_start(fd);
+	if (err < 0)
+		goto out;
 
 	return fd;
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-11-02 16:38:07 UTC (rev 140)
+++ trunk/usr/tgtd.c	2005-11-02 16:40:36 UTC (rev 141)
@@ -26,7 +26,7 @@
 #include "tgtd.h"
 #include "dl.h"
 
-#define	POLLS_PER_DRV	64
+#define	POLLS_PER_DRV	32
 
 int nl_fd, ipc_fd;
 
@@ -154,9 +154,8 @@
 
 int main(int argc, char **argv)
 {
-	int ch, longindex;
+	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	int nr;
 	pid_t pid;
 	struct pollfd *poll_array;
 
@@ -198,7 +197,7 @@
 		setsid();
 	}
 
-	nl_fd = nl_open(&nr);
+	nl_fd = nl_open();
 	if (nl_fd < 0)
 		exit(nl_fd);
 
@@ -206,6 +205,9 @@
 	if (ipc_fd < 0)
 		exit(ipc_fd);
 
+	dl_init();
+
+	nr = MAX_DL_HANDLES;
 	poll_array = poll_init(nr);
 
 	dl_config_load();

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-11-02 16:38:07 UTC (rev 140)
+++ trunk/usr/tgtd.h	2005-11-02 16:40:36 UTC (rev 141)
@@ -5,11 +5,14 @@
 
 extern int nl_fd;
 
-extern int nl_open(int *nr_drivers);
+extern int nl_open(void);
 extern void nl_event_handle(int fd);
 extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
+#define	TGT_TYPE_SYSFSDIR	"/sys/class/tgt_type"
+#define	TGT_TARGET_SYSFSDIR	"/sys/class/tgt_target"
+
 #endif



From tomo at berlios.de  Wed Nov  2 17:41:37 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 2 Nov 2005 17:41:37 +0100
Subject: [Stgt-svn] r142 - trunk/istgt/usr
Message-ID: <200511021641.jA2GfbI5013510@sheep.berlios.de>

Author: tomo
Date: 2005-11-02 17:41:37 +0100 (Wed, 02 Nov 2005)
New Revision: 142

Modified:
   trunk/istgt/usr/ctldev.c
   trunk/istgt/usr/istgt.c
Log:
Changes in istgt user-space code for /sys/class/tgt_type again.


Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-11-02 16:40:36 UTC (rev 141)
+++ trunk/istgt/usr/ctldev.c	2005-11-02 16:41:37 UTC (rev 142)
@@ -585,15 +585,55 @@
 	free(namelist);
 }
 
+static int get_typeid(void)
+{
+	int err = -EINVAL, i, nr, fd, typeid = -EINVAL;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], *p;
+
+	nr = scandir("/sys/class/tgt_type", &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		memset(path, 0, sizeof(path));
+		strncpy(path, "/sys/class/tgt_type/", sizeof(path));
+		strncat(&path[strlen(path)], namelist[i]->d_name, sizeof(path));
+		strncat(&path[strlen(path)], "/name", sizeof(path));
+		eprintf("%s\n", path);
+		fd = open(path, O_RDONLY);
+		if (fd < 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0)
+			continue;
+		eprintf("%s\n", buf);
+		if (!strncmp(buf, THIS_NAME, strlen(THIS_NAME))) {
+			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+				;
+			typeid = atoi(p);
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return typeid;
+}
+
 static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
 {
-	int err = -EINVAL, i, nr, fd;
+	int err = -EINVAL, i, nr, fd, typeid;
 	struct dirent **namelist;
 	char path[PATH_MAX], buf[PATH_MAX], *p;
 
 	if (req->op != OP_DELETE)
 		return err;
 
+	typeid = get_typeid();
+
 	nr = scandir("/sys/class/tgt_target", &namelist, filter, alphasort);
 	if (!nr)
 		return -ENOENT;
@@ -602,7 +642,7 @@
 		memset(path, 0, sizeof(path));
 		strncpy(path, "/sys/class/tgt_target/", sizeof(path));
 		strncat(&path[strlen(path)], namelist[i]->d_name, sizeof(path));
-		strncat(&path[strlen(path)], "/name", sizeof(path));
+		strncat(&path[strlen(path)], "/typeid", sizeof(path));
 		eprintf("%s\n", path);
 		fd = open(path, O_RDONLY);
 		if (fd < 0)
@@ -612,7 +652,7 @@
 		if (err < 0)
 			continue;
 		eprintf("%s\n", buf);
-		if (!strncmp(buf, THIS_NAME, strlen(THIS_NAME))) {
+		if (typeid == atoi(buf)) {
 			int tid;
 
 			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)

Modified: trunk/istgt/usr/istgt.c
===================================================================
--- trunk/istgt/usr/istgt.c	2005-11-02 16:40:36 UTC (rev 141)
+++ trunk/istgt/usr/istgt.c	2005-11-02 16:41:37 UTC (rev 142)
@@ -114,9 +114,8 @@
 	freeaddrinfo(res0);
 }
 
-void poll_init(struct pollfd *pfds, int nr)
+void poll_init(struct pollfd *pfds)
 {
-	eprintf("%d\n", nr);
 	listen_socket_create(pfds + POLL_LISTEN);
 }
 



From tomo at berlios.de  Wed Nov  2 19:10:37 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 2 Nov 2005 19:10:37 +0100
Subject: [Stgt-svn] r143 - in trunk: include kernel usr
Message-ID: <200511021810.jA2IAb3m010586@sheep.berlios.de>

Author: tomo
Date: 2005-11-02 19:10:29 +0100 (Wed, 02 Nov 2005)
New Revision: 143

Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/netlink.c
Log:
Fix target_type_id handling bug and kill tid_to_did().


Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-11-02 16:41:37 UTC (rev 142)
+++ trunk/include/tgt_if.h	2005-11-02 18:10:29 UTC (rev 143)
@@ -64,10 +64,12 @@
 			uint64_t cid;
 			int tid;
 			uint64_t dev_id;
+			int typeid;
 		} cmd_req;
 		struct {
 			int tid;
 			uint32_t len;
+			int typeid;
 		} tgt_passthru;
 	} k;
 

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-02 16:41:37 UTC (rev 142)
+++ trunk/kernel/tgt.c	2005-11-02 18:10:29 UTC (rev 143)
@@ -71,7 +71,7 @@
 
 int tgt_target_template_register(struct tgt_target_template *tt)
 {
-	static int target_type_id;
+	static atomic_t target_type_id = ATOMIC_INIT(0);
 	unsigned long flags;
 	struct target_type_internal *ti;
 	int err;
@@ -90,13 +90,14 @@
 		return -EINVAL;
 	}
 
+	ti->typeid = atomic_add_return(1, &target_type_id);
+
 	err = tgt_sysfs_register_type(ti);
 	if (err)
 		goto proto_put;
 
 	spin_lock_irqsave(&target_tmpl_lock, flags);
 	list_add_tail(&ti->list, &target_tmpl_list);
-	ti->typeid = target_type_id++;
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
 
 	return 0;
@@ -769,6 +770,7 @@
 	ev->k.cmd_req.tid = cmd->session->target->tid;
 	ev->k.cmd_req.dev_id = cmd->dev_id;
 	ev->k.cmd_req.cid = cmd->cid;
+	ev->k.cmd_req.typeid = cmd->session->target->typeid;
 
 	proto->build_uspace_pdu(cmd, pdu);
 
@@ -866,6 +868,7 @@
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.tgt_passthru.tid = target->tid;
+	ev.k.tgt_passthru.typeid = target->typeid;
 	ev.k.tgt_passthru.len = dlen;
 
 	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-02 16:41:37 UTC (rev 142)
+++ trunk/usr/dl.c	2005-11-02 18:10:29 UTC (rev 143)
@@ -47,25 +47,6 @@
 	return -ENOENT;
 }
 
-/* This function will be killed soon. */
-static int tid_to_did(int tid)
-{
-	char path[PATH_MAX], buf[PATH_MAX];
-	int fd, err;
-
-	sprintf(path, TGT_TARGET_SYSFSDIR "/target%d/typeid", tid);
-	fd = open(path, O_RDONLY);
-	if (fd < 0)
-		return fd;
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0)
-		return err;
-
-	return atoi(buf);
-}
-
 static char *dlname(char *d_name, char *entry)
 {
 	int fd, err;
@@ -191,28 +172,18 @@
 	return NULL;
 }
 
-void *dl_proto_cmd_process(int tid)
+void *dl_proto_cmd_process(int tid, int typeid)
 {
-	int idx = tid_to_did(tid);
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, "cmd_process");
 
-	if (idx < 0)
-		return NULL;
-
-	if (dinfo[idx].pdl)
-		return dlsym(dinfo[idx].pdl, "cmd_process");
-
 	return NULL;
 }
 
-void *dl_event_fn(int tid)
+void *dl_event_fn(int tid, int typeid)
 {
-	int idx = tid_to_did(tid);
+	if (dinfo[typeid].dl)
+		return dlsym(dinfo[typeid].dl, "async_event");
 
-	if (idx < 0)
-		return NULL;
-
-	if (dinfo[idx].dl)
-		return dlsym(dinfo[idx].dl, "async_event");
-
 	return NULL;
 }

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-11-02 16:41:37 UTC (rev 142)
+++ trunk/usr/dl.h	2005-11-02 18:10:29 UTC (rev 143)
@@ -10,7 +10,7 @@
 extern void *dl_poll_init_fn(int idx);
 extern void *dl_poll_fn(int idx);
 extern void *dl_ipc_fn(char *driver);
-extern void *dl_event_fn(int tid);
-extern void *dl_proto_cmd_process(int tid);
+extern void *dl_event_fn(int tid, int typeid);
+extern void *dl_proto_cmd_process(int tid, int typeid);
 
 #endif

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-02 16:41:37 UTC (rev 142)
+++ trunk/usr/netlink.c	2005-11-02 18:10:29 UTC (rev 143)
@@ -120,7 +120,8 @@
 	scb = (uint8_t *) ev_req->data;
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
-	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid);
+	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid,
+				  ev_req->k.cmd_req.typeid);
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
 			    ev_req->k.cmd_req.dev_id, scb,
@@ -136,7 +137,6 @@
 	ev_res->u.cmd_res.len = len;
 	ev_res->u.cmd_res.result = result;
 
-
 	log_error("scsi_cmd_process res %d len %d\n", result, len);
 
 	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
@@ -162,7 +162,8 @@
 		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dl_event_fn(ev->k.tgt_passthru.tid);
+		fn = dl_event_fn(ev->k.tgt_passthru.tid,
+				 ev->k.tgt_passthru.typeid);
 		if (fn)
 			fn(NLMSG_DATA(recvbuf));
 		else



From tomo at berlios.de  Thu Nov  3 03:37:16 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 3 Nov 2005 03:37:16 +0100
Subject: [Stgt-svn] r144 - trunk/usr
Message-ID: <200511030237.jA32bGV5015292@sheep.berlios.de>

Author: tomo
Date: 2005-11-03 03:37:15 +0100 (Thu, 03 Nov 2005)
New Revision: 144

Added:
   trunk/usr/tgt_sysfs.h
Modified:
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/ipc.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Replace driver string in tgtadm_req struct with typeid.


Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/dl.c	2005-11-03 02:37:15 UTC (rev 144)
@@ -24,6 +24,7 @@
 #include "log.h"
 #include "dl.h"
 #include "tgtd.h"
+#include "tgt_sysfs.h"
 
 struct driver_info {
 	char *name;
@@ -34,19 +35,6 @@
 
 static struct driver_info dinfo[MAX_DL_HANDLES];
 
-static int driver_find_by_name(char *name)
-{
-	int i;
-
-	for (i = 0; i < MAX_DL_HANDLES; i++) {
-		if (dinfo[i].dl &&
-		    !strncmp(dinfo[i].name, name, strlen(dinfo[i].name)))
-			return i;
-	}
-
-	return -ENOENT;
-}
-
 static char *dlname(char *d_name, char *entry)
 {
 	int fd, err;
@@ -123,6 +111,10 @@
 		}
 	}
 
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
 	return 0;
 }
 
@@ -157,18 +149,11 @@
 	return NULL;
 }
 
-void *dl_ipc_fn(char *name)
+void *dl_ipc_fn(int typeid)
 {
-	int idx = driver_find_by_name(name);
+	if (dinfo[typeid].dl)
+		return dlsym(dinfo[typeid].dl, "ipc_mgmt");
 
-	if (idx < 0) {
-		eprintf("%d %s\n", idx, name);
-		return NULL;
-	}
-
-	if (dinfo[idx].dl)
-		return dlsym(dinfo[idx].dl, "ipc_mgmt");
-
 	return NULL;
 }
 

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/dl.h	2005-11-03 02:37:15 UTC (rev 144)
@@ -9,7 +9,7 @@
 
 extern void *dl_poll_init_fn(int idx);
 extern void *dl_poll_fn(int idx);
-extern void *dl_ipc_fn(char *driver);
+extern void *dl_ipc_fn(int typeid);
 extern void *dl_event_fn(int tid, int typeid);
 extern void *dl_proto_cmd_process(int tid, int typeid);
 

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/ipc.c	2005-11-03 02:37:15 UTC (rev 144)
@@ -99,11 +99,11 @@
 
 	req = NLMSG_DATA(nlh);
 
-	dprintf("%s %d %d\n", req->driver, err, nlh->nlmsg_len);
+	dprintf("%d %d %d\n", req->typeid, err, nlh->nlmsg_len);
 
-	fn = dl_ipc_fn(req->driver);
+	fn = dl_ipc_fn(req->typeid);
 	if (!fn) {
-		eprintf("Cannot handle event %s\n", req->driver);
+		eprintf("Cannot handle event %d\n", req->typeid);
 		err = -EINVAL;
 		goto fail;
 	}

Added: trunk/usr/tgt_sysfs.h
===================================================================
--- trunk/usr/tgt_sysfs.h	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/tgt_sysfs.h	2005-11-03 02:37:15 UTC (rev 144)
@@ -0,0 +1,8 @@
+#ifndef	__TGT_SYSFS_H
+#define	__TGT_SYSFS_H
+
+#define	TGT_TYPE_SYSFSDIR	"/sys/class/tgt_type"
+#define	TGT_TARGET_SYSFSDIR	"/sys/class/tgt_target"
+#define	TGT_DEVICE_SYSFSDIR	"/sys/class/tgt_device"
+
+#endif

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/tgtadm.c	2005-11-03 02:37:15 UTC (rev 144)
@@ -18,6 +18,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>
+#include <dirent.h>
 #include <string.h>
 #include <dlfcn.h>
 #include <inttypes.h>
@@ -29,7 +30,15 @@
 #include <linux/netlink.h>
 
 #include "tgtadm.h"
+#include "tgt_sysfs.h"
 
+#define eprintf(fmt, args...)					\
+do {								\
+	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+} while (0)
+
+#define dprintf eprintf
+
 static char program_name[] = "tgtadm";
 
 static struct option const long_options[] =
@@ -98,6 +107,51 @@
 	exit(status == 0 ? 0 : -1);
 }
 
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static int driver_to_typeid(char *name)
+{
+	int i, nr, err, fd, id = -ENOENT;
+	char *p, path[PATH_MAX], buf[PATH_MAX];
+	struct dirent **namelist;
+
+	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
+	for (i = 0; i < nr; i++) {
+		snprintf(path, sizeof(path), TGT_TYPE_SYSFSDIR "/%s/name",
+			 namelist[i]->d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd < 0) {
+			eprintf("%s %d\n", path, errno);
+			continue;
+		}
+
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0) {
+			eprintf("%s %d\n", path, err);
+			continue;
+		}
+
+		if (strncmp(name, buf, strlen(name)))
+			continue;
+
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		id = atoi(p);
+		break;
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return id;
+}
+
 static int ipc_mgmt_connect(void)
 {
 	int fd, err;
@@ -202,7 +256,7 @@
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len;
-	int tid = -1;
+	int tid = -1, typeid;
 	uint32_t cid = 0, set = 0;
 	uint64_t sid = 0, lun = 0;
 	char *params = NULL, *driver = NULL;
@@ -253,15 +307,21 @@
 	}
 
 	if (op < 0) {
-		fprintf(stderr, "You must specify the operation type\n");
+		eprintf("You must specify the operation type\n");
 		goto out;
 	}
 
 	if (!driver) {
-		fprintf(stderr, "You must specify the driver name\n");
+		eprintf("You must specify the driver name\n");
 		goto out;
 	}
 
+	typeid = driver_to_typeid(driver);
+	if (typeid < 0) {
+		eprintf("Invalid driver name %s\n", driver);
+		goto out;
+	}
+
 	if (optind < argc) {
 		fprintf(stderr, "unrecognized: ");
 		while (optind < argc)
@@ -274,7 +334,7 @@
 	memset(rbuf, 0, sizeof(rbuf));
 
 	req = (struct tgtadm_req *) sbuf;
-	strncpy(req->driver, driver, sizeof(req->driver));
+	req->typeid = typeid;
 	req->op = op;
 	req->set = set;
 	req->tid = tid;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/tgtadm.h	2005-11-03 02:37:15 UTC (rev 144)
@@ -9,8 +9,6 @@
 #define	SET_DEVICE	(1 << 3)
 #define	SET_USER	(1 << 4)
 
-#define	TGT_DNAME_LEN	64
-
 enum tgtadm_op {
 	OP_NEW,
 	OP_DELETE,
@@ -19,7 +17,7 @@
 };
 
 struct tgtadm_req {
-	char driver[TGT_DNAME_LEN];
+	int typeid;
 	int op;
 	uint32_t set;
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-11-02 18:10:29 UTC (rev 143)
+++ trunk/usr/tgtd.h	2005-11-03 02:37:15 UTC (rev 144)
@@ -12,7 +12,4 @@
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-#define	TGT_TYPE_SYSFSDIR	"/sys/class/tgt_type"
-#define	TGT_TARGET_SYSFSDIR	"/sys/class/tgt_target"
-
 #endif



From tomo at berlios.de  Thu Nov  3 07:30:47 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 3 Nov 2005 07:30:47 +0100
Subject: [Stgt-svn] r145 - trunk/usr
Message-ID: <200511030630.jA36UlN7005123@sheep.berlios.de>

Author: tomo
Date: 2005-11-03 07:30:24 +0100 (Thu, 03 Nov 2005)
New Revision: 145

Modified:
   trunk/usr/dl.c
   trunk/usr/tgtadm.c
Log:
tgtadm loads protocol libraries first, and then operates the rest
options because protocol libraries needs to operates some options.


Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-03 02:37:15 UTC (rev 144)
+++ trunk/usr/dl.c	2005-11-03 06:30:24 UTC (rev 145)
@@ -23,7 +23,6 @@
 
 #include "log.h"
 #include "dl.h"
-#include "tgtd.h"
 #include "tgt_sysfs.h"
 
 struct driver_info {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-11-03 02:37:15 UTC (rev 144)
+++ trunk/usr/tgtadm.c	2005-11-03 06:30:24 UTC (rev 145)
@@ -12,16 +12,16 @@
  */
 
 #include <ctype.h>
+#include <dirent.h>
+#include <dlfcn.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>
+#include <inttypes.h>
+#include <stdio.h>
 #include <stdlib.h>
-#include <stdio.h>
+#include <string.h>
 #include <unistd.h>
-#include <dirent.h>
-#include <string.h>
-#include <dlfcn.h>
-#include <inttypes.h>
 
 #include <sys/socket.h>
 #include <sys/stat.h>
@@ -152,6 +152,36 @@
 	return id;
 }
 
+static int driver_dl_init(int argc, char **argv)
+{
+	int ch, longindex, id;
+	char *name = NULL;
+
+	while ((ch = getopt_long(argc, argv, "n:", long_options,
+				 &longindex)) >= 0) {
+		switch (ch) {
+		case 'n':
+			name = optarg;
+			break;
+		}
+	}
+
+	if (!name) {
+		eprintf("You must specify the driver name\n");
+		goto out;
+	}
+
+	id = driver_to_typeid(name);
+	if (id < 0) {
+		eprintf("Invalid driver name %s\n", name);
+		goto out;
+	}
+
+	return id;
+out:
+	exit(0);
+}
+
 static int ipc_mgmt_connect(void)
 {
 	int fd, err;
@@ -259,15 +289,19 @@
 	int tid = -1, typeid;
 	uint32_t cid = 0, set = 0;
 	uint64_t sid = 0, lun = 0;
-	char *params = NULL, *driver = NULL;
+	char *params = NULL;
 	struct tgtadm_req *req;
 	char sbuf[8192], rbuf[8912];
 
+	typeid = driver_dl_init(argc, argv);
+	if (typeid < 0)
+		goto out;
+
+	optind = 1;
 	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvh",
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'n':
-			driver = optarg;
 			break;
 		case 'o':
 			op = str_to_op(optarg);
@@ -295,7 +329,7 @@
 			set |= SET_USER;
 			break;
 		case 'v':
-/* 			printf("%s version %s\n", program_name, IET_VERSION_STRING); */
+			printf("%s\n", program_name);
 			exit(0);
 			break;
 		case 'h':
@@ -305,23 +339,11 @@
 			usage(-1);
 		}
 	}
-
 	if (op < 0) {
 		eprintf("You must specify the operation type\n");
 		goto out;
 	}
 
-	if (!driver) {
-		eprintf("You must specify the driver name\n");
-		goto out;
-	}
-
-	typeid = driver_to_typeid(driver);
-	if (typeid < 0) {
-		eprintf("Invalid driver name %s\n", driver);
-		goto out;
-	}
-
 	if (optind < argc) {
 		fprintf(stderr, "unrecognized: ");
 		while (optind < argc)



From tomo at berlios.de  Thu Nov  3 07:32:08 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 3 Nov 2005 07:32:08 +0100
Subject: [Stgt-svn] r146 - in trunk: ibmvstgt/kernel istgt/kernel kernel
Message-ID: <200511030632.jA36W8kC005412@sheep.berlios.de>

Author: tomo
Date: 2005-11-03 07:31:56 +0100 (Thu, 03 Nov 2005)
New Revision: 146

Modified:
   trunk/ibmvstgt/kernel/ibmvstgt.c
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
Log:
Add subprotocol entry to struct tgt_target_template.


Modified: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-11-03 06:30:24 UTC (rev 145)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-11-03 06:31:56 UTC (rev 146)
@@ -1160,6 +1160,7 @@
 	.name = TGT_NAME,
 	.module = THIS_MODULE,
 	.protocol = "scsi",
+	.subprotocol = "rdma",
 	.transfer_response = ibmvstgt_cmd_done,
 	.transfer_write_data = recv_cmd_data,
 	.priv_data_size = sizeof(struct server_adapter),

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-03 06:30:24 UTC (rev 145)
+++ trunk/istgt/kernel/iscsi.c	2005-11-03 06:31:56 UTC (rev 146)
@@ -1633,6 +1633,7 @@
 	.name = THIS_NAME,
 	.module = THIS_MODULE,
 	.protocol = "scsi",
+	.subprotocol = "iscsi",
 	.target_create = target_add,
 	.target_destroy = target_del,
 	.msg_recv = iet_msg_recv,

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-11-03 06:30:24 UTC (rev 145)
+++ trunk/kernel/tgt_sysfs.c	2005-11-03 06:31:56 UTC (rev 146)
@@ -65,10 +65,12 @@
 
 tgt_target_template_rd_attr(name, "%s\n");
 tgt_target_template_rd_attr(protocol, "%s\n");
+tgt_target_template_rd_attr(subprotocol, "%s\n");
 
 static struct class_device_attribute *tgt_type_attrs[] = {
 	&class_device_attr_name,
 	&class_device_attr_protocol,
+	&class_device_attr_subprotocol,
 	NULL,
 };
 

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-11-03 06:30:24 UTC (rev 145)
+++ trunk/kernel/tgt_target.h	2005-11-03 06:31:56 UTC (rev 146)
@@ -71,6 +71,11 @@
 	const char *protocol;
 
 	/*
+	 * name of sub-protocol to use
+	 */
+	const char *subprotocol;
+
+	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
 	 */
 	struct class_device_attribute **target_attrs;



From tomo at berlios.de  Fri Nov  4 06:51:55 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 4 Nov 2005 06:51:55 +0100
Subject: [Stgt-svn] r147 - in trunk: istgt/usr usr
Message-ID: <200511040551.jA45ptA0025737@sheep.berlios.de>

Author: tomo
Date: 2005-11-04 06:51:37 +0100 (Fri, 04 Nov 2005)
New Revision: 147

Added:
   trunk/usr/mgmt.c
Modified:
   trunk/istgt/usr/ctldev.c
   trunk/istgt/usr/iscsid.h
   trunk/istgt/usr/target.c
   trunk/usr/Makefile
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/ipc.c
   trunk/usr/log.h
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Add generic user-space management functions (create/destroy_target/device).


Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/istgt/usr/ctldev.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -23,14 +23,18 @@
 #include "iscsid.h"
 #include "tgt_if.h"
 #include "tgtadm.h"
+#include "tgt_sysfs.h"
 
 #ifndef O_LARGEFILE
 #define O_LARGEFILE	0100000
 #endif
 
+extern struct qelem targets_list;
 extern int nl_fd;
 extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
 
+static int typeid;
+
 static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
 {
 	int err;
@@ -348,165 +352,74 @@
 	return err;
 }
 
-static int iscsi_target_create(int *tid)
+static int istgt_ktarget_destroy(int tid)
 {
 	int err;
-	char nlm_ev[8912];
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+	struct target* target;
 
-	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_CREATE,
-		   NLMSG_SPACE(sizeof(*ev)), 0);
+	if (!(target = target_find_by_id(tid)))
+		return -ENOENT;
 
-	ev = NLMSG_DATA(nlh);
-	sprintf(ev->u.c_target.type, "%s", THIS_NAME);
-	ev->u.c_target.nr_cmds = DEFAULT_NR_QUEUED_CMNDS;
+	if (target->nr_sessions)
+		return -EBUSY;
 
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	if (err > 0) {
-		*tid = err;
-		err = 0;
+	if (!list_empty(&target->sessions_list)) {
+		eprintf("bug still have sessions %d\n", tid);
+		exit(-1);
 	}
 
-	return err;
-}
+	err = ktarget_destroy(tid);
+	if (err < 0)
+		return err;
 
-static int iscsi_target_destroy(int tid)
-{
-	int err;
-	char nlm_ev[8912];
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+	remque(&target->tlist);
 
-	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_DESTROY,
-		   NLMSG_SPACE(sizeof(*ev)), 0);
+	free(target);
 
-	ev = NLMSG_DATA(nlh);
-	ev->u.d_target.tid = tid;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-
-	return err;
+	return 0;
 }
 
-static int iscsi_lunit_create(int tid, uint64_t lun, char *args)
+static int istgt_ktarget_create(int typeid, char *name)
 {
-	int err, fd;
-	char *p, *q, *type = NULL, *path = NULL;
-	char dtype[] = "tgt_vsd";
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
+	struct target *target;
+	int err;
 
-	dprintf("%s\n", args);
-
-	if (isspace(*args))
-		args++;
-	if ((p = strchr(args, '\n')))
-		*p = '\0';
-
-	while ((p = strsep(&args, ","))) {
-		if (!p)
-			continue;
-
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-
-		if (!strcmp(p, "Path"))
-			path = q;
-		else if (!strcmp(p, "Type"))
-			type = q;
-	}
-
-	if (!type)
-		type = dtype;
-	if (!path) {
-		eprintf("%d %" PRIu64 "\n", tid, lun);
+	if (!name)
 		return -EINVAL;
-	}
 
-	dprintf("%s %s %Zd\n", type, path, strlen(path));
+	if (!(target = malloc(sizeof(*target))))
+		return -ENOMEM;
 
-	fd = open(path, O_RDWR | O_LARGEFILE);
-	if (fd < 0) {
-		eprintf("Could not open %s errno %d\n", path, errno);
-		return errno;
-	}
+	memset(target, 0, sizeof(*target));
+	memcpy(target->name, name, sizeof(target->name) - 1);
 
-	nlh = calloc(1, NLMSG_SPACE(sizeof(*ev)));
-	if (!nlh) {
-		err = -ENOMEM;
-		goto close_fd;
+	err = ktarget_create(typeid);
+	if (err < 0) {
+		eprintf("can't create a target %d\n", err);
+		goto out;
 	}
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_CREATE,
-		   NLMSG_SPACE(sizeof(*ev)), 0);
 
-	ev = NLMSG_DATA(nlh);
-	ev->u.c_device.tid = tid;
-	ev->u.c_device.dev_id = lun;
-	ev->u.c_device.fd = fd;
-	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
+	INIT_LIST_HEAD(&target->tlist);
+	INIT_LIST_HEAD(&target->sessions_list);
+	target->tid = err;
+	insque(&target->tlist, &targets_list);
 
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-close_fd:
-	if (err) {
-		close(fd);
-		free(nlh);
-	}
 	return err;
-}
-
-static int iscsi_lunit_destroy(int tid, uint64_t lun)
-{
-	int err, fd;
-	char nlm_ev[8912];
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
-	char path[PATH_MAX], buf[PATH_MAX];
-
-	dprintf("%d %" PRIu64 "\n",tid, lun);
-
-	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
-		   NLMSG_SPACE(sizeof(*ev)), 0);
-
-	ev = NLMSG_DATA(nlh);
-	ev->u.d_device.tid = tid;
-	ev->u.d_device.dev_id = lun;
-
-	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/fd",
-		tid, lun);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		perror("iscsi_lunit_destroy could not open fd file");
-		return errno;
-	}
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		perror("iscsi_lunit_destroy could not read fd file");
-		return errno;
-	}
-	sscanf(buf, "%d\n", &fd);
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	close(fd);
+out:
+	free(target);
 	return err;
 }
 
-static int target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+static int istgt_target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
 {
 	int err = -EINVAL, tid = req->tid;
 
 	switch (req->op) {
 	case OP_NEW:
-		err = target_add(&tid, params);
+		err = istgt_ktarget_create(typeid, params);
 		break;
 	case OP_DELETE:
-		err = target_del(tid);
+		err = istgt_ktarget_destroy(tid);
 		break;
 	case OP_UPDATE:
 		err = trgt_mgmt_params(tid, req->sid, params);
@@ -518,24 +431,6 @@
 	return err;
 }
 
-static int device_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL;
-
-	switch (req->op) {
-	case OP_NEW:
-		err = iscsi_lunit_create(req->tid, req->lun, params);
-		break;
-	case OP_DELETE:
-		err = iscsi_lunit_destroy(req->tid, req->lun);
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
 static int user_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
 {
 	return 0;
@@ -551,125 +446,6 @@
 	return 0;
 }
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static void all_devices_destroy(int tid)
-{
-	struct dirent **namelist;
-	char *p;
-	int i, nr;
-	uint32_t lun;
-
-	nr = scandir("/sys/class/tgt_device", &namelist, filter, alphasort);
-	if (!nr)
-		return;
-
-	for (i = 0; i < nr; i++) {
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		eprintf("%d\n", atoi(p));
-		if (tid != atoi(p))
-			continue;
-		p = strchr(p, ':');
-		if (!p)
-			continue;
-		lun = strtoul(++p, NULL, 10);
-		iscsi_lunit_destroy(tid, lun);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-}
-
-static int get_typeid(void)
-{
-	int err = -EINVAL, i, nr, fd, typeid = -EINVAL;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], *p;
-
-	nr = scandir("/sys/class/tgt_type", &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		memset(path, 0, sizeof(path));
-		strncpy(path, "/sys/class/tgt_type/", sizeof(path));
-		strncat(&path[strlen(path)], namelist[i]->d_name, sizeof(path));
-		strncat(&path[strlen(path)], "/name", sizeof(path));
-		eprintf("%s\n", path);
-		fd = open(path, O_RDONLY);
-		if (fd < 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0)
-			continue;
-		eprintf("%s\n", buf);
-		if (!strncmp(buf, THIS_NAME, strlen(THIS_NAME))) {
-			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-				;
-			typeid = atoi(p);
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return typeid;
-}
-
-static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, i, nr, fd, typeid;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], *p;
-
-	if (req->op != OP_DELETE)
-		return err;
-
-	typeid = get_typeid();
-
-	nr = scandir("/sys/class/tgt_target", &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		memset(path, 0, sizeof(path));
-		strncpy(path, "/sys/class/tgt_target/", sizeof(path));
-		strncat(&path[strlen(path)], namelist[i]->d_name, sizeof(path));
-		strncat(&path[strlen(path)], "/typeid", sizeof(path));
-		eprintf("%s\n", path);
-		fd = open(path, O_RDONLY);
-		if (fd < 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0)
-			continue;
-		eprintf("%s\n", buf);
-		if (typeid == atoi(buf)) {
-			int tid;
-
-			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-				;
-			tid = atoi(p);
-			all_devices_destroy(tid);
-			target_del(tid);
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
-}
-
 int ipc_mgmt(char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
@@ -681,21 +457,30 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->set, req->op, req->tid, req->sid, req->lun, params);
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
+		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
 
-	if (req->set & SET_USER)
-		err = user_mgmt(req, params, rbuf, &rlen);
-	else if (req->set & SET_DEVICE)
-		err = device_mgmt(req, params, rbuf, &rlen);
-	else if (req->set & SET_CONNECTION)
-		err = conn_mgmt(req, params, rbuf, &rlen);
-	else if (req->set & SET_SESSION)
+	switch (req->mode) {
+	case MODE_DEVICE:
+	case MODE_SYSTEM:
+		err = tgt_mgmt(sbuf, rbuf);
+		break;
+	case MODE_TARGET:
+		err = istgt_target_mgmt(req, params, rbuf, &rlen);
+		break;
+	case MODE_SESSION:
 		err = session_mgmt(req, params, rbuf, &rlen);
-	else if (req->set & SET_TARGET)
-		err = target_mgmt(req, params, rbuf, &rlen);
-	else if (!req->set)
-		err = system_mgmt(req, params, rbuf, &rlen);
+		break;
+	case MODE_CONNECTION:
+		err = conn_mgmt(req, params, rbuf, &rlen);
+		break;
+	case MODE_USER:
+		err = user_mgmt(req, params, rbuf, &rlen);
+		break;
+	default:
+		eprintf("Unknown mode %d\n", req->mode);
+		break;
+	}
 
 	nlh = (struct nlmsghdr *) rbuf;
 	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
@@ -728,6 +513,61 @@
 	return p;
 }
 
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static int driver_to_typeid(char *name)
+{
+	int i, nr, err, fd, id = -ENOENT;
+	char *p, path[PATH_MAX], buf[PATH_MAX];
+	struct dirent **namelist;
+
+	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
+	for (i = 0; i < nr; i++) {
+		snprintf(path, sizeof(path), TGT_TYPE_SYSFSDIR "/%s/name",
+			 namelist[i]->d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd < 0) {
+			eprintf("%s %d\n", path, errno);
+			continue;
+		}
+
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0) {
+			eprintf("%s %d\n", path, err);
+			continue;
+		}
+
+		if (strncmp(name, buf, strlen(name)))
+			continue;
+
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		id = atoi(p);
+		break;
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return id;
+}
+
+void initial_device_create(int tid, int64_t lun, char *params)
+{
+	char *path, *devtype;
+	char d[] = "tgt_vsd";
+
+	path = devtype = NULL;
+	kdevice_create_parser(params, &path, &devtype);
+	kdevice_create(tid, lun, path, devtype ? : d);
+}
+
 void initial_config_load(void)
 {
 	FILE *config;
@@ -736,8 +576,10 @@
 	int idx, tid;
 	uint32_t val;
 
-	eprintf("%s\n", "load config");
+	typeid = driver_to_typeid(THIS_NAME);
 
+	dprintf("%d\n", typeid);
+
 	if (!(config = fopen(CONFIG_FILE, "r")))
 		return;
 
@@ -751,17 +593,15 @@
 			tid = 0;
 			if (!(p = target_sep_string(&q)))
 				continue;
-			eprintf("creaing target %s\n", p);
-			if (target_add(&tid, p) < 0)
-				tid = -1;
+			dprintf("creaing target %s\n", p);
+			tid = istgt_ktarget_create(typeid, p);
 		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
 			;
 		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
 			/* target->max_sessions = strtol(q, &q, 0); */
 		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
 			uint64_t lun = strtoull(q, &q, 10);
-			eprintf("creaing lun %d %" PRIu64 " %s\n", tid, lun, p);
-			iscsi_lunit_create(tid, lun, q);
+			initial_device_create(tid, lun, q);
 		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
 			val = strtol(q, &q, 0);
 			if (param_check_val(target_keys, idx, &val) < 0)
@@ -783,12 +623,8 @@
 }
 
 struct iscsi_kernel_interface ioctl_ki = {
-	.lunit_create = iscsi_lunit_create,
-	.lunit_destroy = iscsi_lunit_destroy,
 	.param_get = iscsi_param_get,
 	.param_set = iscsi_param_set,
-	.target_create = iscsi_target_create,
-	.target_destroy = iscsi_target_destroy,
 	.session_create = iscsi_session_create,
 	.session_destroy = iscsi_session_destroy,
 	.conn_create = iscsi_conn_create,

Modified: trunk/istgt/usr/iscsid.h
===================================================================
--- trunk/istgt/usr/iscsid.h	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/istgt/usr/iscsid.h	2005-11-04 05:51:37 UTC (rev 147)
@@ -172,21 +172,15 @@
 extern void session_remove(struct session *session);
 
 /* target.c */
-extern int target_add(int *tid, char *name);
-extern int target_del(int tid);
 extern int target_find_by_name(const char *name, int *tid);
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 
 /* ctldev.c */
 struct iscsi_kernel_interface {
-	int (*lunit_create) (int tid, uint64_t lun, char *args);
-	int (*lunit_destroy) (int tid, uint64_t lun);
 	int (*param_get) (int tid, uint64_t sid, struct iscsi_param *);
 	int (*param_set) (int tid, uint64_t sid, int type, uint32_t flags,
 			  struct iscsi_param *);
-	int (*target_create) (int *tid);
-	int (*target_destroy) (int tid);
 	int (*session_create) (int tid, uint64_t sid, uint32_t exp,
 			       uint32_t max);
 	int (*session_destroy) (int tid, uint64_t sid);

Modified: trunk/istgt/usr/target.c
===================================================================
--- trunk/istgt/usr/target.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/istgt/usr/target.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -15,7 +15,7 @@
 #include "iscsid.h"
 #include "tgtadm.h"
 
-static struct qelem targets_list = LIST_HEAD_INIT(targets_list);
+struct qelem targets_list = LIST_HEAD_INIT(targets_list);
 
 void target_list_build(struct connection *conn, char *addr, char *name)
 {
@@ -57,59 +57,3 @@
 
 	return NULL;
 }
-
-int target_del(int tid)
-{
-	int err;
-	struct target* target;
-
-	if (!(target = target_find_by_id(tid)))
-		return -ENOENT;
-
-	if (target->nr_sessions)
-		return -EBUSY;
-
-	if ((err = ki->target_destroy(tid)) < 0)
-		return err;
-
-	remque(&target->tlist);
-
-	if (!list_empty(&target->sessions_list)) {
-		fprintf(stderr, "%s still have sessions %d\n", __FUNCTION__, tid);
-		exit(-1);
-	}
-
-	free(target);
-
-	return 0;
-}
-
-int target_add(int *tid, char *name)
-{
-	struct target *target;
-	int err;
-
-	if (!name)
-		return -EINVAL;
-
-	if (!(target = malloc(sizeof(*target))))
-		return -ENOMEM;
-
-	memset(target, 0, sizeof(*target));
-	memcpy(target->name, name, sizeof(target->name) - 1);
-
-	if ((err = ki->target_create(tid)) < 0) {
-		log_warning("can't create a target %d %u\n", err, *tid);
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&target->tlist);
-	INIT_LIST_HEAD(&target->sessions_list);
-	target->tid = *tid;
-	insque(&target->tlist, &targets_list);
-
-	return 0;
-out:
-	free(target);
-	return err;
-}

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/Makefile	2005-11-04 05:51:37 UTC (rev 147)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o ipc.o dl.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/dl.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -34,6 +34,11 @@
 
 static struct driver_info dinfo[MAX_DL_HANDLES];
 
+char *typeid_to_name(int typeid)
+{
+	return dinfo[typeid].name;
+}
+
 static char *dlname(char *d_name, char *entry)
 {
 	int fd, err;

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/dl.h	2005-11-04 05:51:37 UTC (rev 147)
@@ -13,4 +13,6 @@
 extern void *dl_event_fn(int tid, int typeid);
 extern void *dl_proto_cmd_process(int tid, int typeid);
 
+extern char *typeid_to_name(int typeid);
+
 #endif

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/ipc.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -102,22 +102,19 @@
 	dprintf("%d %d %d\n", req->typeid, err, nlh->nlmsg_len);
 
 	fn = dl_ipc_fn(req->typeid);
-	if (!fn) {
-		eprintf("Cannot handle event %d\n", req->typeid);
-		err = -EINVAL;
-		goto fail;
-	}
-	err = fn((char *) nlh, rbuf);
+	if (fn)
+		err = fn((char *) nlh, rbuf);
+	else
+		err = tgt_mgmt((char *) nlh, rbuf);
 
 send:
 	err = write(fd, nlh, nlh->nlmsg_len);
+	if (err < 0)
+		eprintf("%d\n", err);
 
 	if (fd > 0)
 		close(fd);
 
-	if (err < 0)
-		eprintf("%d\n", err);
-
 	return;
 fail:
 	nlh = (struct nlmsghdr *) rbuf;

Modified: trunk/usr/log.h
===================================================================
--- trunk/usr/log.h	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/log.h	2005-11-04 05:51:37 UTC (rev 147)
@@ -73,12 +73,12 @@
 
 #define eprintf(fmt, args...)						\
 do {									\
-	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
 #define dprintf(fmt, args...)						\
 do {									\
-	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
 #endif	/* LOG_H */

Added: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/mgmt.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -0,0 +1,362 @@
+/*
+ * Generic management functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <ctype.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <linux/netlink.h>
+
+#include <tgt_if.h>
+#include "tgtd.h"
+#include "dl.h"
+#include "log.h"
+#include "tgtadm.h"
+#include "tgt_sysfs.h"
+
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0100000
+#endif
+
+static void nlmsg_init(struct nlmsghdr *nlh, uint32_t seq,
+		       uint16_t type, uint32_t len, uint16_t flags)
+{
+	nlh->nlmsg_pid = getpid();
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_seq = seq;
+}
+
+typedef void (init_tgt_event_t) (struct tgt_event *ev, struct tgtadm_req *req);
+
+int tgt_event_execute(struct tgtadm_req *req, int event, init_tgt_event_t *func)
+{
+	int err;
+	struct tgt_event *ev;
+	struct nlmsghdr *nlh;
+	char nlm_sev[NLMSG_SPACE(sizeof(struct tgt_event))];
+	char nlm_rev[NLMSG_SPACE(sizeof(struct tgt_event))];
+
+	memset(nlm_sev, 0, sizeof(nlm_sev));
+	memset(nlm_rev, 0, sizeof(nlm_rev));
+
+	nlh = (struct nlmsghdr *) nlm_sev;
+
+	nlmsg_init(nlh, 0, event, NLMSG_SPACE(sizeof(*ev)), 0);
+	ev = NLMSG_DATA(nlh);
+	func(ev, req);
+
+	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, (char *) nlh,
+			  nlh->nlmsg_len, nlm_rev);
+	if (err < 0)
+		eprintf("%d\n", err);
+	else
+		err = ((struct tgt_event *) NLMSG_DATA(nlm_rev))->k.event_res.err;
+
+	return err;
+}
+
+static void __ktarget_create(struct tgt_event *ev, struct tgtadm_req *req)
+{
+	sprintf(ev->u.c_target.type, "%s", typeid_to_name(req->typeid));
+}
+
+int ktarget_create(int typeid)
+{
+	struct tgtadm_req req;
+	req.typeid = typeid;
+
+	return tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
+				 __ktarget_create);
+}
+
+static void __ktarget_destroy(struct tgt_event *ev, struct tgtadm_req *req)
+{
+	ev->u.d_target.tid = req->tid;
+}
+
+int ktarget_destroy(int tid)
+{
+	struct tgtadm_req req;
+	req.tid = tid;
+
+	return tgt_event_execute(&req, TGT_UEVENT_TARGET_DESTROY,
+				 __ktarget_destroy);
+}
+
+struct kdevice_create_info {
+	int fd;
+	char devtype[256];
+};
+
+static void __kdevice_create(struct tgt_event *ev, struct tgtadm_req *req)
+{
+	struct kdevice_create_info *info =
+		(struct kdevice_create_info *) ((char *) req + sizeof(*req));
+
+	ev->u.c_device.tid = req->tid;
+	ev->u.c_device.dev_id = req->lun;
+	ev->u.c_device.fd = info->fd;
+	strncpy(ev->u.c_device.type, info->devtype,
+		sizeof(ev->u.c_device.type));
+}
+
+void kdevice_create_parser(char *args, char **path, char **devtype)
+{
+	char *p, *q;
+
+	if (isspace(*args))
+		args++;
+	if ((p = strchr(args, '\n')))
+		*p = '\0';
+
+	while ((p = strsep(&args, ","))) {
+		if (!p)
+			continue;
+
+		if (!(q = strchr(p, '=')))
+			continue;
+		*q++ = '\0';
+
+		if (!strcmp(p, "Path"))
+			*path = q;
+		else if (!strcmp(p, "Type"))
+			*devtype = q;
+	}
+}
+
+int kdevice_create(int tid, uint64_t devid, char *path, char *devtype)
+{
+	int fd;
+	char buf[sizeof(struct tgtadm_req) + sizeof(struct kdevice_create_info)];
+	struct tgtadm_req *req;
+	struct kdevice_create_info *info;
+
+	dprintf("%d %" PRIu64 " %s %s\n", tid, devid, path, devtype);
+
+	req = (struct tgtadm_req *) buf;
+	info = (struct kdevice_create_info *) (buf + sizeof(*req));
+
+	req->tid = tid;
+	req->lun = devid;
+
+	fd = open(path, O_RDWR | O_LARGEFILE);
+	if (fd < 0) {
+		eprintf("Could not open %s errno %d\n", path, errno);
+		return -errno;
+	}
+	info->fd = fd;
+	strncpy(info->devtype, devtype, sizeof(info->devtype));
+
+	return tgt_event_execute(req, TGT_UEVENT_DEVICE_CREATE,
+				 __kdevice_create);
+}
+
+static void __kdevice_destroy(struct tgt_event *ev, struct tgtadm_req *req)
+{
+	ev->u.d_device.tid = req->tid;
+	ev->u.d_device.dev_id = req->lun;
+}
+
+int kdevice_destroy(int tid, uint64_t devid)
+{
+	int fd, err;
+	struct tgtadm_req req;
+	char path[PATH_MAX], buf[PATH_MAX];
+
+	req.tid = tid;
+	req.lun = devid;
+
+	dprintf("%u %" PRIu64 "\n", tid, devid);
+
+	snprintf(path, sizeof(path),
+		 TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd", tid, devid);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		eprintf("%s %d\n", path, errno);
+		return -errno;
+	}
+
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		return err;
+	}
+	sscanf(buf, "%d\n", &fd);
+
+	err = tgt_event_execute(&req, TGT_UEVENT_DEVICE_DESTROY,
+				__kdevice_destroy);
+	if (!err)
+		close(fd);
+
+	return err;
+}
+
+static int target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL;
+
+	switch (req->op) {
+	case OP_NEW:
+		err = ktarget_create(req->typeid);
+		break;
+	case OP_DELETE:
+		err = ktarget_destroy(req->tid);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int device_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL;
+	char *path, *devtype;
+
+	switch (req->op) {
+	case OP_NEW:
+		path = devtype = NULL;
+		kdevice_create_parser(params, &path, &devtype);
+		if (!path || !devtype)
+			eprintf("Invalid path or device type\n");
+		else
+			err = kdevice_create(req->tid, req->lun, path,devtype);
+		break;
+	case OP_DELETE:
+		err = kdevice_destroy(req->tid, req->lun);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static void all_devices_destroy(int tid)
+{
+	struct dirent **namelist;
+	char *p;
+	int i, nr;
+	uint64_t devid;
+
+	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return;
+
+	for (i = 0; i < nr; i++) {
+
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		if (tid != atoi(p))
+			continue;
+		p = strchr(p, ':');
+		if (!p)
+			continue;
+		devid = strtoull(++p, NULL, 10);
+		kdevice_destroy(tid, devid);
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+}
+
+static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL, i, nr, fd;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], *p;
+
+	if (req->op != OP_DELETE)
+		return err;
+
+	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
+			 namelist[i]->d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd < 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0)
+			continue;
+
+		if (req->typeid == atoi(buf)) {
+			int tid;
+
+			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+				;
+			tid = atoi(p);
+			all_devices_destroy(tid);
+			ktarget_destroy(tid);
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return 0;
+}
+
+int tgt_mgmt(char *sbuf, char *rbuf)
+{
+	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
+	struct tgtadm_req *req;
+	struct tgtadm_res *res;
+	int err = -EINVAL, rlen = 0;
+	char *params;
+
+	req = NLMSG_DATA(nlh);
+	params = (char *) req + sizeof(*req);
+
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
+		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
+
+	switch (req->mode) {
+	case MODE_SYSTEM:
+		err = system_mgmt(req, params, rbuf, &rlen);
+		break;
+	case MODE_TARGET:
+		err = target_mgmt(req, params, rbuf, &rlen);
+		break;
+	case MODE_DEVICE:
+		err = device_mgmt(req, params, rbuf, &rlen);
+		break;
+	default:
+		break;
+	}
+
+	nlh = (struct nlmsghdr *) rbuf;
+	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
+	res = NLMSG_DATA(nlh);
+	res->err = err;
+
+	return err;
+}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/tgtadm.c	2005-11-04 05:51:37 UTC (rev 147)
@@ -32,8 +32,8 @@
 #include "tgtadm.h"
 #include "tgt_sysfs.h"
 
-#define eprintf(fmt, args...)					\
-do {								\
+#define eprintf(fmt, args...)						\
+do {									\
 	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
@@ -264,6 +264,24 @@
 	return err;
 }
 
+static int set_to_mode(uint32_t set)
+{
+	int mode = MODE_SYSTEM;
+
+	if (set & (1 << MODE_USER))
+		mode = MODE_USER;
+	else if (set & (1 << MODE_DEVICE))
+		mode = MODE_DEVICE;
+	else if (set & (1 << MODE_CONNECTION))
+		mode = MODE_CONNECTION;
+	else if (set & (1 << MODE_SESSION))
+		mode = MODE_SESSION;
+	else if (set & (1 << MODE_TARGET))
+		mode = MODE_TARGET;
+
+	return mode;
+}
+
 static int str_to_op(char *str)
 {
 	int op;
@@ -308,25 +326,25 @@
 			break;
 		case 't':
 			tid = strtol(optarg, NULL, 10);
-			set |= SET_TARGET;
+			set |= (1 << MODE_TARGET);
 			break;
 		case 's':
 			sid = strtoull(optarg, NULL, 10);
-			set |= SET_SESSION;
+			set |= (1 << MODE_SESSION);
 			break;
 		case 'c':
 			cid = strtoul(optarg, NULL, 10);
-			set |= SET_CONNECTION;
+			set |= (1 << MODE_CONNECTION);
 			break;
 		case 'l':
 			lun = strtoull(optarg, NULL, 10);
-			set |= SET_DEVICE;
+			set |= (1 << MODE_DEVICE);
 			break;
 		case 'p':
 			params = optarg;
 			break;
 		case 'u':
-			set |= SET_USER;
+			set |= (1 << MODE_USER);
 			break;
 		case 'v':
 			printf("%s\n", program_name);
@@ -357,8 +375,8 @@
 
 	req = (struct tgtadm_req *) sbuf;
 	req->typeid = typeid;
+	req->mode = set_to_mode(set);
 	req->op = op;
-	req->set = set;
 	req->tid = tid;
 	req->sid = sid;
 	req->lun = lun;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2005-11-03 06:31:56 UTC (rev 146)
+++ trunk/usr/tgtadm.h	2005-11-04 05:51:37 UTC (rev 147)
@@ -3,12 +3,6 @@
 
 #define TGT_IPC_NAMESPACE "TGT_IPC_ABSTRACT_NAMESPACE"
 
-#define	SET_TARGET	(1 << 0)
-#define	SET_SESSION	(1 << 1)
-#define	SET_CONNECTION	(1 << 2)
-#define	SET_DEVICE	(1 << 3)
-#define	SET_USER	(1 << 4)
-
 enum tgtadm_op {
 	OP_NEW,
 	OP_DELETE,
@@ -16,11 +10,22 @@
 	OP_SHOW,
 };
 
+enum tgtadm_mode {
+	MODE_SYSTEM,
+	MODE_TARGET,
+	MODE_DEVICE,
+
+	MODE_SESSION,
+	MODE_CONNECTION,
+	MODE_USER,
+};
+
 struct tgtadm_req {
 	int typeid;
-	int op;
-	uint32_t set;
 
+	enum tgtadm_mode mode;
+	enum tgtadm_op op;
+
 	int tid;
 	uint64_t sid;
 	int cid;
@@ -31,4 +36,11 @@
 	int err;
 };
 
+extern int tgt_mgmt(char *sbuf, char *rbuf);
+extern int ktarget_destroy(int tid);
+extern int ktarget_create(int typeid);
+extern int kdevice_destroy(int tid, uint64_t devid);
+extern int kdevice_create(int tid, uint64_t devid, char *path, char *devtype);
+extern void kdevice_create_parser(char *args, char **path, char **devtype);
+
 #endif



From tomo at berlios.de  Fri Nov  4 13:07:19 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 4 Nov 2005 13:07:19 +0100
Subject: [Stgt-svn] r148 - trunk/istgt/usr
Message-ID: <200511041207.jA4C7JPt012527@sheep.berlios.de>

Author: tomo
Date: 2005-11-04 13:07:15 +0100 (Fri, 04 Nov 2005)
New Revision: 148

Modified:
   trunk/istgt/usr/ctldev.c
Log:
Minor cleanups.

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-11-04 05:51:37 UTC (rev 147)
+++ trunk/istgt/usr/ctldev.c	2005-11-04 12:07:15 UTC (rev 148)
@@ -21,18 +21,12 @@
 #include <linux/netlink.h>
 
 #include "iscsid.h"
+#include "tgtd.h"
 #include "tgt_if.h"
 #include "tgtadm.h"
 #include "tgt_sysfs.h"
 
-#ifndef O_LARGEFILE
-#define O_LARGEFILE	0100000
-#endif
-
 extern struct qelem targets_list;
-extern int nl_fd;
-extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
-
 static int typeid;
 
 static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)



From tomo at berlios.de  Fri Nov  4 15:45:03 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 4 Nov 2005 15:45:03 +0100
Subject: [Stgt-svn] r149 - trunk
Message-ID: <200511041445.jA4Ej3qO008283@sheep.berlios.de>

Author: tomo
Date: 2005-11-04 15:45:03 +0100 (Fri, 04 Nov 2005)
New Revision: 149

Modified:
   trunk/initd
Log:
Add simple tricks to the initd script to support two drivers.

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-11-04 12:07:15 UTC (rev 148)
+++ trunk/initd	2005-11-04 14:45:03 UTC (rev 149)
@@ -7,6 +7,10 @@
 MEM_SIZE=1048576
 export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${LD_LIBRARY_PATH}
 
+if [ -f ${PWD}/istgt/kernel/istgt.ko ] ; then
+	TARGET=istgt
+fi
+
 start_server()
 {
 	insmod ${PWD}/kernel/tgt_core.ko
@@ -14,18 +18,31 @@
 	insmod ${PWD}/kernel/tgt_vsd.ko
 #	insmod ${PWD}/kernel/tgt_sd.ko
 
-	modprobe -q crc32c
-	insmod ${PWD}/istgt/kernel/istgt.ko
+	if [ $TARGET = "istgt" ] ; then
+		modprobe -q crc32c
+		insmod ${PWD}/istgt/kernel/istgt.ko
+	else
+		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
+	fi
 
 	${PWD}/usr/tgtd
 }
 	
 stop_server()
 {
-	${PWD}/usr/tgtadm --driver istgt --op delete
+	if [ $TARGET = "istgt" ] ; then
+		${PWD}/usr/tgtadm --driver istgt --op delete
+	else
+		${PWD}/usr/tgtadm --driver istgt --op delete
+	fi
+
 	killall -9 tgtd
 
-	rmmod istgt
+	if [ $TARGET = "istgt" ] ; then
+		rmmod istgt
+	else
+		rmmod ibmvstgt
+	fi
 
 #	rmmod tgt_sd
 	rmmod tgt_vsd



From tomo at berlios.de  Fri Nov  4 15:49:45 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 4 Nov 2005 15:49:45 +0100
Subject: [Stgt-svn] r150 - in trunk: istgt/usr usr
Message-ID: <200511041449.jA4Enjpp008643@sheep.berlios.de>

Author: tomo
Date: 2005-11-04 15:49:44 +0100 (Fri, 04 Nov 2005)
New Revision: 150

Modified:
   trunk/istgt/usr/ctldev.c
   trunk/usr/mgmt.c
   trunk/usr/netlink.c
   trunk/usr/tgtd.h
Log:
Change nl_cmd_call() interface to prevent the access of invalid memory
address.


Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-11-04 14:45:03 UTC (rev 149)
+++ trunk/istgt/usr/ctldev.c	2005-11-04 14:49:44 UTC (rev 150)
@@ -38,7 +38,7 @@
 	struct iet_msg *msg;
 
 	err = nl_cmd_call(nl_fd, nlm_send->nlmsg_type,
-			  (char *) nlm_send, len, rbuf);
+			  (char *) nlm_send, len, rbuf, sizeof(rbuf));
 
 	nlm_recv = (struct nlmsghdr *) rbuf;
 	ev = NLMSG_DATA(nlm_recv);

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2005-11-04 14:45:03 UTC (rev 149)
+++ trunk/usr/mgmt.c	2005-11-04 14:49:44 UTC (rev 150)
@@ -60,7 +60,7 @@
 	func(ev, req);
 
 	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, (char *) nlh,
-			  nlh->nlmsg_len, nlm_rev);
+			  nlh->nlmsg_len, nlm_rev, sizeof(nlm_rev));
 	if (err < 0)
 		eprintf("%d\n", err);
 	else

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-04 14:45:03 UTC (rev 149)
+++ trunk/usr/netlink.c	2005-11-04 14:49:44 UTC (rev 150)
@@ -178,12 +178,12 @@
 	}
 }
 
-int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf)
+int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen)
 {
 	int err;
 	struct nlmsghdr *nlh;
 
-	err = __nl_write(fd, type, data, size);
+	err = __nl_write(fd, type, sbuf, slen);
 	if (err < 0)
 		return err;
 
@@ -191,7 +191,12 @@
 
 	if (rbuf) {
 		nlh = (struct nlmsghdr *) recvbuf;
-		memcpy(rbuf, nlh, nlh->nlmsg_len);
+		if (rlen < nlh->nlmsg_len)
+			eprintf("Too small rbuf %d %d\n", rlen, nlh->nlmsg_len);
+		else
+			rlen = nlh->nlmsg_len;
+
+		memcpy(rbuf, nlh, rlen);
 	}
 
 	return err;
@@ -204,7 +209,7 @@
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
 	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
-			  NLMSG_SPACE(sizeof(struct tgt_event)), NULL);
+			  NLMSG_SPACE(sizeof(struct tgt_event)), NULL, 0);
 
 	ev = (struct tgt_event *) NLMSG_DATA(nlmsg);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-11-04 14:45:03 UTC (rev 149)
+++ trunk/usr/tgtd.h	2005-11-04 14:49:44 UTC (rev 150)
@@ -7,7 +7,7 @@
 
 extern int nl_open(void);
 extern void nl_event_handle(int fd);
-extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
+extern int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);



From tomo at berlios.de  Fri Nov  4 23:52:58 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 4 Nov 2005 23:52:58 +0100
Subject: [Stgt-svn] r151 - trunk
Message-ID: <200511042252.jA4MqwD4027461@sheep.berlios.de>

Author: tomo
Date: 2005-11-04 23:52:58 +0100 (Fri, 04 Nov 2005)
New Revision: 151

Modified:
   trunk/initd
Log:
Fix the initd script again.

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-11-04 14:49:44 UTC (rev 150)
+++ trunk/initd	2005-11-04 22:52:58 UTC (rev 151)
@@ -33,7 +33,7 @@
 	if [ $TARGET = "istgt" ] ; then
 		${PWD}/usr/tgtadm --driver istgt --op delete
 	else
-		${PWD}/usr/tgtadm --driver istgt --op delete
+		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
 	fi
 
 	killall -9 tgtd



From tomo at berlios.de  Sat Nov  5 00:04:49 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 00:04:49 +0100
Subject: [Stgt-svn] r152 - trunk/usr
Message-ID: <200511042304.jA4N4nXn028408@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 00:04:49 +0100 (Sat, 05 Nov 2005)
New Revision: 152

Modified:
   trunk/usr/dl.c
Log:
Fix dl_init() for a driver that doesn't have a driver-specific library.


Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-11-04 22:52:58 UTC (rev 151)
+++ trunk/usr/dl.c	2005-11-04 23:04:49 UTC (rev 152)
@@ -84,35 +84,29 @@
 			;
 		idx = atoi(p);
 		if (idx > MAX_DL_HANDLES) {
-			eprintf("Cannot load %s %d\n",
+			eprintf("Too large dl idx %s %d\n",
 				namelist[i]->d_name, idx);
 			continue;
 		}
+		di = &dinfo[idx];
 
-		p = dlname(namelist[i]->d_name, "name");
-		if (!p)
+		di->name = dlname(namelist[i]->d_name, "name");
+		if (!di->name)
 			continue;
 
-		di = &dinfo[idx];
-
-		di->name = p;
-		snprintf(path, sizeof(path), "%s.so", p);
+		snprintf(path, sizeof(path), "%s.so", di->name);
 		di->dl = dlopen(path, RTLD_LAZY);
-		if (!di->dl) {
+		if (!di->dl)
 			eprintf("%s %s\n", path, dlerror());
-			continue;
-		}
 
-		p = dlname(namelist[i]->d_name, "protocol");
-		if (!p)
+		di->proto = dlname(namelist[i]->d_name, "protocol");
+		if (!di->proto)
 			continue;
-		di->proto = p;
-		snprintf(path, sizeof(path), "%s.so", p);
+
+		snprintf(path, sizeof(path), "%s.so", di->proto);
 		di->pdl = dlopen(path, RTLD_LAZY);
-		if (!di->pdl) {
+		if (!di->pdl)
 			eprintf("%s %s\n", path, dlerror());
-			continue;
-		}
 	}
 
 	for (i = 0; i < nr; i++)



From tomo at berlios.de  Sat Nov  5 01:00:43 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 01:00:43 +0100
Subject: [Stgt-svn] r153 - trunk
Message-ID: <200511050000.jA500hml020356@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 01:00:20 +0100 (Sat, 05 Nov 2005)
New Revision: 153

Added:
   trunk/README
Log:
Add simple README file.

Added: trunk/README
===================================================================
--- trunk/README	2005-11-04 23:04:49 UTC (rev 152)
+++ trunk/README	2005-11-05 00:00:20 UTC (rev 153)
@@ -0,0 +1,92 @@
+Introduction
+-------------
+Note that linux target framework software (tgt) is under active
+development. Don't play with important data.
+
+Currently, tgt supports two SCSI targets, iSCSI software target
+(istgt) and IBM virtual SCSI target (ibmvstgt).
+
+
+Starting
+-------------
+The software consists of kernel modules and user-space tools (daemon,
+management tool, dynamic libraries). The compilation of the kernel
+modules require the path to above kernel sources:
+
+host:~/tgt$ make KERNELSRC=<kernel-src>
+
+Make sure that everything is built successfully. Now you can start tgt
+by type the followings.
+
+host:~/tgt$ su
+host:~/tgt# ./initd start
+
+You need to be in the tgt source code directory to execute the script
+correctly.
+
+You can see /sys/class/tgt_type directory to make sure kernel modules
+loaded.
+
+host:~/tgt# cat /sys/class/tgt_type/driver1/name
+istgt
+host:~/tgt# cat /sys/class/tgt_type/driver1/protocol
+scsi
+
+The number in the directory path is driver id. The istgt driver id is
+1 in the above example.
+
+By defaults, tgt generates logs of debug messages. Please see
+/var/log/kern.log and /var/log/daemon.log (your Linux distributions
+may use the different log file names).
+
+
+Configuration
+-------------
+Everyting is configured via the tgtadm management tool. Currenlty, tgt
+does not support persistent configurations. The tgtadm alayws requires
+you to specify the driver name like the following examples.
+
+host:~/tgt# ./usr/tgtadm --driver istgt --help
+host:~/tgt# ./usr/tgtadm --driver ibmvstgt --help
+
+First, you need to create a target.
+
+host:~/tgt# ./usr/tgtadm --driver istgt --op new --tid 0 \
+--params Name=iqn.2001-04.com.example:storage.disk1.sys1.xyz
+
+If you use ibmvstgt, you don't need to create a target because they
+are created automatically. A target is created per virtual bus.
+
+You can see /sys/class/tgt_target directory to make sure the target is
+ready.
+
+host:~/tgt# cat /sys/class/tgt_target/target0/typeid
+1
+
+This number is the driver id. That is, this target (tid 0) belongs to
+the driver id 1.
+
+The number in the directory path is target id (tid). tid is 0 in the
+above example.
+
+Then, you need to add a device to the target (tid 0).
+
+host:~/tgt# ./usr/tgtadm --driver istgt --op new --tid 0 --lun 0 \
+--params Path=/dev/sdb1,Type=tgt_vsd
+
+You can see /sys/class/tgt_device directory to make sure the device
+was added successfully.
+
+host:~/tgt# cat /sys/class/tgt_device/device0\:0/size
+9006649344
+
+Note that every target must need a device whose lun is zero. Now the
+target is ready for accepting accesses from initiators.
+
+
+Stopping
+-------------
+Simply execute:
+
+host:~/tgt# ./initd stop
+



From mnc at berlios.de  Sat Nov  5 04:08:18 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 5 Nov 2005 04:08:18 +0100
Subject: [Stgt-svn] r154 - trunk/kernel
Message-ID: <200511050308.jA538Ipj007227@sheep.berlios.de>

Author: mnc
Date: 2005-11-05 04:08:11 +0100 (Sat, 05 Nov 2005)
New Revision: 154

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_vsd.c
Log:
rename some of the queueing functions to execute and complete to express that they are not necessarily queueing anything and are really only being asked to run some command  - they may queue the command to a real queue, drop the command, run a FS operation, etc

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt.c	2005-11-05 03:08:11 UTC (rev 154)
@@ -542,8 +542,8 @@
 	struct tgt_target *target = cmd->session->target;
 	int err;
 
-	if (target->proto->dequeue_cmd)
-		target->proto->dequeue_cmd(cmd);
+	if (target->proto->complete_cmd)
+		target->proto->complete_cmd(cmd);
 
 	cmd->done = tgt_cmd_destroy;
 	err = target->tt->transfer_response(cmd);
@@ -577,7 +577,7 @@
 	if (device)
 		dprintk("found %" PRIu64 "\n", cmd->dev_id);
 
-	err = target->proto->queue_cmd(cmd);
+	err = target->proto->execute_cmd(cmd);
 
 	switch (err) {
 	case TGT_CMD_FAILED:

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt_device.h	2005-11-05 03:08:11 UTC (rev 154)
@@ -40,7 +40,7 @@
 	 * If returning TGT_CMD_COMPLETED or TGT_CMD_FAILED the result
 	 * field must be set.
 	 */
-	int (* queue_cmd)(struct tgt_cmd *cmd);
+	int (* execute_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a userspace command
 	 */

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt_protocol.h	2005-11-05 03:08:11 UTC (rev 154)
@@ -42,8 +42,8 @@
 				       uint8_t *dev_id_buff, int id_buff_size,
 				       int flags);
 
-	int (* queue_cmd) (struct tgt_cmd *cmd);
-	void (* dequeue_cmd) (struct tgt_cmd *cmd);
+	int (* execute_cmd) (struct tgt_cmd *cmd);
+	void (* complete_cmd) (struct tgt_cmd *cmd);
 	/*
 	 * Build userspace packet
 	 */

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt_scsi.c	2005-11-05 03:08:11 UTC (rev 154)
@@ -200,10 +200,10 @@
 static void device_queue_cmd(void *data)
 {
 	struct tgt_cmd *cmd = data;
-	cmd->device->dt->queue_cmd(cmd);
+	cmd->device->dt->execute_cmd(cmd);
 }
 
-static void scsi_tgt_dequeue_pending_cmd(struct tgt_device *device)
+static void scsi_tgt_execute_pending_cmds(struct tgt_device *device)
 {
 	struct scsi_tgt_device *stdev = device->pt_data;
 	struct tgt_cmd *cmd, *tmp;
@@ -228,7 +228,7 @@
 	}
 }
 
-static void scsi_tgt_dequeue_cmd(struct tgt_cmd *cmd)
+static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	struct tgt_device *device = cmd->device;
@@ -253,12 +253,12 @@
 	}
 
 	if (!list_empty(&stdev->pending_cmds))
-		scsi_tgt_dequeue_pending_cmd(device);
+		scsi_tgt_execute_pending_cmds(device);
 
 	spin_unlock_irqrestore(&stdev->lock, flags);
 }
 
-static int scsi_tgt_queue_cmd(struct tgt_cmd *cmd)
+static int scsi_tgt_execute_cmd(struct tgt_cmd *cmd)
 {
 	struct tgt_device *device = cmd->device;
 	struct scsi_tgt_device *stdev = device->pt_data;
@@ -281,7 +281,7 @@
 	spin_unlock_irqrestore(&stdev->lock, flags);
 
 	if (enabled)
-		err = device->dt->queue_cmd(cmd);
+		err = device->dt->execute_cmd(cmd);
 	else
 		err = TGT_CMD_KERN_QUEUED;
 
@@ -316,8 +316,8 @@
 	.module = THIS_MODULE,
 	.create_cmd = scsi_tgt_create_cmd,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
-	.queue_cmd = scsi_tgt_queue_cmd,
-	.dequeue_cmd = scsi_tgt_dequeue_cmd,
+	.execute_cmd = scsi_tgt_execute_cmd,
+	.complete_cmd = scsi_tgt_complete_cmd,
 	.attach_device = scsi_tgt_attach_device,
 	.detach_device = scsi_tgt_detach_device,
 	.priv_dev_data_size = sizeof(struct scsi_tgt_device),

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt_sd.c	2005-11-05 03:08:11 UTC (rev 154)
@@ -192,7 +192,7 @@
 /*
  * TODO part of this will move to a io_handler callout
  */
-static int tgt_sd_queue_rq(struct tgt_cmd *cmd)
+static int tgt_sd_execute_rq(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	struct file *file = cmd->device->file;
@@ -226,7 +226,7 @@
 	return -ENOMEM;
 }
 
-static int tgt_sd_queue(struct tgt_cmd *cmd)
+static int tgt_sd_execute(struct tgt_cmd *cmd)
 {
 	struct tgt_device *device = cmd->device;
 	loff_t pos = cmd->offset;
@@ -239,14 +239,14 @@
 	 * TODO this will become device->io_handler->queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	return tgt_sd_queue_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
+	return tgt_sd_execute_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
 }
 
 static struct tgt_device_template tgt_sd = {
 	.name = "tgt_sd",
 	.module = THIS_MODULE,
 	.create = tgt_sd_create,
-	.queue_cmd = tgt_sd_queue,
+	.execute_cmd = tgt_sd_execute,
 	.prep_cmd = tgt_sd_prep,
 };
 

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-11-05 00:00:20 UTC (rev 153)
+++ trunk/kernel/tgt_vsd.c	2005-11-05 03:08:11 UTC (rev 154)
@@ -107,7 +107,7 @@
 /*
  * TODO this will move to a io_handler callout
  */
-static int vsd_queue_file_io(struct tgt_cmd *cmd, int op)
+static int vsd_execute_file_io(struct tgt_cmd *cmd, int op)
 {
 	struct file *file = cmd->device->file;
 	ssize_t ret;
@@ -136,7 +136,7 @@
 	return 0;
 }
 
-static int tgt_vsd_queue(struct tgt_cmd *cmd)
+static int tgt_vsd_execute(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	int err, rw;
@@ -168,7 +168,7 @@
 	 * TODO this will become device->io_handler->queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	err = vsd_queue_file_io(cmd, rw);
+	err = vsd_execute_file_io(cmd, rw);
 	if (!err) {
 		cmd->result = SAM_STAT_GOOD;
 		return TGT_CMD_COMPLETED;
@@ -187,7 +187,7 @@
 	.name = "tgt_vsd",
 	.module = THIS_MODULE,
 	.create = tgt_vsd_create,
-	.queue_cmd = tgt_vsd_queue,
+	.execute_cmd = tgt_vsd_execute,
 	.prep_cmd = tgt_vsd_prep,
 	.complete_uspace_cmd = tgt_vsd_uspace_complete,
 };



From tomo at berlios.de  Sat Nov  5 10:04:08 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 10:04:08 +0100
Subject: [Stgt-svn] r155 - trunk/istgt/kernel
Message-ID: <200511050904.jA5948fP003401@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 10:04:04 +0100 (Sat, 05 Nov 2005)
New Revision: 155

Removed:
   trunk/istgt/kernel/target.c
Modified:
   trunk/istgt/kernel/Makefile
   trunk/istgt/kernel/config.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
Log:
Killed target_list_sem semaphore because tgt serializes target
creating and destroying. Removed target.c because it is pretty small
now (Merged it with iscsi.c).


Modified: trunk/istgt/kernel/Makefile
===================================================================
--- trunk/istgt/kernel/Makefile	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/Makefile	2005-11-05 09:04:04 UTC (rev 155)
@@ -12,7 +12,7 @@
 ifneq ($(KERNELRELEASE),)
 obj-m		+= istgt.o
 istgt-objs	:= iscsi.o nthread.o config.o digest.o\
-			conn.o session.o target.o param.o
+			conn.o session.o param.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/istgt/kernel/config.c
===================================================================
--- trunk/istgt/kernel/config.c	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/config.c	2005-11-05 09:04:04 UTC (rev 155)
@@ -34,7 +34,7 @@
 	struct iet_msg *msg = data;
 	int err;
 
-	err = target_lock(target, 1);
+	err = down_interruptible(&target->target_sem);
 	if (err < 0) {
 		eprintk("interrupted %u %d\n", err, msg->msg_type);
 		goto done;
@@ -70,7 +70,7 @@
 		err = -EINVAL;
 	}
 
-	target_unlock(target);
+	up(&target->target_sem);
 done:
 	msg->result = err;
 	tgt_msg_send(tgt, msg, sizeof(*msg), GFP_KERNEL);

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 09:04:04 UTC (rev 155)
@@ -13,9 +13,7 @@
 
 #include <iscsi.h>
 
-unsigned long debug_enable_flags;
-
-static kmem_cache_t *iscsi_cmnd_cache;
+static kmem_cache_t *istgt_cmd_cache;
 static char dummy_data[1024];
 
 static uint32_t cmnd_write_size(struct iscsi_cmnd *cmnd)
@@ -58,7 +56,7 @@
 	struct iscsi_cmnd *cmnd;
 
 	/* TODO: async interface is necessary ? */
-	cmnd = kmem_cache_alloc(iscsi_cmnd_cache, GFP_KERNEL | __GFP_NOFAIL);
+	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
 
 	memset(cmnd, 0, sizeof(*cmnd));
 	INIT_LIST_HEAD(&cmnd->list);
@@ -366,7 +364,7 @@
 
 	if (cmnd->tc)
 		cmnd->tc->done(cmnd->tc);
-	kmem_cache_free(iscsi_cmnd_cache, cmnd);
+	kmem_cache_free(istgt_cmd_cache, cmnd);
 }
 
 static void cmnd_skip_pdu(struct iscsi_cmnd *cmnd)
@@ -1629,53 +1627,113 @@
 	return 0;
 }
 
+
+static struct iscsi_sess_param default_session_param = {
+	.initial_r2t = 1,
+	.immediate_data = 1,
+	.max_connections = 1,
+	.max_recv_data_length = 8192,
+	.max_xmit_data_length = 8192,
+	.max_burst_length = 262144,
+	.first_burst_length = 65536,
+	.default_wait_time = 2,
+	.default_retain_time = 20,
+	.max_outstanding_r2t = 1,
+	.data_pdu_inorder = 1,
+	.data_sequence_inorder = 1,
+	.error_recovery_level = 0,
+	.header_digest = DIGEST_NONE,
+	.data_digest = DIGEST_NONE,
+	.ofmarker = 0,
+	.ifmarker = 0,
+	.ofmarkint = 2048,
+	.ifmarkint = 2048,
+};
+
+static struct iscsi_trgt_param default_target_param = {
+	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
+};
+
+static int istgt_target_create(struct tgt_target *tt)
+{
+	int err = -EINVAL;
+	struct iscsi_target *target = tt->tt_data;
+
+	target->tt = tt;
+	target->tid = target->tt->tid;
+
+	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
+	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
+
+	init_MUTEX(&target->target_sem);
+	INIT_LIST_HEAD(&target->session_list);
+
+	nthread_init(target);
+	err = nthread_start(target);
+
+	return err;
+}
+
+static void istgt_target_destroy(struct tgt_target *tt)
+{
+	struct iscsi_target *target =
+		(struct iscsi_target *) tt->tt_data;
+
+	down(&target->target_sem);
+
+	/* kernel may crash until tgt supports lifetime management. */
+	BUG_ON(!list_empty(&target->session_list));
+
+	up(&target->target_sem);
+
+	nthread_stop(target);
+}
+
 static struct tgt_target_template istgt_template = {
 	.name = THIS_NAME,
 	.module = THIS_MODULE,
 	.protocol = "scsi",
 	.subprotocol = "iscsi",
-	.target_create = target_add,
-	.target_destroy = target_del,
+	.target_create = istgt_target_create,
+	.target_destroy = istgt_target_destroy,
 	.msg_recv = iet_msg_recv,
 	.transfer_response = scsi_cmnd_done,
 	.transfer_write_data = buffer_ready,
 	.priv_data_size = sizeof(struct iscsi_target),
 };
 
-static void iscsi_exit(void)
+static void istgt_exit(void)
 {
-	if (iscsi_cmnd_cache)
-		kmem_cache_destroy(iscsi_cmnd_cache);
-
+	kmem_cache_destroy(istgt_cmd_cache);
 	tgt_target_template_unregister(&istgt_template);
 }
 
-static int iscsi_init(void)
+static int istgt_init(void)
 {
-	int err = -ENOMEM;
+	int err;
 
 	printk("iSCSI Target Software for Linux Target Framework %s\n",
 	       VERSION_STRING);
 
-	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
-					     0, 0, NULL, NULL);
-	if (!iscsi_cmnd_cache)
-		goto err;
+	istgt_cmd_cache = kmem_cache_create("istgt_cmd",
+					    sizeof(struct iscsi_cmnd),
+					    0, 0, NULL, NULL);
+	if (!istgt_cmd_cache)
+		return -ENOMEM;
 
 	err = tgt_target_template_register(&istgt_template);
 	if (err < 0)
-		goto err;
+		goto free_cmd_cache;
 
 	return 0;
 
-err:
-	iscsi_exit();
+free_cmd_cache:
+	kmem_cache_destroy(istgt_cmd_cache);
+
 	return err;
 }
 
-module_param(debug_enable_flags, ulong, S_IRUGO);
+module_init(istgt_init);
+module_exit(istgt_exit);
 
-module_init(iscsi_init);
-module_exit(iscsi_exit);
-
 MODULE_LICENSE("GPL");

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 09:04:04 UTC (rev 155)
@@ -218,12 +218,6 @@
 extern int nthread_stop(struct iscsi_target *);
 extern void nthread_wakeup(struct iscsi_target *);
 
-/* target.c */
-extern int target_lock(struct iscsi_target *, int);
-extern void target_unlock(struct iscsi_target *);
-extern int target_add(struct tgt_target *);
-extern void target_del(struct tgt_target *);
-
 /* config.c */
 extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
 extern int event_send(struct tgt_target *tgt, int tid, uint64_t sid,

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/nthread.c	2005-11-05 09:04:04 UTC (rev 155)
@@ -635,14 +635,14 @@
 		clear_bit(D_DATA_READY, &info->flags);
 		spin_unlock_bh(&info->nthread_lock);
 
-		target_lock(target, 0);
+		down(&target->target_sem);
 		list_for_each_entry_safe(conn, tmp, &info->active_conns, poll_list) {
 			if (test_bit(CONN_ACTIVE, &conn->state))
 				process_io(conn);
 			else
 				close_conn(conn);
 		}
-		target_unlock(target);
+		up(&target->target_sem);
 
 	} while (!kthread_should_stop());
 

Deleted: trunk/istgt/kernel/target.c
===================================================================
--- trunk/istgt/kernel/target.c	2005-11-05 03:08:11 UTC (rev 154)
+++ trunk/istgt/kernel/target.c	2005-11-05 09:04:04 UTC (rev 155)
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <linux/mempool.h>
-
-#include <iscsi.h>
-#include <digest.h>
-
-static DECLARE_MUTEX(target_list_sem);
-
-static struct iscsi_sess_param default_session_param = {
-	.initial_r2t = 1,
-	.immediate_data = 1,
-	.max_connections = 1,
-	.max_recv_data_length = 8192,
-	.max_xmit_data_length = 8192,
-	.max_burst_length = 262144,
-	.first_burst_length = 65536,
-	.default_wait_time = 2,
-	.default_retain_time = 20,
-	.max_outstanding_r2t = 1,
-	.data_pdu_inorder = 1,
-	.data_sequence_inorder = 1,
-	.error_recovery_level = 0,
-	.header_digest = DIGEST_NONE,
-	.data_digest = DIGEST_NONE,
-	.ofmarker = 0,
-	.ifmarker = 0,
-	.ofmarkint = 2048,
-	.ifmarkint = 2048,
-};
-
-static struct iscsi_trgt_param default_target_param = {
-	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
-};
-
-inline int target_lock(struct iscsi_target *target, int interruptible)
-{
-	int err = 0;
-
-	if (interruptible)
-		err = down_interruptible(&target->target_sem);
-	else
-		down(&target->target_sem);
-
-	return err;
-}
-
-inline void target_unlock(struct iscsi_target *target)
-{
-	up(&target->target_sem);
-}
-
-int target_add(struct tgt_target *tt)
-{
-	int err = -EINVAL;
-	struct iscsi_target *target = tt->tt_data;
-
-	down(&target_list_sem);
-
-	target->tt = tt;
-	target->tid = target->tt->tid;
-
-	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
-	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
-
-	init_MUTEX(&target->target_sem);
-	INIT_LIST_HEAD(&target->session_list);
-
-	nthread_init(target);
-	err = nthread_start(target);
-
-	up(&target_list_sem);
-
-	return err;
-}
-
-void target_del(struct tgt_target *tt)
-{
-	struct iscsi_target *target =
-		(struct iscsi_target *) tt->tt_data;
-
-	down(&target_list_sem);
-
-	target_lock(target, 0);
-
-	/* kernel may crash until tgt supports lifetime management. */
-	BUG_ON(!list_empty(&target->session_list));
-
-	target_unlock(target);
-	up(&target_list_sem);
-
-	nthread_stop(target);
-}



From tomo at berlios.de  Sat Nov  5 10:23:14 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 10:23:14 +0100
Subject: [Stgt-svn] r156 - trunk/istgt/kernel
Message-ID: <200511050923.jA59NEYp004357@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 10:23:13 +0100 (Sat, 05 Nov 2005)
New Revision: 156

Modified:
   trunk/istgt/kernel/digest.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
Log:
Rename cmnd_* macros cmd_*.

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-11-05 09:04:04 UTC (rev 155)
+++ trunk/istgt/kernel/digest.c	2005-11-05 09:23:13 UTC (rev 156)
@@ -135,7 +135,7 @@
 	struct scatterlist *sg;
 	uint32_t offset, crc;
 
-	if (cmnd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
+	if (cmd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
 		struct iscsi_cmnd *scsi_cmnd = cmnd->req;
 		struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 
@@ -150,7 +150,7 @@
 	digest_data(cmnd->conn->rx_digest_tfm, cmnd, sg, offset,
 		    (uint8_t *) &crc);
 
-	if (!cmnd->conn->read_overflow && (cmnd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) {
+	if (!cmnd->conn->read_overflow && (cmd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) {
 		if (crc != cmnd->ddigest)
 			return -EIO;
 	}

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 09:04:04 UTC (rev 155)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 09:23:13 UTC (rev 156)
@@ -18,7 +18,7 @@
 
 static uint32_t cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
 
 	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
 		return be32_to_cpu(hdr->data_length);
@@ -27,7 +27,7 @@
 
 static uint32_t cmnd_read_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
 
 	if (hdr->flags & ISCSI_FLAG_CMD_READ) {
 		if (!(hdr->flags & ISCSI_FLAG_CMD_WRITE))
@@ -136,8 +136,8 @@
 
 	if (!list_empty(&cmnd->list)) {
 		eprintk("%x %x %x %x %lx %lx %u %u %u %u %u %u %u %d %d\n",
-			cmnd_itt(cmnd), cmnd_ttt(cmnd), cmnd_opcode(cmnd),
-			cmnd_scsicode(cmnd), cmnd->state, cmnd->flags,
+			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
+			cmd_scsicode(cmnd), cmnd->state, cmnd->flags,
 			cmnd->r2t_sn, cmnd->r2t_length, cmnd->is_unsolicited_data,
 			cmnd->target_task_tag, cmnd->outstanding_r2t,
 			cmnd->hdigest, cmnd->ddigest,
@@ -154,7 +154,7 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_cmnd *data_cmnd;
 	struct scatterlist *sg = cmnd->tc->sg;
-	struct iscsi_cmd *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
 	uint32_t pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
@@ -216,7 +216,7 @@
 static struct iscsi_cmnd *create_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 	struct iscsi_cmd_rsp *rsp_hdr;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
@@ -267,7 +267,7 @@
 	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr->itt = cmnd_hdr(req)->itt;
+	rsp_hdr->itt = cmd_hdr(req)->itt;
 
 	stc = tgt_cmd_to_scsi(req->tc);
 	sense = (struct iscsi_sense_data *) stc->sense_buff;
@@ -302,7 +302,7 @@
 	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr->itt = cmnd_hdr(req)->itt;
+	rsp_hdr->itt = cmd_hdr(req)->itt;
 
 	stc = tgt_cmd_to_scsi(req->tc);
 	sg->page = virt_to_page(stc->sense_buff);
@@ -342,7 +342,7 @@
 	kfree(cmnd->pdu.ahs);
 
 	if (!list_empty(&cmnd->list)) {
-		struct iscsi_cmd *req = cmnd_hdr(cmnd);
+		struct iscsi_cmd *req = cmd_hdr(cmnd);
 
 		eprintk("cmnd %p still on some list?, %x, %x, %x, %x, %x, %x, %x %lx %lx\n",
 			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
@@ -350,7 +350,7 @@
 			req->cmdsn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
 
 		if (cmnd->req) {
-			struct iscsi_cmd *req = cmnd_hdr(cmnd->req);
+			struct iscsi_cmd *req = cmd_hdr(cmnd->req);
 			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
 		}
 		dump_stack();
@@ -377,8 +377,8 @@
 
 	BUG_ON(1);
 
-/* 	eprintk("%x %x %x %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd), */
-/* 		cmnd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
+/* 	eprintk("%x %x %x %u\n", cmd_itt(cmnd), cmnd_opcode(cmnd), */
+/* 		cmd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
 
 /* 	if (!(size = cmnd->pdu.datasize)) */
 /* 		return; */
@@ -554,7 +554,7 @@
 	if (tmp && tmp == cmnd)
 		__cmnd_remove_hash(tmp);
 	else
-		eprintk("%p:%x not found\n", cmnd, cmnd_itt(cmnd));
+		eprintk("%p:%x not found\n", cmnd, cmd_itt(cmnd));
 
 	spin_unlock(&session->cmnd_hash_lock);
 }
@@ -567,8 +567,8 @@
 
 	rsp = get_rsp_cmnd(req);
 	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
-	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
-		eprintk("unexpected response command %u\n", cmnd_opcode(rsp));
+	if (cmd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
+		eprintk("unexpected response command %u\n", cmd_opcode(rsp));
 		return;
 	}
 
@@ -579,7 +579,7 @@
 	}
 	size = cmnd_read_size(req);
 	if (size) {
-		if (cmnd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
+		if (cmd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
 			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
 			rsp_hdr->bi_residual_count = cpu_to_be32(size);
 		} else {
@@ -661,7 +661,7 @@
 
 	length = req->r2t_length;
 	burst = req->conn->session->param.max_burst_length;
-	offset = be32_to_cpu(cmnd_hdr(req)->data_length) - length;
+	offset = be32_to_cpu(cmd_hdr(req)->data_length) - length;
 
 	do {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
@@ -670,8 +670,8 @@
 		rsp_hdr = (struct iscsi_r2t_rsp *)&rsp->pdu.bhs;
 		rsp_hdr->opcode = ISCSI_OP_R2T;
 		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		memcpy(rsp_hdr->lun, cmnd_hdr(req)->lun, 8);
-		rsp_hdr->itt = cmnd_hdr(req)->itt;
+		memcpy(rsp_hdr->lun, cmd_hdr(req)->lun, 8);
+		rsp_hdr->itt = cmd_hdr(req)->itt;
 		rsp_hdr->r2tsn = cpu_to_be32(req->r2t_sn++);
 		rsp_hdr->data_offset = cpu_to_be32(offset);
 		if (length > burst) {
@@ -683,7 +683,7 @@
 			length = 0;
 		}
 
-		dprintk("%x %u %u %u %u\n", cmnd_itt(req),
+		dprintk("%x %u %u %u %u\n", cmd_itt(req),
 			be32_to_cpu(rsp_hdr->data_length),
 			be32_to_cpu(rsp_hdr->data_offset),
 			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
@@ -702,7 +702,7 @@
 {
 	struct tgt_cmd *tc = (struct tgt_cmd *) data;
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
-	struct iscsi_cmd *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
 
 	if (tc->result != SAM_STAT_GOOD) {
 		struct iscsi_cmnd *rsp;
@@ -760,7 +760,7 @@
 
 static void tgt_scsi_cmd_create(struct iscsi_cmnd *req)
 {
-	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 	struct iscsi_conn *conn = req->conn;
 	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	enum dma_data_direction data_dir;
@@ -833,24 +833,24 @@
 	uint32_t size, tmp;
 	int i = 0, err = 0;
 
-	if (cmnd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+	if (cmd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		/*
 		 * We don't request a NOP-Out by sending a NOP-In.
 		 * See 10.18.2 in the draft 20.
 		 */
-		eprintk("initiator bug %x\n", cmnd_itt(cmnd));
+		eprintk("initiator bug %x\n", cmd_itt(cmnd));
 		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
 	}
 
-	if (cmnd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+	if (cmd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		if (!(cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE))
 			eprintk("%s\n","initiator bug!");
 		update_stat_sn(cmnd);
 		err = check_cmd_sn(cmnd);
 		goto out;
 	} else if ((err = cmnd_insert_hash(cmnd)) < 0) {
-		eprintk("ignore this request %x\n", cmnd_itt(cmnd));
+		eprintk("ignore this request %x\n", cmd_itt(cmnd));
 		goto out;
 	}
 
@@ -905,7 +905,7 @@
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
-	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 
 	dprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
@@ -935,7 +935,7 @@
 		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
 		      req->pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -964,14 +964,14 @@
 		req->target_task_tag = get_next_ttt(conn->session);
 
 		if (!param->immediate_data && req->pdu.datasize)
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
 
 		if (param->initial_r2t &&
 		    !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL))
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
 
 		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
-			eprintk("Verification is ignored %x\n", cmnd_itt(req));
+			eprintk("Verification is ignored %x\n", cmd_itt(req));
 
 		if (req->pdu.datasize) {
 			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)
@@ -1001,18 +1001,18 @@
 	cmnd->req = scsi_cmnd = cmnd_find_hash(conn->session, req->itt, req->ttt);
 	if (!scsi_cmnd) {
 		eprintk("unable to find scsi task %x %x\n",
-			cmnd_itt(cmnd), cmnd_ttt(cmnd));
+			cmd_itt(cmnd), cmd_ttt(cmnd));
 		goto skip_data;
 	}
 
 	if (scsi_cmnd->r2t_length < cmnd->pdu.datasize) {
 		eprintk("invalid data len %x %u %u\n",
-			cmnd_itt(scsi_cmnd), cmnd->pdu.datasize, scsi_cmnd->r2t_length);
+			cmd_itt(scsi_cmnd), cmnd->pdu.datasize, scsi_cmnd->r2t_length);
 		goto skip_data;
 	}
 
 	if (scsi_cmnd->r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
-		eprintk("%x %u %u %u\n", cmnd_itt(scsi_cmnd), scsi_cmnd->r2t_length,
+		eprintk("%x %u %u %u\n", cmd_itt(scsi_cmnd), scsi_cmnd->r2t_length,
 			offset,	cmnd_write_size(scsi_cmnd));
 		goto skip_data;
 	}
@@ -1023,7 +1023,7 @@
 		/* unsolicited burst data */
 		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_FINAL) {
 			eprintk("unexpected data from %x %x\n",
-				cmnd_itt(cmnd), cmnd_ttt(cmnd));
+				cmd_itt(cmnd), cmd_ttt(cmnd));
 			goto skip_data;
 		}
 	}
@@ -1052,7 +1052,7 @@
 	BUG_ON(!scsi_cmnd);
 
 	if (conn->read_overflow) {
-		eprintk("%x %u\n", cmnd_itt(cmnd), conn->read_overflow);
+		eprintk("%x %u\n", cmd_itt(cmnd), conn->read_overflow);
 		offset = be32_to_cpu(req->offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
 		if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, conn->read_overflow) < 0)
@@ -1070,7 +1070,7 @@
 		/* TODO : proper error handling */
 		if (!(req->flags & ISCSI_FLAG_CMD_FINAL) &&
 		    scsi_cmnd->r2t_length == 0)
-			eprintk("initiator error %x\n", cmnd_itt(scsi_cmnd));
+			eprintk("initiator error %x\n", cmd_itt(scsi_cmnd));
 
 		if (!(req->flags & ISCSI_FLAG_CMD_FINAL))
 			goto out;
@@ -1103,7 +1103,7 @@
 /* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
 
 /* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
-/* 		eprintk("%x %x %x %u %u %u %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd), */
+/* 		eprintk("%x %x %x %u %u %u %u\n", cmd_itt(cmnd), cmnd_opcode(cmnd), */
 /* 			cmnd->r2t_length, cmnd_scsicode(cmnd), */
 /* 			cmnd_write_size(cmnd), cmnd->is_unsolicited_data, */
 /* 			cmnd->outstanding_r2t); */
@@ -1128,7 +1128,7 @@
 
 /* 				if (all) */
 /* 					__cmnd_abort(cmnd); */
-/* 				else if (translate_lun(cmnd_hdr(cmnd)->lun) == lun) */
+/* 				else if (translate_lun(cmd_hdr(cmnd)->lun) == lun) */
 /* 					__cmnd_abort(cmnd); */
 /* 			} */
 /* 		} */
@@ -1169,7 +1169,7 @@
 /* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
 	rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
 
-	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
+	eprintk("%x %d %x\n", cmd_itt(req), function, req_hdr->rtt);
 
 /* 	switch (function) { */
 /* 	case ISCSI_FUNCTION_ABORT_TASK: */
@@ -1223,7 +1223,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_nopin *rsp_hdr;
 
-	if (cmnd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
 		rsp_hdr = (struct iscsi_nopin *)&rsp->pdu.bhs;
@@ -1270,7 +1270,7 @@
 	dprintk("%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
 		cmnd->pdu.bhs.statsn);
 
-	switch (cmnd_opcode(cmnd)) {
+	switch (cmd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_OUT:
 		noop_out_exec(cmnd);
 		break;
@@ -1290,7 +1290,7 @@
 	case ISCSI_OP_SNACK:
 		break;
 	default:
-		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
 		break;
 	}
 }
@@ -1385,7 +1385,7 @@
 	iop++;
 	conn->write_size = sizeof(cmnd->pdu.bhs);
 
-	switch (cmnd_opcode(cmnd)) {
+	switch (cmd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
@@ -1427,7 +1427,7 @@
 		cmnd_send_pdu(conn, cmnd);
 		break;
 	default:
-		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
 		break;
 	}
 
@@ -1440,8 +1440,8 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
-	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
-	switch (cmnd_opcode(cmnd)) {
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
 	case ISCSI_OP_SCSI_CMD_RSP:
 	case ISCSI_OP_SCSI_TMFUNC_RSP:
@@ -1453,7 +1453,7 @@
 	case ISCSI_OP_LOGOUT_RSP:
 		break;
 	default:
-		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
 		BUG_ON(1);
 		break;
 	}
@@ -1481,7 +1481,7 @@
 	uint32_t cmd_sn;
 
 	dprintk("%p:%x %u,%u\n",
-		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn,
+		cmnd, cmd_opcode(cmnd), cmnd->pdu.bhs.statsn,
 		session->exp_cmd_sn);
 
 	if (cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE) {
@@ -1501,13 +1501,13 @@
 			if (cmnd->pdu.bhs.statsn != cmd_sn)
 				break;
 /* 			eprintk("find out-of-order %x %u %u\n", */
-/* 				cmnd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
+/* 				cmd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
 			list_del_init(&cmnd->list);
 			clear_cmnd_pending(cmnd);
 		}
 	} else {
 /* 		eprintk("out-of-order %x %u %u\n", */
-/* 			cmnd_itt(cmnd), cmd_sn, session->exp_cmd_sn); */
+/* 			cmd_itt(cmnd), cmd_sn, session->exp_cmd_sn); */
 
 		set_cmnd_pending(cmnd);
 		if (before(cmd_sn, session->exp_cmd_sn)) /* close the conn */
@@ -1534,7 +1534,7 @@
 	struct iscsi_sess_param *param = &conn->session->param;
 
 	if (cmnd->pdu.datasize > param->max_recv_data_length) {
-		eprintk("too lond data %x %u %u\n", cmnd_itt(cmnd),
+		eprintk("too lond data %x %u %u\n", cmd_itt(cmnd),
 			cmnd->pdu.datasize, param->max_recv_data_length);
 
 		if (get_pgcnt(cmnd->pdu.datasize, 0) > ISCSI_CONN_IOV_MAX) {
@@ -1554,7 +1554,7 @@
 	if (check_segment_length(cmnd) < 0)
 		return;
 
-	switch (cmnd_opcode(cmnd)) {
+	switch (cmd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_OUT:
 		err = noop_out_start(conn, cmnd);
 		break;
@@ -1581,7 +1581,7 @@
 	}
 
 	if (err < 0) {
-		eprintk("%x %x %d\n", cmnd_opcode(cmnd), cmnd_itt(cmnd), err);
+		eprintk("%x %x %d\n", cmd_opcode(cmnd), cmd_itt(cmnd), err);
 		iscsi_cmnd_reject(cmnd, -err);
 	}
 }
@@ -1590,8 +1590,8 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
-	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
-	switch (cmnd_opcode(cmnd)) {
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
 	case ISCSI_OP_SCSI_REJECT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
@@ -1612,7 +1612,7 @@
 		cmnd_release(cmnd, 0);
 		break;
 	default:
-		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
 		BUG();
 		break;
 	}

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 09:04:04 UTC (rev 155)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 09:23:13 UTC (rev 156)
@@ -245,11 +245,11 @@
 	hton24(pdu->bhs.dlength, pdu->datasize);
 }
 
-#define cmnd_hdr(cmnd) ((struct iscsi_cmd *) (&((cmnd)->pdu.bhs)))
-#define cmnd_ttt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.ttt)
-#define cmnd_itt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.itt)
-#define cmnd_opcode(cmnd) ((cmnd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
-#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)->cdb[0]
+#define cmd_hdr(cmd) ((struct iscsi_cmd *) (&((cmd)->pdu.bhs)))
+#define cmd_ttt(cmd) cpu_to_be32((cmd)->pdu.bhs.ttt)
+#define cmd_itt(cmd) cpu_to_be32((cmd)->pdu.bhs.itt)
+#define cmd_opcode(cmd) ((cmd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
+#define cmd_scsicode(cmd) cmd_hdr(cmd)->cdb[0]
 
 #define	SECTOR_SIZE_BITS	9
 

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-11-05 09:04:04 UTC (rev 155)
+++ trunk/istgt/kernel/nthread.c	2005-11-05 09:23:13 UTC (rev 156)
@@ -257,7 +257,7 @@
 		rx_ddigest(conn, RX_END);
 		break;
 	default:
-		eprintk("%d %d %x\n", res, conn->read_state, cmnd_opcode(cmnd));
+		eprintk("%d %d %x\n", res, conn->read_state, cmd_opcode(cmnd));
 		BUG_ON(1);
 	}
 
@@ -268,13 +268,13 @@
 		return res;
 
 	if (conn->read_size) {
-		eprintk("%d %x %d\n", res, cmnd_opcode(cmnd), conn->read_size);
+		eprintk("%d %x %d\n", res, cmd_opcode(cmnd), conn->read_size);
 		BUG_ON(1);
 	}
 
 	cmnd_rx_end(cmnd);
 	if (conn->read_size) {
-		eprintk("%x %d\n", cmnd_opcode(cmnd), conn->read_size);
+		eprintk("%x %d\n", cmd_opcode(cmnd), conn->read_size);
 		conn->read_state = RX_DATA;
 		return 1;
 	}
@@ -522,7 +522,7 @@
 		res = tx_ddigest(cmnd, TX_END);
 		break;
 	default:
-		eprintk("%d %d %x\n", res, conn->write_state, cmnd_opcode(cmnd));
+		eprintk("%d %d %x\n", res, conn->write_state, cmd_opcode(cmnd));
 		BUG_ON(1);
 	}
 
@@ -533,7 +533,7 @@
 		return res;
 
 	if (conn->write_size) {
-		eprintk("%d %x %u\n", res, cmnd_opcode(cmnd), conn->write_size);
+		eprintk("%d %x %u\n", res, cmd_opcode(cmnd), conn->write_size);
 		BUG_ON(conn->write_size);
 	}
 	cmnd_tx_end(cmnd);
@@ -600,7 +600,7 @@
 	if (atomic_read(&conn->nr_cmnds)) {
 		eprintk("%u\n", atomic_read(&conn->nr_cmnds));
 		list_for_each_entry(cmnd, &conn->pdu_list, conn_list)
-			eprintk("%x %x\n", cmnd_opcode(cmnd), cmnd_itt(cmnd));
+			eprintk("%x %x\n", cmd_opcode(cmnd), cmd_itt(cmnd));
 		BUG_ON(1);
 	}
 



From tomo at berlios.de  Sat Nov  5 10:31:00 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 10:31:00 +0100
Subject: [Stgt-svn] r157 - trunk/istgt/kernel
Message-ID: <200511050931.jA59V09p004614@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 10:31:00 +0100 (Sat, 05 Nov 2005)
New Revision: 157

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
Log:
Rename cmnd_flags macros.

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 09:23:13 UTC (rev 156)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 09:31:00 UTC (rev 157)
@@ -96,7 +96,7 @@
 	struct iscsi_cmnd *rsp = cmnd_alloc(cmnd->conn, 0);
 
 	if (final)
-		set_cmnd_final(rsp);
+		set_cmd_final(rsp);
 	list_add_tail(&rsp->pdu_list, &cmnd->pdu_list);
 	rsp->req = cmnd;
 	return rsp;
@@ -522,7 +522,7 @@
 	tmp = __cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG);
 	if (!tmp) {
 		list_add_tail(&cmnd->hash_list, head);
-		set_cmnd_hashed(cmnd);
+		set_cmd_hashed(cmnd);
 	} else
 		err = -TASK_IN_PROGRESS;
 
@@ -820,7 +820,7 @@
 		if (!cmnd->is_unsolicited_data)
 			send_r2t(cmnd);
 	} else {
-		set_cmnd_waitio(cmnd);
+		set_cmd_waitio(cmnd);
 		if (cmnd->tc)
 			cmd->done(cmd);
 		else
@@ -1063,7 +1063,7 @@
 	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		if (req->flags & ISCSI_FLAG_CMD_FINAL) {
 			scsi_cmnd->is_unsolicited_data = 0;
-			if (!cmnd_pending(scsi_cmnd))
+			if (!cmd_pending(scsi_cmnd))
 				scsi_cmnd_exec(scsi_cmnd);
 		}
 	} else {
@@ -1261,7 +1261,7 @@
 	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
 	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
-	set_cmnd_close(rsp);
+	set_cmd_close(rsp);
 	iscsi_cmnd_init_write(rsp);
 }
 
@@ -1341,7 +1341,7 @@
 		return;
 
 	req = cmnd->req;
-	is_last = cmnd_final(cmnd);
+	is_last = cmd_final(cmnd);
 
 	if (force) {
 		while (!list_empty(&cmnd->pdu_list)) {
@@ -1353,7 +1353,7 @@
 		list_del_init(&cmnd->list);
 	}
 
-	if (cmnd_hashed(cmnd))
+	if (cmd_hashed(cmnd))
 		cmnd_remove_hash(cmnd);
 
 	list_del_init(&cmnd->pdu_list);
@@ -1458,7 +1458,7 @@
 		break;
 	}
 
-	if (cmnd_close(cmnd))
+	if (cmd_close(cmnd))
 		conn_close(conn);
 
 	list_del_init(&cmnd->list);
@@ -1503,13 +1503,13 @@
 /* 			eprintk("find out-of-order %x %u %u\n", */
 /* 				cmd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
 			list_del_init(&cmnd->list);
-			clear_cmnd_pending(cmnd);
+			clear_cmd_pending(cmnd);
 		}
 	} else {
 /* 		eprintk("out-of-order %x %u %u\n", */
 /* 			cmd_itt(cmnd), cmd_sn, session->exp_cmd_sn); */
 
-		set_cmnd_pending(cmnd);
+		set_cmd_pending(cmnd);
 		if (before(cmd_sn, session->exp_cmd_sn)) /* close the conn */
 			eprintk("unexpected cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
 

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 09:23:13 UTC (rev 156)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 09:31:00 UTC (rev 157)
@@ -253,30 +253,30 @@
 
 #define	SECTOR_SIZE_BITS	9
 
-enum cmnd_flags {
-	CMND_hashed,
-	CMND_final,
-	CMND_waitio,
-	CMND_close,
-	CMND_lunit,
-	CMND_pending,
+enum istgt_cmd_flags {
+	CMD_hashed,
+	CMD_final,
+	CMD_waitio,
+	CMD_close,
+	CMD_lunit,
+	CMD_pending,
 };
 
-#define set_cmnd_hashed(cmnd)	set_bit(CMND_hashed, &(cmnd)->flags)
-#define cmnd_hashed(cmnd)	test_bit(CMND_hashed, &(cmnd)->flags)
+#define set_cmd_hashed(cmd)	set_bit(CMD_hashed, &(cmd)->flags)
+#define cmd_hashed(cmd)	test_bit(CMD_hashed, &(cmd)->flags)
 
-#define set_cmnd_final(cmnd)	set_bit(CMND_final, &(cmnd)->flags)
-#define cmnd_final(cmnd)	test_bit(CMND_final, &(cmnd)->flags)
+#define set_cmd_final(cmd)	set_bit(CMD_final, &(cmd)->flags)
+#define cmd_final(cmd)	test_bit(CMD_final, &(cmd)->flags)
 
-#define set_cmnd_waitio(cmnd)	set_bit(CMND_waitio, &(cmnd)->flags)
-#define cmnd_waitio(cmnd)	test_bit(CMND_waitio, &(cmnd)->flags)
+#define set_cmd_waitio(cmd)	set_bit(CMD_waitio, &(cmd)->flags)
+#define cmd_waitio(cmd)	test_bit(CMD_waitio, &(cmd)->flags)
 
-#define set_cmnd_close(cmnd)	set_bit(CMND_close, &(cmnd)->flags)
-#define cmnd_close(cmnd)	test_bit(CMND_close, &(cmnd)->flags)
+#define set_cmd_close(cmd)	set_bit(CMD_close, &(cmd)->flags)
+#define cmd_close(cmd)	test_bit(CMD_close, &(cmd)->flags)
 
-#define set_cmnd_pending(cmnd)	set_bit(CMND_pending, &(cmnd)->flags)
-#define clear_cmnd_pending(cmnd)	clear_bit(CMND_pending, &(cmnd)->flags)
-#define cmnd_pending(cmnd)	test_bit(CMND_pending, &(cmnd)->flags)
+#define set_cmd_pending(cmd)	set_bit(CMD_pending, &(cmd)->flags)
+#define clear_cmd_pending(cmd)	clear_bit(CMD_pending, &(cmd)->flags)
+#define cmd_pending(cmd)	test_bit(CMD_pending, &(cmd)->flags)
 
 /* We still use 'IET' id. Maybe someday, we get own id. */
 



From tomo at berlios.de  Sat Nov  5 10:44:07 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 10:44:07 +0100
Subject: [Stgt-svn] r158 - trunk/istgt/kernel
Message-ID: <200511050944.jA59i7oO006178@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 10:44:00 +0100 (Sat, 05 Nov 2005)
New Revision: 158

Modified:
   trunk/istgt/kernel/digest.c
   trunk/istgt/kernel/digest.h
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
Log:
Rename struct iscsi_cmnd struct istgt_cmd (note that struct iscsi_cmd is
taken as PDU header struct by iscsi_proto.h).



Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-11-05 09:31:00 UTC (rev 157)
+++ trunk/istgt/kernel/digest.c	2005-11-05 09:44:00 UTC (rev 158)
@@ -77,7 +77,7 @@
 	crypto_digest_final(tfm, crc);
 }
 
-int digest_rx_header(struct iscsi_cmnd *cmnd)
+int digest_rx_header(struct istgt_cmd *cmnd)
 {
 	uint32_t crc;
 
@@ -88,13 +88,13 @@
 	return 0;
 }
 
-void digest_tx_header(struct iscsi_cmnd *cmnd)
+void digest_tx_header(struct istgt_cmd *cmnd)
 {
 	digest_header(cmnd->conn->tx_digest_tfm, &cmnd->pdu,
 		      (uint8_t *) &cmnd->hdigest);
 }
 
-static void digest_data(struct crypto_tfm *tfm, struct iscsi_cmnd *cmnd,
+static void digest_data(struct crypto_tfm *tfm, struct istgt_cmd *cmnd,
 			struct scatterlist *sgv, uint32_t offset, uint8_t *crc)
 {
 	struct scatterlist sg[ISCSI_CONN_IOV_MAX];
@@ -130,13 +130,13 @@
 	crypto_digest_final(tfm, crc);
 }
 
-int digest_rx_data(struct iscsi_cmnd *cmnd)
+int digest_rx_data(struct istgt_cmd *cmnd)
 {
 	struct scatterlist *sg;
 	uint32_t offset, crc;
 
 	if (cmd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
-		struct iscsi_cmnd *scsi_cmnd = cmnd->req;
+		struct istgt_cmd *scsi_cmnd = cmnd->req;
 		struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 
 		sg = scsi_cmnd->tc->sg;
@@ -158,7 +158,7 @@
 	return 0;
 }
 
-void digest_tx_data(struct iscsi_cmnd *cmnd)
+void digest_tx_data(struct istgt_cmd *cmnd)
 {
 	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 

Modified: trunk/istgt/kernel/digest.h
===================================================================
--- trunk/istgt/kernel/digest.h	2005-11-05 09:31:00 UTC (rev 157)
+++ trunk/istgt/kernel/digest.h	2005-11-05 09:44:00 UTC (rev 158)
@@ -11,10 +11,10 @@
 extern int digest_init(struct iscsi_conn *conn);
 extern void digest_cleanup(struct iscsi_conn *conn);
 
-extern int digest_rx_header(struct iscsi_cmnd *cmnd);
-extern int digest_rx_data(struct iscsi_cmnd *cmnd);
+extern int digest_rx_header(struct istgt_cmd *cmnd);
+extern int digest_rx_data(struct istgt_cmd *cmnd);
 
-extern void digest_tx_header(struct iscsi_cmnd *cmnd);
-extern void digest_tx_data(struct iscsi_cmnd *cmnd);
+extern void digest_tx_header(struct istgt_cmd *cmnd);
+extern void digest_tx_data(struct istgt_cmd *cmnd);
 
 #endif /* __IET_DIGEST_H__ */

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 09:31:00 UTC (rev 157)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 09:44:00 UTC (rev 158)
@@ -16,7 +16,7 @@
 static kmem_cache_t *istgt_cmd_cache;
 static char dummy_data[1024];
 
-static uint32_t cmnd_write_size(struct iscsi_cmnd *cmnd)
+static uint32_t cmnd_write_size(struct istgt_cmd *cmnd)
 {
 	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
 
@@ -25,7 +25,7 @@
 	return 0;
 }
 
-static uint32_t cmnd_read_size(struct iscsi_cmnd *cmnd)
+static uint32_t cmnd_read_size(struct istgt_cmd *cmnd)
 {
 	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
 
@@ -51,9 +51,9 @@
  * @return    ptr to command or NULL
  */
 
-struct iscsi_cmnd *cmnd_alloc(struct iscsi_conn *conn, int req)
+struct istgt_cmd *cmnd_alloc(struct iscsi_conn *conn, int req)
 {
-	struct iscsi_cmnd *cmnd;
+	struct istgt_cmd *cmnd;
 
 	/* TODO: async interface is necessary ? */
 	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
@@ -91,9 +91,9 @@
  * @return    ptr to response command or NULL
  */
 
-static struct iscsi_cmnd *iscsi_cmnd_create_rsp_cmnd(struct iscsi_cmnd *cmnd, int final)
+static struct istgt_cmd *iscsi_cmnd_create_rsp_cmnd(struct istgt_cmd *cmnd, int final)
 {
-	struct iscsi_cmnd *rsp = cmnd_alloc(cmnd->conn, 0);
+	struct istgt_cmd *rsp = cmnd_alloc(cmnd->conn, 0);
 
 	if (final)
 		set_cmd_final(rsp);
@@ -102,21 +102,21 @@
 	return rsp;
 }
 
-static struct iscsi_cmnd *get_rsp_cmnd(struct iscsi_cmnd *req)
+static struct istgt_cmd *get_rsp_cmnd(struct istgt_cmd *req)
 {
-	return list_entry(req->pdu_list.prev, struct iscsi_cmnd, pdu_list);
+	return list_entry(req->pdu_list.prev, struct istgt_cmd, pdu_list);
 }
 
 static void iscsi_cmnds_init_write(struct list_head *send)
 {
-	struct iscsi_cmnd *cmnd = list_entry(send->next, struct iscsi_cmnd, list);
+	struct istgt_cmd *cmnd = list_entry(send->next, struct istgt_cmd, list);
 	struct iscsi_conn *conn = cmnd->conn;
 	struct list_head *pos, *next;
 
 	spin_lock(&conn->list_lock);
 
 	list_for_each_safe(pos, next, send) {
-		cmnd = list_entry(pos, struct iscsi_cmnd, list);
+		cmnd = list_entry(pos, struct istgt_cmd, list);
 
 		dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
 
@@ -130,7 +130,7 @@
 	nthread_wakeup(conn->session->target);
 }
 
-static void iscsi_cmnd_init_write(struct iscsi_cmnd *cmnd)
+static void iscsi_cmnd_init_write(struct istgt_cmd *cmnd)
 {
 	LIST_HEAD(head);
 
@@ -149,10 +149,10 @@
 	iscsi_cmnds_init_write(&head);
 }
 
-static void do_send_data_rsp(struct iscsi_cmnd *cmnd)
+static void do_send_data_rsp(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
-	struct iscsi_cmnd *data_cmnd;
+	struct istgt_cmd *data_cmnd;
 	struct scatterlist *sg = cmnd->tc->sg;
 	struct iscsi_cmd *req = cmd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
@@ -213,9 +213,9 @@
 	iscsi_cmnds_init_write(&send);
 }
 
-static struct iscsi_cmnd *create_scsi_rsp(struct iscsi_cmnd *req)
+static struct istgt_cmd *create_scsi_rsp(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 	struct iscsi_cmd_rsp *rsp_hdr;
 
@@ -231,9 +231,9 @@
 	return rsp;
 }
 
-void send_scsi_rsp(struct iscsi_cmnd *req)
+void send_scsi_rsp(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	uint32_t size;
 
@@ -252,9 +252,9 @@
 	uint8_t  data[0];
 } __packed;
 
-static struct iscsi_cmnd *do_create_sense_rsp(struct iscsi_cmnd *req)
+static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
 	struct scsi_tgt_cmd *stc;
@@ -286,11 +286,11 @@
 	return rsp;
 }
 
-static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
+static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
 					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
 {
 	struct scsi_tgt_cmd *stc;
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
 	struct scatterlist *sg = &req->sense_sg;
@@ -331,7 +331,7 @@
  * @cmnd: ptr to command
  */
 
-void iscsi_cmnd_remove(struct iscsi_cmnd *cmnd)
+void iscsi_cmnd_remove(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn;
 
@@ -367,7 +367,7 @@
 	kmem_cache_free(istgt_cmd_cache, cmnd);
 }
 
-static void cmnd_skip_pdu(struct iscsi_cmnd *cmnd)
+static void cmnd_skip_pdu(struct istgt_cmd *cmnd)
 {
 /* 	struct iscsi_conn *conn = cmnd->conn; */
 /* 	struct tio *tio = cmnd->tio; */
@@ -403,9 +403,9 @@
 /* 	conn->read_msg.msg_iovlen = ++i; */
 }
 
-static void iscsi_cmnd_reject(struct iscsi_cmnd *req, int reason)
+static void iscsi_cmnd_reject(struct istgt_cmd *req, int reason)
 {
-/* 	struct iscsi_cmnd *rsp; */
+/* 	struct istgt_cmd *rsp; */
 /* 	struct iscsi_reject_hdr *rsp_hdr; */
 /* 	struct tio *tio; */
 /* 	char *addr; */
@@ -429,7 +429,7 @@
 /* 	req->pdu.bhs.opcode = ISCSI_OP_PDU_REJECT; */
 }
 
-static void cmnd_set_sn(struct iscsi_cmnd *cmnd, int set_stat_sn)
+static void cmnd_set_sn(struct istgt_cmd *cmnd, int set_stat_sn)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_session *sess = conn->session;
@@ -441,7 +441,7 @@
 						sess->max_queued_cmnds);
 }
 
-static void update_stat_sn(struct iscsi_cmnd *cmnd)
+static void update_stat_sn(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	uint32_t exp_stat_sn;
@@ -455,7 +455,7 @@
 	}
 }
 
-static int check_cmd_sn(struct iscsi_cmnd *cmnd)
+static int check_cmd_sn(struct istgt_cmd *cmnd)
 {
 	struct iscsi_session *session = cmnd->conn->session;
 	uint32_t cmd_sn;
@@ -468,11 +468,11 @@
 	return -ISCSI_PROTOCOL_ERROR;
 }
 
-static struct iscsi_cmnd *__cmnd_find_hash(struct iscsi_session *session,
+static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
 					   uint32_t itt, uint32_t ttt)
 {
 	struct list_head *head;
-	struct iscsi_cmnd *cmnd;
+	struct istgt_cmd *cmnd;
 
 	head = &session->cmnd_hash[cmnd_hashfn(itt)];
 
@@ -487,10 +487,10 @@
 	return NULL;
 }
 
-static struct iscsi_cmnd *cmnd_find_hash(struct iscsi_session *session,
+static struct istgt_cmd *cmnd_find_hash(struct iscsi_session *session,
 					 uint32_t itt, uint32_t ttt)
 {
-	struct iscsi_cmnd *cmnd;
+	struct istgt_cmd *cmnd;
 
 	spin_lock(&session->cmnd_hash_lock);
 
@@ -501,10 +501,10 @@
 	return cmnd;
 }
 
-static int cmnd_insert_hash(struct iscsi_cmnd *cmnd)
+static int cmnd_insert_hash(struct istgt_cmd *cmnd)
 {
 	struct iscsi_session *session = cmnd->conn->session;
-	struct iscsi_cmnd *tmp;
+	struct istgt_cmd *tmp;
 	struct list_head *head;
 	int err = 0;
 	uint32_t itt = cmnd->pdu.bhs.itt;
@@ -537,15 +537,15 @@
 	return err;
 }
 
-static void __cmnd_remove_hash(struct iscsi_cmnd *cmnd)
+static void __cmnd_remove_hash(struct istgt_cmd *cmnd)
 {
 	list_del(&cmnd->hash_list);
 }
 
-static void cmnd_remove_hash(struct iscsi_cmnd *cmnd)
+static void cmnd_remove_hash(struct istgt_cmd *cmnd)
 {
 	struct iscsi_session *session = cmnd->conn->session;
-	struct iscsi_cmnd *tmp;
+	struct istgt_cmd *tmp;
 
 	spin_lock(&session->cmnd_hash_lock);
 
@@ -559,9 +559,9 @@
 	spin_unlock(&session->cmnd_hash_lock);
 }
 
-static void cmnd_skip_data(struct iscsi_cmnd *req)
+static void cmnd_skip_data(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	uint32_t size;
 
@@ -652,9 +652,9 @@
 	return 0;
 }
 
-static void send_r2t(struct iscsi_cmnd *req)
+static void send_r2t(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_r2t_rsp *rsp_hdr;
 	uint32_t length, offset, burst;
 	LIST_HEAD(send);
@@ -701,11 +701,11 @@
 static void __scsi_cmnd_done(void *data)
 {
 	struct tgt_cmd *tc = (struct tgt_cmd *) data;
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
 	struct iscsi_cmd *req = cmd_hdr(cmnd);
 
 	if (tc->result != SAM_STAT_GOOD) {
-		struct iscsi_cmnd *rsp;
+		struct istgt_cmd *rsp;
 
 		rsp = do_create_sense_rsp(cmnd);
 		iscsi_cmnd_init_write(rsp);
@@ -749,7 +749,7 @@
 static int scsi_cmnd_done(struct tgt_cmd *tc)
 {
 	int err;
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
 
 	INIT_WORK(&cmnd->work, __scsi_cmnd_done, tc);
 	err = schedule_work(&cmnd->work);
@@ -758,7 +758,7 @@
 	return TGT_CMD_XMIT_OK;
 }
 
-static void tgt_scsi_cmd_create(struct iscsi_cmnd *req)
+static void tgt_scsi_cmd_create(struct istgt_cmd *req)
 {
 	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 	struct iscsi_conn *conn = req->conn;
@@ -812,7 +812,7 @@
 	}
 }
 
-static void scsi_cmnd_exec(struct iscsi_cmnd *cmnd)
+static void scsi_cmnd_exec(struct istgt_cmd *cmnd)
 {
 	struct tgt_cmd *cmd = cmnd->tc;
 
@@ -828,7 +828,7 @@
 	}
 }
 
-static int noop_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
+static int noop_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
 {
 	uint32_t size, tmp;
 	int i = 0, err = 0;
@@ -903,7 +903,7 @@
 	return cpu_to_be32(ttt);
 }
 
-static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
+static void scsi_cmnd_start(struct iscsi_conn *conn, struct istgt_cmd *req)
 {
 	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 
@@ -990,10 +990,10 @@
 	return;
 }
 
-static void data_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
+static void data_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
 {
 	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
-	struct iscsi_cmnd *scsi_cmnd = NULL;
+	struct istgt_cmd *scsi_cmnd = NULL;
 	uint32_t offset = be32_to_cpu(req->offset);
 
 	update_stat_sn(cmnd);
@@ -1041,10 +1041,10 @@
 	return;
 }
 
-static void data_out_end(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
+static void data_out_end(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
 {
 	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
-	struct iscsi_cmnd *scsi_cmnd;
+	struct istgt_cmd *scsi_cmnd;
 	uint32_t offset;
 
 	BUG_ON(!cmnd);
@@ -1088,7 +1088,7 @@
 	return;
 }
 
-/* static int __cmnd_abort(struct iscsi_cmnd *cmnd) */
+/* static int __cmnd_abort(struct istgt_cmd *cmnd) */
 /* { */
 /* 	if (!cmnd_waitio(cmnd)) { */
 /* 		cmnd_release(cmnd, 1); */
@@ -1099,7 +1099,7 @@
 
 /* static int cmnd_abort(struct iscsi_session *session, u32 itt) */
 /* { */
-/* 	struct iscsi_cmnd *cmnd; */
+/* 	struct istgt_cmd *cmnd; */
 /* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
 
 /* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
@@ -1113,12 +1113,12 @@
 /* 	return err; */
 /* } */
 
-/* static int target_reset(struct iscsi_cmnd *req, u32 lun, int all) */
+/* static int target_reset(struct istgt_cmd *req, u32 lun, int all) */
 /* { */
 /* 	struct iscsi_target *target = req->conn->session->target; */
 /* 	struct iscsi_session *session; */
 /* 	struct iscsi_conn *conn; */
-/* 	struct iscsi_cmnd *cmnd, *tmp; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
 
 /* 	list_for_each_entry(session, &target->session_list, list) { */
 /* 		list_for_each_entry(conn, &session->conn_list, list) { */
@@ -1137,11 +1137,11 @@
 /* 	return 0; */
 /* } */
 
-/* static void task_set_abort(struct iscsi_cmnd *req) */
+/* static void task_set_abort(struct istgt_cmd *req) */
 /* { */
 /* 	struct iscsi_session *session = req->conn->session; */
 /* 	struct iscsi_conn *conn; */
-/* 	struct iscsi_cmnd *cmnd, *tmp; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
 
 /* 	list_for_each_entry(conn, &session->conn_list, list) { */
 /* 		list_for_each_entry_safe(cmnd, tmp, &conn->pdu_list, conn_list) { */
@@ -1151,11 +1151,11 @@
 /* 	} */
 /* } */
 
-static void execute_task_management(struct iscsi_cmnd *req)
+static void execute_task_management(struct istgt_cmd *req)
 {
 /* 	struct iscsi_conn *conn = req->conn; */
 /* 	struct iscsi_target *target = conn->session->target; */
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
 	struct iscsi_tm_rsp *rsp_hdr;
 	int function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
@@ -1218,9 +1218,9 @@
 	iscsi_cmnd_init_write(rsp);
 }
 
-static void noop_out_exec(struct iscsi_cmnd *req)
+static void noop_out_exec(struct istgt_cmd *req)
 {
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_nopin *rsp_hdr;
 
 	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
@@ -1249,10 +1249,10 @@
 		iscsi_cmnd_remove(req);
 }
 
-static void logout_exec(struct iscsi_cmnd *req)
+static void logout_exec(struct istgt_cmd *req)
 {
 	struct iscsi_logout *req_hdr;
-	struct iscsi_cmnd *rsp;
+	struct istgt_cmd *rsp;
 	struct iscsi_logout_rsp *rsp_hdr;
 
 	req_hdr = (struct iscsi_logout *)&req->pdu.bhs;
@@ -1265,7 +1265,7 @@
 	iscsi_cmnd_init_write(rsp);
 }
 
-static void iscsi_cmnd_exec(struct iscsi_cmnd *cmnd)
+static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
 {
 	dprintk("%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
 		cmnd->pdu.bhs.statsn);
@@ -1309,7 +1309,7 @@
 	conn->write_size += size;
 }
 
-static void cmnd_send_pdu(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
+static void cmnd_send_pdu(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
 {
 	uint32_t size;
 
@@ -1332,9 +1332,9 @@
 	set_fs(oldfs);
 }
 
-void cmnd_release(struct iscsi_cmnd *cmnd, int force)
+void cmnd_release(struct istgt_cmd *cmnd, int force)
 {
-	struct iscsi_cmnd *req, *rsp;
+	struct istgt_cmd *req, *rsp;
 	int is_last = 0;
 
 	if (!cmnd)
@@ -1345,7 +1345,7 @@
 
 	if (force) {
 		while (!list_empty(&cmnd->pdu_list)) {
-			rsp = list_entry(cmnd->pdu_list.next, struct iscsi_cmnd, pdu_list);
+			rsp = list_entry(cmnd->pdu_list.next, struct istgt_cmd, pdu_list);
 			list_del_init(&rsp->list);
 			list_del(&rsp->pdu_list);
 			iscsi_cmnd_remove(rsp);
@@ -1368,7 +1368,7 @@
 	return;
 }
 
-void cmnd_tx_start(struct iscsi_cmnd *cmnd)
+void cmnd_tx_start(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iovec *iop;
@@ -1436,7 +1436,7 @@
 	conn->write_size = (conn->write_size + 3) & -4;
 }
 
-void cmnd_tx_end(struct iscsi_cmnd *cmnd)
+void cmnd_tx_end(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
@@ -1474,7 +1474,7 @@
  * @cmnd: ptr to command
  */
 
-static void iscsi_session_push_cmnd(struct iscsi_cmnd *cmnd)
+static void iscsi_session_push_cmnd(struct istgt_cmd *cmnd)
 {
 	struct iscsi_session *session = cmnd->conn->session;
 	struct list_head *entry;
@@ -1497,7 +1497,7 @@
 
 			if (list_empty(&session->pending_list))
 				break;
-			cmnd = list_entry(session->pending_list.next, struct iscsi_cmnd, list);
+			cmnd = list_entry(session->pending_list.next, struct istgt_cmd, list);
 			if (cmnd->pdu.bhs.statsn != cmd_sn)
 				break;
 /* 			eprintk("find out-of-order %x %u %u\n", */
@@ -1517,7 +1517,7 @@
 			eprintk("too large cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
 
 		list_for_each(entry, &session->pending_list) {
-			struct iscsi_cmnd *tmp = list_entry(entry, struct iscsi_cmnd, list);
+			struct istgt_cmd *tmp = list_entry(entry, struct istgt_cmd, list);
 			if (before(cmd_sn, tmp->pdu.bhs.statsn))
 				break;
 		}
@@ -1528,7 +1528,7 @@
 	}
 }
 
-static int check_segment_length(struct iscsi_cmnd *cmnd)
+static int check_segment_length(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_sess_param *param = &conn->session->param;
@@ -1546,7 +1546,7 @@
 	return 0;
 }
 
-void cmnd_rx_start(struct iscsi_cmnd *cmnd)
+void cmnd_rx_start(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	int err = 0;
@@ -1586,7 +1586,7 @@
 	}
 }
 
-void cmnd_rx_end(struct iscsi_cmnd *cmnd)
+void cmnd_rx_end(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
@@ -1620,7 +1620,7 @@
 
 static int buffer_ready(struct tgt_cmd *tc)
 {
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
 
 	complete(&cmnd->event);
 
@@ -1716,7 +1716,7 @@
 	       VERSION_STRING);
 
 	istgt_cmd_cache = kmem_cache_create("istgt_cmd",
-					    sizeof(struct iscsi_cmnd),
+					    sizeof(struct istgt_cmd),
 					    0, 0, NULL, NULL);
 	if (!istgt_cmd_cache)
 		return -ENOMEM;

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 09:31:00 UTC (rev 157)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 09:44:00 UTC (rev 158)
@@ -58,7 +58,7 @@
 	void (*old_data_ready)(struct sock *, int);
 };
 
-struct iscsi_cmnd;
+struct istgt_cmd;
 
 enum iscsi_device_state {
 	IDEV_RUNNING,
@@ -134,14 +134,14 @@
 	struct list_head pdu_list;		/* in/outcoming pdus */
 	struct list_head write_list;		/* list of data pdus to be sent */
 
-	struct iscsi_cmnd *read_cmnd;
+	struct istgt_cmd *read_cmnd;
 	struct msghdr read_msg;
 	struct iovec read_iov[ISCSI_CONN_IOV_MAX];
 	uint32_t read_size;
 	uint32_t read_overflow;
 	int read_state;
 
-	struct iscsi_cmnd *write_cmnd;
+	struct istgt_cmd *write_cmnd;
 	struct iovec write_iov[ISCSI_CONN_IOV_MAX];
 	struct iovec *write_iop;
 
@@ -162,7 +162,7 @@
 	unsigned int datasize;
 };
 
-struct iscsi_cmnd {
+struct istgt_cmd {
 	struct list_head list;
 	struct list_head conn_list;
 	unsigned long state;
@@ -188,7 +188,7 @@
 	struct work_struct work;
 	struct completion event;
 
-	struct iscsi_cmnd *req;
+	struct istgt_cmd *req;
 	struct tgt_cmd *tc;
 };
 
@@ -198,13 +198,13 @@
 #define ISCSI_OP_SCSI_ABORT	ISCSI_OP_VENDOR4_CMD
 
 /* iscsi.c */
-extern struct iscsi_cmnd *cmnd_alloc(struct iscsi_conn *, int);
-extern void cmnd_rx_start(struct iscsi_cmnd *);
-extern void cmnd_rx_end(struct iscsi_cmnd *);
-extern void cmnd_tx_start(struct iscsi_cmnd *);
-extern void cmnd_tx_end(struct iscsi_cmnd *);
-extern void cmnd_release(struct iscsi_cmnd *, int);
-extern void send_scsi_rsp(struct iscsi_cmnd *);
+extern struct istgt_cmd *cmnd_alloc(struct iscsi_conn *, int);
+extern void cmnd_rx_start(struct istgt_cmd *);
+extern void cmnd_rx_end(struct istgt_cmd *);
+extern void cmnd_tx_start(struct istgt_cmd *);
+extern void cmnd_tx_end(struct istgt_cmd *);
+extern void cmnd_release(struct istgt_cmd *, int);
+extern void send_scsi_rsp(struct istgt_cmd *);
 
 /* conn.c */
 extern int conn_add(struct iscsi_session *, struct conn_info *);

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-11-05 09:31:00 UTC (rev 157)
+++ trunk/istgt/kernel/nthread.c	2005-11-05 09:44:00 UTC (rev 158)
@@ -40,20 +40,20 @@
 	conn->read_size = (len + 3) & -4;
 }
 
-static void iscsi_conn_read_ahs(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
+static void iscsi_conn_read_ahs(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
 {
 	cmnd->pdu.ahs = kmalloc(cmnd->pdu.ahssize, __GFP_NOFAIL|GFP_KERNEL);
 	BUG_ON(!cmnd->pdu.ahs);
 	iscsi_conn_init_read(conn, cmnd->pdu.ahs, cmnd->pdu.ahssize);
 }
 
-static struct iscsi_cmnd * iscsi_get_send_cmnd(struct iscsi_conn *conn)
+static struct istgt_cmd * iscsi_get_send_cmnd(struct iscsi_conn *conn)
 {
-	struct iscsi_cmnd *cmnd = NULL;
+	struct istgt_cmd *cmnd = NULL;
 
 	spin_lock(&conn->list_lock);
 	if (!list_empty(&conn->write_list)) {
-		cmnd = list_entry(conn->write_list.next, struct iscsi_cmnd, list);
+		cmnd = list_entry(conn->write_list.next, struct istgt_cmd, list);
 		list_del_init(&cmnd->list);
 	}
 	spin_unlock(&conn->list_lock);
@@ -162,7 +162,7 @@
 
 static void rx_ddigest(struct iscsi_conn *conn, int state)
 {
-	struct iscsi_cmnd *cmnd = conn->read_cmnd;
+	struct istgt_cmd *cmnd = conn->read_cmnd;
 	int res = digest_rx_data(cmnd);
 
 	if (!res)
@@ -173,7 +173,7 @@
 
 static void rx_hdigest(struct iscsi_conn *conn, int state)
 {
-	struct iscsi_cmnd *cmnd = conn->read_cmnd;
+	struct istgt_cmd *cmnd = conn->read_cmnd;
 	int res = digest_rx_header(cmnd);
 
 	if (!res)
@@ -182,9 +182,9 @@
 		conn_close(conn);
 }
 
-static struct iscsi_cmnd *create_cmnd(struct iscsi_conn *conn)
+static struct istgt_cmd *create_cmnd(struct iscsi_conn *conn)
 {
-	struct iscsi_cmnd *cmnd;
+	struct istgt_cmd *cmnd;
 
 	cmnd = cmnd_alloc(conn, 1);
 	iscsi_conn_init_read(cmnd->conn, &cmnd->pdu.bhs, sizeof(cmnd->pdu.bhs));
@@ -195,7 +195,7 @@
 
 static int recv(struct iscsi_conn *conn)
 {
-	struct iscsi_cmnd *cmnd = conn->read_cmnd;
+	struct istgt_cmd *cmnd = conn->read_cmnd;
 	int hdigest, ddigest, res = 1;
 
 	if (!test_bit(CONN_ACTIVE, &conn->state))
@@ -428,7 +428,7 @@
 	}
 }
 
-static int tx_ddigest(struct iscsi_cmnd *cmnd, int state)
+static int tx_ddigest(struct istgt_cmd *cmnd, int state)
 {
 	int res, rest = cmnd->conn->write_size;
 	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
@@ -449,7 +449,7 @@
 	return res;
 }
 
-static void init_tx_hdigest(struct iscsi_cmnd *cmnd)
+static void init_tx_hdigest(struct istgt_cmd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iovec *iop;
@@ -495,7 +495,7 @@
 
 static int send(struct iscsi_conn *conn)
 {
-	struct iscsi_cmnd *cmnd = conn->write_cmnd;
+	struct istgt_cmd *cmnd = conn->write_cmnd;
 	int ddigest, res = 0;
 
 	ddigest = conn->ddigest_type != DIGEST_NONE ? 1 : 0;
@@ -574,7 +574,7 @@
 static void close_conn(struct iscsi_conn *conn)
 {
 	struct iscsi_session *session = conn->session;
-	struct iscsi_cmnd *cmnd;
+	struct istgt_cmd *cmnd;
 
 	conn->sock->ops->shutdown(conn->sock, 2);
 
@@ -591,7 +591,7 @@
 		yield();
 
 	while (!list_empty(&conn->pdu_list)) {
-		cmnd = list_entry(conn->pdu_list.next, struct iscsi_cmnd, conn_list);
+		cmnd = list_entry(conn->pdu_list.next, struct istgt_cmd, conn_list);
 
 		list_del_init(&cmnd->list);
 		cmnd_release(cmnd, 1);



From tomo at berlios.de  Sat Nov  5 11:05:01 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 11:05:01 +0100
Subject: [Stgt-svn] r159 - trunk/istgt/kernel
Message-ID: <200511051005.jA5A51WB007720@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 11:05:00 +0100 (Sat, 05 Nov 2005)
New Revision: 159

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
Log:
Minor cleanups of iscsi.h (kill state in struct istgt_cmd because it
is not used at all and rename write_tcmnd write_sg).


Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 09:44:00 UTC (rev 158)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 10:05:00 UTC (rev 159)
@@ -135,9 +135,9 @@
 	LIST_HEAD(head);
 
 	if (!list_empty(&cmnd->list)) {
-		eprintk("%x %x %x %x %lx %lx %u %u %u %u %u %u %u %d %d\n",
+		eprintk("%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n",
 			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
-			cmd_scsicode(cmnd), cmnd->state, cmnd->flags,
+			cmd_scsicode(cmnd), cmnd->flags,
 			cmnd->r2t_sn, cmnd->r2t_length, cmnd->is_unsolicited_data,
 			cmnd->target_task_tag, cmnd->outstanding_r2t,
 			cmnd->hdigest, cmnd->ddigest,
@@ -344,16 +344,15 @@
 	if (!list_empty(&cmnd->list)) {
 		struct iscsi_cmd *req = cmd_hdr(cmnd);
 
-		eprintk("cmnd %p still on some list?, %x, %x, %x, %x, %x, %x, %x %lx %lx\n",
+		eprintk("cmnd %p still on some list?, %x %x %x %x %x %x %x %lx\n",
 			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
-			be32_to_cpu(req->data_length),
-			req->cmdsn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
+			be32_to_cpu(req->data_length), req->cmdsn,
+			be32_to_cpu(cmnd->pdu.datasize), conn->state);
 
 		if (cmnd->req) {
 			struct iscsi_cmd *req = cmd_hdr(cmnd->req);
 			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
 		}
-		dump_stack();
 		BUG();
 	}
 	list_del(&cmnd->list);
@@ -1304,7 +1303,7 @@
 /* 	assert(offset <= sg->offset + tio->size); */
 /* 	assert(offset + size <= tio->offset + tio->size); */
 
-	conn->write_tcmnd = sg;
+	conn->write_sg = sg;
 	conn->write_offset = offset;
 	conn->write_size += size;
 }

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 09:44:00 UTC (rev 158)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 10:05:00 UTC (rev 159)
@@ -145,7 +145,7 @@
 	struct iovec write_iov[ISCSI_CONN_IOV_MAX];
 	struct iovec *write_iop;
 
-	struct scatterlist *write_tcmnd;
+	struct scatterlist *write_sg;
 
 	uint32_t write_size;
 	uint32_t write_offset;
@@ -165,7 +165,6 @@
 struct istgt_cmd {
 	struct list_head list;
 	struct list_head conn_list;
-	unsigned long state;
 	unsigned long flags;
 	struct iscsi_conn *conn;
 

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-11-05 09:44:00 UTC (rev 158)
+++ trunk/istgt/kernel/nthread.c	2005-11-05 10:05:00 UTC (rev 159)
@@ -343,8 +343,9 @@
 		}
 	}
 
-	if (!(sg = conn->write_tcmnd)) {
-		eprintk("%s\n", "warning data missing!");
+	sg = conn->write_sg;
+	if (!sg) {
+		eprintk("warning data missing!\n");
 		return 0;
 	}
 	offset = conn->write_offset;
@@ -370,7 +371,7 @@
 				goto err;
 			}
 			if (res == size) {
-				conn->write_tcmnd = NULL;
+				conn->write_sg = NULL;
 				conn->write_size = 0;
 				return saved_size;
 			}



From tomo at berlios.de  Sat Nov  5 11:08:17 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 11:08:17 +0100
Subject: [Stgt-svn] r160 - trunk/istgt/kernel
Message-ID: <200511051008.jA5A8HuE008416@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 11:08:14 +0100 (Sat, 05 Nov 2005)
New Revision: 160

Modified:
   trunk/istgt/kernel/iscsi.h
Log:
Kill unused stuff in iscsi.h.

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 10:05:00 UTC (rev 159)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 10:08:14 UTC (rev 160)
@@ -60,11 +60,6 @@
 
 struct istgt_cmd;
 
-enum iscsi_device_state {
-	IDEV_RUNNING,
-	IDEV_DEL,
-};
-
 struct iscsi_target {
 	int tid;
 
@@ -257,7 +252,6 @@
 	CMD_final,
 	CMD_waitio,
 	CMD_close,
-	CMD_lunit,
 	CMD_pending,
 };
 



From tomo at berlios.de  Sat Nov  5 11:15:30 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 11:15:30 +0100
Subject: [Stgt-svn] r161 - trunk/istgt/kernel
Message-ID: <200511051015.jA5AFU69008900@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 11:15:24 +0100 (Sat, 05 Nov 2005)
New Revision: 161

Modified:
   trunk/istgt/kernel/iscsi.c
Log:
Rename cmnd_opcode cmd_opcode again.

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 10:08:14 UTC (rev 160)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 10:15:24 UTC (rev 161)
@@ -118,7 +118,7 @@
 	list_for_each_safe(pos, next, send) {
 		cmnd = list_entry(pos, struct istgt_cmd, list);
 
-		dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
+		dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
 
 		list_del_init(&cmnd->list);
 		BUG_ON(conn != cmnd->conn);
@@ -376,7 +376,7 @@
 
 	BUG_ON(1);
 
-/* 	eprintk("%x %x %x %u\n", cmd_itt(cmnd), cmnd_opcode(cmnd), */
+/* 	eprintk("%x %x %x %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
 /* 		cmd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
 
 /* 	if (!(size = cmnd->pdu.datasize)) */
@@ -446,7 +446,7 @@
 	uint32_t exp_stat_sn;
 
 	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
-	dprintk("%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
+	dprintk("%x,%x\n", cmd_opcode(cmnd), exp_stat_sn);
 	if ((int32_t) (exp_stat_sn - conn->exp_stat_sn) > 0 &&
 	    (int32_t) (exp_stat_sn - conn->stat_sn) <= 0) {
 		// free pdu resources
@@ -1102,7 +1102,7 @@
 /* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
 
 /* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
-/* 		eprintk("%x %x %x %u %u %u %u\n", cmd_itt(cmnd), cmnd_opcode(cmnd), */
+/* 		eprintk("%x %x %x %u %u %u %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
 /* 			cmnd->r2t_length, cmnd_scsicode(cmnd), */
 /* 			cmnd_write_size(cmnd), cmnd->is_unsolicited_data, */
 /* 			cmnd->outstanding_r2t); */
@@ -1266,7 +1266,7 @@
 
 static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
 {
-	dprintk("%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
+	dprintk("%p,%x,%u\n", cmnd, cmd_opcode(cmnd),
 		cmnd->pdu.bhs.statsn);
 
 	switch (cmd_opcode(cmnd)) {
@@ -1372,7 +1372,7 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iovec *iop;
 
-	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
 	BUG_ON(!cmnd);
 	iscsi_cmnd_set_length(&cmnd->pdu);
 



From tomo at berlios.de  Sat Nov  5 11:27:03 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 11:27:03 +0100
Subject: [Stgt-svn] r162 - trunk/istgt/kernel
Message-ID: <200511051027.jA5AR3Cs009779@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 11:27:02 +0100 (Sat, 05 Nov 2005)
New Revision: 162

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
Log:
send_scsi_rsp() can be static now.

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 10:15:24 UTC (rev 161)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 10:27:02 UTC (rev 162)
@@ -231,7 +231,7 @@
 	return rsp;
 }
 
-void send_scsi_rsp(struct istgt_cmd *req)
+static void send_scsi_rsp(struct istgt_cmd *req)
 {
 	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 10:15:24 UTC (rev 161)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 10:27:02 UTC (rev 162)
@@ -198,7 +198,6 @@
 extern void cmnd_tx_start(struct istgt_cmd *);
 extern void cmnd_tx_end(struct istgt_cmd *);
 extern void cmnd_release(struct istgt_cmd *, int);
-extern void send_scsi_rsp(struct istgt_cmd *);
 
 /* conn.c */
 extern int conn_add(struct iscsi_session *, struct conn_info *);



From tomo at berlios.de  Sat Nov  5 11:39:01 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 11:39:01 +0100
Subject: [Stgt-svn] r163 - trunk/istgt/kernel
Message-ID: <200511051039.jA5Ad10x011597@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 11:38:59 +0100 (Sat, 05 Nov 2005)
New Revision: 163

Modified:
   trunk/istgt/kernel/config.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
Log:
Kill tid struct iscsi_target. We use tgt's tid instead.


Modified: trunk/istgt/kernel/config.c
===================================================================
--- trunk/istgt/kernel/config.c	2005-11-05 10:27:02 UTC (rev 162)
+++ trunk/istgt/kernel/config.c	2005-11-05 10:38:59 UTC (rev 163)
@@ -77,12 +77,12 @@
 	return err;
 }
 
-int event_send(struct tgt_target *tgt, int tid, uint64_t sid, uint32_t cid,
+int event_send(struct tgt_target *tgt, uint64_t sid, uint32_t cid,
 	       uint32_t state)
 {
 	struct iet_msg msg;
 
-	msg.k.conn_state_change.tid = tid;
+	msg.k.conn_state_change.tid = tgt->tid;
 	msg.k.conn_state_change.sid = sid;
 	msg.k.conn_state_change.cid = cid;
 	msg.k.conn_state_change.state = state;

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-05 10:27:02 UTC (rev 162)
+++ trunk/istgt/kernel/iscsi.c	2005-11-05 10:38:59 UTC (rev 163)
@@ -1659,7 +1659,6 @@
 	struct iscsi_target *target = tt->tt_data;
 
 	target->tt = tt;
-	target->tid = target->tt->tid;
 
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 10:27:02 UTC (rev 162)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 10:38:59 UTC (rev 163)
@@ -61,8 +61,6 @@
 struct istgt_cmd;
 
 struct iscsi_target {
-	int tid;
-
 	struct iscsi_sess_param sess_param;
 	struct iscsi_trgt_param trgt_param;
 
@@ -213,7 +211,7 @@
 
 /* config.c */
 extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
-extern int event_send(struct tgt_target *tgt, int tid, uint64_t sid,
+extern int event_send(struct tgt_target *tgt, uint64_t sid,
 		      uint32_t cid, uint32_t state);
 
 /* session.c */

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-11-05 10:27:02 UTC (rev 162)
+++ trunk/istgt/kernel/nthread.c	2005-11-05 10:38:59 UTC (rev 163)
@@ -606,10 +606,9 @@
 	}
 
 	eprintk("%d %" PRIu64 " %u\n",
-		session->target->tid, session->sid, conn->cid);
+		session->target->tt->tid, session->sid, conn->cid);
 
-	event_send(session->target->tt, session->target->tid,
-		   session->sid, conn->cid, E_CONN_CLOSE);
+	event_send(session->target->tt, session->sid, conn->cid, E_CONN_CLOSE);
 	conn_free(conn);
 
 	if (list_empty(&session->conn_list))
@@ -674,11 +673,11 @@
 	struct task_struct *task;
 
 	if (info->task) {
-		eprintk("Target (%u) already runs\n", target->tid);
+		eprintk("Target (%u) already runs\n", target->tt->tid);
 		return -EALREADY;
 	}
 
-	task = kthread_run(istd, target, "istd%d", target->tid);
+	task = kthread_run(istd, target, "istd%d", target->tt->tid);
 
 	if (IS_ERR(task))
 		err = PTR_ERR(task);



From tomo at berlios.de  Sat Nov  5 12:14:15 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 5 Nov 2005 12:14:15 +0100
Subject: [Stgt-svn] r164 - trunk/istgt/kernel
Message-ID: <200511051114.jA5BEF9p017052@sheep.berlios.de>

Author: tomo
Date: 2005-11-05 12:14:14 +0100 (Sat, 05 Nov 2005)
New Revision: 164

Modified:
   trunk/istgt/kernel/iscsi.h
Log:
Minor cleanups of iscsi.h

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-05 10:38:59 UTC (rev 163)
+++ trunk/istgt/kernel/iscsi.h	2005-11-05 11:14:14 UTC (rev 164)
@@ -236,11 +236,11 @@
 	hton24(pdu->bhs.dlength, pdu->datasize);
 }
 
-#define cmd_hdr(cmd) ((struct iscsi_cmd *) (&((cmd)->pdu.bhs)))
-#define cmd_ttt(cmd) cpu_to_be32((cmd)->pdu.bhs.ttt)
-#define cmd_itt(cmd) cpu_to_be32((cmd)->pdu.bhs.itt)
-#define cmd_opcode(cmd) ((cmd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
-#define cmd_scsicode(cmd) cmd_hdr(cmd)->cdb[0]
+#define cmd_hdr(cmd)		((struct iscsi_cmd *) (&((cmd)->pdu.bhs)))
+#define cmd_ttt(cmd)		cpu_to_be32((cmd)->pdu.bhs.ttt)
+#define cmd_itt(cmd)		cpu_to_be32((cmd)->pdu.bhs.itt)
+#define cmd_opcode(cmd)		((cmd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
+#define cmd_scsicode(cmd)	cmd_hdr(cmd)->cdb[0]
 
 #define	SECTOR_SIZE_BITS	9
 
@@ -253,16 +253,16 @@
 };
 
 #define set_cmd_hashed(cmd)	set_bit(CMD_hashed, &(cmd)->flags)
-#define cmd_hashed(cmd)	test_bit(CMD_hashed, &(cmd)->flags)
+#define cmd_hashed(cmd)		test_bit(CMD_hashed, &(cmd)->flags)
 
 #define set_cmd_final(cmd)	set_bit(CMD_final, &(cmd)->flags)
-#define cmd_final(cmd)	test_bit(CMD_final, &(cmd)->flags)
+#define cmd_final(cmd)		test_bit(CMD_final, &(cmd)->flags)
 
 #define set_cmd_waitio(cmd)	set_bit(CMD_waitio, &(cmd)->flags)
-#define cmd_waitio(cmd)	test_bit(CMD_waitio, &(cmd)->flags)
+#define cmd_waitio(cmd)		test_bit(CMD_waitio, &(cmd)->flags)
 
 #define set_cmd_close(cmd)	set_bit(CMD_close, &(cmd)->flags)
-#define cmd_close(cmd)	test_bit(CMD_close, &(cmd)->flags)
+#define cmd_close(cmd)		test_bit(CMD_close, &(cmd)->flags)
 
 #define set_cmd_pending(cmd)	set_bit(CMD_pending, &(cmd)->flags)
 #define clear_cmd_pending(cmd)	clear_bit(CMD_pending, &(cmd)->flags)



From mnc at berlios.de  Sun Nov 13 09:43:39 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sun, 13 Nov 2005 09:43:39 +0100
Subject: [Stgt-svn] r165 - in trunk: include kernel
Message-ID: <200511130843.jAD8hdLT006011@sheep.berlios.de>

Author: mnc
Date: 2005-11-13 09:43:34 +0100 (Sun, 13 Nov 2005)
New Revision: 165

Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
Log:
*** note this may break svn for a while *** use request_queue as message passing queue so we can share code for scattertlists and tags with the block layer

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/include/tgt_if.h	2005-11-13 08:43:34 UTC (rev 165)
@@ -49,6 +49,8 @@
 			uint64_t dev_id;
 		} d_device;
 		struct {
+			int tid;
+			uint64_t dev_id;
 			uint64_t cid;
 			uint32_t len;
 			int result;

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt.c	2005-11-13 08:43:34 UTC (rev 165)
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/mempool.h>
 #include <linux/netlink.h>
+#include <linux/blkdev.h>
 #include <linux/file.h>
 #include <asm/scatterlist.h>
 #include <net/tcp.h>
@@ -38,12 +39,6 @@
 static int tgtd_pid;
 static struct sock *nls;
 
-/* TODO: lock per session */
-static spinlock_t cmd_hash_lock;
-#define TGT_HASH_ORDER		8
-#define	cmd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
-static struct list_head cmd_hash[1 << TGT_HASH_ORDER];
-
 static struct target_type_internal *target_template_get(const char *name)
 {
 	unsigned long flags;
@@ -96,6 +91,26 @@
 	if (err)
 		goto proto_put;
 
+	/* set some defaults if not set */
+
+	/*
+	 * If the driver imposes no hard sector transfer limit, start at
+	 * machine infinity initially.
+	 */
+	if (!tt->max_sectors)
+		tt->max_sectors = TGT_DEFAULT_MAX_SECTORS;
+	/*
+	 * assume a 4GB boundary, if not set
+	 */
+	if (!tt->seg_boundary_mask)
+		tt->seg_boundary_mask = 0xffffffff;
+
+	if (!tt->max_segment_size)
+		tt->max_segment_size = MAX_SEGMENT_SIZE;
+
+	if (!tt->max_hw_segments)
+		tt->max_hw_segments = MAX_HW_SEGMENTS;
+
 	spin_lock_irqsave(&target_tmpl_lock, flags);
 	list_add_tail(&ti->list, &target_tmpl_list);
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
@@ -431,6 +446,122 @@
 }
 EXPORT_SYMBOL_GPL(tgt_device_find);
 
+static void tgt_request_fn(struct request_queue *q)
+{
+	struct tgt_target *target;
+	struct tgt_cmd *cmd;
+	struct request *rq;
+	int err;
+
+	while ((rq = elv_next_request(q)) != NULL) {
+		/* we need to set state or refcount under this lock! */
+		cmd = rq->special;
+
+		/*
+		 * the iosched nicely ordered these, should we try to keep the
+		 * ordering or for most cases will it not make a difference
+		 * since the lower levels will iosched again (not for
+		 * passthrough though). Maybe we should use a tgt_device
+		 * flag to indicate what is best for the real device.
+		 */
+		if (atomic_read(&cmd->state) != TGT_CMD_READY)
+			break;
+		/*
+		 * hit queue depth (command completion will run the
+		 * queue again
+		 */
+		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
+			break;
+		blkdev_dequeue_request(rq);
+
+		spin_unlock_irq(q->queue_lock);
+
+		/*
+		 * TODO: kill cid. We can use the request queue tag instead
+		 */
+		dprintk("cmd %p tag %d\n", cmd, rq->tag);
+
+		target = cmd->session->target;
+	        err = target->proto->execute_cmd(cmd);
+	        switch (err) {
+	        case TGT_CMD_FAILED:
+		case TGT_CMD_COMPLETED:
+			dprintk("command completed %d\n", err);
+			tgt_transfer_response(cmd);
+		default:
+			dprintk("command %d queued to real dev\n", rq->tag);
+		}
+
+		spin_lock_irq(q->queue_lock);
+	}
+}
+
+#define min_not_zero(l, r) (l == 0) ? r : ((r == 0) ? l : min(l, r))
+
+static int tgt_setup_queue(struct tgt_device *device)
+{
+	struct io_restrictions *limits = &device->limits;
+	struct tgt_target_template *tt = device->target->tt;
+	struct request_queue *q;
+
+	int err;
+
+	q = blk_init_queue(tgt_request_fn, NULL);
+	if (!q)
+		return -ENOMEM;
+	device->q = q;
+	q->queuedata = device;
+	/*
+	 * this is a tmp hack: we do not register this queue
+	 * becuase we do not have a proper parent. We can remove
+	 * this code and do this from userspace when the queue's parent
+	 * is not the gendisk.
+	 */
+	elevator_exit(q->elevator);
+	/*
+	 * for the virtual devices iosched happens there, and for passthru
+	 * devs we do noop for now (do we need to since the initiator does
+	 * ioscheduling)
+	 */
+	err = elevator_init(q, "noop");
+	if (err) {
+		blk_cleanup_queue(q);
+		return err;
+	}
+
+	blk_queue_max_sectors(q, min_not_zero(tt->max_sectors,
+					limits->max_sectors));
+	blk_queue_max_phys_segments(q, min_not_zero(limits->max_phys_segments,
+					(unsigned short)TGT_MAX_PHYS_SEGMENTS));
+	blk_queue_max_hw_segments(q, min_not_zero(tt->max_hw_segments,
+					limits->max_hw_segments));
+	blk_queue_max_segment_size(q, min_not_zero(tt->max_segment_size,
+					limits->max_segment_size));
+	blk_queue_segment_boundary(q, min_not_zero(tt->seg_boundary_mask,
+					limits->seg_boundary_mask));
+	if (!tt->use_clustering || !device->use_clustering)
+		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+
+	dprintk("max_sectors %u\n", q->max_sectors);
+	dprintk("max_phys_segments %u\n", q->max_phys_segments);
+	dprintk("max_hw_segments %u\n", q->max_hw_segments);
+	dprintk("max_segment_size %u\n", q->max_segment_size);
+	dprintk("seg_boundary_mask %lx\n", q->seg_boundary_mask);
+	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
+		dprintk("clustering set\n");
+	else
+		dprintk("clustering not set\n");
+
+	/* who should set this limit ? */
+	err = blk_queue_init_tags(q, TGT_QUEUE_DEPTH, NULL);
+	if (err) {
+		blk_cleanup_queue(q);
+		return err;
+	}
+
+	return 0;
+}
+
 static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags)
 {
@@ -481,15 +612,20 @@
 	if (target->proto->attach_device)
 		target->proto->attach_device(device->pt_data);
 
-	if (tgt_sysfs_register_device(device))
+	if (tgt_setup_queue(device))
 		goto dt_destroy;
 
+	if (tgt_sysfs_register_device(device))
+		goto cleaup_queue;
+
 	spin_lock_irqsave(&target->lock, flags);
 	list_add(&device->dlist, &target->device_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return 0;
 
+cleaup_queue:
+	blk_cleanup_queue(device->q);
 dt_destroy:
 	if (device->dt->destroy)
 		device->dt->destroy(device);
@@ -506,6 +642,25 @@
 	return -EINVAL;
 }
 
+void tgt_device_free(struct tgt_device *device)
+{
+	struct tgt_target *target = device->target;
+
+	if (device->dt->destroy)
+		device->dt->destroy(device);
+
+	if (target->proto->detach_device)
+		target->proto->detach_device(device->pt_data);
+
+	blk_cleanup_queue(device->q);
+	fput(device->file);
+	device_template_put(device->dt);
+
+	kfree(device->dt_data);
+	kfree(device->pt_data);
+	kfree(device);
+}
+
 static int tgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct tgt_device *device;
@@ -523,19 +678,62 @@
 		return -EINVAL;
 
 	list_del(&device->dlist);
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-
-	if (target->proto->detach_device)
-		target->proto->detach_device(device->pt_data);
-
-	fput(device->file);
-	device_template_put(device->dt);
 	tgt_sysfs_unregister_device(device);
 
 	return 0;
 }
 
+static void tgt_free_buffer(struct tgt_cmd *cmd)
+{
+	int i;
+
+	for (i = 0; i < cmd->sg_count; i++)
+		__free_page(cmd->sg[i].page);
+	kfree(cmd->sg);
+}
+
+static void __tgt_cmd_destroy(void *data)
+{
+	struct tgt_cmd *cmd = data;
+	struct request *rq = cmd->rq;
+	struct request_queue *q = NULL;
+	unsigned long flags;
+
+	if (rq) {
+		q = rq->q;
+
+		dprintk("tag %d\n", rq->tag);
+
+		spin_lock_irqsave(q->queue_lock, flags);
+		if (blk_rq_tagged(rq))
+			blk_queue_end_tag(q, rq);
+		end_that_request_last(rq);
+		spin_unlock_irqrestore(q->queue_lock, flags);
+	}
+
+	mempool_free(cmd, cmd->session->cmd_pool);
+
+	if (q)
+		blk_run_queue(q);
+}
+
+static void tgt_cmd_destroy(struct tgt_cmd *cmd)
+{
+	dprintk("cmd %p\n", cmd);
+
+	tgt_free_buffer(cmd);
+
+	/*
+	 * Goose the queue incase we are blocked on a queue depth
+	 * limit or resource problem.
+	 *
+	 * This is run from a interrpt handler normally so we queue
+	 * the work
+	 */
+	INIT_WORK(&cmd->work, __tgt_cmd_destroy, cmd);
+	queue_work(cmd->session->target->twq, &cmd->work);
+}
+
 void tgt_transfer_response(void *data)
 {
 	struct tgt_cmd *cmd = data;
@@ -558,41 +756,13 @@
 		queue_delayed_work(cmd->session->target->twq, &cmd->work,
 				   10 * HZ);
 		break;
-	};
+	}
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
-static void queuecommand(void *data)
-{
-	int err = 0;
-	struct tgt_cmd *cmd = data;
-	struct tgt_target *target = cmd->session->target;
-	struct tgt_device *device = cmd->device;
-
-	dprintk("cid %" PRIx64 "\n", cmd->cid);
-
-	/* Should we do this earlier? */
-	if (!device)
-		cmd->device = device = tgt_device_find(target, cmd->dev_id);
-	if (device)
-		dprintk("found %" PRIu64 "\n", cmd->dev_id);
-
-	err = target->proto->execute_cmd(cmd);
-
-	switch (err) {
-	case TGT_CMD_FAILED:
-	case TGT_CMD_COMPLETED:
-		dprintk("command completed %d\n", err);
-		tgt_transfer_response(cmd);
-	default:
-		dprintk("command %" PRIx64 " queued\n", cmd->cid);
-	};
-}
-
 struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *tgt_priv)
 {
 	struct tgt_cmd *cmd;
-	unsigned long flags;
 
 	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
 	if (!cmd) {
@@ -602,58 +772,46 @@
 
 	memset(cmd, 0, sizeof(*cmd));
 	cmd->session = session;
-	cmd->cid = (uint64_t) (unsigned long) cmd;
 	cmd->private = tgt_priv;
 	INIT_LIST_HEAD(&cmd->clist);
-	INIT_LIST_HEAD(&cmd->hash_list);
+	cmd->done = tgt_cmd_destroy;
+	atomic_set(&cmd->state, TGT_CMD_CREATED);
 
-	dprintk("%p %" PRIx64 "\n", session, cmd->cid);
-
-	spin_lock_irqsave(&cmd_hash_lock, flags);
-	list_add_tail(&cmd->hash_list, &cmd_hash[cmd_hashfn(cmd->cid)]);
-	spin_unlock_irqrestore(&cmd_hash_lock, flags);
-
+	dprintk("%p %p\n", session, cmd);
 	return cmd;
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_create);
 
-static void tgt_free_buffer(struct tgt_cmd *cmd)
+static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
-	int i;
+	int write = (cmd->data_dir == DMA_TO_DEVICE);
+	struct request_queue *q = cmd->device->q;
+	struct request *rq;
 
-	for (i = 0; i < cmd->sg_count; i++)
-		__free_page(cmd->sg[i].page);
-	kfree(cmd->sg);
+	rq = blk_get_request(q, write, gfp_mask);
+	if (!rq)
+		return -ENOMEM;
+
+	cmd->rq = rq;
+	rq->special = cmd;
+	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
+	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 0);
+	return 0;
 }
 
-void tgt_cmd_destroy(struct tgt_cmd *cmd)
+static void set_cmd_ready(struct tgt_cmd *cmd)
 {
 	unsigned long flags;
+	struct request_queue *q = cmd->device->q;
 
-	dprintk("cid %" PRIx64 "\n", cmd->cid);
-
-	tgt_free_buffer(cmd);
-
-	spin_lock_irqsave(&cmd_hash_lock, flags);
-	list_del(&cmd->hash_list);
-	spin_unlock_irqrestore(&cmd_hash_lock, flags);
-
-	mempool_free(cmd, cmd->session->cmd_pool);
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_destroy);
-
-static int __tgt_cmd_queue(struct tgt_cmd *cmd)
-{
-	struct tgt_session *session = cmd->session;
-
 	/*
-	 * we may need to code so that other layers can override this
-	 * done function
+	 * we have a request that is ready for processing so
+	 * plug the queue
 	 */
-	cmd->done = tgt_cmd_destroy;
-	INIT_WORK(&cmd->work, queuecommand, cmd);
-	queue_work(session->target->twq, &cmd->work);
-	return 0;
+	spin_lock_irqsave(q->queue_lock, flags);
+	atomic_set(&cmd->state, TGT_CMD_READY);
+	blk_plug_device(q);
+	spin_unlock_irqrestore(q->queue_lock, flags);
 }
 
 static void tgt_write_data_transfer_done(struct tgt_cmd *cmd)
@@ -662,12 +820,7 @@
 	 * TODO check for errors and add state checking. we may have
 	 * to internally queue for the target driver
 	 */
-
-	/*
-	 * we are normally called from a irq so since the tgt_vsd blocks
-	 * we must queue this cmd
-	 */
-	__tgt_cmd_queue(cmd);
+	set_cmd_ready(cmd);
 }
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
@@ -686,12 +839,18 @@
 	cmd->sg_count = pgcnt(len, offset);
 	offset &= ~PAGE_CACHE_MASK;
 
-	dprintk("cid %" PRIx64 " pg_count %d offset %" PRIu64 " len %d\n",
-		cmd->cid, cmd->sg_count, cmd->offset, cmd->bufflen);
+	dprintk("cmd %p tag %d pg_count %d offset %" PRIu64 " len %d\n",
+		cmd, cmd->rq->tag, cmd->sg_count, cmd->offset, cmd->bufflen);
 
+	/*
+	 * TODO: mempool this like in scsi_lib.c
+	 */
 	cmd->sg = kmalloc(cmd->sg_count * sizeof(struct scatterlist),
 			   GFP_KERNEL | __GFP_NOFAIL);
 
+	/*
+	 * TODO need to create reserves
+	 */
 	for (i = 0; i < cmd->sg_count; i++) {
 		struct scatterlist *sg = &cmd->sg[i];
 
@@ -709,6 +868,7 @@
 	struct tgt_cmd *cmd = data;
 
 	__tgt_alloc_buffer(cmd);
+	atomic_set(&cmd->state, TGT_CMD_BUF_ALLOCATED);
 
 	/*
 	 * we probably will not be able to rely on the target
@@ -723,30 +883,30 @@
 		 */
 		cmd->session->target->tt->transfer_write_data(cmd);
 	} else
-		queuecommand(cmd);
+		set_cmd_ready(cmd);
 }
 
-void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd)
+int tgt_cmd_start(struct tgt_cmd *cmd)
 {
 	struct tgt_session *session = cmd->session;
-	BUG_ON(!list_empty(&cmd->clist));
+	int err;
 
-	INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
-	queue_work(session->target->twq, &cmd->work);
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_alloc_buffer);
+	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
+	if (err)
+		return err;
 
-int tgt_cmd_queue(struct tgt_cmd *cmd)
-{
-	if (cmd->bufflen)
-		tgt_cmd_alloc_buffer(cmd);
-	else
-		__tgt_cmd_queue(cmd);
+	if (cmd->bufflen) {
+		atomic_set(&cmd->state, TGT_CMD_STARTED);
+		INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
+		queue_work(session->target->twq, &cmd->work);
+	} else
+		set_cmd_ready(cmd);
+
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tgt_cmd_queue);
+EXPORT_SYMBOL_GPL(tgt_cmd_start);
 
-int tgt_uspace_cmd_send(struct tgt_cmd *cmd)
+int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
 	struct tgt_protocol *proto = cmd->session->target->proto;
 	struct sk_buff *skb;
@@ -756,7 +916,7 @@
 	int len, proto_pdu_size = proto->uspace_pdu_size;
 
 	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
 	if (!skb)
 		return -ENOMEM;
 
@@ -769,7 +929,7 @@
 	pdu = (char *) ev->data;
 	ev->k.cmd_req.tid = cmd->session->target->tid;
 	ev->k.cmd_req.dev_id = cmd->dev_id;
-	ev->k.cmd_req.cid = cmd->cid;
+	ev->k.cmd_req.cid = cmd->rq->tag;
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
 
 	proto->build_uspace_pdu(cmd, pdu);
@@ -778,20 +938,54 @@
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
-static void uspace_cmd_done(struct tgt_cmd *cmd, void *data,
-			     int result, uint32_t len)
+static struct tgt_cmd *find_cmd_by_id(struct tgt_device *device, uint64_t cid)
 {
-	struct tgt_device *device = cmd->device;
+
+	struct request *rq;
+
+	rq = blk_queue_find_tag(device->q, cid);
+	if (rq)
+		return rq->special;
+	eprintk("Could not find cid %llu\n", (unsigned long long)cid);
+	return NULL;
+}
+
+static int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+			   int result, uint32_t len)
+{
+	struct tgt_target *target;
+	struct tgt_device *device;
+	struct tgt_cmd *cmd;
 	char *p = data;
 	int i;
 
-	dprintk("cid %" PRIx64 " result %d len %d bufflen %u\n",
-		cmd->cid, result, len, cmd->bufflen);
+	target = target_find(tid);
+	if (!target) {
+		eprintk("Could not find target %d\n", tid);
+		return -EINVAL;
+	}
 
+	device = tgt_device_find(target, dev_id);
+	if (!device) {
+		eprintk("Could not find device %llu\n",
+			(unsigned long long) dev_id);
+		return -EINVAL;
+	}
+
+	cmd = find_cmd_by_id(device, cid);
+	if (!cmd) {
+		eprintk("Could not find command %llu\n",
+			(unsigned long long) cid);
+		return -EINVAL;	
+	}
+
+	dprintk("cmd %p tag %d result %d len %d bufflen %u\n",
+		cmd, cmd->rq->tag, result, len, cmd->bufflen);
+
 	if (len) {
 		/*
 		 * yuck TODO fix.
-		 * This will happen if we though we were going to do some
+		 * This will happen if we thought we were going to do some
 		 * IO but we ended up just gettting some sense back
 		 */
 		if (len != cmd->bufflen) {
@@ -816,27 +1010,8 @@
 	if (device->dt->complete_uspace_cmd)
 		device->dt->complete_uspace_cmd(cmd);
 	tgt_transfer_response(cmd);
-}
 
-static struct tgt_cmd *find_cmd_by_id(uint64_t cid)
-{
-	struct list_head *head;
-	struct tgt_cmd *cmd;
-	unsigned long flags;
-
-	head = &cmd_hash[cmd_hashfn(cid)];
-
-	spin_lock_irqsave(&cmd_hash_lock, flags);
-
-	list_for_each_entry(cmd, head, hash_list) {
-		if (cmd->cid == cid)
-			goto found;
-	}
-	cmd = NULL;
-found:
-	spin_unlock_irqrestore(&cmd_hash_lock, flags);
-
-	return cmd;
+	return 0;
 }
 
 static int send_event_res(uint16_t type, struct tgt_event *p,
@@ -880,7 +1055,6 @@
 {
 	int err = 0;
 	struct tgt_event *ev = NLMSG_DATA(nlh);
-	struct tgt_cmd *cmd;
 	struct tgt_target *target;
 
 	dprintk("%d %d %d\n", nlh->nlmsg_type,
@@ -930,16 +1104,9 @@
 					 ev->u.d_device.dev_id);
 		break;
 	case TGT_UEVENT_CMD_RES:
-		cmd = find_cmd_by_id(ev->u.cmd_res.cid);
-		if (cmd)
-			uspace_cmd_done(cmd, ev->data,
-					 ev->u.cmd_res.result,
-					 ev->u.cmd_res.len);
-		else {
-			eprintk("cannot found %" PRIx64 "\n",
-				ev->u.cmd_res.cid);
-			err = -EEXIST;
-		}
+		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
+				      ev->u.cmd_res.cid, ev->data,
+				      ev->u.cmd_res.result, ev->u.cmd_res.len);
 		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);
@@ -1005,10 +1172,9 @@
 
 static int __init tgt_init(void)
 {
-	int i, err = -ENOMEM;
+	int err = -ENOMEM;
 
 	spin_lock_init(&all_targets_lock);
-	spin_lock_init(&cmd_hash_lock);
 	spin_lock_init(&target_tmpl_lock);
 	spin_lock_init(&device_tmpl_lock);
 
@@ -1022,9 +1188,6 @@
 	if (!nls)
 		goto out;
 
-	for (i = 0; i < ARRAY_SIZE(cmd_hash); i++)
-		INIT_LIST_HEAD(&cmd_hash[i]);
-
 	return 0;
 out:
 	tgt_exit();

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt.h	2005-11-13 08:43:34 UTC (rev 165)
@@ -10,10 +10,12 @@
 #define __TGT_H
 
 #include <linux/mempool.h>
+#include <linux/bio.h>
 #include <linux/dma-mapping.h>
 
 #include <tgt_types.h>
 
+struct request;
 struct tgt_device;
 struct tgt_protocol;
 
@@ -25,9 +27,11 @@
 };
 
 enum {
-	TGT_CMD_CREATE,
+	TGT_CMD_CREATED,
+	TGT_CMD_BUF_ALLOCATED,
+	TGT_CMD_STARTED,
+	TGT_CMD_READY,
 	TGT_CMD_RECV,
-	TGT_CMD_QUEUED,
 	TGT_CMD_XMIT,
 	TGT_CMD_DONE,
 };
@@ -37,9 +41,8 @@
 	struct tgt_device *device;
 	struct tgt_protocol *proto;
 
-	uint32_t state;
+	atomic_t state;
 	uint64_t dev_id;
-	uint64_t cid;
 
 	struct work_struct work;
 	void (*done) (struct tgt_cmd *);
@@ -54,6 +57,7 @@
 	uint64_t offset;
 	int result;
 
+	struct request *rq;
 	/*
 	 * target driver private
 	 */
@@ -73,10 +77,9 @@
 
 extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
 			gfp_t flags);
-extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
+extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask);
 extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *priv);
-extern void tgt_cmd_destroy(struct tgt_cmd *cmd);
-extern int tgt_cmd_queue(struct tgt_cmd *cmd);
+extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_device.h	2005-11-13 08:43:34 UTC (rev 165)
@@ -8,9 +8,12 @@
 #ifndef __TGT_DEVICE_H
 #define __TGT_DEVICE_H
 
+#include <linux/blkdev.h>
+#include <linux/device-mapper.h>
 #include <linux/device.h>
 #include <linux/list.h>
 
+struct request_queue;
 struct tgt_device;
 struct tgt_cmd;
 
@@ -75,6 +78,16 @@
 	uint32_t blk_shift;
 	uint64_t size;
 
+	/*
+	 * queue for tgt <-> tgt LLD requests
+	 */
+	struct request_queue *q;
+	/*
+	 * end device io limits (should be set by tgt_device drivers)
+	 */
+	struct io_restrictions limits;
+	unsigned use_clustering;
+
 	struct tgt_target *target;
 	struct list_head dlist;
 };
@@ -82,6 +95,7 @@
 #define cdev_to_tgt_device(cdev) \
         container_of(cdev, struct tgt_device, cdev)
 
+extern void tgt_device_free(struct tgt_device *device);
 extern struct tgt_device *tgt_device_find(struct tgt_target *target,
 					  uint64_t dev_id);
 extern int tgt_sysfs_register_device(struct tgt_device *device);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_scsi.c	2005-11-13 08:43:34 UTC (rev 165)
@@ -95,6 +95,10 @@
 		if (!device) {
 			eprintk("Could not find device %x %" PRIu64 "\n",
 				scmd->scb[0], cmd->dev_id);
+			/*
+			 * TODO: FIX THIS LEAK. We should check magic
+			 * target queue.
+			 */
 			return NULL;
 		}
 	}
@@ -110,7 +114,7 @@
 	/* do scsi device specific setup */
 	device->dt->prep_cmd(cmd, data_len);
 
-	tgt_cmd_queue(cmd);
+	tgt_cmd_start(cmd);
 
 	return cmd;
 }

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_sd.c	2005-11-13 08:43:34 UTC (rev 165)
@@ -24,9 +24,24 @@
  */
 static int tgt_sd_create(struct tgt_device *device)
 {
+	struct file *file = device->file;
+	struct io_restrictions *limits = &device->limits;
+	struct request_queue *q;
 	struct inode *inode;
 
-	inode = device->file->f_dentry->d_inode;
+	q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
+	limits->max_sectors = q->max_hw_sectors;
+	limits->max_phys_segments = q->max_phys_segments;
+	limits->max_hw_segments = q->max_hw_segments;
+	limits->hardsect_size = q->hardsect_size;
+	limits->max_segment_size = q->max_segment_size;
+	limits->seg_boundary_mask = q->seg_boundary_mask;
+	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
+		device->use_clustering = 1;
+	else
+		device->use_clustering = 0;
+
+	inode = file->f_dentry->d_inode;
 	if (S_ISREG(inode->i_mode))
 		;
 	else if (S_ISBLK(inode->i_mode))
@@ -101,95 +116,6 @@
 }
 
 /*
- * this is going to the bio layer
- */
-static struct bio *bio_map_pages(request_queue_t *q, struct page *page,
-				 unsigned int len, unsigned int offset,
-				 unsigned int gfp_mask)
-{
-	int nr_pages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;
-	struct bio *bio;
-
-	bio = bio_alloc(gfp_mask, nr_pages);
-	if (!bio)
-		return ERR_PTR(-ENOMEM);
-
-	while (len) {
-		unsigned int bytes = PAGE_SIZE - offset;
-
-		if (bytes > len)
-			bytes = len;
-
-		if (__bio_add_page(q, bio, page, bytes, offset) < bytes)
-			goto free_bio;
-
-		offset = 0;
-		len -= bytes;
-		page++;
-	}
-
-	return bio;
-
- free_bio:
-	bio_put(bio);
-	return ERR_PTR(-EINVAL);
-}
-
-/*
- * this is going to scsi-ml or the block layer
- */
-static int req_map_sg(request_queue_t *q, struct request *rq,
-		      struct scatterlist *sg, int nsegs, unsigned int gfp)
-{
-	struct bio *bio;
-	int i, err = 0;
-	unsigned int len = 0;
-
-	for (i = 0; i < nsegs; i++) {
-		bio = bio_map_pages(q, sg[i].page, sg[i].length, sg[i].offset,
-				    gfp);
-		if (IS_ERR(bio)) {
-			err = PTR_ERR(bio);
-			goto free_bios;
-		}
-		len += sg[i].length;
-
-		bio->bi_flags &= ~(1 << BIO_SEG_VALID);
-		if (rq_data_dir(rq) == WRITE)
-			bio->bi_rw |= (1 << BIO_RW);
-		blk_queue_bounce(q, &bio);
-
-		if (i == 0)
-			blk_rq_bio_prep(q, rq, bio);
-		else if (!q->back_merge_fn(q, rq, bio)) {
-			bio_endio(bio, bio->bi_size, 0);
-			err = -EINVAL;
-			goto free_bios;
-		} else {
-			rq->biotail->bi_next = bio;
-			rq->biotail = bio;
-			rq->hard_nr_sectors += bio_sectors(bio);
-			rq->nr_sectors = rq->hard_nr_sectors;
-		}
-	}
-
-	rq->buffer = rq->data = NULL;
-	rq->data_len = len;
-	return 0;
-
- free_bios:
-	while ((bio = rq->bio) != NULL) {
-		rq->bio = bio->bi_next;
-		/*
-		 * call endio instead of bio_put incase it was bounced
-		 */
-		bio_endio(bio, bio->bi_size, 0);
-	}
-
-	return err;
-}
-
-/*
  * TODO part of this will move to a io_handler callout
  */
 static int tgt_sd_execute_rq(struct tgt_cmd *cmd)
@@ -204,10 +130,10 @@
 	if (!rq)
 		goto hw_error;
 
-	if (req_map_sg(q, rq, cmd->sg, cmd->sg_count,
+/*	if (req_map_sg(q, rq, cmd->sg, cmd->sg_count,
 			GFP_KERNEL | __GFP_NOFAIL))
 		goto free_request;
-
+*/
 	rq->cmd_len = COMMAND_SIZE(scmd->scb[0]);
 	memcpy(rq->cmd, scmd->scb, rq->cmd_len);
 	rq->sense_len = 0;

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_sysfs.c	2005-11-13 08:43:34 UTC (rev 165)
@@ -224,12 +224,10 @@
 static void tgt_device_class_release(struct class_device *cdev)
 {
 	struct tgt_device *device = cdev_to_tgt_device(cdev);
-	struct tgt_target *target = device->target;
+	struct class_device *parent = &device->target->cdev;
 
-	class_device_put(&target->cdev);
-	kfree(device->dt_data);
-	kfree(device->pt_data);
-	kfree(device);
+	tgt_device_free(device);
+	class_device_put(parent);
 }
 
 static struct class tgt_device_class = {

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_target.h	2005-11-13 08:43:34 UTC (rev 165)
@@ -29,11 +29,24 @@
 	TGT_CMD_XMIT_REQUEUE,
 };
 
+#define TGT_DEFAULT_MAX_SECTORS 1024
+#define TGT_MAX_PHYS_SEGMENTS 255
+/*
+ * this should be a template and device limit probably
+ */
+#define TGT_QUEUE_DEPTH 64 
+
 struct tgt_target_template {
 	const char *name;
 	struct module *module;
 	unsigned priv_data_size;
 
+	unsigned short max_hw_segments;
+	unsigned int max_segment_size;
+	unsigned long seg_boundary_mask;
+	unsigned short max_sectors;
+	unsigned use_clustering;
+
 	/*
 	 * Target creation/destroy callbacks useful when userspace
 	 * initiates these operations

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-11-05 11:14:14 UTC (rev 164)
+++ trunk/kernel/tgt_vsd.c	2005-11-13 08:43:34 UTC (rev 165)
@@ -16,6 +16,7 @@
 #include <scsi/scsi.h>
 
 #include <tgt.h>
+#include <tgt_target.h>
 #include <tgt_device.h>
 #include <tgt_scsi.h>
 
@@ -31,6 +32,7 @@
 	else
 		return -EINVAL;
 
+	device->use_clustering = 1;
 	device->size = inode->i_size;
 	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
 
@@ -132,12 +134,12 @@
 	}
 
 	/* sync_page_range(inode, inode->i_mapping, pos, (size_t) cmd->bufflen); */
-
 	return 0;
 }
 
-static int tgt_vsd_execute(struct tgt_cmd *cmd)
+static void __tgt_vsd_execute(void *data)
 {
+	struct tgt_cmd *cmd = data;
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	int err, rw;
 
@@ -154,35 +156,44 @@
 		rw = WRITE;
 		break;
 	default:
-		err = tgt_uspace_cmd_send(cmd);
+		err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
 		/*
 		 * successfully queued
 		 */
 		if (err >= 0)
-			return TGT_CMD_USPACE_QUEUED;
+			return;
 
 		goto failed;
 	};
 
-	/*
-	 * TODO this will become device->io_handler->queue_cmd
-	 * when we seperate the io_handlers
-	 */
 	err = vsd_execute_file_io(cmd, rw);
 	if (!err) {
 		cmd->result = SAM_STAT_GOOD;
-		return TGT_CMD_COMPLETED;
+		goto done;
 	}
 
 	/*
-	 * we should to a switch but I am not sure of all the err values
+	 * we should do a switch but I am not sure of all the err values
 	 * returned. If you find one add it
 	 */
 failed:
+	/* TODO if -ENOMEM return QUEUEFULL or BUSY ??? */
 	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-	return TGT_CMD_FAILED;
+done:
+	tgt_transfer_response(cmd);
 }
 
+static int tgt_vsd_execute(struct tgt_cmd *cmd)
+{
+	/*
+	 * TODO: this module needs to do async non blocking io or create
+	 * its own threads
+	 */
+	INIT_WORK(&cmd->work, __tgt_vsd_execute, cmd);
+	queue_work(cmd->session->target->twq, &cmd->work);
+	return TGT_CMD_KERN_QUEUED;
+}
+
 static struct tgt_device_template tgt_vsd = {
 	.name = "tgt_vsd",
 	.module = THIS_MODULE,



From mnc at berlios.de  Mon Nov 14 01:37:35 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Mon, 14 Nov 2005 01:37:35 +0100
Subject: [Stgt-svn] r166 - in trunk: istgt/usr usr
Message-ID: <200511140037.jAE0bZi1011884@sheep.berlios.de>

Author: mnc
Date: 2005-11-14 01:37:20 +0100 (Mon, 14 Nov 2005)
New Revision: 166

Modified:
   trunk/istgt/usr/ctldev.c
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
Log:
include linux/types when including linux/netlink in userspace to fix FC4 compile errors

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-11-13 08:43:34 UTC (rev 165)
+++ trunk/istgt/usr/ctldev.c	2005-11-14 00:37:20 UTC (rev 166)
@@ -18,6 +18,7 @@
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <fcntl.h>
+#include <linux/types.h>
 #include <linux/netlink.h>
 
 #include "iscsid.h"

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2005-11-13 08:43:34 UTC (rev 165)
+++ trunk/usr/mgmt.c	2005-11-14 00:37:20 UTC (rev 166)
@@ -17,6 +17,7 @@
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <linux/types.h>
 #include <linux/netlink.h>
 
 #include <tgt_if.h>

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-11-13 08:43:34 UTC (rev 165)
+++ trunk/usr/tgtadm.c	2005-11-14 00:37:20 UTC (rev 166)
@@ -27,6 +27,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
+#include <linux/types.h>
 #include <linux/netlink.h>
 
 #include "tgtadm.h"



From tomo at berlios.de  Tue Nov 15 10:31:04 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 15 Nov 2005 10:31:04 +0100
Subject: [Stgt-svn] r167 - trunk/kernel
Message-ID: <200511150931.jAF9V4ti018275@sheep.berlios.de>

Author: tomo
Date: 2005-11-15 10:31:02 +0100 (Tue, 15 Nov 2005)
New Revision: 167

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt_target.h
Log:
Just remove unnecessary space.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-14 00:37:20 UTC (rev 166)
+++ trunk/kernel/tgt.c	2005-11-15 09:31:02 UTC (rev 167)
@@ -976,7 +976,7 @@
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);
-		return -EINVAL;	
+		return -EINVAL;
 	}
 
 	dprintk("cmd %p tag %d result %d len %d bufflen %u\n",

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-11-14 00:37:20 UTC (rev 166)
+++ trunk/kernel/tgt_target.h	2005-11-15 09:31:02 UTC (rev 167)
@@ -34,7 +34,7 @@
 /*
  * this should be a template and device limit probably
  */
-#define TGT_QUEUE_DEPTH 64 
+#define TGT_QUEUE_DEPTH 64
 
 struct tgt_target_template {
 	const char *name;



From tomo at berlios.de  Tue Nov 15 10:58:32 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 15 Nov 2005 10:58:32 +0100
Subject: [Stgt-svn] r168 - in trunk/istgt: include kernel
Message-ID: <200511150958.jAF9wWw8010131@sheep.berlios.de>

Author: tomo
Date: 2005-11-15 10:58:22 +0100 (Tue, 15 Nov 2005)
New Revision: 168

Modified:
   trunk/istgt/include/iscsi_proto.h
   trunk/istgt/kernel/iscsi.c
Log:
Changes for the latest version of iscsi_proto.h. We can remove our own iscsi_proto.h with 2.6.15-rc1 or later.


Modified: trunk/istgt/include/iscsi_proto.h
===================================================================
--- trunk/istgt/include/iscsi_proto.h	2005-11-15 09:31:02 UTC (rev 167)
+++ trunk/istgt/include/iscsi_proto.h	2005-11-15 09:58:22 UTC (rev 168)
@@ -548,9 +548,11 @@
 	uint8_t flags;
 	uint8_t reason;
 	uint8_t rsvd2;
-	uint8_t rsvd3;
+	uint8_t hlength;
 	uint8_t dlength[3];
-	uint8_t rsvd4[16];
+	uint8_t rsvd3[8];
+	__be32  ffffffff;
+	uint8_t rsvd4[4];
 	__be32	statsn;
 	__be32	exp_cmdsn;
 	__be32	max_cmdsn;
@@ -560,17 +562,17 @@
 };
 
 /* Reason for Reject */
-#define CMD_BEFORE_LOGIN	1
-#define DATA_DIGEST_ERROR	2
-#define DATA_SNACK_REJECT	3
-#define ISCSI_PROTOCOL_ERROR	4
-#define CMD_NOT_SUPPORTED	5
-#define IMM_CMD_REJECT		6
-#define TASK_IN_PROGRESS	7
-#define INVALID_SNACK		8
-#define BOOKMARK_REJECTED	9
-#define BOOKMARK_NO_RESOURCES	10
-#define NEGOTIATION_RESET	11
+#define ISCSI_REASON_CMD_BEFORE_LOGIN	1
+#define ISCSI_REASON_DATA_DIGEST_ERROR	2
+#define ISCSI_REASON_DATA_SNACK_REJECT	3
+#define ISCSI_REASON_PROTOCOL_ERROR	4
+#define ISCSI_REASON_CMD_NOT_SUPPORTED	5
+#define ISCSI_REASON_IMM_CMD_REJECT		6
+#define ISCSI_REASON_TASK_IN_PROGRESS	7
+#define ISCSI_REASON_INVALID_SNACK		8
+#define ISCSI_REASON_BOOKMARK_INVALID	9
+#define ISCSI_REASON_BOOKMARK_NO_RESOURCES	10
+#define ISCSI_REASON_NEGOTIATION_RESET	11
 
 /* Max. number of Key=Value pairs in a text message */
 #define MAX_KEY_VALUE_PAIRS	8192

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-11-15 09:31:02 UTC (rev 167)
+++ trunk/istgt/kernel/iscsi.c	2005-11-15 09:58:22 UTC (rev 168)
@@ -464,7 +464,7 @@
 	if ((int32_t) (cmd_sn - session->exp_cmd_sn) >= 0)
 		return 0;
 	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
-	return -ISCSI_PROTOCOL_ERROR;
+	return -ISCSI_REASON_PROTOCOL_ERROR;
 }
 
 static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
@@ -510,7 +510,7 @@
 
 	dprintk("%p:%x\n", cmnd, itt);
 	if (itt == ISCSI_RESERVED_TAG) {
-		err = -ISCSI_PROTOCOL_ERROR;
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -523,7 +523,7 @@
 		list_add_tail(&cmnd->hash_list, head);
 		set_cmd_hashed(cmnd);
 	} else
-		err = -TASK_IN_PROGRESS;
+		err = -ISCSI_REASON_TASK_IN_PROGRESS;
 
 	spin_unlock(&session->cmnd_hash_lock);
 
@@ -838,7 +838,7 @@
 		 * See 10.18.2 in the draft 20.
 		 */
 		eprintk("initiator bug %x\n", cmd_itt(cmnd));
-		err = -ISCSI_PROTOCOL_ERROR;
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -1572,10 +1572,10 @@
 		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
-		err = -CMD_NOT_SUPPORTED;
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
 		break;
 	default:
-		err = -CMD_NOT_SUPPORTED;
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
 		break;
 	}
 



From tomo at berlios.de  Wed Nov 16 04:51:25 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 16 Nov 2005 04:51:25 +0100
Subject: [Stgt-svn] r169 - in trunk: include kernel usr
Message-ID: <200511160351.jAG3pPnH005940@sheep.berlios.de>

Author: tomo
Date: 2005-11-16 04:51:16 +0100 (Wed, 16 Nov 2005)
New Revision: 169

Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Add target queue.


Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/include/tgt_if.h	2005-11-16 03:51:16 UTC (rev 169)
@@ -23,6 +23,10 @@
 	TGT_KEVENT_TARGET_PASSTHRU,
 };
 
+enum tgt_cmd_flags {
+	TGT_CMD_DEVICE,
+};
+
 struct tgt_event {
 	/* user-> kernel */
 	union {
@@ -53,6 +57,7 @@
 			uint64_t dev_id;
 			uint64_t cid;
 			uint32_t len;
+			uint32_t flags;
 			int result;
 		} cmd_res;
 	} u;
@@ -63,10 +68,11 @@
 			int err;
 		} event_res;
 		struct {
-			uint64_t cid;
 			int tid;
 			uint64_t dev_id;
+			uint64_t cid;
 			int typeid;
+			uint32_t flags;
 		} cmd_req;
 		struct {
 			int tid;

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt.c	2005-11-16 03:51:16 UTC (rev 169)
@@ -148,6 +148,95 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
 
+static void tgt_request_fn(struct request_queue *q)
+{
+	struct tgt_target *target;
+	struct tgt_cmd *cmd;
+	struct request *rq;
+	int err;
+
+	while ((rq = elv_next_request(q)) != NULL) {
+		/* we need to set state or refcount under this lock! */
+		cmd = rq->special;
+
+		/*
+		 * the iosched nicely ordered these, should we try to keep the
+		 * ordering or for most cases will it not make a difference
+		 * since the lower levels will iosched again (not for
+		 * passthrough though). Maybe we should use a tgt_device
+		 * flag to indicate what is best for the real device.
+		 */
+		if (atomic_read(&cmd->state) != TGT_CMD_READY)
+			break;
+		/*
+		 * hit queue depth (command completion will run the
+		 * queue again
+		 */
+		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
+			break;
+
+		blkdev_dequeue_request(rq);
+
+		spin_unlock_irq(q->queue_lock);
+
+		/*
+		 * TODO: kill cid. We can use the request queue tag instead
+		 */
+		dprintk("cmd %p tag %d\n", cmd, rq->tag);
+
+		target = cmd->session->target;
+	        err = target->proto->execute_cmd(cmd);
+	        switch (err) {
+	        case TGT_CMD_FAILED:
+		case TGT_CMD_COMPLETED:
+			dprintk("command completed %d\n", err);
+			tgt_transfer_response(cmd);
+		default:
+			dprintk("command %d queued to real dev\n", rq->tag);
+		}
+
+		spin_lock_irq(q->queue_lock);
+	}
+}
+
+static int tgt_queue_setup(struct request_queue **queue, int depth)
+{
+	struct request_queue *q;
+	int err;
+
+	q = blk_init_queue(tgt_request_fn, NULL);
+	if (!q)
+		return -ENOMEM;
+
+	/*
+	 * this is a tmp hack: we do not register this queue
+	 * becuase we do not have a proper parent. We can remove
+	 * this code and do this from userspace when the queue's parent
+	 * is not the gendisk.
+	 */
+	elevator_exit(q->elevator);
+	/*
+	 * for the virtual devices iosched happens there, and for passthru
+	 * devs we do noop for now (do we need to since the initiator does
+	 * ioscheduling)
+	 */
+	err = elevator_init(q, "noop");
+	if (err)
+		goto cleanup_queue;
+
+	/* who should set this limit ? */
+	err = blk_queue_init_tags(q, depth, NULL);
+	if (err)
+		goto cleanup_queue;
+
+	*queue = q;
+	return 0;
+
+cleanup_queue:
+	blk_cleanup_queue(q);
+	return err;
+}
+
 static struct tgt_target *target_find(int tid)
 {
 	struct tgt_target *target;
@@ -204,14 +293,19 @@
 		if (target->tt->target_create(target))
 			goto free_priv_tt_data;
 
-	if (tgt_sysfs_register_target(target))
+	if (tgt_queue_setup(&target->q, queued_cmds ? : TGT_QUEUE_DEPTH))
 		goto tt_destroy;
 
+	if (tgt_sysfs_register_target(target))
+		goto queue_destroy;
+
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
 	return target;
 
+queue_destroy:
+	blk_cleanup_queue(target->q);
 tt_destroy:
 	if (target->tt->target_destroy)
 		target->tt->target_destroy(target);
@@ -239,6 +333,7 @@
 		target->tt->target_destroy(target);
 
 	destroy_workqueue(target->twq);
+	blk_cleanup_queue(target->q);
 	target_template_put(target->tt);
 	tgt_sysfs_unregister_target(target);
 
@@ -446,88 +541,21 @@
 }
 EXPORT_SYMBOL_GPL(tgt_device_find);
 
-static void tgt_request_fn(struct request_queue *q)
-{
-	struct tgt_target *target;
-	struct tgt_cmd *cmd;
-	struct request *rq;
-	int err;
-
-	while ((rq = elv_next_request(q)) != NULL) {
-		/* we need to set state or refcount under this lock! */
-		cmd = rq->special;
-
-		/*
-		 * the iosched nicely ordered these, should we try to keep the
-		 * ordering or for most cases will it not make a difference
-		 * since the lower levels will iosched again (not for
-		 * passthrough though). Maybe we should use a tgt_device
-		 * flag to indicate what is best for the real device.
-		 */
-		if (atomic_read(&cmd->state) != TGT_CMD_READY)
-			break;
-		/*
-		 * hit queue depth (command completion will run the
-		 * queue again
-		 */
-		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
-			break;
-		blkdev_dequeue_request(rq);
-
-		spin_unlock_irq(q->queue_lock);
-
-		/*
-		 * TODO: kill cid. We can use the request queue tag instead
-		 */
-		dprintk("cmd %p tag %d\n", cmd, rq->tag);
-
-		target = cmd->session->target;
-	        err = target->proto->execute_cmd(cmd);
-	        switch (err) {
-	        case TGT_CMD_FAILED:
-		case TGT_CMD_COMPLETED:
-			dprintk("command completed %d\n", err);
-			tgt_transfer_response(cmd);
-		default:
-			dprintk("command %d queued to real dev\n", rq->tag);
-		}
-
-		spin_lock_irq(q->queue_lock);
-	}
-}
-
 #define min_not_zero(l, r) (l == 0) ? r : ((r == 0) ? l : min(l, r))
 
-static int tgt_setup_queue(struct tgt_device *device)
+static int tgt_device_queue_setup(struct tgt_device *device)
 {
 	struct io_restrictions *limits = &device->limits;
 	struct tgt_target_template *tt = device->target->tt;
 	struct request_queue *q;
-
 	int err;
 
-	q = blk_init_queue(tgt_request_fn, NULL);
-	if (!q)
-		return -ENOMEM;
+	err = tgt_queue_setup(&q, TGT_QUEUE_DEPTH);
+	if (err)
+		return err;
+
 	device->q = q;
 	q->queuedata = device;
-	/*
-	 * this is a tmp hack: we do not register this queue
-	 * becuase we do not have a proper parent. We can remove
-	 * this code and do this from userspace when the queue's parent
-	 * is not the gendisk.
-	 */
-	elevator_exit(q->elevator);
-	/*
-	 * for the virtual devices iosched happens there, and for passthru
-	 * devs we do noop for now (do we need to since the initiator does
-	 * ioscheduling)
-	 */
-	err = elevator_init(q, "noop");
-	if (err) {
-		blk_cleanup_queue(q);
-		return err;
-	}
 
 	blk_queue_max_sectors(q, min_not_zero(tt->max_sectors,
 					limits->max_sectors));
@@ -552,13 +580,6 @@
 	else
 		dprintk("clustering not set\n");
 
-	/* who should set this limit ? */
-	err = blk_queue_init_tags(q, TGT_QUEUE_DEPTH, NULL);
-	if (err) {
-		blk_cleanup_queue(q);
-		return err;
-	}
-
 	return 0;
 }
 
@@ -612,7 +633,7 @@
 	if (target->proto->attach_device)
 		target->proto->attach_device(device->pt_data);
 
-	if (tgt_setup_queue(device))
+	if (tgt_device_queue_setup(device))
 		goto dt_destroy;
 
 	if (tgt_sysfs_register_device(device))
@@ -785,9 +806,14 @@
 static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
 	int write = (cmd->data_dir == DMA_TO_DEVICE);
-	struct request_queue *q = cmd->device->q;
+	struct request_queue *q;
 	struct request *rq;
 
+	if (cmd->device)
+		q = cmd->device->q;
+	else
+		q = cmd->session->target->q;
+
 	rq = blk_get_request(q, write, gfp_mask);
 	if (!rq)
 		return -ENOMEM;
@@ -802,7 +828,7 @@
 static void set_cmd_ready(struct tgt_cmd *cmd)
 {
 	unsigned long flags;
-	struct request_queue *q = cmd->device->q;
+	struct request_queue *q = cmd->rq->q;
 
 	/*
 	 * we have a request that is ready for processing so
@@ -920,7 +946,7 @@
 	if (!skb)
 		return -ENOMEM;
 
-	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
+	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
 	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
 			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
@@ -931,48 +957,57 @@
 	ev->k.cmd_req.dev_id = cmd->dev_id;
 	ev->k.cmd_req.cid = cmd->rq->tag;
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
+	if (cmd->device)
+		ev->k.cmd_req.flags |= 1 << TGT_CMD_DEVICE;
 
-	proto->build_uspace_pdu(cmd, pdu);
+	proto->uspace_pdu_build(cmd, pdu);
 
 	return netlink_unicast(nls, skb, tgtd_pid, 0);
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
-static struct tgt_cmd *find_cmd_by_id(struct tgt_device *device, uint64_t cid)
+static struct tgt_cmd *find_cmd_by_id(struct request_queue *q, uint64_t cid)
 {
 
 	struct request *rq;
 
-	rq = blk_queue_find_tag(device->q, cid);
+	rq = blk_queue_find_tag(q, cid);
 	if (rq)
 		return rq->special;
-	eprintk("Could not find cid %llu\n", (unsigned long long)cid);
 	return NULL;
 }
 
 static int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-			   int result, uint32_t len)
+			   int result, uint32_t len, uint32_t flags)
 {
 	struct tgt_target *target;
 	struct tgt_device *device;
 	struct tgt_cmd *cmd;
+	struct request_queue *q;
 	char *p = data;
 	int i;
 
+	dprintk("%d %llu %llu %x\n", tid, (unsigned long long) dev_id,
+		(unsigned long long) cid, flags);
+
 	target = target_find(tid);
 	if (!target) {
 		eprintk("Could not find target %d\n", tid);
 		return -EINVAL;
 	}
 
-	device = tgt_device_find(target, dev_id);
-	if (!device) {
-		eprintk("Could not find device %llu\n",
-			(unsigned long long) dev_id);
-		return -EINVAL;
-	}
+	if (flags & (1 << TGT_CMD_DEVICE)) {
+		device = tgt_device_find(target, dev_id);
+		if (!device) {
+			eprintk("Could not find device %llu\n",
+				(unsigned long long) dev_id);
+			return -EINVAL;
+		}
+		q = device->q;
+	} else
+		q = target->q;
 
-	cmd = find_cmd_by_id(device, cid);
+	cmd = find_cmd_by_id(q, cid);
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);
@@ -1007,8 +1042,7 @@
 	}
 
 	cmd->result = result;
-	if (device->dt->complete_uspace_cmd)
-		device->dt->complete_uspace_cmd(cmd);
+	target->proto->uspace_cmd_complete(cmd);
 	tgt_transfer_response(cmd);
 
 	return 0;
@@ -1106,7 +1140,8 @@
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
 				      ev->u.cmd_res.cid, ev->data,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len);
+				      ev->u.cmd_res.result, ev->u.cmd_res.len,
+				      ev->u.cmd_res.flags);
 		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt_device.h	2005-11-16 03:51:16 UTC (rev 169)
@@ -45,10 +45,6 @@
 	 */
 	int (* execute_cmd)(struct tgt_cmd *cmd);
 	/*
-	 * complete a userspace command
-	 */
-	void (* complete_uspace_cmd)(struct tgt_cmd *cmd);
-	/*
 	 * complete a kernel command if your queue_command was async
 	 * and the device used one of the tgt threads to process the
 	 * command

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt_protocol.h	2005-11-16 03:51:16 UTC (rev 169)
@@ -47,8 +47,9 @@
 	/*
 	 * Build userspace packet
 	 */
-	void (* build_uspace_pdu)(struct tgt_cmd *cmd, void *data);
+	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
+	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
 	/*
 	 * Initialize protocol specific data per device
 	 */

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt_scsi.c	2005-11-16 03:51:16 UTC (rev 169)
@@ -83,25 +83,6 @@
 	/* translate target driver LUN to device id */
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	device = tgt_device_find(session->target, cmd->dev_id);
-	if (!device) {
-		switch (scmd->scb[0]) {
-		case INQUIRY:
-		case REPORT_LUNS:
-			/* we assume that we have lun 0. */
-			device = tgt_device_find(session->target, 0);
-			break;
-		}
-
-		if (!device) {
-			eprintk("Could not find device %x %" PRIu64 "\n",
-				scmd->scb[0], cmd->dev_id);
-			/*
-			 * TODO: FIX THIS LEAK. We should check magic
-			 * target queue.
-			 */
-			return NULL;
-		}
-	}
 	cmd->device = device;
 
 	/* is this device specific */
@@ -112,7 +93,8 @@
 	 */
 	cmd->bufflen = data_len;
 	/* do scsi device specific setup */
-	device->dt->prep_cmd(cmd, data_len);
+	if (device)
+		device->dt->prep_cmd(cmd, data_len);
 
 	tgt_cmd_start(cmd);
 
@@ -235,10 +217,15 @@
 static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	struct tgt_device *device = cmd->device;
-	struct scsi_tgt_device *stdev = device->pt_data;
+	struct tgt_device *device;
+	struct scsi_tgt_device *stdev;
 	unsigned long flags;
 
+	device = cmd->device;
+	if (!device)
+		return;
+
+	stdev = device->pt_data;
 	spin_lock_irqsave(&stdev->lock, flags);
 
 	stdev->active_cmds--;
@@ -262,15 +249,37 @@
 	spin_unlock_irqrestore(&stdev->lock, flags);
 }
 
+/* TODO: reimplement SCSI ordering by using the queuest_queue */
+
+static void __tgt_uspace_cmd_send(void *data)
+{
+	struct tgt_cmd *cmd = data;
+	int err;
+
+	err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
+	if (err >= 0)
+		return;
+
+	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+	tgt_transfer_response(cmd);
+}
+
 static int scsi_tgt_execute_cmd(struct tgt_cmd *cmd)
 {
 	struct tgt_device *device = cmd->device;
-	struct scsi_tgt_device *stdev = device->pt_data;
+	struct scsi_tgt_device *stdev;
 	unsigned long flags;
 	int err, enabled, more;
 
-	BUG_ON(!device);
+	dprintk("%p %x\n", cmd, tgt_cmd_to_scsi(cmd)->scb[0]);
 
+	if (!device) {
+		INIT_WORK(&cmd->work, __tgt_uspace_cmd_send, cmd);
+		queue_work(cmd->session->target->twq, &cmd->work);
+		return TGT_CMD_KERN_QUEUED;
+	}
+
+	stdev = device->pt_data;
 	spin_lock_irqsave(&stdev->lock, flags);
 
 	/* Do we need our own list_head? */
@@ -292,12 +301,19 @@
 	return err;
 }
 
-static void scsi_tgt_build_uspace_pdu(struct tgt_cmd *cmd, void *data)
+static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
 {
 	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
 	memcpy(data, scmd->scb, sizeof(scmd->scb));
 }
 
+static void scsi_tgt_uspace_cmd_complete(struct tgt_cmd *cmd)
+{
+	/* userspace did everything for us just copy the buffer */
+	if (cmd->result != SAM_STAT_GOOD)
+		scsi_tgt_sense_copy(cmd);
+}
+
 static void scsi_tgt_attach_device(void *data)
 {
 	struct scsi_tgt_device *stdev = data;
@@ -319,7 +335,8 @@
 	.name = "scsi",
 	.module = THIS_MODULE,
 	.create_cmd = scsi_tgt_create_cmd,
-	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
+	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
+	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
 	.execute_cmd = scsi_tgt_execute_cmd,
 	.complete_cmd = scsi_tgt_complete_cmd,
 	.attach_device = scsi_tgt_attach_device,

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt_target.h	2005-11-16 03:51:16 UTC (rev 169)
@@ -103,6 +103,7 @@
 
 	struct class_device cdev;
 
+	struct request_queue *q;
 	int queued_cmds;
 
 	/* Protects session_list, work_list, device_list */

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/kernel/tgt_vsd.c	2005-11-16 03:51:16 UTC (rev 169)
@@ -78,13 +78,6 @@
 	cmd->offset = off;
 }
 
-static void tgt_vsd_uspace_complete(struct tgt_cmd *cmd)
-{
-	/* userspace did everything for us just copy the buffer */
-	if (cmd->result != SAM_STAT_GOOD)
-		scsi_tgt_sense_copy(cmd);
-}
-
 /*
  * TODO: We need to redo our scatter lists so they take into account
  * this common usage, but also not violate HW limits
@@ -200,7 +193,6 @@
 	.create = tgt_vsd_create,
 	.execute_cmd = tgt_vsd_execute,
 	.prep_cmd = tgt_vsd_prep,
-	.complete_uspace_cmd = tgt_vsd_uspace_complete,
 };
 
 static int __init tgt_vsd_init(void)

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/usr/netlink.c	2005-11-16 03:51:16 UTC (rev 169)
@@ -114,7 +114,7 @@
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
 	uint64_t cid = ev_req->k.cmd_req.cid;
 	uint8_t *scb;
-	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *);
+	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *, uint32_t);
 
 	memset(resbuf, 0, NL_BUFSIZE);
 	scb = (uint8_t *) ev_req->data;
@@ -122,10 +122,12 @@
 
 	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid,
 				  ev_req->k.cmd_req.typeid);
+
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
 			    ev_req->k.cmd_req.dev_id, scb,
-			    (uint8_t *) ev_res->data, &len);
+			    (uint8_t *) ev_res->data, &len,
+			    ev_req->k.cmd_req.flags);
 	else {
 		result = -EINVAL;
 		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
@@ -133,8 +135,11 @@
 	}
 
 	memset(ev_res, 0, sizeof(*ev_res));
+	ev_res->u.cmd_res.tid = ev_req->k.cmd_req.tid;
+	ev_res->u.cmd_res.dev_id = ev_req->k.cmd_req.dev_id;
 	ev_res->u.cmd_res.cid = cid;
 	ev_res->u.cmd_res.len = len;
+	ev_res->u.cmd_res.flags = ev_req->k.cmd_req.flags;
 	ev_res->u.cmd_res.result = result;
 
 	log_error("scsi_cmd_process res %d len %d\n", result, len);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-11-15 09:58:22 UTC (rev 168)
+++ trunk/usr/scsi.c	2005-11-16 03:51:16 UTC (rev 169)
@@ -25,6 +25,7 @@
 #include <fcntl.h>
 
 #include "tgtd.h"
+#include "tgt_if.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -232,6 +233,7 @@
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
+	errno = 0;
 	device_info(tid, lun, &size);
 
 	if (!(scb[1] & 0x3)) {
@@ -490,15 +492,14 @@
 	return SAM_STAT_GOOD;
 }
 
-int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
+		uint32_t flags)
 {
-	int err, result = SAM_STAT_GOOD;
-	uint64_t size;
+	int result = SAM_STAT_GOOD;
 
-	dprintf("%x\n", scb[0]);
+	dprintf("%d %" PRIu64 " %x %x\n", tid, lun, scb[0], flags);
 
-	err = device_info(tid, lun, &size);
-	if (errno == ENOENT)
+	if (!(flags & (1 << TGT_CMD_DEVICE)))
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:



From tomo at berlios.de  Wed Nov 16 05:07:42 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 16 Nov 2005 05:07:42 +0100
Subject: [Stgt-svn] r170 - trunk/usr
Message-ID: <200511160407.jAG47gjk007890@sheep.berlios.de>

Author: tomo
Date: 2005-11-16 05:07:35 +0100 (Wed, 16 Nov 2005)
New Revision: 170

Modified:
   trunk/usr/scsi.c
Log:
usr/scsi.c uses tgt_sysfs.h

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-11-16 03:51:16 UTC (rev 169)
+++ trunk/usr/scsi.c	2005-11-16 04:07:35 UTC (rev 170)
@@ -26,6 +26,7 @@
 
 #include "tgtd.h"
 #include "tgt_if.h"
+#include "tgt_sysfs.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -66,7 +67,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[128];
 
-	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/size",
+	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
 		tid, lun);
 
 	fd = open(path, O_RDONLY);
@@ -324,9 +325,9 @@
 	char buf[128];
 	int result = SAM_STAT_GOOD;
 
-	dir = opendir("/sys/class/tgt_device");
+	dir = opendir(TGT_DEVICE_SYSFSDIR);
 	if (!dir) {
-		perror("can't open /sys/class/tgt_device\n");
+		eprintf("can't open %s %d\n", TGT_DEVICE_SYSFSDIR, errno);
 		exit(0);
 	}
 
@@ -406,7 +407,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/fd",
+	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
 		tid, lun);
 
 	fd = open(path, O_RDONLY);



From tomo at berlios.de  Wed Nov 16 05:23:19 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 16 Nov 2005 05:23:19 +0100
Subject: [Stgt-svn] r171 - trunk/kernel
Message-ID: <200511160423.jAG4NJeE013495@sheep.berlios.de>

Author: tomo
Date: 2005-11-16 05:23:18 +0100 (Wed, 16 Nov 2005)
New Revision: 171

Modified:
   trunk/kernel/tgt.c
Log:
Prevent a target having devices being destroyed.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-16 04:07:35 UTC (rev 170)
+++ trunk/kernel/tgt.c	2005-11-16 04:23:18 UTC (rev 171)
@@ -325,6 +325,9 @@
 {
 	dprintk("%p\n", target);
 
+	if (!list_empty(&target->device_list))
+		return -EBUSY;
+
 	spin_lock(&all_targets_lock);
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);



From tomo at berlios.de  Wed Nov 16 06:12:41 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 16 Nov 2005 06:12:41 +0100
Subject: [Stgt-svn] r172 - in trunk: include kernel usr
Message-ID: <200511160512.jAG5CfHT021917@sheep.berlios.de>

Author: tomo
Date: 2005-11-16 06:12:40 +0100 (Wed, 16 Nov 2005)
New Revision: 172

Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Use magic TGT_INVALID_DEV_ID dev_id instead of adding flags.

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-11-16 04:23:18 UTC (rev 171)
+++ trunk/include/tgt_if.h	2005-11-16 05:12:40 UTC (rev 172)
@@ -23,9 +23,7 @@
 	TGT_KEVENT_TARGET_PASSTHRU,
 };
 
-enum tgt_cmd_flags {
-	TGT_CMD_DEVICE,
-};
+#define	TGT_INVALID_DEV_ID	~0ULL
 
 struct tgt_event {
 	/* user-> kernel */
@@ -57,7 +55,6 @@
 			uint64_t dev_id;
 			uint64_t cid;
 			uint32_t len;
-			uint32_t flags;
 			int result;
 		} cmd_res;
 	} u;
@@ -72,7 +69,6 @@
 			uint64_t dev_id;
 			uint64_t cid;
 			int typeid;
-			uint32_t flags;
 		} cmd_req;
 		struct {
 			int tid;

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-16 04:23:18 UTC (rev 171)
+++ trunk/kernel/tgt.c	2005-11-16 05:12:40 UTC (rev 172)
@@ -957,11 +957,9 @@
 
 	pdu = (char *) ev->data;
 	ev->k.cmd_req.tid = cmd->session->target->tid;
-	ev->k.cmd_req.dev_id = cmd->dev_id;
+	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
 	ev->k.cmd_req.cid = cmd->rq->tag;
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
-	if (cmd->device)
-		ev->k.cmd_req.flags |= 1 << TGT_CMD_DEVICE;
 
 	proto->uspace_pdu_build(cmd, pdu);
 
@@ -981,7 +979,7 @@
 }
 
 static int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-			   int result, uint32_t len, uint32_t flags)
+			   int result, uint32_t len)
 {
 	struct tgt_target *target;
 	struct tgt_device *device;
@@ -990,8 +988,8 @@
 	char *p = data;
 	int i;
 
-	dprintk("%d %llu %llu %x\n", tid, (unsigned long long) dev_id,
-		(unsigned long long) cid, flags);
+	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
+		(unsigned long long) cid);
 
 	target = target_find(tid);
 	if (!target) {
@@ -999,7 +997,9 @@
 		return -EINVAL;
 	}
 
-	if (flags & (1 << TGT_CMD_DEVICE)) {
+	if (dev_id == TGT_INVALID_DEV_ID)
+		q = target->q;
+	else {
 		device = tgt_device_find(target, dev_id);
 		if (!device) {
 			eprintk("Could not find device %llu\n",
@@ -1007,8 +1007,7 @@
 			return -EINVAL;
 		}
 		q = device->q;
-	} else
-		q = target->q;
+	}
 
 	cmd = find_cmd_by_id(q, cid);
 	if (!cmd) {
@@ -1143,8 +1142,7 @@
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
 				      ev->u.cmd_res.cid, ev->data,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len,
-				      ev->u.cmd_res.flags);
+				      ev->u.cmd_res.result, ev->u.cmd_res.len);
 		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-16 04:23:18 UTC (rev 171)
+++ trunk/usr/netlink.c	2005-11-16 05:12:40 UTC (rev 172)
@@ -114,7 +114,7 @@
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
 	uint64_t cid = ev_req->k.cmd_req.cid;
 	uint8_t *scb;
-	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *, uint32_t);
+	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
 	scb = (uint8_t *) ev_req->data;
@@ -126,8 +126,7 @@
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
 			    ev_req->k.cmd_req.dev_id, scb,
-			    (uint8_t *) ev_res->data, &len,
-			    ev_req->k.cmd_req.flags);
+			    (uint8_t *) ev_res->data, &len);
 	else {
 		result = -EINVAL;
 		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
@@ -139,7 +138,6 @@
 	ev_res->u.cmd_res.dev_id = ev_req->k.cmd_req.dev_id;
 	ev_res->u.cmd_res.cid = cid;
 	ev_res->u.cmd_res.len = len;
-	ev_res->u.cmd_res.flags = ev_req->k.cmd_req.flags;
 	ev_res->u.cmd_res.result = result;
 
 	log_error("scsi_cmd_process res %d len %d\n", result, len);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-11-16 04:23:18 UTC (rev 171)
+++ trunk/usr/scsi.c	2005-11-16 05:12:40 UTC (rev 172)
@@ -500,7 +500,7 @@
 
 	dprintf("%d %" PRIu64 " %x %x\n", tid, lun, scb[0], flags);
 
-	if (!(flags & (1 << TGT_CMD_DEVICE)))
+	if (lun == TGT_INVALID_DEV_ID)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:



From tomo at berlios.de  Thu Nov 17 06:18:41 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 17 Nov 2005 06:18:41 +0100
Subject: [Stgt-svn] r173 - trunk/kernel
Message-ID: <200511170518.jAH5IfwP031222@sheep.berlios.de>

Author: tomo
Date: 2005-11-17 06:18:38 +0100 (Thu, 17 Nov 2005)
New Revision: 173

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
Rewrite the SCSI command ordering code by using the request_queue support.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-16 05:12:40 UTC (rev 172)
+++ trunk/kernel/tgt.c	2005-11-17 05:18:38 UTC (rev 173)
@@ -175,8 +175,6 @@
 		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
 			break;
 
-		blkdev_dequeue_request(rq);
-
 		spin_unlock_irq(q->queue_lock);
 
 		/*
@@ -199,15 +197,28 @@
 	}
 }
 
-static int tgt_queue_setup(struct request_queue **queue, int depth)
+static void tgt_queue_destroy(struct request_queue *q)
 {
+	kfree(q->queuedata);
+	blk_cleanup_queue(q);
+}
+
+static int tgt_queue_create(struct tgt_protocol *proto, int depth,
+			    struct request_queue **queue)
+{
 	struct request_queue *q;
-	int err;
+	int err = -ENOMEM;
 
-	q = blk_init_queue(tgt_request_fn, NULL);
+	*queue = q = blk_init_queue(tgt_request_fn, NULL);
 	if (!q)
 		return -ENOMEM;
 
+	if (proto->priv_queuedata_size) {
+		q->queuedata = kzalloc(proto->priv_queuedata_size, GFP_KERNEL);
+		if (!q->queuedata)
+			goto out;
+	}
+
 	/*
 	 * this is a tmp hack: we do not register this queue
 	 * becuase we do not have a proper parent. We can remove
@@ -220,20 +231,24 @@
 	 * devs we do noop for now (do we need to since the initiator does
 	 * ioscheduling)
 	 */
-	err = elevator_init(q, "noop");
+	err = elevator_init(q, proto->elevator ? : "noop");
 	if (err)
-		goto cleanup_queue;
+		goto out;
 
 	/* who should set this limit ? */
 	err = blk_queue_init_tags(q, depth, NULL);
 	if (err)
-		goto cleanup_queue;
+		goto out;
 
-	*queue = q;
-	return 0;
+	if (proto->queue_create) {
+		err = proto->queue_create(q->queuedata);
+		if (err)
+			goto out;
+	}
 
-cleanup_queue:
-	blk_cleanup_queue(q);
+	return 0;
+out:
+	tgt_queue_destroy(q);
 	return err;
 }
 
@@ -293,7 +308,8 @@
 		if (target->tt->target_create(target))
 			goto free_priv_tt_data;
 
-	if (tgt_queue_setup(&target->q, queued_cmds ? : TGT_QUEUE_DEPTH))
+	if (tgt_queue_create(target->proto, queued_cmds ? : TGT_QUEUE_DEPTH,
+			     &target->q))
 		goto tt_destroy;
 
 	if (tgt_sysfs_register_target(target))
@@ -305,7 +321,7 @@
 	return target;
 
 queue_destroy:
-	blk_cleanup_queue(target->q);
+	tgt_queue_destroy(target->q);
 tt_destroy:
 	if (target->tt->target_destroy)
 		target->tt->target_destroy(target);
@@ -336,7 +352,7 @@
 		target->tt->target_destroy(target);
 
 	destroy_workqueue(target->twq);
-	blk_cleanup_queue(target->q);
+	tgt_queue_destroy(target->q);
 	target_template_put(target->tt);
 	tgt_sysfs_unregister_target(target);
 
@@ -550,15 +566,9 @@
 {
 	struct io_restrictions *limits = &device->limits;
 	struct tgt_target_template *tt = device->target->tt;
-	struct request_queue *q;
-	int err;
+	struct request_queue *q = device->q;
 
-	err = tgt_queue_setup(&q, TGT_QUEUE_DEPTH);
-	if (err)
-		return err;
-
 	device->q = q;
-	q->queuedata = device;
 
 	blk_queue_max_sectors(q, min_not_zero(tt->max_sectors,
 					limits->max_sectors));
@@ -624,23 +634,16 @@
 	if (!device->dt_data)
 		goto put_template;
 
-	device->pt_data =
-		kzalloc(target->proto->priv_dev_data_size, GFP_KERNEL);
-	if (!device->pt_data)
-		goto free_priv_dt_data;
-
 	if (device->dt->create)
 		if (device->dt->create(device))
-			goto free_priv_pt_data;
+			goto free_priv_dt_data;
 
-	if (target->proto->attach_device)
-		target->proto->attach_device(device->pt_data);
-
-	if (tgt_device_queue_setup(device))
+	if (tgt_queue_create(target->proto, TGT_QUEUE_DEPTH, &device->q))
 		goto dt_destroy;
+	tgt_device_queue_setup(device);
 
 	if (tgt_sysfs_register_device(device))
-		goto cleaup_queue;
+		goto queue_destroy;
 
 	spin_lock_irqsave(&target->lock, flags);
 	list_add(&device->dlist, &target->device_list);
@@ -648,13 +651,11 @@
 
 	return 0;
 
-cleaup_queue:
-	blk_cleanup_queue(device->q);
+queue_destroy:
+	tgt_queue_destroy(device->q);
 dt_destroy:
 	if (device->dt->destroy)
 		device->dt->destroy(device);
-free_priv_pt_data:
-	kfree(device->pt_data);
 free_priv_dt_data:
 	kfree(device->dt_data);
 put_template:
@@ -668,20 +669,14 @@
 
 void tgt_device_free(struct tgt_device *device)
 {
-	struct tgt_target *target = device->target;
-
 	if (device->dt->destroy)
 		device->dt->destroy(device);
 
-	if (target->proto->detach_device)
-		target->proto->detach_device(device->pt_data);
-
-	blk_cleanup_queue(device->q);
+	tgt_queue_destroy(device->q);
 	fput(device->file);
 	device_template_put(device->dt);
 
 	kfree(device->dt_data);
-	kfree(device->pt_data);
 	kfree(device);
 }
 

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-16 05:12:40 UTC (rev 172)
+++ trunk/kernel/tgt_device.h	2005-11-17 05:18:38 UTC (rev 173)
@@ -64,7 +64,6 @@
 struct tgt_device {
 	struct tgt_device_template *dt;
 	void *dt_data;
-	void *pt_data;
 
 	struct class_device cdev;
 

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-11-16 05:12:40 UTC (rev 172)
+++ trunk/kernel/tgt_protocol.h	2005-11-17 05:18:38 UTC (rev 173)
@@ -26,8 +26,9 @@
 
 	kmem_cache_t *cmd_cache;
 	unsigned uspace_pdu_size;
-	unsigned priv_dev_data_size;
+	unsigned priv_queuedata_size;
 
+	char *elevator;
 	/*
 	 * Create a command and allocate a buffer of size data_len for
 	 * for transfer. The buffer will be allocated with GFP_KERNEL
@@ -51,10 +52,9 @@
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
 	/*
-	 * Initialize protocol specific data per device
+	 * Initialize protocol specific data per queue
 	 */
-	void (* attach_device)(void *data);
-	void (* detach_device)(void *data);
+	int (* queue_create)(void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-16 05:12:40 UTC (rev 172)
+++ trunk/kernel/tgt_scsi.c	2005-11-17 05:18:38 UTC (rev 173)
@@ -17,24 +17,118 @@
 #include <tgt_protocol.h>
 #include <tgt_target.h>
 
-enum scsi_tgt_device_state_bit {
-	STDEV_ORDERED,
-	STDEV_HEAD,
+static kmem_cache_t *scsi_tgt_cmd_cache;
+
+struct tgt_scsi_queuedata {
+	int nr_active; /* Can we use q->in_flight? */
+	int blocked;
 };
 
-/*
- * The ordering stuff can be generic for all protocols. If so, should
- * these be moved into struct tgt_device?
- */
-struct scsi_tgt_device {
-	spinlock_t lock;
-	struct list_head pending_cmds;
-	unsigned long state;
-	unsigned active_cmds;
+static struct request *elevator_tgt_scsi_next_request(request_queue_t *q)
+{
+	struct request *rq;
+	struct tgt_scsi_queuedata *sqdata = q->queuedata;
+	struct scsi_tgt_cmd *scmd;
+	int enabled = 0;
+
+	if (list_empty(&q->queue_head))
+		return NULL;
+
+	rq = list_entry_rq(q->queue_head.next);
+
+	scmd = tgt_cmd_to_scsi(rq->special);
+	dprintk("%p %x %x %d %d\n", rq->special, scmd->tags, scmd->scb[0],
+		sqdata->blocked, sqdata->nr_active);
+	switch (scmd->tags) {
+	case MSG_SIMPLE_TAG:
+		if (!sqdata->blocked)
+			enabled = 1;
+	case MSG_ORDERED_TAG:
+		if (!sqdata->blocked && !sqdata->nr_active)
+			enabled = 1;
+		break;
+	case MSG_HEAD_TAG:
+		enabled = 1;
+		break;
+	default:
+		BUG();
+	}
+
+	return enabled ? rq : NULL;
+}
+
+static void elevator_tgt_scsi_add_request(request_queue_t *q,
+					  struct request *rq, int where)
+{
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(rq->special);
+
+	switch (scmd->tags) {
+	case MSG_SIMPLE_TAG:
+	case MSG_ORDERED_TAG:
+		list_add_tail(&rq->queuelist, &q->queue_head);
+		break;
+	case MSG_HEAD_TAG:
+		list_add(&rq->queuelist, &q->queue_head);
+		break;
+	default:
+		eprintk("unknown scsi tag %p %x %x\n",
+			rq->special, scmd->tags, scmd->scb[0]);
+
+		scmd->tags = MSG_SIMPLE_TAG;
+		list_add_tail(&rq->queuelist, &q->queue_head);
+	}
+}
+
+static void elevator_tgt_scsi_remove_request(request_queue_t *q,
+					     struct request *rq)
+{
+	struct tgt_scsi_queuedata *sqdata = q->queuedata;
+	struct tgt_cmd *cmd = rq->special;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+
+	sqdata->nr_active++;
+
+	dprintk("%p %x %x %d %d %llu\n", rq->special, scmd->tags, scmd->scb[0],
+		sqdata->blocked, sqdata->nr_active,
+		cmd->device ? cmd->device->dev_id : ~0ULL);
+
+	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
+		sqdata->blocked = 1;
+}
+
+static struct elevator_type elevator_tgt_scsi = {
+	.ops = {
+		.elevator_next_req_fn = elevator_tgt_scsi_next_request,
+		.elevator_add_req_fn = elevator_tgt_scsi_add_request,
+		.elevator_remove_req_fn = elevator_tgt_scsi_remove_request,
+	},
+	.elevator_name = __stringify(KBUILD_MODNAME),
+	.elevator_owner = THIS_MODULE,
 };
 
-static kmem_cache_t *scsi_tgt_cmd_cache;
+static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
+{
+	struct request_queue *q = cmd->rq->q;
+	struct tgt_scsi_queuedata *sqdata = q->queuedata;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	unsigned long flags;
 
+	dprintk("%p %x %x %d %d %llu\n", cmd, scmd->tags, scmd->scb[0],
+		sqdata->blocked, sqdata->nr_active,
+		cmd->device ? cmd->device->dev_id : ~0ULL);
+
+	spin_lock_irqsave(q->queue_lock, flags);
+
+	sqdata->nr_active--;
+
+	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
+		sqdata->blocked = 0;
+
+	blk_plug_device(q);
+
+	spin_unlock_irqrestore(q->queue_lock, flags);
+}
+
 /*
  * we should be able to use scsi-ml's functions for this
  */
@@ -82,8 +176,7 @@
 
 	/* translate target driver LUN to device id */
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
-	device = tgt_device_find(session->target, cmd->dev_id);
-	cmd->device = device;
+	cmd->device = device = tgt_device_find(session->target, cmd->dev_id);
 
 	/* is this device specific */
 	cmd->data_dir = data_dir;
@@ -141,116 +234,6 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-#define	device_blocked(x)	((x)->state & (1 << STDEV_ORDERED | 1 << STDEV_HEAD))
-
-static int scsi_tgt_task_state(struct tgt_cmd *cmd, int queue, int *more)
-{
-	struct tgt_device *device = cmd->device;
-	struct scsi_tgt_device *stdev = device->pt_data;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	int enabled = 0;
-
-	*more = 0;
-	switch (scmd->tags) {
-	case MSG_SIMPLE_TAG:
-		if (!device_blocked(stdev) &&
-		    queue ? list_empty(&stdev->pending_cmds) : 1) {
-			enabled = 1;
-			*more = 1;
-		}
-
-		break;
-	case MSG_ORDERED_TAG:
-		if (!device_blocked(stdev) &&
-		    !stdev->active_cmds &&
-		    queue ? list_empty(&stdev->pending_cmds) : 1) {
-			enabled = 1;
-			stdev->state |= 1 << STDEV_ORDERED;
-		}
-		break;
-	case MSG_HEAD_TAG:
-		BUG_ON(!queue);
-		stdev->state |= 1 << STDEV_HEAD;
-		enabled = 1;
-		break;
-	default:
-		printk("unknown scsi tag %x\n", scmd->tags);
-		enabled = 1;
-		*more = 1;
-		break;
-	}
-
-	return enabled;
-}
-
-static void device_queue_cmd(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	cmd->device->dt->execute_cmd(cmd);
-}
-
-static void scsi_tgt_execute_pending_cmds(struct tgt_device *device)
-{
-	struct scsi_tgt_device *stdev = device->pt_data;
-	struct tgt_cmd *cmd, *tmp;
-	struct scsi_tgt_cmd *scmd;
-	int enabled, more;
-
-	list_for_each_entry_safe(cmd, tmp, &stdev->pending_cmds, clist) {
-		scmd = tgt_cmd_to_scsi(cmd);
-
-		enabled = scsi_tgt_task_state(cmd, 0, &more);
-		BUG_ON(!enabled && more);
-
-		if (enabled) {
-			list_del(&cmd->clist);
-			stdev->active_cmds++;
-			INIT_WORK(&cmd->work, device_queue_cmd, cmd);
-			queue_work(cmd->session->target->twq, &cmd->work);
-		}
-
-		if (!more)
-			break;
-	}
-}
-
-static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	struct tgt_device *device;
-	struct scsi_tgt_device *stdev;
-	unsigned long flags;
-
-	device = cmd->device;
-	if (!device)
-		return;
-
-	stdev = device->pt_data;
-	spin_lock_irqsave(&stdev->lock, flags);
-
-	stdev->active_cmds--;
-
-	switch (scmd->tags) {
-	case MSG_SIMPLE_TAG:
-		break;
-	case MSG_ORDERED_TAG:
-		stdev->state &= ~(1 << STDEV_ORDERED);
-		break;
-	case MSG_HEAD_TAG:
-		stdev->state &= ~(1 << STDEV_HEAD);
-		break;
-	default:
-		break;
-	}
-
-	if (!list_empty(&stdev->pending_cmds))
-		scsi_tgt_execute_pending_cmds(device);
-
-	spin_unlock_irqrestore(&stdev->lock, flags);
-}
-
-/* TODO: reimplement SCSI ordering by using the queuest_queue */
-
 static void __tgt_uspace_cmd_send(void *data)
 {
 	struct tgt_cmd *cmd = data;
@@ -266,39 +249,14 @@
 
 static int scsi_tgt_execute_cmd(struct tgt_cmd *cmd)
 {
-	struct tgt_device *device = cmd->device;
-	struct scsi_tgt_device *stdev;
-	unsigned long flags;
-	int err, enabled, more;
-
 	dprintk("%p %x\n", cmd, tgt_cmd_to_scsi(cmd)->scb[0]);
 
-	if (!device) {
+	if (!cmd->device) {
 		INIT_WORK(&cmd->work, __tgt_uspace_cmd_send, cmd);
 		queue_work(cmd->session->target->twq, &cmd->work);
 		return TGT_CMD_KERN_QUEUED;
-	}
-
-	stdev = device->pt_data;
-	spin_lock_irqsave(&stdev->lock, flags);
-
-	/* Do we need our own list_head? */
-	BUG_ON(!list_empty(&cmd->clist));
-
-	enabled = scsi_tgt_task_state(cmd, 1, &more);
-	if (enabled)
-		stdev->active_cmds++;
-	else
-		list_add_tail(&cmd->clist, &stdev->pending_cmds);
-
-	spin_unlock_irqrestore(&stdev->lock, flags);
-
-	if (enabled)
-		err = device->dt->execute_cmd(cmd);
-	else
-		err = TGT_CMD_KERN_QUEUED;
-
-	return err;
+	} else
+		return cmd->device->dt->execute_cmd(cmd);
 }
 
 static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
@@ -314,34 +272,16 @@
 		scsi_tgt_sense_copy(cmd);
 }
 
-static void scsi_tgt_attach_device(void *data)
-{
-	struct scsi_tgt_device *stdev = data;
-
-	spin_lock_init(&stdev->lock);
-	INIT_LIST_HEAD(&stdev->pending_cmds);
-	stdev->active_cmds = 0;
-}
-
-static void scsi_tgt_detach_device(void *data)
-{
-	struct scsi_tgt_device *stdev = data;
-
-	/* TODO */
-	BUG_ON(!list_empty(&stdev->pending_cmds));
-}
-
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
+	.elevator = elevator_tgt_scsi.elevator_name,
 	.create_cmd = scsi_tgt_create_cmd,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
 	.execute_cmd = scsi_tgt_execute_cmd,
 	.complete_cmd = scsi_tgt_complete_cmd,
-	.attach_device = scsi_tgt_attach_device,
-	.detach_device = scsi_tgt_detach_device,
-	.priv_dev_data_size = sizeof(struct scsi_tgt_device),
+	.priv_queuedata_size = sizeof(struct tgt_scsi_queuedata),
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 
@@ -360,13 +300,24 @@
 
 	err = tgt_protocol_register(&scsi_tgt_proto);
 	if (err)
-		kmem_cache_destroy(scsi_tgt_cmd_cache);
+		goto protocol_unregister;
 
+	err = elv_register(&elevator_tgt_scsi);
+	if (err)
+		goto cache_destroy;
+
+	return 0;
+cache_destroy:
+	kmem_cache_destroy(scsi_tgt_cmd_cache);
+protocol_unregister:
+	tgt_protocol_unregister(&scsi_tgt_proto);
+
 	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
+	elv_unregister(&elevator_tgt_scsi);
 	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	tgt_protocol_unregister(&scsi_tgt_proto);
 }



From tomo at berlios.de  Fri Nov 18 10:54:44 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 18 Nov 2005 10:54:44 +0100
Subject: [Stgt-svn] r178 - trunk/kernel
Message-ID: <200511180954.jAI9si2l025356@sheep.berlios.de>

Author: tomo
Date: 2005-11-18 10:54:37 +0100 (Fri, 18 Nov 2005)
New Revision: 178

Modified:
   trunk/kernel/tgt.c
Log:
Fix a bug that tgt_session_destroy does not unlink slist from target->session_list.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-18 04:07:40 UTC (rev 177)
+++ trunk/kernel/tgt.c	2005-11-18 09:54:37 UTC (rev 178)
@@ -455,6 +455,13 @@
 
 int tgt_session_destroy(struct tgt_session *session)
 {
+	struct tgt_target *target = session->target;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_del(&session->slist);
+	spin_unlock_irqrestore(&target->lock, flags);
+
 	mempool_destroy(session->cmd_pool);
 	kfree(session);
 



From tomo at berlios.de  Fri Nov 18 11:18:46 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 18 Nov 2005 11:18:46 +0100
Subject: [Stgt-svn] r179 - trunk/kernel
Message-ID: <200511181018.jAIAIkKb028562@sheep.berlios.de>

Author: tomo
Date: 2005-11-18 11:18:44 +0100 (Fri, 18 Nov 2005)
New Revision: 179

Modified:
   trunk/kernel/tgt.c
Log:
Fix a race in tgt_device_destroy.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-18 09:54:37 UTC (rev 178)
+++ trunk/kernel/tgt.c	2005-11-18 10:18:44 UTC (rev 179)
@@ -697,11 +697,12 @@
 
 	spin_lock_irqsave(&target->lock, flags);
 	device = tgt_device_find_nolock(target, dev_id);
+	if (device)
+		list_del(&device->dlist);
 	spin_unlock_irqrestore(&target->lock, flags);
 	if (!device)
 		return -EINVAL;
 
-	list_del(&device->dlist);
 	tgt_sysfs_unregister_device(device);
 
 	return 0;



From tomo at berlios.de  Fri Nov 18 13:12:14 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 18 Nov 2005 13:12:14 +0100
Subject: [Stgt-svn] r181 - trunk/kernel
Message-ID: <200511181212.jAICCE5R001563@sheep.berlios.de>

Author: tomo
Date: 2005-11-18 13:11:42 +0100 (Fri, 18 Nov 2005)
New Revision: 181

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
Create tgt_queuedata (and remove protocol-specific queuedata) for device lifetime management.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-18 11:32:05 UTC (rev 180)
+++ trunk/kernel/tgt.c	2005-11-18 12:11:42 UTC (rev 181)
@@ -212,11 +212,9 @@
 	if (!q)
 		return -ENOMEM;
 
-	if (proto->priv_queuedata_size) {
-		q->queuedata = kzalloc(proto->priv_queuedata_size, GFP_KERNEL);
-		if (!q->queuedata)
-			goto out;
-	}
+	q->queuedata = kzalloc(sizeof(struct tgt_queuedata), GFP_KERNEL);
+	if (!q->queuedata)
+		goto out;
 
 	/*
 	 * this is a tmp hack: we do not register this queue

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-18 11:32:05 UTC (rev 180)
+++ trunk/kernel/tgt.h	2005-11-18 12:11:42 UTC (rev 181)
@@ -66,6 +66,16 @@
 	unsigned long proto_priv[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
+enum {
+	TGT_QUEUE_DEL,
+	TGT_QUEUE_PRIVATE_START,
+};
+
+struct tgt_queuedata {
+	int active_cmd; /* should we use q->in_flight? */
+	unsigned long qflags;
+};
+
 extern struct tgt_session *
 tgt_session_create(struct tgt_target *target,
 		   int max_cmds,

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-11-18 11:32:05 UTC (rev 180)
+++ trunk/kernel/tgt_protocol.h	2005-11-18 12:11:42 UTC (rev 181)
@@ -26,7 +26,6 @@
 
 	kmem_cache_t *cmd_cache;
 	unsigned uspace_pdu_size;
-	unsigned priv_queuedata_size;
 
 	char *elevator;
 	/*

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-18 11:32:05 UTC (rev 180)
+++ trunk/kernel/tgt_scsi.c	2005-11-18 12:11:42 UTC (rev 181)
@@ -19,17 +19,16 @@
 
 static kmem_cache_t *scsi_tgt_cmd_cache;
 
-struct tgt_scsi_queuedata {
-	int nr_active; /* Can we use q->in_flight? */
-	int blocked;
+enum {
+	TGT_SCSI_QUEUE_BLOCKED = TGT_QUEUE_PRIVATE_START,
 };
 
 static struct request *elevator_tgt_scsi_next_request(request_queue_t *q)
 {
 	struct request *rq;
-	struct tgt_scsi_queuedata *sqdata = q->queuedata;
 	struct scsi_tgt_cmd *scmd;
 	int enabled = 0;
+	struct tgt_queuedata *tqd = q->queuedata;
 
 	if (list_empty(&q->queue_head))
 		return NULL;
@@ -37,14 +36,15 @@
 	rq = list_entry_rq(q->queue_head.next);
 
 	scmd = tgt_cmd_to_scsi(rq->special);
-	dprintk("%p %x %x %d %d\n", rq->special, scmd->tags, scmd->scb[0],
-		sqdata->blocked, sqdata->nr_active);
+	dprintk("%p %x %x %llx %d\n", rq->special, scmd->tags, scmd->scb[0],
+		(unsigned long long) tqd->qflags, tqd->active_cmd);
 	switch (scmd->tags) {
 	case MSG_SIMPLE_TAG:
-		if (!sqdata->blocked)
+		if (!test_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags))
 			enabled = 1;
 	case MSG_ORDERED_TAG:
-		if (!sqdata->blocked && !sqdata->nr_active)
+		if (!test_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags) &&
+		    !tqd->active_cmd)
 			enabled = 1;
 		break;
 	case MSG_HEAD_TAG:
@@ -82,18 +82,18 @@
 static void elevator_tgt_scsi_remove_request(request_queue_t *q,
 					     struct request *rq)
 {
-	struct tgt_scsi_queuedata *sqdata = q->queuedata;
+	struct tgt_queuedata *tqd = q->queuedata;
 	struct tgt_cmd *cmd = rq->special;
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
-	sqdata->nr_active++;
+	tqd->active_cmd++;
 
-	dprintk("%p %x %x %d %d %llu\n", rq->special, scmd->tags, scmd->scb[0],
-		sqdata->blocked, sqdata->nr_active,
+	dprintk("%p %x %x %llx %d %llu\n", rq->special, scmd->tags, scmd->scb[0],
+		(unsigned long long) tqd->qflags, tqd->active_cmd,
 		cmd->device ? cmd->device->dev_id : ~0ULL);
 
 	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
-		sqdata->blocked = 1;
+		set_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
 }
 
 static struct elevator_type elevator_tgt_scsi = {
@@ -109,20 +109,20 @@
 static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
 {
 	struct request_queue *q = cmd->rq->q;
-	struct tgt_scsi_queuedata *sqdata = q->queuedata;
+	struct tgt_queuedata *tqd = q->queuedata;
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	unsigned long flags;
 
-	dprintk("%p %x %x %d %d %llu\n", cmd, scmd->tags, scmd->scb[0],
-		sqdata->blocked, sqdata->nr_active,
+	dprintk("%p %x %x %llx %d %llu\n", cmd, scmd->tags, scmd->scb[0],
+		(unsigned long long) tqd->qflags, tqd->active_cmd,
 		cmd->device ? cmd->device->dev_id : ~0ULL);
 
 	spin_lock_irqsave(q->queue_lock, flags);
 
-	sqdata->nr_active--;
+	tqd->active_cmd--;
 
 	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
-		sqdata->blocked = 0;
+		clear_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
 
 	blk_plug_device(q);
 
@@ -281,7 +281,6 @@
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
 	.execute_cmd = scsi_tgt_execute_cmd,
 	.complete_cmd = scsi_tgt_complete_cmd,
-	.priv_queuedata_size = sizeof(struct tgt_scsi_queuedata),
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 



From tomo at berlios.de  Fri Nov 18 13:19:11 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 18 Nov 2005 13:19:11 +0100
Subject: [Stgt-svn] r182 - trunk/kernel
Message-ID: <200511181219.jAICJB5l005708@sheep.berlios.de>

Author: tomo
Date: 2005-11-18 13:19:09 +0100 (Fri, 18 Nov 2005)
New Revision: 182

Modified:
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sd.c
Log:
Trivial cleanups of printk.

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-18 12:11:42 UTC (rev 181)
+++ trunk/kernel/tgt_scsi.c	2005-11-18 12:19:09 UTC (rev 182)
@@ -167,7 +167,7 @@
 
 	cmd = tgt_cmd_create(session, tgt_priv);
 	if (!cmd) {
-		printk(KERN_ERR "Could not allocate command\n");
+		eprintk("Could not allocate command\n");
 		return NULL;
 	}
 	scmd = tgt_cmd_to_scsi(cmd);

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-11-18 12:11:42 UTC (rev 181)
+++ trunk/kernel/tgt_sd.c	2005-11-18 12:19:09 UTC (rev 182)
@@ -53,7 +53,7 @@
 		return -EINVAL;
 
 	device->size = inode->i_size;
-	printk("%d %llu\n", device->fd, inode->i_size >> 9);
+	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
 
 	return 0;
 }



From tomo at berlios.de  Sat Nov 19 07:26:03 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 19 Nov 2005 07:26:03 +0100
Subject: [Stgt-svn] r183 - in trunk: istgt/kernel kernel
Message-ID: <200511190626.jAJ6Q3FX018800@sheep.berlios.de>

Author: tomo
Date: 2005-11-19 07:25:52 +0100 (Sat, 19 Nov 2005)
New Revision: 183

Modified:
   trunk/istgt/kernel/iscsi.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_scsi.c
Log:
Device lifetime management by using class_device_get/put.


Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-11-18 12:19:09 UTC (rev 182)
+++ trunk/istgt/kernel/iscsi.h	2005-11-19 06:25:52 UTC (rev 183)
@@ -12,6 +12,7 @@
 #include <linux/crypto.h>
 #include <net/sock.h>
 #include <asm/scatterlist.h>
+#include <linux/blkdev.h>
 
 #include <iscsi_proto.h>
 #include <istgt_u.h>

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-18 12:19:09 UTC (rev 182)
+++ trunk/kernel/tgt.c	2005-11-19 06:25:52 UTC (rev 183)
@@ -544,7 +544,7 @@
 	return NULL;
 }
 
-struct tgt_device *tgt_device_find(struct tgt_target *target, uint64_t dev_id)
+static struct tgt_device *tgt_device_find(struct tgt_target *target, uint64_t dev_id)
 {
 	static struct tgt_device *device;
 	unsigned long flags;
@@ -555,8 +555,32 @@
 
 	return device;
 }
-EXPORT_SYMBOL_GPL(tgt_device_find);
 
+struct tgt_device *tgt_device_get(struct tgt_target *target, uint64_t dev_id)
+{
+	static struct tgt_device *device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	if (device)
+		if (test_bit(TGT_QUEUE_DEL, &tgt_qdata(device->q)->qflags))
+			device = NULL;
+		else
+			class_device_get(&device->cdev);
+
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return device;
+}
+EXPORT_SYMBOL_GPL(tgt_device_get);
+
+void tgt_device_put(struct tgt_device *device)
+{
+	class_device_put(&device->cdev);
+}
+EXPORT_SYMBOL_GPL(tgt_device_put);
+
 #define min_not_zero(l, r) (l == 0) ? r : ((r == 0) ? l : min(l, r))
 
 static int tgt_device_queue_setup(struct tgt_device *device)
@@ -666,6 +690,15 @@
 
 void tgt_device_free(struct tgt_device *device)
 {
+	struct tgt_target *target = device->target;
+	unsigned long flags;
+
+	dprintk("%d %lld\n", target->tid, (unsigned long long) device->dev_id);
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_del(&device->dlist);
+	spin_unlock_irqrestore(&target->lock, flags);
+
 	if (device->dt->destroy)
 		device->dt->destroy(device);
 
@@ -682,22 +715,35 @@
 	struct tgt_device *device;
 	struct tgt_target *target;
 	unsigned long flags;
+	int err = 0;
 
 	target = target_find(tid);
 	if (!target)
 		return -ENOENT;
 
+	/*
+	 * We cannot delete the device from the list because
+	 * uspace_cmd_done would use it later.
+	 */
 	spin_lock_irqsave(&target->lock, flags);
 	device = tgt_device_find_nolock(target, dev_id);
 	if (device)
-		list_del(&device->dlist);
+		err = test_and_set_bit(TGT_QUEUE_DEL,
+				       &tgt_qdata(device->q)->qflags);
 	spin_unlock_irqrestore(&target->lock, flags);
+
 	if (!device)
-		return -EINVAL;
+		return -ENOENT;
 
-	tgt_sysfs_unregister_device(device);
-
-	return 0;
+	if (err) {
+		eprintk("the device is being removed %d %lld\n",
+			tid, (unsigned long long) dev_id);
+		return -EBUSY;
+	} else {
+		/* TODO: revoke commands in the devece queue here. */
+		tgt_sysfs_unregister_device(device);
+		return 0;
+	}
 }
 
 static void tgt_free_buffer(struct tgt_cmd *cmd)

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-18 12:19:09 UTC (rev 182)
+++ trunk/kernel/tgt.h	2005-11-19 06:25:52 UTC (rev 183)
@@ -91,7 +91,12 @@
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 
+static inline struct tgt_queuedata *tgt_qdata(struct request_queue *q)
+{
+	return (struct tgt_queuedata *) q->queuedata;
+}
 
+
 #define DEBUG_TGT
 
 #define eprintk(fmt, args...)					\

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-18 12:19:09 UTC (rev 182)
+++ trunk/kernel/tgt_device.h	2005-11-19 06:25:52 UTC (rev 183)
@@ -91,8 +91,11 @@
         container_of(cdev, struct tgt_device, cdev)
 
 extern void tgt_device_free(struct tgt_device *device);
-extern struct tgt_device *tgt_device_find(struct tgt_target *target,
-					  uint64_t dev_id);
+extern struct tgt_device *tgt_device_get(struct tgt_target *target,
+					 uint64_t dev_id);
+extern void tgt_device_put(struct tgt_device *device);
+
+
 extern int tgt_sysfs_register_device(struct tgt_device *device);
 extern void tgt_sysfs_unregister_device(struct tgt_device *device);
 extern int tgt_device_template_register(struct tgt_device_template *dt);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-18 12:19:09 UTC (rev 182)
+++ trunk/kernel/tgt_scsi.c	2005-11-19 06:25:52 UTC (rev 183)
@@ -28,7 +28,7 @@
 	struct request *rq;
 	struct scsi_tgt_cmd *scmd;
 	int enabled = 0;
-	struct tgt_queuedata *tqd = q->queuedata;
+	struct tgt_queuedata *tqd = tgt_qdata(q);
 
 	if (list_empty(&q->queue_head))
 		return NULL;
@@ -82,7 +82,7 @@
 static void elevator_tgt_scsi_remove_request(request_queue_t *q,
 					     struct request *rq)
 {
-	struct tgt_queuedata *tqd = q->queuedata;
+	struct tgt_queuedata *tqd = tgt_qdata(q);
 	struct tgt_cmd *cmd = rq->special;
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
@@ -109,7 +109,7 @@
 static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
 {
 	struct request_queue *q = cmd->rq->q;
-	struct tgt_queuedata *tqd = q->queuedata;
+	struct tgt_queuedata *tqd = tgt_qdata(q);
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	unsigned long flags;
 
@@ -118,15 +118,14 @@
 		cmd->device ? cmd->device->dev_id : ~0ULL);
 
 	spin_lock_irqsave(q->queue_lock, flags);
-
 	tqd->active_cmd--;
-
 	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
 		clear_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
-
 	blk_plug_device(q);
-
 	spin_unlock_irqrestore(q->queue_lock, flags);
+
+	if (cmd->device)
+		tgt_device_put(cmd->device);
 }
 
 /*
@@ -176,7 +175,7 @@
 
 	/* translate target driver LUN to device id */
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
-	cmd->device = device = tgt_device_find(session->target, cmd->dev_id);
+	cmd->device = device = tgt_device_get(session->target, cmd->dev_id);
 
 	/* is this device specific */
 	cmd->data_dir = data_dir;



From tomo at berlios.de  Sat Nov 19 07:31:53 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 19 Nov 2005 07:31:53 +0100
Subject: [Stgt-svn] r184 - trunk/kernel
Message-ID: <200511190631.jAJ6VrWa021351@sheep.berlios.de>

Author: tomo
Date: 2005-11-19 07:31:51 +0100 (Sat, 19 Nov 2005)
New Revision: 184

Modified:
   trunk/kernel/tgt.c
Log:
Trivial change for gcc warning.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-19 06:25:52 UTC (rev 183)
+++ trunk/kernel/tgt.c	2005-11-19 06:31:51 UTC (rev 184)
@@ -563,12 +563,12 @@
 
 	spin_lock_irqsave(&target->lock, flags);
 	device = tgt_device_find_nolock(target, dev_id);
-	if (device)
+	if (device) {
 		if (test_bit(TGT_QUEUE_DEL, &tgt_qdata(device->q)->qflags))
 			device = NULL;
 		else
 			class_device_get(&device->cdev);
-
+	}
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return device;



From tomo at berlios.de  Sat Nov 19 17:38:46 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 19 Nov 2005 17:38:46 +0100
Subject: [Stgt-svn] r185 - trunk/usr
Message-ID: <200511191638.jAJGckok010825@sheep.berlios.de>

Author: tomo
Date: 2005-11-19 17:38:46 +0100 (Sat, 19 Nov 2005)
New Revision: 185

Modified:
   trunk/usr/netlink.c
Log:
Fix a bug that happens only on 32-bit architectures. This should be fixed in a better way later on.


Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-11-19 06:31:51 UTC (rev 184)
+++ trunk/usr/netlink.c	2005-11-19 16:38:46 UTC (rev 185)
@@ -133,7 +133,7 @@
 			ev_req->k.cmd_req.tid, ev_req->k.cmd_req.dev_id, cid);
 	}
 
-	memset(ev_res, 0, sizeof(*ev_res));
+	memset(ev_res, 0, (char *) ev_res->data - (char *) ev_res);
 	ev_res->u.cmd_res.tid = ev_req->k.cmd_req.tid;
 	ev_res->u.cmd_res.dev_id = ev_req->k.cmd_req.dev_id;
 	ev_res->u.cmd_res.cid = cid;



From tomo at berlios.de  Sun Nov 20 09:19:17 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 20 Nov 2005 09:19:17 +0100
Subject: [Stgt-svn] r186 - trunk/kernel
Message-ID: <200511200819.jAK8JH7r032595@sheep.berlios.de>

Author: tomo
Date: 2005-11-20 09:19:00 +0100 (Sun, 20 Nov 2005)
New Revision: 186

Modified:
   trunk/kernel/tgt_scsi.c
Log:
Fix gcc warning in ppc64 and sparc64.

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-19 16:38:46 UTC (rev 185)
+++ trunk/kernel/tgt_scsi.c	2005-11-20 08:19:00 UTC (rev 186)
@@ -90,7 +90,7 @@
 
 	dprintk("%p %x %x %llx %d %llu\n", rq->special, scmd->tags, scmd->scb[0],
 		(unsigned long long) tqd->qflags, tqd->active_cmd,
-		cmd->device ? cmd->device->dev_id : ~0ULL);
+		cmd->device ? (unsigned long long) cmd->device->dev_id : ~0ULL);
 
 	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
 		set_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
@@ -115,7 +115,7 @@
 
 	dprintk("%p %x %x %llx %d %llu\n", cmd, scmd->tags, scmd->scb[0],
 		(unsigned long long) tqd->qflags, tqd->active_cmd,
-		cmd->device ? cmd->device->dev_id : ~0ULL);
+		cmd->device ? (unsigned long long) cmd->device->dev_id : ~0ULL);
 
 	spin_lock_irqsave(q->queue_lock, flags);
 	tqd->active_cmd--;



From tomo at berlios.de  Mon Nov 21 15:15:41 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 21 Nov 2005 15:15:41 +0100
Subject: [Stgt-svn] r187 - trunk/kernel
Message-ID: <200511211415.jALEFfHJ015015@sheep.berlios.de>

Author: tomo
Date: 2005-11-21 15:15:40 +0100 (Mon, 21 Nov 2005)
New Revision: 187

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
Log:
Make tgt_session_destroy work asynchronously. tgt_session_destroy may
be called in interrupt context and need to wait for some commands to
finish because we cannot revoke I/O operations.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-20 08:19:00 UTC (rev 186)
+++ trunk/kernel/tgt.c	2005-11-21 14:15:40 UTC (rev 187)
@@ -350,103 +350,84 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_destroy);
 
-static int session_init(struct tgt_session *session, int max_cmds)
+struct tgt_session_wait {
+	struct completion event;
+	int err;
+};
+
+static void tgt_session_op_init(struct tgt_session *session,
+				void (*func)(void *),
+				tgt_session_done_t *done, void *arg)
 {
+	session->done = done;
+	session->arg = arg;
+	INIT_WORK(&session->work, func, session);
+	queue_work(session->target->twq, &session->work);
+}
+
+static void tgt_session_sync_helper(void *arg, struct tgt_session *session)
+{
+	struct tgt_session_wait *w = (struct tgt_session_wait *) arg;
+
+	if (session)
+		w->err = 0;
+	else
+		w->err = 1;
+	complete(&w->event);
+}
+
+static void tgt_session_async_create(void *data)
+{
+	struct tgt_session *session = (struct tgt_session *) data;
 	struct tgt_target *target = session->target;
 	struct tgt_protocol *proto = session->target->proto;
 	unsigned long flags;
+	int err = 0;
 
-	session->cmd_pool = mempool_create(max_cmds, mempool_alloc_slab,
+	session->cmd_pool = mempool_create(TGT_MAX_CMD, mempool_alloc_slab,
 					   mempool_free_slab, proto->cmd_cache);
 	if (!session->cmd_pool)
-		goto out;
+		err = -ENOMEM;
 
-	spin_lock_irqsave(&target->lock, flags);
-	list_add(&session->slist, &target->session_list);
-	spin_unlock_irqrestore(&target->lock, flags);
+	if (!err) {
+		spin_lock_irqsave(&target->lock, flags);
+		list_add(&session->slist, &target->session_list);
+		spin_unlock_irqrestore(&target->lock, flags);
+	}
 
-	return 0;
-out:
-	if (session->cmd_pool)
-		mempool_destroy(session->cmd_pool);
-
-	return -ENOMEM;
-}
-
-struct async_session_data {
-	struct tgt_session *session;
-	struct work_struct work;
-	int cmds;
-	void (*done)(void *, struct tgt_session *);
-	void *arg;
-};
-
-static void session_async_create(void *data)
-{
-	struct async_session_data *async
-		= (struct async_session_data *) data;
-	int err;
-
-	err = session_init(async->session, async->cmds);
+	session->done(session->arg, err ? NULL : session);
 	if (err)
-		kfree(async->session);
-	async->done(async->arg, err ? NULL : async->session);
-	kfree(async);
+		kfree(session);
 }
 
-struct tgt_session *
-tgt_session_create(struct tgt_target *target,
-		   int max_cmds,
-		   void (*done)(void *, struct tgt_session *),
-		   void *arg)
+struct tgt_session *tgt_session_create(struct tgt_target *target,
+				       tgt_session_done_t *done, void *arg)
 {
 	struct tgt_session *session;
-	struct async_session_data *async;
+	struct tgt_session_wait w;
 
-	BUG_ON(!target);
-
-	if (done && !arg) {
-		eprintk("Need arg %d!\n", target->tid);
-		return NULL;
-	}
-
-	dprintk("%p %d\n", target, max_cmds);
-
 	session = kzalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
 	if (!session)
 		return NULL;
-
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 
-	if (done) {
-		async = kmalloc(sizeof(*async), GFP_ATOMIC);
-		if (!async)
-			goto out;
-
-		async->session = session;
-		async->cmds = max_cmds;
-		async->done = done;
-		async->arg = arg;
-
-		INIT_WORK(&async->work, session_async_create, async);
-		queue_work(session->target->twq, &async->work);
-		return session;
+	init_completion(&w.event);
+	tgt_session_op_init(session, tgt_session_async_create,
+			    done ? : tgt_session_sync_helper,
+			    arg ? : &w);
+	if (!done) {
+		wait_for_completion(&w.event);
+		if (w.err)
+			return NULL;
 	}
-
-	if (session_init(session, max_cmds) < 0)
-		goto out;
-
 	return session;
-
-out:
-	kfree(session);
-	return NULL;
 }
 EXPORT_SYMBOL_GPL(tgt_session_create);
 
-int tgt_session_destroy(struct tgt_session *session)
+static void tgt_session_async_destroy(void *data)
 {
+	struct tgt_session *session = (struct tgt_session *) data;
 	struct tgt_target *target = session->target;
 	unsigned long flags;
 
@@ -454,9 +435,25 @@
 	list_del(&session->slist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
+	session->done(session->arg, NULL);
+
 	mempool_destroy(session->cmd_pool);
 	kfree(session);
+}
 
+int tgt_session_destroy(struct tgt_session *session,
+			tgt_session_done_t *done, void *arg)
+{
+	struct tgt_session_wait w;
+
+	init_completion(&w.event);
+	tgt_session_op_init(session, tgt_session_async_destroy,
+			    done ? : tgt_session_sync_helper,
+			    arg ? : &w);
+
+	if (!done)
+		wait_for_completion(&w.event);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(tgt_session_destroy);

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-20 08:19:00 UTC (rev 186)
+++ trunk/kernel/tgt.h	2005-11-21 14:15:40 UTC (rev 187)
@@ -18,12 +18,24 @@
 struct request;
 struct tgt_device;
 struct tgt_protocol;
+struct tgt_session;
 
+/*
+ * this should be in a tgt_target_template
+ */
+#define	TGT_MAX_CMD	64
+
+typedef void (tgt_session_done_t) (void *, struct tgt_session *);
+
 struct tgt_session {
 	struct tgt_target *target;
 	struct list_head slist;
 
 	mempool_t *cmd_pool;
+
+	struct work_struct work;
+	tgt_session_done_t *done;
+	void *arg;
 };
 
 enum {
@@ -78,10 +90,9 @@
 
 extern struct tgt_session *
 tgt_session_create(struct tgt_target *target,
-		   int max_cmds,
-		   void (*done)(void *, struct tgt_session *), void *arg);
-extern int tgt_session_destroy(struct tgt_session *session);
-
+		   tgt_session_done_t *done, void *arg);
+extern int tgt_session_destroy(struct tgt_session *session,
+			       tgt_session_done_t *done, void *arg);
 extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
 			gfp_t flags);
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask);



From tomo at berlios.de  Mon Nov 21 15:16:57 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 21 Nov 2005 15:16:57 +0100
Subject: [Stgt-svn] r188 - trunk/ibmvstgt/kernel
Message-ID: <200511211416.jALEGvJW015157@sheep.berlios.de>

Author: tomo
Date: 2005-11-21 15:16:57 +0100 (Mon, 21 Nov 2005)
New Revision: 188

Modified:
   trunk/ibmvstgt/kernel/ibmvstgt.c
Log:
Adjust ibmvstgt for the new session interface.

Modified: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-11-21 14:15:40 UTC (rev 187)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-11-21 14:16:57 UTC (rev 188)
@@ -1114,8 +1114,7 @@
 	INIT_WORK(&adapter->crq_work, handle_crq, adapter);
 	INIT_LIST_HEAD(&adapter->cmd_queue);
 
-	adapter->ts = tgt_session_create(tt, INITIAL_SRP_LIMIT,
-					 NULL, NULL);
+	adapter->ts = tgt_session_create(tt, NULL, NULL);
 	if (!adapter->ts)
 		goto free_tt;
 
@@ -1134,7 +1133,7 @@
 free_pool:
 	mempool_destroy(adapter->iu_pool);
 free_ts:
-	tgt_session_destroy(adapter->ts);
+	tgt_session_destroy(adapter->ts, NULL, NULL);
 free_tt:
 	tgt_target_destroy(tt);
 
@@ -1149,7 +1148,7 @@
 
 	crq_queue_destroy(adapter);
 	mempool_destroy(adapter->iu_pool);
-	tgt_session_destroy(adapter->ts);
+	tgt_session_destroy(adapter->ts, NULL, NULL);
 
 	tgt_target_destroy(tt);
 



From tomo at berlios.de  Mon Nov 21 15:17:23 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 21 Nov 2005 15:17:23 +0100
Subject: [Stgt-svn] r189 - trunk/istgt/kernel
Message-ID: <200511211417.jALEHNiX015221@sheep.berlios.de>

Author: tomo
Date: 2005-11-21 15:17:23 +0100 (Mon, 21 Nov 2005)
New Revision: 189

Modified:
   trunk/istgt/kernel/session.c
Log:
Adjust istgt for the new session interface.

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-11-21 14:16:57 UTC (rev 188)
+++ trunk/istgt/kernel/session.c	2005-11-21 14:17:23 UTC (rev 189)
@@ -53,7 +53,7 @@
 
 	list_add(&session->list, &target->session_list);
 
-	session->ts = tgt_session_create(target->tt, 64, NULL, NULL);
+	session->ts = tgt_session_create(target->tt, NULL, NULL);
 
 	return 0;
 }
@@ -81,7 +81,7 @@
 
 	list_del(&session->list);
 
-	tgt_session_destroy(session->ts);
+	tgt_session_destroy(session->ts, NULL, NULL);
 	kfree(session);
 
 	return 0;



From tomo at berlios.de  Mon Nov 21 23:49:55 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 21 Nov 2005 23:49:55 +0100
Subject: [Stgt-svn] r190 - trunk/kernel
Message-ID: <200511212249.jALMnt37025392@sheep.berlios.de>

Author: tomo
Date: 2005-11-21 23:49:54 +0100 (Mon, 21 Nov 2005)
New Revision: 190

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
Log:
Make sure that we don't try to destroy unfinished sessions.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-21 14:17:23 UTC (rev 189)
+++ trunk/kernel/tgt.c	2005-11-21 22:49:54 UTC (rev 190)
@@ -393,6 +393,8 @@
 		spin_lock_irqsave(&target->lock, flags);
 		list_add(&session->slist, &target->session_list);
 		spin_unlock_irqrestore(&target->lock, flags);
+
+		set_bit(TGT_SESSION_CREATED, &session->state);
 	}
 
 	session->done(session->arg, err ? NULL : session);
@@ -446,6 +448,9 @@
 {
 	struct tgt_session_wait w;
 
+	/* We cannot handle unfinished sessions. Should we do? */
+	BUG_ON(!test_bit(TGT_SESSION_CREATED, &session->state));
+
 	init_completion(&w.event);
 	tgt_session_op_init(session, tgt_session_async_destroy,
 			    done ? : tgt_session_sync_helper,

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-21 14:17:23 UTC (rev 189)
+++ trunk/kernel/tgt.h	2005-11-21 22:49:54 UTC (rev 190)
@@ -27,11 +27,16 @@
 
 typedef void (tgt_session_done_t) (void *, struct tgt_session *);
 
+enum {
+	TGT_SESSION_CREATED,
+};
+
 struct tgt_session {
 	struct tgt_target *target;
 	struct list_head slist;
 
 	mempool_t *cmd_pool;
+	unsigned long state;
 
 	struct work_struct work;
 	tgt_session_done_t *done;



