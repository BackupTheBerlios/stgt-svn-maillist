<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r535 - in branches/user-iscsi: . ibmvstgt kernel	patchset usr usr/iscsi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r535%20-%20in%20branches/user-iscsi%3A%20.%20ibmvstgt%20kernel%0A%09patchset%20usr%20usr/iscsi&In-Reply-To=%3C200608201901.k7KJ1VOX004329%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000521.html">
   <LINK REL="Next"  HREF="000523.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r535 - in branches/user-iscsi: . ibmvstgt kernel	patchset usr usr/iscsi</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r535%20-%20in%20branches/user-iscsi%3A%20.%20ibmvstgt%20kernel%0A%09patchset%20usr%20usr/iscsi&In-Reply-To=%3C200608201901.k7KJ1VOX004329%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r535 - in branches/user-iscsi: . ibmvstgt kernel	patchset usr usr/iscsi">tomo at mail.berlios.de
       </A><BR>
    <I>Sun Aug 20 21:01:31 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000521.html">[Stgt-svn] r534 - branches
</A></li>
        <LI>Next message: <A HREF="000523.html">[Stgt-svn] r536 - in branches/user-iscsi: . usr usr/include
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#522">[ date ]</a>
              <a href="thread.html#522">[ thread ]</a>
              <a href="subject.html#522">[ subject ]</a>
              <a href="author.html#522">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-08-20 21:00:24 +0200 (Sun, 20 Aug 2006)
New Revision: 535

Removed:
   branches/user-iscsi/ibmv
   branches/user-iscsi/ibmvstgt/Makefile
   branches/user-iscsi/ibmvstgt/kernel/
   branches/user-iscsi/initd
   branches/user-iscsi/kernel/Makefile
   branches/user-iscsi/kernel/scsi_tgt_if.c
   branches/user-iscsi/kernel/scsi_tgt_lib.c
   branches/user-iscsi/kernel/scsi_tgt_priv.h
   branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt
   branches/user-iscsi/patchset/README
   branches/user-iscsi/qla2xxx/
   branches/user-iscsi/usr/ibmvio/
   branches/user-iscsi/usr/iscsi/Makefile
   branches/user-iscsi/usr/iscsi/netlink.c
   branches/user-iscsi/usr/tgtif.c
Modified:
   branches/user-iscsi/Makefile
   branches/user-iscsi/README
   branches/user-iscsi/iscsi
   branches/user-iscsi/usr/Makefile
   branches/user-iscsi/usr/iscsi/conn.c
   branches/user-iscsi/usr/iscsi/iscsi.h
   branches/user-iscsi/usr/iscsi/iscsid.c
   branches/user-iscsi/usr/iscsi/iscsid.h
   branches/user-iscsi/usr/iscsi/istgt.c
   branches/user-iscsi/usr/iscsi/session.c
   branches/user-iscsi/usr/iscsi/types.h
   branches/user-iscsi/usr/mgmt.c
   branches/user-iscsi/usr/scsi.c
   branches/user-iscsi/usr/target.c
   branches/user-iscsi/usr/tgtd.c
   branches/user-iscsi/usr/tgtd.h
   branches/user-iscsi/usr/util.h
Log:
Commit initial code.

Modified: branches/user-iscsi/Makefile
===================================================================
--- branches/user-iscsi/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -2,31 +2,7 @@
 # Need to use some magic to select what target drivers will be complied
 #
 
-IBMVIO=1
-ISCSI=1
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-export IBMVIO
-export ISCSI
-export KERNELSRC
-
 all:
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt
-else
-	make -C istgt
-endif
 	make -C usr
-	make -C kernel
 clean:
 	make -C usr clean
-	make -C kernel clean
-
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt clean
-else
-	make -C istgt clean
-endif

Modified: branches/user-iscsi/README
===================================================================
--- branches/user-iscsi/README	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/README	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,83 +1,15 @@
 Introduction
 -------------
-Note that linux target framework (tgt) is under active
-development. Don't play with important data.
 
-Currently, tgt supports only one low level driver, IBM VIO server
-(ibmvstgt).
+This is an experimental branch to implement iscsi target software in
+user space by exploiting tgt user-space code.
 
 
 Starting
 -------------
-The software consists of kernel modules and user-space tools (daemon,
-management tool, dynamic libraries).
 
-First, get kernel sources from James's scsi-rc-fixes-2.6 git tree:
+First, modify the user-iscsi/iscsi schell script for configuration.
 
-master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-target-2.6.git
-
-Second, if you use ibmvstgt, apply scsi-target-2.6-tree.diff in the
-patchset directory. If not, you can skip this.
-
-Third, rebuild the kernel, and reboot with the new kernel.
-
-The compilation of the kernel modules require the path to above kernel
-source:
-
-host:~/use-scsi-ml$ make KERNELSRC=&lt;kernel-src&gt;
-
-Make sure that everything is built successfully. Now you can load the
-kernel modules by typing the followings.
-
-host:~/use-scsi-ml$ su
-host:~/use-scsi-ml# ./initd start
-
-See /var/log/kern.log (your Linux distributions may use the different
-log file name) to make sure that the kernel modules are loaded
-properly. You should see messages like the followings:
-
-Feb 27 19:37:52 lilac kernel: IBM eServer i/pSeries Virtual SCSI Target Driver
-Feb 27 19:37:52 lilac kernel: vio_register_driver: driver ibmvscsi registering
-Feb 27 19:37:52 lilac kernel: scsi1 : ibmvstgt
-
-You need the scsi host number (it is 1 in this example) in the next
-stage (configuration).
-
-
-Configuration
--------------
-
-Everyting is configured via the tgtadm management tool. Currenlty, tgt
-does not support persistent configurations. You can use a makeshift
-script, 'ibmv' to do the necessary job.
-
-Note that the ibmv script exports /dev/sdb1 to initiators as LUN 0 by
-defaults. You MUST change the device path if your /dev/sdb1 stores
-important data or your box does not have /dev/sdb1.
-
-host:~/use-scsi-ml# ./ibmv 1
-
-You need to specify the scsi host number as the first argument.
-
-Please see /var/log/daemon.log (your Linux distributions may use the
-different log file name again) to make sure that everything is
-fine. You should see something like the followings:
-
-Feb 27 22:36:40 lilac tgtd: dl_init(71) istgt library is not loaded.
-Feb 27 22:36:40 lilac tgtd: dl_init(71) ibmvstgt library is not loaded.
-Feb 27 22:37:08 lilac tgtd: tgt_target_create(572) Succeed to create a new target 1
-Feb 27 22:37:08 lilac tgtd: tgt_target_bind(517) Succeed to bind the target 1 to the scsi host 1
-Feb 27 22:37:08 lilac tgtd: tgt_device_create(238) Succeed to add a logical unit 0 to the target 1
-
-
-Now you are ready. Boot up VIO clients.
-
-Note that the tgt kernel modules enable the debug option by
-defaults. We are not ready for improving performance.
-
-
-Stopping
--------------
-Simply execute:
-
-host:~/use-scsi-ml# ./initd stop
+host:~/user-iscsi$ make
+host:~/user-iscsi$ su
+host:~/user-iscsi# ./iscsi

Deleted: branches/user-iscsi/ibmv
===================================================================
--- branches/user-iscsi/ibmv	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/ibmv	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,10 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start ibmvstgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
-${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --bus vio,30000003
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1

Deleted: branches/user-iscsi/ibmvstgt/Makefile
===================================================================
--- branches/user-iscsi/ibmvstgt/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/ibmvstgt/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,7 +0,0 @@
-SUBDIRS := $(shell pwd)
-
-mods:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
-
-clean:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Deleted: branches/user-iscsi/initd
===================================================================
--- branches/user-iscsi/initd	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/initd	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,132 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start tgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
-
-#
-# Need to select one
-#
-#TARGET=ibmvio
-TARGET=iscsi_tcp
-
-#
-# IBM pSeries VIO server
-#
-start_ibmvio()
-{
-	insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
-	insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
-}
-
-stop_ibmvio()
-{
-	rmmod libsrp
-	rmmod ibmvstgt
-}
-
-
-#
-# iSCSI stuff
-#
-start_iscsi_core()
-{
-	insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
-	insmod ${PWD}/istgt/kernel/libiscsi.ko
-}
-
-stop_iscsi_core()
-{
-	rmmod libiscsi
-	rmmod scsi_transport_iscsi
-}
-
-start_iscsi_tcp()
-{
-	modprobe -q crc32c
-
-	start_iscsi_core
-
-	insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
-	insmod ${PWD}/istgt/kernel/iscsi_tcp_target.ko
-}
-
-stop_iscsi_tcp()
-{
-	rmmod iscsi_tcp_target
-	rmmod iscsi_tcp
-}
-
-start_iscsi_iser()
-{
-    	start_iscsi_core
-}
-
-start_server()
-{
-	insmod ${PWD}/kernel/scsi_tgt.ko
-
-	case &quot;$TARGET&quot; in
-	    iscsi_tcp)
-		start_iscsi_tcp
-		;;
-	    ibmvio)
-		start_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	${PWD}/usr/tgtd -d8 --drivers iscsi
-
-	sleep 1
-}
-	
-stop_server()
-{
-	case &quot;$TARGET&quot; in
-	    iscsi_tcp)
-		${PWD}/usr/tgtadm --driver istgt --op delete
-		killall -9 istgtd
-		;;
-	    ibmvio)
-		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
-		;;
-	    *)
-		;;
-	esac
-
-	killall -9 tgtd
-
-	sleep 1
-
-	case &quot;$TARGET&quot; in
-	    iscsi_tcp)
-		stop_iscsi_tcp
-		;;
-	    ibmvio)
-		stop_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	rmmod scsi_tgt
-}
-
-case &quot;$1&quot; in
-	start)
-		start_server
-		;;
-	stop)
-		stop_server
-		;;
-	*)
-		echo &quot;Usage: {start|stop}&quot; &gt;&amp;2
-		exit 1
-		;;
-esac
-
-exit 0

Modified: branches/user-iscsi/iscsi
===================================================================
--- branches/user-iscsi/iscsi	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/iscsi	2006-08-20 19:00:24 UTC (rev 535)
@@ -5,5 +5,6 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+${PWD}/usr/tgtd --lld iscsi
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1

Deleted: branches/user-iscsi/kernel/Makefile
===================================================================
--- branches/user-iscsi/kernel/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,24 +0,0 @@
-#
-# Makefile for the Linux kernel device drivers.
-#
-
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17
-
-ifneq ($(KERNELRELEASE),)
-obj-m			+= scsi_tgt.o
-scsi_tgt-objs		:= scsi_tgt_lib.o scsi_tgt_if.o
-
-else
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-PWD := $(shell pwd)
-
-default:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) modules
-
-clean:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) clean
-endif

Deleted: branches/user-iscsi/kernel/scsi_tgt_if.c
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_if.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_if.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,315 +0,0 @@
-/*
- * SCSI target kernel/user interface functions
- *
- * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include &lt;linux/blkdev.h&gt;
-#include &lt;linux/file.h&gt;
-#include &lt;net/tcp.h&gt;
-#include &lt;scsi/scsi.h&gt;
-#include &lt;scsi/scsi_cmnd.h&gt;
-#include &lt;scsi/scsi_device.h&gt;
-#include &lt;scsi/scsi_host.h&gt;
-#include &lt;scsi/scsi_tgt.h&gt;
-#include &lt;scsi/scsi_tgt_if.h&gt;
-
-#include &quot;scsi_tgt_priv.h&quot;
-
-struct rbuf {
-	u32 idx;
-	u32 nr_entry;
-	int entry_size;
-	char *buf;
-	int buf_size;
-	spinlock_t lock;
-};
-
-static int chrdev;
-static struct rbuf txbuf, rxbuf;
-static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
-
-static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-{
-	u32 offset = (idx &amp; (rbuf-&gt;nr_entry - 1)) * rbuf-&gt;entry_size;
-	return (struct rbuf_hdr *) (rbuf-&gt;buf + offset);
-}
-
-static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-{
-	int i;
-
-	esize += sizeof(struct rbuf_hdr);
-	rbuf-&gt;idx = 0;
-	rbuf-&gt;entry_size = esize;
-	rbuf-&gt;buf = buf;
-	spin_lock_init(&amp;rbuf-&gt;lock);
-
-	bsize /= esize;
-	for (i = 0; (1 &lt;&lt; i) &lt; bsize &amp;&amp; (1 &lt;&lt; (i + 1)) &lt;= bsize; i++)
-		;
-	rbuf-&gt;nr_entry = 1 &lt;&lt; i;
-}
-
-static int send_event_rsp(u32 type, struct tgt_event *p)
-{
-	struct tgt_event *ev;
-	struct rbuf_hdr *hdr;
-	struct page *sp, *ep;
-	unsigned long flags;
-	int err = 0;
-
-	spin_lock_irqsave(&amp;txbuf.lock, flags);
-
-	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx);
-	if (hdr-&gt;status)
-		err = 1;
-	else
-		txbuf.idx++;
-
-	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
-
-	if (err)
-		return err;
-
-	ev = (struct tgt_event *) hdr-&gt;data;
-	memcpy(ev, p, sizeof(*ev));
-	ev-&gt;type = type;
-	hdr-&gt;status = 1;
-	mb();
-
-	sp = virt_to_page(hdr);
-	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-	for (;sp &lt;= ep; sp++)
-		flush_dcache_page(sp);
-
-	wake_up_interruptible(&amp;tgt_poll_wait);
-
-	return 0;
-}
-
-int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct tgt_event ev;
-	int err;
-
-	memset(&amp;ev, 0, sizeof(ev));
-	ev.k.cmd_req.host_no = shost-&gt;host_no;
-	ev.k.cmd_req.cid = cmd-&gt;request-&gt;tag;
-	ev.k.cmd_req.data_len = cmd-&gt;request_bufflen;
-	memcpy(ev.k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev.k.cmd_req.scb));
-	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-	ev.k.cmd_req.attribute = cmd-&gt;tag;
-	ev.k.cmd_req.tag = tag;
-
-	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-		ev.k.cmd_req.data_len, cmd-&gt;tag,
-		(unsigned long long) ev.k.cmd_req.tag);
-
-	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &amp;ev);
-	if (err)
-		eprintk(&quot;tx buf is full, could not send\n&quot;);
-	return err;
-}
-
-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct tgt_event ev;
-	int err;
-
-	memset(&amp;ev, 0, sizeof(ev));
-	ev.k.cmd_done.host_no = shost-&gt;host_no;
-	ev.k.cmd_done.cid = cmd-&gt;request-&gt;tag;
-	ev.k.cmd_done.result = cmd-&gt;result;
-
-	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-		ev.k.cmd_req.data_len, cmd-&gt;tag,
-		(unsigned long long) ev.k.cmd_req.tag);
-
-	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev);
-	if (err)
-		eprintk(&quot;tx buf is full, could not send\n&quot;);
-	return err;
-}
-
-int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-				  struct scsi_lun *scsilun, void *data)
-{
-	struct tgt_event ev;
-	int err;
-
-	memset(&amp;ev, 0, sizeof(ev));
-	ev.k.tsk_mgmt_req.host_no = host_no;
-	ev.k.tsk_mgmt_req.function = function;
-	ev.k.tsk_mgmt_req.tag = tag;
-	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
-
-	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
-		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-
-	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev);
-	if (err)
-		eprintk(&quot;tx buf is full, could not send\n&quot;);
-	return err;
-}
-
-static int event_recv_msg(struct tgt_event *ev)
-{
-	int err = 0;
-
-	switch (ev-&gt;type) {
-	case TGT_UEVENT_CMD_RSP:
-		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_rsp.host_no,
-					   ev-&gt;u.cmd_rsp.cid,
-					   ev-&gt;u.cmd_rsp.result,
-					   ev-&gt;u.cmd_rsp.len,
-					   ev-&gt;u.cmd_rsp.uaddr,
-					   ev-&gt;u.cmd_rsp.rw);
-		break;
-	case TGT_UEVENT_TSK_MGMT_RSP:
-		err = scsi_tgt_kspace_tsk_mgmt(ev-&gt;u.tsk_mgmt_rsp.host_no,
-					       ev-&gt;u.tsk_mgmt_rsp.mid,
-					       ev-&gt;u.tsk_mgmt_rsp.result);
-		break;
-	default:
-		eprintk(&quot;unknown type %d\n&quot;, ev-&gt;type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static ssize_t tgt_write(struct file *file, const char __user * buffer,
-			 size_t count, loff_t * ppos)
-{
-	struct rbuf_hdr *hdr;
-	struct tgt_event *ev;
-	struct page *sp, *ep;
-
-retry:
-	hdr = head_rbuf_hdr(&amp;rxbuf, rxbuf.idx);
-
-	sp = virt_to_page(hdr);
-	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-	for (;sp &lt;= ep; sp++)
-		flush_dcache_page(sp);
-
-	if (!hdr-&gt;status)
-		return count;
-
-	rxbuf.idx++;
-	ev = (struct tgt_event *) hdr-&gt;data;
-	event_recv_msg(ev);
-	hdr-&gt;status = 0;
-
-	goto retry;
-}
-
-static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
-{
-	struct rbuf_hdr *hdr;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	poll_wait(file, &amp;tgt_poll_wait, wait);
-
-	spin_lock_irqsave(&amp;txbuf.lock, flags);
-
-	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx - 1);
-	if (hdr-&gt;status)
-		mask |= POLLIN | POLLRDNORM;
-
-	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
-
-	return mask;
-}
-
-static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-	unsigned long size, addr;
-	struct page *page;
-	int err, i;
-
-	if (vma-&gt;vm_pgoff) {
-		eprintk(&quot;bug\n&quot;);
-		return -EINVAL;
-	}
-
-	size = vma-&gt;vm_end - vma-&gt;vm_start;
-	if (size != TGT_RINGBUF_SIZE * 2) {
-		eprintk(&quot;%lu\n&quot;, size);
-		return -EINVAL;
-	}
-	addr = vma-&gt;vm_start;
-	page = virt_to_page(txbuf.buf);
-	for (i = 0; i &lt; size &gt;&gt; PAGE_SHIFT; i++) {
-		err = vm_insert_page(vma, addr, page);
-		if (err) {
-			eprintk(&quot;%d %d %lu\n&quot;, err, i, addr);
-			return -EINVAL;
-		}
-		addr += PAGE_SIZE;
-		page++;
-	}
-
-	return 0;
-}
-
-static struct file_operations tgt_fops = {
-	.owner	= THIS_MODULE,
-	.poll	= tgt_poll,
-	.write	= tgt_write,
-	.mmap	= tgt_mmap,
-};
-
-void __exit scsi_tgt_if_exit(void)
-{
-	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-
-	unregister_chrdev(chrdev, &quot;tgt&quot;);
-	free_pages((unsigned long) txbuf.buf, order);
-}
-
-int __init scsi_tgt_if_init(void)
-{
-	u32 bsize = TGT_RINGBUF_SIZE;
-	int order;
-	char *buf;
-
-	chrdev = register_chrdev(0, &quot;tgt&quot;, &amp;tgt_fops);
-	if (chrdev &lt; 0)
-		return chrdev;
-
-	order = long_log2((bsize * 2) &gt;&gt; PAGE_SHIFT);
-	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-					order);
-	if (!buf)
-		goto free_dev;
-	rbuf_init(&amp;txbuf, buf, bsize, sizeof(struct tgt_event));
-	rbuf_init(&amp;rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
-
-	return 0;
-
-free_dev:
-	unregister_chrdev(chrdev, &quot;tgt&quot;);
-
-	return -ENOMEM;
-}

Deleted: branches/user-iscsi/kernel/scsi_tgt_lib.c
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_lib.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_lib.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,695 +0,0 @@
-/*
- * SCSI target lib functions
- *
- * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include &lt;linux/blkdev.h&gt;
-#include &lt;linux/hash.h&gt;
-#include &lt;linux/module.h&gt;
-#include &lt;linux/pagemap.h&gt;
-#include &lt;scsi/scsi.h&gt;
-#include &lt;scsi/scsi_cmnd.h&gt;
-#include &lt;scsi/scsi_device.h&gt;
-#include &lt;scsi/scsi_host.h&gt;
-#include &lt;scsi/scsi_tgt.h&gt;
-#include &lt;../drivers/md/dm-bio-list.h&gt;
-
-#include &quot;scsi_tgt_priv.h&quot;
-
-static struct workqueue_struct *scsi_tgtd;
-static kmem_cache_t *scsi_tgt_cmd_cache;
-
-/*
- * TODO: this struct will be killed when the block layer supports large bios
- * and James's work struct code is in
- */
-struct scsi_tgt_cmd {
-	/* TODO replace work with James b's code */
-	struct work_struct work;
-	/* TODO replace the lists with a large bio */
-	struct bio_list xfer_done_list;
-	struct bio_list xfer_list;
-
-	struct list_head hash_list;
-	struct request *rq;
-
-	void *buffer;
-	unsigned bufflen;
-};
-
-#define TGT_HASH_ORDER	4
-#define cmd_hashfn(cid)	hash_long((cid), TGT_HASH_ORDER)
-
-struct scsi_tgt_queuedata {
-	struct Scsi_Host *shost;
-	struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
-	spinlock_t cmd_hash_lock;
-};
-
-/*
- * Function:	scsi_host_get_command()
- *
- * Purpose:	Allocate and setup a scsi command block and blk request
- *
- * Arguments:	shost	- scsi host
- *		data_dir - dma data dir
- *		gfp_mask- allocator flags
- *
- * Returns:	The allocated scsi command structure.
- *
- * This should be called by target LLDs to get a command.
- */
-struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-					enum dma_data_direction data_dir,
-					gfp_t gfp_mask)
-{
-	int write = (data_dir == DMA_TO_DEVICE);
-	struct request *rq;
-	struct scsi_cmnd *cmd;
-	struct scsi_tgt_cmd *tcmd;
-
-	/* Bail if we can't get a reference to the device */
-	if (!get_device(&amp;shost-&gt;shost_gendev))
-		return NULL;
-
-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-	if (!tcmd)
-		goto put_dev;
-
-	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
-	if (!rq)
-		goto free_tcmd;
-
-	cmd = __scsi_get_command(shost, gfp_mask);
-	if (!cmd)
-		goto release_rq;
-
-	memset(cmd, 0, sizeof(*cmd));
-	cmd-&gt;sc_data_direction = data_dir;
-	cmd-&gt;jiffies_at_alloc = jiffies;
-	cmd-&gt;request = rq;
-
-	rq-&gt;special = cmd;
-	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-	rq-&gt;end_io_data = tcmd;
-
-	bio_list_init(&amp;tcmd-&gt;xfer_list);
-	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-	tcmd-&gt;rq = rq;
-
-	return cmd;
-
-release_rq:
-	blk_put_request(rq);
-free_tcmd:
-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-put_dev:
-	put_device(&amp;shost-&gt;shost_gendev);
-	return NULL;
-
-}
-EXPORT_SYMBOL_GPL(scsi_host_get_command);
-
-/*
- * Function:	scsi_host_put_command()
- *
- * Purpose:	Free a scsi command block
- *
- * Arguments:	shost	- scsi host
- * 		cmd	- command block to free
- *
- * Returns:	Nothing.
- *
- * Notes:	The command must not belong to any lists.
- */
-static void scsi_host_put_command(struct Scsi_Host *shost,
-				  struct scsi_cmnd *cmd)
-{
-	struct request_queue *q = shost-&gt;uspace_req_q;
-	struct request *rq = cmd-&gt;request;
-	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
-	unsigned long flags;
-
-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-
-	spin_lock_irqsave(q-&gt;queue_lock, flags);
-	__blk_put_request(q, rq);
-	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
-
-	__scsi_put_command(shost, cmd, &amp;shost-&gt;shost_gendev);
-}
-
-static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-{
-	struct bio *bio;
-
-	/* must call bio_endio in case bio was bounced */
-	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_done_list))) {
-		bio_endio(bio, bio-&gt;bi_size, 0);
-		bio_unmap_user(bio);
-	}
-
-	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list))) {
-		bio_endio(bio, bio-&gt;bi_size, 0);
-		bio_unmap_user(bio);
-	}
-}
-
-static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-{
-	struct request_queue *q = cmd-&gt;request-&gt;q;
-	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
-	unsigned long flags;
-	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-
-	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
-	list_del(&amp;tcmd-&gt;hash_list);
-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-}
-
-static void scsi_tgt_cmd_destroy(void *data)
-{
-	struct scsi_cmnd *cmd = data;
-	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-
-	dprintk(&quot;cmd %p %d %lu\n&quot;, cmd, cmd-&gt;sc_data_direction,
-		rq_data_dir(cmd-&gt;request));
-
-	cmd_hashlist_del(cmd);
-
-	/*
-	 * We must set rq-&gt;flags here because bio_map_user and
-	 * blk_rq_bio_prep ruined ti.
-	 */
-	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
-		cmd-&gt;request-&gt;flags |= 1;
-	else
-		cmd-&gt;request-&gt;flags &amp;= ~1UL;
-
-	scsi_unmap_user_pages(tcmd);
-	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-}
-
-static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
-{
-	struct scsi_tgt_queuedata *qdata = rq-&gt;q-&gt;queuedata;
-	unsigned long flags;
-	struct list_head *head;
-	static u32 tag = 0;
-
-	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
-	rq-&gt;tag = tag++;
-	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(rq-&gt;tag)];
-	list_add(&amp;tcmd-&gt;hash_list, head);
-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-}
-
-/*
- * scsi_tgt_alloc_queue - setup queue used for message passing
- * shost: scsi host
- *
- * This should be called by the LLD after host allocation.
- * And will be released when the host is released.
- */
-int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-{
-	struct scsi_tgt_queuedata *queuedata;
-	struct request_queue *q;
-	int err, i;
-
-	/*
-	 * Do we need to send a netlink event or should uspace
-	 * just respond to the hotplug event?
-	 */
-	q = __scsi_alloc_queue(shost, NULL);
-	if (!q)
-		return -ENOMEM;
-
-	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-	if (!queuedata) {
-		err = -ENOMEM;
-		goto cleanup_queue;
-	}
-	queuedata-&gt;shost = shost;
-	q-&gt;queuedata = queuedata;
-
-	/*
-	 * this is a silly hack. We should probably just queue as many
-	 * command as is recvd to userspace. uspace can then make
-	 * sure we do not overload the HBA
-	 */
-	q-&gt;nr_requests = shost-&gt;hostt-&gt;can_queue;
-	/*
-	 * We currently only support software LLDs so this does
-	 * not matter for now. Do we need this for the cards we support?
-	 * If so we should make it a host template value.
-	 */
-	blk_queue_dma_alignment(q, 0);
-	shost-&gt;uspace_req_q = q;
-
-	for (i = 0; i &lt; ARRAY_SIZE(queuedata-&gt;cmd_hash); i++)
-		INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_hash[i]);
-	spin_lock_init(&amp;queuedata-&gt;cmd_hash_lock);
-
-	return 0;
-
-cleanup_queue:
-	blk_cleanup_queue(q);
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-
-struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_queuedata *queue = cmd-&gt;request-&gt;q-&gt;queuedata;
-	return queue-&gt;shost;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-
-/*
- * scsi_tgt_queue_command - queue command for userspace processing
- * @cmd:	scsi command
- * @scsilun:	scsi lun
- * @tag:	unique value to identify this command for tmf
- */
-int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-			   u64 tag)
-{
-	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-	int err;
-
-	init_scsi_tgt_cmd(cmd-&gt;request, tcmd);
-	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-	if (err)
-		cmd_hashlist_del(cmd);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-
-/*
- * This is run from a interrpt handler normally and the unmap
- * needs process context so we must queue
- */
-static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-
-	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
-
-	scsi_tgt_uspace_send_status(cmd);
-	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
-	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
-}
-
-static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	int err;
-
-	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
-
-	err = shost-&gt;hostt-&gt;transfer_response(cmd, scsi_tgt_cmd_done);
-	switch (err) {
-	case SCSI_MLQUEUE_HOST_BUSY:
-	case SCSI_MLQUEUE_DEVICE_BUSY:
-		return -EAGAIN;
-	}
-
-	return 0;
-}
-
-static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-{
-	int err;
-
-	err = __scsi_tgt_transfer_response(cmd);
-	if (!err)
-		return;
-
-	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
-	err = scsi_tgt_uspace_send_status(cmd);
-	if (err &lt;= 0)
-		/* the eh will have to pick this up */
-		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
-}
-
-static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-{
-	struct request *rq = cmd-&gt;request;
-	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
-	int count;
-
-	cmd-&gt;use_sg = rq-&gt;nr_phys_segments;
-	cmd-&gt;request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-	if (!cmd-&gt;request_buffer)
-		return -ENOMEM;
-
-	cmd-&gt;request_bufflen = rq-&gt;data_len;
-
-	dprintk(&quot;cmd %p addr %p cnt %d %lu\n&quot;, cmd, tcmd-&gt;buffer, cmd-&gt;use_sg,
-		rq_data_dir(rq));
-	count = blk_rq_map_sg(rq-&gt;q, rq, cmd-&gt;request_buffer);
-	if (likely(count &lt;= cmd-&gt;use_sg)) {
-		cmd-&gt;use_sg = count;
-		return 0;
-	}
-
-	eprintk(&quot;cmd %p addr %p cnt %d\n&quot;, cmd, tcmd-&gt;buffer, cmd-&gt;use_sg);
-	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
-	return -EINVAL;
-}
-
-/* TODO: test this crap and replace bio_map_user with new interface maybe */
-static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-			       int rw)
-{
-	struct request_queue *q = cmd-&gt;request-&gt;q;
-	struct request *rq = cmd-&gt;request;
-	void *uaddr = tcmd-&gt;buffer;
-	unsigned int len = tcmd-&gt;bufflen;
-	struct bio *bio;
-	int err;
-
-	while (len &gt; 0) {
-		dprintk(&quot;%lx %u\n&quot;, (unsigned long) uaddr, len);
-		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
-		if (IS_ERR(bio)) {
-			err = PTR_ERR(bio);
-			dprintk(&quot;fail to map %lx %u %d %x\n&quot;,
-				(unsigned long) uaddr, len, err, cmd-&gt;cmnd[0]);
-			goto unmap_bios;
-		}
-
-		uaddr += bio-&gt;bi_size;
-		len -= bio-&gt;bi_size;
-
-		/*
-		 * The first bio is added and merged. We could probably
-		 * try to add others using scsi_merge_bio() but for now
-		 * we keep it simple. The first bio should be pretty large
-		 * (either hitting the 1 MB bio pages limit or a queue limit)
-		 * already but for really large IO we may want to try and
-		 * merge these.
-		 */
-		if (!rq-&gt;bio) {
-			blk_rq_bio_prep(q, rq, bio);
-			rq-&gt;data_len = bio-&gt;bi_size;
-		} else
-			/* put list of bios to transfer in next go around */
-			bio_list_add(&amp;tcmd-&gt;xfer_list, bio);
-	}
-
-	cmd-&gt;offset = 0;
-	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-	if (err)
-		goto unmap_bios;
-
-	return 0;
-
-unmap_bios:
-	if (rq-&gt;bio) {
-		bio_unmap_user(rq-&gt;bio);
-		while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list)))
-			bio_unmap_user(bio);
-	}
-
-	return err;
-}
-
-static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-
-static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-	struct bio *bio;
-	int err;
-
-	/* should we free resources here on error ? */
-	if (cmd-&gt;result) {
-send_uspace_err:
-		err = scsi_tgt_uspace_send_status(cmd);
-		if (err &lt;= 0)
-			/* the tgt uspace eh will have to pick this up */
-			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
-		return;
-	}
-
-	dprintk(&quot;cmd %p request_bufflen %u bufflen %u\n&quot;,
-		cmd, cmd-&gt;request_bufflen, tcmd-&gt;bufflen);
-
-	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
-	bio_list_add(&amp;tcmd-&gt;xfer_done_list, cmd-&gt;request-&gt;bio);
-
-	tcmd-&gt;buffer += cmd-&gt;request_bufflen;
-	cmd-&gt;offset += cmd-&gt;request_bufflen;
-
-	if (!tcmd-&gt;xfer_list.head) {
-		scsi_tgt_transfer_response(cmd);
-		return;
-	}
-
-	dprintk(&quot;cmd2 %p request_bufflen %u bufflen %u\n&quot;,
-		cmd, cmd-&gt;request_bufflen, tcmd-&gt;bufflen);
-
-	bio = bio_list_pop(&amp;tcmd-&gt;xfer_list);
-	BUG_ON(!bio);
-
-	blk_rq_bio_prep(cmd-&gt;request-&gt;q, cmd-&gt;request, bio);
-	cmd-&gt;request-&gt;data_len = bio-&gt;bi_size;
-	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-	if (err) {
-		cmd-&gt;result = DID_ERROR &lt;&lt; 16;
-		goto send_uspace_err;
-	}
-
-	if (scsi_tgt_transfer_data(cmd)) {
-		cmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
-		goto send_uspace_err;
-	}
-}
-
-static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-{
-	int err;
-	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-
-	err = host-&gt;hostt-&gt;transfer_data(cmd, scsi_tgt_data_transfer_done);
-	switch (err) {
-		case SCSI_MLQUEUE_HOST_BUSY:
-		case SCSI_MLQUEUE_DEVICE_BUSY:
-			return -EAGAIN;
-	default:
-		return 0;
-	}
-}
-
-static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-				unsigned len)
-{
-	char __user *p = (char __user *) uaddr;
-
-	if (copy_from_user(cmd-&gt;sense_buffer, p,
-			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-		printk(KERN_ERR &quot;Could not copy the sense buffer\n&quot;);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-{
-	int err;
-
-	err = host-&gt;hostt-&gt;eh_abort_handler(cmd);
-	if (err)
-		eprintk(&quot;fail to abort %p\n&quot;, cmd);
-
-	scsi_tgt_cmd_destroy(cmd);
-	return err;
-}
-
-static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
-{
-	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
-	struct request *rq = NULL;
-	struct list_head *head;
-	struct scsi_tgt_cmd *tcmd;
-	unsigned long flags;
-
-	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(cid)];
-	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
-	list_for_each_entry(tcmd, head, hash_list) {
-		if (tcmd-&gt;rq-&gt;tag == cid) {
-			rq = tcmd-&gt;rq;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-
-	return rq;
-}
-
-int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-			 unsigned long uaddr, u8 rw)
-{
-	struct Scsi_Host *shost;
-	struct scsi_cmnd *cmd;
-	struct request *rq;
-	struct scsi_tgt_cmd *tcmd;
-	int err = 0;
-
-	dprintk(&quot;%d %u %d %u %lx %u\n&quot;, host_no, cid, result,
-		len, uaddr, rw);
-
-	/* TODO: replace with a O(1) alg */
-	shost = scsi_host_lookup(host_no);
-	if (IS_ERR(shost)) {
-		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
-		return -EINVAL;
-	}
-
-	rq = tgt_cmd_hash_lookup(shost-&gt;uspace_req_q, cid);
-	if (!rq) {
-		printk(KERN_ERR &quot;Could not find cid %u\n&quot;, cid);
-		err = -EINVAL;
-		goto done;
-	}
-	cmd = rq-&gt;special;
-
-	dprintk(&quot;cmd %p result %d len %d bufflen %u %lu %x\n&quot;, cmd,
-		result, len, cmd-&gt;request_bufflen, rq_data_dir(rq), cmd-&gt;cmnd[0]);
-
-	if (result == TASK_ABORTED) {
-		scsi_tgt_abort_cmd(shost, cmd);
-		goto done;
-	}
-	/*
-	 * store the userspace values here, the working values are
-	 * in the request_* values
-	 */
-	tcmd = cmd-&gt;request-&gt;end_io_data;
-	tcmd-&gt;buffer = (void *)uaddr;
-	tcmd-&gt;bufflen = len;
-	cmd-&gt;result = result;
-
-	if (!tcmd-&gt;bufflen) {
-		err = __scsi_tgt_transfer_response(cmd);
-		goto done;
-	}
-
-	/*
-	 * TODO: Do we need to handle case where request does not
-	 * align with LLD.
-	 */
-	err = scsi_map_user_pages(rq-&gt;end_io_data, cmd, rw);
-	if (err) {
-		eprintk(&quot;%p %d\n&quot;, cmd, err);
-		err = -EAGAIN;
-		goto done;
-	}
-
-	/* userspace failure */
-	if (cmd-&gt;result) {
-		if (status_byte(cmd-&gt;result) == CHECK_CONDITION)
-			scsi_tgt_copy_sense(cmd, uaddr, len);
-		err = __scsi_tgt_transfer_response(cmd);
-		goto done;
-	}
-	/* ask the target LLD to transfer the data to the buffer */
-	err = scsi_tgt_transfer_data(cmd);
-
-done:
-	scsi_host_put(shost);
-	return err;
-}
-
-int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-			      struct scsi_lun *scsilun, void *data)
-{
-	int err;
-
-	/* TODO: need to retry if this fails. */
-	err = scsi_tgt_uspace_send_tsk_mgmt(shost-&gt;host_no, function,
-					    tag, scsilun, data);
-	if (err &lt; 0)
-		eprintk(&quot;The task management request lost!\n&quot;);
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-
-int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-{
-	struct Scsi_Host *shost;
-	int err;
-
-	dprintk(&quot;%d %d %llx\n&quot;, host_no, result, (unsigned long long) mid);
-
-	shost = scsi_host_lookup(host_no);
-	if (IS_ERR(shost)) {
-		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
-		return -EINVAL;
-	}
-	err = shost-&gt;hostt-&gt;tsk_mgmt_response(mid, result);
-	scsi_host_put(shost);
-
-	return err;
-}
-
-static int __init scsi_tgt_init(void)
-{
-	int err;
-
-	scsi_tgt_cmd_cache = kmem_cache_create(&quot;scsi_tgt_cmd&quot;,
-					       sizeof(struct scsi_tgt_cmd),
-					       0, 0, NULL, NULL);
-	if (!scsi_tgt_cmd_cache)
-		return -ENOMEM;
-
-	scsi_tgtd = create_workqueue(&quot;scsi_tgtd&quot;);
-	if (!scsi_tgtd) {
-		err = -ENOMEM;
-		goto free_kmemcache;
-	}
-
-	err = scsi_tgt_if_init();
-	if (err)
-		goto destroy_wq;
-
-	return 0;
-
-destroy_wq:
-	destroy_workqueue(scsi_tgtd);
-free_kmemcache:
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
-	return err;
-}
-
-static void __exit scsi_tgt_exit(void)
-{
-	destroy_workqueue(scsi_tgtd);
-	scsi_tgt_if_exit();
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
-}
-
-module_init(scsi_tgt_init);
-module_exit(scsi_tgt_exit);
-
-MODULE_DESCRIPTION(&quot;SCSI target core&quot;);
-MODULE_LICENSE(&quot;GPL&quot;);

Deleted: branches/user-iscsi/kernel/scsi_tgt_priv.h
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_priv.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_priv.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,24 +0,0 @@
-struct scsi_cmnd;
-struct scsi_lun;
-struct Scsi_Host;
-struct task_struct;
-
-/* tmp - will replace with SCSI logging stuff */
-#define eprintk(fmt, args...)					\
-do {								\
-	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#define dprintk eprintk
-
-extern void scsi_tgt_if_exit(void);
-extern int scsi_tgt_if_init(void);
-
-extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-				    u64 tag);
-extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
-extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-				unsigned long uaddr, u8 rw);
-extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-					 struct scsi_lun *scsilun, void *data);
-extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);

Deleted: branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,583 +0,0 @@
-Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143376921 +0900
-
----
-
- drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
- drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
- drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
- drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
- 4 files changed, 142 insertions(+), 125 deletions(-)
-
-74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool-&gt;events[i].ext_list) {
- 			dma_free_coherent(hostdata-&gt;dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool-&gt;events[i].ext_list,
- 				  pool-&gt;events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_out_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_in_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd-&gt;data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd-&gt;data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
-+	else
-+		srp_cmd-&gt;buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i &lt; num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i &lt; num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
--	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd-&gt;additional_data;
--		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd-&gt;add_data;
-+		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd-&gt;additional_data;
--		int num_mapped = indirect-&gt;head.length / 
--			sizeof(indirect-&gt;list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd-&gt;add_data;
-+		int num_mapped = indirect-&gt;table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
-+			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i &lt; num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &amp;sg[i];
--		descr-&gt;virtual_address = sg_dma_address(sg_entry);
--		descr-&gt;length = sg_dma_len(sg_entry);
--		descr-&gt;memory_handle = 0;
-+		descr-&gt;va = sg_dma_address(sg_entry);
-+		descr-&gt;len = sg_dma_len(sg_entry);
-+		descr-&gt;key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd-&gt;request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
--		data-&gt;length = sg_dma_len(&amp;sg[0]);
--		data-&gt;memory_handle = 0;
-+		data-&gt;va = sg_dma_address(&amp;sg[0]);
-+		data-&gt;len = sg_dma_len(&amp;sg[0]);
-+		data-&gt;key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect-&gt;head.virtual_address = 0;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	indirect-&gt;head.memory_handle = 0;
-+	indirect-&gt;table_desc.va = 0;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect-&gt;table_desc.key = 0;
- 
- 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
--		indirect-&gt;total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &amp;indirect-&gt;desc_list[0]);
-+		indirect-&gt;len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct-&gt;ext_list) {
--		evt_struct-&gt;ext_list =(struct memory_descriptor*)
-+		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&amp;evt_struct-&gt;ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &amp;evt_struct-&gt;ext_list_token, 0);
- 		if (!evt_struct-&gt;ext_list) {
--		    printk(KERN_ERR
--		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
-+			printk(KERN_ERR
-+			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
- 
--	indirect-&gt;total_length = total_length;
--	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect-&gt;len = total_length;
-+	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
-+	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
- 
--	data-&gt;virtual_address =
-+	data-&gt;va =
- 		dma_map_single(dev, cmd-&gt;request_buffer,
- 			       cmd-&gt;request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data-&gt;virtual_address)) {
-+	if (dma_mapping_error(data-&gt;va)) {
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
- 		return 0;
- 	}
--	data-&gt;length = cmd-&gt;request_bufflen;
--	data-&gt;memory_handle = 0;
-+	data-&gt;len = cmd-&gt;request_bufflen;
-+	data-&gt;key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
--	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
-+	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
- 
--	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
--			       rsp-&gt;type);
-+			       rsp-&gt;opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd-&gt;result = rsp-&gt;status;
- 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd-&gt;sense_buffer,
--			       rsp-&gt;sense_and_response_data,
--			       rsp-&gt;sense_data_list_length);
-+			       rsp-&gt;data,
-+			       rsp-&gt;sense_data_len);
- 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct-&gt;hostdata-&gt;dev);
- 
--		if (rsp-&gt;doover)
--			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
--		else if (rsp-&gt;diover)
--			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
-+		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
-+		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
- 	}
- 
- 	if (evt_struct-&gt;cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
- 	u16 lun = lun_from_dev(cmnd-&gt;device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd-&gt;type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd-&gt;opcode = SRP_CMD;
- 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
- 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct-&gt;cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
--	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
--	    (indirect-&gt;head.virtual_address == 0)) {
--		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
-+	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
-+	    indirect-&gt;table_desc.va == 0) {
-+		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
--	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
- 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
--		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
-+		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
- 
--	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
-+	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
- 	    (max_requests - 2))
--		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
-+		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&amp;hostdata-&gt;request_limit,
--		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
-+		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
- 
- 	hostdata-&gt;host-&gt;can_queue =
--	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
- 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &amp;evt_struct-&gt;iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login-&gt;type = SRP_LOGIN_REQ_TYPE;
--	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login-&gt;required_buffer_formats = 0x0006;
-+	login-&gt;opcode = SRP_LOGIN_REQ;
-+	login-&gt;req_it_iu_len = sizeof(union srp_iu);
-+	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt-&gt;task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
- 
- 	evt-&gt;sync_srp = &amp;srp_rsp;
- 	init_completion(&amp;evt-&gt;comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
-+			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
- 			       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
- 		printk(KERN_INFO
- 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
--		       tsk_mgmt-&gt;managed_task_tag);
-+		       tsk_mgmt-&gt;task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;task_tag);
- 
- 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
- 	list_del(&amp;found_evt-&gt;list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
- 	       tsk_mgmt-&gt;lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
--		       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       rsp_rc, tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
- 			   &amp;hostdata-&gt;request_limit);
- 
- 	if (evt_struct-&gt;done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include &lt;linux/dma-mapping.h&gt;
- #include &lt;linux/interrupt.h&gt;
- #include &quot;ibmvscsi.h&quot;
--#include &quot;srp.h&quot;
- 
- static char partition_name[97] = &quot;UNKNOWN&quot;;
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include &quot;srp.h&quot;
-+#include &lt;scsi/srp.h&gt;
-+
-+#define SRP_VERSION &quot;16.a&quot;
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,246 +0,0 @@
-Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143377151 +0900
-
----
-
- drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
- 1 files changed, 0 insertions(+), 227 deletions(-)
- delete mode 100644 drivers/scsi/ibmvscsi/srp.h
-
-acbd74e89dc7bcf4e2596800e46a19378db44641
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION &quot;16.a&quot;
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,375 +0,0 @@
-Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
-
-This patch moves scsi_host_get_command and scsi_host_put_command to
-scsi_tgt_lib.c from scsi.c
-
-A target driver allocates scsi_cmnd structure via
-scsi_host_get_command, then pass it to tgt core via
-scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
-needs to allocate scsi_tgt_cmd structure (for tgt specific data).
-Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
-target drivers.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi.c         |  102 ++++------------------------------------
- drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
- include/scsi/scsi_cmnd.h    |    6 +-
- include/scsi/scsi_tgt.h     |    4 ++
- 4 files changed, 112 insertions(+), 109 deletions(-)
-
-b8f2574dbd844ac43602d9fa74e6196027528c63
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 9c22465..1d2fbe0 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
--
--/*
-- * Function:	scsi_host_get_command()
-- *
-- * Purpose:	Allocate and setup a scsi command block and blk request
-- *
-- * Arguments:	shost	- scsi host
-- *		data_dir - dma data dir
-- *		gfp_mask- allocator flags
-- *
-- * Returns:	The allocated scsi command structure.
-- *
-- * This should be called by target LLDs to get a command.
-- */
--struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
--					enum dma_data_direction data_dir,
--					gfp_t gfp_mask)
--{
--	int write = (data_dir == DMA_TO_DEVICE);
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--
--	/* Bail if we can't get a reference to the device */
--	if (!get_device(&amp;shost-&gt;shost_gendev))
--		return NULL;
--
--	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
--	if (!rq)
--		goto put_dev;
--
--	cmd = __scsi_get_command(shost, gfp_mask);
--	if (!cmd)
--		goto release_rq;
--
--	memset(cmd, 0, sizeof(*cmd));
--	cmd-&gt;sc_data_direction = data_dir;
--	cmd-&gt;jiffies_at_alloc = jiffies;
--	cmd-&gt;request = rq;
--
--	rq-&gt;special = cmd;
--	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
--
--	return cmd;
--
--release_rq:
--	blk_put_request(rq);
--put_dev:
--	put_device(&amp;shost-&gt;shost_gendev);
--	return NULL;
--
--}
--EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&amp;dev-&gt;sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
--/*
-- * Function:	scsi_host_put_command()
-- *
-- * Purpose:	Free a scsi command block
-- *
-- * Arguments:	shost	- scsi host
-- * 		cmd	- command block to free
-- *
-- * Returns:	Nothing.
-- *
-- * Notes:	The command must not belong to any lists.
-- */
--void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
- {
--	struct request_queue *q = shost-&gt;uspace_req_q;
--	struct request *rq = cmd-&gt;request;
- 	unsigned long flags;
- 
- 	/* changing locks here, don't need to restore the irq state */
-@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
- 		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
- 		cmd = NULL;
- 	}
--	spin_unlock(&amp;shost-&gt;free_list_lock);
--
--	spin_lock(q-&gt;queue_lock);
--	__blk_put_request(q, rq);
--	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
-+	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
- 
- 	if (likely(cmd != NULL))
- 		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
- 
--	put_device(&amp;shost-&gt;shost_gendev);
-+	put_device(dev);
- }
--EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+EXPORT_SYMBOL(__scsi_put_command);
- 
- /*
-  * Function:	scsi_put_command()
-@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd-&gt;device;
--	struct Scsi_Host *shost = sdev-&gt;host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&amp;cmd-&gt;device-&gt;list_lock, flags);
- 	BUG_ON(list_empty(&amp;cmd-&gt;list));
- 	list_del_init(&amp;cmd-&gt;list);
--	spin_unlock(&amp;cmd-&gt;device-&gt;list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&amp;shost-&gt;free_list_lock);
--	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
--		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
--
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
-+	spin_unlock_irqrestore(&amp;cmd-&gt;device-&gt;list_lock, flags);
- 
--	put_device(&amp;sdev-&gt;sdev_gendev);
-+	__scsi_put_command(cmd-&gt;device-&gt;host, cmd, &amp;sdev-&gt;sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index aea3e4d..e82340c 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
- 	struct list_head cmd_req;
- };
- 
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&amp;shost-&gt;shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd-&gt;sc_data_direction = data_dir;
-+	cmd-&gt;jiffies_at_alloc = jiffies;
-+	cmd-&gt;request = rq;
-+
-+	rq-&gt;special = cmd;
-+	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq-&gt;end_io_data = tcmd;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&amp;shost-&gt;shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+static void scsi_host_put_command(struct Scsi_Host *shost,
-+				  struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost-&gt;uspace_req_q;
-+	struct request *rq = cmd-&gt;request;
-+	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q-&gt;queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &amp;shost-&gt;shost_gendev);
-+}
-+
- static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
- {
- 	struct bio *bio;
-@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
- 		cmd-&gt;request-&gt;flags &amp;= ~1UL;
- 
- 	scsi_unmap_user_pages(tcmd);
--	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
- }
- 
-@@ -177,13 +265,13 @@ out:
- 		goto retry;
- }
- 
--/**
-+/*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-  *
-  * This should be called by the LLD after host allocation.
-  * And will be released when the host is released.
-- **/
-+ */
- int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
- {
- 	struct scsi_tgt_queuedata *queuedata;
-@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
- 
--/**
-+/*
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-  * @noblock:	set to nonzero if the command should be queued
-- **/
-+ */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
- 	struct request_queue *q = cmd-&gt;request-&gt;q;
- 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
- 	unsigned long flags;
--	struct scsi_tgt_cmd *tcmd;
--
--	/*
--	 * It would be better to allocate scsi_tgt_cmd structure in
--	 * scsi_host_get_command and not to fail due to OOM.
--	 */
--	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
--	if (!tcmd)
--		return -ENOMEM;
--	cmd-&gt;request-&gt;end_io_data = tcmd;
-+	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
- 
- 	bio_list_init(&amp;tcmd-&gt;xfer_list);
- 	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 51156c7..c822bc2 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -150,11 +150,11 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
--extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
--					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
--extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-index 2d65be7..61e8ee9 100644
---- a/include/scsi/scsi_tgt.h
-+++ b/include/scsi/scsi_tgt.h
-@@ -2,6 +2,8 @@
-  * SCSI target definitions
-  */
- 
-+#include &lt;linux/dma-mapping.h&gt;
-+
- struct Scsi_Host;
- struct scsi_cmnd;
- struct scsi_lun;
-@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
- extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
- extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
- 				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,554 +0,0 @@
-Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
-
-The user-space damoen and tgt kernel module need to exhange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch replaces netlink shared memory between kernel and user
-spaces. The user-space damoen and tgt kernel module creates shared
-memory via mmap and use it like ring buffer. poll (kernel to user) and
-write (user to kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
- drivers/scsi/scsi_tgt_lib.c  |   10 +
- drivers/scsi/scsi_tgt_priv.h |    6 -
- include/linux/netlink.h      |    1 
- include/scsi/scsi_tgt_if.h   |   19 +--
- 5 files changed, 216 insertions(+), 131 deletions(-)
-
-cd29acfca7cdeb8c351db14af357207e9dcb17f3
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-index 37e0feb..c4c5bdb 100644
---- a/drivers/scsi/scsi_tgt_if.c
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -21,7 +21,6 @@
-  */
- #include &lt;linux/blkdev.h&gt;
- #include &lt;linux/file.h&gt;
--#include &lt;linux/netlink.h&gt;
- #include &lt;net/tcp.h&gt;
- #include &lt;scsi/scsi.h&gt;
- #include &lt;scsi/scsi_cmnd.h&gt;
-@@ -32,87 +31,129 @@
- 
- #include &quot;scsi_tgt_priv.h&quot;
- 
--static int tgtd_pid;
--static struct sock *nl_sk;
-+struct rbuf {
-+	u32 idx;
-+	u32 nr_entry;
-+	int entry_size;
-+	char *buf;
-+	int buf_size;
-+	spinlock_t lock;
-+};
-+
-+static int chrdev;
-+static struct rbuf txbuf, rxbuf;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
- 
--static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
--			  pid_t pid)
-+static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-+{
-+	u32 offset = (idx &amp; (rbuf-&gt;nr_entry - 1)) * rbuf-&gt;entry_size;
-+	return (struct rbuf_hdr *) (rbuf-&gt;buf + offset);
-+}
-+
-+static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-+{
-+	int i;
-+
-+	esize += sizeof(struct rbuf_hdr);
-+	rbuf-&gt;idx = 0;
-+	rbuf-&gt;entry_size = esize;
-+	rbuf-&gt;buf = buf;
-+	spin_lock_init(&amp;rbuf-&gt;lock);
-+
-+	bsize /= esize;
-+	for (i = 0; (1 &lt;&lt; i) &lt; bsize &amp;&amp; (1 &lt;&lt; (i + 1)) &lt;= bsize; i++)
-+		;
-+	rbuf-&gt;nr_entry = 1 &lt;&lt; i;
-+}
-+
-+static int send_event_rsp(u32 type, struct tgt_event *p)
- {
- 	struct tgt_event *ev;
--	struct nlmsghdr *nlh;
--	struct sk_buff *skb;
--	uint32_t len;
--
--	len = NLMSG_SPACE(sizeof(*ev));
--	skb = alloc_skb(len, flags);
--	if (!skb)
--		return -ENOMEM;
-+	struct rbuf_hdr *hdr;
-+	struct page *sp, *ep;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&amp;txbuf.lock, flags);
-+
-+	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx);
-+	if (hdr-&gt;status)
-+		err = 1;
-+	else
-+		txbuf.idx++;
- 
--	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
- 
--	ev = NLMSG_DATA(nlh);
-+	if (err)
-+		return err;
-+
-+	ev = (struct tgt_event *) hdr-&gt;data;
- 	memcpy(ev, p, sizeof(*ev));
-+	ev-&gt;type = type;
-+	hdr-&gt;status = 1;
-+	mb();
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-+	for (;sp &lt;= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	wake_up_interruptible(&amp;tgt_poll_wait);
- 
--	return netlink_unicast(nl_sk, skb, pid, 0);
-+	return 0;
- }
- 
--int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
--			 gfp_t flags)
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
--	struct sk_buff *skb;
--	struct nlmsghdr *nlh;
--	struct tgt_event *ev;
--	int err, len;
-+	struct tgt_event ev;
-+	int err;
- 
--	len = NLMSG_SPACE(sizeof(*ev));
--	/*
--	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
--	 */
--	skb = alloc_skb(NLMSG_SPACE(len), flags);
--	if (!skb)
--		return -ENOMEM;
--
--	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
--			  len - sizeof(*nlh), 0);
--
--	ev = NLMSG_DATA(nlh);
--	ev-&gt;k.cmd_req.host_no = shost-&gt;host_no;
--	ev-&gt;k.cmd_req.cid = cmd-&gt;request-&gt;tag;
--	ev-&gt;k.cmd_req.data_len = cmd-&gt;request_bufflen;
--	memcpy(ev-&gt;k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev-&gt;k.cmd_req.scb));
--	memcpy(ev-&gt;k.cmd_req.lun, lun, sizeof(ev-&gt;k.cmd_req.lun));
--	ev-&gt;k.cmd_req.attribute = cmd-&gt;tag;
--	ev-&gt;k.cmd_req.tag = tag;
--
--	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev-&gt;k.cmd_req.cid,
--		ev-&gt;k.cmd_req.data_len, cmd-&gt;tag,
--		(unsigned long long) ev-&gt;k.cmd_req.tag);
--
--	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
--	if (err &lt; 0)
--		printk(KERN_ERR &quot;scsi_tgt_uspace_send: could not send skb %d\n&quot;,
--		       err);
-+	memset(&amp;ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost-&gt;host_no;
-+	ev.k.cmd_req.cid = cmd-&gt;request-&gt;tag;
-+	ev.k.cmd_req.data_len = cmd-&gt;request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd-&gt;tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd-&gt;tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
- 	return err;
- }
- 
--int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&amp;ev, 0, sizeof(ev));
- 	ev.k.cmd_done.host_no = shost-&gt;host_no;
- 	ev.k.cmd_done.cid = cmd-&gt;request-&gt;tag;
- 	ev.k.cmd_done.result = cmd-&gt;result;
- 
--	return send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev, gfp_mask, tgtd_pid);
-+	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd-&gt;tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
-+	return err;
- }
- 
- int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
- 				  struct scsi_lun *scsilun, void *data)
- {
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&amp;ev, 0, sizeof(ev));
- 	ev.k.tsk_mgmt_req.host_no = host_no;
-@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
- 	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
- 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
- 
--	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev, GFP_KERNEL, tgtd_pid);
-+	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
-+	return err;
- }
- 
--static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+static int event_recv_msg(struct tgt_event *ev)
- {
--	struct tgt_event *ev = NLMSG_DATA(nlh);
- 	int err = 0;
- 
--	dprintk(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type,
--		nlh-&gt;nlmsg_pid, current-&gt;pid);
--
--	switch (nlh-&gt;nlmsg_type) {
--	case TGT_UEVENT_REQ:
--		tgtd_pid = NETLINK_CREDS(skb)-&gt;pid;
--		break;
-+	switch (ev-&gt;type) {
- 	case TGT_UEVENT_CMD_RSP:
--		/* TODO: handle multiple cmds in one event */
- 		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_rsp.host_no,
- 					   ev-&gt;u.cmd_rsp.cid,
- 					   ev-&gt;u.cmd_rsp.result,
-@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
- 					       ev-&gt;u.tsk_mgmt_rsp.result);
- 		break;
- 	default:
--		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
-+		eprintk(&quot;unknown type %d\n&quot;, ev-&gt;type);
- 		err = -EINVAL;
- 	}
- 
- 	return err;
- }
- 
--static int event_recv_skb(struct sk_buff *skb)
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
- {
--	int err;
--	uint32_t rlen;
--	struct nlmsghdr	*nlh;
--	struct tgt_event ev;
-+	struct rbuf_hdr *hdr;
-+	struct tgt_event *ev;
-+	struct page *sp, *ep;
- 
--	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
--		nlh = (struct nlmsghdr *) skb-&gt;data;
--		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
--			return 0;
--		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
--		if (rlen &gt; skb-&gt;len)
--			rlen = skb-&gt;len;
--		err = event_recv_msg(skb, nlh);
--
--		dprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
--		/*
--		 * TODO for passthru commands the lower level should
--		 * probably handle the result or we should modify this
--		 */
--		switch (nlh-&gt;nlmsg_type) {
--		case TGT_UEVENT_CMD_RSP:
--		case TGT_UEVENT_TSK_MGMT_RSP:
--			break;
--		default:
--			memset(&amp;ev, 0, sizeof(ev));
--			ev.k.event_rsp.err = err;
--			send_event_rsp(TGT_KEVENT_RSP, &amp;ev,
--				       GFP_KERNEL | __GFP_NOFAIL,
--					nlh-&gt;nlmsg_pid);
--		}
--		skb_pull(skb, rlen);
--	}
--	return 0;
-+retry:
-+	hdr = head_rbuf_hdr(&amp;rxbuf, rxbuf.idx);
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-+	for (;sp &lt;= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	if (!hdr-&gt;status)
-+		return count;
-+
-+	rxbuf.idx++;
-+	ev = (struct tgt_event *) hdr-&gt;data;
-+	event_recv_msg(ev);
-+	hdr-&gt;status = 0;
-+
-+	goto retry;
- }
- 
--static void event_recv(struct sock *sk, int length)
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
- {
--	struct sk_buff *skb;
-+	struct rbuf_hdr *hdr;
-+	unsigned long flags;
-+	unsigned int mask = 0;
- 
--	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
--		if (NETLINK_CREDS(skb)-&gt;uid) {
--			skb_pull(skb, skb-&gt;len);
--			kfree_skb(skb);
--			continue;
--		}
-+	poll_wait(file, &amp;tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&amp;txbuf.lock, flags);
- 
--		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
--			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
--		else
--			kfree_skb(skb);
-+	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx - 1);
-+	if (hdr-&gt;status)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
-+
-+	return mask;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long size, addr;
-+	struct page *page;
-+	int err, i;
-+
-+	if (vma-&gt;vm_pgoff) {
-+		eprintk(&quot;bug\n&quot;);
-+		return -EINVAL;
-+	}
-+
-+	size = vma-&gt;vm_end - vma-&gt;vm_start;
-+	if (size != TGT_RINGBUF_SIZE * 2) {
-+		eprintk(&quot;%lu\n&quot;, size);
-+		return -EINVAL;
-+	}
-+	addr = vma-&gt;vm_start;
-+	page = virt_to_page(txbuf.buf);
-+	for (i = 0; i &lt; size &gt;&gt; PAGE_SHIFT; i++) {
-+		err = vm_insert_page(vma, addr, page);
-+		if (err) {
-+			eprintk(&quot;%d %d %lu\n&quot;, err, i, addr);
-+			return -EINVAL;
-+		}
-+		addr += PAGE_SIZE;
-+		page++;
- 	}
-+
-+	return 0;
- }
- 
-+static struct file_operations tgt_fops = {
-+	.owner	= THIS_MODULE,
-+	.poll	= tgt_poll,
-+	.write	= tgt_write,
-+	.mmap	= tgt_mmap,
-+};
-+
- void __exit scsi_tgt_if_exit(void)
- {
--	sock_release(nl_sk-&gt;sk_socket);
-+	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-+
-+	unregister_chrdev(chrdev, &quot;tgt&quot;);
-+	free_pages((unsigned long) txbuf.buf, order);
- }
- 
- int __init scsi_tgt_if_init(void)
- {
--	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
--				    THIS_MODULE);
--	if (!nl_sk)
--		return -ENOMEM;
-+	u32 bsize = TGT_RINGBUF_SIZE;
-+	int order;
-+	char *buf;
-+
-+	chrdev = register_chrdev(0, &quot;tgt&quot;, &amp;tgt_fops);
-+	if (chrdev &lt; 0)
-+		return chrdev;
-+
-+	order = long_log2((bsize * 2) &gt;&gt; PAGE_SHIFT);
-+	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-+					order);
-+	if (!buf)
-+		goto free_dev;
-+	rbuf_init(&amp;txbuf, buf, bsize, sizeof(struct tgt_event));
-+	rbuf_init(&amp;rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
- 
- 	return 0;
-+
-+free_dev:
-+	unregister_chrdev(chrdev, &quot;tgt&quot;);
-+
-+	return -ENOMEM;
- }
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index e82340c..7ebfbc0 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -246,7 +246,7 @@ retry:
- 	tcmd = rq-&gt;end_io_data;
- 	init_scsi_tgt_cmd(rq, tcmd);
- 	cmd = rq-&gt;special;
--	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, tcmd-&gt;tag, GFP_ATOMIC);
-+	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
- 	if (err &lt; 0) {
- 		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
- 
-@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
- 
- 	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
- 
--	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+	scsi_tgt_uspace_send_status(cmd);
- 	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
- 	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
- }
-@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
- 		return;
- 
- 	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
--	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
-+	err = scsi_tgt_uspace_send_status(cmd);
-+	if (err &lt;= 0)
- 		/* the eh will have to pick this up */
- 		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
- }
-@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
- 	/* should we free resources here on error ? */
- 	if (cmd-&gt;result) {
- send_uspace_err:
--		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
-+		err = scsi_tgt_uspace_send_status(cmd);
-+		if (err &lt;= 0)
- 			/* the tgt uspace eh will have to pick this up */
- 			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
- 		return;
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-index 77a1d06..bd16a2c 100644
---- a/drivers/scsi/scsi_tgt_priv.h
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -14,9 +14,9 @@ do {								\
- extern void scsi_tgt_if_exit(void);
- extern int scsi_tgt_if_init(void);
- 
--extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
--				u64 tag, gfp_t flags);
--extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
- extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
- 				unsigned long uaddr, u8 rw);
- extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 9422ae5..c256ebe 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,7 +21,6 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
--#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-index 63b2e3a..74392a9 100644
---- a/include/scsi/scsi_tgt_if.h
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -24,25 +24,20 @@
- 
- enum tgt_event_type {
- 	/* user -&gt; kernel */
--	TGT_UEVENT_REQ,
- 	TGT_UEVENT_CMD_RSP,
- 	TGT_UEVENT_TSK_MGMT_RSP,
- 
- 	/* kernel -&gt; user */
--	TGT_KEVENT_RSP,
- 	TGT_KEVENT_CMD_REQ,
- 	TGT_KEVENT_CMD_DONE,
- 	TGT_KEVENT_TSK_MGMT_REQ,
- };
- 
- struct tgt_event {
-+	uint32_t type;
- 	/* user-&gt; kernel */
- 	union {
- 		struct {
--			int type;
--			int host_no;
--		} event_req;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t len;
-@@ -60,9 +55,6 @@ struct tgt_event {
- 	/* kernel -&gt; user */
- 	union {
- 		struct {
--			int err;
--		} event_rsp;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t data_len;
-@@ -86,4 +78,13 @@ struct tgt_event {
- 	} k;
- 
- } __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RINGBUF_SIZE (1UL &lt;&lt; 16)
-+
-+struct rbuf_hdr {
-+	uint32_t status;
-+	uint32_t len;
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
- #endif
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,197 +0,0 @@
-Subject: [PATCH] scsi target: kill target command list
-
-scsi_tgt_queue_command just adds a command to the list and then kernel
-thread sends it to user space because scsi_tgt_queue_command cannot
-use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
-
-Now we don't use netlink any more. So we can kill the list and
-scsi_tgt_queue_command just sends a command to user space.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
- 1 files changed, 24 insertions(+), 82 deletions(-)
-
-0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index 7ebfbc0..5c66f10 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
- 	/* TODO replace the lists with a large bio */
- 	struct bio_list xfer_done_list;
- 	struct bio_list xfer_list;
--	struct scsi_lun *lun;
- 
- 	struct list_head hash_list;
- 	struct request *rq;
--	u64 tag;
- 
- 	void *buffer;
- 	unsigned bufflen;
-@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
- 	struct Scsi_Host *shost;
- 	struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
- 	spinlock_t cmd_hash_lock;
--
--	struct work_struct uspace_send_work;
--
--	spinlock_t cmd_req_lock;
--	struct mutex cmd_req_mutex;
--	struct list_head cmd_req;
- };
- 
- /*
-@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
- 	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
- 	rq-&gt;end_io_data = tcmd;
- 
-+	bio_list_init(&amp;tcmd-&gt;xfer_list);
-+	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-+	tcmd-&gt;rq = rq;
-+
- 	return cmd;
- 
- release_rq:
-@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
- 	}
- }
- 
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd-&gt;request-&gt;q;
-+	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-+
-+	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
-+	list_del(&amp;tcmd-&gt;hash_list);
-+	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-+}
-+
- static void scsi_tgt_cmd_destroy(void *data)
- {
- 	struct scsi_cmnd *cmd = data;
- 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
--	struct scsi_tgt_queuedata *qdata = cmd-&gt;request-&gt;q-&gt;queuedata;
--	unsigned long flags;
- 
- 	dprintk(&quot;cmd %p %d %lu\n&quot;, cmd, cmd-&gt;sc_data_direction,
- 		rq_data_dir(cmd-&gt;request));
- 
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
--	list_del(&amp;tcmd-&gt;hash_list);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-+	cmd_hashlist_del(cmd);
- 
- 	/*
- 	 * We must set rq-&gt;flags here because bio_map_user and
-@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
- 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
- }
- 
--static void scsi_tgt_uspace_send_fn(void *data)
--{
--	struct request_queue *q = data;
--	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--	struct scsi_tgt_cmd *tcmd;
--	unsigned long flags;
--	int err;
--
--retry:
--	err = 0;
--	if (list_empty(&amp;qdata-&gt;cmd_req))
--		return;
--
--	mutex_lock(&amp;qdata-&gt;cmd_req_mutex);
--
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--	if (list_empty(&amp;qdata-&gt;cmd_req)) {
--		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--		mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
--		goto out;
--	}
--	rq = list_entry_rq(qdata-&gt;cmd_req.next);
--	list_del_init(&amp;rq-&gt;queuelist);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--
--	tcmd = rq-&gt;end_io_data;
--	init_scsi_tgt_cmd(rq, tcmd);
--	cmd = rq-&gt;special;
--	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
--	if (err &lt; 0) {
--		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
--
--		spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--		list_add(&amp;rq-&gt;queuelist, &amp;qdata-&gt;cmd_req);
--		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--	}
--
--	mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
--out:
--	/* TODO: proper error handling */
--	if (err &lt; 0)
--		queue_delayed_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work,
--				   HZ / 10);
--	else
--		goto retry;
--}
--
- /*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
- 		INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_hash[i]);
- 	spin_lock_init(&amp;queuedata-&gt;cmd_hash_lock);
- 
--	INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_req);
--	spin_lock_init(&amp;queuedata-&gt;cmd_req_lock);
--	INIT_WORK(&amp;queuedata-&gt;uspace_send_work, scsi_tgt_uspace_send_fn, q);
--	mutex_init(&amp;queuedata-&gt;cmd_req_mutex);
--
- 	return 0;
- 
- cleanup_queue:
-@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-- * @noblock:	set to nonzero if the command should be queued
-+ * @tag:	unique value to identify this command for tmf
-  */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
--	struct request_queue *q = cmd-&gt;request-&gt;q;
--	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
--	unsigned long flags;
- 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-+	int err;
- 
--	bio_list_init(&amp;tcmd-&gt;xfer_list);
--	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
--	tcmd-&gt;lun = scsilun;
--	tcmd-&gt;tag = tag;
--	tcmd-&gt;rq = cmd-&gt;request;
--
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--	list_add_tail(&amp;cmd-&gt;request-&gt;queuelist, &amp;qdata-&gt;cmd_req);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
-+	init_scsi_tgt_cmd(cmd-&gt;request, tcmd);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
- 
--	queue_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work);
--	return 0;
-+	return err;
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
- 
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/README
===================================================================
--- branches/user-iscsi/patchset/README	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/README	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,7 +0,0 @@
-This patchset for scsi-target git tree:
-
-<A HREF="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary</A>
-
-
-Get the tree and apply all the patches. Sorry for the
-inconvenience. We will create our own git tree shortly.

Modified: branches/user-iscsi/usr/Makefile
===================================================================
--- branches/user-iscsi/usr/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,17 +1,10 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -D_LARGEFILE64_SOURCE -I./include -I.
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
+TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o
 
-ifneq ($(IBMVIO),)
-CFLAGS += -DIBMVIO
-TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
-endif
-
-ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
+TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o)
 LIBS = -lcrypto
-endif
 
 all: $(PROGRAMS)
 

Deleted: branches/user-iscsi/usr/iscsi/Makefile
===================================================================
--- branches/user-iscsi/usr/iscsi/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,9 +0,0 @@
-CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../istgt/include -I../../include -I../../usr
-LIBS = -lcrypto
-DAEMON = iscsi.o
-
-$(DAEMON): istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
-	$(CC) -o $@ $^ $(LIBS)
-
-clean:
-	rm -f *.o istgtd $(SHAREDLIB)

Modified: branches/user-iscsi/usr/iscsi/conn.c
===================================================================
--- branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -13,6 +13,7 @@
 #include &lt;sys/stat.h&gt;
 
 #include &quot;iscsid.h&quot;
+#include &quot;tgtd.h&quot;
 
 #define ISCSI_CONN_NEW		1
 #define ISCSI_CONN_EXIT		5
@@ -33,13 +34,26 @@
 {
 	struct connection *conn;
 
-	if (!(conn = malloc(sizeof(*conn))))
+	conn = zalloc(sizeof(*conn));
+	if (!conn)
 		return NULL;
 
-	memset(conn, 0, sizeof(*conn));
+	conn-&gt;req_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn-&gt;req_buffer) {
+		free(conn);
+		return NULL;
+	}
+	conn-&gt;rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn-&gt;rsp_buffer) {
+		free(conn-&gt;req_buffer);
+		free(conn);
+		return NULL;
+	}
+
 	conn-&gt;state = STATE_FREE;
 	param_set_defaults(conn-&gt;session_param, session_keys);
 
+	INIT_LIST_HEAD(&amp;conn-&gt;send);
 	INIT_LIST_HEAD(&amp;conn-&gt;clist);
 
 	return conn;
@@ -48,6 +62,8 @@
 void conn_free(struct connection *conn)
 {
 	list_del(&amp;conn-&gt;clist);
+	free(conn-&gt;req_buffer);
+	free(conn-&gt;rsp_buffer);
 	free(conn-&gt;initiator);
 	free(conn);
 }
@@ -64,9 +80,8 @@
 	return NULL;
 }
 
-void conn_take_fd(struct connection *conn, int fd)
+int conn_take_fd(struct connection *conn, int fd)
 {
-	int i, err;
 	uint64_t sid = sid64(conn-&gt;isid, conn-&gt;tsih);
 
 	log_debug(&quot;conn_take_fd: %d %u %u %u %&quot; PRIx64,
@@ -74,51 +89,25 @@
 
 	conn-&gt;session-&gt;conn_cnt++;
 
-	err = ki-&gt;create_conn(thandle, conn-&gt;session-&gt;ksid, conn-&gt;kcid,
-			      &amp;conn-&gt;kcid);
-	if (err) {
-		eprintf(&quot;%d %d %u %u %u %&quot; PRIx64,
-			fd, err, conn-&gt;cid, conn-&gt;stat_sn, conn-&gt;exp_stat_sn, sid);
-		goto out;
-	}
+	dprintf(&quot;conn_take_fd: %d %u %u %u\n&quot;, conn-&gt;session-&gt;target-&gt;tid,
+		conn-&gt;cid, conn-&gt;stat_sn, conn-&gt;exp_stat_sn);
 
-	for (i = 0; i &lt; ISCSI_PARAM_ERL + 1; i++) {
-		/* FIXME */
-		if (i == ISCSI_PARAM_DATADGST_EN || i == ISCSI_PARAM_HDRDGST_EN)
-			continue;
-		if (ki-&gt;set_param(thandle, conn-&gt;session-&gt;ksid, conn-&gt;kcid, i,
-				  &amp;conn-&gt;session_param[i].val,
-				  sizeof(uint32_t), &amp;err) || err) {
-			break;
-		}
-	}
+	/* FIXME */
+	tgt_target_bind(conn-&gt;session-&gt;target-&gt;tid, conn-&gt;tsih, 0);
 
-	if (ki-&gt;bind_conn(thandle, conn-&gt;session-&gt;ksid, conn-&gt;kcid, fd, 1, &amp;err) || err) {
-		eprintf(&quot;%d %d %u %u %u %&quot; PRIx64,
-			fd, err, conn-&gt;cid, conn-&gt;stat_sn, conn-&gt;exp_stat_sn, sid);
-		goto out;
-	}
-
-	if (ki-&gt;start_conn(thandle, conn-&gt;session-&gt;ksid, conn-&gt;kcid, &amp;err) || err) {
-		eprintf(&quot;%d %d %u %u %u %&quot; PRIx64,
-			fd, err, conn-&gt;cid, conn-&gt;stat_sn, conn-&gt;exp_stat_sn, sid);
-		goto out;
-	}
-
-out:
-	return;
+	return 0;
 }
 
 void conn_read_pdu(struct connection *conn)
 {
-	conn-&gt;iostate = IOSTATE_READ_BHS;
+	conn-&gt;rx_iostate = IOSTATE_READ_BHS;
 	conn-&gt;buffer = (void *)&amp;conn-&gt;req.bhs;
 	conn-&gt;rwsize = BHS_SIZE;
 }
 
 void conn_write_pdu(struct connection *conn)
 {
-	conn-&gt;iostate = IOSTATE_WRITE_BHS;
+	conn-&gt;tx_iostate = IOSTATE_WRITE_BHS;
 	memset(&amp;conn-&gt;rsp, 0, sizeof(conn-&gt;rsp));
 	conn-&gt;buffer = (void *)&amp;conn-&gt;rsp.bhs;
 	conn-&gt;rwsize = BHS_SIZE;
@@ -126,17 +115,17 @@
 
 void conn_free_pdu(struct connection *conn)
 {
-	conn-&gt;iostate = IOSTATE_FREE;
-	if (conn-&gt;req.ahs) {
-		free(conn-&gt;req.ahs);
-		conn-&gt;req.ahs = NULL;
-	}
-	if (conn-&gt;rsp.ahs) {
-		free(conn-&gt;rsp.ahs);
-		conn-&gt;rsp.ahs = NULL;
-	}
-	if (conn-&gt;rsp.data) {
-		free(conn-&gt;rsp.data);
-		conn-&gt;rsp.data = NULL;
-	}
+	conn-&gt;rx_iostate = conn-&gt;tx_iostate = IOSTATE_FREE;
+/* 	if (conn-&gt;req.ahs) { */
+/* 		free(conn-&gt;req.ahs); */
+/* 		conn-&gt;req.ahs = NULL; */
+/* 	} */
+/* 	if (conn-&gt;rsp.ahs) { */
+/* 		free(conn-&gt;rsp.ahs); */
+/* 		conn-&gt;rsp.ahs = NULL; */
+/* 	} */
+/* 	if (conn-&gt;rsp.data) { */
+/* 		free(conn-&gt;rsp.data); */
+/* 		conn-&gt;rsp.data = NULL; */
+/* 	} */
 }

Modified: branches/user-iscsi/usr/iscsi/iscsi.h
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsi.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsi.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -3,7 +3,6 @@
 extern int iscsi_event_handle(struct pollfd *);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
-extern int iscsi_target_bind(int);
 
 struct tgt_driver iscsi = {
 	.name		= &quot;iscsi&quot;,
@@ -12,5 +11,5 @@
 	.event_handle	= iscsi_event_handle,
 	.target_create	= iscsi_target_create,
 	.target_destroy	= iscsi_target_destroy,
-	.target_bind	= iscsi_target_bind,
+/* 	.target_bind	= iscsi_target_bind, */
 };

Modified: branches/user-iscsi/usr/iscsi/iscsid.c
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -13,8 +13,10 @@
 #include &lt;netinet/in.h&gt;
 #include &lt;arpa/inet.h&gt;
 #include &lt;netdb.h&gt;
+#include &lt;scsi/scsi.h&gt;
 
 #include &quot;iscsid.h&quot;
+#include &quot;tgtd.h&quot;
 
 static struct iscsi_key login_keys[] = {
 	{&quot;InitiatorName&quot;,},
@@ -88,11 +90,9 @@
 	int len = keylen + valuelen + 2;
 	char *buffer;
 
-	if (!conn-&gt;rsp.datasize) {
-		if (!conn-&gt;rsp_buffer)
-			conn-&gt;rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn-&gt;rsp.datasize)
 		conn-&gt;rsp.data = conn-&gt;rsp_buffer;
-	}
+
 	if (conn-&gt;rwsize + len &gt; INCOMING_BUFSIZE) {
 		log_warning(&quot;Dropping key (%s=%s)&quot;, key, value);
 		return;
@@ -676,7 +676,7 @@
 
 int cmnd_execute(struct connection *conn)
 {
-	int res = 1;
+	int res = 0;
 
 	switch (conn-&gt;req.bhs.opcode &amp; ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_LOGIN:
@@ -702,7 +702,7 @@
 		break;
 	default:
 		//reject
-		res = 0;
+		res = -EINVAL;
 		break;
 	}
 
@@ -728,3 +728,311 @@
 		break;
 	}
 }
+
+static int iscsi_cmd_done(int host_no, int len, int result, int rw,
+			  uint64_t addr, uint64_t tag)
+{
+	struct session *session;
+	struct iscsi_ctask *ctask;
+
+	dprintf(&quot;%u %d %d %d %&quot; PRIx64 &quot; %&quot; PRIx64 &quot;\n&quot;, host_no, len, result,
+		rw, addr, tag);
+	session = session_lookup(host_no);
+	if (!session)
+		return -EINVAL;
+
+	list_for_each_entry(ctask, &amp;session-&gt;cmd_list, c_hlist) {
+		if (ctask-&gt;tag == tag)
+			goto found;
+	}
+	eprintf(&quot;Cannot find a task %&quot; PRIx64 &quot;\n&quot;, tag);
+	return -EINVAL;
+
+found:
+	eprintf(&quot;found a task %&quot; PRIx64 &quot;\n&quot;, tag);
+	ctask-&gt;addr = addr;
+	ctask-&gt;result = result;
+	ctask-&gt;len = len;
+	ctask-&gt;rw = rw;
+
+	return 0;
+}
+
+static int iscsi_cmd_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask-&gt;conn;
+	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &amp;conn-&gt;rsp.bhs;
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp-&gt;itt = ctask-&gt;tag;
+	rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp-&gt;cmd_status = ctask-&gt;result;
+	rsp-&gt;statsn = cpu_to_be32(conn-&gt;stat_sn++);
+	rsp-&gt;exp_cmdsn = cpu_to_be32(conn-&gt;exp_cmd_sn);
+	rsp-&gt;max_cmdsn = cpu_to_be32(conn-&gt;exp_cmd_sn + 8);
+
+	return 0;
+}
+
+static int iscsi_data_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask-&gt;conn;
+	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &amp;conn-&gt;rsp.bhs;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &amp;ctask-&gt;req;
+	int residual, datalen, exp_datalen = ntohl(req-&gt;data_length);
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp-&gt;opcode = ISCSI_OP_SCSI_DATA_IN;
+	rsp-&gt;itt = ctask-&gt;tag;
+	rsp-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	rsp-&gt;cmd_status = ISCSI_STATUS_CMD_COMPLETED;
+
+	rsp-&gt;offset = cpu_to_be32(ctask-&gt;offset);
+	rsp-&gt;datasn = cpu_to_be32(ctask-&gt;data_sn++);
+	rsp-&gt;cmd_status = ctask-&gt;result;
+
+	datalen = min(exp_datalen, ctask-&gt;len);
+	if (datalen &gt; conn-&gt;session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val)
+		eprintf(&quot;cannot handle %d %d %d %d\n&quot;,
+			datalen, exp_datalen, ctask-&gt;len,
+			conn-&gt;session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val);
+
+	rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+	if (ctask-&gt;len &lt; exp_datalen) {
+		rsp-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		residual = exp_datalen - ctask-&gt;len;
+	} else if (ctask-&gt;len &gt; exp_datalen) {
+		rsp-&gt;flags |= ISCSI_FLAG_CMD_OVERFLOW;
+		residual = ctask-&gt;len - exp_datalen;
+	} else
+		residual = 0;
+
+	rsp-&gt;residual_count = cpu_to_be32(residual);
+	if (rsp-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL)
+		rsp-&gt;statsn = cpu_to_be32(conn-&gt;stat_sn++);
+	rsp-&gt;exp_cmdsn = cpu_to_be32(conn-&gt;exp_cmd_sn);
+	rsp-&gt;max_cmdsn = cpu_to_be32(conn-&gt;exp_cmd_sn + 8);
+
+	conn-&gt;rsp.datasize = datalen;
+	hton24(rsp-&gt;dlength, datalen);
+	conn-&gt;rsp.data = (void *) (unsigned long) ctask-&gt;addr;
+
+	return 0;
+}
+
+static int iscsi_r2t_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask-&gt;conn;
+	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &amp;conn-&gt;rsp.bhs;
+	int length, max_burst = conn-&gt;session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
+	memset(rsp, 0, sizeof(*rsp));
+
+	rsp-&gt;opcode = ISCSI_OP_R2T;
+	rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	memcpy(rsp-&gt;lun, ctask-&gt;req.lun, sizeof(rsp-&gt;lun));
+
+	rsp-&gt;itt = ctask-&gt;req.itt;
+	rsp-&gt;r2tsn = cpu_to_be32(ctask-&gt;exp_r2tsn++);
+	rsp-&gt;data_offset = cpu_to_be32(ctask-&gt;offset);
+	rsp-&gt;ttt = (unsigned long) ctask;
+	length = min(ctask-&gt;r2t_count, max_burst);
+	rsp-&gt;data_length = cpu_to_be32(length);
+	ctask-&gt;r2t_count -= length;
+
+	return 0;
+}
+
+static int iscsi_data_out_rx_start(struct connection *conn)
+{
+	struct iscsi_ctask *ctask;
+	struct iscsi_data *req = (struct iscsi_data *) &amp;conn-&gt;req.bhs;
+
+	list_for_each_entry(ctask, &amp;conn-&gt;session-&gt;cmd_list, c_hlist) {
+		if (ctask-&gt;tag == req-&gt;itt)
+			goto found;
+	}
+	return -EINVAL;
+found:
+	eprintf(&quot;found a task %&quot; PRIx64 &quot; %u %u %u\n&quot;, ctask-&gt;tag,
+		ctask-&gt;r2t_count,
+		ntoh24(req-&gt;dlength), be32_to_cpu(req-&gt;offset));
+
+	conn-&gt;buffer = (void *) (unsigned long) ctask-&gt;addr;
+	conn-&gt;buffer += be32_to_cpu(req-&gt;offset);
+	conn-&gt;rwsize = ntoh24(req-&gt;dlength);
+
+	ctask-&gt;offset += ntoh24(req-&gt;dlength);
+
+	conn-&gt;ctask = ctask;
+
+	return 0;
+}
+
+static int iscsi_cmd_init(struct connection *conn)
+{
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &amp;conn-&gt;req.bhs;
+	struct iscsi_ctask *ctask;
+	int err, attr;
+
+	ctask = zalloc(sizeof(*ctask));
+	if (!ctask) {
+		eprintf(&quot;OOM\n&quot;);
+		return -ENOMEM;
+	}
+
+	memcpy(&amp;ctask-&gt;req, req, sizeof(*req));
+	ctask-&gt;tag = req-&gt;itt;
+	ctask-&gt;conn = conn;
+	INIT_LIST_HEAD(&amp;ctask-&gt;c_hlist);
+
+	list_add(&amp;ctask-&gt;c_hlist, &amp;conn-&gt;session-&gt;cmd_list);
+
+	dprintf(&quot;%u %x %d %d %u\n&quot;, conn-&gt;session-&gt;tsih,
+		req-&gt;cdb[0], ntohl(req-&gt;data_length),
+		req-&gt;flags &amp; ISCSI_FLAG_CMD_ATTR_MASK, req-&gt;itt);
+
+	switch (req-&gt;flags &amp; ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		attr = SIMPLE_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		attr = HEAD_OF_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+	default:
+		attr = ORDERED_QUEUE_TAG;
+	}
+
+	attr = SIMPLE_QUEUE_TAG;
+	err = target_cmd_queue(conn-&gt;session-&gt;tsih, req-&gt;cdb,
+			       req-&gt;lun, ntohl(req-&gt;data_length),
+			       attr,
+			       req-&gt;itt, iscsi_cmd_done);
+
+	conn-&gt;exp_cmd_sn++;
+	conn-&gt;ctask = ctask;
+
+	if (req-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
+		conn-&gt;rwsize = ntoh24(req-&gt;dlength);
+		conn-&gt;buffer = (void *) (unsigned long) conn-&gt;ctask-&gt;addr;
+		ctask-&gt;r2t_count = ntohl(req-&gt;data_length) - conn-&gt;rwsize;
+		ctask-&gt;unsol_count = !(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL);
+		ctask-&gt;offset = conn-&gt;rwsize;
+
+		dprintf(&quot;%d %d %d %d\n&quot;, conn-&gt;rwsize, ctask-&gt;r2t_count,
+			ctask-&gt;unsol_count, ctask-&gt;offset);
+	}
+
+	return err;
+}
+
+static int __iscsi_cmd_rx_done(struct connection *conn, int *is_rsp)
+{
+	struct iscsi_ctask *ctask = conn-&gt;ctask;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &amp;ctask-&gt;req;
+	int err = 0;
+
+	if (req-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
+		if (ctask-&gt;r2t_count) {
+			if (ctask-&gt;unsol_count)
+				*is_rsp = 0;
+			else
+				err = iscsi_r2t_build(ctask);
+		} else
+			err = iscsi_cmd_rsp_build(ctask);
+	} else {
+		if (ctask-&gt;len)
+			err = iscsi_data_rsp_build(ctask);
+		else
+			err = iscsi_cmd_rsp_build(ctask);
+	}
+
+	return err;
+}
+
+int iscsi_cmd_rx_done(struct connection *conn, int *is_rsp)
+{
+	struct iscsi_hdr *hdr = &amp;conn-&gt;req.bhs;
+	uint8_t op;
+	int err = 0;
+
+	*is_rsp = 1;
+	op = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		__iscsi_cmd_rx_done(conn, is_rsp);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		dprintf(&quot;%d\n&quot;, conn-&gt;ctask-&gt;r2t_count);
+		if (conn-&gt;ctask-&gt;r2t_count)
+			err = iscsi_r2t_build(conn-&gt;ctask);
+		else
+			err = iscsi_cmd_rsp_build(conn-&gt;ctask);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+	default:
+		eprintf(&quot;Cannot handle yet %x\n&quot;, op);
+		break;
+	}
+
+	return err;
+}
+
+int iscsi_cmd_rx_start(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &amp;conn-&gt;req.bhs;
+	uint8_t op;
+	int err;
+
+	op = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
+	dprintf(&quot;%u\n&quot;, op);
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_cmd_init(conn);
+		if (!err)
+			conn-&gt;exp_stat_sn = be32_to_cpu(hdr-&gt;exp_statsn);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		err = iscsi_data_out_rx_start(conn);
+		if (!err)
+			conn-&gt;exp_stat_sn = be32_to_cpu(hdr-&gt;exp_statsn);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		eprintf(&quot;Cannot handle yet %x\n&quot;, op);
+		err = -EINVAL;
+	default:
+		eprintf(&quot;Unknown op %x\n&quot;, op);
+		err = -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+void iscsi_cmd_tx_done(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &amp;conn-&gt;rsp.bhs;
+
+	switch (hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_R2T:
+		break;
+	default:
+		target_cmd_done(conn-&gt;session-&gt;tsih, conn-&gt;ctask-&gt;tag);
+		list_del(&amp;conn-&gt;ctask-&gt;c_hlist);
+		free(conn-&gt;ctask);
+	}
+
+	conn-&gt;ctask = NULL;
+}

Modified: branches/user-iscsi/usr/iscsi/iscsid.h
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -11,12 +11,13 @@
 #include &lt;linux/types.h&gt;
 
 #include &quot;types.h&quot;
-#include &quot;iscsi_if.h&quot;
-#include &quot;list.h&quot;
 #include &quot;param.h&quot;
-#include &quot;log.h&quot;
+#include &quot;../list.h&quot;
+#include &quot;../log.h&quot;
+#include &quot;../util.h&quot;
 
-#include &lt;scsi/iscsi_proto.h&gt;
+#include &lt;iscsi_proto.h&gt;
+#include &lt;iscsi_if.h&gt;
 
 #define ISCSI_NAME_LEN 255
 #define ISTGT_NAMESPACE &quot;ISTGT_ABSTRACT_NAMESPACE&quot;
@@ -25,9 +26,6 @@
 #define DIGEST_NONE		(1 &lt;&lt; 0)
 #define DIGEST_CRC32C           (1 &lt;&lt; 1)
 
-extern uint64_t thandle;
-extern int nl_fd;
-
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] &lt;&lt;  0 | (uint64_t) isid[1] &lt;&lt;  8 |	\
@@ -36,6 +34,8 @@
 	(uint64_t) tsih &lt;&lt; 48;					\
 })
 
+struct connection;
+
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;
@@ -52,24 +52,47 @@
 	struct list_head slist;
 	struct list_head hlist;
 
+
 	char *initiator;
 	struct target *target;
 	uint8_t isid[6];
 	uint16_t tsih;
 
-	/* workaroud */
-	uint32_t ksid;
-	uint32_t hostno;
-
 	struct list_head conn_list;
 	int conn_cnt;
+
+	struct list_head cmd_list;
 };
 
+struct iscsi_ctask {
+	struct iscsi_hdr req;
+	struct iscsi_hdr rsp;
+
+	uint64_t tag;
+	struct connection *conn;
+
+	struct list_head c_hlist;
+
+	uint64_t addr;
+	int result;
+	int len;
+	int rw;
+
+	int offset;
+	int data_sn;
+
+	int r2t_count;
+	int unsol_count;
+	int exp_r2tsn;
+};
+
 struct connection {
 	int state;
-	int iostate;
+	int tx_iostate;
+	int rx_iostate;
 	int fd;
 
+	struct list_head send;
 	struct list_head clist;
 	struct session *session;
 
@@ -84,9 +107,6 @@
 	int session_type;
 	int auth_method;
 
-	/* workaroud */
-	uint32_t kcid;
-
 	uint32_t stat_sn;
 	uint32_t exp_stat_sn;
 
@@ -110,6 +130,8 @@
 			unsigned char *challenge;
 		} chap;
 	} auth;
+
+	struct iscsi_ctask *ctask;
 };
 
 #define IOSTATE_FREE		0
@@ -131,6 +153,7 @@
 #define STATE_KERNEL		9
 #define STATE_CLOSE		10
 #define STATE_EXIT		11
+#define STATE_SCSI		12
 
 #define AUTH_STATE_START	0
 #define AUTH_STATE_CHALLENGE	1
@@ -170,7 +193,7 @@
 extern struct connection *conn_alloc(void);
 extern void conn_free(struct connection *conn);
 extern struct connection * conn_find(struct session *session, uint32_t cid);
-extern void conn_take_fd(struct connection *conn, int fd);
+extern int conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
 extern void conn_free_pdu(struct connection *conn);
@@ -183,13 +206,15 @@
 extern void cmnd_finish(struct connection *conn);
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
+extern int iscsi_cmd_rx_start(struct connection *conn);
+extern int iscsi_cmd_rx_done(struct connection *conn, int *is_rsp);
+extern void iscsi_cmd_tx_done(struct connection *conn);
 
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
-extern struct session *session_find_id(int tid, uint64_t sid);
-extern struct session *session_find_hostno(int hostno);
-extern void session_create(struct connection *conn);
-extern void session_remove(struct session *session);
+extern int session_create(struct connection *conn);
+extern void session_destroy(struct session *session);
+extern struct session *session_lookup(uint16_t tsih);
 
 /* target.c */
 extern int target_find_by_name(const char *name, int *tid);
@@ -197,9 +222,6 @@
 extern void target_list_build(struct connection *, char *, char *);
 extern int target_bind(int tid, int hostno);
 
-extern void ipc_event(void);
-extern int ipc_init(void);
-
 /* netlink.c */
 struct iscsi_kernel_interface {
 	int (*set_param) (uint64_t transport_handle, uint32_t sid,

Modified: branches/user-iscsi/usr/iscsi/istgt.c
===================================================================
--- branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -41,14 +41,11 @@
 
 enum {
 	POLL_LISTEN,
-	POLL_NL = POLL_LISTEN + LISTEN_MAX,
-	POLL_INCOMING,
+	POLL_INCOMING = POLL_LISTEN + LISTEN_MAX,
 	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
 };
 
 static struct connection *incoming[INCOMING_MAX];
-uint64_t thandle;
-int nl_fd;
 
 static void set_non_blocking(int fd)
 {
@@ -127,24 +124,22 @@
 
 	eprintf(&quot;%d\n&quot;, afd);
 
-	namesize = sizeof(from);
-	if ((fd = accept(afd, (struct sockaddr *) &amp;from, &amp;namesize)) &lt; 0) {
-		if (errno != EINTR &amp;&amp; errno != EAGAIN) {
-			eprintf(&quot;accept(incoming_socket)\n&quot;);
-			exit(1);
-		}
-		return;
-	}
-
 	for (i = 0; i &lt; INCOMING_MAX; i++) {
 		if (!incoming[i])
 			break;
 	}
 	if (i &gt;= INCOMING_MAX) {
-		eprintf(&quot;unable to find incoming slot? %d\n&quot;, i);
-		goto out;
+		eprintf(&quot;unable to find incoming slot %d\n&quot;, i);
+		return;
 	}
 
+	namesize = sizeof(from);
+	fd = accept(afd, (struct sockaddr *) &amp;from, &amp;namesize);
+	if (fd &lt; 0) {
+		eprintf(&quot;%s\n&quot;, strerror(errno));
+		return;
+	}
+
 	conn = conn_alloc();
 	if (!conn) {
 		eprintf(&quot;fail to allocate conn\n&quot;);
@@ -166,145 +161,206 @@
 	return;
 }
 
-void iscsi_event_handle(struct pollfd *pfds)
+static void iscsi_rx(struct pollfd *pfd, struct connection *conn)
 {
-	struct connection *conn;
-	struct pollfd *pfd;
-	int i, res, opt;
+	int res;
 
-	for (i = 0; i &lt; LISTEN_MAX; i++) {
-		if (pfds[POLL_LISTEN + i].revents)
-			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
-	}
+	switch (conn-&gt;rx_iostate) {
+	case IOSTATE_READ_BHS:
+	case IOSTATE_READ_AHS_DATA:
+	read_again:
+		res = read(pfd-&gt;fd, conn-&gt;buffer, conn-&gt;rwsize);
+		if (res &lt;= 0) {
+			if (res == 0 || (errno != EINTR &amp;&amp; errno != EAGAIN))
+				conn-&gt;state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto read_again;
+			break;
+		}
+		conn-&gt;rwsize -= res;
+		conn-&gt;buffer += res;
+		if (conn-&gt;rwsize)
+			break;
 
-	for (i = 0; i &lt; INCOMING_MAX; i++) {
-		conn = incoming[i];
-		pfd = &amp;pfds[POLL_INCOMING + i];
-		if (!conn || !pfd-&gt;revents)
-			continue;
+		switch (conn-&gt;rx_iostate) {
+		case IOSTATE_READ_BHS:
+			conn-&gt;rx_iostate = IOSTATE_READ_AHS_DATA;
+			conn-&gt;req.ahssize = conn-&gt;req.bhs.hlength * 4;
+			conn-&gt;req.datasize = ntoh24(conn-&gt;req.bhs.dlength);
+			conn-&gt;rwsize = (conn-&gt;req.ahssize + conn-&gt;req.datasize + 3) &amp; -4;
 
-		pfd-&gt;revents = 0;
+			if (conn-&gt;req.ahssize) {
+				eprintf(&quot;FIXME: we cannot handle ahs\n&quot;);
+				conn-&gt;state = STATE_CLOSE;
+				break;
+			}
 
-		switch (conn-&gt;iostate) {
-		case IOSTATE_READ_BHS:
-		case IOSTATE_READ_AHS_DATA:
-		read_again:
-			res = read(pfd-&gt;fd, conn-&gt;buffer, conn-&gt;rwsize);
-			if (res &lt;= 0) {
-				if (res == 0 || (errno != EINTR &amp;&amp; errno != EAGAIN))
+			if (conn-&gt;state == STATE_SCSI) {
+				res = iscsi_cmd_rx_start(conn);
+				if (res) {
 					conn-&gt;state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto read_again;
-				break;
+					break;
+				}
 			}
-			conn-&gt;rwsize -= res;
-			conn-&gt;buffer += res;
-			if (conn-&gt;rwsize)
-				break;
-
-			switch (conn-&gt;iostate) {
-			case IOSTATE_READ_BHS:
-				conn-&gt;iostate = IOSTATE_READ_AHS_DATA;
-				conn-&gt;req.ahssize =
-					conn-&gt;req.bhs.hlength * 4;
-				conn-&gt;req.datasize =
-					ntoh24(conn-&gt;req.bhs.dlength);
-				conn-&gt;rwsize = (conn-&gt;req.ahssize + conn-&gt;req.datasize + 3) &amp; -4;
-				if (conn-&gt;rwsize) {
-					if (!conn-&gt;req_buffer)
-						conn-&gt;req_buffer = malloc(INCOMING_BUFSIZE);
+			if (conn-&gt;rwsize) {
+				if (conn-&gt;state == STATE_SCSI) {
+					dprintf(&quot;%d\n&quot;, conn-&gt;rwsize);
+				} else {
 					conn-&gt;buffer = conn-&gt;req_buffer;
 					conn-&gt;req.ahs = conn-&gt;buffer;
-					conn-&gt;req.data = conn-&gt;buffer + conn-&gt;req.ahssize;
-					goto read_again;
 				}
+				conn-&gt;req.data =
+					conn-&gt;buffer + conn-&gt;req.ahssize;
+				goto read_again;
+			}
 
-			case IOSTATE_READ_AHS_DATA:
+		case IOSTATE_READ_AHS_DATA:
+			if (conn-&gt;state == STATE_SCSI) {
+				int rsp;
+
+				dprintf(&quot;done\n&quot;);
+
 				conn_write_pdu(conn);
 				pfd-&gt;events = POLLOUT;
+				res = iscsi_cmd_rx_done(conn, &amp;rsp);
+				if (!res &amp;&amp; !rsp) {
+					conn_read_pdu(conn);
+					pfd-&gt;events = POLLIN;
+				}
+			} else {
+				conn_write_pdu(conn);
+				pfd-&gt;events = POLLOUT;
+				res = cmnd_execute(conn);
+			}
 
-				if (!cmnd_execute(conn))
-					conn-&gt;state = STATE_CLOSE;
-				break;
-			}
+			if (res)
+				conn-&gt;state = STATE_CLOSE;
 			break;
+		break;
+		}
+	}
+}
 
-		case IOSTATE_WRITE_BHS:
-		case IOSTATE_WRITE_AHS:
-		case IOSTATE_WRITE_DATA:
-		write_again:
-			opt = 1;
-			setsockopt(pfd-&gt;fd, SOL_TCP, TCP_CORK, &amp;opt, sizeof(opt));
-			res = write(pfd-&gt;fd, conn-&gt;buffer, conn-&gt;rwsize);
-			if (res &lt; 0) {
-				if (errno != EINTR &amp;&amp; errno != EAGAIN)
-					conn-&gt;state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto write_again;
-				break;
-			}
+static void iscsi_tx(struct pollfd *pfd, struct connection *conn)
+{
+	int opt, res;
 
-			conn-&gt;rwsize -= res;
-			conn-&gt;buffer += res;
-			if (conn-&gt;rwsize)
+	switch (conn-&gt;tx_iostate) {
+	case IOSTATE_WRITE_BHS:
+	case IOSTATE_WRITE_AHS:
+	case IOSTATE_WRITE_DATA:
+	write_again:
+		if (conn-&gt;state == STATE_SCSI)
+			dprintf(&quot;%d %d %d\n&quot;, conn-&gt;rwsize, conn-&gt;rsp.ahssize,
+				conn-&gt;rsp.datasize);
+		opt = 1;
+		setsockopt(pfd-&gt;fd, SOL_TCP, TCP_CORK, &amp;opt, sizeof(opt));
+		res = write(pfd-&gt;fd, conn-&gt;buffer, conn-&gt;rwsize);
+		if (res &lt; 0) {
+			if (errno != EINTR &amp;&amp; errno != EAGAIN)
+				conn-&gt;state = STATE_CLOSE;
+			else if (errno == EINTR)
 				goto write_again;
+			break;
+		}
 
-			switch (conn-&gt;iostate) {
-			case IOSTATE_WRITE_BHS:
-				if (conn-&gt;rsp.ahssize) {
-					conn-&gt;iostate = IOSTATE_WRITE_AHS;
-					conn-&gt;buffer = conn-&gt;rsp.ahs;
-					conn-&gt;rwsize = conn-&gt;rsp.ahssize;
-					goto write_again;
-				}
-			case IOSTATE_WRITE_AHS:
-				if (conn-&gt;rsp.datasize) {
-					int o;
+		conn-&gt;rwsize -= res;
+		conn-&gt;buffer += res;
+		if (conn-&gt;rwsize)
+			goto write_again;
 
-					conn-&gt;iostate = IOSTATE_WRITE_DATA;
-					conn-&gt;buffer = conn-&gt;rsp.data;
-					conn-&gt;rwsize = conn-&gt;rsp.datasize;
-					o = conn-&gt;rwsize &amp; 3;
-					if (o) {
-						for (o = 4 - o; o; o--)
-							*((uint8_t *)conn-&gt;buffer + conn-&gt;rwsize++) = 0;
-					}
-					goto write_again;
+		switch (conn-&gt;tx_iostate) {
+		case IOSTATE_WRITE_BHS:
+			if (conn-&gt;rsp.ahssize) {
+				conn-&gt;tx_iostate = IOSTATE_WRITE_AHS;
+				conn-&gt;buffer = conn-&gt;rsp.ahs;
+				conn-&gt;rwsize = conn-&gt;rsp.ahssize;
+				goto write_again;
+			}
+		case IOSTATE_WRITE_AHS:
+			if (conn-&gt;rsp.datasize) {
+				int pad;
+
+				conn-&gt;tx_iostate = IOSTATE_WRITE_DATA;
+				conn-&gt;buffer = conn-&gt;rsp.data;
+				conn-&gt;rwsize = conn-&gt;rsp.datasize;
+				pad = conn-&gt;rwsize &amp; (PAD_WORD_LEN - 1);
+				if (pad) {
+					for (pad = PAD_WORD_LEN - pad; pad; pad--)
+						*((uint8_t *)conn-&gt;buffer + conn-&gt;rwsize++) = 0;
 				}
-			case IOSTATE_WRITE_DATA:
-				opt = 0;
-				setsockopt(pfd-&gt;fd, SOL_TCP, TCP_CORK, &amp;opt, sizeof(opt));
-				cmnd_finish(conn);
+				goto write_again;
+			}
+		case IOSTATE_WRITE_DATA:
+			opt = 0;
+			setsockopt(pfd-&gt;fd, SOL_TCP, TCP_CORK, &amp;opt, sizeof(opt));
+			cmnd_finish(conn);
 
-				switch (conn-&gt;state) {
-				case STATE_KERNEL:
-					conn_take_fd(conn, pfd-&gt;fd);
+			switch (conn-&gt;state) {
+			case STATE_KERNEL:
+				res = conn_take_fd(conn, pfd-&gt;fd);
+				if (res)
 					conn-&gt;state = STATE_CLOSE;
-					break;
-				case STATE_EXIT:
-				case STATE_CLOSE:
-					break;
-				default:
+				else {
+					conn-&gt;state = STATE_SCSI;
 					conn_read_pdu(conn);
 					pfd-&gt;events = POLLIN;
-					break;
 				}
 				break;
+			case STATE_EXIT:
+			case STATE_CLOSE:
+				break;
+			case STATE_SCSI:
+				iscsi_cmd_tx_done(conn);
+			default:
+				conn_read_pdu(conn);
+				pfd-&gt;events = POLLIN;
+				break;
 			}
-
 			break;
-		default:
-			eprintf(&quot;illegal iostate %d for port %d!\n&quot;, conn-&gt;iostate, i);
-			exit(1);
 		}
 
+		break;
+	default:
+		eprintf(&quot;illegal iostate %d\n&quot;, conn-&gt;tx_iostate);
+		conn-&gt;state = STATE_CLOSE;
+	}
+}
+
+void iscsi_event_handle(struct pollfd *pfds)
+{
+	struct session *session;
+	struct connection *conn;
+	struct pollfd *pfd;
+	int i;
+
+	for (i = 0; i &lt; LISTEN_MAX; i++) {
+		if (pfds[POLL_LISTEN + i].revents)
+			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
+	}
+
+	for (i = 0; i &lt; INCOMING_MAX; i++) {
+		conn = incoming[i];
+		pfd = &amp;pfds[POLL_INCOMING + i];
+		if (!conn || !pfd-&gt;revents)
+			continue;
+
+		if (pfd-&gt;revents &amp; POLLIN)
+			iscsi_rx(pfd, conn);
+		if (pfd-&gt;revents &amp; POLLOUT)
+			iscsi_tx(pfd, conn);
+		pfd-&gt;revents = 0;
+
 		if (conn-&gt;state == STATE_CLOSE) {
 			dprintf(&quot;connection closed\n&quot;);
+			session = conn-&gt;session;
 			conn_free_pdu(conn);
 			conn_free(conn);
-/* 			close(pfd-&gt;fd); */
+			close(pfd-&gt;fd);
 			pfd-&gt;fd = -1;
 			incoming[i] = NULL;
+			if (session)
+				session_destroy(session);
 		}
 	}
 }
@@ -313,9 +369,6 @@
 {
 	int i;
 
-	pfd[POLL_NL].fd = nl_fd;
-	pfd[POLL_NL].events = POLLIN;
-
 	listen_socket_create(pfd + POLL_LISTEN);
 
 	for (i = 0; i &lt; INCOMING_MAX; i++) {
@@ -329,7 +382,6 @@
 
 int iscsi_init(int *npfd)
 {
-	iscsi_nl_init();
 	*npfd = POLL_MAX;
 
 	return 0;

Deleted: branches/user-iscsi/usr/iscsi/netlink.c
===================================================================
--- branches/user-iscsi/usr/iscsi/netlink.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/netlink.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,372 +0,0 @@
-/*
- * iSCSI Netlink/Linux Interface
- *
- * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
- * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include &lt;ctype.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;dirent.h&gt;
-
-#include &lt;sys/ioctl.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;sys/un.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/netlink.h&gt;
-
-#include &quot;iscsid.h&quot;
-#include &quot;tgtadm.h&quot;
-
-#define NL_BUFSIZE 4096
-
-static struct sockaddr_nl saddr, daddr;
-
-static int __nl_read(int fd, void *data, int size, int flags)
-{
-	struct sockaddr_nl saddr;
-	socklen_t slen = sizeof(saddr);
-
-	memset(&amp;saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-
-	return recvfrom(fd, data, size, flags, (struct sockaddr *) &amp;saddr, &amp;slen);
-}
-
-static int nl_read(char *buf)
-{
-	struct nlmsghdr *nlh;
-	int err;
-
-peek_again:
-	err = __nl_read(nl_fd, buf, NLMSG_LENGTH(0), MSG_PEEK);
-	if (err &lt; 0) {
-		eprintf(&quot;%d\n&quot;, err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-
-/* 	dprintf(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type, nlh-&gt;nlmsg_len, getpid()); */
-read_again:
-	err = __nl_read(nl_fd, buf, nlh-&gt;nlmsg_len, 0);
-	if (err &lt; 0) {
-		eprintf(&quot;%d\n&quot;, err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto read_again;
-		return err;
-	}
-
-	return err;
-}
-
-static int __kipc_call(struct iscsi_uevent *ev, int len)
-{
-	struct nlmsghdr *nlh;
-	char sbuf[NL_BUFSIZE];
-	int err;
-
-	nlh = (struct nlmsghdr *) sbuf;
-	memset(sbuf, 0, NL_BUFSIZE);
-	memcpy(NLMSG_DATA(nlh), ev, len);
-
-	len = NLMSG_SPACE(len);
-	nlh-&gt;nlmsg_pid = getpid();
-	nlh-&gt;nlmsg_len = len;
-	nlh-&gt;nlmsg_type = ev-&gt;type;
-
-	err = sendto(nl_fd, nlh, len, 0, (struct sockaddr *) &amp;daddr, sizeof(daddr));
-	if (err &lt; 0) {
-		eprintf(&quot;%d\n&quot;, err);
-		return err;
-	}
-
-	memset(sbuf, 0, NL_BUFSIZE);
-	err = nl_read(sbuf);
-	if (err &lt; 0) {
-		eprintf(&quot;%d\n&quot;, err);
-		return err;
-	}
-
-	memcpy(ev, NLMSG_DATA(sbuf), sizeof(*ev));
-
-	return err;
-}
-
-static int kcreate_session(uint64_t transport_handle, uint32_t initial_cmdsn,
-		uint32_t *out_sid, uint32_t *out_hostno)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf(&quot;%&quot;PRIx64 &quot; %u %u %u\n&quot;,
-		transport_handle, initial_cmdsn, *out_sid, *out_hostno);
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.c_session.initial_cmdsn = initial_cmdsn;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		return rc;
-	}
-
-	*out_hostno = ev.r.c_session_ret.host_no;
-	*out_sid = ev.r.c_session_ret.sid;
-
-	return 0;
-}
-
-static int kdestroy_session(uint64_t transport_handle, uint32_t sid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.d_session.sid = sid;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int kcreate_conn(uint64_t transport_handle, uint32_t sid,
-		       uint32_t cid, uint32_t *out_cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf(&quot;%&quot;PRIx64 &quot; %u %u\n&quot;, transport_handle, sid, cid);
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.c_conn.cid = cid;
-	ev.u.c_conn.sid = sid;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		eprintf(&quot;%d\n&quot;, rc);
-		return rc;
-	}
-
-	if ((int)ev.r.c_conn_ret.cid == -1)
-		return -EIO;
-
-	*out_cid = ev.r.c_conn_ret.cid;
-	return 0;
-}
-
-static int kdestroy_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.d_conn.sid = sid;
-	ev.u.d_conn.cid = cid;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		eprintf(&quot;%d\n&quot;, rc);
-	}
-
-	return 0;
-}
-
-static int
-kbind_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   uint64_t transport_eph, int is_leading, int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	ev.type = ISCSI_UEVENT_BIND_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.b_conn.sid = sid;
-	ev.u.b_conn.cid = cid;
-	ev.u.b_conn.transport_eph = transport_eph;
-	ev.u.b_conn.is_leading = is_leading;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-
-	return 0;
-}
-
-static int
-kstop_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid, int flag)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_STOP_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.stop_conn.sid = sid;
-	ev.u.stop_conn.cid = cid;
-	ev.u.stop_conn.flag = flag;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int
-kstart_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	    int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&amp;ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_START_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.start_conn.sid = sid;
-	ev.u.start_conn.cid = cid;
-
-	if ((rc = __kipc_call(&amp;ev, sizeof(ev))) &lt; 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-	return 0;
-}
-
-static int
-kset_param(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   enum iscsi_param param, void *value, int len, int *retcode)
-{
-	struct iscsi_uevent *ev;
-	char setparam_buf[NL_BUFSIZE];
-	int rc;
-
-	memset(setparam_buf, 0, sizeof(setparam_buf));
-	ev = (struct iscsi_uevent *) setparam_buf;
-	ev-&gt;type = ISCSI_UEVENT_SET_PARAM;
-	ev-&gt;transport_handle = transport_handle;
-	ev-&gt;u.set_param.sid = sid;
-	ev-&gt;u.set_param.cid = cid;
-	ev-&gt;u.set_param.param = param;
-	ev-&gt;u.set_param.len = len;
-	memcpy(setparam_buf + sizeof(*ev), value, len);
-
-	if ((rc = __kipc_call(ev, sizeof(*ev) + len)) &lt; 0) {
-		return rc;
-	}
-
-	*retcode = ev-&gt;r.retcode;
-
-	return 0;
-}
-
-static int transport_handle_init(void)
-{
-	int fd, err;
-	char buf[64];
-
-	fd = open(&quot;/sys/class/iscsi_transport/iscsi_tcp_tgt/handle&quot;, O_RDONLY);
-	if (fd &lt; 0)
-		return fd;
-	err = read(fd, buf, sizeof(buf));
-	if (err &lt; 0)
-		goto out;
-	thandle = strtoull(buf, NULL, 10);
-	dprintf(&quot;%&quot; PRIx64 &quot;\n&quot;, thandle);
-	err = 0;
-out:
-	close(fd);
-	return err;
-}
-
-int iscsi_nl_init(void)
-{
-	int err, rsize = 256 * 1024;
-
-	err = transport_handle_init();
-	if (err)
-		return err;
-
-	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
-	if (nl_fd &lt; 0) {
-		eprintf(&quot;Fail to create the netlink socket %d\n&quot;, errno);
-		return err;
-	}
-	eprintf(&quot;create the netlink socket %d\n&quot;, nl_fd);
-
-	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &amp;rsize, sizeof(rsize));
-	if (err) {
-		eprintf(&quot;fail to setsockopt %d\n&quot;, errno);
-		return err;
-	}
-
-	memset(&amp;saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-/* 	err = bind(nl_fd, (struct sockaddr *) &amp;saddr, sizeof(saddr)); */
-/* 	if (err) { */
-/* 		eprintf(&quot;can not bind NETLINK_ISCSI socket %d\n&quot;, errno); */
-/* 		close(nl_fd); */
-/* 		return err; */
-/* 	} */
-
-	memset(&amp;daddr, 0, sizeof(daddr));
-	daddr.nl_family = AF_NETLINK;
-	daddr.nl_pid = 0; /* kernel */
-	daddr.nl_groups = 0; /* unicast */
-	eprintf(&quot;create the netlink socket %d %d\n&quot;, nl_fd, err);
-
-	return err;
-}
-
-struct iscsi_kernel_interface nl_ki = {
-	.create_session		= kcreate_session,
-	.destroy_session	= kdestroy_session,
-	.create_conn		= kcreate_conn,
-	.destroy_conn		= kdestroy_conn,
-	.bind_conn		= kbind_conn,
-	.set_param              = kset_param,
-	.start_conn             = kstart_conn,
-	.stop_conn              = kstop_conn,
-};
-
-struct iscsi_kernel_interface *ki = &amp;nl_ki;

Modified: branches/user-iscsi/usr/iscsi/session.c
===================================================================
--- branches/user-iscsi/usr/iscsi/session.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/session.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -18,38 +18,6 @@
 
 static LIST_HEAD(sessions_list);
 
-static struct session *session_alloc(int tid)
-{
-	struct session *session;
-	struct target *target = target_find_by_id(tid);
-
-	if (!target)
-		return NULL;
-	if (!(session = malloc(sizeof(*session))))
-		return NULL;
-	memset(session, 0, sizeof(*session));
-
-	session-&gt;target = target;
-	INIT_LIST_HEAD(&amp;session-&gt;slist);
-	list_add(&amp;session-&gt;slist, &amp;target-&gt;sessions_list);
-
-	INIT_LIST_HEAD(&amp;session-&gt;conn_list);
-
-	return session;
-}
-
-int iscsi_target_bind(int hostno)
-{
-	struct session *session;
-
-	list_for_each_entry(session, &amp;sessions_list, hlist) {
-		if (session-&gt;hostno == hostno)
-			return session-&gt;target-&gt;tid;
-	}
-
-	return -ENOENT;
-}
-
 struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
@@ -69,67 +37,69 @@
 	return NULL;
 }
 
-struct session *session_find_id(int tid, uint64_t sid)
+struct session *session_lookup(uint16_t tsih)
 {
 	struct session *session;
-	struct target *target;
-
-	if (!(target = target_find_by_id(tid)))
-		return NULL;
-
-	log_debug(&quot;session_find_id: %#&quot; PRIx64, sid);
-	list_for_each_entry(session, &amp;target-&gt;sessions_list, slist) {
-		if (sid64(session-&gt;isid, session-&gt;tsih) == sid)
+	list_for_each_entry(session, &amp;sessions_list, hlist) {
+		if (session-&gt;tsih == tsih)
 			return session;
 	}
-
 	return NULL;
 }
 
-void session_create(struct connection *conn)
+int session_create(struct connection *conn)
 {
-	struct session *session;
-	uint64_t sid;
-	static uint16_t tsih = 1;
+	struct session *session = NULL;
+	static uint16_t tsih, last_tsih = 0;
+	struct target *target;
 
-	/* First, we need to get an available sid. */
-	while (1) {
-		sid = sid64(conn-&gt;isid, tsih);
-		if (!session_find_id(conn-&gt;tid, sid))
+	target = target_find_by_id(conn-&gt;tid);
+	if (!target)
+		return -EINVAL;
+
+	for (tsih = last_tsih + 1; tsih != last_tsih; tsih++) {
+		if (!tsih)
+			continue;
+		session = session_lookup(tsih);
+		if (!session)
 			break;
-		tsih++;
 	}
+	if (session)
+		return -EINVAL;
 
-	session = session_alloc(conn-&gt;tid);
+	session = zalloc(sizeof(*session));
 	if (!session)
-		return;
+		return -ENOMEM;
 
+	session-&gt;target = target;
+	INIT_LIST_HEAD(&amp;session-&gt;slist);
+	list_add(&amp;session-&gt;slist, &amp;target-&gt;sessions_list);
+
+	INIT_LIST_HEAD(&amp;session-&gt;conn_list);
+	INIT_LIST_HEAD(&amp;session-&gt;cmd_list);
+
 	memcpy(session-&gt;isid, conn-&gt;isid, sizeof(session-&gt;isid));
-	session-&gt;tsih = tsih++;
+	session-&gt;tsih = last_tsih = tsih;
 
 	conn_add_to_session(conn, session);
 	conn-&gt;session-&gt;initiator = strdup(conn-&gt;initiator);
 
-	log_debug(&quot;session_create: %#&quot; PRIx64, sid);
+	log_debug(&quot;session_create: %#&quot; PRIx64, sid64(conn-&gt;isid, session-&gt;tsih));
 
-	ki-&gt;create_session(thandle, conn-&gt;exp_cmd_sn, &amp;session-&gt;ksid,
-			   &amp;session-&gt;hostno);
-
 	list_add(&amp;session-&gt;hlist, &amp;sessions_list);
+
+	return 0;
 }
 
-void session_remove(struct session *session)
+void session_destroy(struct session *session)
 {
-	uint64_t sid = sid64(session-&gt;isid, session-&gt;tsih);
+	eprintf(&quot;%d\n&quot;, session-&gt;tsih);
 
-	eprintf(&quot;%#&quot;  PRIx64 &quot;\n&quot;, sid);
+	if (!list_empty(&amp;session-&gt;conn_list)) {
+		eprintf(&quot;%d conn_list is not null\n&quot;, session-&gt;tsih);
+		return;
+	}
 
-	if (!list_empty(&amp;session-&gt;conn_list))
-		eprintf(&quot;%&quot; PRIx64 &quot; conn_list is not null\n&quot;, sid);
-
-	if (!session-&gt;tsih)
-		ki-&gt;destroy_session(thandle, session-&gt;ksid);
-
 	if (session-&gt;target) {
 		list_del(&amp;session-&gt;slist);
 /* 		session-&gt;target-&gt;nr_sessions--; */

Modified: branches/user-iscsi/usr/iscsi/types.h
===================================================================
--- branches/user-iscsi/usr/iscsi/types.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/types.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -27,4 +27,7 @@
 #error &quot;unknown endianess!&quot;
 #endif
 
+typedef uint16_t __be16;
+typedef uint32_t __be32;
+
 #endif	/* TYPES_H */

Modified: branches/user-iscsi/usr/mgmt.c
===================================================================
--- branches/user-iscsi/usr/mgmt.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/mgmt.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -223,8 +223,16 @@
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 
+retry:
 	err = recvmsg(fd, &amp;msg, MSG_PEEK | MSG_DONTWAIT);
 	if (err != len) {
+		/*
+		 * workaround. We need to put this request to
+		 * scheduler and wait for timeout or data.
+		 */
+		if (errno == EAGAIN)
+			goto retry;
+
 		eprintf(&quot;can't read %s\n&quot;, strerror(errno));
 		goto out;
 	}

Modified: branches/user-iscsi/usr/scsi.c
===================================================================
--- branches/user-iscsi/usr/scsi.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/scsi.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -21,7 +21,7 @@
 #include &lt;unistd.h&gt;
 #include &lt;asm/byteorder.h&gt;
 #include &lt;linux/fs.h&gt;
-#include &lt;scsi/scsi.h&gt;
+#include &quot;scsi.h&quot;
 #include &lt;sys/mman.h&gt;
 
 #include &quot;list.h&quot;

Modified: branches/user-iscsi/usr/target.c
===================================================================
--- branches/user-iscsi/usr/target.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/target.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -32,7 +32,7 @@
 #include &lt;sys/stat.h&gt;
 
 #include &lt;linux/fs.h&gt;
-#include &lt;scsi/scsi.h&gt;
+#include &quot;scsi.h&quot;
 
 #include &quot;list.h&quot;
 #include &quot;util.h&quot;

Modified: branches/user-iscsi/usr/tgtd.c
===================================================================
--- branches/user-iscsi/usr/tgtd.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtd.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -39,7 +39,7 @@
 #include &quot;driver.h&quot;
 
 enum {
-	POLL_KI, /* kernel interface */
+/* 	POLL_KI, /\* kernel interface *\/ */
 	POLL_IPC, /* unix domain socket for tgtdadm */
 	POLL_END,
 };
@@ -138,10 +138,10 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_KI].revents) {
-		kspace_event_handle();
-		nevent--;
-	}
+/* 	if (pfd[POLL_KI].revents) { */
+/* 		kspace_event_handle(); */
+/* 		nevent--; */
+/* 	} */
 
 	if (pfd[POLL_IPC].revents) {
 		dprintf(&quot;ipc event\n&quot;);
@@ -171,8 +171,8 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_KI].fd = nl_fd;
-	pfd[POLL_KI].events = POLLIN;
+/* 	pfd[POLL_KI].fd = nl_fd; */
+/* 	pfd[POLL_KI].events = POLLIN; */
 	pfd[POLL_IPC].fd = ud_fd;
 	pfd[POLL_IPC].events = POLLIN;
 
@@ -276,14 +276,15 @@
 	if (err)
 		exit(1);
 
-	err = kreq_init(&amp;ki_fd);
-	if (err)
-		exit(1);
+/* 	err = kreq_init(&amp;ki_fd); */
+/* 	if (err) */
+/* 		exit(1); */
 
 	err = ipc_init(&amp;ipc_fd);
 	if (err)
 		exit(1);
 
+	ki_fd = 0;
 	pfd = pfd_init(nr_pfd, ki_fd, ipc_fd);
 
 	event_loop(pfd, nr_pfd, timeout);

Modified: branches/user-iscsi/usr/tgtd.h
===================================================================
--- branches/user-iscsi/usr/tgtd.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtd.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -37,7 +37,7 @@
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
 typedef int (cmd_end_t)(int host_no, int len, int result, int rw, uint64_t addr,
-			 uint64_t tag);
+			uint64_t tag);
 typedef int (mgmt_end_t)(int host_no, uint64_t mid, int result);
 extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
 			    uint32_t data_len, int attribute, uint64_t tag,

Deleted: branches/user-iscsi/usr/tgtif.c
===================================================================
--- branches/user-iscsi/usr/tgtif.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtif.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,187 +0,0 @@
-/*
- * SCSI kernel and user interface
- *
- * Copyright (C) 2006 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * Copyright (C) 2006 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;asm/types.h&gt;
-#include &lt;sys/mman.h&gt;
-#include &lt;sys/poll.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;scsi/scsi_tgt_if.h&gt;
-
-#include &quot;list.h&quot;
-#include &quot;util.h&quot;
-#include &quot;tgtd.h&quot;
-
-struct uring {
-	uint32_t idx;
-	uint32_t nr_entry;
-	int entry_size;
-	char *buf;
-	int buf_size;
-};
-
-static struct uring kuring, ukring;
-static int chrfd;
-
-static inline struct rbuf_hdr *head_ring_hdr(struct uring *r)
-{
-	uint32_t offset = (r-&gt;idx &amp; (r-&gt;nr_entry - 1)) * r-&gt;entry_size;
-	return (struct rbuf_hdr *) (r-&gt;buf + offset);
-}
-
-static void ring_init(struct uring *r, char *buf, int bsize, int esize)
-{
-	int i;
-
-	esize += sizeof(struct rbuf_hdr);
-	r-&gt;idx = 0;
-	r-&gt;buf = buf;
-	r-&gt;buf_size = bsize;
-	r-&gt;entry_size = esize;
-
-	bsize /= esize;
-	for (i = 0; (1 &lt;&lt; i) &lt; bsize &amp;&amp; (1 &lt;&lt; (i + 1)) &lt;= bsize; i++)
-		;
-	r-&gt;nr_entry = 1 &lt;&lt; i;
-
-	dprintf(&quot;%u %u\n&quot;, r-&gt;entry_size, r-&gt;nr_entry);
-}
-
-static int kreq_send(struct tgt_event *ev)
-{
-	struct rbuf_hdr *hdr;
-	hdr = head_ring_hdr(&amp;ukring);
-	if (hdr-&gt;status)
-		return -ENOMEM;
-
-	memcpy(hdr-&gt;data, ev, sizeof(*ev));
-	ukring.idx++;
-	hdr-&gt;status = 1;
-
-	write(chrfd, ev, 1);
-
-	return 0;
-}
-
-static int kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
-{
-	struct tgt_event ev;
-
-	ev.u.tsk_mgmt_rsp.host_no = host_no;
-	ev.u.tsk_mgmt_rsp.mid = mid;
-	ev.u.tsk_mgmt_rsp.result = result;
-
-	return kreq_send(&amp;ev);
-}
-
-static int kspace_send_cmd_res(int host_no, int len, int result,
-			       int rw, uint64_t addr, uint64_t tag)
-{
-	struct tgt_event ev;
-
-	ev.type = TGT_UEVENT_CMD_RSP;
-	ev.u.cmd_rsp.host_no = host_no;
-/* 	ev.u.cmd_rsp.cid = cmd-&gt;cid; */
-	ev.u.cmd_rsp.len = len;
-	ev.u.cmd_rsp.result = result;
-	ev.u.cmd_rsp.uaddr = addr;
-	ev.u.cmd_rsp.rw = rw;
-
-	return kreq_send(&amp;ev);
-}
-
-void kspace_event_handle(void)
-{
-	struct rbuf_hdr *hdr;
-	struct tgt_event *ev;
-
-	dprintf(&quot;nl event %u\n&quot;, kuring.idx);
-retry:
-	hdr = head_ring_hdr(&amp;kuring);
-	if (!hdr-&gt;status)
-		return;
-
-	ev = (struct tgt_event *) (hdr-&gt;data);
-
-	dprintf(&quot;event %u\n&quot;, ev-&gt;type);
-
-	switch (ev-&gt;type) {
-	case TGT_KEVENT_CMD_REQ:
-		target_cmd_queue(ev-&gt;k.cmd_req.host_no, ev-&gt;k.cmd_req.scb,
-				 ev-&gt;k.cmd_req.lun, ev-&gt;k.cmd_req.data_len,
-				 ev-&gt;k.cmd_req.attribute, ev-&gt;k.cmd_req.tag,
-				 kspace_send_cmd_res);
-		break;
-	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(ev-&gt;k.cmd_done.host_no, ev-&gt;k.cmd_done.cid);
-		break;
-	case TGT_KEVENT_TSK_MGMT_REQ:
-		target_mgmt_request(ev-&gt;k.cmd_req.host_no,
-				    ev-&gt;k.tsk_mgmt_req.mid,
-				    ev-&gt;k.tsk_mgmt_req.function,
-				    ev-&gt;k.tsk_mgmt_req.lun,
-				    ev-&gt;k.tsk_mgmt_req.tag,
-				    kspace_send_tsk_mgmt);
-		break;
-	default:
-		eprintf(&quot;unknown event %u\n&quot;, ev-&gt;type);
-	}
-
-	hdr-&gt;status = 0;
-	kuring.idx++;
-
-	goto retry;
-}
-
-#define CHRDEV_PATH &quot;/dev/tgt&quot;
-
-int kreq_init(int *ki_fd)
-{
-	int err, fd, size = TGT_RINGBUF_SIZE;
-	char *buf;
-
-	err = chrdev_open(&quot;tgt&quot;, CHRDEV_PATH, 0, &amp;fd);
-	if (err)
-		return err;
-
-	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (buf == MAP_FAILED) {
-		eprintf(&quot;fail to mmap %s\n&quot;, strerror(errno));
-		close(fd);
-		return -EINVAL;
-	}
-
-	ring_init(&amp;kuring, buf, size, sizeof(struct tgt_event));
-	ring_init(&amp;ukring, buf + size, size, sizeof(struct tgt_event));
-
-	*ki_fd = chrfd = fd;
-
-	return 0;
-}

Modified: branches/user-iscsi/usr/util.h
===================================================================
--- branches/user-iscsi/usr/util.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/util.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -33,6 +33,14 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x &gt; __y ? __x: __y; })
 
+static inline void *zalloc(size_t size)
+{
+	void *p = malloc(size);
+	if (p)
+		memset(p, 0, size);
+	return p;
+}
+
 extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000521.html">[Stgt-svn] r534 - branches
</A></li>
	<LI>Next message: <A HREF="000523.html">[Stgt-svn] r536 - in branches/user-iscsi: . usr usr/include
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#522">[ date ]</a>
              <a href="thread.html#522">[ thread ]</a>
              <a href="subject.html#522">[ subject ]</a>
              <a href="author.html#522">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
