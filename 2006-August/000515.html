<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r528 - trunk/patchset
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r528%20-%20trunk/patchset&In-Reply-To=%3C200608162358.k7GNwB69006635%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000514.html">
   <LINK REL="Next"  HREF="000516.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r528 - trunk/patchset</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r528%20-%20trunk/patchset&In-Reply-To=%3C200608162358.k7GNwB69006635%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r528 - trunk/patchset">tomo at mail.berlios.de
       </A><BR>
    <I>Thu Aug 17 01:58:11 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000514.html">[Stgt-svn] r527 - trunk/usr
</A></li>
        <LI>Next message: <A HREF="000516.html">[Stgt-svn] r529 - in trunk/usr: . ibmvio
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#515">[ date ]</a>
              <a href="thread.html#515">[ thread ]</a>
              <a href="subject.html#515">[ subject ]</a>
              <a href="author.html#515">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-08-17 01:57:56 +0200 (Thu, 17 Aug 2006)
New Revision: 528

Added:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
   trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
Removed:
   trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   trunk/patchset/0005-scsi-target-kill-target-command-list.txt
Modified:
   trunk/patchset/README
Log:
Update the patchset (against James' scsi-rc-fixes tree).


Added: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,48 @@
+From 9286b9ae56bd63756c6f4e2993abf049c8f01153 Mon Sep 17 00:00:00 2001
+From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at debian.localdomain</A>&gt;
+Date: Thu, 17 Aug 2006 06:56:32 +0900
+Subject: [PATCH 1/9] [PATCH] block layer: kill length alignment test in bin_map_user
+
+The tgt project is mapping in bios using bio_map_user. The current targets
+do not need their len to be aligned with a queue limit so this check is
+causing some problems. Note: pointers passed into the kernel are properly
+aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
+
+The major user, blk_bio_map_user checks for the len before mapping
+so it is not affected by this patch.
+
+And the semi-newly added user blk_rq_map_user_iov has been failing
+out when the len is not aligned properly so maybe people have been
+good and not sending misaligned lens or that path is not used very
+often and this change will not be very dangerous. st and sg do not
+check the length and we have not seen any problem reports from those
+wider used paths so this patch should be fairly safe - for mm
+and wider testing at least.
+
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/fs/bio.c b/fs/bio.c
+index 6a0b9ad..6fe47ce 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr &amp; queue_dma_alignment(q)) || (len &amp; queue_dma_alignment(q)))
++		if (uaddr &amp; queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,583 +0,0 @@
-Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143376921 +0900
-
----
-
- drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
- drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
- drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
- drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
- 4 files changed, 142 insertions(+), 125 deletions(-)
-
-74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool-&gt;events[i].ext_list) {
- 			dma_free_coherent(hostdata-&gt;dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool-&gt;events[i].ext_list,
- 				  pool-&gt;events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_out_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_in_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd-&gt;data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd-&gt;data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
-+	else
-+		srp_cmd-&gt;buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i &lt; num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i &lt; num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
--	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd-&gt;additional_data;
--		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd-&gt;add_data;
-+		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd-&gt;additional_data;
--		int num_mapped = indirect-&gt;head.length / 
--			sizeof(indirect-&gt;list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd-&gt;add_data;
-+		int num_mapped = indirect-&gt;table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
-+			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i &lt; num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &amp;sg[i];
--		descr-&gt;virtual_address = sg_dma_address(sg_entry);
--		descr-&gt;length = sg_dma_len(sg_entry);
--		descr-&gt;memory_handle = 0;
-+		descr-&gt;va = sg_dma_address(sg_entry);
-+		descr-&gt;len = sg_dma_len(sg_entry);
-+		descr-&gt;key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd-&gt;request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
--		data-&gt;length = sg_dma_len(&amp;sg[0]);
--		data-&gt;memory_handle = 0;
-+		data-&gt;va = sg_dma_address(&amp;sg[0]);
-+		data-&gt;len = sg_dma_len(&amp;sg[0]);
-+		data-&gt;key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect-&gt;head.virtual_address = 0;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	indirect-&gt;head.memory_handle = 0;
-+	indirect-&gt;table_desc.va = 0;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect-&gt;table_desc.key = 0;
- 
- 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
--		indirect-&gt;total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &amp;indirect-&gt;desc_list[0]);
-+		indirect-&gt;len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct-&gt;ext_list) {
--		evt_struct-&gt;ext_list =(struct memory_descriptor*)
-+		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&amp;evt_struct-&gt;ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &amp;evt_struct-&gt;ext_list_token, 0);
- 		if (!evt_struct-&gt;ext_list) {
--		    printk(KERN_ERR
--		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
-+			printk(KERN_ERR
-+			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
- 
--	indirect-&gt;total_length = total_length;
--	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect-&gt;len = total_length;
-+	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
-+	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
- 
--	data-&gt;virtual_address =
-+	data-&gt;va =
- 		dma_map_single(dev, cmd-&gt;request_buffer,
- 			       cmd-&gt;request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data-&gt;virtual_address)) {
-+	if (dma_mapping_error(data-&gt;va)) {
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
- 		return 0;
- 	}
--	data-&gt;length = cmd-&gt;request_bufflen;
--	data-&gt;memory_handle = 0;
-+	data-&gt;len = cmd-&gt;request_bufflen;
-+	data-&gt;key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
--	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
-+	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
- 
--	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
--			       rsp-&gt;type);
-+			       rsp-&gt;opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd-&gt;result = rsp-&gt;status;
- 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd-&gt;sense_buffer,
--			       rsp-&gt;sense_and_response_data,
--			       rsp-&gt;sense_data_list_length);
-+			       rsp-&gt;data,
-+			       rsp-&gt;sense_data_len);
- 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct-&gt;hostdata-&gt;dev);
- 
--		if (rsp-&gt;doover)
--			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
--		else if (rsp-&gt;diover)
--			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
-+		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
-+		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
- 	}
- 
- 	if (evt_struct-&gt;cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
- 	u16 lun = lun_from_dev(cmnd-&gt;device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd-&gt;type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd-&gt;opcode = SRP_CMD;
- 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
- 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct-&gt;cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
--	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
--	    (indirect-&gt;head.virtual_address == 0)) {
--		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
-+	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
-+	    indirect-&gt;table_desc.va == 0) {
-+		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
--	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
- 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
--		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
-+		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
- 
--	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
-+	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
- 	    (max_requests - 2))
--		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
-+		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&amp;hostdata-&gt;request_limit,
--		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
-+		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
- 
- 	hostdata-&gt;host-&gt;can_queue =
--	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
- 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &amp;evt_struct-&gt;iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login-&gt;type = SRP_LOGIN_REQ_TYPE;
--	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login-&gt;required_buffer_formats = 0x0006;
-+	login-&gt;opcode = SRP_LOGIN_REQ;
-+	login-&gt;req_it_iu_len = sizeof(union srp_iu);
-+	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt-&gt;task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
- 
- 	evt-&gt;sync_srp = &amp;srp_rsp;
- 	init_completion(&amp;evt-&gt;comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
-+			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
- 			       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
- 		printk(KERN_INFO
- 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
--		       tsk_mgmt-&gt;managed_task_tag);
-+		       tsk_mgmt-&gt;task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;task_tag);
- 
- 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
- 	list_del(&amp;found_evt-&gt;list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
- 	       tsk_mgmt-&gt;lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
--		       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       rsp_rc, tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
- 			   &amp;hostdata-&gt;request_limit);
- 
- 	if (evt_struct-&gt;done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include &lt;linux/dma-mapping.h&gt;
- #include &lt;linux/interrupt.h&gt;
- #include &quot;ibmvscsi.h&quot;
--#include &quot;srp.h&quot;
- 
- static char partition_name[97] = &quot;UNKNOWN&quot;;
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include &quot;srp.h&quot;
-+#include &lt;scsi/srp.h&gt;
-+
-+#define SRP_VERSION &quot;16.a&quot;
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,
--- 
-1.1.3

Added: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,154 @@
+From 810f8fd6b5ad802477ad9a95bbf6540c5d44f2de Mon Sep 17 00:00:00 2001
+From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at debian.localdomain</A>&gt;
+Date: Thu, 17 Aug 2006 07:31:59 +0900
+Subject: [PATCH 2/9] [PATCH] block layer: add partial mappings support to bio_map_user
+
+For target mode we could end up with the case where we get very large
+request from the initiator. The request could be so large that we
+cannot transfer all the data in one operation. For example the
+HBA's segment or max_sector limits might limit us to a 1 MB transfer.
+To send a 5 MB command then we need to transfer the command chunk by chunk.
+
+To do this, tgt core will map in as much data as possible into a bio,
+send this off, then when that transfer is completed we send off another
+request/bio. To be able to pack as much data into a bio as possible
+we need bio_map_user to support partially mapped bios.
+
+- bio_map_user_iov always allows partial mappings.
+
+- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
+if the bio is partially mapped.
+
+- Added a length argument to blk_rq_map_user_iov in order to avoid
+including sg.h in ll_rw_blk.c for struct sg_iovec.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
+ block/scsi_ioctl.c     |    3 ++-
+ fs/bio.c               |   14 +-------------
+ include/linux/blkdev.h |    3 ++-
+ 4 files changed, 23 insertions(+), 26 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 61d6b3c..aee4f4b 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+-	if (!IS_ERR(bio)) {
+-		rq-&gt;bio = rq-&gt;biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq-&gt;buffer = rq-&gt;data = NULL;
+-		rq-&gt;data_len = len;
+-		return 0;
++	if (bio-&gt;bi_size != len) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq-&gt;bio = rq-&gt;biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq-&gt;buffer = rq-&gt;data = NULL;
++	rq-&gt;data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
++	if (bio-&gt;bi_size != len) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq-&gt;bio = rq-&gt;biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq-&gt;buffer = rq-&gt;data = NULL;
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index b33eda2..b77e185 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr-&gt;iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr-&gt;iovec_count,
++					  hdr-&gt;dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr-&gt;dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr-&gt;dxferp, hdr-&gt;dxfer_len);
+diff --git a/fs/bio.c b/fs/bio.c
+index 6fe47ce..ade77bf 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
+ {
+ 	struct bio *bio;
+-	int len = 0, i;
+ 
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
+ 
+@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
+ 
+-	for (i = 0; i &lt; iov_count; i++)
+-		len += iov[i].iov_len;
+-
+-	if (bio-&gt;bi_size == len)
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio-&gt;bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
+ 
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index aafe827..613a441 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,246 +0,0 @@
-Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143377151 +0900
-
----
-
- drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
- 1 files changed, 0 insertions(+), 227 deletions(-)
- delete mode 100644 drivers/scsi/ibmvscsi/srp.h
-
-acbd74e89dc7bcf4e2596800e46a19378db44641
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION &quot;16.a&quot;
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
--- 
-1.1.3

Added: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,54 @@
+From 682da4d3e68a63d56a8a306b9e61ea0305be19d6 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Wed, 16 Aug 2006 08:23:21 +0900
+Subject: [PATCH 3/9] [PATCH] block layer: use blk_rq_bio_prep in init_request_from_bio
+
+Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
+blk_rq_bio_prep's flags copying. The first three bits have not been
+the same for some time so that has been broken. The user of
+blk_rq_bio_prep will setup the request flags so if it wanted failfast
+or to be a barrier it will set the correct flag itself.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ block/ll_rw_blk.c |   11 ++---------
+ 1 files changed, 2 insertions(+), 9 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index aee4f4b..3f46356 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
+ 
+ 	req-&gt;errors = 0;
+ 	req-&gt;hard_sector = req-&gt;sector = bio-&gt;bi_sector;
+-	req-&gt;hard_nr_sectors = req-&gt;nr_sectors = bio_sectors(bio);
+-	req-&gt;current_nr_sectors = req-&gt;hard_cur_sectors = bio_cur_sectors(bio);
+-	req-&gt;nr_phys_segments = bio_phys_segments(req-&gt;q, bio);
+-	req-&gt;nr_hw_segments = bio_hw_segments(req-&gt;q, bio);
+-	req-&gt;buffer = bio_data(bio);	/* see -&gt;buffer comment above */
+ 	req-&gt;waiting = NULL;
+-	req-&gt;bio = req-&gt;biotail = bio;
+ 	req-&gt;ioprio = bio_prio(bio);
+ 	req-&gt;rq_disk = bio-&gt;bi_bdev-&gt;bd_disk;
+ 	req-&gt;start_time = jiffies;
++
++	blk_rq_bio_prep(req-&gt;q, req, bio);
+ }
+ 
+ static int __make_request(request_queue_t *q, struct bio *bio)
+@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
+ 
+ void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
+ {
+-	/* first two bits are identical in rq-&gt;flags and bio-&gt;bi_rw */
+-	rq-&gt;flags |= (bio-&gt;bi_rw &amp; 3);
+-
+ 	rq-&gt;nr_phys_segments = bio_phys_segments(q, bio);
+ 	rq-&gt;nr_hw_segments = bio_hw_segments(q, bio);
+ 	rq-&gt;current_nr_sectors = bio_cur_sectors(bio);
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,375 +0,0 @@
-Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
-
-This patch moves scsi_host_get_command and scsi_host_put_command to
-scsi_tgt_lib.c from scsi.c
-
-A target driver allocates scsi_cmnd structure via
-scsi_host_get_command, then pass it to tgt core via
-scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
-needs to allocate scsi_tgt_cmd structure (for tgt specific data).
-Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
-target drivers.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi.c         |  102 ++++------------------------------------
- drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
- include/scsi/scsi_cmnd.h    |    6 +-
- include/scsi/scsi_tgt.h     |    4 ++
- 4 files changed, 112 insertions(+), 109 deletions(-)
-
-b8f2574dbd844ac43602d9fa74e6196027528c63
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 9c22465..1d2fbe0 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
--
--/*
-- * Function:	scsi_host_get_command()
-- *
-- * Purpose:	Allocate and setup a scsi command block and blk request
-- *
-- * Arguments:	shost	- scsi host
-- *		data_dir - dma data dir
-- *		gfp_mask- allocator flags
-- *
-- * Returns:	The allocated scsi command structure.
-- *
-- * This should be called by target LLDs to get a command.
-- */
--struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
--					enum dma_data_direction data_dir,
--					gfp_t gfp_mask)
--{
--	int write = (data_dir == DMA_TO_DEVICE);
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--
--	/* Bail if we can't get a reference to the device */
--	if (!get_device(&amp;shost-&gt;shost_gendev))
--		return NULL;
--
--	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
--	if (!rq)
--		goto put_dev;
--
--	cmd = __scsi_get_command(shost, gfp_mask);
--	if (!cmd)
--		goto release_rq;
--
--	memset(cmd, 0, sizeof(*cmd));
--	cmd-&gt;sc_data_direction = data_dir;
--	cmd-&gt;jiffies_at_alloc = jiffies;
--	cmd-&gt;request = rq;
--
--	rq-&gt;special = cmd;
--	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
--
--	return cmd;
--
--release_rq:
--	blk_put_request(rq);
--put_dev:
--	put_device(&amp;shost-&gt;shost_gendev);
--	return NULL;
--
--}
--EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&amp;dev-&gt;sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
--/*
-- * Function:	scsi_host_put_command()
-- *
-- * Purpose:	Free a scsi command block
-- *
-- * Arguments:	shost	- scsi host
-- * 		cmd	- command block to free
-- *
-- * Returns:	Nothing.
-- *
-- * Notes:	The command must not belong to any lists.
-- */
--void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
- {
--	struct request_queue *q = shost-&gt;uspace_req_q;
--	struct request *rq = cmd-&gt;request;
- 	unsigned long flags;
- 
- 	/* changing locks here, don't need to restore the irq state */
-@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
- 		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
- 		cmd = NULL;
- 	}
--	spin_unlock(&amp;shost-&gt;free_list_lock);
--
--	spin_lock(q-&gt;queue_lock);
--	__blk_put_request(q, rq);
--	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
-+	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
- 
- 	if (likely(cmd != NULL))
- 		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
- 
--	put_device(&amp;shost-&gt;shost_gendev);
-+	put_device(dev);
- }
--EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+EXPORT_SYMBOL(__scsi_put_command);
- 
- /*
-  * Function:	scsi_put_command()
-@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd-&gt;device;
--	struct Scsi_Host *shost = sdev-&gt;host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&amp;cmd-&gt;device-&gt;list_lock, flags);
- 	BUG_ON(list_empty(&amp;cmd-&gt;list));
- 	list_del_init(&amp;cmd-&gt;list);
--	spin_unlock(&amp;cmd-&gt;device-&gt;list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&amp;shost-&gt;free_list_lock);
--	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
--		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
--
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
-+	spin_unlock_irqrestore(&amp;cmd-&gt;device-&gt;list_lock, flags);
- 
--	put_device(&amp;sdev-&gt;sdev_gendev);
-+	__scsi_put_command(cmd-&gt;device-&gt;host, cmd, &amp;sdev-&gt;sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index aea3e4d..e82340c 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
- 	struct list_head cmd_req;
- };
- 
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&amp;shost-&gt;shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd-&gt;sc_data_direction = data_dir;
-+	cmd-&gt;jiffies_at_alloc = jiffies;
-+	cmd-&gt;request = rq;
-+
-+	rq-&gt;special = cmd;
-+	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq-&gt;end_io_data = tcmd;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&amp;shost-&gt;shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+static void scsi_host_put_command(struct Scsi_Host *shost,
-+				  struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost-&gt;uspace_req_q;
-+	struct request *rq = cmd-&gt;request;
-+	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q-&gt;queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &amp;shost-&gt;shost_gendev);
-+}
-+
- static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
- {
- 	struct bio *bio;
-@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
- 		cmd-&gt;request-&gt;flags &amp;= ~1UL;
- 
- 	scsi_unmap_user_pages(tcmd);
--	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
- }
- 
-@@ -177,13 +265,13 @@ out:
- 		goto retry;
- }
- 
--/**
-+/*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-  *
-  * This should be called by the LLD after host allocation.
-  * And will be released when the host is released.
-- **/
-+ */
- int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
- {
- 	struct scsi_tgt_queuedata *queuedata;
-@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
- 
--/**
-+/*
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-  * @noblock:	set to nonzero if the command should be queued
-- **/
-+ */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
- 	struct request_queue *q = cmd-&gt;request-&gt;q;
- 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
- 	unsigned long flags;
--	struct scsi_tgt_cmd *tcmd;
--
--	/*
--	 * It would be better to allocate scsi_tgt_cmd structure in
--	 * scsi_host_get_command and not to fail due to OOM.
--	 */
--	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
--	if (!tcmd)
--		return -ENOMEM;
--	cmd-&gt;request-&gt;end_io_data = tcmd;
-+	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
- 
- 	bio_list_init(&amp;tcmd-&gt;xfer_list);
- 	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 51156c7..c822bc2 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -150,11 +150,11 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
--extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
--					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
--extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-index 2d65be7..61e8ee9 100644
---- a/include/scsi/scsi_tgt.h
-+++ b/include/scsi/scsi_tgt.h
-@@ -2,6 +2,8 @@
-  * SCSI target definitions
-  */
- 
-+#include &lt;linux/dma-mapping.h&gt;
-+
- struct Scsi_Host;
- struct scsi_cmnd;
- struct scsi_lun;
-@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
- extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
- extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
- 				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
--- 
-1.1.3

Added: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,306 @@
+From 26dc82d471a4e83acec09789c8da6cc7fa788c89 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:39:42 +0900
+Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+This patch contains the needed changes to the scsi-ml to support targets.
+
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ drivers/scsi/hosts.c     |    4 ++++
+ drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
+ include/scsi/scsi_cmnd.h |    7 +++++++
+ include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 104 insertions(+), 26 deletions(-)
+
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index dfcb96f..341c1ee 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
+ 		kthread_stop(shost-&gt;ehandler);
+ 	if (shost-&gt;work_q)
+ 		destroy_workqueue(shost-&gt;work_q);
++	if (shost-&gt;uspace_req_q) {
++		kfree(shost-&gt;uspace_req_q-&gt;queuedata);
++		scsi_free_queue(shost-&gt;uspace_req_q);
++	}
+ 
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost-&gt;shost_data);
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index b332cad..08f8597 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&amp;dev-&gt;sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
++{
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&amp;shost-&gt;free_list_lock, flags);
++	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
++		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
++		cmd = NULL;
++	}
++	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
++
++	put_device(dev);
++}
++EXPORT_SYMBOL(__scsi_put_command);
++
+ /*
+  * Function:	scsi_put_command()
+  *
+@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd-&gt;device;
+-	struct Scsi_Host *shost = sdev-&gt;host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&amp;cmd-&gt;device-&gt;list_lock, flags);
+ 	BUG_ON(list_empty(&amp;cmd-&gt;list));
+ 	list_del_init(&amp;cmd-&gt;list);
+-	spin_unlock(&amp;cmd-&gt;device-&gt;list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&amp;shost-&gt;free_list_lock);
+-	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
+-		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
++	spin_unlock_irqrestore(&amp;cmd-&gt;device-&gt;list_lock, flags);
+ 
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
+-
+-	put_device(&amp;sdev-&gt;sdev_gendev);
++	__scsi_put_command(cmd-&gt;device-&gt;host, cmd, &amp;sdev-&gt;sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 077c1c6..ea22612 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -734,7 +734,9 @@ #endif
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp-&gt;pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev-&gt;host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost-&gt;sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost-&gt;max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost-&gt;dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost-&gt;use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &amp;q-&gt;queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev-&gt;host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 58e6444..254a904 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@ #include &lt;linux/timer.h&gt;
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ 
+ 
+@@ -133,7 +134,10 @@ #define SCSI_STATE_MLQUEUE         0x100
+ 
+ 
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
+ extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
+@@ -142,4 +146,7 @@ extern void *scsi_kmap_atomic_sg(struct 
+ 				 size_t *offset, size_t *len);
+ extern void scsi_kunmap_atomic_sg(void *virt);
+ 
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
++
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index b3dd90f..1a393b6 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@ #include &lt;linux/types.h&gt;
+ #include &lt;linux/workqueue.h&gt;
+ #include &lt;linux/mutex.h&gt;
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -122,6 +123,39 @@ #endif
+ 	int (* queuecommand)(struct scsi_cmnd *,
+ 			     void (*done)(struct scsi_cmnd *));
+ 
++ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd-&gt;request_bufflen
++	 * bytes of the cmd at cmd-&gt;offset in the cmd. The cmd-&gt;use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd-&gt;request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
+ 	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+@@ -561,6 +595,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++						void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,554 +0,0 @@
-Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
-
-The user-space damoen and tgt kernel module need to exhange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch replaces netlink shared memory between kernel and user
-spaces. The user-space damoen and tgt kernel module creates shared
-memory via mmap and use it like ring buffer. poll (kernel to user) and
-write (user to kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
- drivers/scsi/scsi_tgt_lib.c  |   10 +
- drivers/scsi/scsi_tgt_priv.h |    6 -
- include/linux/netlink.h      |    1 
- include/scsi/scsi_tgt_if.h   |   19 +--
- 5 files changed, 216 insertions(+), 131 deletions(-)
-
-cd29acfca7cdeb8c351db14af357207e9dcb17f3
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-index 37e0feb..c4c5bdb 100644
---- a/drivers/scsi/scsi_tgt_if.c
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -21,7 +21,6 @@
-  */
- #include &lt;linux/blkdev.h&gt;
- #include &lt;linux/file.h&gt;
--#include &lt;linux/netlink.h&gt;
- #include &lt;net/tcp.h&gt;
- #include &lt;scsi/scsi.h&gt;
- #include &lt;scsi/scsi_cmnd.h&gt;
-@@ -32,87 +31,129 @@
- 
- #include &quot;scsi_tgt_priv.h&quot;
- 
--static int tgtd_pid;
--static struct sock *nl_sk;
-+struct rbuf {
-+	u32 idx;
-+	u32 nr_entry;
-+	int entry_size;
-+	char *buf;
-+	int buf_size;
-+	spinlock_t lock;
-+};
-+
-+static int chrdev;
-+static struct rbuf txbuf, rxbuf;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
- 
--static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
--			  pid_t pid)
-+static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-+{
-+	u32 offset = (idx &amp; (rbuf-&gt;nr_entry - 1)) * rbuf-&gt;entry_size;
-+	return (struct rbuf_hdr *) (rbuf-&gt;buf + offset);
-+}
-+
-+static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-+{
-+	int i;
-+
-+	esize += sizeof(struct rbuf_hdr);
-+	rbuf-&gt;idx = 0;
-+	rbuf-&gt;entry_size = esize;
-+	rbuf-&gt;buf = buf;
-+	spin_lock_init(&amp;rbuf-&gt;lock);
-+
-+	bsize /= esize;
-+	for (i = 0; (1 &lt;&lt; i) &lt; bsize &amp;&amp; (1 &lt;&lt; (i + 1)) &lt;= bsize; i++)
-+		;
-+	rbuf-&gt;nr_entry = 1 &lt;&lt; i;
-+}
-+
-+static int send_event_rsp(u32 type, struct tgt_event *p)
- {
- 	struct tgt_event *ev;
--	struct nlmsghdr *nlh;
--	struct sk_buff *skb;
--	uint32_t len;
--
--	len = NLMSG_SPACE(sizeof(*ev));
--	skb = alloc_skb(len, flags);
--	if (!skb)
--		return -ENOMEM;
-+	struct rbuf_hdr *hdr;
-+	struct page *sp, *ep;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&amp;txbuf.lock, flags);
-+
-+	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx);
-+	if (hdr-&gt;status)
-+		err = 1;
-+	else
-+		txbuf.idx++;
- 
--	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
- 
--	ev = NLMSG_DATA(nlh);
-+	if (err)
-+		return err;
-+
-+	ev = (struct tgt_event *) hdr-&gt;data;
- 	memcpy(ev, p, sizeof(*ev));
-+	ev-&gt;type = type;
-+	hdr-&gt;status = 1;
-+	mb();
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-+	for (;sp &lt;= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	wake_up_interruptible(&amp;tgt_poll_wait);
- 
--	return netlink_unicast(nl_sk, skb, pid, 0);
-+	return 0;
- }
- 
--int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
--			 gfp_t flags)
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
--	struct sk_buff *skb;
--	struct nlmsghdr *nlh;
--	struct tgt_event *ev;
--	int err, len;
-+	struct tgt_event ev;
-+	int err;
- 
--	len = NLMSG_SPACE(sizeof(*ev));
--	/*
--	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
--	 */
--	skb = alloc_skb(NLMSG_SPACE(len), flags);
--	if (!skb)
--		return -ENOMEM;
--
--	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
--			  len - sizeof(*nlh), 0);
--
--	ev = NLMSG_DATA(nlh);
--	ev-&gt;k.cmd_req.host_no = shost-&gt;host_no;
--	ev-&gt;k.cmd_req.cid = cmd-&gt;request-&gt;tag;
--	ev-&gt;k.cmd_req.data_len = cmd-&gt;request_bufflen;
--	memcpy(ev-&gt;k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev-&gt;k.cmd_req.scb));
--	memcpy(ev-&gt;k.cmd_req.lun, lun, sizeof(ev-&gt;k.cmd_req.lun));
--	ev-&gt;k.cmd_req.attribute = cmd-&gt;tag;
--	ev-&gt;k.cmd_req.tag = tag;
--
--	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev-&gt;k.cmd_req.cid,
--		ev-&gt;k.cmd_req.data_len, cmd-&gt;tag,
--		(unsigned long long) ev-&gt;k.cmd_req.tag);
--
--	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
--	if (err &lt; 0)
--		printk(KERN_ERR &quot;scsi_tgt_uspace_send: could not send skb %d\n&quot;,
--		       err);
-+	memset(&amp;ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost-&gt;host_no;
-+	ev.k.cmd_req.cid = cmd-&gt;request-&gt;tag;
-+	ev.k.cmd_req.data_len = cmd-&gt;request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd-&gt;tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd-&gt;tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
- 	return err;
- }
- 
--int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&amp;ev, 0, sizeof(ev));
- 	ev.k.cmd_done.host_no = shost-&gt;host_no;
- 	ev.k.cmd_done.cid = cmd-&gt;request-&gt;tag;
- 	ev.k.cmd_done.result = cmd-&gt;result;
- 
--	return send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev, gfp_mask, tgtd_pid);
-+	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd-&gt;tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
-+	return err;
- }
- 
- int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
- 				  struct scsi_lun *scsilun, void *data)
- {
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&amp;ev, 0, sizeof(ev));
- 	ev.k.tsk_mgmt_req.host_no = host_no;
-@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
- 	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
- 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
- 
--	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev, GFP_KERNEL, tgtd_pid);
-+	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev);
-+	if (err)
-+		eprintk(&quot;tx buf is full, could not send\n&quot;);
-+	return err;
- }
- 
--static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+static int event_recv_msg(struct tgt_event *ev)
- {
--	struct tgt_event *ev = NLMSG_DATA(nlh);
- 	int err = 0;
- 
--	dprintk(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type,
--		nlh-&gt;nlmsg_pid, current-&gt;pid);
--
--	switch (nlh-&gt;nlmsg_type) {
--	case TGT_UEVENT_REQ:
--		tgtd_pid = NETLINK_CREDS(skb)-&gt;pid;
--		break;
-+	switch (ev-&gt;type) {
- 	case TGT_UEVENT_CMD_RSP:
--		/* TODO: handle multiple cmds in one event */
- 		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_rsp.host_no,
- 					   ev-&gt;u.cmd_rsp.cid,
- 					   ev-&gt;u.cmd_rsp.result,
-@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
- 					       ev-&gt;u.tsk_mgmt_rsp.result);
- 		break;
- 	default:
--		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
-+		eprintk(&quot;unknown type %d\n&quot;, ev-&gt;type);
- 		err = -EINVAL;
- 	}
- 
- 	return err;
- }
- 
--static int event_recv_skb(struct sk_buff *skb)
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
- {
--	int err;
--	uint32_t rlen;
--	struct nlmsghdr	*nlh;
--	struct tgt_event ev;
-+	struct rbuf_hdr *hdr;
-+	struct tgt_event *ev;
-+	struct page *sp, *ep;
- 
--	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
--		nlh = (struct nlmsghdr *) skb-&gt;data;
--		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
--			return 0;
--		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
--		if (rlen &gt; skb-&gt;len)
--			rlen = skb-&gt;len;
--		err = event_recv_msg(skb, nlh);
--
--		dprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
--		/*
--		 * TODO for passthru commands the lower level should
--		 * probably handle the result or we should modify this
--		 */
--		switch (nlh-&gt;nlmsg_type) {
--		case TGT_UEVENT_CMD_RSP:
--		case TGT_UEVENT_TSK_MGMT_RSP:
--			break;
--		default:
--			memset(&amp;ev, 0, sizeof(ev));
--			ev.k.event_rsp.err = err;
--			send_event_rsp(TGT_KEVENT_RSP, &amp;ev,
--				       GFP_KERNEL | __GFP_NOFAIL,
--					nlh-&gt;nlmsg_pid);
--		}
--		skb_pull(skb, rlen);
--	}
--	return 0;
-+retry:
-+	hdr = head_rbuf_hdr(&amp;rxbuf, rxbuf.idx);
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
-+	for (;sp &lt;= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	if (!hdr-&gt;status)
-+		return count;
-+
-+	rxbuf.idx++;
-+	ev = (struct tgt_event *) hdr-&gt;data;
-+	event_recv_msg(ev);
-+	hdr-&gt;status = 0;
-+
-+	goto retry;
- }
- 
--static void event_recv(struct sock *sk, int length)
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
- {
--	struct sk_buff *skb;
-+	struct rbuf_hdr *hdr;
-+	unsigned long flags;
-+	unsigned int mask = 0;
- 
--	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
--		if (NETLINK_CREDS(skb)-&gt;uid) {
--			skb_pull(skb, skb-&gt;len);
--			kfree_skb(skb);
--			continue;
--		}
-+	poll_wait(file, &amp;tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&amp;txbuf.lock, flags);
- 
--		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
--			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
--		else
--			kfree_skb(skb);
-+	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx - 1);
-+	if (hdr-&gt;status)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
-+
-+	return mask;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long size, addr;
-+	struct page *page;
-+	int err, i;
-+
-+	if (vma-&gt;vm_pgoff) {
-+		eprintk(&quot;bug\n&quot;);
-+		return -EINVAL;
-+	}
-+
-+	size = vma-&gt;vm_end - vma-&gt;vm_start;
-+	if (size != TGT_RINGBUF_SIZE * 2) {
-+		eprintk(&quot;%lu\n&quot;, size);
-+		return -EINVAL;
-+	}
-+	addr = vma-&gt;vm_start;
-+	page = virt_to_page(txbuf.buf);
-+	for (i = 0; i &lt; size &gt;&gt; PAGE_SHIFT; i++) {
-+		err = vm_insert_page(vma, addr, page);
-+		if (err) {
-+			eprintk(&quot;%d %d %lu\n&quot;, err, i, addr);
-+			return -EINVAL;
-+		}
-+		addr += PAGE_SIZE;
-+		page++;
- 	}
-+
-+	return 0;
- }
- 
-+static struct file_operations tgt_fops = {
-+	.owner	= THIS_MODULE,
-+	.poll	= tgt_poll,
-+	.write	= tgt_write,
-+	.mmap	= tgt_mmap,
-+};
-+
- void __exit scsi_tgt_if_exit(void)
- {
--	sock_release(nl_sk-&gt;sk_socket);
-+	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-+
-+	unregister_chrdev(chrdev, &quot;tgt&quot;);
-+	free_pages((unsigned long) txbuf.buf, order);
- }
- 
- int __init scsi_tgt_if_init(void)
- {
--	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
--				    THIS_MODULE);
--	if (!nl_sk)
--		return -ENOMEM;
-+	u32 bsize = TGT_RINGBUF_SIZE;
-+	int order;
-+	char *buf;
-+
-+	chrdev = register_chrdev(0, &quot;tgt&quot;, &amp;tgt_fops);
-+	if (chrdev &lt; 0)
-+		return chrdev;
-+
-+	order = long_log2((bsize * 2) &gt;&gt; PAGE_SHIFT);
-+	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-+					order);
-+	if (!buf)
-+		goto free_dev;
-+	rbuf_init(&amp;txbuf, buf, bsize, sizeof(struct tgt_event));
-+	rbuf_init(&amp;rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
- 
- 	return 0;
-+
-+free_dev:
-+	unregister_chrdev(chrdev, &quot;tgt&quot;);
-+
-+	return -ENOMEM;
- }
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index e82340c..7ebfbc0 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -246,7 +246,7 @@ retry:
- 	tcmd = rq-&gt;end_io_data;
- 	init_scsi_tgt_cmd(rq, tcmd);
- 	cmd = rq-&gt;special;
--	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, tcmd-&gt;tag, GFP_ATOMIC);
-+	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
- 	if (err &lt; 0) {
- 		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
- 
-@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
- 
- 	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
- 
--	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+	scsi_tgt_uspace_send_status(cmd);
- 	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
- 	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
- }
-@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
- 		return;
- 
- 	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
--	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
-+	err = scsi_tgt_uspace_send_status(cmd);
-+	if (err &lt;= 0)
- 		/* the eh will have to pick this up */
- 		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
- }
-@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
- 	/* should we free resources here on error ? */
- 	if (cmd-&gt;result) {
- send_uspace_err:
--		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
-+		err = scsi_tgt_uspace_send_status(cmd);
-+		if (err &lt;= 0)
- 			/* the tgt uspace eh will have to pick this up */
- 			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
- 		return;
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-index 77a1d06..bd16a2c 100644
---- a/drivers/scsi/scsi_tgt_priv.h
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -14,9 +14,9 @@ do {								\
- extern void scsi_tgt_if_exit(void);
- extern int scsi_tgt_if_init(void);
- 
--extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
--				u64 tag, gfp_t flags);
--extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
- extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
- 				unsigned long uaddr, u8 rw);
- extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 9422ae5..c256ebe 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,7 +21,6 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
--#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-index 63b2e3a..74392a9 100644
---- a/include/scsi/scsi_tgt_if.h
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -24,25 +24,20 @@
- 
- enum tgt_event_type {
- 	/* user -&gt; kernel */
--	TGT_UEVENT_REQ,
- 	TGT_UEVENT_CMD_RSP,
- 	TGT_UEVENT_TSK_MGMT_RSP,
- 
- 	/* kernel -&gt; user */
--	TGT_KEVENT_RSP,
- 	TGT_KEVENT_CMD_REQ,
- 	TGT_KEVENT_CMD_DONE,
- 	TGT_KEVENT_TSK_MGMT_REQ,
- };
- 
- struct tgt_event {
-+	uint32_t type;
- 	/* user-&gt; kernel */
- 	union {
- 		struct {
--			int type;
--			int host_no;
--		} event_req;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t len;
-@@ -60,9 +55,6 @@ struct tgt_event {
- 	/* kernel -&gt; user */
- 	union {
- 		struct {
--			int err;
--		} event_rsp;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t data_len;
-@@ -86,4 +78,13 @@ struct tgt_event {
- 	} k;
- 
- } __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RINGBUF_SIZE (1UL &lt;&lt; 16)
-+
-+struct rbuf_hdr {
-+	uint32_t status;
-+	uint32_t len;
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
- #endif
--- 
-1.1.3

Deleted: trunk/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,197 +0,0 @@
-Subject: [PATCH] scsi target: kill target command list
-
-scsi_tgt_queue_command just adds a command to the list and then kernel
-thread sends it to user space because scsi_tgt_queue_command cannot
-use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
-
-Now we don't use netlink any more. So we can kill the list and
-scsi_tgt_queue_command just sends a command to user space.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
- 1 files changed, 24 insertions(+), 82 deletions(-)
-
-0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index 7ebfbc0..5c66f10 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
- 	/* TODO replace the lists with a large bio */
- 	struct bio_list xfer_done_list;
- 	struct bio_list xfer_list;
--	struct scsi_lun *lun;
- 
- 	struct list_head hash_list;
- 	struct request *rq;
--	u64 tag;
- 
- 	void *buffer;
- 	unsigned bufflen;
-@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
- 	struct Scsi_Host *shost;
- 	struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
- 	spinlock_t cmd_hash_lock;
--
--	struct work_struct uspace_send_work;
--
--	spinlock_t cmd_req_lock;
--	struct mutex cmd_req_mutex;
--	struct list_head cmd_req;
- };
- 
- /*
-@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
- 	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
- 	rq-&gt;end_io_data = tcmd;
- 
-+	bio_list_init(&amp;tcmd-&gt;xfer_list);
-+	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-+	tcmd-&gt;rq = rq;
-+
- 	return cmd;
- 
- release_rq:
-@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
- 	}
- }
- 
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd-&gt;request-&gt;q;
-+	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-+
-+	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
-+	list_del(&amp;tcmd-&gt;hash_list);
-+	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-+}
-+
- static void scsi_tgt_cmd_destroy(void *data)
- {
- 	struct scsi_cmnd *cmd = data;
- 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
--	struct scsi_tgt_queuedata *qdata = cmd-&gt;request-&gt;q-&gt;queuedata;
--	unsigned long flags;
- 
- 	dprintk(&quot;cmd %p %d %lu\n&quot;, cmd, cmd-&gt;sc_data_direction,
- 		rq_data_dir(cmd-&gt;request));
- 
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
--	list_del(&amp;tcmd-&gt;hash_list);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
-+	cmd_hashlist_del(cmd);
- 
- 	/*
- 	 * We must set rq-&gt;flags here because bio_map_user and
-@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
- 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
- }
- 
--static void scsi_tgt_uspace_send_fn(void *data)
--{
--	struct request_queue *q = data;
--	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--	struct scsi_tgt_cmd *tcmd;
--	unsigned long flags;
--	int err;
--
--retry:
--	err = 0;
--	if (list_empty(&amp;qdata-&gt;cmd_req))
--		return;
--
--	mutex_lock(&amp;qdata-&gt;cmd_req_mutex);
--
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--	if (list_empty(&amp;qdata-&gt;cmd_req)) {
--		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--		mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
--		goto out;
--	}
--	rq = list_entry_rq(qdata-&gt;cmd_req.next);
--	list_del_init(&amp;rq-&gt;queuelist);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--
--	tcmd = rq-&gt;end_io_data;
--	init_scsi_tgt_cmd(rq, tcmd);
--	cmd = rq-&gt;special;
--	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
--	if (err &lt; 0) {
--		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
--
--		spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--		list_add(&amp;rq-&gt;queuelist, &amp;qdata-&gt;cmd_req);
--		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
--	}
--
--	mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
--out:
--	/* TODO: proper error handling */
--	if (err &lt; 0)
--		queue_delayed_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work,
--				   HZ / 10);
--	else
--		goto retry;
--}
--
- /*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
- 		INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_hash[i]);
- 	spin_lock_init(&amp;queuedata-&gt;cmd_hash_lock);
- 
--	INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_req);
--	spin_lock_init(&amp;queuedata-&gt;cmd_req_lock);
--	INIT_WORK(&amp;queuedata-&gt;uspace_send_work, scsi_tgt_uspace_send_fn, q);
--	mutex_init(&amp;queuedata-&gt;cmd_req_mutex);
--
- 	return 0;
- 
- cleanup_queue:
-@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-- * @noblock:	set to nonzero if the command should be queued
-+ * @tag:	unique value to identify this command for tmf
-  */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
--	struct request_queue *q = cmd-&gt;request-&gt;q;
--	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
--	unsigned long flags;
- 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
-+	int err;
- 
--	bio_list_init(&amp;tcmd-&gt;xfer_list);
--	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
--	tcmd-&gt;lun = scsilun;
--	tcmd-&gt;tag = tag;
--	tcmd-&gt;rq = cmd-&gt;request;
--
--	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
--	list_add_tail(&amp;cmd-&gt;request-&gt;queuelist, &amp;qdata-&gt;cmd_req);
--	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
-+	init_scsi_tgt_cmd(cmd-&gt;request, tcmd);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
- 
--	queue_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work);
--	return 0;
-+	return err;
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
- 
--- 
-1.1.3

Added: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,787 @@
+From 74646b3cdc53f2f8bee28d5d5533b08ef93253c2 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:42:16 +0900
+Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
+
+The core scsi target lib functions.
+
+TODO:
+- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
+do that weird include.
+- convert scsi_tgt_cmd's work struct to James's execute code. And try
+to kill our scsi_tgt_cmd.
+- add host state checking. We do refcouting so hotplug is partially
+supported, but we need to add state checking to make it easier on
+the LLD.
+- must remove our request-&gt;flags hack
+
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ drivers/scsi/scsi_tgt_lib.c  |  699 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   24 +
+ include/scsi/scsi_tgt.h      |   17 +
+ 3 files changed, 740 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..f7ae7e2
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,699 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include &lt;linux/blkdev.h&gt;
++#include &lt;linux/hash.h&gt;
++#include &lt;linux/module.h&gt;
++#include &lt;linux/pagemap.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_device.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;../drivers/md/dm-bio-list.h&gt;
++
++#include &quot;scsi_tgt_priv.h&quot;
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++
++	struct list_head hash_list;
++	struct request *rq;
++	u64 tag;
++
++	void *buffer;
++	unsigned bufflen;
++	unsigned offset; /* we need this ? */
++};
++
++#define TGT_HASH_ORDER	4
++#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++	struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
++	spinlock_t cmd_hash_lock;
++};
++
++/*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&amp;shost-&gt;shost_gendev))
++		return NULL;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		goto put_dev;
++
++	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto free_tcmd;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd-&gt;sc_data_direction = data_dir;
++	cmd-&gt;jiffies_at_alloc = jiffies;
++	cmd-&gt;request = rq;
++
++	rq-&gt;special = cmd;
++	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++	rq-&gt;end_io_data = tcmd;
++
++	bio_list_init(&amp;tcmd-&gt;xfer_list);
++	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
++	tcmd-&gt;rq = rq;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++free_tcmd:
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++put_dev:
++	put_device(&amp;shost-&gt;shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++static void scsi_host_put_command(struct Scsi_Host *shost,
++				  struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost-&gt;uspace_req_q;
++	struct request *rq = cmd-&gt;request;
++	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
++	unsigned long flags;
++
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++
++	spin_lock_irqsave(q-&gt;queue_lock, flags);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
++
++	__scsi_put_command(shost, cmd, &amp;shost-&gt;shost_gendev);
++}
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_done_list))) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list))) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void cmd_hashlist_del(struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = cmd-&gt;request-&gt;q;
++	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
++	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
++	list_del(&amp;tcmd-&gt;hash_list);
++	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	dprintk(&quot;cmd %p %d %lu\n&quot;, cmd, cmd-&gt;sc_data_direction,
++		rq_data_dir(cmd-&gt;request));
++
++	cmd_hashlist_del(cmd);
++
++	/*
++	 * We must set rq-&gt;flags here because bio_map_user and
++	 * blk_rq_bio_prep ruined ti.
++	 */
++	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
++		cmd-&gt;request-&gt;flags |= 1;
++	else
++		cmd-&gt;request-&gt;flags &amp;= ~1UL;
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
++			      u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = rq-&gt;q-&gt;queuedata;
++	unsigned long flags;
++	struct list_head *head;
++
++	tcmd-&gt;tag = tag;
++	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
++	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(tag)];
++	list_add(&amp;tcmd-&gt;hash_list, head);
++	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
++}
++
++/*
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ */
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err, i;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, NULL);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata-&gt;shost = shost;
++	q-&gt;queuedata = queuedata;
++
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q-&gt;nr_requests = shost-&gt;hostt-&gt;can_queue;
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost-&gt;uspace_req_q = q;
++
++	for (i = 0; i &lt; ARRAY_SIZE(queuedata-&gt;cmd_hash); i++)
++		INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_hash[i]);
++	spin_lock_init(&amp;queuedata-&gt;cmd_hash_lock);
++
++	return 0;
++
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd-&gt;request-&gt;q-&gt;queuedata;
++	return queue-&gt;shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/*
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @tag:	unique value to identify this command for tmf
++ */
++int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			   u64 tag)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++	int err;
++
++	init_scsi_tgt_cmd(cmd-&gt;request, tcmd, tag);
++	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
++	if (err)
++		cmd_hashlist_del(cmd);
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
++
++	scsi_tgt_uspace_send_status(cmd, tcmd-&gt;tag);
++	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
++
++	err = shost-&gt;hostt-&gt;transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
++	err = scsi_tgt_uspace_send_status(cmd, tcmd-&gt;tag);
++	if (err &lt;= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd-&gt;request;
++	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
++	int count;
++
++	cmd-&gt;use_sg = rq-&gt;nr_phys_segments;
++	cmd-&gt;request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd-&gt;request_buffer)
++		return -ENOMEM;
++
++	cmd-&gt;request_bufflen = rq-&gt;data_len;
++
++	dprintk(&quot;cmd %p addr %p cnt %d %lu\n&quot;, cmd, tcmd-&gt;buffer, cmd-&gt;use_sg,
++		rq_data_dir(rq));
++	count = blk_rq_map_sg(rq-&gt;q, rq, cmd-&gt;request_buffer);
++	if (likely(count &lt;= cmd-&gt;use_sg)) {
++		cmd-&gt;use_sg = count;
++		return 0;
++	}
++
++	eprintk(&quot;cmd %p addr %p cnt %d\n&quot;, cmd, tcmd-&gt;buffer, cmd-&gt;use_sg);
++	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd-&gt;request-&gt;q;
++	struct request *rq = cmd-&gt;request;
++	void *uaddr = tcmd-&gt;buffer;
++	unsigned int len = tcmd-&gt;bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len &gt; 0) {
++		dprintk(&quot;%lx %u\n&quot;, (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk(&quot;fail to map %lx %u %d %x\n&quot;,
++				(unsigned long) uaddr, len, err, cmd-&gt;cmnd[0]);
++			goto unmap_bios;
++		}
++
++		uaddr += bio-&gt;bi_size;
++		len -= bio-&gt;bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq-&gt;bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq-&gt;data_len = bio-&gt;bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&amp;tcmd-&gt;xfer_list, bio);
++	}
++
++	tcmd-&gt;offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq-&gt;bio) {
++		bio_unmap_user(rq-&gt;bio);
++		while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd-&gt;result) {
++send_uspace_err:
++		err = scsi_tgt_uspace_send_status(cmd, tcmd-&gt;tag);
++		if (err &lt;= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
++		return;
++	}
++
++	dprintk(&quot;cmd %p request_bufflen %u bufflen %u\n&quot;,
++		cmd, cmd-&gt;request_bufflen, tcmd-&gt;bufflen);
++
++	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
++	bio_list_add(&amp;tcmd-&gt;xfer_done_list, cmd-&gt;request-&gt;bio);
++
++	tcmd-&gt;buffer += cmd-&gt;request_bufflen;
++	tcmd-&gt;offset += cmd-&gt;request_bufflen;
++
++	if (!tcmd-&gt;xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk(&quot;cmd2 %p request_bufflen %u bufflen %u\n&quot;,
++		cmd, cmd-&gt;request_bufflen, tcmd-&gt;bufflen);
++
++	bio = bio_list_pop(&amp;tcmd-&gt;xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd-&gt;request-&gt;q, cmd-&gt;request, bio);
++	cmd-&gt;request-&gt;data_len = bio-&gt;bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd-&gt;result = DID_ERROR &lt;&lt; 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host-&gt;hostt-&gt;transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd-&gt;sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR &quot;Could not copy the sense buffer\n&quot;);
++		return -EIO;
++	}
++	return 0;
++}
++
++static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = host-&gt;hostt-&gt;eh_abort_handler(cmd);
++	if (err)
++		eprintk(&quot;fail to abort %p\n&quot;, cmd);
++
++	scsi_tgt_cmd_destroy(cmd);
++	return err;
++}
++
++static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
++	struct request *rq = NULL;
++	struct list_head *head;
++	struct scsi_tgt_cmd *tcmd;
++	unsigned long flags;
++
++	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(tag)];
++	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
++	list_for_each_entry(tcmd, head, hash_list) {
++		if (tcmd-&gt;tag == tag) {
++			rq = tcmd-&gt;rq;
++			break;
++		}
++	}
++	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
++
++	return rq;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++			 unsigned long uaddr, u8 rw)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	struct scsi_tgt_cmd *tcmd;
++	int err = 0;
++
++	dprintk(&quot;%d %llu %d %u %lx %u\n&quot;, host_no, (unsigned long long) tag,
++		result, len, uaddr, rw);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
++		return -EINVAL;
++	}
++
++	rq = tgt_cmd_hash_lookup(shost-&gt;uspace_req_q, tag);
++	if (!rq) {
++		printk(KERN_ERR &quot;Could not find tag %llu\n&quot;,
++		       (unsigned long long) tag);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq-&gt;special;
++
++	dprintk(&quot;cmd %p result %d len %d bufflen %u %lu %x\n&quot;, cmd,
++		result, len, cmd-&gt;request_bufflen, rq_data_dir(rq), cmd-&gt;cmnd[0]);
++
++	if (result == TASK_ABORTED) {
++		scsi_tgt_abort_cmd(shost, cmd);
++		goto done;
++	}
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	tcmd = cmd-&gt;request-&gt;end_io_data;
++	tcmd-&gt;buffer = (void *)uaddr;
++	tcmd-&gt;bufflen = len;
++	cmd-&gt;result = result;
++
++	if (!tcmd-&gt;bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq-&gt;end_io_data, cmd, rw);
++	if (err) {
++		eprintk(&quot;%p %d\n&quot;, cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd-&gt;result) {
++		if (status_byte(cmd-&gt;result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
++			      struct scsi_lun *scsilun, void *data)
++{
++	int err;
++
++	/* TODO: need to retry if this fails. */
++	err = scsi_tgt_uspace_send_tsk_mgmt(shost-&gt;host_no, function,
++					    tag, scsilun, data);
++	if (err &lt; 0)
++		eprintk(&quot;The task management request lost!\n&quot;);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
++
++int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
++{
++	struct Scsi_Host *shost;
++	int err;
++
++	dprintk(&quot;%d %d %llx\n&quot;, host_no, result, (unsigned long long) mid);
++
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
++		return -EINVAL;
++	}
++	err = shost-&gt;hostt-&gt;tsk_mgmt_response(mid, result);
++	scsi_host_put(shost);
++
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create(&quot;scsi_tgt_cmd&quot;,
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue(&quot;scsi_tgtd&quot;);
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION(&quot;SCSI target core&quot;);
++MODULE_LICENSE(&quot;GPL&quot;);
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..b7b6ea6
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,24 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define dprintk eprintk
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				    u64 tag);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
++extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++				unsigned long uaddr, u8 rw);
++extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++					 struct scsi_lun *scsilun, void *data);
++extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..61e8ee9
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,17 @@
++/*
++ * SCSI target definitions
++ */
++
++#include &lt;linux/dma-mapping.h&gt;
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
+-- 
+1.4.1.1
+

Added: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,481 @@
+From c4e930538407cf31b2eb9f718685cd07e4070569 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:44:21 +0900
+Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
+
+The user-space damoen and tgt kernel module need to exhange mmapped
+addresses. netlink cannot do that. We need two-way kernel/user
+high-performance interface, however, mainline kernel provides no
+standard interface like that.
+
+This patch addes shared memory interface between kernel and user
+spaces like some other drivers do. The user-space damoen and tgt
+kernel module creates shared memory via mmap and use it like ring
+buffer. poll (kernel to user) and write (user to kernel) system calls
+are used for notification.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+---
+ drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/scsi_tgt_if.h |   93 ++++++++++++
+ 2 files changed, 443 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..09c4ab1
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,350 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include &lt;linux/miscdevice.h&gt;
++#include &lt;linux/file.h&gt;
++#include &lt;net/tcp.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_device.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;scsi/scsi_tgt_if.h&gt;
++
++#include &quot;scsi_tgt_priv.h&quot;
++
++struct tgt_ring {
++	u32 tr_idx;
++	unsigned long tr_pages[TGT_RING_PAGES];
++	spinlock_t tr_lock;
++};
++
++/* tx_ring : kernel-&gt;user, rx_ring : user-&gt;kernel */
++static struct tgt_ring tx_ring, rx_ring;
++static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
++
++static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
++{
++	if (ring-&gt;tr_idx == TGT_MAX_EVENTS - 1)
++		ring-&gt;tr_idx = 0;
++	else
++		ring-&gt;tr_idx++;
++}
++
++static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
++{
++	u32 pidx, off;
++
++	pidx = idx / TGT_EVENT_PER_PAGE;
++	off = idx % TGT_EVENT_PER_PAGE;
++
++	return (struct tgt_event *)
++		(ring-&gt;tr_pages[pidx] + sizeof(struct tgt_event) * off);
++}
++
++static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &amp;tx_ring;
++	unsigned long flags;
++	int err = 0;
++
++	spin_lock_irqsave(&amp;ring-&gt;tr_lock, flags);
++
++	ev = tgt_head_event(ring, ring-&gt;tr_idx);
++	if (ev-&gt;status == TGT_EVENT_STATUS_EMPTY)
++		tgt_ring_idx_inc(ring);
++	else
++		err = -BUSY;
++
++	spin_unlock_irqrestore(&amp;ring-&gt;tr_lock, flags);
++
++	if (err)
++		return err;
++
++	memcpy(ev, p, sizeof(*ev));
++	ev-&gt;type = type;
++	ev-&gt;status = TGT_EVENT_STATUS_USED;
++	mb();
++
++	flush_dcache_page(virt_to_page(ev));
++
++	wake_up_interruptible(&amp;tgt_poll_wait);
++
++	return 0;
++}
++
++int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.cmd_req.host_no = shost-&gt;host_no;
++	ev.k.cmd_req.data_len = cmd-&gt;request_bufflen;
++	memcpy(ev.k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev.k.cmd_req.scb));
++	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
++	ev.k.cmd_req.attribute = cmd-&gt;tag;
++	ev.k.cmd_req.tag = tag;
++
++	dprintk(&quot;%p %d %u %x %llx\n&quot;, cmd, shost-&gt;host_no,
++		ev.k.cmd_req.data_len, cmd-&gt;tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost-&gt;host_no;
++	ev.k.cmd_done.tag = tag;
++	ev.k.cmd_done.result = cmd-&gt;result;
++
++	dprintk(&quot;%p %d %llu %u %x\n&quot;, cmd, shost-&gt;host_no,
++		(unsigned long long) ev.k.cmd_req.tag,
++		ev.k.cmd_req.data_len, cmd-&gt;tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++				  struct scsi_lun *scsilun, void *data)
++{
++	struct tgt_event ev;
++	int err;
++
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.tsk_mgmt_req.host_no = host_no;
++	ev.k.tsk_mgmt_req.function = function;
++	ev.k.tsk_mgmt_req.tag = tag;
++	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
++	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
++
++	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
++		(unsigned long long) ev.k.tsk_mgmt_req.mid);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
++
++	return err;
++}
++
++static int event_recv_msg(struct tgt_event *ev)
++{
++	int err = 0;
++
++	switch (ev-&gt;type) {
++	case TGT_UEVENT_CMD_RSP:
++		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_rsp.host_no,
++					   ev-&gt;u.cmd_rsp.tag,
++					   ev-&gt;u.cmd_rsp.result,
++					   ev-&gt;u.cmd_rsp.len,
++					   ev-&gt;u.cmd_rsp.uaddr,
++					   ev-&gt;u.cmd_rsp.rw);
++		break;
++	case TGT_UEVENT_TSK_MGMT_RSP:
++		err = scsi_tgt_kspace_tsk_mgmt(ev-&gt;u.tsk_mgmt_rsp.host_no,
++					       ev-&gt;u.tsk_mgmt_rsp.mid,
++					       ev-&gt;u.tsk_mgmt_rsp.result);
++		break;
++	default:
++		eprintk(&quot;unknown type %d\n&quot;, ev-&gt;type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static ssize_t tgt_write(struct file *file, const char __user * buffer,
++			 size_t count, loff_t * ppos)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &amp;rx_ring;
++
++	while (1) {
++		ev = tgt_head_event(ring, ring-&gt;tr_idx);
++		if (ev-&gt;status == TGT_EVENT_STATUS_EMPTY)
++			break;
++
++		/* do we need this? */
++		flush_dcache_page(virt_to_page(ev));
++
++		tgt_ring_idx_inc(ring);
++		ev-&gt;status = TGT_EVENT_STATUS_EMPTY;
++		event_recv_msg(ev);
++	};
++
++	return count;
++}
++
++static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &amp;tx_ring;
++	unsigned long flags;
++	unsigned int mask = 0;
++	u32 idx;
++
++	poll_wait(file, &amp;tgt_poll_wait, wait);
++
++	spin_lock_irqsave(&amp;ring-&gt;tr_lock, flags);
++
++	idx = ring-&gt;tr_idx ? ring-&gt;tr_idx - 1 : TGT_MAX_EVENTS - 1;
++	ev = tgt_head_event(ring, idx);
++	if (ev-&gt;status == TGT_EVENT_STATUS_USED)
++		mask |= POLLIN | POLLRDNORM;
++
++	spin_unlock_irqrestore(&amp;ring-&gt;tr_lock, flags);
++
++	return mask;
++}
++
++static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
++			   struct tgt_ring *ring)
++{
++	int i, err;
++
++	for (i = 0; i &lt; TGT_RING_PAGES; i++) {
++		struct page *page = virt_to_page(ring-&gt;tr_pages[i]);
++		err = vm_insert_page(vma, addr, page);
++		if (err)
++			return err;
++		addr += PAGE_SIZE;
++	}
++
++	return 0;
++}
++
++static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	unsigned long addr;
++	int err;
++
++	if (vma-&gt;vm_pgoff)
++		return -EINVAL;
++
++	if (vma-&gt;vm_end - vma-&gt;vm_start != TGT_RING_SIZE * 2) {
++		eprintk(&quot;mmap size must be %lu, not %lu \n&quot;,
++			TGT_RING_SIZE * 2, vma-&gt;vm_end - vma-&gt;vm_start);
++		return -EINVAL;
++	}
++
++	addr = vma-&gt;vm_start;
++	err = uspace_ring_map(vma, addr, &amp;tx_ring);
++	if (err)
++		return err;
++	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &amp;rx_ring);
++
++	return err;
++}
++
++static int tgt_open(struct inode *inode, struct file *file)
++{
++	tx_ring.tr_idx = rx_ring.tr_idx = 0;
++
++	return 0;
++}
++
++static struct file_operations tgt_fops = {
++	.owner		= THIS_MODULE,
++	.open		= tgt_open,
++	.poll		= tgt_poll,
++	.write		= tgt_write,
++	.mmap		= tgt_mmap,
++};
++
++static struct miscdevice tgt_miscdev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = &quot;tgt&quot;,
++	.fops = &amp;tgt_fops,
++};
++
++static void tgt_ring_exit(struct tgt_ring *ring)
++{
++	int i;
++
++	for (i = 0; i &lt; TGT_RING_PAGES; i++)
++		free_page(ring-&gt;tr_pages[i]);
++}
++
++static int tgt_ring_init(struct tgt_ring *ring)
++{
++	int i;
++
++	spin_lock_init(&amp;ring-&gt;tr_lock);
++
++	for (i = 0; i &lt; TGT_RING_PAGES; i++) {
++		ring-&gt;tr_pages[i] = get_zeroed_page(GFP_KERNEL);
++		if (!ring-&gt;tr_pages[i]) {
++			eprintk(&quot;out of memory\n&quot;);
++			return -ENOMEM;
++		}
++	}
++
++	return 0;
++}
++
++void scsi_tgt_if_exit(void)
++{
++	tgt_ring_exit(&amp;tx_ring);
++	tgt_ring_exit(&amp;rx_ring);
++	misc_deregister(&amp;tgt_miscdev);
++}
++
++int scsi_tgt_if_init(void)
++{
++	int err;
++
++	err = tgt_ring_init(&amp;tx_ring);
++	if (err)
++		return err;
++
++	err = tgt_ring_init(&amp;rx_ring);
++	if (err)
++		goto free_tx_ring;
++
++	err = misc_register(&amp;tgt_miscdev);
++	if (err)
++		goto free_rx_ring;
++
++	return 0;
++free_rx_ring:
++	tgt_ring_exit(&amp;rx_ring);
++free_tx_ring:
++	tgt_ring_exit(&amp;tx_ring);
++
++	return err;
++}
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..5671920
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,93 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_status {
++	TGT_EVENT_STATUS_EMPTY = 0,
++	TGT_EVENT_STATUS_USED,
++};
++
++enum tgt_event_type {
++	/* user -&gt; kernel */
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
++
++	/* kernel -&gt; user */
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
++};
++
++struct tgt_event {
++	uint32_t status;
++	uint32_t type;
++
++	/* user-&gt; kernel */
++	union {
++		struct {
++			int host_no;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint8_t rw;
++			uint64_t tag;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			uint64_t mid;
++			int result;
++		} tsk_mgmt_rsp;
++	} u;
++
++	/* kernel -&gt; user */
++	union {
++		struct {
++			int host_no;
++			uint32_t data_len;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
++			uint64_t tag;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint64_t tag;
++			int result;
++		} cmd_done;
++		struct {
++			int host_no;
++			int function;
++			uint64_t tag;
++			uint8_t lun[8];
++			uint64_t mid;
++		} tsk_mgmt_req;
++	} k;
++
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#define TGT_RING_SIZE (1UL &lt;&lt; 16)
++#define TGT_RING_PAGES (TGT_RING_SIZE &gt;&gt; PAGE_SHIFT)
++#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
++#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
++
++#endif
+-- 
+1.4.1.1
+

Added: trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
===================================================================
--- trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,57 @@
+From fff20a33841c7ab473dea824b4c52e2b9a9c8edc Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:48:43 +0900
+Subject: [PATCH 7/9] scsi tgt: scsi target netlink interface
+
+Makefile and Kconfig stuff.
+
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ drivers/scsi/Kconfig  |    7 +++++++
+ drivers/scsi/Makefile |    3 +++
+ 2 files changed, 10 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 96a81cd..566626c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate &quot;SCSI target support&quot;
++	depends on SCSI &amp;&amp; EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool &quot;legacy /proc/scsi/ support&quot;
+ 	depends on SCSI &amp;&amp; PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ebd0cf0..ede0c45 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+-- 
+1.4.1.1
+

Added: trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,595 @@
+From dca0bd3d8d7bc4493a11c3897e69d0187513c5b4 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:50:32 +0900
+Subject: [PATCH 8/9] scsi tgt: SRP library functions
+
+libsrp provides helper functions for SRP target drivers.
+
+The next step would be to add initiator support to merge the two SRP
+initiator drivers (ibmvscsi and ib_srp) in mainline.
+
+Some SRP target drivers would be out of drivers/scsi/ so I added an
+entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
+it.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ drivers/scsi/Kconfig  |    9 +
+ drivers/scsi/Makefile |    1 
+ drivers/scsi/libsrp.c |  449 +++++++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/libsrp.h |   75 ++++++++
+ 4 files changed, 534 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 566626c..e5098d3 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -1846,6 +1846,15 @@ config ZFCP
+           called zfcp. If you want to compile it as a module, say M here
+           and read &lt;file:Documentation/modules.txt&gt;.
+ 
++config SCSI_SRP
++	tristate &quot;SCSI RDMA Protocol helper library&quot;
++	depends on SCSI
++	help
++	  If you wish to use SRP target drivers, say Y.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called libsrp.
++
+ endmenu
+ 
+ source &quot;drivers/scsi/pcmcia/Kconfig&quot;
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ede0c45..d71bb59 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
+ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
+ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
++obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
+new file mode 100644
+index 0000000..b8a7c3d
+--- /dev/null
++++ b/drivers/scsi/libsrp.c
+@@ -0,0 +1,449 @@
++/*
++ * SCSI RDAM Protocol lib functions
++ *
++ * Copyright (C) 2006 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include &lt;linux/err.h&gt;
++#include &lt;linux/kfifo.h&gt;
++#include &lt;linux/scatterlist.h&gt;
++#include &lt;linux/dma-mapping.h&gt;
++#include &lt;linux/pci.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_tcq.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;scsi/srp.h&gt;
++#include &lt;scsi/libsrp.h&gt;
++
++enum srp_task_attributes {
++	SRP_SIMPLE_TASK = 0,
++	SRP_HEAD_TASK = 1,
++	SRP_ORDERED_TASK = 2,
++	SRP_ACA_TASK = 4
++};
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
++			     struct srp_buf **ring)
++{
++	int i;
++	struct iu_entry *iue;
++
++	q-&gt;pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
++	if (!q-&gt;pool)
++		return -ENOMEM;
++	q-&gt;items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
++	if (!q-&gt;items)
++		goto free_pool;
++
++	spin_lock_init(&amp;q-&gt;lock);
++	q-&gt;queue = kfifo_init((void *) q-&gt;pool, max * sizeof(void *),
++			      GFP_KERNEL, &amp;q-&gt;lock);
++	if (IS_ERR(q-&gt;queue))
++		goto free_item;
++
++	for (i = 0, iue = q-&gt;items; i &lt; max; i++) {
++		__kfifo_put(q-&gt;queue, (void *) &amp;iue, sizeof(void *));
++		iue-&gt;sbuf = ring[i];
++		iue++;
++	}
++	return 0;
++
++free_item:
++	kfree(q-&gt;items);
++free_pool:
++	kfree(q-&gt;pool);
++	return -ENOMEM;
++}
++
++static void srp_iu_pool_free(struct srp_queue *q)
++{
++	kfree(q-&gt;items);
++	kfree(q-&gt;pool);
++}
++
++static struct srp_buf ** srp_ring_alloc(struct device *dev,
++					size_t max, size_t size)
++{
++	int i;
++	struct srp_buf **ring;
++
++	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
++	if (!ring)
++		return NULL;
++
++	for (i = 0; i &lt; max; i++) {
++		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
++		if (!ring[i])
++			goto out;
++		ring[i]-&gt;buf = dma_alloc_coherent(dev, size, &amp;ring[i]-&gt;dma,
++						  GFP_KERNEL);
++		if (!ring[i]-&gt;buf)
++			goto out;
++	}
++	return ring;
++
++out:
++	for (i = 0; i &lt; max &amp;&amp; ring[i]; i++) {
++		if (ring[i]-&gt;buf)
++			dma_free_coherent(dev, size, ring[i]-&gt;buf, ring[i]-&gt;dma);
++		kfree(ring[i]);
++	}
++	kfree(ring);
++
++	return NULL;
++}
++
++static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
++			  size_t size)
++{
++	int i;
++
++	for (i = 0; i &lt; max; i++) {
++		dma_free_coherent(dev, size, ring[i]-&gt;buf, ring[i]-&gt;dma);
++		kfree(ring[i]);
++	}
++}
++
++int srp_target_alloc(struct srp_target *target, struct device *dev,
++		     size_t nr, size_t iu_size)
++{
++	int err;
++
++	spin_lock_init(&amp;target-&gt;lock);
++	INIT_LIST_HEAD(&amp;target-&gt;cmd_queue);
++
++	target-&gt;dev = dev;
++	target-&gt;dev-&gt;driver_data = target;
++
++	target-&gt;srp_iu_size = iu_size;
++	target-&gt;rx_ring_size = nr;
++	target-&gt;rx_ring = srp_ring_alloc(target-&gt;dev, nr, iu_size);
++	if (!target-&gt;rx_ring)
++		return -ENOMEM;
++	err = srp_iu_pool_alloc(&amp;target-&gt;iu_queue, nr, target-&gt;rx_ring);
++	if (err)
++		goto free_ring;
++
++	return 0;
++
++free_ring:
++	srp_ring_free(target-&gt;dev, target-&gt;rx_ring, nr, iu_size);
++	return -ENOMEM;
++}
++EXPORT_SYMBOL_GPL(srp_target_alloc);
++
++void srp_target_free(struct srp_target *target)
++{
++	srp_ring_free(target-&gt;dev, target-&gt;rx_ring, target-&gt;rx_ring_size,
++		      target-&gt;srp_iu_size);
++	srp_iu_pool_free(&amp;target-&gt;iu_queue);
++}
++EXPORT_SYMBOL_GPL(srp_target_free);
++
++struct iu_entry *srp_iu_get(struct srp_target *target)
++{
++	struct iu_entry *iue = NULL;
++
++	kfifo_get(target-&gt;iu_queue.queue, (void *) &amp;iue, sizeof(void *));
++	BUG_ON(!iue);
++
++	iue-&gt;target = target;
++	iue-&gt;scmd = NULL;
++	INIT_LIST_HEAD(&amp;iue-&gt;ilist);
++	iue-&gt;flags = 0;
++	return iue;
++}
++EXPORT_SYMBOL_GPL(srp_iu_get);
++
++void srp_iu_put(struct iu_entry *iue)
++{
++	kfifo_put(iue-&gt;target-&gt;iu_queue.queue, (void *) &amp;iue, sizeof(void *));
++}
++EXPORT_SYMBOL_GPL(srp_iu_put);
++
++static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
++		       enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	struct srp_target *target = iue-&gt;target;
++	struct scatterlist *sg = scmd-&gt;request_buffer;
++	int nsg, err;
++
++	dprintk(&quot;%p %u %u %u %d\n&quot;, iue, scmd-&gt;request_bufflen, scmd-&gt;bufflen,
++		md-&gt;len, scmd-&gt;use_sg);
++
++	nsg = dma_map_sg(target-&gt;dev, sg, scmd-&gt;use_sg, DMA_BIDIRECTIONAL);
++	if (!nsg) {
++		printk(&quot;fail to map %p %d\n&quot;, iue, scmd-&gt;use_sg);
++		return 0;
++	}
++	err = rdma_io(iue, sg, nsg, md, 1, dir,
++		      min(scmd-&gt;request_bufflen, md-&gt;len));
++
++	dma_unmap_sg(target-&gt;dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++	return err;
++}
++
++static int indirect_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			 struct srp_indirect_buf *id,
++			 enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	struct srp_target *target = iue-&gt;target;
++	struct srp_direct_buf *md;
++	struct scatterlist dummy, *sg = scmd-&gt;request_buffer;
++	dma_addr_t token = 0;
++	long err;
++	unsigned int done = 0;
++	int nmd, nsg;
++
++	nmd = id-&gt;table_desc.len / sizeof(struct srp_direct_buf);
++
++	dprintk(&quot;%p %u %u %u %u %d %d %d\n&quot;,
++		iue, scmd-&gt;request_bufflen, scmd-&gt;bufflen,
++		id-&gt;len, scmd-&gt;offset, nmd,
++		cmd-&gt;data_in_desc_cnt, cmd-&gt;data_out_desc_cnt);
++
++	if ((dir == DMA_FROM_DEVICE &amp;&amp; nmd == cmd-&gt;data_in_desc_cnt) ||
++	    (dir == DMA_TO_DEVICE &amp;&amp; nmd == cmd-&gt;data_out_desc_cnt)) {
++		md = &amp;id-&gt;desc_list[0];
++		goto rdma;
++	}
++
++	md = dma_alloc_coherent(target-&gt;dev, id-&gt;table_desc.len,
++				 &amp;token, GFP_KERNEL);
++	if (!md) {
++		eprintk(&quot;Can't get dma memory %u\n&quot;, id-&gt;table_desc.len);
++		return 0;
++	}
++
++	sg_init_one(&amp;dummy, md, id-&gt;table_desc.len);
++	sg_dma_address(&amp;dummy) = token;
++	err = rdma_io(iue, &amp;dummy, 1, &amp;id-&gt;table_desc, 1, DMA_TO_DEVICE,
++		      id-&gt;table_desc.len);
++	if (err &lt; 0) {
++		eprintk(&quot;Error copying indirect table %ld\n&quot;, err);
++		goto free_mem;
++	}
++
++rdma:
++	nsg = dma_map_sg(target-&gt;dev, sg, scmd-&gt;use_sg, DMA_BIDIRECTIONAL);
++	if (!nsg) {
++		eprintk(&quot;fail to map %p %d\n&quot;, iue, scmd-&gt;use_sg);
++		goto free_mem;
++	}
++
++	err = rdma_io(iue, sg, nsg, md, nmd, dir,
++		      min(scmd-&gt;request_bufflen, id-&gt;len));
++	dma_unmap_sg(target-&gt;dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++free_mem:
++	if (token)
++		dma_free_coherent(target-&gt;dev, id-&gt;table_desc.len, md, token);
++
++	return done;
++}
++
++static int data_out_desc_size(struct srp_cmd *cmd)
++{
++	int size = 0;
++	u8 fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		size = sizeof(struct srp_direct_buf);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		size = sizeof(struct srp_indirect_buf) +
++			sizeof(struct srp_direct_buf) * cmd-&gt;data_out_desc_cnt;
++		break;
++	default:
++		eprintk(&quot;client error. Invalid data_out_format %x\n&quot;, fmt);
++		break;
++	}
++	return size;
++}
++
++static int __srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			       enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	int offset, err = 0;
++	u8 format;
++
++	offset = cmd-&gt;add_cdb_len * 4;
++	if (dir == DMA_FROM_DEVICE)
++		offset += data_out_desc_size(cmd);
++
++	if (dir == DMA_TO_DEVICE)
++		format = cmd-&gt;buf_fmt &gt;&gt; 4;
++	else
++		format = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++
++	switch (format) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *)
++			(cmd-&gt;add_data + offset);
++		err = direct_data(scmd, md, dir, rdma_io);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *)
++			(cmd-&gt;add_data + offset);
++		err = indirect_data(scmd, cmd, id, dir, rdma_io);
++		break;
++	default:
++		eprintk(&quot;Unknown format %d %x\n&quot;, dir, format);
++		break;
++	}
++
++	return err;
++}
++
++/* TODO: this can be called multiple times for a single command. */
++int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++		      rdma_io_t rdma_io)
++{
++	struct iu_entry	*iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	enum dma_data_direction dir;
++
++	if (test_bit(V_WRITE, &amp;iue-&gt;flags))
++		dir = DMA_TO_DEVICE;
++	else
++		dir = DMA_FROM_DEVICE;
++	__srp_transfer_data(scmd, cmd, dir, rdma_io);
++	return 0;
++}
++EXPORT_SYMBOL_GPL(srp_transfer_data);
++
++static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	int len = 0, offset = cmd-&gt;add_cdb_len * 4;
++	u8 fmt;
++
++	if (dir == DMA_TO_DEVICE)
++		fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
++	else {
++		fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++		offset += data_out_desc_size(cmd);
++	}
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *) (cmd-&gt;add_data + offset);
++		len = md-&gt;len;
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *) (cmd-&gt;add_data + offset);
++		len = id-&gt;len;
++		break;
++	default:
++		eprintk(&quot;invalid data format %x\n&quot;, fmt);
++		break;
++	}
++	return len;
++}
++
++static uint8_t getcontrolbyte(u8 *cdb)
++{
++	return cdb[COMMAND_SIZE(cdb[0]) - 1];
++}
++
++static inline uint8_t getlink(struct srp_cmd *cmd)
++{
++	return (getcontrolbyte(cmd-&gt;cdb) &amp; 0x01);
++}
++
++int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
++{
++	struct Scsi_Host *shost = iue-&gt;target-&gt;shost;
++	enum dma_data_direction data_dir;
++	struct scsi_cmnd *scmd;
++	int tag, len;
++
++	if (getlink(cmd))
++		__set_bit(V_LINKED, &amp;iue-&gt;flags);
++
++	tag = MSG_SIMPLE_TAG;
++
++	switch (cmd-&gt;task_attr) {
++	case SRP_SIMPLE_TASK:
++		tag = MSG_SIMPLE_TAG;
++		break;
++	case SRP_ORDERED_TASK:
++		tag = MSG_ORDERED_TAG;
++		break;
++	case SRP_HEAD_TASK:
++		tag = MSG_HEAD_TAG;
++		break;
++	default:
++		eprintk(&quot;Task attribute %d not supported\n&quot;, cmd-&gt;task_attr);
++		tag = MSG_ORDERED_TAG;
++	}
++
++	switch (cmd-&gt;cdb[0]) {
++	case WRITE_6:
++	case WRITE_10:
++	case WRITE_VERIFY:
++	case WRITE_12:
++	case WRITE_VERIFY_12:
++		__set_bit(V_WRITE, &amp;iue-&gt;flags);
++	}
++
++	if (cmd-&gt;buf_fmt &gt;&gt; 4)
++		data_dir = DMA_TO_DEVICE;
++	else
++		data_dir = DMA_FROM_DEVICE;
++	len = vscsis_data_length(cmd, data_dir);
++
++	dprintk(&quot;%p %x %lx %d %d %d %llx\n&quot;, iue, cmd-&gt;cdb[0],
++		cmd-&gt;lun, data_dir, len, tag, (unsigned long long) cmd-&gt;tag);
++
++	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
++	BUG_ON(!scmd);
++	scmd-&gt;SCp.ptr = (char *) iue;
++	memcpy(scmd-&gt;cmnd, cmd-&gt;cdb, MAX_COMMAND_SIZE);
++	scmd-&gt;request_bufflen = len;
++	scmd-&gt;tag = tag;
++	iue-&gt;scmd = scmd;
++	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &amp;cmd-&gt;lun, cmd-&gt;tag);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(srp_cmd_perform);
++
++MODULE_DESCRIPTION(&quot;SCSI RDAM Protocol lib functions&quot;);
++MODULE_AUTHOR(&quot;FUJITA Tomonori&quot;);
++MODULE_LICENSE(&quot;GPL&quot;);
+diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
+new file mode 100644
+index 0000000..9dd10ff
+--- /dev/null
++++ b/include/scsi/libsrp.h
+@@ -0,0 +1,75 @@
++#ifndef __LIBSRP_H__
++#define __LIBSRP_H__
++
++#include &lt;linux/list.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/srp.h&gt;
++
++enum iue_flags {
++	V_DIOVER,
++	V_WRITE,
++	V_LINKED,
++	V_FLYING,
++};
++
++struct srp_buf {
++	dma_addr_t dma;
++	void *buf;
++};
++
++struct srp_queue {
++	void *pool;
++	void *items;
++	struct kfifo *queue;
++	spinlock_t lock;
++};
++
++struct srp_target {
++	struct Scsi_Host *shost;
++	struct device *dev;
++
++	spinlock_t lock;
++	struct list_head cmd_queue;
++
++	size_t srp_iu_size;
++	struct srp_queue iu_queue;
++	size_t rx_ring_size;
++	struct srp_buf **rx_ring;
++
++	/* IB needs tx_ring too */
++
++	void *ldata;
++};
++
++struct iu_entry {
++	struct srp_target *target;
++	struct scsi_cmnd *scmd;
++
++	struct list_head ilist;
++	dma_addr_t remote_token;
++	unsigned long flags;
++
++	struct srp_buf *sbuf;
++};
++
++typedef int (rdma_io_t) (struct iu_entry *, struct scatterlist *, int,
++			 struct srp_direct_buf *, int,
++			 enum dma_data_direction, unsigned int);
++
++static inline struct srp_target *host_to_target(struct Scsi_Host *host)
++{
++	return (struct srp_target *) host-&gt;hostdata;
++}
++
++extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
++extern void srp_target_free(struct srp_target *);
++
++extern struct iu_entry *srp_iu_get(struct srp_target *);
++extern void srp_iu_put(struct iu_entry *);
++
++extern int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd);
++extern int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			     rdma_io_t rdma_io);
++
++#endif
+-- 
+1.4.1.1
+

Added: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,1023 @@
+From 49997b6ea087c515fad787cb90637e03a44f396f Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: Thu, 17 Aug 2006 08:51:51 +0900
+Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries Virtual SCSI Target Driver
+
+This is IBM Virtual SCSI target driver for tgt.
+
+This patch dependents on the previous patch to convert the ibmvscsi
+driver to use include/scsi/srp.h.
+
+The driver is based on the original ibmvscsis driver:
+
+<A HREF="http://lkml.org/lkml/2005/10/17/99">http://lkml.org/lkml/2005/10/17/99</A>
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+Signed-off-by: James Bottomley &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">James.Bottomley at SteelEye.com</A>&gt;
+---
+ drivers/scsi/Kconfig             |   14 +
+ drivers/scsi/Makefile            |    1 
+ drivers/scsi/ibmvscsi/Makefile   |    2 
+ drivers/scsi/ibmvscsi/ibmvstgt.c |  943 ++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 960 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index e5098d3..c25154c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ibmvscsic.
+ 
++config SCSI_IBMVSCSIS
++	tristate &quot;IBM Virtual SCSI Server support&quot;
++	depends on PPC_PSERIES &amp;&amp; SCSI_TGT &amp;&amp; SCSI_SRP
++	help
++	  This is the SRP target driver for IBM pSeries virtual environments.
++
++	  The userspace component needed to initialize the driver and
++	  documentation can be found:
++
++	  <A HREF="http://stgt.berlios.de/">http://stgt.berlios.de/</A>
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ibmvstgt.
++
+ config SCSI_INITIO
+ 	tristate &quot;Initio 9100U(W) support&quot;
+ 	depends on PCI &amp;&amp; SCSI
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index d71bb59..78544e3 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
+ obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+ obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
+diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
+index 4e247b6..6ac0633 100644
+--- a/drivers/scsi/ibmvscsi/Makefile
++++ b/drivers/scsi/ibmvscsi/Makefile
+@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
+ ibmvscsic-y			+= ibmvscsi.o
+ ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
+ ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
++
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
+diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
+new file mode 100644
+index 0000000..cf1e851
+--- /dev/null
++++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
+@@ -0,0 +1,943 @@
++/*
++ * IBM eServer i/pSeries Virtual SCSI Target Driver
++ * Copyright (C) 2003-2005 Dave Boutcher (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">boutcher at us.ibm.com</A>) IBM Corp.
++ *			   Santiago Leon (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">santil at us.ibm.com</A>) IBM Corp.
++ *			   Linda Xie (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">lxie at us.ibm.com</A>) IBM Corp.
++ *
++ * Copyright (C) 2005-2006 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
++ * USA
++ */
++#include &lt;linux/interrupt.h&gt;
++#include &lt;linux/module.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;scsi/libsrp.h&gt;
++#include &lt;asm/hvcall.h&gt;
++#include &lt;asm/iommu.h&gt;
++#include &lt;asm/prom.h&gt;
++#include &lt;asm/vio.h&gt;
++
++#include &quot;ibmvscsi.h&quot;
++
++#define	INITIAL_SRP_LIMIT	16
++#define	DEFAULT_MAX_SECTORS	512
++
++#define	TGT_NAME	&quot;ibmvstgt&quot;
++
++/*
++ * Hypervisor calls.
++ */
++#define h_copy_rdma(l, sa, sb, da, db) \
++			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
++#define h_send_crq(ua, l, h) \
++			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
++#define h_reg_crq(ua, tok, sz)\
++			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
++#define h_free_crq(ua) \
++			plpar_hcall_norets(H_FREE_CRQ, ua);
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++struct vio_port {
++	struct vio_dev *dma_dev;
++
++	struct crq_queue crq_queue;
++	struct work_struct crq_work;
++
++	unsigned long liobn;
++	unsigned long riobn;
++};
++
++static struct workqueue_struct *vtgtd;
++
++/*
++ * These are fixed for the system and come from the Open Firmware device tree.
++ * We just store them here to save getting them every time.
++ */
++static char system_id[64] = &quot;&quot;;
++static char partition_name[97] = &quot;UNKNOWN&quot;;
++static unsigned int partition_number = -1;
++
++static struct vio_port *target_to_port(struct srp_target *target)
++{
++	return (struct vio_port *) target-&gt;ldata;
++}
++
++static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
++{
++	return (union viosrp_iu *) (iue-&gt;sbuf-&gt;buf);
++}
++
++static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
++{
++	struct srp_target *target = iue-&gt;target;
++	struct vio_port *vport = target_to_port(target);
++	long rc, rc1;
++	union {
++		struct viosrp_crq cooked;
++		uint64_t raw[2];
++	} crq;
++
++	/* First copy the SRP */
++	rc = h_copy_rdma(length, vport-&gt;liobn, iue-&gt;sbuf-&gt;dma,
++			 vport-&gt;riobn, iue-&gt;remote_token);
++
++	if (rc)
++		eprintk(&quot;Error %ld transferring data\n&quot;, rc);
++
++	crq.cooked.valid = 0x80;
++	crq.cooked.format = format;
++	crq.cooked.reserved = 0x00;
++	crq.cooked.timeout = 0x00;
++	crq.cooked.IU_length = length;
++	crq.cooked.IU_data_ptr = vio_iu(iue)-&gt;srp.rsp.tag;
++
++	if (rc == 0)
++		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
++	else
++		crq.cooked.status = 0x00;
++
++	rc1 = h_send_crq(vport-&gt;dma_dev-&gt;unit_address, crq.raw[0], crq.raw[1]);
++
++	if (rc1) {
++		eprintk(&quot;%ld sending response\n&quot;, rc1);
++		return rc1;
++	}
++
++	return rc;
++}
++
++#define SRP_RSP_SENSE_DATA_LEN	18
++
++static int send_rsp(struct iu_entry *iue, unsigned char status,
++		    unsigned char asc)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	uint64_t tag = iu-&gt;srp.rsp.tag;
++
++	/* If the linked bit is on and status is good */
++	if (test_bit(V_LINKED, &amp;iue-&gt;flags) &amp;&amp; (status == NO_SENSE))
++		status = 0x10;
++
++	memset(iu, 0, sizeof(struct srp_rsp));
++	iu-&gt;srp.rsp.opcode = SRP_RSP;
++	iu-&gt;srp.rsp.req_lim_delta = 1;
++	iu-&gt;srp.rsp.tag = tag;
++
++	if (test_bit(V_DIOVER, &amp;iue-&gt;flags))
++		iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
++
++	iu-&gt;srp.rsp.data_in_res_cnt = 0;
++	iu-&gt;srp.rsp.data_out_res_cnt = 0;
++
++	iu-&gt;srp.rsp.flags &amp;= ~SRP_RSP_FLAG_RSPVALID;
++
++	iu-&gt;srp.rsp.resp_data_len = 0;
++	iu-&gt;srp.rsp.status = status;
++	if (status) {
++		uint8_t *sense = iu-&gt;srp.rsp.data;
++
++		if (iue-&gt;scmd) {
++			iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu-&gt;srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
++			memcpy(sense, iue-&gt;scmd-&gt;sense_buffer,
++			       SCSI_SENSE_BUFFERSIZE);
++		} else {
++			iu-&gt;srp.rsp.status = SAM_STAT_CHECK_CONDITION;
++			iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu-&gt;srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
++
++			/* Valid bit and 'current errors' */
++			sense[0] = (0x1 &lt;&lt; 7 | 0x70);
++			/* Sense key */
++			sense[2] = status;
++			/* Additional sense length */
++			sense[7] = 0xa;	/* 10 bytes */
++			/* Additional sense code */
++			sense[12] = asc;
++		}
++	}
++
++	send_iu(iue, sizeof(iu-&gt;srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
++		VIOSRP_SRP_FORMAT);
++
++	return 0;
++}
++
++static void handle_cmd_queue(struct srp_target *target)
++{
++	struct iu_entry *iue;
++	unsigned long flags;
++
++retry:
++	spin_lock_irqsave(&amp;target-&gt;lock, flags);
++
++	list_for_each_entry(iue, &amp;target-&gt;cmd_queue, ilist) {
++		if (!test_and_set_bit(V_FLYING, &amp;iue-&gt;flags)) {
++			spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
++			srp_cmd_perform(iue, (struct srp_cmd *) iue-&gt;sbuf-&gt;buf);
++			goto retry;
++		}
++	}
++
++	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
++}
++
++static int ibmvstgt_rdma(struct iu_entry *iue, struct scatterlist *sg, int nsg,
++			 struct srp_direct_buf *md, int nmd,
++			 enum dma_data_direction dir, unsigned int rest)
++{
++	struct srp_target *target = iue-&gt;target;
++	struct vio_port *vport = target_to_port(target);
++	dma_addr_t token;
++	long err;
++	unsigned int done = 0;
++	int i, sidx, soff;
++
++	sidx = soff = 0;
++	token = sg_dma_address(sg + sidx);
++
++	for (i = 0; i &lt; nmd &amp;&amp; rest; i++) {
++		unsigned int mdone, mlen;
++
++		mlen = min(rest, md[i].len);
++		for (mdone = 0; mlen;) {
++			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
++
++			if (dir == DMA_TO_DEVICE)
++				err = h_copy_rdma(slen,
++						  vport-&gt;riobn,
++						  md[i].va + mdone,
++						  vport-&gt;liobn,
++						  token + soff);
++			else
++				err = h_copy_rdma(slen,
++						  vport-&gt;liobn,
++						  token + soff,
++						  vport-&gt;riobn,
++						  md[i].va + mdone);
++
++			if (err != H_SUCCESS) {
++				eprintk(&quot;rdma error %d %d\n&quot;, dir, slen);
++				goto out;
++			}
++
++			mlen -= slen;
++			mdone += slen;
++			soff += slen;
++			done += slen;
++
++			if (soff == sg_dma_len(sg + sidx)) {
++				sidx++;
++				soff = 0;
++				token = sg_dma_address(sg + sidx);
++
++				if (sidx &gt; nsg) {
++					eprintk(&quot;out of sg %p %d %d\n&quot;,
++						iue, sidx, nsg);
++					goto out;
++				}
++			}
++		};
++
++		rest -= mlen;
++	}
++out:
++
++	return 0;
++}
++
++static int ibmvstgt_transfer_data(struct scsi_cmnd *scmd,
++				  void (*done)(struct scsi_cmnd *))
++{
++	struct iu_entry	*iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	int err;
++
++	err = srp_transfer_data(scmd, &amp;vio_iu(iue)-&gt;srp.cmd, ibmvstgt_rdma);
++	done(scmd);
++
++	return err;
++}
++
++static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
++			     void (*done)(struct scsi_cmnd *))
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	struct srp_target *target = iue-&gt;target;
++
++	dprintk(&quot;%p %p %x\n&quot;, iue, target, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&amp;target-&gt;lock, flags);
++	list_del(&amp;iue-&gt;ilist);
++	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
++
++	if (scmd-&gt;result != SAM_STAT_GOOD) {
++		eprintk(&quot;operation failed %p %d %x\n&quot;,
++			iue, scmd-&gt;result, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
++		send_rsp(iue, HARDWARE_ERROR, 0x00);
++	} else
++		send_rsp(iue, NO_SENSE, 0x00);
++
++	done(scmd);
++	srp_iu_put(iue);
++	return 0;
++}
++
++int send_adapter_info(struct iu_entry *iue,
++		      dma_addr_t remote_buffer, uint16_t length)
++{
++	struct srp_target *target = iue-&gt;target;
++	struct vio_port *vport = target_to_port(target);
++	struct Scsi_Host *shost = target-&gt;shost;
++	dma_addr_t data_token;
++	struct mad_adapter_info_data *info;
++	int err;
++
++	info = dma_alloc_coherent(target-&gt;dev, sizeof(*info), &amp;data_token,
++				  GFP_KERNEL);
++	if (!info) {
++		eprintk(&quot;bad dma_alloc_coherent %p\n&quot;, target);
++		return 1;
++	}
++
++	/* Get remote info */
++	err = h_copy_rdma(sizeof(*info), vport-&gt;riobn, remote_buffer,
++			  vport-&gt;liobn, data_token);
++	if (err == H_SUCCESS) {
++		dprintk(&quot;Client connect: %s (%d)\n&quot;,
++			info-&gt;partition_name, info-&gt;partition_number);
++	}
++
++	memset(info, 0, sizeof(*info));
++
++	strcpy(info-&gt;srp_version, &quot;16.a&quot;);
++	strncpy(info-&gt;partition_name, partition_name,
++		sizeof(info-&gt;partition_name));
++	info-&gt;partition_number = partition_number;
++	info-&gt;mad_version = 1;
++	info-&gt;os_type = 2;
++	info-&gt;port_max_txu[0] = shost-&gt;hostt-&gt;max_sectors &lt;&lt; 9;
++
++	/* Send our info to remote */
++	err = h_copy_rdma(sizeof(*info), vport-&gt;liobn, data_token,
++			  vport-&gt;riobn, remote_buffer);
++
++	dma_free_coherent(target-&gt;dev, sizeof(*info), info, data_token);
++
++	if (err != H_SUCCESS) {
++		eprintk(&quot;Error sending adapter info %d\n&quot;, err);
++		return 1;
++	}
++
++	return 0;
++}
++
++static void process_login(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct srp_login_rsp *rsp = &amp;iu-&gt;srp.login_rsp;
++	uint64_t tag = iu-&gt;srp.rsp.tag;
++
++	/* TODO handle case that requested size is wrong and
++	 * buffer format is wrong
++	 */
++	memset(iu, 0, sizeof(struct srp_login_rsp));
++	rsp-&gt;opcode = SRP_LOGIN_RSP;
++	rsp-&gt;req_lim_delta = INITIAL_SRP_LIMIT;
++	rsp-&gt;tag = tag;
++	rsp-&gt;max_it_iu_len = sizeof(union srp_iu);
++	rsp-&gt;max_ti_iu_len = sizeof(union srp_iu);
++	/* direct and indirect */
++	rsp-&gt;buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
++
++	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
++}
++
++static inline void queue_cmd(struct iu_entry *iue)
++{
++	struct srp_target *target = iue-&gt;target;
++	unsigned long flags;
++
++	spin_lock_irqsave(&amp;target-&gt;lock, flags);
++	list_add_tail(&amp;iue-&gt;ilist, &amp;target-&gt;cmd_queue);
++	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
++}
++
++static int process_tsk_mgmt(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int fn;
++
++	dprintk(&quot;%p %u\n&quot;, iue, iu-&gt;srp.tsk_mgmt.tsk_mgmt_func);
++
++	switch (iu-&gt;srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		fn = ABORT_TASK;
++		break;
++	case SRP_TSK_ABORT_TASK_SET:
++		fn = ABORT_TASK_SET;
++		break;
++	case SRP_TSK_CLEAR_TASK_SET:
++		fn = CLEAR_TASK_SET;
++		break;
++	case SRP_TSK_LUN_RESET:
++		fn = LOGICAL_UNIT_RESET;
++		break;
++	case SRP_TSK_CLEAR_ACA:
++		fn = CLEAR_ACA;
++		break;
++	default:
++		fn = 0;
++	}
++	if (fn)
++		scsi_tgt_tsk_mgmt_request(iue-&gt;target-&gt;shost, fn,
++					  iu-&gt;srp.tsk_mgmt.task_tag,
++					  (struct scsi_lun *) &amp;iu-&gt;srp.tsk_mgmt.lun,
++					  iue);
++	else
++		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
++
++	return !fn;
++}
++
++static int process_mad_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct viosrp_adapter_info *info;
++	struct viosrp_host_config *conf;
++
++	switch (iu-&gt;mad.empty_iu.common.type) {
++	case VIOSRP_EMPTY_IU_TYPE:
++		eprintk(&quot;%s\n&quot;, &quot;Unsupported EMPTY MAD IU&quot;);
++		break;
++	case VIOSRP_ERROR_LOG_TYPE:
++		eprintk(&quot;%s\n&quot;, &quot;Unsupported ERROR LOG MAD IU&quot;);
++		iu-&gt;mad.error_log.common.status = 1;
++		send_iu(iue, sizeof(iu-&gt;mad.error_log),	VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_ADAPTER_INFO_TYPE:
++		info = &amp;iu-&gt;mad.adapter_info;
++		info-&gt;common.status = send_adapter_info(iue, info-&gt;buffer,
++							info-&gt;common.length);
++		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_HOST_CONFIG_TYPE:
++		conf = &amp;iu-&gt;mad.host_config;
++		conf-&gt;common.status = 1;
++		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
++		break;
++	default:
++		eprintk(&quot;Unknown type %u\n&quot;, iu-&gt;srp.rsp.opcode);
++	}
++
++	return 1;
++}
++
++static int process_srp_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int done = 1;
++	u8 opcode = iu-&gt;srp.rsp.opcode;
++
++	switch (opcode) {
++	case SRP_LOGIN_REQ:
++		process_login(iue);
++		break;
++	case SRP_TSK_MGMT:
++		done = process_tsk_mgmt(iue);
++		break;
++	case SRP_CMD:
++		queue_cmd(iue);
++		done = 0;
++		break;
++	case SRP_LOGIN_RSP:
++	case SRP_I_LOGOUT:
++	case SRP_T_LOGOUT:
++	case SRP_RSP:
++	case SRP_CRED_REQ:
++	case SRP_CRED_RSP:
++	case SRP_AER_REQ:
++	case SRP_AER_RSP:
++		eprintk(&quot;Unsupported type %u\n&quot;, opcode);
++		break;
++	default:
++		eprintk(&quot;Unknown type %u\n&quot;, opcode);
++	}
++
++	return done;
++}
++
++static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct iu_entry *iue;
++	long err, done;
++
++	iue = srp_iu_get(target);
++	if (!iue) {
++		eprintk(&quot;Error getting IU from pool, %p\n&quot;, target);
++		return;
++	}
++
++	iue-&gt;remote_token = crq-&gt;IU_data_ptr;
++
++	err = h_copy_rdma(crq-&gt;IU_length, vport-&gt;riobn,
++			  iue-&gt;remote_token, vport-&gt;liobn, iue-&gt;sbuf-&gt;dma);
++
++	if (err != H_SUCCESS)
++		eprintk(&quot;%ld transferring data error %p\n&quot;, err, iue);
++
++	if (crq-&gt;format == VIOSRP_MAD_FORMAT)
++		done = process_mad_iu(iue);
++	else
++		done = process_srp_iu(iue);
++
++	if (done)
++		srp_iu_put(iue);
++}
++
++static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++
++	vio_disable_interrupts(vport-&gt;dma_dev);
++	queue_work(vtgtd, &amp;vport-&gt;crq_work);
++
++	return IRQ_HANDLED;
++}
++
++static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
++{
++	int err;
++	struct vio_port *vport = target_to_port(target);
++
++	queue-&gt;msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
++	if (!queue-&gt;msgs)
++		goto malloc_failed;
++	queue-&gt;size = PAGE_SIZE / sizeof(*queue-&gt;msgs);
++
++	queue-&gt;msg_token = dma_map_single(target-&gt;dev, queue-&gt;msgs,
++					  queue-&gt;size * sizeof(*queue-&gt;msgs),
++					  DMA_BIDIRECTIONAL);
++
++	if (dma_mapping_error(queue-&gt;msg_token))
++		goto map_failed;
++
++	err = h_reg_crq(vport-&gt;dma_dev-&gt;unit_address, queue-&gt;msg_token,
++			PAGE_SIZE);
++
++	/* If the adapter was left active for some reason (like kexec)
++	 * try freeing and re-registering
++	 */
++	if (err == H_RESOURCE) {
++	    do {
++		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
++	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	    err = h_reg_crq(vport-&gt;dma_dev-&gt;unit_address, queue-&gt;msg_token,
++			    PAGE_SIZE);
++	}
++
++	if (err != H_SUCCESS &amp;&amp; err != 2) {
++		eprintk(&quot;Error 0x%x opening virtual adapter\n&quot;, err);
++		goto reg_crq_failed;
++	}
++
++	err = request_irq(vport-&gt;dma_dev-&gt;irq, &amp;ibmvstgt_interrupt,
++			  SA_INTERRUPT, &quot;ibmvstgt&quot;, target);
++	if (err)
++		goto req_irq_failed;
++
++	vio_enable_interrupts(vport-&gt;dma_dev);
++
++	h_send_crq(vport-&gt;dma_dev-&gt;unit_address, 0xC001000000000000, 0);
++
++	queue-&gt;cur = 0;
++	spin_lock_init(&amp;queue-&gt;lock);
++
++	return 0;
++
++req_irq_failed:
++	do {
++		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++reg_crq_failed:
++	dma_unmap_single(target-&gt;dev, queue-&gt;msg_token,
++			 queue-&gt;size * sizeof(*queue-&gt;msgs), DMA_BIDIRECTIONAL);
++map_failed:
++	free_page((unsigned long) queue-&gt;msgs);
++
++malloc_failed:
++	return -ENOMEM;
++}
++
++static void crq_queue_destroy(struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct crq_queue *queue = &amp;vport-&gt;crq_queue;
++	int err;
++
++	free_irq(vport-&gt;dma_dev-&gt;irq, target);
++	do {
++		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	dma_unmap_single(target-&gt;dev, queue-&gt;msg_token,
++			 queue-&gt;size * sizeof(*queue-&gt;msgs), DMA_BIDIRECTIONAL);
++
++	free_page((unsigned long) queue-&gt;msgs);
++}
++
++static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	dprintk(&quot;%x %x\n&quot;, crq-&gt;valid, crq-&gt;format);
++
++	switch (crq-&gt;valid) {
++	case 0xC0:
++		/* initialization */
++		switch (crq-&gt;format) {
++		case 0x01:
++			h_send_crq(vport-&gt;dma_dev-&gt;unit_address,
++				   0xC002000000000000, 0);
++			break;
++		case 0x02:
++			break;
++		default:
++			eprintk(&quot;Unknown format %u\n&quot;, crq-&gt;format);
++		}
++		break;
++	case 0xFF:
++		/* transport event */
++		break;
++	case 0x80:
++		/* real payload */
++		switch (crq-&gt;format) {
++		case VIOSRP_SRP_FORMAT:
++		case VIOSRP_MAD_FORMAT:
++			process_iu(crq, target);
++			break;
++		case VIOSRP_OS400_FORMAT:
++		case VIOSRP_AIX_FORMAT:
++		case VIOSRP_LINUX_FORMAT:
++		case VIOSRP_INLINE_FORMAT:
++			eprintk(&quot;Unsupported format %u\n&quot;, crq-&gt;format);
++			break;
++		default:
++			eprintk(&quot;Unknown format %u\n&quot;, crq-&gt;format);
++		}
++		break;
++	default:
++		eprintk(&quot;unknown message type 0x%02x!?\n&quot;, crq-&gt;valid);
++	}
++}
++
++static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
++{
++	struct viosrp_crq *crq;
++	unsigned long flags;
++
++	spin_lock_irqsave(&amp;queue-&gt;lock, flags);
++	crq = &amp;queue-&gt;msgs[queue-&gt;cur];
++	if (crq-&gt;valid &amp; 0x80) {
++		if (++queue-&gt;cur == queue-&gt;size)
++			queue-&gt;cur = 0;
++	} else
++		crq = NULL;
++	spin_unlock_irqrestore(&amp;queue-&gt;lock, flags);
++
++	return crq;
++}
++
++static void handle_crq(void *data)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++	struct viosrp_crq *crq;
++	int done = 0;
++
++	while (!done) {
++		while ((crq = next_crq(&amp;vport-&gt;crq_queue)) != NULL) {
++			process_crq(crq, target);
++			crq-&gt;valid = 0x00;
++		}
++
++		vio_enable_interrupts(vport-&gt;dma_dev);
++
++		crq = next_crq(&amp;vport-&gt;crq_queue);
++		if (crq) {
++			vio_disable_interrupts(vport-&gt;dma_dev);
++			process_crq(crq, target);
++			crq-&gt;valid = 0x00;
++		} else
++			done = 1;
++	}
++
++	handle_cmd_queue(target);
++}
++
++
++static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
++	struct srp_target *target = iue-&gt;target;
++
++	dprintk(&quot;%p %p %x\n&quot;, iue, target, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&amp;target-&gt;lock, flags);
++	list_del(&amp;iue-&gt;ilist);
++	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
++
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
++{
++	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
++	union viosrp_iu *iu = vio_iu(iue);
++	unsigned char status, asc;
++
++	eprintk(&quot;%p %d\n&quot;, iue, result);
++	status = NO_SENSE;
++	asc = 0;
++
++	switch (iu-&gt;srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		asc = 0x14;
++		if (result)
++			status = ABORTED_COMMAND;
++		break;
++	default:
++		break;
++	}
++
++	send_rsp(iue, status, asc);
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static ssize_t system_id_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, system_id);
++}
++
++static ssize_t partition_number_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, &quot;%x\n&quot;, partition_number);
++}
++
++static ssize_t unit_address_show(struct class_device *cdev, char *buf)
++{
++	struct Scsi_Host *shost = class_to_shost(cdev);
++	struct srp_target *target = host_to_target(shost);
++	struct vio_port *vport = target_to_port(target);
++	return snprintf(buf, PAGE_SIZE, &quot;%x\n&quot;, vport-&gt;dma_dev-&gt;unit_address);
++}
++
++static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
++static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
++static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
++
++static struct class_device_attribute *ibmvstgt_attrs[] = {
++	&amp;class_device_attr_system_id,
++	&amp;class_device_attr_partition_number,
++	&amp;class_device_attr_unit_address,
++	NULL,
++};
++
++static struct scsi_host_template ibmvstgt_sht = {
++	.name			= TGT_NAME,
++	.module			= THIS_MODULE,
++	.can_queue		= INITIAL_SRP_LIMIT,
++	.sg_tablesize		= SG_ALL,
++	.use_clustering		= DISABLE_CLUSTERING,
++	.max_sectors		= DEFAULT_MAX_SECTORS,
++	.transfer_response	= ibmvstgt_cmd_done,
++	.transfer_data		= ibmvstgt_transfer_data,
++	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
++	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
++	.shost_attrs		= ibmvstgt_attrs,
++	.proc_name		= TGT_NAME,
++};
++
++static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
++{
++	struct Scsi_Host *shost;
++	struct srp_target *target;
++	struct vio_port *vport;
++	unsigned int *dma, dma_size;
++	int err = -ENOMEM;
++
++	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
++	if (!vport)
++		return err;
++	shost = scsi_host_alloc(&amp;ibmvstgt_sht, sizeof(struct srp_target));
++	if (!shost)
++		goto free_vport;
++	err = scsi_tgt_alloc_queue(shost);
++	if (err)
++		goto put_host;
++
++	target = host_to_target(shost);
++	target-&gt;shost = shost;
++	vport-&gt;dma_dev = dev;
++	target-&gt;ldata = vport;
++	err = srp_target_alloc(target, &amp;dev-&gt;dev, INITIAL_SRP_LIMIT,
++			       SRP_MAX_IU_LEN);
++	if (err)
++		goto put_host;
++
++	dma = (unsigned int *) vio_get_attribute(dev, &quot;ibm,my-dma-window&quot;,
++						 &amp;dma_size);
++	if (!dma || dma_size != 40) {
++		eprintk(&quot;Couldn't get window property %d\n&quot;, dma_size);
++		err = -EIO;
++		goto free_srp_target;
++	}
++	vport-&gt;liobn = dma[0];
++	vport-&gt;riobn = dma[5];
++
++	INIT_WORK(&amp;vport-&gt;crq_work, handle_crq, target);
++
++	err = crq_queue_create(&amp;vport-&gt;crq_queue, target);
++	if (err)
++		goto free_srp_target;
++
++	err = scsi_add_host(shost, target-&gt;dev);
++	if (err)
++		goto destroy_queue;
++	return 0;
++
++destroy_queue:
++	crq_queue_destroy(target);
++free_srp_target:
++	srp_target_free(target);
++put_host:
++	scsi_host_put(shost);
++free_vport:
++	kfree(vport);
++	return err;
++}
++
++static int ibmvstgt_remove(struct vio_dev *dev)
++{
++	struct srp_target *target = (struct srp_target *) dev-&gt;dev.driver_data;
++	struct Scsi_Host *shost = target-&gt;shost;
++
++	srp_target_free(target);
++	crq_queue_destroy(target);
++	scsi_remove_host(shost);
++	scsi_host_put(shost);
++	return 0;
++}
++
++static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
++	{&quot;v-scsi-host&quot;, &quot;IBM,v-scsi-host&quot;},
++	{&quot;&quot;,&quot;&quot;}
++};
++
++MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
++
++static struct vio_driver ibmvstgt_driver = {
++	.id_table = ibmvstgt_device_table,
++	.probe = ibmvstgt_probe,
++	.remove = ibmvstgt_remove,
++	.driver = {
++		.name = &quot;ibmvscsi&quot;,
++		.owner = THIS_MODULE,
++	}
++};
++
++static int get_system_info(void)
++{
++	struct device_node *rootdn;
++	char *id, *model, *name;
++	unsigned int *num;
++
++	rootdn = find_path_device(&quot;/&quot;);
++	if (!rootdn)
++		return -ENOENT;
++
++	model = get_property(rootdn, &quot;model&quot;, NULL);
++	id = get_property(rootdn, &quot;system-id&quot;, NULL);
++	if (model &amp;&amp; id)
++		snprintf(system_id, sizeof(system_id), &quot;%s-%s&quot;, model, id);
++
++	name = get_property(rootdn, &quot;ibm,partition-name&quot;, NULL);
++	if (name)
++		strncpy(partition_name, name, sizeof(partition_name));
++
++	num = (unsigned int *) get_property(rootdn, &quot;ibm,partition-no&quot;, NULL);
++	if (num)
++		partition_number = *num;
++
++	return 0;
++}
++
++static int ibmvstgt_init(void)
++{
++	int err = -ENOMEM;
++
++	printk(&quot;IBM eServer i/pSeries Virtual SCSI Target Driver\n&quot;);
++
++	vtgtd = create_workqueue(&quot;ibmvtgtd&quot;);
++	if (!vtgtd)
++		return err;
++
++	err = get_system_info();
++	if (err)
++		goto destroy_wq;
++
++	err = vio_register_driver(&amp;ibmvstgt_driver);
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(vtgtd);
++	return err;
++}
++
++static void ibmvstgt_exit(void)
++{
++	printk(&quot;Unregister IBM virtual SCSI driver\n&quot;);
++
++	destroy_workqueue(vtgtd);
++	vio_unregister_driver(&amp;ibmvstgt_driver);
++}
++
++MODULE_DESCRIPTION(&quot;IBM Virtual SCSI Target&quot;);
++MODULE_AUTHOR(&quot;Dave Boutcher&quot;);
++MODULE_LICENSE(&quot;GPL&quot;);
++
++module_init(ibmvstgt_init);
++module_exit(ibmvstgt_exit);
+-- 
+1.4.1.1
+

Modified: trunk/patchset/README
===================================================================
--- trunk/patchset/README	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/README	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,7 +1,6 @@
-This patchset for scsi-target git tree:
+This patchset for scsi-rc-fixes git tree:
 
-<A HREF="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary</A>
+<A HREF="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-rc-fixes-2.6.git;a=summary">http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-rc-fixes-2.6.git;a=summary</A>
 
-
 Get the tree and apply all the patches. Sorry for the
 inconvenience. We will create our own git tree shortly.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000514.html">[Stgt-svn] r527 - trunk/usr
</A></li>
	<LI>Next message: <A HREF="000516.html">[Stgt-svn] r529 - in trunk/usr: . ibmvio
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#515">[ date ]</a>
              <a href="thread.html#515">[ thread ]</a>
              <a href="subject.html#515">[ subject ]</a>
              <a href="author.html#515">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
