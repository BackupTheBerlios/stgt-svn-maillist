From tomo at berlios.de  Sat Sep  3 03:57:32 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 3 Sep 2005 03:57:32 +0200
Subject: [Stgt-svn] r33 - trunk/usr
Message-ID: <200509030157.j831vWrh019925@sheep.berlios.de>

Author: tomo
Date: 2005-09-03 03:57:30 +0200 (Sat, 03 Sep 2005)
New Revision: 33

Modified:
   trunk/usr/scsi.c
Log:
Forget to close a file descriptor in device_info().

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-08-31 15:48:52 UTC (rev 32)
+++ trunk/usr/scsi.c	2005-09-03 01:57:30 UTC (rev 33)
@@ -67,6 +67,8 @@
 	if (err < 0)
 		return err;
 	*size = strtoull(buf, NULL, 10);
+
+	close(fd);
 	return 0;
 }
 



From tomo at berlios.de  Sat Sep  3 08:47:54 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 3 Sep 2005 08:47:54 +0200
Subject: [Stgt-svn] r34 - in trunk: include kernel usr
Message-ID: <200509030647.j836lstH018424@sheep.berlios.de>

Author: tomo
Date: 2005-09-03 08:47:48 +0200 (Sat, 03 Sep 2005)
New Revision: 34

Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/stgtd.h
Log:
Add error handling support to user-space code.

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/include/stgt_if.h	2005-09-03 06:47:48 UTC (rev 34)
@@ -35,8 +35,8 @@
 		} d_device;
 		struct {
 			uint64_t cid;
-			uint32_t size;
-			int err;
+			uint32_t len;
+			int result;
 		} cmnd_res;
 	} u;
 

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/kernel/stgt.c	2005-09-03 06:47:48 UTC (rev 34)
@@ -767,18 +767,28 @@
 	done(cmnd);
 }
 
-static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data, uint32_t datasize)
+static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data,
+			     int result, uint32_t len)
 {
+	int i;
 	assert(cmnd->done);
 
-	dprintk("%x %u\n", cmnd->scb[0], datasize);
+	dprintk("%x %u\n", cmnd->scb[0], len);
 
-	if (datasize) {
-		__alloc_buffer(cmnd, datasize, 0);
-		/* FIXEM: multiple pages */
-		memcpy(page_address(cmnd->sg[0].page), data, datasize);
+	if (len) {
+		__alloc_buffer(cmnd, len, 0);
+
+		for (i = 0; i < cmnd->sg_count; i++) {
+			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
+			char *p = data;
+
+			memcpy(page_address(cmnd->sg[i].page), p, copy);
+			p += copy;
+			len -= copy;
+		}
 	}
 
+	cmnd->result = result;
 	cmnd_done(cmnd);
 }
 
@@ -922,7 +932,8 @@
 		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
 		if (cmnd)
 			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
-					 ev->u.cmnd_res.size);
+					 ev->u.cmnd_res.result,
+					 ev->u.cmnd_res.len);
 		else {
 			eprintk("cannot found %llu\n", ev->u.cmnd_res.cid);
 			err = -EEXIST;

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/kernel/stgt.h	2005-09-03 06:47:48 UTC (rev 34)
@@ -34,7 +34,7 @@
 	struct scatterlist *sg;
 	uint32_t bufflen;
 
-	uint8_t sense_buffer[SCSI_SENSE_BUFFERSIZE];
+	int result;
 
 	void *private;
 };

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/usr/netlink.c	2005-09-03 06:47:48 UTC (rev 34)
@@ -107,7 +107,7 @@
 
 static int scsi_cmnd_queue(int fd, char *reqbuf, char *resbuf)
 {
-	int size;
+	int result, len;
 	struct iovec iov[2];
 	struct stgt_event *ev = (struct stgt_event *) reqbuf;
 	uint64_t cid = ev->k.cmnd_req.cid;
@@ -117,21 +117,20 @@
 	scb = reqbuf + sizeof(*ev);
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
-	size = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.lun,
-				scb, resbuf);
+	result = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.lun,
+				scb, resbuf, &len);
 
-	/* TODO: error handling */
 	memset(ev, 0, sizeof(*ev));
 	ev->u.cmnd_res.cid = cid;
-	ev->u.cmnd_res.size = size;
-	ev->u.cmnd_res.err = 0;
+	ev->u.cmnd_res.len = len;
+	ev->u.cmnd_res.result = result;
 
 	iov[0].iov_base = ev;
 	iov[0].iov_len = sizeof(*ev);
 	iov[1].iov_base = resbuf;
-	iov[1].iov_len = size;
+	iov[1].iov_len = len;
 
-	return nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, size ? 2 : 1);
+	return nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, len ? 2 : 1);
 }
 
 void nl_event_handle(int fd)

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/usr/scsi.c	2005-09-03 06:47:48 UTC (rev 34)
@@ -34,6 +34,15 @@
 #define SERVICE_ACTION_IN     0x9e
 #endif
 
+/* Additional Sense Code (SAM3) */
+#define	SAM_ASC_LOGICAL_UNIT_NOT_SUPPORTED	0x25
+#define	SAM_ASC_INVALID_FIELD_IN_CDB		0x24
+#define	SAM_ASC_NO_ADDITIONAL_SENSE_INFORMATION	0x00
+
+#define SAM_STAT_GOOD            0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+
+
 static uint32_t blk_shift = 9;
 
 #define min(x,y) ({ \
@@ -72,6 +81,20 @@
 	return 0;
 }
 
+static int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
+		      uint8_t ascode, uint8_t ascodeq)
+{
+	int len = 6;
+
+	data[0] = res_code | 1U << 7;
+	data[2] = key;
+	data[7] = len;
+	data[12] = ascode;
+	data[13] = ascodeq;
+
+	return len;
+}
+
 static int insert_disconnect_pg(uint8_t *ptr)
 {
 	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
@@ -133,20 +156,26 @@
 	return sizeof(geo_m_pg);
 }
 
-static int mode_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
+static int mode_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
-	int len = 4, err = 0;
+	int result = SAM_STAT_GOOD;
 	uint8_t pcode = scb[2] & 0x3f;
 	uint64_t size;
 
-	device_info(tid, lun, &size);
+	if (device_info(tid, lun, &size) < 0) {
+		*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_LOGICAL_UNIT_NOT_SUPPORTED, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	*len = 4;
 	size >>= blk_shift;
 
 	if ((scb[1] & 0x8))
 		data[3] = 0;
 	else {
 		data[3] = 8;
-		len += 8;
+		*len += 8;
 		*(uint32_t *)(data + 4) = (size >> 32) ?
 			cpu_to_be32(0xffffffff) : cpu_to_be32(size);
 		*(uint32_t *)(data + 8) = cpu_to_be32(1 << blk_shift);
@@ -156,51 +185,52 @@
 	case 0x0:
 		break;
 	case 0x2:
-		len += insert_disconnect_pg(data + len);
+		*len += insert_disconnect_pg(data + *len);
 		break;
 	case 0x3:
-		len += insert_format_m_pg(data + len);
+		*len += insert_format_m_pg(data + *len);
 		break;
 	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
+		*len += insert_geo_m_pg(data + *len, size);
 		break;
 	case 0x8:
-		len += insert_caching_pg(data + len);
+		*len += insert_caching_pg(data + *len);
 		break;
 	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
+		*len += insert_ctrl_m_pg(data + *len);
 		break;
 	case 0x1c:
-		len += insert_iec_m_pg(data + len);
+		*len += insert_iec_m_pg(data + *len);
 		break;
 	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
+		*len += insert_disconnect_pg(data + *len);
+		*len += insert_format_m_pg(data + *len);
+		*len += insert_geo_m_pg(data + *len, size);
+		*len += insert_caching_pg(data + *len);
+		*len += insert_ctrl_m_pg(data + *len);
+		*len += insert_iec_m_pg(data + *len);
 		break;
 	default:
-		err = -1;
+		result = SAM_STAT_CHECK_CONDITION;
+		*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_INVALID_FIELD_IN_CDB, 0);
 	}
 
-	data[0] = len - 1;
+	data[0] = *len - 1;
 
-	return len;
+	return result;
 }
 
 #define VENDOR_ID	"IET"
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int inquiry(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
+static int inquiry(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
-	int err = -1;
-	int len = 0;
+	int result = SAM_STAT_CHECK_CONDITION;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		return err;
+		goto err;
 
 	if (!(scb[1] & 0x3)) {
 		data[2] = 4;
@@ -220,15 +250,15 @@
 		data[61] = 0x60;
 		data[62] = 0x03;
 		data[63] = 0x00;
-		len = 64;
-		err = 0;
+		*len = 64;
+		result = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
 		/* We do not support it now. */
 		data[1] = 0x1;
 		data[5] = 0;
-		len = 6;
-		err = 0;
+		*len = 6;
+		result = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
 		if (scb[2] == 0x0) {
@@ -237,14 +267,14 @@
 			data[4] = 0x0;
 			data[5] = 0x80;
 			data[6] = 0x83;
-			len = 7;
-			err = 0;
+			*len = 7;
+			result = SAM_STAT_GOOD;
 		} else if (scb[2] == 0x80) {
 			data[1] = 0x80;
 			data[3] = 4;
 			memset(data + 4, 0x20, 4);
-			len = 8;
-			err = 0;
+			*len = 8;
+			result = SAM_STAT_GOOD;
 		} else if (scb[2] == 0x83) {
 #define SCSI_ID_LEN	24
 			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
@@ -256,20 +286,28 @@
 			data[7] = tmp;
 			if (lun != ~0UL)
 				sprintf(data + 8, "deadbeaf%d:%u", tid, lun);
-			len = tmp + 8;
-			err = 0;
+			*len = tmp + 8;
+			result = SAM_STAT_GOOD;
 		}
 	}
 
-	len = min_t(int, len, scb[4]);
+	if (result != SAM_STAT_GOOD)
+		goto err;
 
+	*len = min_t(int, *len, scb[4]);
+
 	if (lun == ~0UL)
 		data[0] = TYPE_NO_LUN;
 
-	return len;
+	return SAM_STAT_GOOD;
+
+err:
+	*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+				SAM_ASC_INVALID_FIELD_IN_CDB, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p)
+static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t lun;
 	uint32_t *data = (uint32_t *) p;
@@ -277,14 +315,21 @@
 	DIR *dir;
 	struct dirent *ent;
 	char buf[128];
+	int result = SAM_STAT_GOOD;
 
 	dir = opendir("/sys/class/stgt_device");
-	if (!dir)
-		return -1;
+	if (!dir) {
+		perror("can't open /sys/class/stgt_device\n");
+		exit(0);
+	}
 
 	alen = be32_to_cpu(*(uint32_t *)&scb[6]);
-	if (alen < 16)
-		return -1;
+	if (alen < 16) {
+		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_INVALID_FIELD_IN_CDB, 0);
+		result = SAM_STAT_CHECK_CONDITION;
+		goto out;
+	}
 
 	alen &= ~(8 - 1);
 	oalen = alen;
@@ -315,92 +360,114 @@
 	}
 
 	data[0] = cpu_to_be32(nr_luns * 8);
-
+	*len = min(oalen, nr_luns * 8 + 8);
+out:
 	closedir(dir);
-
-	return min(oalen, nr_luns * 8 + 8);
+	return result;
 }
 
-static int read_capacity(int tid, uint32_t lun, uint8_t *scb, uint8_t *p)
+static int read_capacity(int tid, uint32_t lun, uint8_t *scb, uint8_t *p, int *len)
 {
-	int len;
 	uint32_t *data = (uint32_t *) p;
 	uint64_t size;
 
-	device_info(tid, lun, &size);
+	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
+		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_INVALID_FIELD_IN_CDB, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	if (device_info(tid, lun, &size) < 0) {
+		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_LOGICAL_UNIT_NOT_SUPPORTED, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
 	size >>= blk_shift;
 
 	data[0] = (size >> 32) ?
 		cpu_to_be32(0xffffffff) : cpu_to_be32(size - 1);
 	data[1] = cpu_to_be32(1U << blk_shift);
+	*len = 8;
 
-	len = 8;
-
-	return len;
+	return SAM_STAT_GOOD;
 }
 
-static int request_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
+/*
+ * TODO: We always assume autosense.
+ */
+static int request_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int* len)
 {
-	int len;
+	*len = sense_data_build(data, 0xf0, NO_SENSE,
+				SAM_ASC_NO_ADDITIONAL_SENSE_INFORMATION, 0);
 
-	data[0] = 0xf0;
-	data[1] = 0;
-	data[2] = NO_SENSE;
-	data[7] = 10;
-
-	len = 18;
-
-	return len;
+	return SAM_STAT_GOOD;
 }
 
-static int sevice_action(int tid, uint32_t lun, uint8_t *scb, uint8_t *p)
+static int sevice_action(int tid, uint32_t lun, uint8_t *scb, uint8_t *p, int *len)
 {
-	int len;
 	uint32_t *data = (uint32_t *) p;
 	uint64_t *data64, size;
 
-	device_info(tid, lun, &size);
+	if (device_info(tid, lun, &size) < 0) {
+		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+					SAM_ASC_LOGICAL_UNIT_NOT_SUPPORTED, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
 	size >>= blk_shift;
 
 	data64 = (uint64_t *) data;
 	data64[0] = cpu_to_be64(size - 1);
 	data[2] = cpu_to_be32(1UL << blk_shift);
 
-	len = 32;
+	*len = 32;
 
-	return len;
+	return SAM_STAT_GOOD;
 }
 
-int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
+int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
-	int len = 0;
+	int result = SAM_STAT_GOOD;
 
 	dprintf("%x\n", scb[0]);
 
+	if (lun == ~0UL)
+		switch (scb[0]) {
+		case REQUEST_SENSE:
+		case INQUIRY:
+		case REPORT_LUNS:
+			break;
+		default:
+			*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+						SAM_ASC_LOGICAL_UNIT_NOT_SUPPORTED, 0);
+			result = SAM_STAT_CHECK_CONDITION;
+			goto out;
+		}
+
 	switch (scb[0]) {
 	case INQUIRY:
-		len = inquiry(tid, lun, scb, data);
+		result = inquiry(tid, lun, scb, data, len);
 		break;
 	case REPORT_LUNS:
-		len = report_luns(tid, lun, scb, data);
+		result = report_luns(tid, lun, scb, data, len);
 		break;
 	case READ_CAPACITY:
-		len = read_capacity(tid, lun, scb, data);
+		result = read_capacity(tid, lun, scb, data, len);
 		break;
 	case MODE_SENSE:
-		len = mode_sense(tid, lun, scb, data);
+		result = mode_sense(tid, lun, scb, data, len);
 		break;
 	case REQUEST_SENSE:
-		len = request_sense(tid, lun, scb, data);
+		result = request_sense(tid, lun, scb, data, len);
 		break;
 	case SERVICE_ACTION_IN:
-		len = sevice_action(tid, lun, scb, data);
+		result = sevice_action(tid, lun, scb, data, len);
 		break;
 	case START_STOP:
 	case TEST_UNIT_READY:
 	case SYNCHRONIZE_CACHE:
 	case VERIFY:
-		len = 0;
+		*len = 0;
 		break;
 	case READ_6:
 	case READ_10:
@@ -412,10 +479,11 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		dprintf("FIXME: access to nonexistent lun %u\n", lun);
-		len = 0;
+		dprintf("BUG? %u %u\n", scb[0], lun);
+		*len = 0;
 		break;
 	}
 
-	return len;
+out:
+	return result;
 }

Modified: trunk/usr/stgtd.h
===================================================================
--- trunk/usr/stgtd.h	2005-09-03 01:57:30 UTC (rev 33)
+++ trunk/usr/stgtd.h	2005-09-03 06:47:48 UTC (rev 34)
@@ -24,6 +24,7 @@
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-extern int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data);
+extern int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb,
+			     uint8_t *data, int *len);
 
 #endif



From tomo at berlios.de  Sat Sep  3 11:26:49 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 3 Sep 2005 11:26:49 +0200
Subject: [Stgt-svn] r35 - trunk/kernel
Message-ID: <200509030926.j839Qn3J032221@sheep.berlios.de>

Author: tomo
Date: 2005-09-03 11:26:45 +0200 (Sat, 03 Sep 2005)
New Revision: 35

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt_vsd.c
Log:
Add error handling support to stgt core.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 06:47:48 UTC (rev 34)
+++ trunk/kernel/stgt.c	2005-09-03 09:26:45 UTC (rev 35)
@@ -737,8 +737,9 @@
 	struct nlmsghdr *nlh;
 	struct stgt_event *ev;
 	char *pdu;
-	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(cmnd->scb));
+	int len;
 
+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(cmnd->scb));
 	if (!(skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL)))
 		return -ENOMEM;
 
@@ -758,10 +759,11 @@
 	return netlink_unicast(nls, skb, daemon_pid, 0);
 }
 
-static void cmnd_done(struct stgt_cmnd *cmnd)
+static void cmnd_done(struct stgt_cmnd *cmnd, int result)
 {
 	void (*done)(struct stgt_cmnd *);
 
+	cmnd->result = result;
 	done = cmnd->done;
 	cmnd->done = NULL;
 	done(cmnd);
@@ -788,13 +790,58 @@
 		}
 	}
 
-	cmnd->result = result;
-	cmnd_done(cmnd);
+	cmnd_done(cmnd, result);
 }
 
+static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
+			    uint8_t ascode, uint8_t ascodeq)
+{
+	int i, len = 6;
+	char *data;
+
+	/* It works, however, dirty. */
+	for (i = 0; i < cmnd->sg_count; i++)
+		__free_page(cmnd->sg[i].page);
+	kfree(cmnd->sg);
+
+	__alloc_buffer(cmnd, len, 0);
+	data = page_address(cmnd->sg[0].page);
+
+	data[0] = 0xf0 | 1U << 7;
+	data[2] = key;
+	data[7] = len;
+	data[12] = ascode;
+	data[13] = ascodeq;
+
+	return len;
+}
+
+/* TODO: better error handling
+ * We should get ASC and ASCQ from the device code.
+ */
+static uint8_t error_to_sense_key(int err)
+{
+	uint8_t key;
+
+	switch (err) {
+	case -ENOMEM:
+		key = ABORTED_COMMAND;
+		break;
+	case -EOVERFLOW:
+		key = HARDWARE_ERROR;
+		break;
+	default:
+		key = HARDWARE_ERROR;
+		break;
+	}
+
+	return key;
+}
+
 static void queuecommand(void *data)
 {
 	int err;
+	uint8_t key;
 	enum stgt_cmnd_type type = STGT_CMND_USPACE;
 	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
 	struct stgt_target *target = cmnd->session->target;
@@ -802,14 +849,6 @@
 
 	dprintk("%x\n", cmnd->scb[0]);
 
-	/*
-	 * seperate vsd (virtual disk from sd (real sd))
-	 * call scsi_device_temaplte->prepcommand to see if they want it
-	 * and allow them to setup.
-	 *
-	 * Then call queuecommand
-	 */
-
 	/* Should we do this earlier? */
 	device = stgt_device_find(target, cmnd->lun);
 	if (device)
@@ -821,14 +860,30 @@
 	switch (type) {
 	case STGT_CMND_KSPACE:
 		err = device->sdt->queuecommand(device, cmnd);
-		cmnd_done(cmnd);
+		if (err < 0)
+			goto failed_cmnd;
+		else
+			cmnd_done(cmnd, SAM_STAT_GOOD);
 		break;
 	case STGT_CMND_USPACE:
 		err = uspace_cmnd_send(cmnd);
+		if (err < 0)
+			goto failed_cmnd;
 		break;
 	default:
+		eprintk("%u %d\n", cmnd->scb[0], type);
+		assert(0);
 		break;
 	}
+
+	return;
+
+failed_cmnd:
+	eprintk("failed cmnd %llu %u %d %d\n",
+		cmnd->cid, cmnd->scb[0], err, type);
+	key = error_to_sense_key(err);
+	sense_data_build(cmnd, key, 0, 0);
+	cmnd_done(cmnd, SAM_STAT_CHECK_CONDITION);
 }
 
 static uint32_t translate_lun(uint8_t *p, int size)

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-03 06:47:48 UTC (rev 34)
+++ trunk/kernel/stgt_vsd.c	2005-09-03 09:26:45 UTC (rev 35)
@@ -11,6 +11,7 @@
 #include <linux/namei.h>
 #include <linux/uio.h>
 #include <linux/fs.h>
+#include <linux/writeback.h>
 #include <scsi/scsi.h>
 
 #include <stgt.h>
@@ -106,10 +107,8 @@
 	int i;
 
 	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov) {
-		printk("%s %d ENOMEM %d\n", __FUNCTION__, __LINE__, sg_count);
+	if (!iov)
 		return NULL;
-	}
 
 	for (i = 0; i < sg_count; i++) {
 		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
@@ -119,47 +118,72 @@
 	return iov;
 }
 
-static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
+static int vfs_io(struct stgt_device *device, struct stgt_cmnd *cmnd, int rw, int sync)
 {
 	struct stgt_vsd_dev *vsddev = device->sdt_data;
+	struct inode *inode = vsddev->filp->f_dentry->d_inode;
+	ssize_t size;
+	struct iovec *iov;
 	loff_t pos = translate_offset(cmnd->scb);
-	ssize_t size;
-	struct iovec *iov = NULL;
 	int err = 0;
 
+	if (cmnd->bufflen + pos > device->size)
+		return -EOVERFLOW;
+
+	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+	if (!iov)
+		return -ENOMEM;
+
+	if (rw == READ)
+		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
+	else
+		size = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
+
+	kfree(iov);
+
+	if (sync)
+		err = sync_page_range(inode, inode->i_mapping, pos,
+				      (size_t) cmnd->bufflen);
+
+	if ((size != cmnd->bufflen) || err)
+		return -EIO;
+	else
+		return 0;
+}
+
+static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
+{
+	struct stgt_vsd_dev *vsddev = device->sdt_data;
+	struct inode *inode = vsddev->filp->f_dentry->d_inode;
+	int err = 0;
+
 	switch (cmnd->scb[0]) {
 	case READ_6:
 	case READ_10:
 	case READ_16:
-		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
-		if (!iov)
-			goto out;
-		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
-		kfree(iov);
+		err = vfs_io(device, cmnd, READ, 0);
 		break;
 	case WRITE_6:
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
-		if (!iov)
-			goto out;
-		err = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
-		kfree(iov);
+		err = vfs_io(device, cmnd, WRITE, 0);
 		break;
 	case RESERVE:
 	case RELEASE:
 	case RESERVE_10:
 	case RELEASE_10:
 		break;
+	case SYNCHRONIZE_CACHE:
+		err = sync_page_range(inode, inode->i_mapping, 0, device->size);
+		break;
 	default:
 		BUG();
 	}
 
 	if (err < 0)
-		printk("%s %d: %d %llu\n", __FUNCTION__, __LINE__, err, pos);
-out:
-	return 0;
+		printk("%s %d: %x %d\n", __FUNCTION__, __LINE__, cmnd->scb[0], err);
+	return err;
 }
 
 static int stgt_vsd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
@@ -178,6 +202,7 @@
 	case RELEASE:
 	case RESERVE_10:
 	case RELEASE_10:
+	case SYNCHRONIZE_CACHE:
 		type = STGT_CMND_KSPACE;
 		break;
 	default:



From tomo at berlios.de  Sat Sep  3 15:52:33 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 3 Sep 2005 15:52:33 +0200
Subject: [Stgt-svn] r37 - in trunk: kernel usr
Message-ID: <200509031352.j83DqX6N032401@sheep.berlios.de>

Author: tomo
Date: 2005-09-03 15:52:32 +0200 (Sat, 03 Sep 2005)
New Revision: 37

Modified:
   trunk/kernel/stgt.c
   trunk/usr/scsi.c
Log:
Fix sense data bugs.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 10:36:39 UTC (rev 36)
+++ trunk/kernel/stgt.c	2005-09-03 13:52:32 UTC (rev 37)
@@ -796,24 +796,25 @@
 static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq)
 {
-	int i, len = 6;
-	char *data;
+	int i, len = 8, alen = 6;
+	uint8_t *data;
 
 	/* It works, however, dirty. */
 	for (i = 0; i < cmnd->sg_count; i++)
 		__free_page(cmnd->sg[i].page);
 	kfree(cmnd->sg);
 
-	__alloc_buffer(cmnd, len, 0);
+	__alloc_buffer(cmnd, len + alen, 0);
 	data = page_address(cmnd->sg[0].page);
+	clear_page(data);
 
-	data[0] = 0xf0 | 1U << 7;
+	data[0] = 0x70 | 1U << 7;
 	data[2] = key;
-	data[7] = len;
+	data[7] = alen;
 	data[12] = ascode;
 	data[13] = ascodeq;
 
-	return len;
+	return len + alen;
 }
 
 /* TODO: better error handling

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-03 10:36:39 UTC (rev 36)
+++ trunk/usr/scsi.c	2005-09-03 13:52:32 UTC (rev 37)
@@ -86,7 +86,7 @@
 	data[12] = ascode;
 	data[13] = ascodeq;
 
-	return len;
+	return len + 8;
 }
 
 static int insert_disconnect_pg(uint8_t *ptr)
@@ -157,7 +157,7 @@
 	uint64_t size;
 
 	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 					0x25, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
@@ -206,7 +206,7 @@
 		break;
 	default:
 		result = SAM_STAT_CHECK_CONDITION;
-		*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
 	}
 
@@ -296,7 +296,7 @@
 	return SAM_STAT_GOOD;
 
 err:
-	*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 				0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
@@ -319,7 +319,7 @@
 
 	alen = be32_to_cpu(*(uint32_t *)&scb[6]);
 	if (alen < 16) {
-		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
 		result = SAM_STAT_CHECK_CONDITION;
 		goto out;
@@ -366,13 +366,13 @@
 	uint64_t size;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x25, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
@@ -392,7 +392,7 @@
  */
 static int request_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int* len)
 {
-	*len = sense_data_build(data, 0xf0, NO_SENSE, 0, 0);
+	*len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
 
 	return SAM_STAT_GOOD;
 }
@@ -403,7 +403,7 @@
 	uint64_t *data64, size;
 
 	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(p, 0xf0, ILLEGAL_REQUEST,
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x25, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
@@ -431,7 +431,7 @@
 		case REPORT_LUNS:
 			break;
 		default:
-			*len = sense_data_build(data, 0xf0, ILLEGAL_REQUEST,
+			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 						0x25, 0);
 			result = SAM_STAT_CHECK_CONDITION;
 			goto out;



From tomo at berlios.de  Sat Sep  3 15:54:12 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 3 Sep 2005 15:54:12 +0200
Subject: [Stgt-svn] r38 - trunk/iscsi/kernel
Message-ID: <200509031354.j83DsCcD032549@sheep.berlios.de>

Author: tomo
Date: 2005-09-03 15:54:11 +0200 (Sat, 03 Sep 2005)
New Revision: 38

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/nthread.c
Log:
IET can use stgt sense data properly.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-03 13:52:32 UTC (rev 37)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-03 13:54:11 UTC (rev 38)
@@ -256,53 +256,82 @@
 	iscsi_cmnd_init_write(rsp);
 }
 
-static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
-					   u8 sense_key, u8 asc, u8 ascq)
+struct iscsi_sense_data {
+	u16 length;
+	u8  data[0];
+} __packed;
+
+static struct iscsi_cmnd *do_create_sense_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-/* 	struct iscsi_scsi_rsp_hdr *rsp_hdr; */
-/* 	struct tio *tio; */
-/* 	struct iscsi_sense_data *sense; */
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct iscsi_sense_data *sense;
+	struct scatterlist *sg = req->stc->sg;
 
-	rsp = NULL;
-	assert(0);
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-/* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-/* 	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs; */
-/* 	rsp_hdr->opcode = ISCSI_OP_SCSI_RSP; */
-/* 	rsp_hdr->flags = ISCSI_FLG_FINAL; */
-/* 	rsp_hdr->response = ISCSI_RESPONSE_COMMAND_COMPLETED; */
-/* 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION; */
-/* 	rsp_hdr->itt = cmnd_hdr(req)->itt; */
+	sense = (struct iscsi_sense_data *) page_address(sg[0].page);
+	memmove(sense->data, sense, req->stc->bufflen);
+	sense->length = cpu_to_be16(req->stc->bufflen);
 
-/* 	tio = rsp->tio = tio_alloc(1); */
-/* 	sense = (struct iscsi_sense_data *) page_address(tio->pvec[0]); */
-/* 	assert(sense); */
-/* 	clear_page(sense); */
-/* 	sense->length = cpu_to_be16(14); */
-/* 	sense->data[0] = 0xf0; */
-/* 	sense->data[2] = sense_key; */
-/* 	sense->data[7] = 6;	// Additional sense length */
-/* 	sense->data[12] = asc; */
-/* 	sense->data[13] = ascq; */
+	req->stc->bufflen += sizeof(struct iscsi_sense_data);
+	sg->length = req->stc->bufflen;
+	rsp->pdu.datasize = sg->length;
+	rsp->sg = sg;
 
-/* 	rsp->pdu.datasize = sizeof(struct iscsi_sense_data) + 14; */
-/* 	tio->size = (rsp->pdu.datasize + 3) & -4; */
-/* 	tio->offset = 0; */
-
 	return rsp;
 }
 
-void send_data_rsp(struct iscsi_cmnd *req, int (*func)(struct iscsi_cmnd *))
+static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
+					   u8 sense_key, u8 asc, u8 ascq)
 {
 	struct iscsi_cmnd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct iscsi_sense_data *sense;
+	struct scatterlist *sg;
 
-	if (func(req) < 0) {
-		rsp = create_sense_rsp(req, ILLEGAL_REQUEST, 0x24, 0x0);
-		iscsi_cmnd_init_write(rsp);
-	} else
-		do_send_data_rsp(req);
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr->itt = cmnd_hdr(req)->itt;
+
+	assert(req->stc);
+	assert(!req->stc->sg);
+
+	/* TODO: really needs cleanups. */
+	req->stc->bufflen = sizeof(struct iscsi_sense_data) + 14;
+	req->stc->sg_count = 1;
+	req->stc->sg = sg =
+		kmalloc(sizeof(struct scatterlist *), __GFP_NOFAIL | GFP_KERNEL);
+
+	sg->page = alloc_page(__GFP_NOFAIL | GFP_KERNEL);
+	sg->offset = 0;
+	sg->length = req->stc->bufflen;
+
+	sense = (struct iscsi_sense_data *) page_address(sg[0].page);
+	clear_page(sense);
+	sense->length = cpu_to_be16(14);
+	sense->data[0] = 0xf0;
+	sense->data[2] = sense_key;
+	sense->data[7] = 6;	// Additional sense length
+	sense->data[12] = asc;
+	sense->data[13] = ascq;
+
+	rsp->pdu.datasize = sizeof(struct iscsi_sense_data) + 14;
+	rsp->sg = sg;
+
+	return rsp;
 }
 
 /**
@@ -680,6 +709,15 @@
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) stc->private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
+	if (stc->result != SAM_STAT_GOOD) {
+		struct iscsi_cmnd *rsp;
+
+		eprintk("%p %d %x\n", stc, stc->result, stc->scb[0]);
+		rsp = do_create_sense_rsp(cmnd);
+		iscsi_cmnd_init_write(rsp);
+		return;
+	}
+
 	switch (req->cdb[0]) {
 	case INQUIRY:
 	case REPORT_LUNS:
@@ -1225,7 +1263,6 @@
 
 	size = (cmnd->pdu.datasize + 3) & -4;
 	assert(cmnd->sg);
-/* 	assert(tio->size == size); */
 	__cmnd_send_pdu(conn, cmnd->sg, 0, size);
 }
 

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-03 13:52:32 UTC (rev 37)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-03 13:54:11 UTC (rev 38)
@@ -206,7 +206,6 @@
 extern void cmnd_tx_start(struct iscsi_cmnd *);
 extern void cmnd_tx_end(struct iscsi_cmnd *);
 extern void cmnd_release(struct iscsi_cmnd *, int);
-extern void send_data_rsp(struct iscsi_cmnd *, int (*)(struct iscsi_cmnd *));
 extern void send_scsi_rsp(struct iscsi_cmnd *);
 
 /* conn.c */

Modified: trunk/iscsi/kernel/nthread.c
===================================================================
--- trunk/iscsi/kernel/nthread.c	2005-09-03 13:52:32 UTC (rev 37)
+++ trunk/iscsi/kernel/nthread.c	2005-09-03 13:54:11 UTC (rev 38)
@@ -294,7 +294,6 @@
 	struct socket *sock;
 	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
 	struct scatterlist *sg;
-/* 	struct tio *tio; */
 	struct iovec *iop;
 	int saved_size, size, sendsize;
 	int offset, idx;



From mnc at berlios.de  Sat Sep  3 21:35:27 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 3 Sep 2005 21:35:27 +0200
Subject: [Stgt-svn] r39 - trunk/kernel
Message-ID: <200509031935.j83JZRMT014092@sheep.berlios.de>

Author: mnc
Date: 2005-09-03 21:35:27 +0200 (Sat, 03 Sep 2005)
New Revision: 39

Modified:
   trunk/kernel/stgt.c
Log:
fix device destroy bug (need to drop lock)

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 13:54:11 UTC (rev 38)
+++ trunk/kernel/stgt.c	2005-09-03 19:35:27 UTC (rev 39)
@@ -583,14 +583,11 @@
 
 	spin_lock_irqsave(&target->lock, flags);
 	device = stgt_device_find_nolock(target, lun);
-	if (device) {
-		list_del(&device->dlist);
-		goto found;
-	}
 	spin_unlock_irqrestore(&target->lock, flags);
+	if (!device)
+		return -EINVAL;
 
-	return -EINVAL;
-found:
+	list_del(&device->dlist);
 	if (device->sdt->destroy)
 		device->sdt->destroy(device);
 



From mnc at berlios.de  Sat Sep  3 22:35:56 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 3 Sep 2005 22:35:56 +0200
Subject: [Stgt-svn] r40 - trunk/kernel
Message-ID: <200509032035.j83KZub7016442@sheep.berlios.de>

Author: mnc
Date: 2005-09-03 22:35:56 +0200 (Sat, 03 Sep 2005)
New Revision: 40

Modified:
   trunk/kernel/stgt.c
Log:
release lock when finding target

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 19:35:27 UTC (rev 39)
+++ trunk/kernel/stgt.c	2005-09-03 20:35:56 UTC (rev 40)
@@ -213,9 +213,10 @@
 		if (target->tid == tid)
 			goto found;
 	}
-	spin_unlock(&all_targets_lock);
 	target = NULL;
 found:
+	spin_unlock(&all_targets_lock);
+
 	return target;
 }
 



From mnc at berlios.de  Tue Sep  6 01:12:38 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 6 Sep 2005 01:12:38 +0200
Subject: [Stgt-svn] r41 - trunk/kernel
Message-ID: <200509052312.j85NCcMF004536@sheep.berlios.de>

Author: mnc
Date: 2005-09-06 01:12:31 +0200 (Tue, 06 Sep 2005)
New Revision: 41

Added:
   trunk/kernel/tgt_protocol.c
   trunk/kernel/tgt_scsi.c
Modified:
   trunk/kernel/Makefile
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_sd.c
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_target.h
   trunk/kernel/stgt_vsd.c
Log:
move kernel scsi specifics to protocol mod (have not renamed all the stgt structs to tgt or btgt yet)

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/Makefile	2005-09-05 23:12:31 UTC (rev 41)
@@ -6,9 +6,9 @@
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= stgt_core.o
-stgt_core-objs	:= stgt_sysfs.o stgt.o
+stgt_core-objs	:= stgt_sysfs.o tgt_protocol.o stgt.o
 
-obj-m		+= stgt_sd.o stgt_vsd.o
+obj-m		+= stgt_vsd.o tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -21,6 +21,7 @@
 #include <stgt_target.h>
 #include <stgt_device.h>
 #include <stgt_if.h>
+#include <tgt_protocol.h>
 
 #define DEBUG_STGT
 
@@ -139,9 +140,10 @@
 struct target_type_internal {
 	struct list_head list;
 	struct stgt_target_template *stt;
+	struct tgt_protocol *proto;
 };
 
-static struct stgt_target_template *target_template_get(const char *name)
+static struct target_type_internal *target_template_get(const char *name)
 {
 	unsigned long flags;
 	struct target_type_internal *ti;
@@ -153,7 +155,7 @@
 			if (!try_module_get(ti->stt->module))
 				ti = NULL;
 			spin_unlock_irqrestore(&target_tmpl_lock, flags);
-			return ti ? ti->stt : NULL;
+			return ti;
 		}
 
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
@@ -178,6 +180,13 @@
 	INIT_LIST_HEAD(&ti->list);
 	ti->stt = stt;
 
+	ti->proto = tgt_protocol_get(stt->protocol);
+	if (!ti->proto) {
+		eprintk("Could not find %s protocol\n", stt->protocol);
+		kfree(ti);
+		return -EINVAL;
+	}
+
 	spin_lock_irqsave(&target_tmpl_lock, flags);
 	list_add_tail(&ti->list, &target_tmpl_list);
 	spin_unlock_irqrestore(&target_tmpl_lock, flags);
@@ -196,6 +205,7 @@
 	list_for_each_entry(ti, &target_tmpl_list, list)
 		if (ti->stt == stt) {
 			list_del(&ti->list);
+			tgt_protocol_put(ti->proto);
 			kfree(ti);
 			break;
 		}
@@ -224,6 +234,7 @@
 {
 	static int target_id;
 	struct stgt_target *target;
+	struct target_type_internal *tti;
 
 	if (!daemon_pid) {
 		eprintk("%s\n", "Run the user-space daemon first!");
@@ -236,10 +247,12 @@
 	dprintk("%p\n", target);
 	memset(target, 0, sizeof(*target));
 
-	target->stt = target_template_get(target_type);
-	if (!target->stt)
+	tti = target_template_get(target_type);
+	if (!tti)
 		goto free_target;
 
+	target->stt = tti->stt;
+	target->proto = tti->proto;
 	target->tid = target_id++;
 	spin_lock_init(&target->lock);
 
@@ -486,39 +499,42 @@
 }
 EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
 
+/*
+ * TODO: use a hash or any better alg/ds
+ */
 static struct stgt_device *
-stgt_device_find_nolock(struct stgt_target *target, uint32_t lun)
+stgt_device_find_nolock(struct stgt_target *target, uint64_t dev_id)
 {
 	struct stgt_device *device;
 
 	list_for_each_entry(device, &target->device_list, dlist)
-		if (device->lun == lun)
+		if (device->dev_id == dev_id)
 			return device;
 
 	return NULL;
 }
 
 static struct stgt_device *
-stgt_device_find(struct stgt_target *target, uint32_t lun)
+stgt_device_find(struct stgt_target *target, uint64_t dev_id)
 {
 	static struct stgt_device *device;
 	unsigned long flags;
 
 	spin_lock_irqsave(&target->lock, flags);
-	device = stgt_device_find_nolock(target, lun);
+	device = stgt_device_find_nolock(target, dev_id);
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return device;
 }
 
-static int stgt_device_create(int tid, uint32_t lun, char *device_type, char *path,
-			      unsigned long dflags)
+static int stgt_device_create(int tid, uint64_t dev_id, char *device_type,
+			      char *path, unsigned long dflags)
 {
 	struct stgt_target *target;
 	struct stgt_device *device;
 	unsigned long flags;
 
-	dprintk("%d %u %s %s\n", tid, lun, device_type, path);
+	dprintk("%d %llu %s %s\n", tid, dev_id, device_type, path);
 
 	target = target_find(tid);
 	if (!target)
@@ -529,16 +545,17 @@
 		return -ENOMEM;
 
 	memset(device, 0, sizeof(*device));
-
-	device->lun = lun;
+	device->dev_id = dev_id;
 	device->target = target;
 	device->path = kstrdup(path, GFP_KERNEL);
 	if (!device->path)
 		goto free_device;
 
 	device->sdt = device_template_get(device_type);
-	if (!device->sdt)
+	if (!device->sdt) {
+		eprintk("Could not get devive type %s\n", device_type);
 		goto free_path;
+	}
 
 	device->sdt_data = kmalloc(sizeof(device->sdt->priv_data_size),
 				   GFP_KERNEL);
@@ -572,7 +589,7 @@
 	return -EINVAL;
 }
 
-static int stgt_device_destroy(int tid, uint32_t lun)
+static int stgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct stgt_device *device;
 	struct stgt_target *target;
@@ -583,7 +600,7 @@
 		return -ENOENT;
 
 	spin_lock_irqsave(&target->lock, flags);
-	device = stgt_device_find_nolock(target, lun);
+	device = stgt_device_find_nolock(target, dev_id);
 	spin_unlock_irqrestore(&target->lock, flags);
 	if (!device)
 		return -EINVAL;
@@ -640,43 +657,15 @@
 }
 EXPORT_SYMBOL(stgt_cmnd_destroy);
 
-static void set_offset_and_length(uint8_t *scb, uint64_t *off, uint32_t *len)
-{
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		*off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		*len = scb[4];
-		if (!*len)
-			*len = 256;
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		*off = be32_to_cpu(*(u32 *) &scb[2]);
-		*len = (scb[7] << 8) + scb[8];
-		break;
-	case READ_16:
-	case WRITE_16:
-		*off = be64_to_cpu(*(u64 *)&scb[2]);
-		*len = be32_to_cpu(*(u32 *)&scb[10]);
-		break;
-	default:
-		break;
-	}
-
-	*off <<= 9;
-	*len <<= 9;
-}
-
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
-static void __alloc_buffer(struct stgt_cmnd *cmnd, uint32_t len, uint64_t offset)
+void __stgt_alloc_buffer(struct stgt_cmnd *cmnd)
 {
+	uint64_t offset = cmnd->offset;
+	uint32_t len = cmnd->bufflen;
 	int i;
 
 	cmnd->sg_count = pgcnt(len, offset);
-	cmnd->bufflen = len;
 	offset &= ~PAGE_CACHE_MASK;
 
 	cmnd->sg = kmalloc(cmnd->sg_count * sizeof(struct scatterlist),
@@ -693,18 +682,15 @@
 		len -= sg->length;
 	}
 }
+EXPORT_SYMBOL(__stgt_alloc_buffer);
 
-static void alloc_buffer(void *data)
+static void stgt_alloc_buffer(void *data)
 {
-	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
-	uint32_t len = 0;
-	uint64_t offset = 0;
+	struct stgt_cmnd *cmnd = data;
 
-	set_offset_and_length(cmnd->scb, &offset, &len);
+	dprintk("%x %llu %u\n", cmnd->scb[0], cmnd->offset, cmnd->bufflen);
+	__stgt_alloc_buffer(cmnd);
 
-	dprintk("%x %llu %u\n", cmnd->scb[0], offset, len);
-	__alloc_buffer(cmnd, len, offset);
-
 	if (cmnd->done) {
 		void (*done)(struct stgt_cmnd *) = cmnd->done;
 		cmnd->done = NULL;
@@ -714,18 +700,22 @@
 
 void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
 {
+	struct tgt_protocol *proto = cmnd->session->target->proto;
+
 	assert(list_empty(&cmnd->clist));
 
+	proto->init_cmnd_buffer(cmnd);
+
 	if (done) {
 		struct stgt_session *session = cmnd->session;
 		struct stgt_work *work;
 
-		work = stgt_init_work(session, alloc_buffer, cmnd);
+		work = stgt_init_work(session, stgt_alloc_buffer, cmnd);
 		stgt_queue_work(session->target, work);
 		return;
 	};
 
-	alloc_buffer(cmnd);
+	stgt_alloc_buffer(cmnd);
 }
 EXPORT_SYMBOL(stgt_cmnd_alloc_buffer);
 
@@ -738,7 +728,8 @@
 	int len;
 
 	len = NLMSG_SPACE(sizeof(*ev) + sizeof(cmnd->scb));
-	if (!(skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL)))
+	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
+	if (!skb)
 		return -ENOMEM;
 
 	dprintk("%d %Zd %Zd\n", len, sizeof(*ev), sizeof(cmnd->scb));
@@ -749,7 +740,7 @@
 
 	pdu = (char *) ev + sizeof(*ev);
 	ev->k.cmnd_req.tid = cmnd->session->target->tid;
-	ev->k.cmnd_req.lun = cmnd->lun;
+	ev->k.cmnd_req.dev_id = cmnd->dev_id;
 	ev->k.cmnd_req.cid = cmnd->cid;
 
 	memcpy(pdu, cmnd->scb, sizeof(cmnd->scb));
@@ -757,16 +748,24 @@
 	return netlink_unicast(nls, skb, daemon_pid, 0);
 }
 
-static void cmnd_done(struct stgt_cmnd *cmnd, int result)
+static void cmnd_done(struct stgt_cmnd *cmnd)
 {
 	void (*done)(struct stgt_cmnd *);
 
-	cmnd->result = result;
 	done = cmnd->done;
 	cmnd->done = NULL;
 	done(cmnd);
 }
 
+static void kspace_cmnd_done(struct stgt_cmnd *cmnd, int result)
+{
+	struct stgt_target *target = cmnd->session->target;
+	struct tgt_protocol *proto = target->proto;
+
+	proto->cmnd_done(cmnd, result);
+	cmnd_done(cmnd);
+}
+
 static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data,
 			     int result, uint32_t len)
 {
@@ -776,7 +775,9 @@
 	dprintk("%x %u\n", cmnd->scb[0], len);
 
 	if (len) {
-		__alloc_buffer(cmnd, len, 0);
+		cmnd->bufflen = len;
+		cmnd->offset = 0;
+		__stgt_alloc_buffer(cmnd);
 
 		for (i = 0; i < cmnd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
@@ -788,128 +789,45 @@
 		}
 	}
 
-	cmnd_done(cmnd, result);
+	cmnd->result = result;
+	cmnd_done(cmnd);
 }
 
-static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
-			    uint8_t ascode, uint8_t ascodeq)
-{
-	int i, len = 8, alen = 6;
-	uint8_t *data;
-
-	/* It works, however, dirty. */
-	for (i = 0; i < cmnd->sg_count; i++)
-		__free_page(cmnd->sg[i].page);
-	kfree(cmnd->sg);
-
-	__alloc_buffer(cmnd, len + alen, 0);
-	data = page_address(cmnd->sg[0].page);
-	clear_page(data);
-
-	data[0] = 0x70 | 1U << 7;
-	data[2] = key;
-	data[7] = alen;
-	data[12] = ascode;
-	data[13] = ascodeq;
-
-	return len + alen;
-}
-
-/* TODO: better error handling
- * We should get ASC and ASCQ from the device code.
- */
-static uint8_t error_to_sense_key(int err)
-{
-	uint8_t key;
-
-	switch (err) {
-	case -ENOMEM:
-		key = ABORTED_COMMAND;
-		break;
-	case -EOVERFLOW:
-		key = HARDWARE_ERROR;
-		break;
-	default:
-		key = HARDWARE_ERROR;
-		break;
-	}
-
-	return key;
-}
-
 static void queuecommand(void *data)
 {
-	int err;
-	uint8_t key;
-	enum stgt_cmnd_type type = STGT_CMND_USPACE;
-	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
+	int err = 0;
+	struct stgt_cmnd *cmnd = data;
 	struct stgt_target *target = cmnd->session->target;
 	struct stgt_device *device;
 
 	dprintk("%x\n", cmnd->scb[0]);
 
 	/* Should we do this earlier? */
-	device = stgt_device_find(target, cmnd->lun);
+	device = stgt_device_find(target, cmnd->dev_id);
 	if (device)
-		dprintk("found %u\n", cmnd->lun);
+		dprintk("found %llu\n", cmnd->dev_id);
 
-	if (device && device->sdt->prepcommand)
-		type = device->sdt->prepcommand(device, cmnd);
-
-	switch (type) {
-	case STGT_CMND_KSPACE:
-		err = device->sdt->queuecommand(device, cmnd);
-		if (err < 0)
-			goto failed_cmnd;
-		else
-			cmnd_done(cmnd, SAM_STAT_GOOD);
-		break;
-	case STGT_CMND_USPACE:
+	if (cmnd->rw == READ || cmnd->rw == WRITE)
+		err = device->sdt->queue_cmnd(device, cmnd);
+	else {
 		err = uspace_cmnd_send(cmnd);
-		if (err < 0)
-			goto failed_cmnd;
-		break;
-	default:
-		eprintk("%u %d\n", cmnd->scb[0], type);
-		assert(0);
-		break;
+		if (err >= 0)
+			/* sent to userspace */
+			return;
 	}
 
-	return;
-
-failed_cmnd:
-	eprintk("failed cmnd %llu %u %d %d\n",
-		cmnd->cid, cmnd->scb[0], err, type);
-	key = error_to_sense_key(err);
-	sense_data_build(cmnd, key, 0, 0);
-	cmnd_done(cmnd, SAM_STAT_CHECK_CONDITION);
+	if (unlikely(err))
+		eprintk("failed cmnd %llu %u %d %d\n",
+			cmnd->cid, cmnd->scb[0], err, cmnd->rw);
+	kspace_cmnd_done(cmnd, err);
 }
 
-static uint32_t translate_lun(uint8_t *p, int size)
-{
-	uint32_t lun = ~0U;
-
-	switch (*p >> 6) {
-	case 0:
-		lun = p[1];
-		break;
-	case 1:
-		lun = (0x3f & p[0]) << 8 | p[1];
-		break;
-	case 2:
-	case 3:
-	default:
-		break;
-	}
-
-	return lun;
-}
-
-int stgt_cmnd_queue(struct stgt_cmnd *cmnd, uint8_t *lun, int lun_size,
+int stgt_cmnd_queue(struct stgt_cmnd *cmnd, uint8_t *id_buff, int buff_size,
 		    void (*done)(struct stgt_cmnd *))
 {
 	struct stgt_work *work;
 	struct stgt_session *session = cmnd->session;
+	struct tgt_protocol *proto = session->target->proto;
 
 	dprintk("%p %x\n", cmnd, cmnd->scb[0]);
 
@@ -924,8 +842,7 @@
 	if (!work)
 		return -ENOMEM;
 
-	cmnd->lun = translate_lun(lun, lun_size);
-
+	proto->prep_cmnd(cmnd, id_buff, buff_size);
 	stgt_queue_work(session->target, work);
 
 	return 0;
@@ -973,14 +890,14 @@
 			break;
 		}
 		err = stgt_device_create(ev->u.c_device.tid,
-					 ev->u.c_device.lun,
+					 ev->u.c_device.dev_id,
 					 ev->u.c_device.type,
 					 (char *) ev + sizeof(*ev),
 					 ev->u.c_device.flags);
 		break;
 	case STGT_UEVENT_DEVICE_DESTROY:
 		err = stgt_device_destroy(ev->u.d_device.tid,
-					  ev->u.d_device.lun);
+					  ev->u.d_device.dev_id);
 		break;
 	case STGT_UEVENT_SCSI_CMND_RES:
 		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
@@ -1078,6 +995,8 @@
 	spin_lock_init(&target_tmpl_lock);
 	spin_lock_init(&device_tmpl_lock);
 
+	tgt_protocol_init();
+
 	err = stgt_sysfs_init();
 	if (err)
 		return err;

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt.h	2005-09-05 23:12:31 UTC (rev 41)
@@ -6,6 +6,7 @@
 #ifndef __SCSI_TARGET_H
 #define __SCSI_TARGET_H
 
+#include <linux/mempool.h>
 #include <scsi/scsi_cmnd.h>
 
 struct stgt_session {
@@ -20,10 +21,14 @@
 	struct stgt_session *session;
 
 	uint32_t state;
-	uint32_t lun;
+	uint64_t dev_id;
 	uint64_t cid;
 
+	/*
+	 * TODO allocate this as protocol specific data
+	 */
 	uint8_t scb[MAX_COMMAND_SIZE];
+	int rw;
 
 	void (*done) (struct stgt_cmnd *);
 
@@ -33,9 +38,13 @@
 	int sg_count;
 	struct scatterlist *sg;
 	uint32_t bufflen;
+	uint64_t offset;
 
 	int result;
 
+	/*
+	 * target driver private
+	 */
 	void *private;
 };
 
@@ -47,6 +56,7 @@
 
 extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session);
 extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
+extern void __stgt_alloc_buffer(struct stgt_cmnd *cmnd);
 extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,

Modified: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt_device.h	2005-09-05 23:12:31 UTC (rev 41)
@@ -14,12 +14,6 @@
 struct stgt_device;
 struct stgt_cmnd;
 
-enum stgt_cmnd_type {
-	STGT_CMND_UNKNOWN,
-	STGT_CMND_KSPACE,
-	STGT_CMND_USPACE,
-};
-
 struct stgt_device_template {
 	const char *name;
 	struct module *module;
@@ -27,8 +21,7 @@
 
 	int (* create)(struct stgt_device *);
 	void (* destroy)(struct stgt_device *);
-	int (* queuecommand)(struct stgt_device *device, struct stgt_cmnd *cmd);
-	int (* prepcommand)(struct stgt_device *device, struct stgt_cmnd *cmn);
+	int (* queue_cmnd)(struct stgt_device *device, struct stgt_cmnd *cmd);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
@@ -43,7 +36,7 @@
 	struct class_device cdev;
 
         char *path;
-        uint32_t lun;
+        uint64_t dev_id;
         uint32_t blk_shift;
         uint64_t size;
 

Modified: trunk/kernel/stgt_sd.c
===================================================================
--- trunk/kernel/stgt_sd.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt_sd.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -105,22 +105,12 @@
 	return 0;
 }
 
-static int stgt_sd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	/*
-	 * can we take owner ship? If so return 0 else return a enum
-	 * (TODO define this)
-	 */
-	return 0;
-}
-
 static struct stgt_device_template stgt_sd = {
 	.name = "stgt_sd",
 	.module = THIS_MODULE,
 	.create = stgt_sd_create,
 	.destroy = stgt_sd_destroy,
-	.queuecommand = stgt_sd_queue,
-	.prepcommand = stgt_sd_prep,
+	.queue_cmnd = stgt_sd_queue,
 };
 
 static int __init stgt_sd_init(void)

Modified: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt_sysfs.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -170,8 +170,8 @@
 	int err, i;
 
 	cdev->class = &stgt_device_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%d",
-		 target->tid, device->lun);
+	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%llu",
+		 target->tid, device->dev_id);
 	err = class_device_register(cdev);
 	if (err)
 		return err;

Modified: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt_target.h	2005-09-05 23:12:31 UTC (rev 41)
@@ -11,11 +11,18 @@
 #include <linux/device.h>
 #include <linux/list.h>
 
+struct tgt_protocol;
+
 struct stgt_target_template {
 	const char *name;
 	struct module *module;
 
 	/*
+	 * name of protocol to use
+	 */
+	const char *protocol;
+
+	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
 	 */
 	struct class_device_attribute **target_attrs;
@@ -24,6 +31,8 @@
 struct stgt_target {
 	int tid;
 	struct stgt_target_template *stt;
+	struct tgt_protocol *proto;
+
 	struct class_device cdev;
 
 	int queued_cmnds;

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/stgt_vsd.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -1,5 +1,5 @@
 /*
- * STGT virtual device
+ * SCSI target virtual device
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -76,31 +76,6 @@
 	return err;
 }
 
-static loff_t translate_offset(uint8_t *scb)
-{
-	loff_t off = 0;
-
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(u32 *)&scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(u64 *)&scb[2]);
-		break;
-	default:
-		BUG();
-	}
-
-	return off << 9;
-}
-
 static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
 {
 	struct iovec* iov;
@@ -118,13 +93,12 @@
 	return iov;
 }
 
-static int vfs_io(struct stgt_device *device, struct stgt_cmnd *cmnd, int rw, int sync)
+static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
 {
 	struct stgt_vsd_dev *vsddev = device->sdt_data;
-	struct inode *inode = vsddev->filp->f_dentry->d_inode;
 	ssize_t size;
 	struct iovec *iov;
-	loff_t pos = translate_offset(cmnd->scb);
+	loff_t pos = cmnd->offset;
 	int err = 0;
 
 	if (cmnd->bufflen + pos > device->size)
@@ -134,91 +108,30 @@
 	if (!iov)
 		return -ENOMEM;
 
-	if (rw == READ)
+	if (cmnd->rw == READ)
 		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
 	else
 		size = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
 
 	kfree(iov);
 
+/* not yet used
 	if (sync)
 		err = sync_page_range(inode, inode->i_mapping, pos,
 				      (size_t) cmnd->bufflen);
-
+*/
 	if ((size != cmnd->bufflen) || err)
 		return -EIO;
 	else
 		return 0;
 }
 
-static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	struct stgt_vsd_dev *vsddev = device->sdt_data;
-	struct inode *inode = vsddev->filp->f_dentry->d_inode;
-	int err = 0;
-
-	switch (cmnd->scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		err = vfs_io(device, cmnd, READ, 0);
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		err = vfs_io(device, cmnd, WRITE, 0);
-		break;
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-		break;
-	case SYNCHRONIZE_CACHE:
-		err = sync_page_range(inode, inode->i_mapping, 0, device->size);
-		break;
-	default:
-		BUG();
-	}
-
-	if (err < 0)
-		printk("%s %d: %x %d\n", __FUNCTION__, __LINE__, cmnd->scb[0], err);
-	return err;
-}
-
-static int stgt_vsd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	enum stgt_cmnd_type type;
-
-	switch (cmnd->scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-	case SYNCHRONIZE_CACHE:
-		type = STGT_CMND_KSPACE;
-		break;
-	default:
-		type = STGT_CMND_USPACE;
-	}
-
-	return type;
-}
-
 static struct stgt_device_template stgt_vsd = {
 	.name = "stgt_vsd",
 	.module = THIS_MODULE,
 	.create = stgt_vsd_create,
 	.destroy = stgt_vsd_destroy,
-	.queuecommand = stgt_vsd_queue,
-	.prepcommand = stgt_vsd_prep,
+	.queue_cmnd = stgt_vsd_queue,
 };
 
 static int __init stgt_vsd_init(void)

Added: trunk/kernel/tgt_protocol.c
===================================================================
--- trunk/kernel/tgt_protocol.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/tgt_protocol.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -0,0 +1,84 @@
+/*
+ * Target protocol registration functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#include <linux/list.h>
+#include <linux/module.h>
+#include <tgt_protocol.h>
+
+static spinlock_t protocol_lock;
+static LIST_HEAD(protocol_list);
+
+struct tgt_proto_internal {
+	struct list_head list;
+	struct tgt_protocol *proto;
+};
+
+struct tgt_protocol *tgt_protocol_get(const char *name)
+{
+	unsigned long flags;
+	struct tgt_proto_internal *tp;
+
+	spin_lock_irqsave(&protocol_lock, flags);
+	list_for_each_entry(tp, &protocol_list, list)
+		if (!strcmp(name, tp->proto->name)) {
+			if (!try_module_get(tp->proto->module))
+				tp = NULL;
+			spin_unlock_irqrestore(&protocol_lock, flags);
+			return tp ? tp->proto : NULL;
+		}
+
+	spin_unlock_irqrestore(&protocol_lock, flags);
+
+	return NULL;
+}
+
+void tgt_protocol_put(struct tgt_protocol *proto)
+{
+	module_put(proto->module);
+}
+
+int tgt_protocol_register(struct tgt_protocol *proto)
+{
+	unsigned long flags;
+	struct tgt_proto_internal *tp;
+
+	tp = kmalloc(sizeof(*tp), GFP_KERNEL);
+	if (!tp)
+		return -ENOMEM;
+	memset(tp, 0, sizeof(*tp));
+	INIT_LIST_HEAD(&tp->list);
+	tp->proto = proto;
+
+	spin_lock_irqsave(&protocol_lock, flags);
+	list_add_tail(&tp->list, &protocol_list);
+	spin_unlock_irqrestore(&protocol_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_protocol_register);
+
+void tgt_protocol_unregister(struct tgt_protocol *proto)
+{
+	unsigned long flags;
+	struct tgt_proto_internal *tp;
+
+	spin_lock_irqsave(&protocol_lock, flags);
+	list_for_each_entry(tp, &protocol_list, list)
+		if (tp->proto == proto) {
+			list_del(&tp->list);
+			kfree(tp);
+			break;
+		}
+
+	spin_unlock_irqrestore(&protocol_lock, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_protocol_unregister);
+
+void __init tgt_protocol_init(void)
+{
+	spin_lock_init(&protocol_lock);
+}

Added: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-03 20:35:56 UTC (rev 40)
+++ trunk/kernel/tgt_scsi.c	2005-09-05 23:12:31 UTC (rev 41)
@@ -0,0 +1,184 @@
+/*
+ * SCSI target protocol
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <scsi/scsi.h>
+#include <stgt.h>
+#include <tgt_protocol.h>
+
+/*
+ * we should be able to use scsi-ml's functions for this
+ */
+static uint64_t scsi_tgt_translate_lun(uint8_t *p, int size)
+{
+	uint64_t lun = ~0U;
+
+	switch (*p >> 6) {
+	case 0:
+		lun = p[1];
+		break;
+	case 1:
+		lun = (0x3f & p[0]) << 8 | p[1];
+		break;
+	case 2:
+	case 3:
+	default:
+		break;
+	}
+
+	return lun;
+}
+
+static void scsi_tgt_init_cmnd_buffer(struct stgt_cmnd *cmnd)
+{
+	uint8_t *scb = cmnd->scb;
+	uint64_t off = 0;
+	uint32_t len = 0;
+
+	/*
+	 * set bufflen and offset
+	 */
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		len = scb[4];
+		if (!len)
+			len = 256;
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(u32 *) &scb[2]);
+		len = (scb[7] << 8) + scb[8];
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(u64 *)&scb[2]);
+		len = be32_to_cpu(*(u32 *)&scb[10]);
+		break;
+	default:
+		break;
+	}
+
+	off <<= 9;
+	len <<= 9;
+
+	cmnd->bufflen = len;
+	cmnd->offset = off;
+}
+
+static void scsi_tgt_prep_cmnd(struct stgt_cmnd *cmnd, uint8_t *id_buff,
+			       int buff_size)
+{
+	uint8_t *scb = cmnd->scb;
+
+	/* set operation */
+	switch (scb[0]) {
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		cmnd->rw = READ;
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		cmnd->rw = WRITE;
+		break;
+	default:
+		cmnd->rw = SPECIAL;
+	};
+
+	/* translate target driver LUN to device id */
+	cmnd->dev_id = scsi_tgt_translate_lun(id_buff, buff_size);
+}
+
+static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
+			    uint8_t ascode, uint8_t ascodeq)
+{
+	int i, len = 8, alen = 6;
+	uint8_t *data;
+
+	/* It works, however, dirty. */
+	for (i = 0; i < cmnd->sg_count; i++)
+		__free_page(cmnd->sg[i].page);
+	kfree(cmnd->sg);
+
+	cmnd->bufflen = len + alen;
+	cmnd->offset = 0;
+
+	__stgt_alloc_buffer(cmnd);
+	data = page_address(cmnd->sg[0].page);
+	clear_page(data);
+
+	data[0] = 0x70 | 1U << 7;
+	data[2] = key;
+	data[7] = alen;
+	data[12] = ascode;
+	data[13] = ascodeq;
+
+	return len + alen;
+}
+
+/*
+ * TODO: better error handling
+ * We should get ASC and ASCQ from the device code.
+ */
+static uint8_t error_to_sense_key(int err)
+{
+	uint8_t key;
+
+	switch (err) {
+	case -ENOMEM:
+		key = ABORTED_COMMAND;
+		break;
+	case -EOVERFLOW:
+		key = HARDWARE_ERROR;
+		break;
+	default:
+		key = HARDWARE_ERROR;
+		break;
+	}
+
+	return key;
+}
+
+static void scsi_tgt_cmnd_done(struct stgt_cmnd *cmnd, int err)
+{
+	if (err < 0) {
+		uint8_t key;
+
+		key = error_to_sense_key(err);
+		sense_data_build(cmnd, key, 0, 0);
+		cmnd->result = SAM_STAT_CHECK_CONDITION;
+	} else
+		cmnd->result = SAM_STAT_GOOD;
+}
+
+static struct tgt_protocol scsi_tgt_proto = {
+	.name = "scsi",
+	.module = THIS_MODULE,
+	.init_cmnd_buffer = scsi_tgt_init_cmnd_buffer,
+	.prep_cmnd = scsi_tgt_prep_cmnd,
+	.cmnd_done = scsi_tgt_cmnd_done,
+};
+
+static int __init scsi_tgt_init(void)
+{
+	return tgt_protocol_register(&scsi_tgt_proto);
+}
+
+static void __exit scsi_tgt_exit(void)
+{
+	tgt_protocol_unregister(&scsi_tgt_proto);
+}
+
+module_init(scsi_tgt_init);
+module_exit(scsi_tgt_exit);
+MODULE_LICENSE("GPL");



From mnc at berlios.de  Tue Sep  6 01:13:45 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 6 Sep 2005 01:13:45 +0200
Subject: [Stgt-svn] r42 - trunk/kernel
Message-ID: <200509052313.j85NDj4V005709@sheep.berlios.de>

Author: mnc
Date: 2005-09-06 01:13:43 +0200 (Tue, 06 Sep 2005)
New Revision: 42

Removed:
   trunk/kernel/stgt_sd.c
Log:
kill stgt_sd.c, because we can do this with a userspace plugin just using SG_IO - yipppeeeee userspace

Deleted: trunk/kernel/stgt_sd.c
===================================================================
--- trunk/kernel/stgt_sd.c	2005-09-05 23:12:31 UTC (rev 41)
+++ trunk/kernel/stgt_sd.c	2005-09-05 23:13:43 UTC (rev 42)
@@ -1,129 +0,0 @@
-/*
- * STGT passthrough device
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/namei.h>
-
-#include <stgt_device.h>
-
-struct stgt_sd_dev {
-	struct block_device *bdev;
-};
-
-/*
- * Convert a device path to a dev_t.
- * from dm-table.c
- */
-static int lookup_device(const char *path, dev_t *dev)
-{
-	int r;
-	struct nameidata nd;
-	struct inode *inode;
-
-	r = path_lookup(path, LOOKUP_FOLLOW, &nd);
-	if (r)
-		return r;
-
-	inode = nd.dentry->d_inode;
-	if (!inode) {
-		r = -ENOENT;
-		goto out;
-	}
-
-	if (!S_ISBLK(inode->i_mode)) {
-		r = -ENOTBLK;
-		goto out;
-	}
-
-	*dev = inode->i_rdev;
-out:
-	path_release(&nd);
-	return r;
-}
-
-static int open_dev(struct stgt_sd_dev *sddev, dev_t devt)
-{
-        struct block_device *bdev;
-
-        bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
-        if (IS_ERR(bdev))
-                return PTR_ERR(bdev);
-	sddev->bdev = bdev;
-        return 0;
-}
-
-/*
- * Close a device that we've been using.
- */
-static void close_dev(struct stgt_sd_dev *sddev)
-{
-	blkdev_put(sddev->bdev);
-}
-
-static int stgt_sd_create(struct stgt_device *device)
-{
-	struct stgt_sd_dev *sddev = device->sdt_data;
-	dev_t devt;
-	int err;
-
-	err = lookup_device(device->path, &devt);
-	if (err)
-		return err;
-
-	err = open_dev(sddev, devt);
-	if (err)
-		return err;
-
-	device->size = sddev->bdev->bd_block_size;
-
-	return 0;
-}
-
-static void stgt_sd_destroy(struct stgt_device *device)
-{
-	close_dev(device->sdt_data);
-}
-
-static int stgt_sd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	/*
-	struct stgt_sd_dev *sddev = device->sdt_data;
-	struct request_queue *q = bdev_get_queue(sddev->bdev);
-	struct request *rq;
-
-	 * format struct request as BLOCK_PC command and do
-	 * elv_add_request or if James's no_wait helper is in
-	 * then use it
-	 *
-	 * Will need some stgt wrappers/helpers though
-	 */
-	return 0;
-}
-
-static struct stgt_device_template stgt_sd = {
-	.name = "stgt_sd",
-	.module = THIS_MODULE,
-	.create = stgt_sd_create,
-	.destroy = stgt_sd_destroy,
-	.queue_cmnd = stgt_sd_queue,
-};
-
-static int __init stgt_sd_init(void)
-{
-	stgt_sd.priv_data_size = sizeof(struct stgt_sd_dev);
-	return stgt_device_template_register(&stgt_sd);
-}
-
-static void __exit stgt_sd_exit(void)
-{
-	stgt_device_template_unregister(&stgt_sd);
-}
-
-module_init(stgt_sd_init);
-module_exit(stgt_sd_exit);
-MODULE_LICENSE("GPL");



From mnc at berlios.de  Tue Sep  6 03:45:38 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 6 Sep 2005 03:45:38 +0200
Subject: [Stgt-svn] r43 - trunk/kernel
Message-ID: <200509060145.j861jcAg007879@sheep.berlios.de>

Author: mnc
Date: 2005-09-06 03:45:35 +0200 (Tue, 06 Sep 2005)
New Revision: 43

Added:
   trunk/kernel/tgt_protocol.h
Log:
add tgt_protocol.h (forgot to when I merged)

Added: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-05 23:13:43 UTC (rev 42)
+++ trunk/kernel/tgt_protocol.h	2005-09-06 01:45:35 UTC (rev 43)
@@ -0,0 +1,41 @@
+/*
+ * Target protocol
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#ifndef __TGT_PROTOCOL_H
+#define __TGT_PROTOCOL_H
+
+struct module;
+struct stgt_cmnd;
+
+struct tgt_protocol {
+	const char *name;
+	struct module *module;
+
+	int priv_cmd_data_size;
+	/*
+	 * perform command preparation, such as setting the rw field
+	 * and dev_id
+	 */
+	void (* prep_cmnd)(struct stgt_cmnd *cmd, uint8_t *id_buff,
+			   int buff_size);
+	/*
+	 * setup buffer fields like offset and len
+	 */
+	void (* init_cmnd_buffer)(struct stgt_cmnd *cmd);
+	/*
+	 * process completion of a command
+	 */
+	void (* cmnd_done)(struct stgt_cmnd *cmd, int err);
+};
+
+extern void tgt_protocol_init(void);
+extern int tgt_protocol_register(struct tgt_protocol *proto);
+extern void tgt_protocol_unregister(struct tgt_protocol *proto);
+extern struct tgt_protocol *tgt_protocol_get(const char *name);
+extern void tgt_protocol_put(struct tgt_protocol *proto);
+
+#endif



From mnc at berlios.de  Tue Sep  6 03:49:24 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 6 Sep 2005 03:49:24 +0200
Subject: [Stgt-svn] r44 - in trunk: include iscsi/kernel iscsi/usr kernel usr
Message-ID: <200509060149.j861nO1t010154@sheep.berlios.de>

Author: mnc
Date: 2005-09-06 03:49:21 +0200 (Tue, 06 Sep 2005)
New Revision: 44

Modified:
   trunk/include/stgt_if.h
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/stgt_sysfs.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/stgtd.h
Log:
for some reason the iscsi and userspace files did not get updated from my scsi protocol checkin so here they are again

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/include/stgt_if.h	2005-09-06 01:49:21 UTC (rev 44)
@@ -25,13 +25,13 @@
 	union {
 		struct {
 			int tid;
-			uint32_t lun;
+			uint64_t dev_id;
 			uint32_t flags;
 			char type[32];
 		} c_device;
 		struct {
 			int tid;
-			uint32_t lun;
+			uint64_t dev_id;
 		} d_device;
 		struct {
 			uint64_t cid;
@@ -48,7 +48,7 @@
 		struct {
 			uint64_t cid;
 			int tid;
-			uint32_t lun;
+			uint64_t dev_id;
 		} cmnd_req;
 	} k;
 };

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-06 01:49:21 UTC (rev 44)
@@ -1574,6 +1574,7 @@
 static struct stgt_target_template iet_stgt_target_template = {
 	.name = "iet",
 	.module = THIS_MODULE,
+	.protocol = "scsi",
 };
 
 static void iscsi_exit(void)

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/iscsi/usr/ctldev.c	2005-09-06 01:49:21 UTC (rev 44)
@@ -443,7 +443,7 @@
 
 	ev = NLMSG_DATA(nlh);
 	ev->u.c_device.tid = tid;
-	ev->u.c_device.lun = lun;
+	ev->u.c_device.dev_id = lun;
 	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
 	memcpy((char *) ev + sizeof(*ev), path, strlen(path));
 
@@ -467,7 +467,7 @@
 
 	ev = NLMSG_DATA(nlh);
 	ev->u.d_device.tid = tid;
-	ev->u.d_device.lun = lun;
+	ev->u.d_device.dev_id = lun;
 
 	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
 

Modified: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/kernel/stgt_sysfs.c	2005-09-06 01:49:21 UTC (rev 44)
@@ -130,7 +130,7 @@
 show_##field (struct class_device *cdev, char *buf)			\
 {									\
 	struct stgt_device *device = cdev_to_stgt_device(cdev);		\
-	return sprintf (buf, format_string, device->field);	\
+	return sprintf(buf, format_string, device->field);	\
 }
 
 #define stgt_device_rd_attr(field, format_string)		\

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/usr/netlink.c	2005-09-06 01:49:21 UTC (rev 44)
@@ -117,7 +117,7 @@
 	scb = reqbuf + sizeof(*ev);
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
-	result = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.lun,
+	result = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.dev_id,
 				scb, resbuf, &len);
 
 	memset(ev, 0, sizeof(*ev));

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/usr/scsi.c	2005-09-06 01:49:21 UTC (rev 44)
@@ -15,6 +15,7 @@
 #include <stdint.h>
 #include <dirent.h>
 #include <unistd.h>
+#include <errno.h>
 #include <scsi/scsi.h>
 #include <asm/byteorder.h>
 #include <sys/stat.h>
@@ -56,12 +57,12 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
-static int device_info(int tid, uint32_t lun, uint64_t *size)
+static int device_info(int tid, uint64_t lun, uint64_t *size)
 {
 	int fd, err;
 	char path[PATH_MAX], buf[128];
 
-	sprintf(path, "/sys/class/stgt_device/device%d:%u/size", tid, lun);
+	sprintf(path, "/sys/class/stgt_device/device%d:%llu/size", tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd < 0)
@@ -150,7 +151,7 @@
 	return sizeof(geo_m_pg);
 }
 
-static int mode_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
+static int mode_sense(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t pcode = scb[2] & 0x3f;
@@ -219,7 +220,7 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int inquiry(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
+static int inquiry(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_CHECK_CONDITION;
 
@@ -278,8 +279,8 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (lun != ~0UL)
-				sprintf(data + 8, "deadbeaf%d:%u", tid, lun);
+			if (lun != ~0ULL)
+				sprintf(data + 8, "deadbeaf%d:%llu", tid, lun);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
 		}
@@ -290,7 +291,7 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (lun == ~0UL)
+	if (lun == ~0ULL)
 		data[0] = TYPE_NO_LUN;
 
 	return SAM_STAT_GOOD;
@@ -303,6 +304,9 @@
 
 static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p, int *len)
 {
+	/*
+	 * TODO Convert to 64 bits
+	 */
 	uint32_t lun;
 	uint32_t *data = (uint32_t *) p;
 	int idx, alen, oalen, rbuflen, nr_luns;
@@ -360,7 +364,7 @@
 	return result;
 }
 
-static int read_capacity(int tid, uint32_t lun, uint8_t *scb, uint8_t *p, int *len)
+static int read_capacity(int tid, uint64_t lun, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t *data = (uint32_t *) p;
 	uint64_t size;
@@ -387,17 +391,70 @@
 	return SAM_STAT_GOOD;
 }
 
+static int sync_cache(int tid, uint64_t lun, uint8_t *scb, uint8_t *data,
+		      int *len)
+{
+	int fd, err;
+	/* yuck! - i need to learn which function to call to avoid this crap */
+	char path[PATH_MAX], buf[PATH_MAX], dev[PATH_MAX];
+
+	sprintf(path, "/sys/class/stgt_device/device%d:%llu/path", tid, lun);
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		perror("scsi sync_cache could not get LU's path");
+		err = EINVAL;
+		goto einval;
+	}
+
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		perror("scsi sync_cache could not read LUN path");
+		err = EIO;
+		goto eio;
+	}
+	sscanf(buf, "%s\n", dev);
+
+	fd = open(dev, O_RDWR);
+	if (fd < 0) {
+		perror("scsi sync_cache could not open device");
+		err = EIO;
+		goto eio;
+	}
+	err = fsync(fd);
+	close(fd);
+
+	switch (err) {
+	case EROFS:
+	case EINVAL:
+	case EBADF:
+einval:
+		/* is this the right sense code? */
+		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	case EIO:
+eio:
+		/* what should I put for the asc/ascq? */
+		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	default:
+		*len = 0;
+		return SAM_STAT_GOOD;
+	}
+}
+
 /*
  * TODO: We always assume autosense.
  */
-static int request_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int* len)
+static int request_sense(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int* len)
 {
 	*len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
 
 	return SAM_STAT_GOOD;
 }
 
-static int sevice_action(int tid, uint32_t lun, uint8_t *scb, uint8_t *p, int *len)
+static int sevice_action(int tid, uint64_t lun, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t *data = (uint32_t *) p;
 	uint64_t *data64, size;
@@ -418,13 +475,13 @@
 	return SAM_STAT_GOOD;
 }
 
-int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data, int *len)
+int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_GOOD;
 
 	dprintf("%x\n", scb[0]);
 
-	if (lun == ~0UL)
+	if (lun == ~0ULL)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:
@@ -456,9 +513,11 @@
 	case SERVICE_ACTION_IN:
 		result = sevice_action(tid, lun, scb, data, len);
 		break;
+	case SYNCHRONIZE_CACHE:
+		result = sync_cache(tid, lun, scb, data, len);
+		break;
 	case START_STOP:
 	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
 	case VERIFY:
 		*len = 0;
 		break;
@@ -472,7 +531,7 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		dprintf("BUG? %u %u\n", scb[0], lun);
+		dprintf("BUG? %u %llu\n", scb[0], lun);
 		*len = 0;
 		break;
 	}

Modified: trunk/usr/stgtd.h
===================================================================
--- trunk/usr/stgtd.h	2005-09-06 01:45:35 UTC (rev 43)
+++ trunk/usr/stgtd.h	2005-09-06 01:49:21 UTC (rev 44)
@@ -24,7 +24,7 @@
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-extern int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb,
+extern int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb,
 			     uint8_t *data, int *len);
 
 #endif



From mnc at berlios.de  Tue Sep  6 03:52:11 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 6 Sep 2005 03:52:11 +0200
Subject: [Stgt-svn] r45 - trunk/usr
Message-ID: <200509060152.j861qBBs011333@sheep.berlios.de>

Author: mnc
Date: 2005-09-06 03:52:09 +0200 (Tue, 06 Sep 2005)
New Revision: 45

Modified:
   trunk/usr/scsi.c
Log:
just use two buffers when mapping LUN to device\n

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-06 01:49:21 UTC (rev 44)
+++ trunk/usr/scsi.c	2005-09-06 01:52:09 UTC (rev 45)
@@ -395,8 +395,7 @@
 		      int *len)
 {
 	int fd, err;
-	/* yuck! - i need to learn which function to call to avoid this crap */
-	char path[PATH_MAX], buf[PATH_MAX], dev[PATH_MAX];
+	char path[PATH_MAX], buf[PATH_MAX];
 
 	sprintf(path, "/sys/class/stgt_device/device%d:%llu/path", tid, lun);
 
@@ -414,9 +413,13 @@
 		err = EIO;
 		goto eio;
 	}
-	sscanf(buf, "%s\n", dev);
+	/*
+	 * yuck! wtf should I be using
+	 */
+	memset(path, 0, PATH_MAX);
+	sscanf(buf, "%s\n", path);
 
-	fd = open(dev, O_RDWR);
+	fd = open(path, O_RDWR);
 	if (fd < 0) {
 		perror("scsi sync_cache could not open device");
 		err = EIO;



From tomo at berlios.de  Tue Sep  6 05:19:55 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 6 Sep 2005 05:19:55 +0200
Subject: [Stgt-svn] r46 - trunk/kernel
Message-ID: <200509060319.j863JtCm032303@sheep.berlios.de>

Author: tomo
Date: 2005-09-06 05:19:42 +0200 (Tue, 06 Sep 2005)
New Revision: 46

Modified:
   trunk/kernel/stgt.c
Log:
Replace EXPORT_SYMBOL with EXPORT_SYMBOL_GPL.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-06 01:52:09 UTC (rev 45)
+++ trunk/kernel/stgt.c	2005-09-06 03:19:42 UTC (rev 46)
@@ -277,7 +277,7 @@
 	kfree(target);
 	return NULL;
 }
-EXPORT_SYMBOL(stgt_target_create);
+EXPORT_SYMBOL_GPL(stgt_target_create);
 
 int stgt_target_destroy(struct stgt_target *target)
 {
@@ -292,7 +292,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(stgt_target_destroy);
+EXPORT_SYMBOL_GPL(stgt_target_destroy);
 
 static int session_init(struct stgt_session *session, int max_cmnds)
 {
@@ -419,7 +419,7 @@
 	kfree(session);
 	return NULL;
 }
-EXPORT_SYMBOL(stgt_session_create);
+EXPORT_SYMBOL_GPL(stgt_session_create);
 
 int stgt_session_destroy(struct stgt_session *session)
 {
@@ -429,7 +429,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(stgt_session_destroy);
+EXPORT_SYMBOL_GPL(stgt_session_destroy);
 
 struct device_type_internal {
 	struct stgt_device_template *sdt;
@@ -638,7 +638,7 @@
 
 	return cmnd;
 }
-EXPORT_SYMBOL(stgt_cmnd_create);
+EXPORT_SYMBOL_GPL(stgt_cmnd_create);
 
 void stgt_cmnd_destroy(struct stgt_cmnd *cmnd)
 {
@@ -655,7 +655,7 @@
 
 	mempool_free(cmnd, cmnd->session->cmnd_pool);
 }
-EXPORT_SYMBOL(stgt_cmnd_destroy);
+EXPORT_SYMBOL_GPL(stgt_cmnd_destroy);
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
@@ -682,7 +682,7 @@
 		len -= sg->length;
 	}
 }
-EXPORT_SYMBOL(__stgt_alloc_buffer);
+EXPORT_SYMBOL_GPL(__stgt_alloc_buffer);
 
 static void stgt_alloc_buffer(void *data)
 {
@@ -717,7 +717,7 @@
 
 	stgt_alloc_buffer(cmnd);
 }
-EXPORT_SYMBOL(stgt_cmnd_alloc_buffer);
+EXPORT_SYMBOL_GPL(stgt_cmnd_alloc_buffer);
 
 static int uspace_cmnd_send(struct stgt_cmnd *cmnd)
 {
@@ -847,7 +847,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(stgt_cmnd_queue);
+EXPORT_SYMBOL_GPL(stgt_cmnd_queue);
 
 static struct stgt_cmnd *find_cmnd_by_id(uint64_t cid)
 {



From tomo at berlios.de  Wed Sep  7 13:38:04 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 13:38:04 +0200
Subject: [Stgt-svn] r47 - trunk/kernel
Message-ID: <200509071138.j87Bc4X3002515@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 13:38:03 +0200 (Wed, 07 Sep 2005)
New Revision: 47

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt_target.h
Log:
Use a work queue per target instead of keventd.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-06 03:19:42 UTC (rev 46)
+++ trunk/kernel/stgt.c	2005-09-07 11:38:03 UTC (rev 47)
@@ -134,7 +134,7 @@
 	list_add_tail(&work->list, &target->work_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	schedule_work(&target->work);
+	queue_work(target->twq, &target->work);
 }
 
 struct target_type_internal {
@@ -232,6 +232,7 @@
 
 struct stgt_target *stgt_target_create(char *target_type, int queued_cmnds)
 {
+	char name[16];
 	static int target_id;
 	struct stgt_target *target;
 	struct target_type_internal *tti;
@@ -263,14 +264,21 @@
 	INIT_WORK(&target->work, stgt_worker, target);
 	target->queued_cmnds = queued_cmnds;
 
-	if (stgt_sysfs_register_target(target))
+	snprintf(name, sizeof(name), "tgtd%d", target->tid);
+	target->twq = create_workqueue(name);
+	if (!target->twq)
 		goto put_template;
 
+	if (stgt_sysfs_register_target(target))
+		goto free_workqueue;
+
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
 	return target;
 
+free_workqueue:
+	destroy_workqueue(target->twq);
 put_template:
 	target_template_put(target->stt);
 free_target:
@@ -287,6 +295,7 @@
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 
+	destroy_workqueue(target->twq);
 	target_template_put(target->stt);
 	stgt_sysfs_unregister_target(target);
 
@@ -370,7 +379,7 @@
 	list_add(&ssa->list, &atomic_sessions);
 	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
 
-	schedule_work(&atomic_session_work);
+	queue_work(session->target->twq, &atomic_session_work);
 
 	return 0;
 }

Modified: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-06 03:19:42 UTC (rev 46)
+++ trunk/kernel/stgt_target.h	2005-09-07 11:38:03 UTC (rev 47)
@@ -47,6 +47,7 @@
 
 	struct work_struct work;
 	struct list_head work_list;
+	struct workqueue_struct *twq;
 };
 
 #define cdev_to_stgt_target(cdev) \



From tomo at berlios.de  Wed Sep  7 14:02:57 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 14:02:57 +0200
Subject: [Stgt-svn] r48 - trunk/iscsi/kernel
Message-ID: <200509071202.j87C2vor023140@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 14:02:57 +0200 (Wed, 07 Sep 2005)
New Revision: 48

Modified:
   trunk/iscsi/kernel/target.c
Log:
Fix failure handling in iscsi_target_create().

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-07 11:38:03 UTC (rev 47)
+++ trunk/iscsi/kernel/target.c	2005-09-07 12:02:57 UTC (rev 48)
@@ -106,12 +106,11 @@
 	int err = -EINVAL;
 	struct iscsi_target *target;
 
-	if (!(target = kmalloc(sizeof(*target), GFP_KERNEL))) {
-		err = -ENOMEM;
-		goto out;
-	}
+	target = kmalloc(sizeof(*target), GFP_KERNEL);
+	if (!target)
+		return -ENOMEM;
+
 	memset(target, 0, sizeof(*target));
-
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
@@ -122,19 +121,21 @@
 
 	nthread_init(target);
 
-	if ((err = target_thread_start(target)) < 0) {
-		target_thread_stop(target);
-		goto out;
-	}
-
 	target->stt = stgt_target_create("iet", DEFAULT_NR_QUEUED_CMNDS);
+	if (!target->stt)
+		goto free_target;
 
+	err = target_thread_start(target);
+	if (err < 0)
+		goto destory_tgt;
+
 	target->tid = info->tid = target->stt->tid;
+	return 0;
 
-	return 0;
-out:
+destory_tgt:
+	stgt_target_destroy(target->stt);
+free_target:
 	kfree(target);
-
 	return err;
 }
 



From tomo at berlios.de  Wed Sep  7 14:06:54 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 14:06:54 +0200
Subject: [Stgt-svn] r49 - trunk/kernel
Message-ID: <200509071206.j87C6s3n023379@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 14:06:53 +0200 (Wed, 07 Sep 2005)
New Revision: 49

Modified:
   trunk/kernel/stgt.c
Log:
Use the address of struct stgt_cmnd as cid (command id).

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-07 12:02:57 UTC (rev 48)
+++ trunk/kernel/stgt.c	2005-09-07 12:06:53 UTC (rev 49)
@@ -626,20 +626,18 @@
 
 struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session)
 {
-	static uint64_t cid = 0;
 	struct stgt_cmnd *cmnd;
 	unsigned long flags;
 
-	dprintk("%p %llu\n", session, cid);
 	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
 	assert(cmnd);
 	memset(cmnd, 0, sizeof(*cmnd));
 	cmnd->session = session;
-	cmnd->cid = cid++;
+	cmnd->cid = (uint64_t) (unsigned long) cmnd;
 	INIT_LIST_HEAD(&cmnd->clist);
 	INIT_LIST_HEAD(&cmnd->hash_list);
 
-	dprintk("%p %llu\n", session, cid);
+	dprintk("%p %llu\n", session, cmnd->cid);
 
 	spin_lock_irqsave(&cmnd_hash_lock, flags);
 	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);



From tomo at berlios.de  Wed Sep  7 19:26:36 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 19:26:36 +0200
Subject: [Stgt-svn] r50 - in trunk: include kernel
Message-ID: <200509071726.j87HQa4n001024@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 19:26:34 +0200 (Wed, 07 Sep 2005)
New Revision: 50

Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_target.h
Log:
Add callbacks (target_create and target_destroy) to stgt_target_template.

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-07 12:06:53 UTC (rev 49)
+++ trunk/include/stgt_if.h	2005-09-07 17:26:34 UTC (rev 50)
@@ -11,6 +11,8 @@
 enum stgt_event_type {
 	/* user -> kernel */
 	STGT_UEVENT_START,
+	STGT_UEVENT_TARGET_CREATE,
+	STGT_UEVENT_TARGET_DESTROY,
 	STGT_UEVENT_DEVICE_CREATE,
 	STGT_UEVENT_DEVICE_DESTROY,
 	STGT_UEVENT_SCSI_CMND_RES,
@@ -24,7 +26,14 @@
 	/* user-> kernel */
 	union {
 		struct {
+			char type[32];
+			int nr_cmnds;
+		} c_target;
+		struct {
 			int tid;
+		} d_target;
+		struct {
+			int tid;
 			uint64_t dev_id;
 			uint32_t flags;
 			char type[32];

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-07 12:06:53 UTC (rev 49)
+++ trunk/kernel/stgt.c	2005-09-07 17:26:34 UTC (rev 50)
@@ -245,7 +245,6 @@
 	target = kmalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
-	dprintk("%p\n", target);
 	memset(target, 0, sizeof(*target));
 
 	tti = target_template_get(target_type);
@@ -269,14 +268,27 @@
 	if (!target->twq)
 		goto put_template;
 
-	if (stgt_sysfs_register_target(target))
+	target->stt_data = kmalloc(sizeof(target->stt->priv_data_size), GFP_KERNEL);
+	if (!target->stt_data)
 		goto free_workqueue;
 
+	if (target->stt->target_create)
+		if (target->stt->target_create(target))
+			goto free_priv_stt_data;
+
+	if (stgt_sysfs_register_target(target))
+		goto stt_destroy;
+
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
 	return target;
 
+stt_destroy:
+	if (target->stt->target_destroy)
+		target->stt->target_destroy(target);
+free_priv_stt_data:
+	kfree(target->stt_data);
 free_workqueue:
 	destroy_workqueue(target->twq);
 put_template:
@@ -295,6 +307,9 @@
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 
+	if (target->stt->target_destroy)
+		target->stt->target_destroy(target);
+
 	destroy_workqueue(target->twq);
 	target_template_put(target->stt);
 	stgt_sysfs_unregister_target(target);
@@ -882,6 +897,7 @@
 	int err = 0;
 	struct stgt_event *ev = NLMSG_DATA(nlh);
 	struct stgt_cmnd *cmnd;
+	struct stgt_target *target;
 
 	daemon_pid  = NETLINK_CREDS(skb)->pid;
 
@@ -891,6 +907,21 @@
 	case STGT_UEVENT_START:
 		dprintk("start %d\n", daemon_pid);
 		break;
+	case STGT_UEVENT_TARGET_CREATE:
+		target = stgt_target_create(ev->u.c_target.type,
+					    ev->u.c_target.nr_cmnds);
+		if (target)
+			err = target->tid;
+		else
+			err = -EINVAL;
+		break;
+	case STGT_UEVENT_TARGET_DESTROY:
+		target = target_find(ev->u.d_target.tid);
+		if (target)
+			err = stgt_target_destroy(target);
+		else
+			err = -EINVAL;
+		break;
 	case STGT_UEVENT_DEVICE_CREATE:
 		if (nlh->nlmsg_len <= NLMSG_SPACE(sizeof(*ev))) {
 			err = -EINVAL;

Modified: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-07 12:06:53 UTC (rev 49)
+++ trunk/kernel/stgt_sysfs.c	2005-09-07 17:26:34 UTC (rev 50)
@@ -33,6 +33,7 @@
 static void stgt_target_class_release(struct class_device *cdev)
 {
 	struct stgt_target *target = cdev_to_stgt_target(cdev);
+	kfree(target->stt_data);
 	kfree(target);
 }
 

Modified: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-07 12:06:53 UTC (rev 49)
+++ trunk/kernel/stgt_target.h	2005-09-07 17:26:34 UTC (rev 50)
@@ -12,11 +12,16 @@
 #include <linux/list.h>
 
 struct tgt_protocol;
+struct stgt_target;
 
 struct stgt_target_template {
 	const char *name;
 	struct module *module;
+	unsigned priv_data_size;
 
+	int (* target_create) (struct stgt_target *);
+	void (* target_destroy) (struct stgt_target *);
+
 	/*
 	 * name of protocol to use
 	 */
@@ -31,6 +36,7 @@
 struct stgt_target {
 	int tid;
 	struct stgt_target_template *stt;
+	void *stt_data;
 	struct tgt_protocol *proto;
 
 	struct class_device cdev;



From tomo at berlios.de  Wed Sep  7 19:28:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 19:28:13 +0200
Subject: [Stgt-svn] r51 - in trunk/iscsi: include kernel usr
Message-ID: <200509071728.j87HSDiv002958@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 19:28:12 +0200 (Wed, 07 Sep 2005)
New Revision: 51

Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
Log:
IET exploits stgt_target_template callbacks to create and destroy targets.


Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/include/iet_u.h	2005-09-07 17:28:12 UTC (rev 51)
@@ -10,10 +10,6 @@
 #define VENDOR_ID_LEN	8
 #define SCSI_ID_LEN	24
 
-struct target_info {
-	int tid;
-};
-
 struct session_info {
 	u32 tid;
 

Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/kernel/config.c	2005-09-07 17:28:12 UTC (rev 51)
@@ -180,20 +180,6 @@
 	return err;
 }
 
-static int add_target(unsigned long ptr)
-{
-	int err;
-	struct target_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	if (!(err = target_add(&info)))
-		err = copy_to_user((void *) ptr, &info, sizeof(info));
-
-	return err;
-}
-
 static long ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct iscsi_target *target = NULL;
@@ -203,20 +189,7 @@
 	if ((err = get_user(id, (u32 *) arg)) != 0)
 		goto done;
 
-	if (cmd == DEL_TARGET) {
-		err = target_del(id);
-		goto done;
-	}
-
-	if (cmd != ADD_TARGET)
-		target = target_lookup_by_id(id);
-
-	switch (cmd) {
-	case ADD_TARGET:
-		err = add_target(arg);
-		goto done;
-	}
-
+	target = target_lookup_by_id(id);
 	if (!target) {
 		eprintk("can't find the target %u\n", id);
 		err = -EINVAL;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-07 17:28:12 UTC (rev 51)
@@ -1575,6 +1575,8 @@
 	.name = "iet",
 	.module = THIS_MODULE,
 	.protocol = "scsi",
+	.target_create = target_add,
+	.target_destroy = target_del,
 };
 
 static void iscsi_exit(void)

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-07 17:28:12 UTC (rev 51)
@@ -226,8 +226,8 @@
 extern int target_lock(struct iscsi_target *, int);
 extern void target_unlock(struct iscsi_target *);
 struct iscsi_target *target_lookup_by_id(u32);
-extern int target_add(struct target_info *);
-extern int target_del(u32 id);
+extern int target_add(struct stgt_target *);
+extern void target_del(struct stgt_target *);
 
 /* config.c */
 extern int iet_procfs_init(void);

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/kernel/target.c	2005-09-07 17:28:12 UTC (rev 51)
@@ -101,16 +101,15 @@
 	nthread_stop(target);
 }
 
-static int iscsi_target_create(struct target_info *info)
+static int iscsi_target_create(struct stgt_target *stt)
 {
 	int err = -EINVAL;
-	struct iscsi_target *target;
+	struct iscsi_target *target =
+		(struct iscsi_target *) stt->stt_data;
 
-	target = kmalloc(sizeof(*target), GFP_KERNEL);
-	if (!target)
-		return -ENOMEM;
-
 	memset(target, 0, sizeof(*target));
+
+	target->stt = stt;
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
@@ -121,25 +120,15 @@
 
 	nthread_init(target);
 
-	target->stt = stgt_target_create("iet", DEFAULT_NR_QUEUED_CMNDS);
-	if (!target->stt)
-		goto free_target;
-
 	err = target_thread_start(target);
 	if (err < 0)
-		goto destory_tgt;
+		return err;
 
-	target->tid = info->tid = target->stt->tid;
+	target->tid = target->stt->tid;
 	return 0;
-
-destory_tgt:
-	stgt_target_destroy(target->stt);
-free_target:
-	kfree(target);
-	return err;
 }
 
-int target_add(struct target_info *info)
+int target_add(struct stgt_target *stt)
 {
 	int err = -EEXIST;
 
@@ -150,10 +139,7 @@
 		goto out;
 	}
 
-	if (info->tid)
-		goto out;
-
-	if (!(err = iscsi_target_create(info)))
+	if (!(err = iscsi_target_create(stt)))
 		nr_targets++;
 out:
 	up(&target_list_sem);
@@ -161,36 +147,17 @@
 	return err;
 }
 
-static void target_destroy(struct iscsi_target *target)
+void target_del(struct stgt_target *stt)
 {
-	dprintk(D_SETUP, "%u\n", target->tid);
+	struct iscsi_target *target =
+		(struct iscsi_target *) stt->stt_data;
 
-	stgt_target_destroy(target->stt);
+	down(&target_list_sem);
 
-	target_thread_stop(target);
-
-	kfree(target);
-}
-
-int target_del(u32 id)
-{
-	struct iscsi_target *target;
-	int err;
-
-	if ((err = down_interruptible(&target_list_sem)) < 0)
-		return err;
-
-	if (!(target = __target_lookup_by_id(id))) {
-		err = -ENOENT;
-		goto out;
-	}
-
 	target_lock(target, 0);
 
-	if (!list_empty(&target->session_list)) {
-		err = -EBUSY;
-		goto out;
-	}
+	if (!list_empty(&target->session_list))
+		BUG();
 
 	list_del(&target->t_list);
 	nr_targets--;
@@ -198,13 +165,7 @@
 	target_unlock(target);
 	up(&target_list_sem);
 
-	target_destroy(target);
-	return 0;
-
-out:
-	target_unlock(target);
-	up(&target_list_sem);
-	return err;
+	target_thread_stop(target);
 }
 
 int iet_info_show(struct seq_file *seq, iet_show_info_t *func)

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-07 17:26:34 UTC (rev 50)
+++ trunk/iscsi/usr/ctldev.c	2005-09-07 17:28:12 UTC (rev 51)
@@ -24,6 +24,11 @@
 
 #define CTL_DEVICE	"/dev/ietctl"
 
+/*
+ * tomo:
+ * netlink code is temporary until ietd will be integrated to stgtd
+ */
+
 extern int ctrl_fd;
 
 struct session_file_operations {
@@ -82,31 +87,6 @@
 	return ctlfd;
 }
 
-static int iscsi_target_create(u32 *tid, char *name)
-{
-	int err;
-	struct target_info info;
-
-	memset(&info, 0, sizeof(info));
-
-	info.tid = *tid;
-	if ((err = ioctl(ctrl_fd, ADD_TARGET, &info)) < 0)
-		log_warning("can't create a target %d %u\n", errno, info.tid);
-
-	*tid = info.tid;
-	return err;
-}
-
-static int iscsi_target_destroy(u32 tid)
-{
-	struct target_info info;
-
-	memset(&info, 0, sizeof(info));
-	info.tid = tid;
-
-	return ioctl(ctrl_fd, DEL_TARGET, &info);
-}
-
 static int iscsi_conn_destroy(u32 tid, u64 sid, u32 cid)
 {
 	int err;
@@ -385,7 +365,7 @@
 	if (fd > 0)
 		close(fd);
 
-	return fd;
+	return err;
 }
 
 static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
@@ -398,6 +378,49 @@
 	nlh->nlmsg_seq = seq;
 }
 
+static int iscsi_target_create(u32 *tid, char *name)
+{
+	int err;
+	char nlm_ev[8912];
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_CREATE,
+		   NLMSG_SPACE(sizeof(*ev)), 0);
+
+	ev = NLMSG_DATA(nlh);
+	sprintf(ev->u.c_target.type, "%s", "iet");
+	ev->u.c_target.nr_cmnds = DEFAULT_NR_QUEUED_CMNDS;
+
+	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+	if (err > 0) {
+		*tid = err;
+		err = 0;
+	}
+
+	return err;
+}
+
+static int iscsi_target_destroy(u32 tid)
+{
+	int err;
+	char nlm_ev[8912];
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_DESTROY,
+		   NLMSG_SPACE(sizeof(*ev)), 0);
+
+	ev = NLMSG_DATA(nlh);
+	ev->u.d_target.tid = tid;
+
+	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+
+	return err;
+}
+
 static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
 {
 	int err;



From tomo at berlios.de  Wed Sep  7 19:36:50 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 7 Sep 2005 19:36:50 +0200
Subject: [Stgt-svn] r52 - trunk/iscsi/kernel
Message-ID: <200509071736.j87HaoMW012707@sheep.berlios.de>

Author: tomo
Date: 2005-09-07 19:36:44 +0200 (Wed, 07 Sep 2005)
New Revision: 52

Modified:
   trunk/iscsi/kernel/iscsi.c
Log:
Forgot set stgt_target_template.priv_data_size.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-07 17:28:12 UTC (rev 51)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-07 17:36:44 UTC (rev 52)
@@ -1615,6 +1615,7 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
+	iet_stgt_target_template.priv_data_size = sizeof(struct iscsi_target);
 	err = stgt_target_template_register(&iet_stgt_target_template);
 	if (err < 0)
 		goto err;



From mnc at berlios.de  Wed Sep  7 19:54:34 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Wed, 7 Sep 2005 19:54:34 +0200
Subject: [Stgt-svn] r53 - trunk/kernel
Message-ID: <200509071754.j87HsYWE005969@sheep.berlios.de>

Author: mnc
Date: 2005-09-07 19:54:33 +0200 (Wed, 07 Sep 2005)
New Revision: 53

Modified:
   trunk/kernel/stgt_vsd.c
Log:
trivial cleanup reflecting that vsd is not scsi specific anymore

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-07 17:36:44 UTC (rev 52)
+++ trunk/kernel/stgt_vsd.c	2005-09-07 17:54:33 UTC (rev 53)
@@ -1,5 +1,5 @@
 /*
- * SCSI target virtual device
+ * virtual device
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -12,7 +12,6 @@
 #include <linux/uio.h>
 #include <linux/fs.h>
 #include <linux/writeback.h>
-#include <scsi/scsi.h>
 
 #include <stgt.h>
 #include <stgt_device.h>



From mnc at berlios.de  Wed Sep  7 19:55:57 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Wed, 7 Sep 2005 19:55:57 +0200
Subject: [Stgt-svn] r54 - trunk/kernel
Message-ID: <200509071755.j87HtvaF006081@sheep.berlios.de>

Author: mnc
Date: 2005-09-07 19:55:57 +0200 (Wed, 07 Sep 2005)
New Revision: 54

Modified:
   trunk/kernel/stgt.c
Log:
trivial cleanup reflecting that stgt.c is not scsi specific now

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-07 17:54:33 UTC (rev 53)
+++ trunk/kernel/stgt.c	2005-09-07 17:55:57 UTC (rev 54)
@@ -1,5 +1,5 @@
 /*
- * SCSI Targets Framework
+ * Core Target Framework code
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -15,7 +15,6 @@
 #include <linux/mempool.h>
 #include <linux/netlink.h>
 #include <net/tcp.h>
-#include <scsi/scsi.h>
 
 #include <stgt.h>
 #include <stgt_target.h>



From mnc at berlios.de  Wed Sep  7 21:13:42 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Wed, 7 Sep 2005 21:13:42 +0200
Subject: [Stgt-svn] r55 - in trunk: include kernel usr
Message-ID: <200509071913.j87JDgo3011949@sheep.berlios.de>

Author: mnc
Date: 2005-09-07 21:13:41 +0200 (Wed, 07 Sep 2005)
New Revision: 55

Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/usr/netlink.c
Log:
more trivial scsi seperation prepatation for userspace

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-07 17:55:57 UTC (rev 54)
+++ trunk/include/stgt_if.h	2005-09-07 19:13:41 UTC (rev 55)
@@ -15,11 +15,11 @@
 	STGT_UEVENT_TARGET_DESTROY,
 	STGT_UEVENT_DEVICE_CREATE,
 	STGT_UEVENT_DEVICE_DESTROY,
-	STGT_UEVENT_SCSI_CMND_RES,
+	STGT_UEVENT_CMND_RES,
 
 	/* kernel -> user */
 	STGT_KEVENT_RESPONSE,
-	STGT_KEVENT_SCSI_CMND_REQ,
+	STGT_KEVENT_CMND_REQ,
 };
 
 struct stgt_event {

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-07 17:55:57 UTC (rev 54)
+++ trunk/kernel/stgt.c	2005-09-07 19:13:41 UTC (rev 55)
@@ -755,7 +755,7 @@
 
 	dprintk("%d %Zd %Zd\n", len, sizeof(*ev), sizeof(cmnd->scb));
 	nlh = __nlmsg_put(skb, daemon_pid, 0,
-			  STGT_KEVENT_SCSI_CMND_REQ, len - sizeof(*nlh), 0);
+			  STGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 
@@ -936,7 +936,7 @@
 		err = stgt_device_destroy(ev->u.d_device.tid,
 					  ev->u.d_device.dev_id);
 		break;
-	case STGT_UEVENT_SCSI_CMND_RES:
+	case STGT_UEVENT_CMND_RES:
 		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
 		if (cmnd)
 			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
@@ -987,7 +987,7 @@
 
 		eprintk("%d %d\n", nlh->nlmsg_type, err);
 		ev->k.event_res.err = err;
-		if (nlh->nlmsg_type != STGT_UEVENT_SCSI_CMND_RES)
+		if (nlh->nlmsg_type != STGT_UEVENT_CMND_RES)
 			send_event_res(NETLINK_CREDS(skb)->pid,
 				       STGT_KEVENT_RESPONSE,
 				       ev, sizeof(*ev));

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-07 17:55:57 UTC (rev 54)
+++ trunk/usr/netlink.c	2005-09-07 19:13:41 UTC (rev 55)
@@ -105,7 +105,7 @@
 	return err;
 }
 
-static int scsi_cmnd_queue(int fd, char *reqbuf, char *resbuf)
+static int cmnd_queue(int fd, char *reqbuf, char *resbuf)
 {
 	int result, len;
 	struct iovec iov[2];
@@ -117,6 +117,10 @@
 	scb = reqbuf + sizeof(*ev);
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
+	/*
+	 * TODO match tid to protocol and route cmnd to correct userspace
+	 * protocol module
+	 */
 	result = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.dev_id,
 				scb, resbuf, &len);
 
@@ -130,7 +134,7 @@
 	iov[1].iov_base = resbuf;
 	iov[1].iov_len = len;
 
-	return nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, len ? 2 : 1);
+	return nl_write(fd, STGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
 }
 
 void nl_event_handle(int fd)
@@ -167,8 +171,8 @@
 	}
 
 	switch (nlh->nlmsg_type) {
-	case STGT_KEVENT_SCSI_CMND_REQ:
-		scsi_cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
+	case STGT_KEVENT_CMND_REQ:
+		cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	default:
 		/* kernel module bug */



From tomo at berlios.de  Thu Sep  8 04:39:39 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 8 Sep 2005 04:39:39 +0200
Subject: [Stgt-svn] r56 - in trunk: kernel usr
Message-ID: <200509080239.j882ddgM014853@sheep.berlios.de>

Author: tomo
Date: 2005-09-08 04:39:37 +0200 (Thu, 08 Sep 2005)
New Revision: 56

Modified:
   trunk/kernel/tgt_scsi.c
   trunk/usr/scsi.c
Log:
Fix 64 bit compile warning (stgt).

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-07 19:13:41 UTC (rev 55)
+++ trunk/kernel/tgt_scsi.c	2005-09-08 02:39:37 UTC (rev 56)
@@ -8,6 +8,7 @@
 #include <linux/fs.h>
 #include <linux/module.h>
 #include <scsi/scsi.h>
+#include <linux/mm.h>
 #include <stgt.h>
 #include <tgt_protocol.h>
 

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-07 19:13:41 UTC (rev 55)
+++ trunk/usr/scsi.c	2005-09-08 02:39:37 UTC (rev 56)
@@ -13,6 +13,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <inttypes.h>
 #include <dirent.h>
 #include <unistd.h>
 #include <errno.h>
@@ -62,7 +63,8 @@
 	int fd, err;
 	char path[PATH_MAX], buf[128];
 
-	sprintf(path, "/sys/class/stgt_device/device%d:%llu/size", tid, lun);
+	sprintf(path, "/sys/class/stgt_device/device%d:%" PRIu64 "/size",
+		tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd < 0)
@@ -280,7 +282,7 @@
 			data[5] = 0x1;
 			data[7] = tmp;
 			if (lun != ~0ULL)
-				sprintf(data + 8, "deadbeaf%d:%llu", tid, lun);
+				sprintf(data + 8, "deadbeaf%d:%" PRIu64, tid, lun);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
 		}
@@ -397,7 +399,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	sprintf(path, "/sys/class/stgt_device/device%d:%llu/path", tid, lun);
+	sprintf(path, "/sys/class/stgt_device/device%d:%" PRIu64 "/path", tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {
@@ -534,7 +536,7 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		dprintf("BUG? %u %llu\n", scb[0], lun);
+		dprintf("BUG? %u %" PRIu64 "\n", scb[0], lun);
 		*len = 0;
 		break;
 	}



From tomo at berlios.de  Thu Sep  8 04:42:44 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 8 Sep 2005 04:42:44 +0200
Subject: [Stgt-svn] r57 - trunk/iscsi/usr
Message-ID: <200509080242.j882gilN015581@sheep.berlios.de>

Author: tomo
Date: 2005-09-08 04:42:42 +0200 (Thu, 08 Sep 2005)
New Revision: 57

Modified:
   trunk/iscsi/usr/ctldev.c
Log:
Fix IET compile warning.

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-08 02:39:37 UTC (rev 56)
+++ trunk/iscsi/usr/ctldev.c	2005-09-08 02:42:42 UTC (rev 57)
@@ -457,7 +457,7 @@
 		return -EINVAL;
 	}
 
-	fprintf(stderr, "%s %d %s %s %d %d\n",
+	fprintf(stderr, "%s %d %s %s %Zd %Zd\n",
 		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));



From tomo at berlios.de  Fri Sep  9 08:56:39 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 08:56:39 +0200
Subject: [Stgt-svn] r58 - trunk/kernel
Message-ID: <200509090656.j896ud14030035@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 08:56:37 +0200 (Fri, 09 Sep 2005)
New Revision: 58

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
Remove protocol specific code from stgt core:
target driver (queue cmnd /alloc buffer) -> protocol (SCSI stuff) -> STGT


Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-08 02:42:42 UTC (rev 57)
+++ trunk/kernel/stgt.c	2005-09-09 06:56:37 UTC (rev 58)
@@ -638,14 +638,27 @@
 	return 0;
 }
 
-struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session)
+struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
+				   uint8_t *proto_data,
+				   uint8_t *id_buff, int buff_size)
 {
+	struct tgt_protocol *proto = session->target->proto;
 	struct stgt_cmnd *cmnd;
+	void *pcmnd_data;
 	unsigned long flags;
 
+	/*
+	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
+	 * However, how can we guarantee the specified number of commands ?
+	 */
+	pcmnd_data = kmalloc(proto->priv_cmd_data_size, GFP_ATOMIC);
+	if (!pcmnd_data)
+		return NULL;
+
 	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
 	assert(cmnd);
 	memset(cmnd, 0, sizeof(*cmnd));
+	cmnd->tgt_protocol_private = pcmnd_data;
 	cmnd->session = session;
 	cmnd->cid = (uint64_t) (unsigned long) cmnd;
 	INIT_LIST_HEAD(&cmnd->clist);
@@ -653,6 +666,8 @@
 
 	dprintk("%p %llu\n", session, cmnd->cid);
 
+	proto->init_cmnd(cmnd, proto_data, id_buff, buff_size);
+
 	spin_lock_irqsave(&cmnd_hash_lock, flags);
 	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);
 	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
@@ -666,6 +681,8 @@
 	unsigned long flags;
 	int i;
 
+	kfree(cmnd->tgt_protocol_private);
+
 	for (i = 0; i < cmnd->sg_count; i++)
 		__free_page(cmnd->sg[i].page);
 	kfree(cmnd->sg);
@@ -709,7 +726,6 @@
 {
 	struct stgt_cmnd *cmnd = data;
 
-	dprintk("%x %llu %u\n", cmnd->scb[0], cmnd->offset, cmnd->bufflen);
 	__stgt_alloc_buffer(cmnd);
 
 	if (cmnd->done) {
@@ -742,18 +758,19 @@
 
 static int uspace_cmnd_send(struct stgt_cmnd *cmnd)
 {
+	struct tgt_protocol *proto = cmnd->session->target->proto;
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
 	struct stgt_event *ev;
 	char *pdu;
-	int len;
+	int len, proto_pdu_size = proto->uspace_pdu_size;
 
-	len = NLMSG_SPACE(sizeof(*ev) + sizeof(cmnd->scb));
+	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
 	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
 	if (!skb)
 		return -ENOMEM;
 
-	dprintk("%d %Zd %Zd\n", len, sizeof(*ev), sizeof(cmnd->scb));
+	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
 	nlh = __nlmsg_put(skb, daemon_pid, 0,
 			  STGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
@@ -764,7 +781,7 @@
 	ev->k.cmnd_req.dev_id = cmnd->dev_id;
 	ev->k.cmnd_req.cid = cmnd->cid;
 
-	memcpy(pdu, cmnd->scb, sizeof(cmnd->scb));
+	proto->build_uspace_pdu(cmnd, pdu);
 
 	return netlink_unicast(nls, skb, daemon_pid, 0);
 }
@@ -793,8 +810,6 @@
 	int i;
 	assert(cmnd->done);
 
-	dprintk("%x %u\n", cmnd->scb[0], len);
-
 	if (len) {
 		cmnd->bufflen = len;
 		cmnd->offset = 0;
@@ -821,8 +836,6 @@
 	struct stgt_target *target = cmnd->session->target;
 	struct stgt_device *device;
 
-	dprintk("%x\n", cmnd->scb[0]);
-
 	/* Should we do this earlier? */
 	device = stgt_device_find(target, cmnd->dev_id);
 	if (device)
@@ -838,20 +851,16 @@
 	}
 
 	if (unlikely(err))
-		eprintk("failed cmnd %llu %u %d %d\n",
-			cmnd->cid, cmnd->scb[0], err, cmnd->rw);
+		eprintk("failed cmnd %llu %d %d\n", cmnd->cid, err, cmnd->rw);
+
 	kspace_cmnd_done(cmnd, err);
 }
 
-int stgt_cmnd_queue(struct stgt_cmnd *cmnd, uint8_t *id_buff, int buff_size,
-		    void (*done)(struct stgt_cmnd *))
+int stgt_cmnd_queue(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
 {
 	struct stgt_work *work;
 	struct stgt_session *session = cmnd->session;
-	struct tgt_protocol *proto = session->target->proto;
 
-	dprintk("%p %x\n", cmnd, cmnd->scb[0]);
-
 	assert(!cmnd->done);
 	cmnd->done = done;
 	if (!done) {
@@ -863,7 +872,6 @@
 	if (!work)
 		return -ENOMEM;
 
-	proto->prep_cmnd(cmnd, id_buff, buff_size);
 	stgt_queue_work(session->target, work);
 
 	return 0;

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-08 02:42:42 UTC (rev 57)
+++ trunk/kernel/stgt.h	2005-09-09 06:56:37 UTC (rev 58)
@@ -1,5 +1,6 @@
 /*
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
 
@@ -24,10 +25,6 @@
 	uint64_t dev_id;
 	uint64_t cid;
 
-	/*
-	 * TODO allocate this as protocol specific data
-	 */
-	uint8_t scb[MAX_COMMAND_SIZE];
 	int rw;
 
 	void (*done) (struct stgt_cmnd *);
@@ -46,6 +43,7 @@
 	 * target driver private
 	 */
 	void *private;
+	void *tgt_protocol_private;
 };
 
 extern struct stgt_session *
@@ -54,13 +52,14 @@
 		    void (*done)(void *, struct stgt_session *), void *arg);
 extern int stgt_session_destroy(struct stgt_session *session);
 
-extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session);
+extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
+					  uint8_t *proto_data,
+					  uint8_t *id_buff, int buff_size);
 extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
 extern void __stgt_alloc_buffer(struct stgt_cmnd *cmnd);
 extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
-			   uint8_t *lun, int lun_len,
 			   void (*done)(struct stgt_cmnd *));
 extern int stgt_sysfs_init(void);
 extern void stgt_sysfs_exit(void);

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-08 02:42:42 UTC (rev 57)
+++ trunk/kernel/tgt_protocol.h	2005-09-09 06:56:37 UTC (rev 58)
@@ -16,12 +16,14 @@
 	struct module *module;
 
 	int priv_cmd_data_size;
+	int uspace_pdu_size;
+
 	/*
 	 * perform command preparation, such as setting the rw field
 	 * and dev_id
 	 */
-	void (* prep_cmnd)(struct stgt_cmnd *cmd, uint8_t *id_buff,
-			   int buff_size);
+	void (* init_cmnd)(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+			   uint8_t *id_buff, int buff_size);
 	/*
 	 * setup buffer fields like offset and len
 	 */
@@ -30,6 +32,8 @@
 	 * process completion of a command
 	 */
 	void (* cmnd_done)(struct stgt_cmnd *cmd, int err);
+
+	void (* build_uspace_pdu)(struct stgt_cmnd *cmnd, void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-08 02:42:42 UTC (rev 57)
+++ trunk/kernel/tgt_scsi.c	2005-09-09 06:56:37 UTC (rev 58)
@@ -12,6 +12,11 @@
 #include <stgt.h>
 #include <tgt_protocol.h>
 
+struct scsi_tgt_cmnd {
+	uint8_t scb[MAX_COMMAND_SIZE];
+	int tags;
+};
+
 /*
  * we should be able to use scsi-ml's functions for this
  */
@@ -37,7 +42,8 @@
 
 static void scsi_tgt_init_cmnd_buffer(struct stgt_cmnd *cmnd)
 {
-	uint8_t *scb = cmnd->scb;
+	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
+	uint8_t *scb = scsi_tgt_cmnd->scb;
 	uint64_t off = 0;
 	uint32_t len = 0;
 
@@ -74,11 +80,14 @@
 	cmnd->offset = off;
 }
 
-static void scsi_tgt_prep_cmnd(struct stgt_cmnd *cmnd, uint8_t *id_buff,
-			       int buff_size)
+static void scsi_tgt_init_cmnd(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+			       uint8_t *id_buff, int buff_size)
 {
-	uint8_t *scb = cmnd->scb;
+	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
+	uint8_t *scb = scsi_tgt_cmnd->scb;
 
+	memcpy(scb, proto_data, sizeof(scsi_tgt_cmnd->scb));
+
 	/* set operation */
 	switch (scb[0]) {
 	case READ_6:
@@ -162,12 +171,22 @@
 		cmnd->result = SAM_STAT_GOOD;
 }
 
+void scsi_tgt_build_uspace_pdu(struct stgt_cmnd *cmnd, void *data)
+{
+	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
+
+	memcpy(data, scsi_tgt_cmnd->scb, sizeof(scsi_tgt_cmnd->scb));
+}
+
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
+	.init_cmnd = scsi_tgt_init_cmnd,
 	.init_cmnd_buffer = scsi_tgt_init_cmnd_buffer,
-	.prep_cmnd = scsi_tgt_prep_cmnd,
 	.cmnd_done = scsi_tgt_cmnd_done,
+	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
+	.priv_cmd_data_size = sizeof(struct scsi_tgt_cmnd),
+	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 
 static int __init scsi_tgt_init(void)



From tomo at berlios.de  Fri Sep  9 08:58:14 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 08:58:14 +0200
Subject: [Stgt-svn] r59 - trunk/iscsi/kernel
Message-ID: <200509090658.j896wELY030341@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 08:58:13 +0200 (Fri, 09 Sep 2005)
New Revision: 59

Modified:
   trunk/iscsi/kernel/iscsi.c
Log:
Make IET compatible with the latest stgt interface.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-09 06:56:37 UTC (rev 58)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-09 06:58:13 UTC (rev 59)
@@ -82,8 +82,6 @@
 	if (req) {
 		assert(conn->session);
 		assert(conn->session->sts);
-		cmnd->stc = stgt_cmnd_create(conn->session->sts);
-		assert(cmnd->stc);
 	}
 
 	dprintk(D_GENERIC, "%p:%p\n", conn, cmnd);
@@ -712,7 +710,6 @@
 	if (stc->result != SAM_STAT_GOOD) {
 		struct iscsi_cmnd *rsp;
 
-		eprintk("%p %d %x\n", stc, stc->result, stc->scb[0]);
 		rsp = do_create_sense_rsp(cmnd);
 		iscsi_cmnd_init_write(rsp);
 		return;
@@ -759,8 +756,7 @@
 	} else {
 		set_cmnd_waitio(cmnd);
 		cmnd->stc->private = cmnd;
-		stgt_cmnd_queue(cmnd->stc, cmnd_hdr(cmnd)->lun,
-				sizeof(cmnd_hdr(cmnd)->lun), scsi_cmnd_done);
+		stgt_cmnd_queue(cmnd->stc, scsi_cmnd_done);
 	}
 }
 
@@ -847,7 +843,10 @@
 
 	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
-	memcpy(req->stc->scb, req_hdr->cdb, sizeof(req->stc->scb));
+	req->stc = stgt_cmnd_create(conn->session->sts, req_hdr->cdb,
+				    req_hdr->lun,
+				    sizeof(req_hdr->lun));
+	assert(req->stc);
 
 	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
@@ -1285,8 +1284,6 @@
 	if (!cmnd)
 		return;
 
-/* 	eprintk("%x %lx %d\n", cmnd_opcode(cmnd), cmnd->flags, force); */
-
 	req = cmnd->req;
 	is_last = cmnd_final(cmnd);
 



From tomo at berlios.de  Fri Sep  9 09:07:21 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 09:07:21 +0200
Subject: [Stgt-svn] r60 - trunk/iscsi/usr
Message-ID: <200509090707.j8977LwA031797@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 09:07:20 +0200 (Fri, 09 Sep 2005)
New Revision: 60

Removed:
   trunk/iscsi/usr/isns.c
   trunk/iscsi/usr/isns.h
Modified:
   trunk/iscsi/usr/Makefile
   trunk/iscsi/usr/ietd.c
   trunk/iscsi/usr/iscsid.h
Log:
Kill iSNS code in IET.

Modified: trunk/iscsi/usr/Makefile
===================================================================
--- trunk/iscsi/usr/Makefile	2005-09-09 06:58:13 UTC (rev 59)
+++ trunk/iscsi/usr/Makefile	2005-09-09 07:07:20 UTC (rev 60)
@@ -4,7 +4,7 @@
 
 all: $(PROGRAMS)
 
-ietd: ietd.o iscsid.o conn.o session.o target.o message.o ctldev.o log.o isns.o chap.o event.o param.o plain.o
+ietd: ietd.o iscsid.o conn.o session.o target.o message.o ctldev.o log.o chap.o event.o param.o plain.o
 
 	$(CC) $^ -o $@ $(LIBS)
 

Modified: trunk/iscsi/usr/ietd.c
===================================================================
--- trunk/iscsi/usr/ietd.c	2005-09-09 06:58:13 UTC (rev 59)
+++ trunk/iscsi/usr/ietd.c	2005-09-09 07:07:20 UTC (rev 60)
@@ -51,7 +51,6 @@
 	{"config", required_argument, 0, 'c'},
 	{"foreground", no_argument, 0, 'f'},
 	{"debug", required_argument, 0, 'd'},
-	{"isns", required_argument, 0, 's'},
 	{"uid", required_argument, 0, 'u'},
 	{"gid", required_argument, 0, 'g'},
 	{"version", no_argument, 0, 'v'},
@@ -75,7 +74,6 @@
 		printf("\
   -f, --foreground        make the program run in the foreground\n\
   -d, --debug debuglevel  print debugging information\n\
-  -s, --isns=[ip]         work with isns server, default is disabled\n\
   -u, --uid=uid           run as uid, default is current user\n\
   -g, --gid=gid           run as gid, default is current user group\n\
   -h, --help              display this help and exit\n\
@@ -376,11 +374,10 @@
 {
 	int ch, longindex;
 	char *config = NULL;
-	char isns_ip[32];
 	uid_t uid = 0;
 	gid_t gid = 0;
 
-	while ((ch = getopt_long(argc, argv, "c:fd:s:u:g:vh", long_options, &longindex)) >= 0) {
+	while ((ch = getopt_long(argc, argv, "c:fd:u:g:vh", long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'c':
 			config = optarg;
@@ -391,11 +388,6 @@
 		case 'd':
 			log_level = atoi(optarg);
 			break;
-		case 's':
-			memset(isns_ip, 0, sizeof(isns_ip));
-			strncpy(isns_ip, optarg, sizeof(isns_ip));
-			use_isns = 1;
-			break;
 		case 'u':
 			uid = strtoul(optarg, NULL, 10);
 			break;
@@ -464,12 +456,6 @@
 		setsid();
 	}
 
-	if (use_isns) {
-		if (initialize_iet_isns(isns_ip,
-					ISCSI_LISTEN_PORT) < 0)
-			use_isns = 0;
-	}
-
 	cops->init(config);
 
 	if (uid && setuid(uid) < 0)
@@ -480,9 +466,5 @@
 
 	event_loop();
 
-	if (use_isns) {
-		cleanup_iet_isns();
-	}
-
 	return 0;
 }

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-09 06:58:13 UTC (rev 59)
+++ trunk/iscsi/usr/iscsid.h	2005-09-09 07:07:20 UTC (rev 60)
@@ -131,9 +131,6 @@
 
 #define INCOMING_BUFSIZE	8192
 
-/* isns */
-struct storage_node;
-
 struct target {
 	struct qelem tlist;
 
@@ -220,20 +217,6 @@
 extern int session_conns_close(u32 tid, u64 sid);
 extern int server_stop(void);
 
-
-/* isns.c */
-struct tag_len_val;
-struct network_entity;
-extern int initialize_iet_isns(char *isnsip, int port);
-extern void cleanup_iet_isns(void);
-extern struct storage_node *initialize_storage_node(char *name, char *alias);
-extern void cleanup_storage_node(struct storage_node *node);
-extern int RegNode(struct storage_node *node);
-extern int DeRegNode(struct storage_node *node);
-extern int use_isns;
-extern int get_portal_address(char *ip);
-extern int DeRegEntity(struct network_entity *entity, struct tag_len_val *name);
-
 /* event.c */
 extern void handle_iscsi_events(int fd);
 extern int nl_open(void);

Deleted: trunk/iscsi/usr/isns.c
===================================================================
--- trunk/iscsi/usr/isns.c	2005-09-09 06:58:13 UTC (rev 59)
+++ trunk/iscsi/usr/isns.c	2005-09-09 07:07:20 UTC (rev 60)
@@ -1,720 +0,0 @@
-/*
- * Implementation for iSCSI iSNS support.
- * (C) 2004 Ming Zhang <mingz at ele.uri.edu>
- * This code is licenced under the GPL.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <net/if.h>
-#include <sys/ioctl.h>
-
-#include "isns.h"
-#include "iscsid.h"
-
-static int cur_transaction_id = 0;
-int sock_fd = -1;
-int use_tcp = 1;
-int isns_port = ISNS_PORT;
-int use_isns = 0;
-
-struct network_entity *iet_entity = NULL;
-struct portal *iet_portal = NULL;
-
-/*
- * wrapper to hide the TCP or UDP detail. currently we use TCP only
- */
-int send_data(char *buf, int size)
-{
-	int i = 0;
-
-	if (sock_fd == -1) {
-		log_error("Wrong sock.\n");
-		return -EINVAL;
-	}
-	do {
-		buf += i;
-		if ((i = send(sock_fd, buf, size, 0)) == -1) {
-			log_error("Send data fail\n");
-			return -EIO;
-		}
-		size -= i;
-		if (size < 0) {
-			log_error("What's wrong? \n");
-			return -EIO;
-		}
-	} while (size);
-	return 0;
-}
-
-/*
- * wrapper to hide the TCP or UDP detail currently we use TCP only
- */
-int recv_data(char *buf, int size)
-{
-	int i = 0;
-
-	if (sock_fd == -1) {
-		log_error("Wrong sock.\n");
-		return -EINVAL;
-	}
-	if ((i = recv(sock_fd, buf, size, 0)) == -1) {
-		log_error("Recv data fail\n");
-		return -EIO;
-	}
-	return i;
-}
-
-int init_isns_connection(int *fd, char *isnsip)
-{
-	struct sockaddr_in isns_addr;
-	struct in_addr isns_in_addr;
-
-	if (use_tcp) {
-		if ((*fd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
-			log_error("fail to create socket\n");
-			return -EIO;
-		}
-		isns_addr.sin_family = AF_INET;
-		isns_addr.sin_port = htons((short)isns_port);
-		if (!inet_aton(isnsip, &isns_in_addr)) {
-			log_error("invalid isns ip\n");
-			return -EINVAL;
-		}
-		isns_addr.sin_addr.s_addr = isns_in_addr.s_addr;
-		if (connect(*fd, (struct sockaddr *) &isns_addr, sizeof (isns_addr)) < 0) {
-			log_error("fail to connect isns server\n");
-			return -EIO;
-		}
-	}
-	else {
-		log_error("Unimplemented yet\n");
-		return -EINVAL;
-	}
-	return 0;
-}
-
-void cleanup_connection(int fd)
-{
-	close(fd);
-}
-
-int send_pdu(struct isns_pdu *pdu, int pdu_size)
-{
-	/* FIXME: Lock protection */
-	return send_data((char *)pdu->hdr, pdu_size);
-}
-
-int send_cmd(struct isns_cmd *cmd)
-{
-	return send_pdu(&cmd->pdu, cmd->cmd_size);
-}
-
-int recv_resp(struct isns_resp *resp, int function_id)
-{
-	int res;
-
-	resp->resp_size = recv_data((char *)resp->pdu.hdr, MAX_ISNS_RESP_SIZE);
-	log_debug(1, "recv %d\n", resp->resp_size);
-	if (check_isns_hdr(resp->pdu.hdr, function_id)) {
-		log_error("Invalid pdu hdr\n");
-		return -EIO;
-	}
-	if ((res = check_isns_resp_status(&resp->pdu)) != ISNSP_RSP_SUCC) {
-		log_error("fail request %d with status code %d\n", function_id, res);
-		return -1;
-	}
-	return 0;
-}
-
-void init_tvllist(TLVLIST *p, int count)
-{
-	int i;
-
-	if (count > MAX_TLV_CNT) {
-		log_error("Invalid tlv count\n");
-		return;
-	}
-	for (i = 0; i < count; i++) {
-		p->tlv[i].attr_tag = INVALID_TAG;
-		p->tlv[i].attr_len = NULL_SIZE;
-		memset(p->tlv[i].attr_val, 0, MAX_TLV_VALUE_LEN);
-	}
-}
-
-char *append_tlv(char *cur_buf, const struct tag_len_val *tlv)
-{
-	if (!cur_buf) {
-		log_error("Invalid cur_buf in append_tlv\n");
-		return cur_buf;
-	}
-	if (!tlv) {
-		log_error("Invalid NULL tlv in append_tlv\n");
-		return cur_buf;
-	}
-	if (tlv->attr_tag == INVALID_TAG)
-		return cur_buf;
-
-	if (tlv->attr_tag == ATTR_TAG_EID)
-		log_debug(2, "attach EID: %ld,%s\n", tlv->attr_len, tlv->attr_val);
-
-	*((u32 *)cur_buf) = htonl(tlv->attr_tag);
-	*((u32 *)cur_buf + 1) = htonl(tlv->attr_len);
-	if (tlv->attr_len)
-		memcpy(cur_buf + 8, (char *)tlv->attr_val, tlv->attr_len);
-	return (cur_buf + tlv->attr_len + 8);
-}
-
-int set_tlv_u32_data(struct tag_len_val *tvl, u32 data, u32 tag, long size)
-{
-	if (!tvl)
-		return -EINVAL;
-
-	/* keep tag and length in host order while data in network order */
-	tvl->attr_tag = tag;
-	tvl->attr_len = size;
-	*(u32 *)tvl->attr_val = htonl(data);
-	return 0;
-}
-
-int set_tlv_ip_data(struct tag_len_val *tvl, char *ip, u32 tag, long size)
-{
-	struct in_addr portal_ip;
-
-	tvl->attr_tag = tag;
-	tvl->attr_len = size;
-
-	if (inet_aton(ip, &portal_ip)) {
-		*((u32 *)tvl->attr_val) = 0x0;
-		*((u32 *)tvl->attr_val + 1) = 0x0;
-		*((u32 *)tvl->attr_val + 2) = htonl(0xFFFF);
-		*((u32 *)tvl->attr_val + 3) = portal_ip.s_addr;
-		return 0;
-	}
-	else {
-		log_error("invalid ip\n");
-		return -EINVAL;
-	}
-}
-
-int set_tlv_string_data(struct tag_len_val *tvl, char *data, u16 tag, int maxlen)
-{
-	tvl->attr_tag = tag;
-	tvl->attr_len = (data) ? Four_Bytes_Aligned(strlen(data)) : 0;
-	if (tvl->attr_len > maxlen) {
-		log_error("Wrong size of string data\n");
-		return -EINVAL;
-	}
-	else {
-		if (tvl->attr_len) {
-			memset(tvl->attr_val, 0, tvl->attr_len);
-			strcpy(tvl->attr_val, data);
-		}
-		return 0;
-	}
-}
-
-#define init_network_entity(x) init_tvllist((TLVLIST *)x, 9)
-#define set_tlv_entity_id(x, y) 		\
-	set_tlv_string_data(x, y, ATTR_TAG_EID, ATTR_TAG_EID_SIZE)
-#define set_tlv_entity_proto(x, y)	\
-	set_tlv_u32_data(x, y, ATTR_TAG_ENTITY_PROTO, ATTR_TAG_ENTITY_PROTO_SIZE)
-#define set_tlv_manage_ip(x, y)	\
-	set_tlv_ip_data(x, y, ATTR_TAG_MANA_IP_ADDR, ATTR_TAG_MANA_IP_ADDR_SIZE)
-
-#define init_storage_node(x) init_tvllist((TLVLIST *)x, 8)
-#define set_tlv_iscsi_name(x, y) 		\
-	set_tlv_string_data(x, y, ATTR_TAG_ISCSI_NAME, ATTR_TAG_ISCSI_NAME_SIZE)
-#define set_tlv_iscsi_alias(x, y) 		\
-	set_tlv_string_data(x, y, ATTR_TAG_ISCSI_ALIAS, ATTR_TAG_ISCSI_ALIAS_SIZE)
-#define set_tlv_iscsi_auth_method(x, y) 		\
-	set_tlv_string_data(x, y, ATTR_TAG_ISCSI_AUTH_METHOD, ATTR_TAG_ISCSI_AUTH_METHOD_SIZE)
-#define set_tlv_iscsi_node_type(x, y)	\
-	set_tlv_u32_data(x, 1UL << (31 - (y)), ATTR_TAG_NODE_TYPE, ATTR_TAG_NODE_TYPE_SIZE)
-
-#define init_portal(x) init_tvllist((TLVLIST *)x, 11)
-#define set_tlv_portal_ip(x, y)	\
-	set_tlv_ip_data(x, y, ATTR_TAG_PORTAL_IP_ADDR, ATTR_TAG_PORTAL_IP_ADDR_SIZE)
-#define set_tlv_portal_port(x, y)	\
-	set_tlv_u32_data(x, y, ATTR_TAG_PORTAL_PORT, ATTR_TAG_PORTAL_PORT_SIZE)
-
-#define init_portal_group(x) init_tvllist((TLVLIST *)x, 5)
-#define set_tlv_pg_iscsi_name(x, y)	\
-	set_tlv_string_data(x, y, ATTR_TAG_PG_ISCSI_NAME, ATTR_TAG_PG_ISCSI_NAME_SIZE)
-#define set_tlv_pg_portal_ip(x, y)	\
-	set_tlv_ip_data(x, y, ATTR_TAG_PG_PORTAL_IP_ADDR, ATTR_TAG_PG_PORTAL_IP_ADDR_SIZE)
-#define set_tlv_pg_portal_port(x, y)	\
-	set_tlv_u32_data(x, y, ATTR_TAG_PG_PORTAL_PORT, ATTR_TAG_PG_PORTAL_PORT_SIZE)
-#define set_tlv_pg_tag(x, y)	\
-	set_tlv_u32_data(x, y, ATTR_TAG_PG_TAG, ATTR_TAG_PG_TAG_SIZE)
-
-#define init_discovery_domain(x) init_tvllist((TLVLIST *)x, 8)
-#define init_discovery_domain_set(x) init_tvllist((TLVLIST *)x, 3)
-
-int initialize_iet_entity(struct network_entity *entity)
-{
-	init_network_entity(entity);
-	set_tlv_entity_proto(&entity->entity_proto, EP_ISCSI);
-	return set_tlv_entity_id(&entity->eid, NULL);
-}
-
-int initialize_iet_portal(int port)
-{
-	int err;
-	int fd;
-	struct ifreq ifr;
-	int i;
-	struct portal *p;
-
-	fd = socket(PF_INET, SOCK_DGRAM, 0);
-	if (fd < 0) {
-		log_error("Can not create socket \n");
-		return -EIO;
-	}
-
-	for (i = 0; i < 8; i++) {
-		sprintf(ifr.ifr_name, "eth%d", i);
-		ifr.ifr_addr.sa_family = AF_INET;
-		if (ioctl(fd, SIOCGIFADDR, &ifr) == 0) {
-			if (!(p = (struct portal *)malloc(sizeof(struct portal)))) {
-				log_error("can not get memory for portal\n");
-				err = -ENOMEM;
-				break;
-			}
-			set_tlv_portal_ip(&p->portal_ip_addr, inet_ntoa(((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr));
-			set_tlv_portal_port(&p->portal_port, port);
-			p->next = iet_portal;
-			iet_portal = p;
-		}
-		else {
-			log_error("fail to get ip address for eth%d\n", i);
-			break;
-		}
-	}
-	close(fd);
-	return 0;
-}
-
-int initialize_iet_isns(char *isnsip, int port)
-{
-	int err;
-	struct portal *p;
-
-	/*
-	 * FIXME: currently only support one entity and one portal.
-	 */
-	if (!(iet_entity = (struct network_entity *)malloc(sizeof(struct network_entity)))) {
-		log_error("can not get memory for iet_entity\n");
-		return -ENOMEM;
-	}
-	if ((err = initialize_iet_entity(iet_entity)))
-		goto fail;
-	if ((err = initialize_iet_portal(port)))
-		goto fail;
-	if ((err = init_isns_connection(&sock_fd, isnsip)))
-		goto fail;
-	return 0;
-fail:
-	if (iet_entity)
-		free(iet_entity);
-	while (iet_portal) {
-		p = iet_portal->next;
-		free(iet_portal);
-		iet_portal = p;
-	};
-	return err;
-}
-
-void cleanup_iet_isns(void)
-{
-	struct portal *p;
-
-	cleanup_connection(sock_fd);
-	if (iet_entity)
-		free(iet_entity);
-	while (iet_portal) {
-		p = iet_portal->next;
-		free(iet_portal);
-		iet_portal = p;
-	};
-}
-
-void get_next_transaction_id(u16 *transaction_id)
-{
-	/* FIXME: Lock protection */
-	*transaction_id = cur_transaction_id++;
-}
-
-void get_cur_transaction_id(u16 *transaction_id)
-{
-	/* FIXME: Lock protection */
-	*transaction_id = cur_transaction_id;
-}
-
-struct isns_cmd *allocate_isns_cmd(void)
-{
-	struct isns_cmd *cmd;
-
-	if (!(cmd = (struct isns_cmd*)malloc(sizeof(struct isns_cmd))))
-		return NULL;
-	if (!(cmd->pdu.hdr = (struct isns_hdr *)malloc(MAX_ISNS_CMD_SIZE))) {
-		free(cmd);
-		return NULL;
-	}
-	cmd->pdu.pay_load = (((char *)cmd->pdu.hdr) + ISNS_HDR_LEN);
-	cmd->pdu.authentication_block = NULL;
-	cmd->cmd_size = ISNS_HDR_LEN;
-
-	return cmd;
-}
-
-void free_isns_cmd(struct isns_cmd *cmd)
-{
-	if (cmd->pdu.authentication_block)
-		free(cmd->pdu.authentication_block);
-	if (cmd->pdu.hdr)
-		free(cmd->pdu.hdr);
-	free(cmd);
-}
-
-struct isns_resp *allocate_isns_resp(void)
-{
-	struct isns_resp *resp;
-
-	if (!(resp = (struct isns_resp*)malloc(sizeof(struct isns_resp))))
-		return NULL;
-	if (!(resp->pdu.hdr = (struct isns_hdr *)malloc(MAX_ISNS_RESP_SIZE))) {
-		free(resp);
-		return NULL;
-	}
-	resp->pdu.pay_load = (((char *)resp->pdu.hdr) + ISNS_HDR_LEN);
-	resp->pdu.authentication_block = NULL;
-
-	return resp;
-}
-
-void free_isns_resp(struct isns_resp *resp)
-{
-	if (resp->pdu.authentication_block)
-		free(resp->pdu.authentication_block);
-	if (resp->pdu.hdr)
-		free(resp->pdu.hdr);
-	free(resp);
-}
-
-void init_isns_hdr(struct isns_hdr *hdr, int function_id, int replace)
-{
-	hdr->isnsp_version = htons((u16)ISNSP_VERSION);
-	hdr->function_id = htons((u16)function_id);
-	hdr->pdu_length = 0;
-	hdr->flags = 0;
-	/* always use one PDU for one command we send */
-	set_bit_first_pdu(hdr->flags);
-	set_bit_last_pdu(hdr->flags);
-	set_bit_sender_client(hdr->flags);
-	if (replace)
-		set_bit_replace(hdr->flags);
-	hdr->flags = htons((u16)hdr->flags);
-	get_next_transaction_id(&hdr->transaction_id);
-	hdr->transaction_id = htons((u16)hdr->transaction_id);
-	hdr->sequence_id = 0;
-}
-
-int check_isns_hdr(struct isns_hdr *hdr, int function_id)
-{
-	if (ntohs(hdr->isnsp_version) != ISNSP_VERSION)
-		return -EINVAL;
-	if (ntohs(hdr->function_id) != function_id)
-		return -EINVAL;
-	/* TODO: more check here */
-	return 0;
-}
-
-int check_isns_resp_status(struct isns_pdu *pdu)
-{
-	int status = ntohl(*(u32 *)pdu->pay_load);
-
-	log_debug(1, "return status code %d\n", status);
-	return status;
-}
-
-/* DD related functions */
-int RegDD(void)
-{
-	return -EPERM;
-}
-
-int DeRegDD(void)
-{
-	return -EPERM;
-}
-
-/* DDS related functions */
-int RegDDS(void)
-{
-	return -EPERM;
-}
-
-int DeRegDDS(void)
-{
-	return -EPERM;
-}
-
-/* Entity related functions */
-int RegEntity(void)
-{
-	return -EPERM;
-}
-
-int DeRegEntity(struct network_entity *entity, struct tag_len_val *name)
-{
-	struct isns_cmd *cmd;
-	struct isns_pdu *pdu;
-	struct isns_resp *resp = NULL;
-	char *buf;
-
-	if (!entity) {
-		log_error("Null entity to deregister.\n");
-		return -EINVAL;
-	}
-
-	if (!(cmd = allocate_isns_cmd())) {
-		log_error("allocate isns cmd fail\n");
-		return -ENOMEM;
-	}
-	pdu = &cmd->pdu;
-	init_isns_hdr(pdu->hdr, FUNC_DevDeReg, NO_REPLACE);
-	buf = pdu->pay_load;
-	buf = append_tlv(buf, name);
-	buf = append_tlv(buf, &delimiter);
-	buf = append_tlv(buf, &entity->eid);
-
-	cmd->cmd_size = buf - (char *)pdu->hdr;
-	pdu->hdr->pdu_length = htons((u16)(buf - (char *)pdu->pay_load));
-
-	if (send_cmd(cmd)) {
-		log_error("fail to send isns cmd\n");
-		return -EIO;
-	}
-	if (!(resp = allocate_isns_resp())) {
-		log_error("allocate isns resp fail\n");
-		return -ENOMEM;
-	}
-	recv_resp(resp, FUNC_DevDeRegRsp);
-	free_isns_resp(resp);
-
-	return 0;
-}
-
-int QryEntity(void)
-{
-	return -EPERM;
-}
-
-int UpdateEntity(void)
-{
-	return -EPERM;
-}
-
-/* Node related functions */
-struct storage_node *initialize_storage_node(char *name, char* alias)
-{
-	struct storage_node *p;
-
-	if (!(p = (struct storage_node *)malloc(sizeof(struct storage_node)))) {
-		log_error("fail to get memory for storage node\n");
-		return NULL;
-	}
-	init_storage_node(p);
-
-	set_tlv_iscsi_name(&p->iscsi_name, name);
-	set_tlv_iscsi_node_type(&p->iscsi_node_type, NODE_TYPE_TARGET);
-	set_tlv_iscsi_alias(&p->iscsi_alias, alias);
-	return p;
-}
-
-void cleanup_storage_node(struct storage_node *node)
-{
-	free(node);
-}
-
-int RegNode(struct storage_node *node)
-{
-	struct isns_cmd *cmd;
-	struct isns_pdu *pdu;
-	struct isns_resp *resp = NULL;
-	char *buf;
-	struct portal *p;
-
-	if (!node) {
-		log_error("Null storage node to register.\n");
-		return -EINVAL;
-	}
-	if (!(cmd = allocate_isns_cmd())) {
-		log_error("allocate isns cmd fail\n");
-		return -ENOMEM;
-	}
-	pdu = &cmd->pdu;
-	init_isns_hdr(pdu->hdr, FUNC_DevAttrReg, NO_REPLACE);
-	buf = pdu->pay_load;
-	buf = append_tlv(buf, &node->iscsi_name);
-	buf = append_tlv(buf, &delimiter);
-	/* FIXME: assume one entity now */
-	buf = append_tlv(buf, &iet_entity->eid);
-	buf = append_tlv(buf, &iet_entity->entity_proto);
-
-	for (p = iet_portal; p ; p = p->next) {
-		buf = append_tlv(buf, &p->portal_ip_addr);
-		buf = append_tlv(buf, &p->portal_port);
-	}
-	buf = append_tlv(buf, &node->iscsi_name);
-	buf = append_tlv(buf, &node->iscsi_node_type);
-	buf = append_tlv(buf, &node->iscsi_alias);
-	buf = append_tlv(buf, &node->iscsi_auth_method);
-
-	cmd->cmd_size = buf - (char *)pdu->hdr;
-	pdu->hdr->pdu_length = htons((u16)(buf - (char *)pdu->pay_load));
-
-	if (send_cmd(cmd)) {
-		log_error("fail to send isns cmd\n");
-		free_isns_cmd(cmd);
-		return -EIO;
-	}
-	free_isns_cmd(cmd);
-
-	if (!(resp = allocate_isns_resp())) {
-		log_error("allocate isns resp fail\n");
-		return -ENOMEM;
-	}
-	if (recv_resp(resp, FUNC_DevAttrRegRsp)) {
-		free_isns_resp(resp);
-		return -EIO;
-	}
-	if ((ntohl(*((u32 *)resp->pdu.pay_load + 1)) == ATTR_TAG_EID) &&
-					!iet_entity->eid.attr_len) {
-		// get assigned EID from iSNS server
-		iet_entity->eid.attr_len = ntohl(*((u32 *)resp->pdu.pay_load + 2));
-		memcpy(iet_entity->eid.attr_val, resp->pdu.pay_load + 8,
-					ntohl(*((u32 *)resp->pdu.pay_load + 2)));
-		log_debug(1, "new eid info, %ld, %s\n", iet_entity->eid.attr_len,
-					iet_entity->eid.attr_val);
-	}
-	free_isns_resp(resp);
-	return 0;
-}
-
-int DeRegNode(struct storage_node *node)
-{
-	struct isns_cmd *cmd;
-	struct isns_pdu *pdu;
-	struct isns_resp *resp = NULL;
-	char *buf;
-
-	if (!node) {
-		log_error("Null storage node to deregister.\n");
-		return -EINVAL;
-	}
-
-	if (!(cmd = allocate_isns_cmd())) {
-		log_error("allocate isns cmd fail\n");
-		return -ENOMEM;
-	}
-	pdu = &cmd->pdu;
-	init_isns_hdr(pdu->hdr, FUNC_DevDeReg, NO_REPLACE);
-	buf = pdu->pay_load;
-	buf = append_tlv(buf, &node->iscsi_name);
-	buf = append_tlv(buf, &delimiter);
-	/* iscsi name can be as an operating attr for dereg */
-	//buf = append_tlv(buf, &iet_entity->eid);
-	buf = append_tlv(buf, &node->iscsi_name);
-
-	cmd->cmd_size = buf - (char *)pdu->hdr;
-	pdu->hdr->pdu_length = htons((u16)(buf - (char *)pdu->pay_load));
-
-	if (send_cmd(cmd)) {
-		log_error("fail to send isns cmd\n");
-		return -EIO;
-	}
-	if (!(resp = allocate_isns_resp())) {
-		log_error("allocate isns resp fail\n");
-		return -ENOMEM;
-	}
-	recv_resp(resp, FUNC_DevDeRegRsp);
-	free_isns_resp(resp);
-
-	return 0;
-}
-
-int QryNode(void)
-{
-	return -EPERM;
-}
-
-int UpdateNode(void)
-{
-	return -EPERM;
-}
-
-/* Portal related functions */
-int RegPortal(void)
-{
-	return -EPERM;
-}
-
-int DeRegPortal(struct portal *p, struct tag_len_val *name)
-{
-	struct isns_cmd *cmd;
-	struct isns_pdu *pdu;
-	struct isns_resp *resp = NULL;
-	char *buf;
-
-	if (!p) {
-		log_error("Null portal to deregister.\n");
-		return -EINVAL;
-	}
-
-	if (!(cmd = allocate_isns_cmd())) {
-		log_error("allocate isns cmd fail\n");
-		return -ENOMEM;
-	}
-	pdu = &cmd->pdu;
-	init_isns_hdr(pdu->hdr, FUNC_DevDeReg, NO_REPLACE);
-	buf = pdu->pay_load;
-	buf = append_tlv(buf, name);
-	buf = append_tlv(buf, &delimiter);
-	buf = append_tlv(buf, &p->portal_ip_addr);
-	buf = append_tlv(buf, &p->portal_port);
-
-	cmd->cmd_size = buf - (char *)pdu->hdr;
-	pdu->hdr->pdu_length = htons((u16)(buf - (char *)pdu->pay_load));
-
-	if (send_cmd(cmd)) {
-		log_error("fail to send isns cmd\n");
-		return -EIO;
-	}
-	if (!(resp = allocate_isns_resp())) {
-		log_error("allocate isns resp fail\n");
-		return -ENOMEM;
-	}
-	recv_resp(resp, FUNC_DevDeRegRsp);
-	free_isns_resp(resp);
-
-	return 0;
-}
-
-int QryPortal(void)
-{
-	return -EPERM;
-}
-
-int UpdatePortal(void)
-{
-	return -EPERM;
-}

Deleted: trunk/iscsi/usr/isns.h
===================================================================
--- trunk/iscsi/usr/isns.h	2005-09-09 06:58:13 UTC (rev 59)
+++ trunk/iscsi/usr/isns.h	2005-09-09 07:07:20 UTC (rev 60)
@@ -1,413 +0,0 @@
-/*
- * Defines for iSCSI iSNS support.
- * (C) 2004 Ming Zhang <mingz at ele.uri.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __ISNS__
-#define __ISNS__
-
-#include "types.h"
-
-/* iSNSP version */
-#define ISNSP_VERSION		0x0001
-
-#define ISNS_PORT		3205
-
-/* Entity Protocol */
-#define EP_NO_PROTOCOL		1
-#define EP_ISCSI		2
-#define EP_IFCP			3
-
-/* Node type bit position */
-#define NODE_TYPE_CONTROL	29
-#define NODE_TYPE_INI		30
-#define NODE_TYPE_TARGET	31
-
-/* iSCSI Auth Method */
-#define ISCSI_AUTH_KB5		"KB5"
-#define ISCSI_AUTH_SPKM1	"SPKM1"
-#define ISCSI_AUTH_SPKM2	"SPKM2"
-#define ISCSI_AUTH_SRP		"SRP"
-#define ISCSI_AUTH_CHAP		"CHAP"
-
-/* DDS Status Enable/Disable */
-#define DDS_STATUS_BIT		31
-
-/* DD Feature */
-#define DDS_BOOT_BIT		31
-
-/* iSNSP Function ID */
-#define FUNC_DevAttrReg		0x0001
-#define FUNC_DevAttrQry		0x0002
-#define FUNC_DevGetNext		0x0003
-#define FUNC_DevDeReg		0x0004
-#define FUNC_SCNReg		0x0005
-#define FUNC_SCNDeReg		0x0006
-#define FUNC_SCNEvent		0x0007
-#define FUNC_SCN		0x0008
-#define FUNC_DDReg		0x0009
-#define FUNC_DDDeReg		0x000A
-#define FUNC_DDSReg		0x000B
-#define FUNC_DDSDeReg		0x000C
-#define FUNC_ESI		0x000D
-#define FUNC_Heartbeat		0x000E
-
-#define FUNC_DevAttrRegRsp	0x8001
-#define FUNC_DevAttrQryRsp	0x8002
-#define FUNC_DevGetNextRsp	0x8003
-#define FUNC_DevDeRegRsp	0x8004
-#define FUNC_SCNRegRsp		0x8005
-#define FUNC_SCNDeRegRsp	0x8006
-#define FUNC_SCNEventRsp	0x8007
-#define FUNC_SCNRsp		0x8008
-#define FUNC_DDRegRsp		0x8009
-#define FUNC_DDDeRegRsp		0x800A
-#define FUNC_DDSRegRsp		0x800B
-#define FUNC_DDSDeRegRsp	0x800C
-#define FUNC_ESIRsp		0x800D
-
-/* All iSNSP Flags */
-#define LSB				31
-#define ISNSP_FLAGS_SENDER_CLIENT	16
-#define ISNSP_FLAGS_SENDER_SERVER	17
-#define ISNSP_FLAGS_AUTHEN_BLOCK	18
-#define ISNSP_FLAGS_REPLACE		19
-#define ISNSP_FLAGS_LAST_PDU		20
-#define ISNSP_FLAGS_FIRST_PDU		21
-
-#define set_bit_sender_client(x)	(x) |= (1 << (LSB - ISNSP_FLAGS_SENDER_CLIENT))
-#define clear_bit_sender_client(x)	(x) &= ~(1 << (LSB - ISNSP_FLAGS_SENDER_CLIENT))
-#define set_bit_sender_server(x)	(x) |= (1 << (LSB - ISNSP_FLAGS_SENDER_SERVER))
-#define clear_bit_sender_server(x)	(x) &= ~(1 << (LSB - ISNSP_FLAGS_SENDER_SERVER))
-#define set_bit_authen_block(x)		(x) |= (1 << (LSB - ISNSP_FLAGS_AUTHEN_BLOCK))
-#define clear_bit_authen_block(x)	(x) &= ~(1 << (LSB - ISNSP_FLAGS_AUTHEN_BLOCK))
-#define set_bit_replace(x)		(x) |= (1 << (LSB - ISNSP_FLAGS_REPLACE))
-#define clear_bit_replace(x)		(x) &= ~(1 << (LSB - ISNSP_FLAGS_REPLACE))
-#define set_bit_last_pdu(x)		(x) |= (1 << (LSB - ISNSP_FLAGS_LAST_PDU))
-#define clear_bit_last_pdu(x)		(x) &= ~(1 << (LSB - ISNSP_FLAGS_LAST_PDU))
-#define set_bit_first_pdu(x)		(x) |= (1 << (LSB - ISNSP_FLAGS_FIRST_PDU))
-#define clear_bit_first_pdu(x)		(x) &= ~(1 << (LSB - ISNSP_FLAGS_FIRST_PDU))
-
-/* ALL iSNSP Response Status Code */
-#define ISNSP_RSP_SUCC				0
-#define ISNSP_RSP_UNKNOWN			1
-#define ISNSP_RSP_MSG_FORMAT_ERR 		2
-#define ISNSP_RSP_INVAL_REG			3
-#define ISNSP_RSP_INVAL_QRY			5
-#define ISNSP_RSP_SRC_UNKNOWN			6
-#define ISNSP_RSP_SRC_ABSENT			7
-#define ISNSP_RSP_SRC_UNAUTH			8
-#define ISNSP_RSP_NO_SUCH_ENTRY			9
-#define ISNSP_RSP_VERSION_NOT_SUP		10
-#define ISNSP_RSP_INTERNAL_ERR			11
-#define ISNSP_RSP_BUSY				12
-#define ISNSP_RSP_OPT_NOT_UNDERSTOOD		13
-#define ISNSP_RSP_INVAL_UPDATE			14
-#define ISNSP_RSP_MSG_NOT_SUP			15
-#define ISNSP_RSP_SCN_EVENT_REJ			16
-#define ISNSP_RSP_SCN_REG_REJ			17
-#define ISNSP_RSP_ATTR_UNIMPL			18
-#define ISNSP_RSP_FC_DOMAIN_ID_NOT_AVA		19
-#define ISNSP_RSP_FC_DOMAIN_ID_NOT_ALL		20
-#define ISNSP_RSP_ESI_NOT_AVA			21
-#define ISNSP_RSP_INVAL_DEREG			22
-#define ISNSP_RSP_REG_FEAT_NOT_SUP		23
-
-/* attribute tag */
-#define INVALID_TAG				0xFFFF
-#define ATTR_TAG_DELIMITER			0
-#define ATTR_TAG_EID				1
-#define ATTR_TAG_ENTITY_PROTO			2
-#define ATTR_TAG_MANA_IP_ADDR			3
-#define ATTR_TAG_TIMESTAMP			4
-#define ATTR_TAG_PROTO_VER_RANGE		5
-#define ATTR_TAG_REG_PERIOD			6
-#define ATTR_TAG_ENTITY_INDEX			7
-#define ATTR_TAG_ENTITY_NEXT_INDEX		8
-#define ATTR_TAG_ENTITY_ISAKMP_PHASE		11
-#define ATTR_TAG_ENTITY_CERT			12
-#define ATTR_TAG_PORTAL_IP_ADDR			16
-#define ATTR_TAG_PORTAL_PORT			17
-#define ATTR_TAG_PORTAL_SYM_NAME		18
-#define ATTR_TAG_ESI_INTERVAL			19
-#define ATTR_TAG_ESI_PORT			20
-#define ATTR_TAG_PORTAL_INDEX			22
-#define ATTR_TAG_SCN_PORT			23
-#define ATTR_TAG_PORTAL_NEXT_INDEX		24
-#define ATTR_TAG_PORTAL_SEC_BITM		27
-#define ATTR_TAG_PORTAL_ISAKMP_PHASE1		28
-#define ATTR_TAG_PORTAL_ISAKMP_PHASE2		29
-#define ATTR_TAG_PORTAL_CERT			31
-#define ATTR_TAG_ISCSI_NAME			32
-#define ATTR_TAG_NODE_TYPE			33
-#define ATTR_TAG_ISCSI_ALIAS			34
-#define ATTR_TAG_ISCSI_SCN_BITM			35
-#define ATTR_TAG_ISCSI_NODE_INDEX		36
-#define ATTR_TAG_WWNN_TOKEN			37
-#define ATTR_TAG_ISCSI_NODE_NEXT_INDEX		38
-#define ATTR_TAG_ISCSI_AUTH_METHOD		42
-#define ATTR_TAG_PG_ISCSI_NAME			48
-#define ATTR_TAG_PG_PORTAL_IP_ADDR		49
-#define ATTR_TAG_PG_PORTAL_PORT			50
-#define ATTR_TAG_PG_TAG				51
-#define ATTR_TAG_PG_INDEX			52
-#define ATTR_TAG_PG_NEXT_INDEX			53
-#define ATTR_TAG_FC_PORT_NAME_WWPN		64
-#define ATTR_TAG_PORT_ID			65
-#define ATTR_TAG_FC_PORT_TYPE			66
-#define ATTR_TAG_SYM_PORT_NAME			67
-#define ATTR_TAG_FABRIC_PORT_NAME		68
-#define ATTR_TAG_HARD_ADDR			69
-#define ATTR_TAG_PORT_IP_ADDR			70
-#define ATTR_TAG_CLASS_OF_SERVICE		71
-#define ATTR_TAG_FC_4_TYPE			72
-#define ATTR_TAG_FC_4_DESC			73
-#define ATTR_TAG_FC_4_FEATURE			74
-#define ATTR_TAG_IFCP_SCN_BITM			75
-#define ATTR_TAG_PORT_ROLE			76
-#define ATTR_TAG_PERM_PORT_NAME			77
-#define ATTR_TAG_FC_4_TYPE_CODE			95
-#define ATTR_TAG_FC_NODE_NAME_WWNN		96
-#define ATTR_TAG_SYM_NODE_NAME			97
-#define ATTR_TAG_NODE_IP_ADDR			98
-#define ATTR_TAG_NODE_IPA			99
-#define ATTR_TAG_PROXY_ISCSI_NAME		101
-#define ATTR_TAG_SWITCH_NAME			128
-#define ATTR_TAG_PREFERRED_ID			129
-#define ATTR_TAG_ASSIGNED_ID			130
-#define ATTR_TAG_VIRT_FABRIC_ID			132
-#define ATTR_TAG_ISNS_SERV_VENDOR_OUI		256
-#define ATTR_TAG_DD_SET_ID			2049
-#define ATTR_TAG_DD_SET_SYM_NAME		2050
-#define ATTR_TAG_DD_SET_STATUS			2051
-#define ATTR_TAG_DD_SET_NEXT_ID			2052
-#define ATTR_TAG_DD_ID				2065
-#define ATTR_TAG_DD_SYM_NAME			2066
-#define ATTR_TAG_DD_MEMBER_ISCSI_INDEX		2067
-#define ATTR_TAG_DD_MEMBER_ISCSI_NAME		2068
-#define ATTR_TAG_DD_MEMBER_FC_PORT_NAME		2069
-#define ATTR_TAG_DD_MEMBER_PORTAL_INDEX		2070
-#define ATTR_TAG_DD_MEMBER_PORTAL_ADDR		2071
-#define ATTR_TAG_DD_MEMBER_PORTAL_TCP		2072
-#define ATTR_TAG_DD_FEATURE			2078
-#define ATTR_TAG_DD_ID_NEXT_ID			2079
-
-/* attribute maximum possible length */
-#define NULL_SIZE				-2
-#define VAR_SIZE				-1
-#define ATTR_TAG_DELIMITER_SIZE			0
-#define ATTR_TAG_EID_SIZE			256
-#define ATTR_TAG_ENTITY_PROTO_SIZE		4
-#define ATTR_TAG_MANA_IP_ADDR_SIZE		16
-#define ATTR_TAG_TIMESTAMP_SIZE			8
-#define ATTR_TAG_PROTO_VER_RANGE_SIZE		4
-#define ATTR_TAG_REG_PERIOD_SIZE		4
-#define ATTR_TAG_ENTITY_INDEX_SIZE		4
-#define ATTR_TAG_ENTITY_NEXT_INDEX_SIZE		4
-#define ATTR_TAG_ENTITY_ISAKMP_PHASE_SIZE	VAR_SIZE
-#define ATTR_TAG_ENTITY_CERT_SIZE		VAR_SIZE
-#define ATTR_TAG_PORTAL_IP_ADDR_SIZE		16
-#define ATTR_TAG_PORTAL_PORT_SIZE		4
-#define ATTR_TAG_PORTAL_SYM_NAME_SIZE		256
-#define ATTR_TAG_ESI_INTERVAL_SZIE		4
-#define ATTR_TAG_ESI_PORT_SIZE			4
-#define ATTR_TAG_PORTAL_INDEX_SIZE		4
-#define ATTR_TAG_SCN_PORT_SIZE			4
-#define ATTR_TAG_PORTAL_NEXT_INDEX_SIZE		4
-#define ATTR_TAG_PORTAL_SEC_BITM_SIZE		4
-#define ATTR_TAG_PORTAL_ISAKMP_PHASE1_SIZE	VAR_SIZE
-#define ATTR_TAG_PORTAL_ISAKMP_PHASE2_SIZE	VAR_SIZE
-#define ATTR_TAG_PORTAL_CERT_SIZE		VAR_SIZE
-#define ATTR_TAG_ISCSI_NAME_SIZE		224
-#define ATTR_TAG_NODE_TYPE_SIZE			4
-#define ATTR_TAG_ISCSI_ALIAS_SIZE		256
-#define ATTR_TAG_ISCSI_SCN_BITM_SIZE		4
-#define ATTR_TAG_ISCSI_NODE_INDEX_SIZE		4
-#define ATTR_TAG_WWNN_TOKEN_SIZE		8
-#define ATTR_TAG_ISCSI_NODE_NEXT_INDEX_SIZE	4
-#define ATTR_TAG_ISCSI_AUTH_METHOD_SIZE		VAR_SIZE
-#define ATTR_TAG_PG_ISCSI_NAME_SIZE		224
-#define ATTR_TAG_PG_PORTAL_IP_ADDR_SIZE		16
-#define ATTR_TAG_PG_PORTAL_PORT_SIZE		4
-#define ATTR_TAG_PG_TAG_SIZE			4
-#define ATTR_TAG_PG_INDEX_SIZE			4
-#define ATTR_TAG_PG_NEXT_INDEX_SIZE		4
-#define ATTR_TAG_FC_PORT_NAME_WWPN_SIZE		8
-#define ATTR_TAG_PORT_ID_SIZE			4
-#define ATTR_TAG_FC_PORT_TYPE_SIZE		4
-#define ATTR_TAG_SYM_PORT_NAME_SIZE		256
-#define ATTR_TAG_FABRIC_PORT_NAME_SIZE		8
-#define ATTR_TAG_HARD_ADDR_SIZE			4
-#define ATTR_TAG_PORT_IP_ADDR_SIZE		16
-#define ATTR_TAG_CLASS_OF_SERVICE_SIZE		4
-#define ATTR_TAG_FC_4_TYPE_SIZE			32
-#define ATTR_TAG_FC_4_DESC_SIZE			256
-#define ATTR_TAG_FC_4_FEATURE_SIZE		128
-#define ATTR_TAG_IFCP_SCN_BITM_SIZE		4
-#define ATTR_TAG_PORT_ROLE_SIZE			4
-#define ATTR_TAG_PERM_PORT_NAME_SIZE		8
-#define ATTR_TAG_FC_4_TYPE_CODE_SIZE		4
-#define ATTR_TAG_FC_NODE_NAME_WWNN_SIZE		8
-#define ATTR_TAG_SYM_NODE_NAME_SIZE		256
-#define ATTR_TAG_NODE_IP_ADDR_SIZE		16
-#define ATTR_TAG_NODE_IPA_SIZE			8
-#define ATTR_TAG_PROXY_ISCSI_NAME_SIZE		256
-#define ATTR_TAG_SWITCH_NAME_SIZE		8
-#define ATTR_TAG_PREFERRED_ID_SIZE		4
-#define ATTR_TAG_ASSIGNED_ID_SIZE		4
-#define ATTR_TAG_VIRT_FABRIC_ID_SIZE		256
-#define ATTR_TAG_ISNS_SERV_VENDOR_OUI_SIZE	4
-#define ATTR_TAG_DD_SET_ID_SIZE			4
-#define ATTR_TAG_DD_SET_SYM_NAME_SIZE		256
-#define ATTR_TAG_DD_SET_STATUS_SIZE		4
-#define ATTR_TAG_DD_SET_NEXT_ID_SIZE		4
-#define ATTR_TAG_DD_ID_SIZE			4
-#define ATTR_TAG_DD_SYM_NAME_SIZE		256
-#define ATTR_TAG_DD_MEMBER_ISCSI_INDEX_SIZE	4
-#define ATTR_TAG_DD_MEMBER_ISCSI_NAME_SIZE	224
-#define ATTR_TAG_DD_MEMBER_FC_PORT_NAME_SIZE	224
-#define ATTR_TAG_DD_MEMBER_PORTAL_INDEX_SIZE	4
-#define ATTR_TAG_DD_MEMBER_PORTAL_ADDR_SIZE	16
-#define ATTR_TAG_DD_MEMBER_PORTAL_TCP_SIZE	4
-#define ATTR_TAG_DD_FEATURE_SIZE		4
-#define ATTR_TAG_DD_ID_NEXT_ID_SIZE		4
-
-#define REPLACE		1
-#define NO_REPLACE	0
-
-/* Be sure this number is still enough */
-#define MAX_ISNS_CMD_SIZE	4096
-#define MAX_ISNS_RESP_SIZE	4096
-
-/*
- * maximum tlv value length, for current implementation is enough 
- * if really need a larger size, then reallocate a memory and cast
- * the first 4 bytes of attr_val to point to it.
- */
-#define MAX_TLV_VALUE_LEN	256
-
-#define Four_Bytes_Aligned(x)	((((x) + 3) >> 2) << 2)
-
-struct tag_len_val {
-	u32 attr_tag;
-	long attr_len;
-	char attr_val[MAX_TLV_VALUE_LEN];
-};
-
-struct network_entity {
-	struct tag_len_val eid;
-	struct tag_len_val entity_proto;
-	struct tag_len_val mana_ip_addr;
-	struct tag_len_val timestamp;
-	struct tag_len_val proto_ver_range;
-	struct tag_len_val reg_period;
-	struct tag_len_val entity_index;
-	struct tag_len_val entity_isakmp_phase;
-	struct tag_len_val entity_cert;
-	struct network_entity *next;
-};
-
-struct portal {
-	struct tag_len_val portal_ip_addr;
-	struct tag_len_val portal_port;
-	struct tag_len_val portal_sym_name;
-	struct tag_len_val esi_interval;
-	struct tag_len_val esi_port;
-	struct tag_len_val portal_index;
-	struct tag_len_val scn_port;
-	struct tag_len_val portal_sec_bitm;
-	struct tag_len_val portal_isakmp_phase1;
-	struct tag_len_val portal_isakmp_phase2;
-	struct tag_len_val portal_cert;
-	struct portal *next;
-};
-
-struct portal_group {
-	struct tag_len_val pg_iscsi_name;
-	struct tag_len_val pg_ip_addr;
-	struct tag_len_val pg_portal_port;
-	struct tag_len_val pg_tag;
-	struct tag_len_val pg_index;
-	struct portal_group *next;
-};
-
-struct storage_node {
-	struct tag_len_val iscsi_name;
-	struct tag_len_val iscsi_node_type;
-	struct tag_len_val iscsi_alias;
-	struct tag_len_val iscsi_scn_bitm;
-	struct tag_len_val iscsi_node_index;
-	struct tag_len_val wwnn_token;
-	struct tag_len_val iscsi_auth_method;
-	struct tag_len_val iscsi_node_cert;
-	struct storage_node *next;
-};
-
-struct discovery_domain {
-	struct tag_len_val dd_id;
-	struct tag_len_val dd_sym_name;
-	struct tag_len_val dd_member_iscsi_index;
-	struct tag_len_val dd_member_iscsi_name;
-	struct tag_len_val dd_member_portal_index;
-	struct tag_len_val dd_member_portal_ip_addr;
-	struct tag_len_val dd_member_portal_port;
-	struct tag_len_val dd_feature;
-	struct discovery_domain *next;
-};
-
-struct discovery_domain_set {
-	struct tag_len_val dds_id;
-	struct tag_len_val dds_sym_name;
-	struct tag_len_val dds_status;
-	struct discovery_domain_set *next;
-};
-
-#define MAX_TLV_CNT		11
-
-typedef union  {
-	struct network_entity ne;
-	struct portal p;
-	struct portal_group pg;
-	struct storage_node node;
-	struct discovery_domain dd;
-	struct discovery_domain_set dds;
-	struct tag_len_val tlv[MAX_TLV_CNT];
-} TLVLIST;
-
-struct tag_len_val delimiter = {ATTR_TAG_DELIMITER, ATTR_TAG_DELIMITER_SIZE};
-
-struct isns_hdr {
-	u16 isnsp_version;
-	u16 function_id;
-	u16 pdu_length;
-	u16 flags;
-	u16 transaction_id;
-	u16 sequence_id;
-};
-
-#define ISNS_HDR_LEN	sizeof(struct isns_hdr)
-
-struct isns_pdu {
-	struct isns_hdr *hdr;
-	char *pay_load;
-	char *authentication_block;
-};
-
-/*
- * currently we only use one pdu for one cmd.
- */
-struct isns_cmd {
-	struct isns_pdu pdu;
-	u32 cmd_size;
-};
-
-struct isns_resp {
-	struct isns_pdu pdu;
-	u32 resp_size;
-};
-
-int check_isns_hdr(struct isns_hdr *hdr, int function_id);
-int check_isns_resp_status(struct isns_pdu *pdu);
-
-#endif



From tomo at berlios.de  Fri Sep  9 09:33:16 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 09:33:16 +0200
Subject: [Stgt-svn] r61 - trunk/usr
Message-ID: <200509090733.j897XGsK003199@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 09:33:14 +0200 (Fri, 09 Sep 2005)
New Revision: 61

Modified:
   trunk/usr/ipc.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/stgtd.c
Log:
Add Mike's Copyright to user-space code.

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-09 07:07:20 UTC (rev 60)
+++ trunk/usr/ipc.c	2005-09-09 07:33:14 UTC (rev 61)
@@ -2,6 +2,7 @@
  * Unix domain socket for ipc
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This code is licenced under the GPL.
  */

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-09 07:07:20 UTC (rev 60)
+++ trunk/usr/netlink.c	2005-09-09 07:33:14 UTC (rev 61)
@@ -1,5 +1,6 @@
 /*
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  *
  * Netlink functions are based on open-iscsi code
  * written by Dmitry Yusupov and Alex Aizman.

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-09 07:07:20 UTC (rev 60)
+++ trunk/usr/scsi.c	2005-09-09 07:33:14 UTC (rev 61)
@@ -2,9 +2,11 @@
  * SCSI command processing
  *
  * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  *
- * heavily based on code from kernel/iscsi.c:
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
  *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
  *   licensed under the terms of the GNU GPL v2.0,
  */

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-09-09 07:07:20 UTC (rev 60)
+++ trunk/usr/stgtd.c	2005-09-09 07:33:14 UTC (rev 61)
@@ -1,8 +1,8 @@
 /*
- * SCSI target framework user-space daemon
+ * Core target framework user-space daemon
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- *
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
 



From tomo at berlios.de  Fri Sep  9 12:17:21 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 12:17:21 +0200
Subject: [Stgt-svn] r62 - trunk/kernel
Message-ID: <200509091017.j89AHLvc016357@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 12:17:20 +0200 (Fri, 09 Sep 2005)
New Revision: 62

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/tgt_scsi.c
Log:
Change the way to handle sense data.
But I'm not really sure what's the best way to handle it.


Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-09 07:33:14 UTC (rev 61)
+++ trunk/kernel/stgt.c	2005-09-09 10:17:20 UTC (rev 62)
@@ -720,7 +720,6 @@
 		len -= sg->length;
 	}
 }
-EXPORT_SYMBOL_GPL(__stgt_alloc_buffer);
 
 static void stgt_alloc_buffer(void *data)
 {
@@ -786,24 +785,20 @@
 	return netlink_unicast(nls, skb, daemon_pid, 0);
 }
 
-static void cmnd_done(struct stgt_cmnd *cmnd)
+static void cmnd_done(struct stgt_cmnd *cmnd, int result)
 {
+	struct stgt_target *target = cmnd->session->target;
+	struct tgt_protocol *proto = target->proto;
 	void (*done)(struct stgt_cmnd *);
 
+	proto->cmnd_done(cmnd, result);
+	cmnd->result = result;
+
 	done = cmnd->done;
 	cmnd->done = NULL;
 	done(cmnd);
 }
 
-static void kspace_cmnd_done(struct stgt_cmnd *cmnd, int result)
-{
-	struct stgt_target *target = cmnd->session->target;
-	struct tgt_protocol *proto = target->proto;
-
-	proto->cmnd_done(cmnd, result);
-	cmnd_done(cmnd);
-}
-
 static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data,
 			     int result, uint32_t len)
 {
@@ -825,8 +820,7 @@
 		}
 	}
 
-	cmnd->result = result;
-	cmnd_done(cmnd);
+	cmnd_done(cmnd, result);
 }
 
 static void queuecommand(void *data)
@@ -850,10 +844,11 @@
 			return;
 	}
 
+	/* kspace command failure or failed to send commands to space. */
 	if (unlikely(err))
 		eprintk("failed cmnd %llu %d %d\n", cmnd->cid, err, cmnd->rw);
 
-	kspace_cmnd_done(cmnd, err);
+	cmnd_done(cmnd, err);
 }
 
 int stgt_cmnd_queue(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-09 07:33:14 UTC (rev 61)
+++ trunk/kernel/stgt.h	2005-09-09 10:17:20 UTC (rev 62)
@@ -39,10 +39,15 @@
 
 	int result;
 
+	/* TODO: there should be a better way. */
+	uint8_t *error_buff;
+	int error_buff_len;
+
 	/*
 	 * target driver private
 	 */
 	void *private;
+
 	void *tgt_protocol_private;
 };
 
@@ -56,7 +61,6 @@
 					  uint8_t *proto_data,
 					  uint8_t *id_buff, int buff_size);
 extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
-extern void __stgt_alloc_buffer(struct stgt_cmnd *cmnd);
 extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-09 07:33:14 UTC (rev 61)
+++ trunk/kernel/tgt_scsi.c	2005-09-09 10:17:20 UTC (rev 62)
@@ -14,6 +14,7 @@
 
 struct scsi_tgt_cmnd {
 	uint8_t scb[MAX_COMMAND_SIZE];
+	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
 	int tags;
 };
 
@@ -112,27 +113,31 @@
 static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq)
 {
-	int i, len = 8, alen = 6;
-	uint8_t *data;
+	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
+	int len = 8, alen = 6;
+	uint8_t *data = scsi_tgt_cmnd->sense_buff;
 
-	/* It works, however, dirty. */
-	for (i = 0; i < cmnd->sg_count; i++)
-		__free_page(cmnd->sg[i].page);
-	kfree(cmnd->sg);
+	memset(data, 0, sizeof(scsi_tgt_cmnd->sense_buff));
 
-	cmnd->bufflen = len + alen;
-	cmnd->offset = 0;
+	if (cmnd->rw == READ || cmnd->rw == WRITE) {
+		/* kspace command failure */
 
-	__stgt_alloc_buffer(cmnd);
-	data = page_address(cmnd->sg[0].page);
-	clear_page(data);
+		data[0] = 0x70 | 1U << 7;
+		data[2] = key;
+		data[7] = alen;
+		data[12] = ascode;
+		data[13] = ascodeq;
+	} else {
+		/* uspace command failure */
 
-	data[0] = 0x70 | 1U << 7;
-	data[2] = key;
-	data[7] = alen;
-	data[12] = ascode;
-	data[13] = ascodeq;
+		len = min(cmnd->bufflen, sizeof(scsi_tgt_cmnd->sense_buff));
+		alen = 0;
+		memcpy(data, page_address(cmnd->sg[0].page), len);
+	}
 
+	cmnd->error_buff = data;
+	cmnd->error_buff_len = len + alen;
+
 	return len + alen;
 }
 



From tomo at berlios.de  Fri Sep  9 12:18:40 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 12:18:40 +0200
Subject: [Stgt-svn] r63 - trunk/iscsi/kernel
Message-ID: <200509091018.j89AIefp016402@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 12:18:39 +0200 (Fri, 09 Sep 2005)
New Revision: 63

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
Log:
Make IET compatible with stgt's new way to handle sense data.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-09 10:17:20 UTC (rev 62)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-09 10:18:39 UTC (rev 63)
@@ -264,7 +264,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
-	struct scatterlist *sg = req->stc->sg;
+	struct scatterlist *sg = &req->sense_sg;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
@@ -275,12 +275,13 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	sense = (struct iscsi_sense_data *) page_address(sg[0].page);
-	memmove(sense->data, sense, req->stc->bufflen);
-	sense->length = cpu_to_be16(req->stc->bufflen);
+	sense = (struct iscsi_sense_data *) req->stc->error_buff;
+	memmove(sense->data, sense, req->stc->error_buff_len);
+	sense->length = cpu_to_be16(req->stc->error_buff_len);
 
-	req->stc->bufflen += sizeof(struct iscsi_sense_data);
-	sg->length = req->stc->bufflen;
+	sg->page = virt_to_page(req->stc->error_buff);
+	sg->offset = offset_in_page(req->stc->error_buff);
+	sg->length = req->stc->error_buff_len + sizeof(struct iscsi_sense_data);
 	rsp->pdu.datasize = sg->length;
 	rsp->sg = sg;
 
@@ -293,7 +294,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
-	struct scatterlist *sg;
+	struct scatterlist *sg = &req->sense_sg;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
@@ -304,21 +305,11 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	assert(req->stc);
-	assert(!req->stc->sg);
+	sg->page = virt_to_page(req->stc->error_buff);
+	sg->offset = offset_in_page(req->stc->error_buff);
+	sg->length = req->stc->error_buff_len;
 
-	/* TODO: really needs cleanups. */
-	req->stc->bufflen = sizeof(struct iscsi_sense_data) + 14;
-	req->stc->sg_count = 1;
-	req->stc->sg = sg =
-		kmalloc(sizeof(struct scatterlist *), __GFP_NOFAIL | GFP_KERNEL);
-
-	sg->page = alloc_page(__GFP_NOFAIL | GFP_KERNEL);
-	sg->offset = 0;
-	sg->length = req->stc->bufflen;
-
-	sense = (struct iscsi_sense_data *) page_address(sg[0].page);
-	clear_page(sense);
+	sense = (struct iscsi_sense_data *) req->stc->error_buff;
 	sense->length = cpu_to_be16(14);
 	sense->data[0] = 0xf0;
 	sense->data[2] = sense_key;

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-09 10:17:20 UTC (rev 62)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-09 10:18:39 UTC (rev 63)
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/crypto.h>
 #include <net/sock.h>
+#include <asm/scatterlist.h>
 
 #include "iscsi_proto.h"
 #include "iet_u.h"
@@ -179,7 +180,7 @@
 
 	struct list_head hash_list;
 
-	struct scatterlist *sg;
+	struct scatterlist *sg, sense_sg;
 
 	u32 r2t_sn;
 	u32 r2t_length;



From tomo at berlios.de  Fri Sep  9 16:14:27 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 9 Sep 2005 16:14:27 +0200
Subject: [Stgt-svn] r64 - trunk/iscsi/include
Message-ID: <200509091414.j89EER3r018338@sheep.berlios.de>

Author: tomo
Date: 2005-09-09 16:14:27 +0200 (Fri, 09 Sep 2005)
New Revision: 64

Modified:
   trunk/iscsi/include/iet_u.h
Log:
Trivial cleanup of unused IET parameters.

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-09 10:18:39 UTC (rev 63)
+++ trunk/iscsi/include/iet_u.h	2005-09-09 14:14:27 UTC (rev 64)
@@ -102,10 +102,6 @@
 
 #define NETLINK_IET	21
 
-#define ADD_TARGET _IOW('i', 0, struct target_info)
-#define DEL_TARGET _IOW('i', 1, struct target_info)
-#define START_TARGET _IO('i', 2)
-#define STOP_TARGET _IO('i', 3)
 #define ADD_SESSION _IOW('i', 6, struct session_info)
 #define DEL_SESSION _IOW('i', 7, struct session_info)
 #define GET_SESSION_INFO _IOWR('i', 8, struct session_info)



From tomo at berlios.de  Mon Sep 12 02:20:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Mon, 12 Sep 2005 02:20:13 +0200
Subject: [Stgt-svn] r68 - in trunk: . include iscsi/kernel iscsi/usr kernel usr
Message-ID: <200509120020.j8C0KDYW001076@sheep.berlios.de>

Author: tomo
Date: 2005-09-12 02:20:00 +0200 (Mon, 12 Sep 2005)
New Revision: 68

Added:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Removed:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_target.h
   trunk/kernel/stgt_vsd.c
   trunk/usr/stgtd.c
   trunk/usr/stgtd.h
Modified:
   trunk/initd
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/session.c
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/Makefile
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/usr/Makefile
   trunk/usr/ipc.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Rename all stgt stuff to tgt.

Deleted: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/include/stgt_if.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,65 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * This code is licenced under the GPL.
- */
-
-#ifndef __SCSI_TARGET_IF_H
-#define __SCSI_TARGET_IF_H
-
-#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
-
-enum stgt_event_type {
-	/* user -> kernel */
-	STGT_UEVENT_START,
-	STGT_UEVENT_TARGET_CREATE,
-	STGT_UEVENT_TARGET_DESTROY,
-	STGT_UEVENT_DEVICE_CREATE,
-	STGT_UEVENT_DEVICE_DESTROY,
-	STGT_UEVENT_CMND_RES,
-
-	/* kernel -> user */
-	STGT_KEVENT_RESPONSE,
-	STGT_KEVENT_CMND_REQ,
-};
-
-struct stgt_event {
-	/* user-> kernel */
-	union {
-		struct {
-			char type[32];
-			int nr_cmnds;
-		} c_target;
-		struct {
-			int tid;
-		} d_target;
-		struct {
-			int tid;
-			uint64_t dev_id;
-			uint32_t flags;
-			char type[32];
-		} c_device;
-		struct {
-			int tid;
-			uint64_t dev_id;
-		} d_device;
-		struct {
-			uint64_t cid;
-			uint32_t len;
-			int result;
-		} cmnd_res;
-	} u;
-
-	/* kernel -> user */
-	union {
-		struct {
-			int err;
-		} event_res;
-		struct {
-			uint64_t cid;
-			int tid;
-			uint64_t dev_id;
-		} cmnd_req;
-	} k;
-};
-
-#endif

Copied: trunk/include/tgt_if.h (from rev 67, trunk/include/stgt_if.h)
===================================================================
--- trunk/include/stgt_if.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/include/tgt_if.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,66 @@
+/*
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#ifndef TARGET_FRAMEWORK_IF_H
+#define TARGET_FRAMEWORK_IF_H
+
+#define TGT_IPC_NAMESPACE "TGT_IPC_ABSTRACT_NAMESPACE"
+
+enum tgt_event_type {
+	/* user -> kernel */
+	TGT_UEVENT_START,
+	TGT_UEVENT_TARGET_CREATE,
+	TGT_UEVENT_TARGET_DESTROY,
+	TGT_UEVENT_DEVICE_CREATE,
+	TGT_UEVENT_DEVICE_DESTROY,
+	TGT_UEVENT_CMND_RES,
+
+	/* kernel -> user */
+	TGT_KEVENT_RESPONSE,
+	TGT_KEVENT_CMND_REQ,
+};
+
+struct tgt_event {
+	/* user-> kernel */
+	union {
+		struct {
+			char type[32];
+			int nr_cmnds;
+		} c_target;
+		struct {
+			int tid;
+		} d_target;
+		struct {
+			int tid;
+			uint64_t dev_id;
+			uint32_t flags;
+			char type[32];
+		} c_device;
+		struct {
+			int tid;
+			uint64_t dev_id;
+		} d_device;
+		struct {
+			uint64_t cid;
+			uint32_t len;
+			int result;
+		} cmnd_res;
+	} u;
+
+	/* kernel -> user */
+	union {
+		struct {
+			int err;
+		} event_res;
+		struct {
+			uint64_t cid;
+			int tid;
+			uint64_t dev_id;
+		} cmnd_req;
+	} k;
+};
+
+#endif

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/initd	2005-09-12 00:20:00 UTC (rev 68)
@@ -8,10 +8,10 @@
 
 start_server()
 {
-	insmod ${PWD}/kernel/stgt_core.ko
+	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/stgt_vsd.ko
-	${PWD}/usr/stgtd
+	insmod ${PWD}/kernel/tgt_vsd.ko
+	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
 	insmod ${PWD}/iscsi/kernel/iscsi_trgt.ko
@@ -21,13 +21,14 @@
 stop_server()
 {
 	${PWD}/iscsi/usr/ietadm --op delete
-	killall ietd
-	killall -9 stgtd
+	killall -9 ietd
+	killall -9 tgtd
+
 	rmmod iscsi_trgt
 
-	rmmod stgt_vsd
+	rmmod tgt_vsd
 	rmmod tgt_scsi
-	rmmod stgt_core
+	rmmod tgt_core
 }
 
 case "$1" in

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -12,8 +12,8 @@
 
 #include <iscsi.h>
 #include <iscsi_dbg.h>
-#include <stgt.h>
-#include <stgt_target.h>
+#include <tgt.h>
+#include <tgt_target.h>
 
 unsigned long debug_enable_flags;
 
@@ -81,7 +81,7 @@
 
 	if (req) {
 		assert(conn->session);
-		assert(conn->session->sts);
+		assert(conn->session->ts);
 	}
 
 	dprintk(D_GENERIC, "%p:%p\n", conn, cmnd);
@@ -160,7 +160,7 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_cmnd *data_cmnd;
-	struct scatterlist *sg = cmnd->stc->sg;
+	struct scatterlist *sg = cmnd->tc->sg;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
 	u32 pdusize, expsize, scsisize, size, offset, sn;
@@ -169,9 +169,9 @@
 	dprintk(D_GENERIC, "%p\n", cmnd);
 	pdusize = conn->session->param.max_xmit_data_length;
 	expsize = cmnd_read_size(cmnd);
-	assert(cmnd->stc);
-	size = min(expsize, cmnd->stc->bufflen);
-	eprintk("%u %u\n", expsize, cmnd->stc->bufflen);
+	assert(cmnd->tc);
+	size = min(expsize, cmnd->tc->bufflen);
+	eprintk("%u %u\n", expsize, cmnd->tc->bufflen);
 	offset = 0;
 	sn = 0;
 
@@ -193,7 +193,7 @@
 			rsp->flags = ISCSI_FLAG_CMD_FINAL |
 				     ISCSI_FLAG_DATA_STATUS;
 
-			scsisize = cmnd->stc->bufflen;
+			scsisize = cmnd->tc->bufflen;
 			if (scsisize < expsize) {
 				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 				size = expsize - scsisize;
@@ -275,13 +275,13 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	sense = (struct iscsi_sense_data *) req->stc->error_buff;
-	memmove(sense->data, sense, req->stc->error_buff_len);
-	sense->length = cpu_to_be16(req->stc->error_buff_len);
+	sense = (struct iscsi_sense_data *) req->tc->error_buff;
+	memmove(sense->data, sense, req->tc->error_buff_len);
+	sense->length = cpu_to_be16(req->tc->error_buff_len);
 
-	sg->page = virt_to_page(req->stc->error_buff);
-	sg->offset = offset_in_page(req->stc->error_buff);
-	sg->length = req->stc->error_buff_len + sizeof(struct iscsi_sense_data);
+	sg->page = virt_to_page(req->tc->error_buff);
+	sg->offset = offset_in_page(req->tc->error_buff);
+	sg->length = req->tc->error_buff_len + sizeof(struct iscsi_sense_data);
 	rsp->pdu.datasize = sg->length;
 	rsp->sg = sg;
 
@@ -305,11 +305,11 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	sg->page = virt_to_page(req->stc->error_buff);
-	sg->offset = offset_in_page(req->stc->error_buff);
-	sg->length = req->stc->error_buff_len;
+	sg->page = virt_to_page(req->tc->error_buff);
+	sg->offset = offset_in_page(req->tc->error_buff);
+	sg->length = req->tc->error_buff_len;
 
-	sense = (struct iscsi_sense_data *) req->stc->error_buff;
+	sense = (struct iscsi_sense_data *) req->tc->error_buff;
 	sense->length = cpu_to_be16(14);
 	sense->data[0] = 0xf0;
 	sense->data[2] = sense_key;
@@ -362,8 +362,8 @@
 	list_del(&cmnd->conn_list);
 	spin_unlock(&conn->list_lock);
 
-	if (cmnd->stc)
-		stgt_cmnd_destroy(cmnd->stc);
+	if (cmnd->tc)
+		tgt_cmnd_destroy(cmnd->tc);
 
 	kmem_cache_free(iscsi_cmnd_cache, cmnd);
 }
@@ -592,7 +592,7 @@
 	cmnd_skip_pdu(req);
 }
 
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct stgt_cmnd *stc,
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmnd *tc,
 			 u32 offset, u32 size)
 {
 	int idx, i;
@@ -601,17 +601,17 @@
 
 	dprintk(D_GENERIC, "%u,%u\n", offset, size);
 
-	assert(stc);
-	sg = stc->sg;
+	assert(tc);
+	sg = tc->sg;
 	offset += sg->offset;
 
-	if (!(offset < sg->offset + stc->bufflen) ||
-	    !(offset + size <= sg->offset + stc->bufflen)) {
-		eprintk("%u %u %u %u", offset, size, sg->offset, stc->bufflen);
+	if (!(offset < sg->offset + tc->bufflen) ||
+	    !(offset + size <= sg->offset + tc->bufflen)) {
+		eprintk("%u %u %u %u", offset, size, sg->offset, tc->bufflen);
 		return -EIO;
 	}
-	assert(offset < sg->offset + stc->bufflen);
-	assert(offset + size <= sg->offset + stc->bufflen);
+	assert(offset < sg->offset + tc->bufflen);
+	assert(offset + size <= sg->offset + tc->bufflen);
 
 	idx = offset >> PAGE_CACHE_SHIFT;
 	offset &= ~PAGE_CACHE_MASK;
@@ -693,12 +693,12 @@
 	iscsi_cmnds_init_write(&send);
 }
 
-static void scsi_cmnd_done(struct stgt_cmnd *stc)
+static void scsi_cmnd_done(struct tgt_cmnd *tc)
 {
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) stc->private;
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
-	if (stc->result != SAM_STAT_GOOD) {
+	if (tc->result != SAM_STAT_GOOD) {
 		struct iscsi_cmnd *rsp;
 
 		rsp = do_create_sense_rsp(cmnd);
@@ -746,8 +746,8 @@
 			send_r2t(cmnd);
 	} else {
 		set_cmnd_waitio(cmnd);
-		cmnd->stc->private = cmnd;
-		stgt_cmnd_queue(cmnd->stc, scsi_cmnd_done);
+		cmnd->tc->private = cmnd;
+		tgt_cmnd_queue(cmnd->tc, scsi_cmnd_done);
 	}
 }
 
@@ -834,10 +834,10 @@
 
 	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
-	req->stc = stgt_cmnd_create(conn->session->sts, req_hdr->cdb,
-				    req_hdr->lun,
-				    sizeof(req_hdr->lun));
-	assert(req->stc);
+	req->tc = tgt_cmnd_create(conn->session->ts, req_hdr->cdb,
+				   req_hdr->lun,
+				   sizeof(req_hdr->lun));
+	assert(req->tc);
 
 	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
@@ -880,7 +880,7 @@
 			cmnd_skip_data(req);
 		}
 
-		stgt_cmnd_alloc_buffer(req->stc, NULL);
+		tgt_cmnd_alloc_buffer(req->tc, NULL);
 
 		break;
 	}
@@ -906,10 +906,10 @@
 		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
 			eprintk("Verification is ignored %x\n", cmnd_itt(req));
 
-		stgt_cmnd_alloc_buffer(req->stc, NULL);
+		tgt_cmnd_alloc_buffer(req->tc, NULL);
 
 		if (req->pdu.datasize) {
-			if (cmnd_recv_pdu(conn, req->stc, 0, req->pdu.datasize) < 0)
+			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)
 				assert(0);
 		}
 		break;
@@ -966,7 +966,7 @@
 	dprintk(D_WRITE, "%u %p %p %u %u\n", req->ttt, cmnd, scsi_cmnd,
 		offset, cmnd->pdu.datasize);
 
-	if (cmnd_recv_pdu(conn, scsi_cmnd->stc, offset, cmnd->pdu.datasize) < 0)
+	if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, cmnd->pdu.datasize) < 0)
 		goto skip_data;
 	return;
 
@@ -991,7 +991,7 @@
 /* 		assert(scsi_cmnd->tio); */
 		offset = be32_to_cpu(req->offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
-		if (cmnd_recv_pdu(conn, scsi_cmnd->stc, offset, conn->read_overflow) < 0)
+		if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, conn->read_overflow) < 0)
 			assert(0);
 		return;
 	}
@@ -1559,7 +1559,7 @@
 	}
 }
 
-static struct stgt_target_template iet_stgt_target_template = {
+static struct tgt_target_template iet_tgt_target_template = {
 	.name = "iet",
 	.module = THIS_MODULE,
 	.protocol = "scsi",
@@ -1578,7 +1578,7 @@
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
 
-	stgt_target_template_unregister(&iet_stgt_target_template);
+	tgt_target_template_unregister(&iet_tgt_target_template);
 }
 
 static int iscsi_init(void)
@@ -1603,8 +1603,8 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-	iet_stgt_target_template.priv_data_size = sizeof(struct iscsi_target);
-	err = stgt_target_template_register(&iet_stgt_target_template);
+	iet_tgt_target_template.priv_data_size = sizeof(struct iscsi_target);
+	err = tgt_target_template_register(&iet_tgt_target_template);
 	if (err < 0)
 		goto err;
 

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -57,7 +57,7 @@
 };
 
 struct iscsi_cmnd;
-struct stgt_target;
+struct tgt_target;
 
 enum iscsi_device_state {
 	IDEV_RUNNING,
@@ -77,7 +77,7 @@
 
 	struct semaphore target_sem;
 
-	struct stgt_target *stt;
+	struct tgt_target *tt;
 };
 
 #define IET_HASH_ORDER		8
@@ -104,7 +104,7 @@
 
 	u32 next_ttt;
 
-	struct stgt_session *sts;
+	struct tgt_session *ts;
 };
 
 enum connection_state_bit {
@@ -192,7 +192,7 @@
 	u32 ddigest;
 
 	struct iscsi_cmnd *req;
-	struct stgt_cmnd *stc;
+	struct tgt_cmnd *tc;
 };
 
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD
@@ -227,8 +227,8 @@
 extern int target_lock(struct iscsi_target *, int);
 extern void target_unlock(struct iscsi_target *);
 struct iscsi_target *target_lookup_by_id(u32);
-extern int target_add(struct stgt_target *);
-extern void target_del(struct stgt_target *);
+extern int target_add(struct tgt_target *);
+extern void target_del(struct tgt_target *);
 
 /* config.c */
 extern int iet_procfs_init(void);

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/session.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -8,7 +8,7 @@
 
 #include <iscsi.h>
 #include <iscsi_dbg.h>
-#include <stgt.h>
+#include <tgt.h>
 
 struct iscsi_session *session_lookup(struct iscsi_target *target, u64 sid)
 {
@@ -59,7 +59,7 @@
 
 	list_add(&session->list, &target->session_list);
 
-	session->sts = stgt_session_create(target->stt, 64, NULL, NULL);
+	session->ts = tgt_session_create(target->tt, 64, NULL, NULL);
 
 	return 0;
 err:
@@ -99,7 +99,7 @@
 	list_del(&session->list);
 	kfree(session->initiator);
 
-	stgt_session_destroy(session->sts);
+	tgt_session_destroy(session->ts);
 	kfree(session);
 
 	return 0;

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/target.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -9,9 +9,9 @@
 #include <iscsi.h>
 #include <digest.h>
 #include <iscsi_dbg.h>
-#include <stgt.h>
-#include <stgt_device.h>
-#include <stgt_target.h>
+#include <tgt.h>
+#include <tgt_device.h>
+#include <tgt_target.h>
 
 #define	MAX_NR_TARGETS	(1UL << 30)
 
@@ -101,15 +101,15 @@
 	nthread_stop(target);
 }
 
-static int iscsi_target_create(struct stgt_target *stt)
+static int iscsi_target_create(struct tgt_target *tt)
 {
 	int err = -EINVAL;
 	struct iscsi_target *target =
-		(struct iscsi_target *) stt->stt_data;
+		(struct iscsi_target *) tt->tt_data;
 
 	memset(target, 0, sizeof(*target));
 
-	target->stt = stt;
+	target->tt = tt;
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
@@ -124,11 +124,11 @@
 	if (err < 0)
 		return err;
 
-	target->tid = target->stt->tid;
+	target->tid = target->tt->tid;
 	return 0;
 }
 
-int target_add(struct stgt_target *stt)
+int target_add(struct tgt_target *tt)
 {
 	int err = -EEXIST;
 
@@ -139,7 +139,7 @@
 		goto out;
 	}
 
-	if (!(err = iscsi_target_create(stt)))
+	if (!(err = iscsi_target_create(tt)))
 		nr_targets++;
 out:
 	up(&target_list_sem);
@@ -147,10 +147,10 @@
 	return err;
 }
 
-void target_del(struct stgt_target *stt)
+void target_del(struct tgt_target *tt)
 {
 	struct iscsi_target *target =
-		(struct iscsi_target *) stt->stt_data;
+		(struct iscsi_target *) tt->tt_data;
 
 	down(&target_list_sem);
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/usr/ctldev.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -20,7 +20,7 @@
 #include <linux/netlink.h>
 
 #include "iscsid.h"
-#include "stgt_if.h"
+#include "tgt_if.h"
 
 #define CTL_DEVICE	"/dev/ietctl"
 
@@ -181,7 +181,7 @@
 	int tid, err;
 	int32_t lun;
 
-	dir = opendir("/sys/class/stgt_device");
+	dir = opendir("/sys/class/tgt_device");
 	if (!dir)
 		return errno;
 
@@ -193,7 +193,7 @@
 
 	closedir(dir);
 
-	dir = opendir("/sys/class/stgt_target");
+	dir = opendir("/sys/class/tgt_target");
 	if (!dir)
 		return errno;
 
@@ -333,8 +333,8 @@
 {
 	int fd, err;
 	struct sockaddr_un addr;
-	char nlm_ev[NLMSG_SPACE(sizeof(struct stgt_event))];
-	struct stgt_event *ev;
+	char nlm_ev[NLMSG_SPACE(sizeof(struct tgt_event))];
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
@@ -343,8 +343,8 @@
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
 
 	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0)
@@ -382,11 +382,11 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_CREATE,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_CREATE,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -406,11 +406,11 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_DESTROY,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -425,8 +425,8 @@
 {
 	int err;
 	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
-	char dtype[] = "stgt_vsd";
-	struct stgt_event *ev;
+	char dtype[] = "tgt_vsd";
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
@@ -461,7 +461,7 @@
 		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_CREATE,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_CREATE,
 		   NLMSG_SPACE(sizeof(*ev) + strlen(path)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -479,13 +479,13 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fprintf(stderr, "%s %d %d %u\n", __FUNCTION__, __LINE__, tid, lun);
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_DESTROY,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/Makefile	2005-09-12 00:20:00 UTC (rev 68)
@@ -2,13 +2,13 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_STGT=20
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20
 
 ifneq ($(KERNELRELEASE),)
-obj-m		+= stgt_core.o
-stgt_core-objs	:= stgt_sysfs.o tgt_protocol.o stgt.o
+obj-m		+= tgt_core.o
+tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= stgt_vsd.o tgt_scsi.o
+obj-m		+= tgt_vsd.o tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Deleted: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,1070 +0,0 @@
-/*
- * Core Target Framework code
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/list.h>
-#include <linux/hash.h>
-#include <linux/pagemap.h>
-#include <linux/slab.h>
-#include <linux/mempool.h>
-#include <linux/netlink.h>
-#include <net/tcp.h>
-
-#include <stgt.h>
-#include <stgt_target.h>
-#include <stgt_device.h>
-#include <stgt_if.h>
-#include <tgt_protocol.h>
-
-#define DEBUG_STGT
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#ifdef DEBUG_STGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
-#endif
-
-#define assert(p) do {						\
-	if (!(p)) {						\
-		printk(KERN_CRIT "BUG at %s:%d assert(%s)\n",	\
-		       __FILE__, __LINE__, #p);			\
-		dump_stack();					\
-		BUG();						\
-	}							\
-} while (0)
-
-MODULE_LICENSE("GPL");
-
-static spinlock_t all_targets_lock;
-static LIST_HEAD(all_targets);
-
-static spinlock_t target_tmpl_lock;
-static LIST_HEAD(target_tmpl_list);
-
-static spinlock_t device_tmpl_lock;
-static LIST_HEAD(device_tmpl_list);
-
-static void session_init_handler(void *data);
-static spinlock_t atomic_sessions_lock;
-static LIST_HEAD(atomic_sessions);
-static DECLARE_WORK(atomic_session_work, session_init_handler,
-		    &atomic_sessions);
-
-static int daemon_pid;
-static struct sock *nls;
-
-static kmem_cache_t *cmnd_slab, *work_slab;
-
-/* TODO: lock per session */
-static spinlock_t cmnd_hash_lock;
-#define STGT_HASH_ORDER		8
-#define	cmnd_hashfn(key)	hash_long((key), STGT_HASH_ORDER)
-static struct list_head cmnd_hash[1 << STGT_HASH_ORDER];
-
-struct atomic_session_args {
-	struct stgt_session *session;
-	void (*done) (void *, struct stgt_session *);
-	int max_cmnds;
-	void *arg;
-	struct list_head list;
-};
-
-struct stgt_work {
-	void (*fn) (void *);
-	void *arg;
-	mempool_t *pool;
-	struct list_head list;
-};
-
-static struct stgt_work * stgt_init_work(struct stgt_session *session,
-					 void (*fn)(void *), void *arg)
-{
-	struct stgt_work *work;
-	mempool_t *pool = session->work_pool;
-
-	work = mempool_alloc(pool, GFP_ATOMIC);
-	if (!work)
-		return NULL;
-
-	work->fn = fn;
-	work->arg = arg;
-	work->pool = pool;
-
-	return work;
-}
-
-static void stgt_worker(void *data)
-{
-	struct stgt_target *target = (struct stgt_target *) data;
-	struct stgt_work *work = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	if (!list_empty(&target->work_list)) {
-		work = list_entry(target->work_list.next, struct stgt_work, list);
-		list_del(&work->list);
-	}
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	if (work) {
-		work->fn(work->arg);
-		mempool_free(work, work->pool);
-	}
-
-	return;
-}
-
-static void stgt_queue_work(struct stgt_target *target, struct stgt_work *work)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add_tail(&work->list, &target->work_list);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	queue_work(target->twq, &target->work);
-}
-
-struct target_type_internal {
-	struct list_head list;
-	struct stgt_target_template *stt;
-	struct tgt_protocol *proto;
-};
-
-static struct target_type_internal *target_template_get(const char *name)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &target_tmpl_list, list)
-		if (!strcmp(name, ti->stt->name)) {
-			if (!try_module_get(ti->stt->module))
-				ti = NULL;
-			spin_unlock_irqrestore(&target_tmpl_lock, flags);
-			return ti;
-		}
-
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void target_template_put(struct stgt_target_template *stt)
-{
-	module_put(stt->module);
-}
-
-int stgt_target_template_register(struct stgt_target_template *stt)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
-	INIT_LIST_HEAD(&ti->list);
-	ti->stt = stt;
-
-	ti->proto = tgt_protocol_get(stt->protocol);
-	if (!ti->proto) {
-		eprintk("Could not find %s protocol\n", stt->protocol);
-		kfree(ti);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-	list_add_tail(&ti->list, &target_tmpl_list);
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_target_template_register);
-
-void stgt_target_template_unregister(struct stgt_target_template *stt)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &target_tmpl_list, list)
-		if (ti->stt == stt) {
-			list_del(&ti->list);
-			tgt_protocol_put(ti->proto);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(stgt_target_template_unregister);
-
-static struct stgt_target *target_find(int tid)
-{
-	struct stgt_target *target;
-
-	spin_lock(&all_targets_lock);
-	list_for_each_entry(target, &all_targets, tlist) {
-		if (target->tid == tid)
-			goto found;
-	}
-	target = NULL;
-found:
-	spin_unlock(&all_targets_lock);
-
-	return target;
-}
-
-struct stgt_target *stgt_target_create(char *target_type, int queued_cmnds)
-{
-	char name[16];
-	static int target_id;
-	struct stgt_target *target;
-	struct target_type_internal *tti;
-
-	if (!daemon_pid) {
-		eprintk("%s\n", "Run the user-space daemon first!");
-		return NULL;
-	}
-
-	target = kmalloc(sizeof(*target), GFP_KERNEL);
-	if (!target)
-		return NULL;
-	memset(target, 0, sizeof(*target));
-
-	tti = target_template_get(target_type);
-	if (!tti)
-		goto free_target;
-
-	target->stt = tti->stt;
-	target->proto = tti->proto;
-	target->tid = target_id++;
-	spin_lock_init(&target->lock);
-
-	INIT_LIST_HEAD(&target->session_list);
-	INIT_LIST_HEAD(&target->device_list);
-	INIT_LIST_HEAD(&target->work_list);
-
-	INIT_WORK(&target->work, stgt_worker, target);
-	target->queued_cmnds = queued_cmnds;
-
-	snprintf(name, sizeof(name), "tgtd%d", target->tid);
-	target->twq = create_workqueue(name);
-	if (!target->twq)
-		goto put_template;
-
-	target->stt_data = kmalloc(sizeof(target->stt->priv_data_size), GFP_KERNEL);
-	if (!target->stt_data)
-		goto free_workqueue;
-
-	if (target->stt->target_create)
-		if (target->stt->target_create(target))
-			goto free_priv_stt_data;
-
-	if (stgt_sysfs_register_target(target))
-		goto stt_destroy;
-
-	spin_lock(&all_targets_lock);
-	list_add(&target->tlist, &all_targets);
-	spin_unlock(&all_targets_lock);
-	return target;
-
-stt_destroy:
-	if (target->stt->target_destroy)
-		target->stt->target_destroy(target);
-free_priv_stt_data:
-	kfree(target->stt_data);
-free_workqueue:
-	destroy_workqueue(target->twq);
-put_template:
-	target_template_put(target->stt);
-free_target:
-	kfree(target);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(stgt_target_create);
-
-int stgt_target_destroy(struct stgt_target *target)
-{
-	dprintk("%p\n", target);
-
-	spin_lock(&all_targets_lock);
-	list_del(&target->tlist);
-	spin_unlock(&all_targets_lock);
-
-	if (target->stt->target_destroy)
-		target->stt->target_destroy(target);
-
-	destroy_workqueue(target->twq);
-	target_template_put(target->stt);
-	stgt_sysfs_unregister_target(target);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_target_destroy);
-
-static int session_init(struct stgt_session *session, int max_cmnds)
-{
-	struct stgt_target *target = session->target;
-	unsigned long flags;
-
-	session->cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, cmnd_slab);
-	if (!session->cmnd_pool)
-		goto out;
-
-	session->work_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, work_slab);
-	if (!session->work_pool)
-		goto out;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add(&session->slist, &target->session_list);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return 0;
-out:
-	if (session->cmnd_pool)
-		mempool_destroy(session->cmnd_pool);
-
-	if (session->work_pool)
-		mempool_destroy(session->work_pool);
-
-	return -ENOMEM;
-}
-
-static void session_init_handler(void *data)
-{
-	struct list_head *head = (struct list_head *) data;
-	struct atomic_session_args *ssa = NULL;
-	unsigned long flags;
-	int err;
-
-	spin_lock_irqsave(&atomic_sessions_lock, flags);
-	if (!list_empty(&atomic_sessions)) {
-		ssa = list_entry(head->next, struct atomic_session_args, list);
-		list_del(&ssa->list);
-	}
-	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
-
-	if (!ssa)
-		return;
-
-	err = session_init(ssa->session, ssa->max_cmnds);
-	if (err)
-		kfree(ssa->session);
-
-	ssa->done(ssa->arg, err ? NULL : ssa->session);
-
-	kfree(ssa);
-}
-
-static int session_atomic_init(struct stgt_session *session,
-			       int max_cmnds,
-			       void (*done) (void *, struct stgt_session *),
-			       int *arg)
-{
-	struct atomic_session_args *ssa;
-	unsigned long flags;
-
-	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
-	if (!ssa)
-		return -ENOMEM;
-
-	ssa->session = session;
-	ssa->max_cmnds = max_cmnds;
-	ssa->arg = arg;
-
-	spin_lock_irqsave(&atomic_sessions_lock, flags);
-	list_add(&ssa->list, &atomic_sessions);
-	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
-
-	queue_work(session->target->twq, &atomic_session_work);
-
-	return 0;
-}
-
-struct stgt_session *
-stgt_session_create(struct stgt_target *target,
-		    int max_cmnds,
-		    void (*done)(void *, struct stgt_session *),
-		    void *arg)
-{
-	struct stgt_session *session;
-
-	if (!target) {
-		eprintk("%s\n", "Null target pointer!");
-		return NULL;
-	}
-
-	if (done && !arg) {
-		eprintk("%s\n", "Need arg !");
-		return NULL;
-	}
-
-	dprintk("%p %d\n", target, max_cmnds);
-
-	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
-	if (!session)
-		return NULL;
-
-	memset(session, 0, sizeof(*session));
-	session->target = target;
-	INIT_LIST_HEAD(&session->slist);
-
-	if (done) {
-		if (session_atomic_init(session, max_cmnds, done, arg) < 0)
-			goto out;
-
-		return session;
-	}
-
-	if (session_init(session, max_cmnds) < 0)
-		goto out;
-
-	return session;
-
-out:
-	kfree(session);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(stgt_session_create);
-
-int stgt_session_destroy(struct stgt_session *session)
-{
-	mempool_destroy(session->cmnd_pool);
-	mempool_destroy(session->work_pool);
-	kfree(session);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_session_destroy);
-
-struct device_type_internal {
-	struct stgt_device_template *sdt;
-	struct list_head list;
-};
-
-static struct stgt_device_template *device_template_get(const char *name)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (!strcmp(name, ti->sdt->name)) {
-			if (!try_module_get(ti->sdt->module))
-				ti = NULL;
-			spin_unlock_irqrestore(&device_tmpl_lock, flags);
-			return ti ? ti->sdt : NULL;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void device_template_put(struct stgt_device_template *sdt)
-{
-	module_put(sdt->module);
-}
-
-int stgt_device_template_register(struct stgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
-	INIT_LIST_HEAD(&ti->list);
-	ti->sdt = sdt;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-	list_add_tail(&ti->list, &device_tmpl_list);
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_device_template_register);
-
-void stgt_device_template_unregister(struct stgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (ti->sdt == sdt) {
-			list_del(&ti->list);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
-
-/*
- * TODO: use a hash or any better alg/ds
- */
-static struct stgt_device *
-stgt_device_find_nolock(struct stgt_target *target, uint64_t dev_id)
-{
-	struct stgt_device *device;
-
-	list_for_each_entry(device, &target->device_list, dlist)
-		if (device->dev_id == dev_id)
-			return device;
-
-	return NULL;
-}
-
-static struct stgt_device *
-stgt_device_find(struct stgt_target *target, uint64_t dev_id)
-{
-	static struct stgt_device *device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	device = stgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return device;
-}
-
-static int stgt_device_create(int tid, uint64_t dev_id, char *device_type,
-			      char *path, unsigned long dflags)
-{
-	struct stgt_target *target;
-	struct stgt_device *device;
-	unsigned long flags;
-
-	dprintk("%d %llu %s %s\n", tid, dev_id, device_type, path);
-
-	target = target_find(tid);
-	if (!target)
-		return -EINVAL;
-
-	device = kmalloc(sizeof(*device), GFP_KERNEL);
-	if (!device)
-		return -ENOMEM;
-
-	memset(device, 0, sizeof(*device));
-	device->dev_id = dev_id;
-	device->target = target;
-	device->path = kstrdup(path, GFP_KERNEL);
-	if (!device->path)
-		goto free_device;
-
-	device->sdt = device_template_get(device_type);
-	if (!device->sdt) {
-		eprintk("Could not get devive type %s\n", device_type);
-		goto free_path;
-	}
-
-	device->sdt_data = kmalloc(sizeof(device->sdt->priv_data_size),
-				   GFP_KERNEL);
-	if (!device->sdt_data)
-		goto put_template;
-
-	if (device->sdt->create)
-		if (device->sdt->create(device))
-			goto free_priv_sdt_data;
-
-	if (stgt_sysfs_register_device(device))
-		goto sdt_destroy;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add(&device->dlist, &target->device_list);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return 0;
-
-sdt_destroy:
-	if (device->sdt->destroy)
-		device->sdt->destroy(device);
-free_priv_sdt_data:
-	kfree(device->sdt_data);
-put_template:
-	device_template_put(device->sdt);
-free_path:
-	kfree(device->path);
-free_device:
-	kfree(device);
-	return -EINVAL;
-}
-
-static int stgt_device_destroy(int tid, uint64_t dev_id)
-{
-	struct stgt_device *device;
-	struct stgt_target *target;
-	unsigned long flags;
-
-	target = target_find(tid);
-	if (!target)
-		return -ENOENT;
-
-	spin_lock_irqsave(&target->lock, flags);
-	device = stgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&target->lock, flags);
-	if (!device)
-		return -EINVAL;
-
-	list_del(&device->dlist);
-	if (device->sdt->destroy)
-		device->sdt->destroy(device);
-
-	device_template_put(device->sdt);
-	stgt_sysfs_unregister_device(device);
-
-	return 0;
-}
-
-struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
-				   uint8_t *proto_data,
-				   uint8_t *id_buff, int buff_size)
-{
-	struct tgt_protocol *proto = session->target->proto;
-	struct stgt_cmnd *cmnd;
-	void *pcmnd_data;
-	unsigned long flags;
-
-	/*
-	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
-	 * However, how can we guarantee the specified number of commands ?
-	 */
-	pcmnd_data = kmalloc(proto->priv_cmd_data_size, GFP_ATOMIC);
-	if (!pcmnd_data)
-		return NULL;
-
-	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
-	assert(cmnd);
-	memset(cmnd, 0, sizeof(*cmnd));
-	cmnd->tgt_protocol_private = pcmnd_data;
-	cmnd->session = session;
-	cmnd->cid = (uint64_t) (unsigned long) cmnd;
-	INIT_LIST_HEAD(&cmnd->clist);
-	INIT_LIST_HEAD(&cmnd->hash_list);
-
-	dprintk("%p %llu\n", session, cmnd->cid);
-
-	proto->init_cmnd(cmnd, proto_data, id_buff, buff_size);
-
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
-	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
-
-	return cmnd;
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_create);
-
-void stgt_cmnd_destroy(struct stgt_cmnd *cmnd)
-{
-	unsigned long flags;
-	int i;
-
-	kfree(cmnd->tgt_protocol_private);
-
-	for (i = 0; i < cmnd->sg_count; i++)
-		__free_page(cmnd->sg[i].page);
-	kfree(cmnd->sg);
-
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
-	list_del(&cmnd->hash_list);
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
-
-	mempool_free(cmnd, cmnd->session->cmnd_pool);
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_destroy);
-
-#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
-
-void __stgt_alloc_buffer(struct stgt_cmnd *cmnd)
-{
-	uint64_t offset = cmnd->offset;
-	uint32_t len = cmnd->bufflen;
-	int i;
-
-	cmnd->sg_count = pgcnt(len, offset);
-	offset &= ~PAGE_CACHE_MASK;
-
-	cmnd->sg = kmalloc(cmnd->sg_count * sizeof(struct scatterlist),
-			   GFP_KERNEL | __GFP_NOFAIL);
-
-	for (i = 0; i < cmnd->sg_count; i++) {
-		struct scatterlist *sg = &cmnd->sg[i];
-
-		sg->page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
-		sg->offset = offset;
-		sg->length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
-
-		offset = 0;
-		len -= sg->length;
-	}
-}
-
-static void stgt_alloc_buffer(void *data)
-{
-	struct stgt_cmnd *cmnd = data;
-
-	__stgt_alloc_buffer(cmnd);
-
-	if (cmnd->done) {
-		void (*done)(struct stgt_cmnd *) = cmnd->done;
-		cmnd->done = NULL;
-		done(cmnd);
-	}
-}
-
-void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
-{
-	struct tgt_protocol *proto = cmnd->session->target->proto;
-
-	assert(list_empty(&cmnd->clist));
-
-	proto->init_cmnd_buffer(cmnd);
-
-	if (done) {
-		struct stgt_session *session = cmnd->session;
-		struct stgt_work *work;
-
-		work = stgt_init_work(session, stgt_alloc_buffer, cmnd);
-		stgt_queue_work(session->target, work);
-		return;
-	};
-
-	stgt_alloc_buffer(cmnd);
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_alloc_buffer);
-
-static int uspace_cmnd_send(struct stgt_cmnd *cmnd)
-{
-	struct tgt_protocol *proto = cmnd->session->target->proto;
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct stgt_event *ev;
-	char *pdu;
-	int len, proto_pdu_size = proto->uspace_pdu_size;
-
-	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, daemon_pid, 0,
-			  STGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev + sizeof(*ev);
-	ev->k.cmnd_req.tid = cmnd->session->target->tid;
-	ev->k.cmnd_req.dev_id = cmnd->dev_id;
-	ev->k.cmnd_req.cid = cmnd->cid;
-
-	proto->build_uspace_pdu(cmnd, pdu);
-
-	return netlink_unicast(nls, skb, daemon_pid, 0);
-}
-
-static void cmnd_done(struct stgt_cmnd *cmnd, int result)
-{
-	struct stgt_target *target = cmnd->session->target;
-	struct tgt_protocol *proto = target->proto;
-	void (*done)(struct stgt_cmnd *);
-
-	proto->cmnd_done(cmnd, result);
-	cmnd->result = result;
-
-	done = cmnd->done;
-	cmnd->done = NULL;
-	done(cmnd);
-}
-
-static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data,
-			     int result, uint32_t len)
-{
-	int i;
-	assert(cmnd->done);
-
-	if (len) {
-		cmnd->bufflen = len;
-		cmnd->offset = 0;
-		__stgt_alloc_buffer(cmnd);
-
-		for (i = 0; i < cmnd->sg_count; i++) {
-			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-			char *p = data;
-
-			memcpy(page_address(cmnd->sg[i].page), p, copy);
-			p += copy;
-			len -= copy;
-		}
-	}
-
-	cmnd_done(cmnd, result);
-}
-
-static void queuecommand(void *data)
-{
-	int err = 0;
-	struct stgt_cmnd *cmnd = data;
-	struct stgt_target *target = cmnd->session->target;
-	struct stgt_device *device;
-
-	/* Should we do this earlier? */
-	device = stgt_device_find(target, cmnd->dev_id);
-	if (device)
-		dprintk("found %llu\n", cmnd->dev_id);
-
-	if (cmnd->rw == READ || cmnd->rw == WRITE)
-		err = device->sdt->queue_cmnd(device, cmnd);
-	else {
-		err = uspace_cmnd_send(cmnd);
-		if (err >= 0)
-			/* sent to userspace */
-			return;
-	}
-
-	/* kspace command failure or failed to send commands to space. */
-	if (unlikely(err))
-		eprintk("failed cmnd %llu %d %d\n", cmnd->cid, err, cmnd->rw);
-
-	cmnd_done(cmnd, err);
-}
-
-int stgt_cmnd_queue(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
-{
-	struct stgt_work *work;
-	struct stgt_session *session = cmnd->session;
-
-	assert(!cmnd->done);
-	cmnd->done = done;
-	if (!done) {
-		eprintk("%s\n", "Null done function!");
-		return -EINVAL;
-	}
-
-	work = stgt_init_work(session, queuecommand, cmnd);
-	if (!work)
-		return -ENOMEM;
-
-	stgt_queue_work(session->target, work);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_queue);
-
-static struct stgt_cmnd *find_cmnd_by_id(uint64_t cid)
-{
-	struct list_head *head;
-	struct stgt_cmnd *cmnd;
-	unsigned long flags;
-
-	head = &cmnd_hash[cmnd_hashfn(cid)];
-
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
-
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd->cid == cid)
-			goto found;
-	}
-	cmnd = NULL;
-found:
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
-
-	return cmnd;
-}
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	int err = 0;
-	struct stgt_event *ev = NLMSG_DATA(nlh);
-	struct stgt_cmnd *cmnd;
-	struct stgt_target *target;
-
-	daemon_pid  = NETLINK_CREDS(skb)->pid;
-
-	dprintk("%d %d\n", daemon_pid, nlh->nlmsg_type);
-
-	switch (nlh->nlmsg_type) {
-	case STGT_UEVENT_START:
-		dprintk("start %d\n", daemon_pid);
-		break;
-	case STGT_UEVENT_TARGET_CREATE:
-		target = stgt_target_create(ev->u.c_target.type,
-					    ev->u.c_target.nr_cmnds);
-		if (target)
-			err = target->tid;
-		else
-			err = -EINVAL;
-		break;
-	case STGT_UEVENT_TARGET_DESTROY:
-		target = target_find(ev->u.d_target.tid);
-		if (target)
-			err = stgt_target_destroy(target);
-		else
-			err = -EINVAL;
-		break;
-	case STGT_UEVENT_DEVICE_CREATE:
-		if (nlh->nlmsg_len <= NLMSG_SPACE(sizeof(*ev))) {
-			err = -EINVAL;
-			break;
-		}
-		err = stgt_device_create(ev->u.c_device.tid,
-					 ev->u.c_device.dev_id,
-					 ev->u.c_device.type,
-					 (char *) ev + sizeof(*ev),
-					 ev->u.c_device.flags);
-		break;
-	case STGT_UEVENT_DEVICE_DESTROY:
-		err = stgt_device_destroy(ev->u.d_device.tid,
-					  ev->u.d_device.dev_id);
-		break;
-	case STGT_UEVENT_CMND_RES:
-		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
-		if (cmnd)
-			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
-					 ev->u.cmnd_res.result,
-					 ev->u.cmnd_res.len);
-		else {
-			eprintk("cannot found %llu\n", ev->u.cmnd_res.cid);
-			err = -EEXIST;
-		}
-		break;
-	default:
-		eprintk("unknown type %d\n", nlh->nlmsg_type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
-{
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len = NLMSG_SPACE(size);
-
-	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
-	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
-	memcpy(NLMSG_DATA(nlh), data, size);
-
-	return netlink_unicast(nls, skb, pid, 0);
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-	struct stgt_event *ev;
-
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		ev = NLMSG_DATA(nlh);
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		err = event_recv_msg(skb, nlh);
-
-		eprintk("%d %d\n", nlh->nlmsg_type, err);
-		ev->k.event_res.err = err;
-		if (nlh->nlmsg_type != STGT_UEVENT_CMND_RES)
-			send_event_res(NETLINK_CREDS(skb)->pid,
-				       STGT_KEVENT_RESPONSE,
-				       ev, sizeof(*ev));
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
-static void __exit stgt_exit(void)
-{
-	if (cmnd_slab)
-		kmem_cache_destroy(cmnd_slab);
-
-	if (work_slab)
-		kmem_cache_destroy(work_slab);
-
-	if (nls)
-		sock_release(nls->sk_socket);
-
-	stgt_sysfs_exit();
-}
-
-static int __init stgt_init(void)
-{
-	int i, err = -ENOMEM;
-
-	spin_lock_init(&all_targets_lock);
-	spin_lock_init(&atomic_sessions_lock);
-	spin_lock_init(&cmnd_hash_lock);
-	spin_lock_init(&target_tmpl_lock);
-	spin_lock_init(&device_tmpl_lock);
-
-	tgt_protocol_init();
-
-	err = stgt_sysfs_init();
-	if (err)
-		return err;
-
-	cmnd_slab = kmem_cache_create("stgt_cmnd", sizeof(struct stgt_cmnd), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!cmnd_slab)
-		goto out;
-
-	work_slab = kmem_cache_create("stgt_work", sizeof(struct stgt_work), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!work_slab)
-		goto out;
-
-	nls = netlink_kernel_create(NETLINK_STGT, event_recv);
-	if (!nls)
-		goto out;
-
-	for (i = 0; i < ARRAY_SIZE(cmnd_hash); i++)
-		INIT_LIST_HEAD(&cmnd_hash[i]);
-
-	return 0;
-out:
-	stgt_exit();
-	return err;
-}
-
-module_init(stgt_init);
-module_exit(stgt_exit);

Deleted: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,70 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __SCSI_TARGET_H
-#define __SCSI_TARGET_H
-
-#include <linux/mempool.h>
-#include <scsi/scsi_cmnd.h>
-
-struct stgt_session {
-	struct stgt_target *target;
-	struct list_head slist;
-
-	mempool_t *cmnd_pool;
-	mempool_t *work_pool;
-};
-
-struct stgt_cmnd {
-	struct stgt_session *session;
-
-	uint32_t state;
-	uint64_t dev_id;
-	uint64_t cid;
-
-	int rw;
-
-	void (*done) (struct stgt_cmnd *);
-
-	struct list_head clist;
-	struct list_head hash_list;
-
-	int sg_count;
-	struct scatterlist *sg;
-	uint32_t bufflen;
-	uint64_t offset;
-
-	int result;
-
-	/* TODO: there should be a better way. */
-	uint8_t *error_buff;
-	int error_buff_len;
-
-	/*
-	 * target driver private
-	 */
-	void *private;
-
-	void *tgt_protocol_private;
-};
-
-extern struct stgt_session *
-stgt_session_create(struct stgt_target *target,
-		    int max_cmnds,
-		    void (*done)(void *, struct stgt_session *), void *arg);
-extern int stgt_session_destroy(struct stgt_session *session);
-
-extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
-					  uint8_t *proto_data,
-					  uint8_t *id_buff, int buff_size);
-extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
-extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
-				  void (*done)(struct stgt_cmnd *));
-extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
-			   void (*done)(struct stgt_cmnd *));
-extern int stgt_sysfs_init(void);
-extern void stgt_sysfs_exit(void);
-#endif

Deleted: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_device.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,55 +0,0 @@
-/*
- * STGT device
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#ifndef __SCSI_STGT_DEVICE_H
-#define __SCSI_STGT_DEVICE_H
-
-#include <linux/device.h>
-#include <linux/list.h>
-
-struct stgt_device;
-struct stgt_cmnd;
-
-struct stgt_device_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	int (* create)(struct stgt_device *);
-	void (* destroy)(struct stgt_device *);
-	int (* queue_cmnd)(struct stgt_device *device, struct stgt_cmnd *cmd);
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **device_attrs;
-};
-
-struct stgt_device {
-	struct stgt_device_template *sdt;
-	void *sdt_data;
-
-	struct class_device cdev;
-
-        char *path;
-        uint64_t dev_id;
-        uint32_t blk_shift;
-        uint64_t size;
-
-        struct stgt_target *target;
-        struct list_head dlist;
-};
-
-#define cdev_to_stgt_device(cdev) \
-        container_of(cdev, struct stgt_device, cdev)
-
-extern int stgt_sysfs_register_device(struct stgt_device *device);
-extern void stgt_sysfs_unregister_device(struct stgt_device *device);
-extern int stgt_device_template_register(struct stgt_device_template *sdt);
-extern void stgt_device_template_unregister(struct stgt_device_template *sdt);
-
-#endif

Deleted: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_sysfs.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,238 +0,0 @@
-/*
- * STGT core sysfs files
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#include <stgt_target.h>
-#include <stgt_device.h>
-
-/*
- * Target files
- */
-#define stgt_target_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct stgt_target *target = cdev_to_stgt_target(cdev);		\
-	return snprintf (buf, 20, format_string, target->field);	\
-}
-
-#define stgt_target_rd_attr(field, format_string)		\
-	stgt_target_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-stgt_target_rd_attr(queued_cmnds, "%u\n");
-
-static struct class_device_attribute *stgt_target_attrs[] = {
-	&class_device_attr_queued_cmnds,
-	NULL
-};
-
-static void stgt_target_class_release(struct class_device *cdev)
-{
-	struct stgt_target *target = cdev_to_stgt_target(cdev);
-	kfree(target->stt_data);
-	kfree(target);
-}
-
-static struct class stgt_target_class = {
-	.name = "stgt_target",
-	.release = stgt_target_class_release,
-};
-
-static struct class_device_attribute *class_attr_overridden(
-				struct class_device_attribute **attrs,
-				struct class_device_attribute *attr)
-{
-	int i;
-
-	if (!attrs)
-		return NULL;
-
-	for (i = 0; attrs[i]; i++)
-		if (!strcmp(attrs[i]->attr.name, attr->attr.name))
-			return attrs[i];
-	return NULL;
-}
-
-static int class_attr_add(struct class_device *classdev,
-			  struct class_device_attribute *attr)
-{
-	struct class_device_attribute *base_attr;
-
-	/*
-	 * Spare the caller from having to copy things it's not interested in.
-	*/
-	base_attr = class_attr_overridden(stgt_target_attrs, attr);
-	if (base_attr) {
-		/* extend permissions */
-		attr->attr.mode |= base_attr->attr.mode;
-
-		/* override null show/store with default */
-		if (!attr->show)
-			attr->show = base_attr->show;
-		if (!attr->store)
-			attr->store = base_attr->store;
-	}
-
-	return class_device_create_file(classdev, attr);
-}
-
-int stgt_sysfs_register_target(struct stgt_target *target)
-{
-	struct class_device *cdev = &target->cdev;
-	int err, i;
-
-	cdev->class = &stgt_target_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "target%d", target->tid);
-
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	if (target->stt->target_attrs) {
-		for (i = 0; target->stt->target_attrs[i]; i++) {
-			err = class_attr_add(&target->cdev,
-					     target->stt->target_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
-	for (i = 0; stgt_target_attrs[i]; i++) {
-		if (!class_attr_overridden(target->stt->target_attrs,
-					   stgt_target_attrs[i])) {
-			err = class_device_create_file(&target->cdev,
-						       stgt_target_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-	class_device_unregister(cdev);
-	return err;
-}
-
-void stgt_sysfs_unregister_target(struct stgt_target *target)
-{
-	class_device_unregister(&target->cdev);
-}
-
-/*
- * Device files
- */
-#define stgt_device_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct stgt_device *device = cdev_to_stgt_device(cdev);		\
-	return sprintf(buf, format_string, device->field);	\
-}
-
-#define stgt_device_rd_attr(field, format_string)		\
-	stgt_device_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-stgt_device_rd_attr(path, "%s\n");
-stgt_device_rd_attr(size, "%llu\n");
-
-static struct class_device_attribute *stgt_device_attrs[] = {
-	&class_device_attr_path,
-	&class_device_attr_size,
-	NULL,
-};
-
-
-static void stgt_device_class_release(struct class_device *cdev)
-{
-	struct stgt_device *device = cdev_to_stgt_device(cdev);
-	struct stgt_target *target = device->target;
-
-	class_device_put(&target->cdev);
-	kfree(device->sdt_data);
-	kfree(device->path);
-	kfree(device);
-}
-
-static struct class stgt_device_class = {
-	.name = "stgt_device",
-	.release = stgt_device_class_release,
-};
-
-int stgt_sysfs_register_device(struct stgt_device *device)
-{
-	struct stgt_target *target = device->target;
-	struct class_device *cdev = &device->cdev;
-	int err, i;
-
-	cdev->class = &stgt_device_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%llu",
-		 target->tid, device->dev_id);
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	/*
-	 * get handle to target so our parent is never released before
-	 * us
-	 */
-	if (!class_device_get(&target->cdev))
-		return -EINVAL;
-
-	if (device->sdt->device_attrs) {
-		for (i = 0; device->sdt->device_attrs[i]; i++) {
-			err = class_attr_add(&device->cdev,
-					     device->sdt->device_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
-	for (i = 0; stgt_device_attrs[i]; i++) {
-		if (!class_attr_overridden(device->sdt->device_attrs,
-					   stgt_device_attrs[i])) {
-			err = class_device_create_file(&device->cdev,
-						       stgt_device_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-	class_device_put(&target->cdev);
-	class_device_unregister(cdev);
-	return err;
-
-}
-
-void stgt_sysfs_unregister_device(struct stgt_device *device)
-{
-	class_device_unregister(&device->cdev);
-}
-
-int stgt_sysfs_init(void)
-{
-	int err;
-
-	err = class_register(&stgt_target_class);
-	if (err)
-		return err;
-
-	err = class_register(&stgt_device_class);
-	if (err)
-		class_unregister(&stgt_target_class);
-	return err;
-}
-
-void stgt_sysfs_exit(void)
-{
-	class_unregister(&stgt_target_class);
-	class_unregister(&stgt_device_class);
-}

Deleted: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_target.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,69 +0,0 @@
-/*
- * STGT target definitions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#ifndef __SCSI_STGT_TARGET_H
-#define __SCSI_STGT_TARGET_H
-
-#include <linux/device.h>
-#include <linux/list.h>
-
-struct tgt_protocol;
-struct stgt_target;
-
-struct stgt_target_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	int (* target_create) (struct stgt_target *);
-	void (* target_destroy) (struct stgt_target *);
-
-	/*
-	 * name of protocol to use
-	 */
-	const char *protocol;
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **target_attrs;
-};
-
-struct stgt_target {
-	int tid;
-	struct stgt_target_template *stt;
-	void *stt_data;
-	struct tgt_protocol *proto;
-
-	struct class_device cdev;
-
-	int queued_cmnds;
-
-	/* Protects session_list, work_list, device_list */
-	spinlock_t lock;
-
-	struct list_head tlist;
-
-	struct list_head device_list;
-	struct list_head session_list;
-
-	struct work_struct work;
-	struct list_head work_list;
-	struct workqueue_struct *twq;
-};
-
-#define cdev_to_stgt_target(cdev) \
-	container_of(cdev, struct stgt_target, cdev)
-
-extern struct stgt_target *stgt_target_create(char *target_type, int nr_cmnds);
-extern int stgt_target_destroy(struct stgt_target *target);
-extern int stgt_sysfs_register_target(struct stgt_target *target);
-extern void stgt_sysfs_unregister_target(struct stgt_target *target);
-extern int stgt_target_template_register(struct stgt_target_template *stt);
-extern void stgt_target_template_unregister(struct stgt_target_template *stt);
-
-#endif

Deleted: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_vsd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,149 +0,0 @@
-/*
- * virtual device
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/namei.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/writeback.h>
-
-#include <stgt.h>
-#include <stgt_device.h>
-
-struct stgt_vsd_dev {
-	struct file *filp;
-};
-
-static void stgt_vsd_destroy(struct stgt_device *device)
-{
-	struct stgt_vsd_dev *vsddev = device->sdt_data;
-	filp_close(vsddev->filp, NULL);
-}
-
-static int open_file(struct stgt_vsd_dev *vsddev, const char *path)
-{
-	struct file *filp;
-	mm_segment_t oldfs;
-	int err = 0;
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
-	set_fs(oldfs);
-
-	if (IS_ERR(filp)) {
-		err = PTR_ERR(filp);
-		printk("Can't open %s %d\n", path, err);
-	} else
-		vsddev->filp = filp;
-
-	return err;
-}
-
-static int stgt_vsd_create(struct stgt_device *device)
-{
-	struct stgt_vsd_dev *vsddev = device->sdt_data;
-	struct inode *inode;
-	int err = 0;
-
-	err = open_file(vsddev, device->path);
-	if (err)
-		return err;
-
-	inode = vsddev->filp->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else {
-		err = -EINVAL;
-		goto out;
-	}
-
-	device->size = inode->i_size;
-	printk("%s %llu\n", device->path, inode->i_size >> 9);
-
-	return 0;
-out:
-	filp_close(vsddev->filp, NULL);
-	return err;
-}
-
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i < sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	struct stgt_vsd_dev *vsddev = device->sdt_data;
-	ssize_t size;
-	struct iovec *iov;
-	loff_t pos = cmnd->offset;
-	int err = 0;
-
-	if (cmnd->bufflen + pos > device->size)
-		return -EOVERFLOW;
-
-	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (cmnd->rw == READ)
-		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
-	else
-		size = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
-
-	kfree(iov);
-
-/* not yet used
-	if (sync)
-		err = sync_page_range(inode, inode->i_mapping, pos,
-				      (size_t) cmnd->bufflen);
-*/
-	if ((size != cmnd->bufflen) || err)
-		return -EIO;
-	else
-		return 0;
-}
-
-static struct stgt_device_template stgt_vsd = {
-	.name = "stgt_vsd",
-	.module = THIS_MODULE,
-	.create = stgt_vsd_create,
-	.destroy = stgt_vsd_destroy,
-	.queue_cmnd = stgt_vsd_queue,
-};
-
-static int __init stgt_vsd_init(void)
-{
-	stgt_vsd.priv_data_size = sizeof(struct stgt_vsd_dev);
-	return stgt_device_template_register(&stgt_vsd);
-}
-
-static void __exit stgt_vsd_exit(void)
-{
-	stgt_device_template_unregister(&stgt_vsd);
-}
-
-module_init(stgt_vsd_init);
-module_exit(stgt_vsd_exit);
-MODULE_LICENSE("GPL");

Copied: trunk/kernel/tgt.c (from rev 67, trunk/kernel/stgt.c)
===================================================================
--- trunk/kernel/stgt.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,1071 @@
+/*
+ * Core Target Framework code
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/hash.h>
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/mempool.h>
+#include <linux/netlink.h>
+#include <asm/scatterlist.h>
+#include <net/tcp.h>
+
+#include <tgt.h>
+#include <tgt_target.h>
+#include <tgt_device.h>
+#include <tgt_if.h>
+#include <tgt_protocol.h>
+
+#define DEBUG_TGT
+
+#define eprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#ifdef DEBUG_TGT
+#define dprintk eprintk
+#else
+#define dprintk(fmt, args...)
+#endif
+
+#define assert(p) do {						\
+	if (!(p)) {						\
+		printk(KERN_CRIT "BUG at %s:%d assert(%s)\n",	\
+		       __FILE__, __LINE__, #p);			\
+		dump_stack();					\
+		BUG();						\
+	}							\
+} while (0)
+
+MODULE_LICENSE("GPL");
+
+static spinlock_t all_targets_lock;
+static LIST_HEAD(all_targets);
+
+static spinlock_t target_tmpl_lock;
+static LIST_HEAD(target_tmpl_list);
+
+static spinlock_t device_tmpl_lock;
+static LIST_HEAD(device_tmpl_list);
+
+static void session_init_handler(void *data);
+static spinlock_t atomic_sessions_lock;
+static LIST_HEAD(atomic_sessions);
+static DECLARE_WORK(atomic_session_work, session_init_handler,
+		    &atomic_sessions);
+
+static int daemon_pid;
+static struct sock *nls;
+
+static kmem_cache_t *cmnd_slab, *work_slab;
+
+/* TODO: lock per session */
+static spinlock_t cmnd_hash_lock;
+#define TGT_HASH_ORDER		8
+#define	cmnd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
+static struct list_head cmnd_hash[1 << TGT_HASH_ORDER];
+
+struct atomic_session_args {
+	struct tgt_session *session;
+	void (*done) (void *, struct tgt_session *);
+	int max_cmnds;
+	void *arg;
+	struct list_head list;
+};
+
+struct tgt_work {
+	void (*fn) (void *);
+	void *arg;
+	mempool_t *pool;
+	struct list_head list;
+};
+
+static struct tgt_work * tgt_init_work(struct tgt_session *session,
+					void (*fn)(void *), void *arg)
+{
+	struct tgt_work *work;
+	mempool_t *pool = session->work_pool;
+
+	work = mempool_alloc(pool, GFP_ATOMIC);
+	if (!work)
+		return NULL;
+
+	work->fn = fn;
+	work->arg = arg;
+	work->pool = pool;
+
+	return work;
+}
+
+static void tgt_worker(void *data)
+{
+	struct tgt_target *target = (struct tgt_target *) data;
+	struct tgt_work *work = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	if (!list_empty(&target->work_list)) {
+		work = list_entry(target->work_list.next, struct tgt_work, list);
+		list_del(&work->list);
+	}
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	if (work) {
+		work->fn(work->arg);
+		mempool_free(work, work->pool);
+	}
+
+	return;
+}
+
+static void tgt_queue_work(struct tgt_target *target, struct tgt_work *work)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_add_tail(&work->list, &target->work_list);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	queue_work(target->twq, &target->work);
+}
+
+struct target_type_internal {
+	struct list_head list;
+	struct tgt_target_template *tt;
+	struct tgt_protocol *proto;
+};
+
+static struct target_type_internal *target_template_get(const char *name)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &target_tmpl_list, list)
+		if (!strcmp(name, ti->tt->name)) {
+			if (!try_module_get(ti->tt->module))
+				ti = NULL;
+			spin_unlock_irqrestore(&target_tmpl_lock, flags);
+			return ti;
+		}
+
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void target_template_put(struct tgt_target_template *tt)
+{
+	module_put(tt->module);
+}
+
+int tgt_target_template_register(struct tgt_target_template *tt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&ti->list);
+	ti->tt = tt;
+
+	ti->proto = tgt_protocol_get(tt->protocol);
+	if (!ti->proto) {
+		eprintk("Could not find %s protocol\n", tt->protocol);
+		kfree(ti);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+	list_add_tail(&ti->list, &target_tmpl_list);
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_target_template_register);
+
+void tgt_target_template_unregister(struct tgt_target_template *tt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &target_tmpl_list, list)
+		if (ti->tt == tt) {
+			list_del(&ti->list);
+			tgt_protocol_put(ti->proto);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
+
+static struct tgt_target *target_find(int tid)
+{
+	struct tgt_target *target;
+
+	spin_lock(&all_targets_lock);
+	list_for_each_entry(target, &all_targets, tlist) {
+		if (target->tid == tid)
+			goto found;
+	}
+	target = NULL;
+found:
+	spin_unlock(&all_targets_lock);
+
+	return target;
+}
+
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmnds)
+{
+	char name[16];
+	static int target_id;
+	struct tgt_target *target;
+	struct target_type_internal *ti;
+
+	if (!daemon_pid) {
+		eprintk("%s\n", "Run the user-space daemon first!");
+		return NULL;
+	}
+
+	target = kmalloc(sizeof(*target), GFP_KERNEL);
+	if (!target)
+		return NULL;
+	memset(target, 0, sizeof(*target));
+
+	ti = target_template_get(target_type);
+	if (!ti)
+		goto free_target;
+
+	target->tt = ti->tt;
+	target->proto = ti->proto;
+	target->tid = target_id++;
+	spin_lock_init(&target->lock);
+
+	INIT_LIST_HEAD(&target->session_list);
+	INIT_LIST_HEAD(&target->device_list);
+	INIT_LIST_HEAD(&target->work_list);
+
+	INIT_WORK(&target->work, tgt_worker, target);
+	target->queued_cmnds = queued_cmnds;
+
+	snprintf(name, sizeof(name), "tgtd%d", target->tid);
+	target->twq = create_workqueue(name);
+	if (!target->twq)
+		goto put_template;
+
+	target->tt_data = kmalloc(sizeof(target->tt->priv_data_size), GFP_KERNEL);
+	if (!target->tt_data)
+		goto free_workqueue;
+
+	if (target->tt->target_create)
+		if (target->tt->target_create(target))
+			goto free_priv_tt_data;
+
+	if (tgt_sysfs_register_target(target))
+		goto tt_destroy;
+
+	spin_lock(&all_targets_lock);
+	list_add(&target->tlist, &all_targets);
+	spin_unlock(&all_targets_lock);
+	return target;
+
+tt_destroy:
+	if (target->tt->target_destroy)
+		target->tt->target_destroy(target);
+free_priv_tt_data:
+	kfree(target->tt_data);
+free_workqueue:
+	destroy_workqueue(target->twq);
+put_template:
+	target_template_put(target->tt);
+free_target:
+	kfree(target);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(tgt_target_create);
+
+int tgt_target_destroy(struct tgt_target *target)
+{
+	dprintk("%p\n", target);
+
+	spin_lock(&all_targets_lock);
+	list_del(&target->tlist);
+	spin_unlock(&all_targets_lock);
+
+	if (target->tt->target_destroy)
+		target->tt->target_destroy(target);
+
+	destroy_workqueue(target->twq);
+	target_template_put(target->tt);
+	tgt_sysfs_unregister_target(target);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_target_destroy);
+
+static int session_init(struct tgt_session *session, int max_cmnds)
+{
+	struct tgt_target *target = session->target;
+	unsigned long flags;
+
+	session->cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
+					    mempool_free_slab, cmnd_slab);
+	if (!session->cmnd_pool)
+		goto out;
+
+	session->work_pool = mempool_create(max_cmnds, mempool_alloc_slab,
+					    mempool_free_slab, work_slab);
+	if (!session->work_pool)
+		goto out;
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_add(&session->slist, &target->session_list);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return 0;
+out:
+	if (session->cmnd_pool)
+		mempool_destroy(session->cmnd_pool);
+
+	if (session->work_pool)
+		mempool_destroy(session->work_pool);
+
+	return -ENOMEM;
+}
+
+static void session_init_handler(void *data)
+{
+	struct list_head *head = (struct list_head *) data;
+	struct atomic_session_args *ssa = NULL;
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&atomic_sessions_lock, flags);
+	if (!list_empty(&atomic_sessions)) {
+		ssa = list_entry(head->next, struct atomic_session_args, list);
+		list_del(&ssa->list);
+	}
+	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
+
+	if (!ssa)
+		return;
+
+	err = session_init(ssa->session, ssa->max_cmnds);
+	if (err)
+		kfree(ssa->session);
+
+	ssa->done(ssa->arg, err ? NULL : ssa->session);
+
+	kfree(ssa);
+}
+
+static int session_atomic_init(struct tgt_session *session,
+			       int max_cmnds,
+			       void (*done) (void *, struct tgt_session *),
+			       int *arg)
+{
+	struct atomic_session_args *ssa;
+	unsigned long flags;
+
+	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
+	if (!ssa)
+		return -ENOMEM;
+
+	ssa->session = session;
+	ssa->max_cmnds = max_cmnds;
+	ssa->arg = arg;
+
+	spin_lock_irqsave(&atomic_sessions_lock, flags);
+	list_add(&ssa->list, &atomic_sessions);
+	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
+
+	queue_work(session->target->twq, &atomic_session_work);
+
+	return 0;
+}
+
+struct tgt_session *
+tgt_session_create(struct tgt_target *target,
+		   int max_cmnds,
+		   void (*done)(void *, struct tgt_session *),
+		   void *arg)
+{
+	struct tgt_session *session;
+
+	if (!target) {
+		eprintk("%s\n", "Null target pointer!");
+		return NULL;
+	}
+
+	if (done && !arg) {
+		eprintk("%s\n", "Need arg !");
+		return NULL;
+	}
+
+	dprintk("%p %d\n", target, max_cmnds);
+
+	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
+	if (!session)
+		return NULL;
+
+	memset(session, 0, sizeof(*session));
+	session->target = target;
+	INIT_LIST_HEAD(&session->slist);
+
+	if (done) {
+		if (session_atomic_init(session, max_cmnds, done, arg) < 0)
+			goto out;
+
+		return session;
+	}
+
+	if (session_init(session, max_cmnds) < 0)
+		goto out;
+
+	return session;
+
+out:
+	kfree(session);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(tgt_session_create);
+
+int tgt_session_destroy(struct tgt_session *session)
+{
+	mempool_destroy(session->cmnd_pool);
+	mempool_destroy(session->work_pool);
+	kfree(session);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_session_destroy);
+
+struct device_type_internal {
+	struct tgt_device_template *sdt;
+	struct list_head list;
+};
+
+static struct tgt_device_template *device_template_get(const char *name)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &device_tmpl_list, list)
+		if (!strcmp(name, ti->sdt->name)) {
+			if (!try_module_get(ti->sdt->module))
+				ti = NULL;
+			spin_unlock_irqrestore(&device_tmpl_lock, flags);
+			return ti ? ti->sdt : NULL;
+		}
+
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void device_template_put(struct tgt_device_template *sdt)
+{
+	module_put(sdt->module);
+}
+
+int tgt_device_template_register(struct tgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&ti->list);
+	ti->sdt = sdt;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+	list_add_tail(&ti->list, &device_tmpl_list);
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_device_template_register);
+
+void tgt_device_template_unregister(struct tgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &device_tmpl_list, list)
+		if (ti->sdt == sdt) {
+			list_del(&ti->list);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_device_template_unregister);
+
+/*
+ * TODO: use a hash or any better alg/ds
+ */
+static struct tgt_device *
+tgt_device_find_nolock(struct tgt_target *target, uint64_t dev_id)
+{
+	struct tgt_device *device;
+
+	list_for_each_entry(device, &target->device_list, dlist)
+		if (device->dev_id == dev_id)
+			return device;
+
+	return NULL;
+}
+
+static struct tgt_device *
+tgt_device_find(struct tgt_target *target, uint64_t dev_id)
+{
+	static struct tgt_device *device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return device;
+}
+
+static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
+			      char *path, unsigned long dflags)
+{
+	struct tgt_target *target;
+	struct tgt_device *device;
+	unsigned long flags;
+
+	dprintk("%d %llu %s %s\n", tid, dev_id, device_type, path);
+
+	target = target_find(tid);
+	if (!target)
+		return -EINVAL;
+
+	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+
+	memset(device, 0, sizeof(*device));
+	device->dev_id = dev_id;
+	device->target = target;
+	device->path = kstrdup(path, GFP_KERNEL);
+	if (!device->path)
+		goto free_device;
+
+	device->dt = device_template_get(device_type);
+	if (!device->dt) {
+		eprintk("Could not get devive type %s\n", device_type);
+		goto free_path;
+	}
+
+	device->dt_data = kmalloc(sizeof(device->dt->priv_data_size),
+				   GFP_KERNEL);
+	if (!device->dt_data)
+		goto put_template;
+
+	if (device->dt->create)
+		if (device->dt->create(device))
+			goto free_priv_dt_data;
+
+	if (tgt_sysfs_register_device(device))
+		goto dt_destroy;
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_add(&device->dlist, &target->device_list);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return 0;
+
+dt_destroy:
+	if (device->dt->destroy)
+		device->dt->destroy(device);
+free_priv_dt_data:
+	kfree(device->dt_data);
+put_template:
+	device_template_put(device->dt);
+free_path:
+	kfree(device->path);
+free_device:
+	kfree(device);
+	return -EINVAL;
+}
+
+static int tgt_device_destroy(int tid, uint64_t dev_id)
+{
+	struct tgt_device *device;
+	struct tgt_target *target;
+	unsigned long flags;
+
+	target = target_find(tid);
+	if (!target)
+		return -ENOENT;
+
+	spin_lock_irqsave(&target->lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	spin_unlock_irqrestore(&target->lock, flags);
+	if (!device)
+		return -EINVAL;
+
+	list_del(&device->dlist);
+	if (device->dt->destroy)
+		device->dt->destroy(device);
+
+	device_template_put(device->dt);
+	tgt_sysfs_unregister_device(device);
+
+	return 0;
+}
+
+struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
+				   uint8_t *proto_data,
+				   uint8_t *id_buff, int buff_size)
+{
+	struct tgt_protocol *proto = session->target->proto;
+	struct tgt_cmnd *cmnd;
+	void *pcmnd_data;
+	unsigned long flags;
+
+	/*
+	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
+	 * However, how can we guarantee the specified number of commands ?
+	 */
+	pcmnd_data = kmalloc(proto->priv_cmd_data_size, GFP_ATOMIC);
+	if (!pcmnd_data)
+		return NULL;
+
+	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
+	assert(cmnd);
+	memset(cmnd, 0, sizeof(*cmnd));
+	cmnd->tgt_protocol_private = pcmnd_data;
+	cmnd->session = session;
+	cmnd->cid = (uint64_t) (unsigned long) cmnd;
+	INIT_LIST_HEAD(&cmnd->clist);
+	INIT_LIST_HEAD(&cmnd->hash_list);
+
+	dprintk("%p %llu\n", session, cmnd->cid);
+
+	proto->init_cmnd(cmnd, proto_data, id_buff, buff_size);
+
+	spin_lock_irqsave(&cmnd_hash_lock, flags);
+	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);
+	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+
+	return cmnd;
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_create);
+
+void tgt_cmnd_destroy(struct tgt_cmnd *cmnd)
+{
+	unsigned long flags;
+	int i;
+
+	kfree(cmnd->tgt_protocol_private);
+
+	for (i = 0; i < cmnd->sg_count; i++)
+		__free_page(cmnd->sg[i].page);
+	kfree(cmnd->sg);
+
+	spin_lock_irqsave(&cmnd_hash_lock, flags);
+	list_del(&cmnd->hash_list);
+	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+
+	mempool_free(cmnd, cmnd->session->cmnd_pool);
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_destroy);
+
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
+
+void __tgt_alloc_buffer(struct tgt_cmnd *cmnd)
+{
+	uint64_t offset = cmnd->offset;
+	uint32_t len = cmnd->bufflen;
+	int i;
+
+	cmnd->sg_count = pgcnt(len, offset);
+	offset &= ~PAGE_CACHE_MASK;
+
+	cmnd->sg = kmalloc(cmnd->sg_count * sizeof(struct scatterlist),
+			   GFP_KERNEL | __GFP_NOFAIL);
+
+	for (i = 0; i < cmnd->sg_count; i++) {
+		struct scatterlist *sg = &cmnd->sg[i];
+
+		sg->page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
+		sg->offset = offset;
+		sg->length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
+
+		offset = 0;
+		len -= sg->length;
+	}
+}
+
+static void tgt_alloc_buffer(void *data)
+{
+	struct tgt_cmnd *cmnd = data;
+
+	__tgt_alloc_buffer(cmnd);
+
+	if (cmnd->done) {
+		void (*done)(struct tgt_cmnd *) = cmnd->done;
+		cmnd->done = NULL;
+		done(cmnd);
+	}
+}
+
+void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+{
+	struct tgt_protocol *proto = cmnd->session->target->proto;
+
+	assert(list_empty(&cmnd->clist));
+
+	proto->init_cmnd_buffer(cmnd);
+
+	if (done) {
+		struct tgt_session *session = cmnd->session;
+		struct tgt_work *work;
+
+		work = tgt_init_work(session, tgt_alloc_buffer, cmnd);
+		tgt_queue_work(session->target, work);
+		return;
+	};
+
+	tgt_alloc_buffer(cmnd);
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_alloc_buffer);
+
+static int uspace_cmnd_send(struct tgt_cmnd *cmnd)
+{
+	struct tgt_protocol *proto = cmnd->session->target->proto;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+	char *pdu;
+	int len, proto_pdu_size = proto->uspace_pdu_size;
+
+	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
+	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
+	nlh = __nlmsg_put(skb, daemon_pid, 0,
+			  TGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+
+	pdu = (char *) ev + sizeof(*ev);
+	ev->k.cmnd_req.tid = cmnd->session->target->tid;
+	ev->k.cmnd_req.dev_id = cmnd->dev_id;
+	ev->k.cmnd_req.cid = cmnd->cid;
+
+	proto->build_uspace_pdu(cmnd, pdu);
+
+	return netlink_unicast(nls, skb, daemon_pid, 0);
+}
+
+static void cmnd_done(struct tgt_cmnd *cmnd, int result)
+{
+	struct tgt_target *target = cmnd->session->target;
+	struct tgt_protocol *proto = target->proto;
+	void (*done)(struct tgt_cmnd *);
+
+	proto->cmnd_done(cmnd, result);
+	cmnd->result = result;
+
+	done = cmnd->done;
+	cmnd->done = NULL;
+	done(cmnd);
+}
+
+static void uspace_cmnd_done(struct tgt_cmnd *cmnd, char *data,
+			     int result, uint32_t len)
+{
+	int i;
+	assert(cmnd->done);
+
+	if (len) {
+		cmnd->bufflen = len;
+		cmnd->offset = 0;
+		__tgt_alloc_buffer(cmnd);
+
+		for (i = 0; i < cmnd->sg_count; i++) {
+			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
+			char *p = data;
+
+			memcpy(page_address(cmnd->sg[i].page), p, copy);
+			p += copy;
+			len -= copy;
+		}
+	}
+
+	cmnd_done(cmnd, result);
+}
+
+static void queuecommand(void *data)
+{
+	int err = 0;
+	struct tgt_cmnd *cmnd = data;
+	struct tgt_target *target = cmnd->session->target;
+	struct tgt_device *device;
+
+	/* Should we do this earlier? */
+	device = tgt_device_find(target, cmnd->dev_id);
+	if (device)
+		dprintk("found %llu\n", cmnd->dev_id);
+
+	if (cmnd->rw == READ || cmnd->rw == WRITE)
+		err = device->dt->queue_cmnd(device, cmnd);
+	else {
+		err = uspace_cmnd_send(cmnd);
+		if (err >= 0)
+			/* sent to userspace */
+			return;
+	}
+
+	/* kspace command failure or failed to send commands to space. */
+	if (unlikely(err))
+		eprintk("failed cmnd %llu %d %d\n", cmnd->cid, err, cmnd->rw);
+
+	cmnd_done(cmnd, err);
+}
+
+int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+{
+	struct tgt_work *work;
+	struct tgt_session *session = cmnd->session;
+
+	assert(!cmnd->done);
+	cmnd->done = done;
+	if (!done) {
+		eprintk("%s\n", "Null done function!");
+		return -EINVAL;
+	}
+
+	work = tgt_init_work(session, queuecommand, cmnd);
+	if (!work)
+		return -ENOMEM;
+
+	tgt_queue_work(session->target, work);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_queue);
+
+static struct tgt_cmnd *find_cmnd_by_id(uint64_t cid)
+{
+	struct list_head *head;
+	struct tgt_cmnd *cmnd;
+	unsigned long flags;
+
+	head = &cmnd_hash[cmnd_hashfn(cid)];
+
+	spin_lock_irqsave(&cmnd_hash_lock, flags);
+
+	list_for_each_entry(cmnd, head, hash_list) {
+		if (cmnd->cid == cid)
+			goto found;
+	}
+	cmnd = NULL;
+found:
+	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+
+	return cmnd;
+}
+
+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+{
+	int err = 0;
+	struct tgt_event *ev = NLMSG_DATA(nlh);
+	struct tgt_cmnd *cmnd;
+	struct tgt_target *target;
+
+	daemon_pid  = NETLINK_CREDS(skb)->pid;
+
+	dprintk("%d %d\n", daemon_pid, nlh->nlmsg_type);
+
+	switch (nlh->nlmsg_type) {
+	case TGT_UEVENT_START:
+		dprintk("start %d\n", daemon_pid);
+		break;
+	case TGT_UEVENT_TARGET_CREATE:
+		target = tgt_target_create(ev->u.c_target.type,
+					   ev->u.c_target.nr_cmnds);
+		if (target)
+			err = target->tid;
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_TARGET_DESTROY:
+		target = target_find(ev->u.d_target.tid);
+		if (target)
+			err = tgt_target_destroy(target);
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_DEVICE_CREATE:
+		if (nlh->nlmsg_len <= NLMSG_SPACE(sizeof(*ev))) {
+			err = -EINVAL;
+			break;
+		}
+		err = tgt_device_create(ev->u.c_device.tid,
+					ev->u.c_device.dev_id,
+					ev->u.c_device.type,
+					(char *) ev + sizeof(*ev),
+					ev->u.c_device.flags);
+		break;
+	case TGT_UEVENT_DEVICE_DESTROY:
+		err = tgt_device_destroy(ev->u.d_device.tid,
+					 ev->u.d_device.dev_id);
+		break;
+	case TGT_UEVENT_CMND_RES:
+		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
+		if (cmnd)
+			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
+					 ev->u.cmnd_res.result,
+					 ev->u.cmnd_res.len);
+		else {
+			eprintk("cannot found %llu\n", ev->u.cmnd_res.cid);
+			err = -EEXIST;
+		}
+		break;
+	default:
+		eprintk("unknown type %d\n", nlh->nlmsg_type);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
+{
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len = NLMSG_SPACE(size);
+
+	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
+	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
+	memcpy(NLMSG_DATA(nlh), data, size);
+
+	return netlink_unicast(nls, skb, pid, 0);
+}
+
+static int event_recv_skb(struct sk_buff *skb)
+{
+	int err;
+	uint32_t rlen;
+	struct nlmsghdr	*nlh;
+	struct tgt_event *ev;
+
+	while (skb->len >= NLMSG_SPACE(0)) {
+		nlh = (struct nlmsghdr *) skb->data;
+		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+			return 0;
+		ev = NLMSG_DATA(nlh);
+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+		if (rlen > skb->len)
+			rlen = skb->len;
+		err = event_recv_msg(skb, nlh);
+
+		eprintk("%d %d\n", nlh->nlmsg_type, err);
+		ev->k.event_res.err = err;
+		if (nlh->nlmsg_type != TGT_UEVENT_CMND_RES)
+			send_event_res(NETLINK_CREDS(skb)->pid,
+				       TGT_KEVENT_RESPONSE,
+				       ev, sizeof(*ev));
+		skb_pull(skb, rlen);
+	}
+	return 0;
+}
+
+static void event_recv(struct sock *sk, int length)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+		if (event_recv_skb(skb) && skb->len)
+			skb_queue_head(&sk->sk_receive_queue, skb);
+		else
+			kfree_skb(skb);
+	}
+}
+
+static void __exit tgt_exit(void)
+{
+	if (cmnd_slab)
+		kmem_cache_destroy(cmnd_slab);
+
+	if (work_slab)
+		kmem_cache_destroy(work_slab);
+
+	if (nls)
+		sock_release(nls->sk_socket);
+
+	tgt_sysfs_exit();
+}
+
+static int __init tgt_init(void)
+{
+	int i, err = -ENOMEM;
+
+	spin_lock_init(&all_targets_lock);
+	spin_lock_init(&atomic_sessions_lock);
+	spin_lock_init(&cmnd_hash_lock);
+	spin_lock_init(&target_tmpl_lock);
+	spin_lock_init(&device_tmpl_lock);
+
+	tgt_protocol_init();
+
+	err = tgt_sysfs_init();
+	if (err)
+		return err;
+
+	cmnd_slab = kmem_cache_create("tgt_cmnd", sizeof(struct tgt_cmnd), 0,
+				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+				      NULL, NULL);
+	if (!cmnd_slab)
+		goto out;
+
+	work_slab = kmem_cache_create("tgt_work", sizeof(struct tgt_work), 0,
+				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+				      NULL, NULL);
+	if (!work_slab)
+		goto out;
+
+	nls = netlink_kernel_create(NETLINK_TGT, event_recv);
+	if (!nls)
+		goto out;
+
+	for (i = 0; i < ARRAY_SIZE(cmnd_hash); i++)
+		INIT_LIST_HEAD(&cmnd_hash[i]);
+
+	return 0;
+out:
+	tgt_exit();
+	return err;
+}
+
+module_init(tgt_init);
+module_exit(tgt_exit);

Copied: trunk/kernel/tgt.h (from rev 67, trunk/kernel/stgt.h)
===================================================================
--- trunk/kernel/stgt.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,71 @@
+/*
+ * Core Target Framework definitions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#ifndef __TGT_H
+#define __TGT_H
+
+#include <linux/mempool.h>
+
+struct tgt_session {
+	struct tgt_target *target;
+	struct list_head slist;
+
+	mempool_t *cmnd_pool;
+	mempool_t *work_pool;
+};
+
+struct tgt_cmnd {
+	struct tgt_session *session;
+
+	uint32_t state;
+	uint64_t dev_id;
+	uint64_t cid;
+
+	int rw;
+
+	void (*done) (struct tgt_cmnd *);
+
+	struct list_head clist;
+	struct list_head hash_list;
+
+	int sg_count;
+	struct scatterlist *sg;
+	uint32_t bufflen;
+	uint64_t offset;
+
+	int result;
+
+	/* TODO: there should be a better way. */
+	uint8_t *error_buff;
+	int error_buff_len;
+
+	/*
+	 * target driver private
+	 */
+	void *private;
+
+	void *tgt_protocol_private;
+};
+
+extern struct tgt_session *
+tgt_session_create(struct tgt_target *target,
+		   int max_cmnds,
+		   void (*done)(void *, struct tgt_session *), void *arg);
+extern int tgt_session_destroy(struct tgt_session *session);
+
+extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
+					uint8_t *proto_data,
+					uint8_t *id_buff, int buff_size);
+extern void tgt_cmnd_destroy(struct tgt_cmnd *cmnd);
+extern void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd,
+				  void (*done)(struct tgt_cmnd *));
+extern int tgt_cmnd_queue(struct tgt_cmnd *cmnd,
+			  void (*done)(struct tgt_cmnd *));
+extern int tgt_sysfs_init(void);
+extern void tgt_sysfs_exit(void);
+#endif

Copied: trunk/kernel/tgt_device.h (from rev 67, trunk/kernel/stgt_device.h)
===================================================================
--- trunk/kernel/stgt_device.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_device.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,55 @@
+/*
+ * Target Framework Device definitions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#ifndef __TGT_DEVICE_H
+#define __TGT_DEVICE_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+struct tgt_device;
+struct tgt_cmnd;
+
+struct tgt_device_template {
+	const char *name;
+	struct module *module;
+	unsigned priv_data_size;
+
+	int (* create)(struct tgt_device *);
+	void (* destroy)(struct tgt_device *);
+	int (* queue_cmnd)(struct tgt_device *device, struct tgt_cmnd *cmnd);
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **device_attrs;
+};
+
+struct tgt_device {
+	struct tgt_device_template *dt;
+	void *dt_data;
+
+	struct class_device cdev;
+
+        char *path;
+        uint64_t dev_id;
+        uint32_t blk_shift;
+        uint64_t size;
+
+        struct tgt_target *target;
+        struct list_head dlist;
+};
+
+#define cdev_to_tgt_device(cdev) \
+        container_of(cdev, struct tgt_device, cdev)
+
+extern int tgt_sysfs_register_device(struct tgt_device *device);
+extern void tgt_sysfs_unregister_device(struct tgt_device *device);
+extern int tgt_device_template_register(struct tgt_device_template *dt);
+extern void tgt_device_template_unregister(struct tgt_device_template *dt);
+
+#endif

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_protocol.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,5 +1,5 @@
 /*
- * Target protocol
+ * Target Framework Protocol definitions
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -9,7 +9,7 @@
 #define __TGT_PROTOCOL_H
 
 struct module;
-struct stgt_cmnd;
+struct tgt_cmnd;
 
 struct tgt_protocol {
 	const char *name;
@@ -22,18 +22,18 @@
 	 * perform command preparation, such as setting the rw field
 	 * and dev_id
 	 */
-	void (* init_cmnd)(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+	void (* init_cmnd)(struct tgt_cmnd *cmnd, uint8_t *proto_data,
 			   uint8_t *id_buff, int buff_size);
 	/*
 	 * setup buffer fields like offset and len
 	 */
-	void (* init_cmnd_buffer)(struct stgt_cmnd *cmd);
+	void (* init_cmnd_buffer)(struct tgt_cmnd *cmd);
 	/*
 	 * process completion of a command
 	 */
-	void (* cmnd_done)(struct stgt_cmnd *cmd, int err);
+	void (* cmnd_done)(struct tgt_cmnd *cmd, int err);
 
-	void (* build_uspace_pdu)(struct stgt_cmnd *cmnd, void *data);
+	void (* build_uspace_pdu)(struct tgt_cmnd *cmnd, void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_scsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -7,9 +7,11 @@
  */
 #include <linux/fs.h>
 #include <linux/module.h>
+#include <linux/mm.h>
 #include <scsi/scsi.h>
-#include <linux/mm.h>
-#include <stgt.h>
+#include <scsi/scsi_cmnd.h>
+
+#include <tgt.h>
 #include <tgt_protocol.h>
 
 struct scsi_tgt_cmnd {
@@ -41,7 +43,7 @@
 	return lun;
 }
 
-static void scsi_tgt_init_cmnd_buffer(struct stgt_cmnd *cmnd)
+static void scsi_tgt_init_cmnd_buffer(struct tgt_cmnd *cmnd)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
 	uint8_t *scb = scsi_tgt_cmnd->scb;
@@ -81,7 +83,7 @@
 	cmnd->offset = off;
 }
 
-static void scsi_tgt_init_cmnd(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+static void scsi_tgt_init_cmnd(struct tgt_cmnd *cmnd, uint8_t *proto_data,
 			       uint8_t *id_buff, int buff_size)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
@@ -110,7 +112,7 @@
 	cmnd->dev_id = scsi_tgt_translate_lun(id_buff, buff_size);
 }
 
-static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
+static int sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
@@ -164,7 +166,7 @@
 	return key;
 }
 
-static void scsi_tgt_cmnd_done(struct stgt_cmnd *cmnd, int err)
+static void scsi_tgt_cmnd_done(struct tgt_cmnd *cmnd, int err)
 {
 	if (err < 0) {
 		uint8_t key;
@@ -176,7 +178,7 @@
 		cmnd->result = SAM_STAT_GOOD;
 }
 
-void scsi_tgt_build_uspace_pdu(struct stgt_cmnd *cmnd, void *data)
+void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
 

Copied: trunk/kernel/tgt_sysfs.c (from rev 67, trunk/kernel/stgt_sysfs.c)
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_sysfs.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,238 @@
+/*
+ * Target framework core sysfs files
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#include <tgt_target.h>
+#include <tgt_device.h>
+
+/*
+ * Target files
+ */
+#define tgt_target_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
+	return snprintf (buf, 20, format_string, target->field);	\
+}
+
+#define tgt_target_rd_attr(field, format_string)		\
+	tgt_target_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_target_rd_attr(queued_cmnds, "%u\n");
+
+static struct class_device_attribute *tgt_target_attrs[] = {
+	&class_device_attr_queued_cmnds,
+	NULL
+};
+
+static void tgt_target_class_release(struct class_device *cdev)
+{
+	struct tgt_target *target = cdev_to_tgt_target(cdev);
+	kfree(target->tt_data);
+	kfree(target);
+}
+
+static struct class tgt_target_class = {
+	.name = "tgt_target",
+	.release = tgt_target_class_release,
+};
+
+static struct class_device_attribute *class_attr_overridden(
+				struct class_device_attribute **attrs,
+				struct class_device_attribute *attr)
+{
+	int i;
+
+	if (!attrs)
+		return NULL;
+
+	for (i = 0; attrs[i]; i++)
+		if (!strcmp(attrs[i]->attr.name, attr->attr.name))
+			return attrs[i];
+	return NULL;
+}
+
+static int class_attr_add(struct class_device *classdev,
+			  struct class_device_attribute *attr)
+{
+	struct class_device_attribute *base_attr;
+
+	/*
+	 * Spare the caller from having to copy things it's not interested in.
+	*/
+	base_attr = class_attr_overridden(tgt_target_attrs, attr);
+	if (base_attr) {
+		/* extend permissions */
+		attr->attr.mode |= base_attr->attr.mode;
+
+		/* override null show/store with default */
+		if (!attr->show)
+			attr->show = base_attr->show;
+		if (!attr->store)
+			attr->store = base_attr->store;
+	}
+
+	return class_device_create_file(classdev, attr);
+}
+
+int tgt_sysfs_register_target(struct tgt_target *target)
+{
+	struct class_device *cdev = &target->cdev;
+	int err, i;
+
+	cdev->class = &tgt_target_class;
+	snprintf(cdev->class_id, BUS_ID_SIZE, "target%d", target->tid);
+
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	if (target->tt->target_attrs) {
+		for (i = 0; target->tt->target_attrs[i]; i++) {
+			err = class_attr_add(&target->cdev,
+					     target->tt->target_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; tgt_target_attrs[i]; i++) {
+		if (!class_attr_overridden(target->tt->target_attrs,
+					   tgt_target_attrs[i])) {
+			err = class_device_create_file(&target->cdev,
+						       tgt_target_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_unregister(cdev);
+	return err;
+}
+
+void tgt_sysfs_unregister_target(struct tgt_target *target)
+{
+	class_device_unregister(&target->cdev);
+}
+
+/*
+ * Device files
+ */
+#define tgt_device_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_device *device = cdev_to_tgt_device(cdev);		\
+	return sprintf(buf, format_string, device->field);	\
+}
+
+#define tgt_device_rd_attr(field, format_string)		\
+	tgt_device_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_device_rd_attr(path, "%s\n");
+tgt_device_rd_attr(size, "%llu\n");
+
+static struct class_device_attribute *tgt_device_attrs[] = {
+	&class_device_attr_path,
+	&class_device_attr_size,
+	NULL,
+};
+
+
+static void tgt_device_class_release(struct class_device *cdev)
+{
+	struct tgt_device *device = cdev_to_tgt_device(cdev);
+	struct tgt_target *target = device->target;
+
+	class_device_put(&target->cdev);
+	kfree(device->dt_data);
+	kfree(device->path);
+	kfree(device);
+}
+
+static struct class tgt_device_class = {
+	.name = "tgt_device",
+	.release = tgt_device_class_release,
+};
+
+int tgt_sysfs_register_device(struct tgt_device *device)
+{
+	struct tgt_target *target = device->target;
+	struct class_device *cdev = &device->cdev;
+	int err, i;
+
+	cdev->class = &tgt_device_class;
+	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%llu",
+		 target->tid, device->dev_id);
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	/*
+	 * get handle to target so our parent is never released before
+	 * us
+	 */
+	if (!class_device_get(&target->cdev))
+		return -EINVAL;
+
+	if (device->dt->device_attrs) {
+		for (i = 0; device->dt->device_attrs[i]; i++) {
+			err = class_attr_add(&device->cdev,
+					     device->dt->device_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; tgt_device_attrs[i]; i++) {
+		if (!class_attr_overridden(device->dt->device_attrs,
+					   tgt_device_attrs[i])) {
+			err = class_device_create_file(&device->cdev,
+						       tgt_device_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_put(&target->cdev);
+	class_device_unregister(cdev);
+	return err;
+
+}
+
+void tgt_sysfs_unregister_device(struct tgt_device *device)
+{
+	class_device_unregister(&device->cdev);
+}
+
+int tgt_sysfs_init(void)
+{
+	int err;
+
+	err = class_register(&tgt_target_class);
+	if (err)
+		return err;
+
+	err = class_register(&tgt_device_class);
+	if (err)
+		class_unregister(&tgt_target_class);
+	return err;
+}
+
+void tgt_sysfs_exit(void)
+{
+	class_unregister(&tgt_target_class);
+	class_unregister(&tgt_device_class);
+}

Copied: trunk/kernel/tgt_target.h (from rev 67, trunk/kernel/stgt_target.h)
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_target.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,69 @@
+/*
+ * Target Framework Target definitions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#ifndef __TGT_TARGET_H
+#define __TGT_TARGET_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+struct tgt_protocol;
+struct tgt_target;
+
+struct tgt_target_template {
+	const char *name;
+	struct module *module;
+	unsigned priv_data_size;
+
+	int (* target_create) (struct tgt_target *);
+	void (* target_destroy) (struct tgt_target *);
+
+	/*
+	 * name of protocol to use
+	 */
+	const char *protocol;
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **target_attrs;
+};
+
+struct tgt_target {
+	int tid;
+	struct tgt_target_template *tt;
+	void *tt_data;
+	struct tgt_protocol *proto;
+
+	struct class_device cdev;
+
+	int queued_cmnds;
+
+	/* Protects session_list, work_list, device_list */
+	spinlock_t lock;
+
+	struct list_head tlist;
+
+	struct list_head device_list;
+	struct list_head session_list;
+
+	struct work_struct work;
+	struct list_head work_list;
+	struct workqueue_struct *twq;
+};
+
+#define cdev_to_tgt_target(cdev) \
+	container_of(cdev, struct tgt_target, cdev)
+
+extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmnds);
+extern int tgt_target_destroy(struct tgt_target *target);
+extern int tgt_sysfs_register_target(struct tgt_target *target);
+extern void tgt_sysfs_unregister_target(struct tgt_target *target);
+extern int tgt_target_template_register(struct tgt_target_template *tt);
+extern void tgt_target_template_unregister(struct tgt_target_template *tt);
+
+#endif

Copied: trunk/kernel/tgt_vsd.c (from rev 67, trunk/kernel/stgt_vsd.c)
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_vsd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,149 @@
+/*
+ * Target virtual device functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/namei.h>
+#include <linux/uio.h>
+#include <linux/fs.h>
+#include <linux/writeback.h>
+
+#include <tgt.h>
+#include <tgt_device.h>
+
+struct tgt_vsd_dev {
+	struct file *filp;
+};
+
+static void tgt_vsd_destroy(struct tgt_device *device)
+{
+	struct tgt_vsd_dev *vsddev = device->dt_data;
+	filp_close(vsddev->filp, NULL);
+}
+
+static int open_file(struct tgt_vsd_dev *vsddev, const char *path)
+{
+	struct file *filp;
+	mm_segment_t oldfs;
+	int err = 0;
+
+	oldfs = get_fs();
+	set_fs(get_ds());
+	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
+	set_fs(oldfs);
+
+	if (IS_ERR(filp)) {
+		err = PTR_ERR(filp);
+		printk("Can't open %s %d\n", path, err);
+	} else
+		vsddev->filp = filp;
+
+	return err;
+}
+
+static int tgt_vsd_create(struct tgt_device *device)
+{
+	struct tgt_vsd_dev *vsddev = device->dt_data;
+	struct inode *inode;
+	int err = 0;
+
+	err = open_file(vsddev, device->path);
+	if (err)
+		return err;
+
+	inode = vsddev->filp->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
+	else {
+		err = -EINVAL;
+		goto out;
+	}
+
+	device->size = inode->i_size;
+	printk("%s %llu\n", device->path, inode->i_size >> 9);
+
+	return 0;
+out:
+	filp_close(vsddev->filp, NULL);
+	return err;
+}
+
+static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
+{
+	struct iovec* iov;
+	int i;
+
+	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
+	if (!iov)
+		return NULL;
+
+	for (i = 0; i < sg_count; i++) {
+		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
+		iov[i].iov_len = sg[i].length;
+	}
+
+	return iov;
+}
+
+static int tgt_vsd_queue(struct tgt_device *device, struct tgt_cmnd *cmnd)
+{
+	struct tgt_vsd_dev *vsddev = device->dt_data;
+	ssize_t size;
+	struct iovec *iov;
+	loff_t pos = cmnd->offset;
+	int err = 0;
+
+	if (cmnd->bufflen + pos > device->size)
+		return -EOVERFLOW;
+
+	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+	if (!iov)
+		return -ENOMEM;
+
+	if (cmnd->rw == READ)
+		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
+	else
+		size = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
+
+	kfree(iov);
+
+/* not yet used
+	if (sync)
+		err = sync_page_range(inode, inode->i_mapping, pos,
+				      (size_t) cmnd->bufflen);
+*/
+	if ((size != cmnd->bufflen) || err)
+		return -EIO;
+	else
+		return 0;
+}
+
+static struct tgt_device_template tgt_vsd = {
+	.name = "tgt_vsd",
+	.module = THIS_MODULE,
+	.create = tgt_vsd_create,
+	.destroy = tgt_vsd_destroy,
+	.queue_cmnd = tgt_vsd_queue,
+};
+
+static int __init tgt_vsd_init(void)
+{
+	tgt_vsd.priv_data_size = sizeof(struct tgt_vsd_dev);
+	return tgt_device_template_register(&tgt_vsd);
+}
+
+static void __exit tgt_vsd_exit(void)
+{
+	tgt_device_template_unregister(&tgt_vsd);
+}
+
+module_init(tgt_vsd_init);
+module_exit(tgt_vsd_exit);
+MODULE_LICENSE("GPL");

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/Makefile	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,9 +1,9 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_STGT=20
-PROGRAMS = stgtd
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_TGT=20
+PROGRAMS = tgtd
 
 all: $(PROGRAMS)
 
-stgtd: stgtd.o scsi.o netlink.o ipc.o log.o
+tgtd: tgtd.o scsi.o netlink.o ipc.o log.o
 	$(CC) $^ -o $@ $(LIBS)
 
 clean:

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/ipc.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -3,7 +3,6 @@
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- *
  * This code is licenced under the GPL.
  */
 
@@ -19,8 +18,8 @@
 #include <sys/socket.h>
 #include <linux/netlink.h>
 
-#include <stgt_if.h>
-#include "stgtd.h"
+#include <tgt_if.h>
+#include "tgtd.h"
 
 void ipc_event_handle(int accept_fd)
 {
@@ -28,7 +27,7 @@
 	struct ucred cred;
 	int fd, err, res;
 	socklen_t len;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	char nlm_ev[8192], *data;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 	struct iovec iov;
@@ -87,7 +86,7 @@
 
 send:
 	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
-	nlh->nlmsg_type = STGT_KEVENT_RESPONSE;
+	nlh->nlmsg_type = TGT_KEVENT_RESPONSE;
 	nlh->nlmsg_flags = 0;
 	nlh->nlmsg_pid = 0;
 	ev = NLMSG_DATA(nlh);
@@ -111,8 +110,8 @@
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
 
 	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
 		return err;

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/netlink.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -22,8 +22,8 @@
 #include <asm/types.h>
 #include <linux/netlink.h>
 
-#include <stgt_if.h>
-#include "stgtd.h"
+#include <tgt_if.h>
+#include "tgtd.h"
 
 #define	NL_BUFSIZE	8192
 
@@ -88,7 +88,7 @@
 {
 	int err;
 	struct iovec iov;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
 
 	iov.iov_base = data;
@@ -100,7 +100,7 @@
 
 	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
 
-	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
+	ev = (struct tgt_event *) NLMSG_DATA(nlm_ev);
 	*res = ev->k.event_res.err;
 
 	return err;
@@ -110,7 +110,7 @@
 {
 	int result, len;
 	struct iovec iov[2];
-	struct stgt_event *ev = (struct stgt_event *) reqbuf;
+	struct tgt_event *ev = (struct tgt_event *) reqbuf;
 	uint64_t cid = ev->k.cmnd_req.cid;
 	uint8_t *scb;
 
@@ -135,13 +135,13 @@
 	iov[1].iov_base = resbuf;
 	iov[1].iov_len = len;
 
-	return nl_write(fd, STGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
+	return nl_write(fd, TGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
 }
 
 void nl_event_handle(int fd)
 {
 	struct nlmsghdr *nlh;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	int err;
 
 peek_again:
@@ -156,7 +156,7 @@
 	}
 
 	nlh = (struct nlmsghdr *) recvbuf;
-	ev = (struct stgt_event *) NLMSG_DATA(nlh);
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
 	dprintf("%d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
 
@@ -172,7 +172,7 @@
 	}
 
 	switch (nlh->nlmsg_type) {
-	case STGT_KEVENT_CMND_REQ:
+	case TGT_KEVENT_CMND_REQ:
 		cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	default:
@@ -186,9 +186,9 @@
 static void nl_start(int fd)
 {
 	int err, res;
-	struct stgt_event ev;
+	struct tgt_event ev;
 
-	err = nl_cmnd_call(fd, STGT_UEVENT_START, (char *) &ev, sizeof(ev), &res);
+	err = nl_cmnd_call(fd, TGT_UEVENT_START, (char *) &ev, sizeof(ev), &res);
 	if (err < 0 || res < 0) {
 		eprintf("%d %d\n", err, res);
 		exit(-1);
@@ -204,7 +204,7 @@
 		return -ENOMEM;
 	recvbuf = sendbuf + NL_BUFSIZE;
 
-	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_STGT);
+	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
 	if (fd < 0) {
 		eprintf("%d\n", fd);
 		return fd;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/scsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -24,7 +24,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#include "stgtd.h"
+#include "tgtd.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -65,7 +65,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[128];
 
-	sprintf(path, "/sys/class/stgt_device/device%d:%" PRIu64 "/size",
+	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/size",
 		tid, lun);
 
 	fd = open(path, O_RDONLY);
@@ -319,9 +319,9 @@
 	char buf[128];
 	int result = SAM_STAT_GOOD;
 
-	dir = opendir("/sys/class/stgt_device");
+	dir = opendir("/sys/class/tgt_device");
 	if (!dir) {
-		perror("can't open /sys/class/stgt_device\n");
+		perror("can't open /sys/class/tgt_device\n");
 		exit(0);
 	}
 
@@ -401,7 +401,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	sprintf(path, "/sys/class/stgt_device/device%d:%" PRIu64 "/path", tid, lun);
+	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/path", tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {

Deleted: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/stgtd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,184 +0,0 @@
-/*
- * Core target framework user-space daemon
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <inttypes.h>
-#include <signal.h>
-#include <string.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <asm/types.h>
-#include <sys/poll.h>
-#include <sys/signal.h>
-#include <sys/stat.h>
-
-#include <stgt_if.h>
-#include "stgtd.h"
-
-int nl_fd, ipc_fd;
-
-enum {
-	POLL_NL,
-	POLL_IPC,
-	POLL_MAX,
-};
-
-static struct option const long_options[] =
-{
-	{"foreground", no_argument, 0, 'f'},
-	{"debug", required_argument, 0, 'd'},
-	{"version", no_argument, 0, 'v'},
-	{"help", no_argument, 0, 'h'},
-	{0, 0, 0, 0},
-};
-
-static char program_name[] = "stgtd";
-
-static void usage(int status)
-{
-	if (status != 0)
-		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
-	else {
-		printf("Usage: %s [OPTION]\n", program_name);
-		printf("\
-SCSI target daemon.\n\
-  -f, --foreground        make the program run in the foreground\n\
-  -d, --debug debuglevel  print debugging information\n\
-  -h, --help              display this help and exit\n\
-");
-	}
-	exit(1);
-}
-
-static void signal_catch(int signo) {
-}
-
-static void init(int daemon, int debug)
-{
-	int fd;
-	char path[64];
-	struct sigaction sa_old;
-	struct sigaction sa_new;
-
-	/* do not allow ctrl-c for now... */
-	sa_new.sa_handler = signal_catch;
-	sigemptyset(&sa_new.sa_mask);
-	sa_new.sa_flags = 0;
-	sigaction(SIGINT, &sa_new, &sa_old );
-	sigaction(SIGPIPE, &sa_new, &sa_old );
-	sigaction(SIGTERM, &sa_new, &sa_old );
-
-	/* Should we use RT stuff? */
-	nice(-20);
-
-	/* Avoid oom-killer */
-	sprintf(path, "/proc/%d/oom_adj", getpid());
-	fd = open(path, O_WRONLY);
-	if (fd < 0) {
-		fprintf(stderr, "can not adjust oom-killer's pardon %s\n", path);
-		return;
-	}
-	write(fd, "-17\n", 4);
-	close(fd);
-
-	if (log_init("tgtd", DEFAULT_AREA_SIZE, daemon, debug) < 0) {
-		fprintf(stderr, "can not start the logger daemon\n");
-		exit(-1);
-	}
-}
-
-static void event_loop(struct pollfd *poll_array)
-{
-	int err;
-
-	while (1) {
-		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
-			if (errno != EINTR) {
-				eprintf("%d %d\n", err, errno);
-				exit(1);
-			}
-			continue;
-		}
-
-		if (poll_array[POLL_NL].revents)
-			nl_event_handle(nl_fd);
-
-		if (poll_array[POLL_IPC].revents)
-			ipc_event_handle(ipc_fd);
-
-	}
-}
-
-int main(int argc, char **argv)
-{
-	int ch, longindex;
-	int is_daemon = 1, is_debug = 1;
-	pid_t pid;
-	struct pollfd poll_array[POLL_MAX + 1];
-
-	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
-		switch (ch) {
-		case 'f':
-			is_daemon = 0;
-			break;
-		case 'd':
-			is_debug = atoi(optarg);
-			break;
-		case 'v':
-			exit(0);
-			break;
-		case 'h':
-			usage(0);
-			break;
-		default:
-			usage(1);
-			break;
-		}
-	}
-
-	init(is_daemon, is_debug);
-
-	if (is_daemon) {
-		pid = fork();
-		if (pid < 0)
-			exit(-1);
-		else if (pid)
-			exit(0);
-
-		chdir("/");
-
-		close(0);
-		open("/dev/null", O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
-
-	memset(poll_array, 0, sizeof(poll_array));
-
-	nl_fd = nl_open();
-	if (nl_fd < 0)
-		exit(nl_fd);
-
-	ipc_fd = ipc_open();
-	if (ipc_fd < 0)
-		exit(ipc_fd);
-
-	poll_array[POLL_NL].fd = nl_fd;
-	poll_array[POLL_NL].events = POLLIN;
-	poll_array[POLL_IPC].fd = ipc_fd;
-	poll_array[POLL_IPC].events = POLLIN;
-
-	event_loop(poll_array);
-
-	return 0;
-}

Deleted: trunk/usr/stgtd.h
===================================================================
--- trunk/usr/stgtd.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/stgtd.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,28 +0,0 @@
-#ifndef __SCSI_TARGET_DAEMON_H
-#define __SCSI_TARGET_DAEMON_H
-
-#include "log.h"
-
-#define eprintf(fmt, args...)						\
-do {									\
-	log_error("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#define dprintf(fmt, args...)						\
-do {									\
-	log_debug("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-extern int nl_fd;
-
-extern int nl_open(void);
-extern void nl_event_handle(int fd);
-extern int nl_cmnd_call(int fd, int type, char *data, int size, int *res);
-
-extern int ipc_open(void);
-extern void ipc_event_handle(int fd);
-
-extern int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb,
-			     uint8_t *data, int *len);
-
-#endif

Copied: trunk/usr/tgtd.c (from rev 67, trunk/usr/stgtd.c)
===================================================================
--- trunk/usr/stgtd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/tgtd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,184 @@
+/*
+ * Core target framework user-space daemon
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <inttypes.h>
+#include <signal.h>
+#include <string.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <asm/types.h>
+#include <sys/poll.h>
+#include <sys/signal.h>
+#include <sys/stat.h>
+
+#include <tgt_if.h>
+#include "tgtd.h"
+
+int nl_fd, ipc_fd;
+
+enum {
+	POLL_NL,
+	POLL_IPC,
+	POLL_MAX,
+};
+
+static struct option const long_options[] =
+{
+	{"foreground", no_argument, 0, 'f'},
+	{"debug", required_argument, 0, 'd'},
+	{"version", no_argument, 0, 'v'},
+	{"help", no_argument, 0, 'h'},
+	{0, 0, 0, 0},
+};
+
+static char program_name[] = "tgtd";
+
+static void usage(int status)
+{
+	if (status != 0)
+		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
+	else {
+		printf("Usage: %s [OPTION]\n", program_name);
+		printf("\
+Target framework daemon.\n\
+  -f, --foreground        make the program run in the foreground\n\
+  -d, --debug debuglevel  print debugging information\n\
+  -h, --help              display this help and exit\n\
+");
+	}
+	exit(1);
+}
+
+static void signal_catch(int signo) {
+}
+
+static void init(int daemon, int debug)
+{
+	int fd;
+	char path[64];
+	struct sigaction sa_old;
+	struct sigaction sa_new;
+
+	/* do not allow ctrl-c for now... */
+	sa_new.sa_handler = signal_catch;
+	sigemptyset(&sa_new.sa_mask);
+	sa_new.sa_flags = 0;
+	sigaction(SIGINT, &sa_new, &sa_old );
+	sigaction(SIGPIPE, &sa_new, &sa_old );
+	sigaction(SIGTERM, &sa_new, &sa_old );
+
+	/* Should we use RT stuff? */
+	nice(-20);
+
+	/* Avoid oom-killer */
+	sprintf(path, "/proc/%d/oom_adj", getpid());
+	fd = open(path, O_WRONLY);
+	if (fd < 0) {
+		fprintf(stderr, "can not adjust oom-killer's pardon %s\n", path);
+		return;
+	}
+	write(fd, "-17\n", 4);
+	close(fd);
+
+	if (log_init(program_name, DEFAULT_AREA_SIZE, daemon, debug) < 0) {
+		fprintf(stderr, "can not start the logger daemon\n");
+		exit(-1);
+	}
+}
+
+static void event_loop(struct pollfd *poll_array)
+{
+	int err;
+
+	while (1) {
+		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
+			if (errno != EINTR) {
+				eprintf("%d %d\n", err, errno);
+				exit(1);
+			}
+			continue;
+		}
+
+		if (poll_array[POLL_NL].revents)
+			nl_event_handle(nl_fd);
+
+		if (poll_array[POLL_IPC].revents)
+			ipc_event_handle(ipc_fd);
+
+	}
+}
+
+int main(int argc, char **argv)
+{
+	int ch, longindex;
+	int is_daemon = 1, is_debug = 1;
+	pid_t pid;
+	struct pollfd poll_array[POLL_MAX + 1];
+
+	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
+		switch (ch) {
+		case 'f':
+			is_daemon = 0;
+			break;
+		case 'd':
+			is_debug = atoi(optarg);
+			break;
+		case 'v':
+			exit(0);
+			break;
+		case 'h':
+			usage(0);
+			break;
+		default:
+			usage(1);
+			break;
+		}
+	}
+
+	init(is_daemon, is_debug);
+
+	if (is_daemon) {
+		pid = fork();
+		if (pid < 0)
+			exit(-1);
+		else if (pid)
+			exit(0);
+
+		chdir("/");
+
+		close(0);
+		open("/dev/null", O_RDWR);
+		dup2(0, 1);
+		dup2(0, 2);
+		setsid();
+	}
+
+	memset(poll_array, 0, sizeof(poll_array));
+
+	nl_fd = nl_open();
+	if (nl_fd < 0)
+		exit(nl_fd);
+
+	ipc_fd = ipc_open();
+	if (ipc_fd < 0)
+		exit(ipc_fd);
+
+	poll_array[POLL_NL].fd = nl_fd;
+	poll_array[POLL_NL].events = POLLIN;
+	poll_array[POLL_IPC].fd = ipc_fd;
+	poll_array[POLL_IPC].events = POLLIN;
+
+	event_loop(poll_array);
+
+	return 0;
+}

Copied: trunk/usr/tgtd.h (from rev 67, trunk/usr/stgtd.h)



From tomo at berlios.de  Mon Sep 12 11:09:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Mon, 12 Sep 2005 11:09:13 +0200
Subject: [Stgt-svn] r69 - trunk/kernel
Message-ID: <200509120909.j8C99Dwq005326@sheep.berlios.de>

Author: tomo
Date: 2005-09-12 11:09:12 +0200 (Mon, 12 Sep 2005)
New Revision: 69

Modified:
   trunk/kernel/tgt.c
Log:
Fix two memory corruption bugs.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-12 00:20:00 UTC (rev 68)
+++ trunk/kernel/tgt.c	2005-09-12 09:09:12 UTC (rev 69)
@@ -268,7 +268,7 @@
 	if (!target->twq)
 		goto put_template;
 
-	target->tt_data = kmalloc(sizeof(target->tt->priv_data_size), GFP_KERNEL);
+	target->tt_data = kmalloc(target->tt->priv_data_size, GFP_KERNEL);
 	if (!target->tt_data)
 		goto free_workqueue;
 
@@ -581,8 +581,8 @@
 		goto free_path;
 	}
 
-	device->dt_data = kmalloc(sizeof(device->dt->priv_data_size),
-				   GFP_KERNEL);
+	device->dt_data = kmalloc(device->dt->priv_data_size,
+				  GFP_KERNEL);
 	if (!device->dt_data)
 		goto put_template;
 



From tomo at berlios.de  Mon Sep 12 11:10:49 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Mon, 12 Sep 2005 11:10:49 +0200
Subject: [Stgt-svn] r70 - in trunk: iscsi/kernel kernel
Message-ID: <200509120910.j8C9An15005455@sheep.berlios.de>

Author: tomo
Date: 2005-09-12 11:10:48 +0200 (Mon, 12 Sep 2005)
New Revision: 70

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/tgt_vsd.c
Log:
Set priv_data_size in a better way.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-12 09:09:12 UTC (rev 69)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-12 09:10:48 UTC (rev 70)
@@ -1565,6 +1565,7 @@
 	.protocol = "scsi",
 	.target_create = target_add,
 	.target_destroy = target_del,
+	.priv_data_size = sizeof(struct iscsi_target),
 };
 
 static void iscsi_exit(void)
@@ -1603,7 +1604,8 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-	iet_tgt_target_template.priv_data_size = sizeof(struct iscsi_target);
+	eprintk("%d %Zd\n", iet_tgt_target_template.priv_data_size, sizeof(struct iscsi_target));
+
 	err = tgt_target_template_register(&iet_tgt_target_template);
 	if (err < 0)
 		goto err;

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-12 09:09:12 UTC (rev 69)
+++ trunk/kernel/tgt_vsd.c	2005-09-12 09:10:48 UTC (rev 70)
@@ -131,11 +131,11 @@
 	.create = tgt_vsd_create,
 	.destroy = tgt_vsd_destroy,
 	.queue_cmnd = tgt_vsd_queue,
+	.priv_data_size = sizeof(struct tgt_vsd_dev),
 };
 
 static int __init tgt_vsd_init(void)
 {
-	tgt_vsd.priv_data_size = sizeof(struct tgt_vsd_dev);
 	return tgt_device_template_register(&tgt_vsd);
 }
 



From tomo at berlios.de  Mon Sep 12 11:24:52 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Mon, 12 Sep 2005 11:24:52 +0200
Subject: [Stgt-svn] r71 - trunk/iscsi/kernel
Message-ID: <200509120924.j8C9OqS8006273@sheep.berlios.de>

Author: tomo
Date: 2005-09-12 11:24:52 +0200 (Mon, 12 Sep 2005)
New Revision: 71

Modified:
   trunk/iscsi/kernel/iscsi.c
Log:
Forget to remove unnecessary debug code.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-12 09:10:48 UTC (rev 70)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-12 09:24:52 UTC (rev 71)
@@ -1604,8 +1604,6 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-	eprintk("%d %Zd\n", iet_tgt_target_template.priv_data_size, sizeof(struct iscsi_target));
-
 	err = tgt_target_template_register(&iet_tgt_target_template);
 	if (err < 0)
 		goto err;



From tomo at berlios.de  Tue Sep 13 03:54:00 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 03:54:00 +0200
Subject: [Stgt-svn] r72 - trunk/kernel
Message-ID: <200509130154.j8D1s0oP001775@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 03:53:58 +0200 (Tue, 13 Sep 2005)
New Revision: 72

Modified:
   trunk/kernel/tgt.c
Log:
Replace assert with BUG_ON.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-12 09:24:52 UTC (rev 71)
+++ trunk/kernel/tgt.c	2005-09-13 01:53:58 UTC (rev 72)
@@ -36,15 +36,6 @@
 #define dprintk(fmt, args...)
 #endif
 
-#define assert(p) do {						\
-	if (!(p)) {						\
-		printk(KERN_CRIT "BUG at %s:%d assert(%s)\n",	\
-		       __FILE__, __LINE__, #p);			\
-		dump_stack();					\
-		BUG();						\
-	}							\
-} while (0)
-
 MODULE_LICENSE("GPL");
 
 static spinlock_t all_targets_lock;
@@ -657,7 +648,7 @@
 		return NULL;
 
 	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
-	assert(cmnd);
+	BUG_ON(!cmnd);
 	memset(cmnd, 0, sizeof(*cmnd));
 	cmnd->tgt_protocol_private = pcmnd_data;
 	cmnd->session = session;
@@ -739,7 +730,7 @@
 {
 	struct tgt_protocol *proto = cmnd->session->target->proto;
 
-	assert(list_empty(&cmnd->clist));
+	BUG_ON(!list_empty(&cmnd->clist));
 
 	proto->init_cmnd_buffer(cmnd);
 
@@ -804,7 +795,7 @@
 			     int result, uint32_t len)
 {
 	int i;
-	assert(cmnd->done);
+	BUG_ON(!cmnd->done);
 
 	if (len) {
 		cmnd->bufflen = len;
@@ -857,7 +848,7 @@
 	struct tgt_work *work;
 	struct tgt_session *session = cmnd->session;
 
-	assert(!cmnd->done);
+	BUG_ON(cmnd->done);
 	cmnd->done = done;
 	if (!done) {
 		eprintk("%s\n", "Null done function!");



From tomo at berlios.de  Tue Sep 13 14:42:32 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 14:42:32 +0200
Subject: [Stgt-svn] r73 - trunk/kernel
Message-ID: <200509131242.j8DCgWsD000985@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 14:42:31 +0200 (Tue, 13 Sep 2005)
New Revision: 73

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_target.h
Log:
Fix the wrong way to use workqueue.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-13 01:53:58 UTC (rev 72)
+++ trunk/kernel/tgt.c	2005-09-13 12:42:31 UTC (rev 73)
@@ -47,16 +47,10 @@
 static spinlock_t device_tmpl_lock;
 static LIST_HEAD(device_tmpl_list);
 
-static void session_init_handler(void *data);
-static spinlock_t atomic_sessions_lock;
-static LIST_HEAD(atomic_sessions);
-static DECLARE_WORK(atomic_session_work, session_init_handler,
-		    &atomic_sessions);
-
 static int daemon_pid;
 static struct sock *nls;
 
-static kmem_cache_t *cmnd_slab, *work_slab;
+static kmem_cache_t *cmnd_slab;
 
 /* TODO: lock per session */
 static spinlock_t cmnd_hash_lock;
@@ -64,70 +58,6 @@
 #define	cmnd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
 static struct list_head cmnd_hash[1 << TGT_HASH_ORDER];
 
-struct atomic_session_args {
-	struct tgt_session *session;
-	void (*done) (void *, struct tgt_session *);
-	int max_cmnds;
-	void *arg;
-	struct list_head list;
-};
-
-struct tgt_work {
-	void (*fn) (void *);
-	void *arg;
-	mempool_t *pool;
-	struct list_head list;
-};
-
-static struct tgt_work * tgt_init_work(struct tgt_session *session,
-					void (*fn)(void *), void *arg)
-{
-	struct tgt_work *work;
-	mempool_t *pool = session->work_pool;
-
-	work = mempool_alloc(pool, GFP_ATOMIC);
-	if (!work)
-		return NULL;
-
-	work->fn = fn;
-	work->arg = arg;
-	work->pool = pool;
-
-	return work;
-}
-
-static void tgt_worker(void *data)
-{
-	struct tgt_target *target = (struct tgt_target *) data;
-	struct tgt_work *work = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	if (!list_empty(&target->work_list)) {
-		work = list_entry(target->work_list.next, struct tgt_work, list);
-		list_del(&work->list);
-	}
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	if (work) {
-		work->fn(work->arg);
-		mempool_free(work, work->pool);
-	}
-
-	return;
-}
-
-static void tgt_queue_work(struct tgt_target *target, struct tgt_work *work)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add_tail(&work->list, &target->work_list);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	queue_work(target->twq, &target->work);
-}
-
 struct target_type_internal {
 	struct list_head list;
 	struct tgt_target_template *tt;
@@ -251,7 +181,6 @@
 	INIT_LIST_HEAD(&target->device_list);
 	INIT_LIST_HEAD(&target->work_list);
 
-	INIT_WORK(&target->work, tgt_worker, target);
 	target->queued_cmnds = queued_cmnds;
 
 	snprintf(name, sizeof(name), "tgtd%d", target->tid);
@@ -319,11 +248,6 @@
 	if (!session->cmnd_pool)
 		goto out;
 
-	session->work_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, work_slab);
-	if (!session->work_pool)
-		goto out;
-
 	spin_lock_irqsave(&target->lock, flags);
 	list_add(&session->slist, &target->session_list);
 	spin_unlock_irqrestore(&target->lock, flags);
@@ -333,63 +257,9 @@
 	if (session->cmnd_pool)
 		mempool_destroy(session->cmnd_pool);
 
-	if (session->work_pool)
-		mempool_destroy(session->work_pool);
-
 	return -ENOMEM;
 }
 
-static void session_init_handler(void *data)
-{
-	struct list_head *head = (struct list_head *) data;
-	struct atomic_session_args *ssa = NULL;
-	unsigned long flags;
-	int err;
-
-	spin_lock_irqsave(&atomic_sessions_lock, flags);
-	if (!list_empty(&atomic_sessions)) {
-		ssa = list_entry(head->next, struct atomic_session_args, list);
-		list_del(&ssa->list);
-	}
-	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
-
-	if (!ssa)
-		return;
-
-	err = session_init(ssa->session, ssa->max_cmnds);
-	if (err)
-		kfree(ssa->session);
-
-	ssa->done(ssa->arg, err ? NULL : ssa->session);
-
-	kfree(ssa);
-}
-
-static int session_atomic_init(struct tgt_session *session,
-			       int max_cmnds,
-			       void (*done) (void *, struct tgt_session *),
-			       int *arg)
-{
-	struct atomic_session_args *ssa;
-	unsigned long flags;
-
-	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
-	if (!ssa)
-		return -ENOMEM;
-
-	ssa->session = session;
-	ssa->max_cmnds = max_cmnds;
-	ssa->arg = arg;
-
-	spin_lock_irqsave(&atomic_sessions_lock, flags);
-	list_add(&ssa->list, &atomic_sessions);
-	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
-
-	queue_work(session->target->twq, &atomic_session_work);
-
-	return 0;
-}
-
 struct tgt_session *
 tgt_session_create(struct tgt_target *target,
 		   int max_cmnds,
@@ -398,16 +268,18 @@
 {
 	struct tgt_session *session;
 
-	if (!target) {
-		eprintk("%s\n", "Null target pointer!");
-		return NULL;
-	}
+	BUG_ON(!target);
 
 	if (done && !arg) {
 		eprintk("%s\n", "Need arg !");
 		return NULL;
 	}
 
+	if (done) {
+		eprintk("%s\n", "Not supported yet!");
+		BUG();
+	}
+
 	dprintk("%p %d\n", target, max_cmnds);
 
 	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
@@ -418,13 +290,6 @@
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 
-	if (done) {
-		if (session_atomic_init(session, max_cmnds, done, arg) < 0)
-			goto out;
-
-		return session;
-	}
-
 	if (session_init(session, max_cmnds) < 0)
 		goto out;
 
@@ -439,7 +304,6 @@
 int tgt_session_destroy(struct tgt_session *session)
 {
 	mempool_destroy(session->cmnd_pool);
-	mempool_destroy(session->work_pool);
 	kfree(session);
 
 	return 0;
@@ -736,10 +600,10 @@
 
 	if (done) {
 		struct tgt_session *session = cmnd->session;
-		struct tgt_work *work;
 
-		work = tgt_init_work(session, tgt_alloc_buffer, cmnd);
-		tgt_queue_work(session->target, work);
+		INIT_WORK(&cmnd->work, tgt_alloc_buffer, cmnd);
+		cmnd->done = done;
+		queue_work(session->target->twq, &cmnd->work);
 		return;
 	};
 
@@ -845,22 +709,15 @@
 
 int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
 {
-	struct tgt_work *work;
 	struct tgt_session *session = cmnd->session;
 
 	BUG_ON(cmnd->done);
+	BUG_ON(!done);
+
 	cmnd->done = done;
-	if (!done) {
-		eprintk("%s\n", "Null done function!");
-		return -EINVAL;
-	}
+	INIT_WORK(&cmnd->work, queuecommand, cmnd);
+	queue_work(session->target->twq, &cmnd->work);
 
-	work = tgt_init_work(session, queuecommand, cmnd);
-	if (!work)
-		return -ENOMEM;
-
-	tgt_queue_work(session->target, work);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(tgt_cmnd_queue);
@@ -1008,9 +865,6 @@
 	if (cmnd_slab)
 		kmem_cache_destroy(cmnd_slab);
 
-	if (work_slab)
-		kmem_cache_destroy(work_slab);
-
 	if (nls)
 		sock_release(nls->sk_socket);
 
@@ -1022,7 +876,6 @@
 	int i, err = -ENOMEM;
 
 	spin_lock_init(&all_targets_lock);
-	spin_lock_init(&atomic_sessions_lock);
 	spin_lock_init(&cmnd_hash_lock);
 	spin_lock_init(&target_tmpl_lock);
 	spin_lock_init(&device_tmpl_lock);
@@ -1039,12 +892,6 @@
 	if (!cmnd_slab)
 		goto out;
 
-	work_slab = kmem_cache_create("tgt_work", sizeof(struct tgt_work), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!work_slab)
-		goto out;
-
 	nls = netlink_kernel_create(NETLINK_TGT, event_recv);
 	if (!nls)
 		goto out;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-13 01:53:58 UTC (rev 72)
+++ trunk/kernel/tgt.h	2005-09-13 12:42:31 UTC (rev 73)
@@ -16,7 +16,6 @@
 	struct list_head slist;
 
 	mempool_t *cmnd_pool;
-	mempool_t *work_pool;
 };
 
 struct tgt_cmnd {
@@ -28,6 +27,7 @@
 
 	int rw;
 
+	struct work_struct work;
 	void (*done) (struct tgt_cmnd *);
 
 	struct list_head clist;
@@ -37,7 +37,6 @@
 	struct scatterlist *sg;
 	uint32_t bufflen;
 	uint64_t offset;
-
 	int result;
 
 	/* TODO: there should be a better way. */

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-09-13 01:53:58 UTC (rev 72)
+++ trunk/kernel/tgt_target.h	2005-09-13 12:42:31 UTC (rev 73)
@@ -51,7 +51,6 @@
 	struct list_head device_list;
 	struct list_head session_list;
 
-	struct work_struct work;
 	struct list_head work_list;
 	struct workqueue_struct *twq;
 };



From tomo at berlios.de  Tue Sep 13 16:18:26 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 16:18:26 +0200
Subject: [Stgt-svn] r74 - trunk/kernel
Message-ID: <200509131418.j8DEIQL1019096@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 16:18:26 +0200 (Tue, 13 Sep 2005)
New Revision: 74

Modified:
   trunk/kernel/tgt.c
Log:
Add async session allocation support.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-13 12:42:31 UTC (rev 73)
+++ trunk/kernel/tgt.c	2005-09-13 14:18:26 UTC (rev 74)
@@ -260,6 +260,27 @@
 	return -ENOMEM;
 }
 
+struct async_session_data {
+	struct tgt_session *session;
+	struct work_struct work;
+	int cmds;
+	void (*done)(void *, struct tgt_session *);
+	void *arg;
+};
+
+static void session_async_create(void *data)
+{
+	struct async_session_data *async
+		= (struct async_session_data *) data;
+	int err;
+
+	err = session_init(async->session, async->cmds);
+	if (err)
+		kfree(async->session);
+	async->done(async->arg, err ? NULL : async->session);
+	kfree(async);
+}
+
 struct tgt_session *
 tgt_session_create(struct tgt_target *target,
 		   int max_cmnds,
@@ -267,29 +288,39 @@
 		   void *arg)
 {
 	struct tgt_session *session;
+	struct async_session_data *async;
 
 	BUG_ON(!target);
 
 	if (done && !arg) {
-		eprintk("%s\n", "Need arg !");
+		eprintk("Need arg %d!\n", target->tid);
 		return NULL;
 	}
 
-	if (done) {
-		eprintk("%s\n", "Not supported yet!");
-		BUG();
-	}
-
 	dprintk("%p %d\n", target, max_cmnds);
 
 	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
 	if (!session)
 		return NULL;
-
 	memset(session, 0, sizeof(*session));
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 
+	if (done) {
+		async = kmalloc(sizeof(*async), GFP_ATOMIC);
+		if (!async)
+			goto out;
+
+		async->session = session;
+		async->cmds = max_cmnds;
+		async->done = done;
+		async->arg = arg;
+
+		INIT_WORK(&async->work, session_async_create, async);
+		queue_work(session->target->twq, &async->work);
+		return session;
+	}
+
 	if (session_init(session, max_cmnds) < 0)
 		goto out;
 



From tomo at berlios.de  Tue Sep 13 17:35:44 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 17:35:44 +0200
Subject: [Stgt-svn] r75 - trunk/iscsi/kernel
Message-ID: <200509131535.j8DFZiFv026023@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 17:35:44 +0200 (Tue, 13 Sep 2005)
New Revision: 75

Modified:
   trunk/iscsi/kernel/iscsi.c
Log:
Fix data corruption bugs. Finally, I succeeded to run postmark with ext3.


Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-13 14:18:26 UTC (rev 74)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-13 15:35:44 UTC (rev 75)
@@ -601,7 +601,8 @@
 
 	dprintk(D_GENERIC, "%u,%u\n", offset, size);
 
-	assert(tc);
+	BUG_ON(!tc);
+	BUG_ON(!tc->sg);
 	sg = tc->sg;
 	offset += sg->offset;
 
@@ -610,8 +611,8 @@
 		eprintk("%u %u %u %u", offset, size, sg->offset, tc->bufflen);
 		return -EIO;
 	}
-	assert(offset < sg->offset + tc->bufflen);
-	assert(offset + size <= sg->offset + tc->bufflen);
+	BUG_ON(!(offset < sg->offset + tc->bufflen));
+	BUG_ON(!(offset + size <= sg->offset + tc->bufflen));
 
 	idx = offset >> PAGE_CACHE_SHIFT;
 	offset &= ~PAGE_CACHE_MASK;
@@ -622,9 +623,12 @@
 
 	i = 0;
 	while (1) {
-		assert(sg->page);
+		sg = tc->sg + idx;
+		BUG_ON(!sg);
+		BUG_ON(!sg->page);
 		addr = page_address(sg->page);
-		assert(addr);
+		BUG_ON(!addr);
+
 		conn->read_iov[i].iov_base =  addr + offset;
 		if (offset + size <= PAGE_CACHE_SIZE) {
 			conn->read_iov[i].iov_len = size;



From tomo at berlios.de  Tue Sep 13 17:36:15 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 17:36:15 +0200
Subject: [Stgt-svn] r76 - trunk/kernel
Message-ID: <200509131536.j8DFaFGY026156@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 17:36:14 +0200 (Tue, 13 Sep 2005)
New Revision: 76

Modified:
   trunk/kernel/tgt.c
Log:
Trivial cosmetic fix.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-13 15:35:44 UTC (rev 75)
+++ trunk/kernel/tgt.c	2005-09-13 15:36:14 UTC (rev 76)
@@ -636,7 +636,7 @@
 		cmnd->done = done;
 		queue_work(session->target->twq, &cmnd->work);
 		return;
-	};
+	}
 
 	tgt_alloc_buffer(cmnd);
 }



From mingz at ele.uri.edu  Tue Sep 13 17:38:50 2005
From: mingz at ele.uri.edu (Ming Zhang)
Date: Tue, 13 Sep 2005 11:38:50 -0400
Subject: [Stgt-svn] r75 - trunk/iscsi/kernel
In-Reply-To: <200509131535.j8DFZiFv026023@sheep.berlios.de>
References: <200509131535.j8DFZiFv026023@sheep.berlios.de>
Message-ID: <1126625930.5385.34.camel@localhost.localdomain>

which iscsi ini u use? open-iscsi?

ming

On Tue, 2005-09-13 at 17:35 +0200, Tomonori Fujita at BerliOS wrote:
> Author: tomo
> Date: 2005-09-13 17:35:44 +0200 (Tue, 13 Sep 2005)
> New Revision: 75
> 
> Modified:
>    trunk/iscsi/kernel/iscsi.c
> Log:
> Fix data corruption bugs. Finally, I succeeded to run postmark with ext3.
> 
> 
> Modified: trunk/iscsi/kernel/iscsi.c
> ===================================================================
> --- trunk/iscsi/kernel/iscsi.c	2005-09-13 14:18:26 UTC (rev 74)
> +++ trunk/iscsi/kernel/iscsi.c	2005-09-13 15:35:44 UTC (rev 75)
> @@ -601,7 +601,8 @@
>  
>  	dprintk(D_GENERIC, "%u,%u\n", offset, size);
>  
> -	assert(tc);
> +	BUG_ON(!tc);
> +	BUG_ON(!tc->sg);
>  	sg = tc->sg;
>  	offset += sg->offset;
>  
> @@ -610,8 +611,8 @@
>  		eprintk("%u %u %u %u", offset, size, sg->offset, tc->bufflen);
>  		return -EIO;
>  	}
> -	assert(offset < sg->offset + tc->bufflen);
> -	assert(offset + size <= sg->offset + tc->bufflen);
> +	BUG_ON(!(offset < sg->offset + tc->bufflen));
> +	BUG_ON(!(offset + size <= sg->offset + tc->bufflen));
>  
>  	idx = offset >> PAGE_CACHE_SHIFT;
>  	offset &= ~PAGE_CACHE_MASK;
> @@ -622,9 +623,12 @@
>  
>  	i = 0;
>  	while (1) {
> -		assert(sg->page);
> +		sg = tc->sg + idx;
> +		BUG_ON(!sg);
> +		BUG_ON(!sg->page);
>  		addr = page_address(sg->page);
> -		assert(addr);
> +		BUG_ON(!addr);
> +
>  		conn->read_iov[i].iov_base =  addr + offset;
>  		if (offset + size <= PAGE_CACHE_SIZE) {
>  			conn->read_iov[i].iov_len = size;
> 
> _______________________________________________
> Stgt-svn mailing list
> Stgt-svn at lists.berlios.de
> http://lists.berlios.de/mailman/listinfo/stgt-svn



From fujita.tomonori at lab.ntt.co.jp  Tue Sep 13 17:44:34 2005
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 14 Sep 2005 00:44:34 +0900
Subject: [Stgt-svn] r75 - trunk/iscsi/kernel
In-Reply-To: <1126625930.5385.34.camel@localhost.localdomain>
References: <200509131535.j8DFZiFv026023@sheep.berlios.de>
	<1126625930.5385.34.camel@localhost.localdomain>
Message-ID: <20050914004434T.fujita.tomonori@lab.ntt.co.jp>

From: Ming Zhang <mingz at ele.uri.edu>
Subject: Re: [Stgt-svn] r75 - trunk/iscsi/kernel
Date: Tue, 13 Sep 2005 11:38:50 -0400

> which iscsi ini u use? open-iscsi?
> 
> ming
> 
> On Tue, 2005-09-13 at 17:35 +0200, Tomonori Fujita at BerliOS wrote:
> > Author: tomo
> > Date: 2005-09-13 17:35:44 +0200 (Tue, 13 Sep 2005)
> > New Revision: 75
> > 
> > Modified:
> >    trunk/iscsi/kernel/iscsi.c
> > Log:
> > Fix data corruption bugs. Finally, I succeeded to run postmark with ext3.
> 

I alway prefer sfnet when I debug unstable iSCSI target software.


From mingz at ele.uri.edu  Tue Sep 13 17:45:32 2005
From: mingz at ele.uri.edu (Ming Zhang)
Date: Tue, 13 Sep 2005 11:45:32 -0400
Subject: [Stgt-svn] r75 - trunk/iscsi/kernel
In-Reply-To: <20050914004434T.fujita.tomonori@lab.ntt.co.jp>
References: <200509131535.j8DFZiFv026023@sheep.berlios.de>
	 <1126625930.5385.34.camel@localhost.localdomain>
	 <20050914004434T.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <1126626332.5385.38.camel@localhost.localdomain>

ic. thx

ming

On Wed, 2005-09-14 at 00:44 +0900, FUJITA Tomonori wrote:
> From: Ming Zhang <mingz at ele.uri.edu>
> Subject: Re: [Stgt-svn] r75 - trunk/iscsi/kernel
> Date: Tue, 13 Sep 2005 11:38:50 -0400
> 
> > which iscsi ini u use? open-iscsi?
> > 
> > ming
> > 
> > On Tue, 2005-09-13 at 17:35 +0200, Tomonori Fujita at BerliOS wrote:
> > > Author: tomo
> > > Date: 2005-09-13 17:35:44 +0200 (Tue, 13 Sep 2005)
> > > New Revision: 75
> > > 
> > > Modified:
> > >    trunk/iscsi/kernel/iscsi.c
> > > Log:
> > > Fix data corruption bugs. Finally, I succeeded to run postmark with ext3.
> > 
> 
> I alway prefer sfnet when I debug unstable iSCSI target software.



From tomo at berlios.de  Tue Sep 13 18:09:05 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 13 Sep 2005 18:09:05 +0200
Subject: [Stgt-svn] r77 - trunk/iscsi/kernel
Message-ID: <200509131609.j8DG95jn030859@sheep.berlios.de>

Author: tomo
Date: 2005-09-13 18:09:04 +0200 (Tue, 13 Sep 2005)
New Revision: 77

Modified:
   trunk/iscsi/kernel/iscsi.c
Log:
Change TMF response (always REJECTED now).

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-13 15:36:14 UTC (rev 76)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-13 16:09:04 UTC (rev 77)
@@ -1106,7 +1106,8 @@
 	rsp_hdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
 	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
-	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE;
+/* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
+	rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_REJECTED;
 
 	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
 



From mnc at berlios.de  Tue Sep 13 19:21:13 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 13 Sep 2005 19:21:13 +0200
Subject: [Stgt-svn] r78 - trunk/kernel
Message-ID: <200509131721.j8DHLDlF014157@sheep.berlios.de>

Author: mnc
Date: 2005-09-13 19:21:12 +0200 (Tue, 13 Sep 2005)
New Revision: 78

Modified:
   trunk/kernel/tgt.c
Log:
hey the core supports high mem

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-13 16:09:04 UTC (rev 77)
+++ trunk/kernel/tgt.c	2005-09-13 17:21:12 UTC (rev 78)
@@ -699,9 +699,12 @@
 
 		for (i = 0; i < cmnd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-			char *p = data;
+			char *dest, *p = data;
 
-			memcpy(page_address(cmnd->sg[i].page), p, copy);
+			dest = kmap_atomic(cmnd->sg[i].page, KM_SOFTIRQ0);
+			memcpy(dest, p, copy);
+			kunmap_atomic(dest, KM_SOFTIRQ0);
+
 			p += copy;
 			len -= copy;
 		}



From mnc at berlios.de  Sat Sep 17 06:56:42 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 17 Sep 2005 06:56:42 +0200
Subject: [Stgt-svn] r79 - in trunk: iscsi/kernel kernel
Message-ID: <200509170456.j8H4ugxU000837@sheep.berlios.de>

Author: mnc
Date: 2005-09-17 06:56:28 +0200 (Sat, 17 Sep 2005)
New Revision: 79

Modified:
   trunk/iscsi/kernel/event.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi_dbg.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt_sysfs.c
Log:
make compile on 2.6.14-rc1

Modified: trunk/iscsi/kernel/event.c
===================================================================
--- trunk/iscsi/kernel/event.c	2005-09-13 17:21:12 UTC (rev 78)
+++ trunk/iscsi/kernel/event.c	2005-09-17 04:56:28 UTC (rev 79)
@@ -95,7 +95,8 @@
 
 int event_init(void)
 {
-	if (!(nl = netlink_kernel_create(NETLINK_IET, event_recv)))
+	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, THIS_MODULE);
+	if (!nl)
 		return -ENOMEM;
 	else
 		return 0;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-13 17:21:12 UTC (rev 78)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-17 04:56:28 UTC (rev 79)
@@ -1107,7 +1107,7 @@
 	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
 /* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
-	rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_REJECTED;
+	rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
 
 	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
 

Modified: trunk/iscsi/kernel/iscsi_dbg.h
===================================================================
--- trunk/iscsi/kernel/iscsi_dbg.h	2005-09-13 17:21:12 UTC (rev 78)
+++ trunk/iscsi/kernel/iscsi_dbg.h	2005-09-17 04:56:28 UTC (rev 79)
@@ -36,7 +36,7 @@
 	}							\
 } while (0)
 
-#if D_IOV
+#ifdef D_IOV
 static inline void iscsi_dump_iov(struct msghdr *msg)
 {
 	int i;
@@ -48,7 +48,7 @@
 #define iscsi_dump_iov(x) do {} while (0)
 #endif
 
-#if D_DUMP_PDU
+#ifdef D_DUMP_PDU
 static void iscsi_dump_char(int ch)
 {
 	static unsigned char text[16];

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-13 17:21:12 UTC (rev 78)
+++ trunk/kernel/tgt.c	2005-09-17 04:56:28 UTC (rev 79)
@@ -926,7 +926,7 @@
 	if (!cmnd_slab)
 		goto out;
 
-	nls = netlink_kernel_create(NETLINK_TGT, event_recv);
+	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
 	if (!nls)
 		goto out;
 

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-09-13 17:21:12 UTC (rev 78)
+++ trunk/kernel/tgt_sysfs.c	2005-09-17 04:56:28 UTC (rev 79)
@@ -23,10 +23,26 @@
 	tgt_target_show_fn(field, format_string)		\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
+#define tgt_target_template_show_fn(field, format_string)		\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
+	return snprintf (buf, 20, format_string, target->tt->field);	\
+}
+
+#define tgt_target_template_rd_attr(field, format_string)		\
+	tgt_target_template_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
 tgt_target_rd_attr(queued_cmnds, "%u\n");
+tgt_target_template_rd_attr(name, "%s\n");
+tgt_target_template_rd_attr(protocol, "%s\n");
 
 static struct class_device_attribute *tgt_target_attrs[] = {
 	&class_device_attr_queued_cmnds,
+	&class_device_attr_name,
+	&class_device_attr_protocol,
 	NULL
 };
 



From mnc at berlios.de  Sat Sep 17 07:00:39 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 17 Sep 2005 07:00:39 +0200
Subject: [Stgt-svn] r80 - trunk
Message-ID: <200509170500.j8H50dmQ003765@sheep.berlios.de>

Author: mnc
Date: 2005-09-17 07:00:35 +0200 (Sat, 17 Sep 2005)
New Revision: 80

Modified:
   trunk/Makefile
Log:
merge Ming's make file patch

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-09-17 04:56:28 UTC (rev 79)
+++ trunk/Makefile	2005-09-17 05:00:35 UTC (rev 80)
@@ -1,3 +1,11 @@
+#KERNELSRC := /usr/src/linux
+
+ifeq ($(KERNELSRC),)
+	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
+endif
+
+export KERNELSRC
+
 all:
 	make -C usr
 	make -C kernel



From mnc at berlios.de  Tue Sep 20 02:23:06 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 20 Sep 2005 02:23:06 +0200
Subject: [Stgt-svn] r81 - trunk/kernel
Message-ID: <200509200023.j8K0N6PP005244@sheep.berlios.de>

Author: mnc
Date: 2005-09-20 02:23:02 +0200 (Tue, 20 Sep 2005)
New Revision: 81

Modified:
   trunk/kernel/tgt_device.h
Log:
must use tabs instead of spaces

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-17 05:00:35 UTC (rev 80)
+++ trunk/kernel/tgt_device.h	2005-09-20 00:23:02 UTC (rev 81)
@@ -35,13 +35,13 @@
 
 	struct class_device cdev;
 
-        char *path;
-        uint64_t dev_id;
-        uint32_t blk_shift;
-        uint64_t size;
+	char *path;
+	uint64_t dev_id;
+	uint32_t blk_shift;
+	uint64_t size;
 
-        struct tgt_target *target;
-        struct list_head dlist;
+	struct tgt_target *target;
+	struct list_head dlist;
 };
 
 #define cdev_to_tgt_device(cdev) \



From mnc at berlios.de  Tue Sep 20 05:12:54 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 20 Sep 2005 05:12:54 +0200
Subject: [Stgt-svn] r82 - in trunk: include iscsi/usr kernel
Message-ID: <200509200312.j8K3CsqK021597@sheep.berlios.de>

Author: mnc
Date: 2005-09-20 05:12:46 +0200 (Tue, 20 Sep 2005)
New Revision: 82

Modified:
   trunk/include/tgt_if.h
   trunk/iscsi/usr/Makefile
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_vsd.c
Log:
open backing device/file in userspace then pass kernel a fd

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/include/tgt_if.h	2005-09-20 03:12:46 UTC (rev 82)
@@ -38,6 +38,7 @@
 			uint64_t dev_id;
 			uint32_t flags;
 			char type[32];
+			int fd;
 		} c_device;
 		struct {
 			int tid;

Modified: trunk/iscsi/usr/Makefile
===================================================================
--- trunk/iscsi/usr/Makefile	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/iscsi/usr/Makefile	2005-09-20 03:12:46 UTC (rev 82)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include -I../../include
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include -I../../include -DNETLINK_TGT=20
 PROGRAMS = ietd ietadm
 LIBS = -lcrypto
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/iscsi/usr/ctldev.c	2005-09-20 03:12:46 UTC (rev 82)
@@ -6,7 +6,6 @@
 
 #include <ctype.h>
 #include <errno.h>
-#include <fcntl.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
@@ -17,6 +16,7 @@
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <asm/fcntl.h>
 #include <linux/netlink.h>
 
 #include "iscsid.h"
@@ -332,27 +332,32 @@
 static int ipc_cmnd_execute(char *data, int len)
 {
 	int fd, err;
-	struct sockaddr_un addr;
+	struct sockaddr_nl addr;
 	char nlm_ev[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
+	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
+	if (fd < 0) {
+		log_error("Could not create socket %d %d\n", fd, errno);
 		return fd;
-
+	}
 	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
-	       strlen(TGT_IPC_NAMESPACE));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_pid = 0;
+	addr.nl_groups = 0;
 
 	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0)
+	if (err < 0) {
+		log_error("Could not connect %d %d\n", err, errno);
 		return err;
+	}
 
 	err = write(fd, data, len);
-	if (err < 0)
+	if (err < 0) {
+		log_error("sendmsg failed %d %d\n", err, errno);
 		goto out;
+	}
 
 	err = read(fd, nlm_ev, sizeof(nlm_ev));
 	if (err < 0)
@@ -423,7 +428,7 @@
 
 static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
 {
-	int err;
+	int err, fd;
 	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
 	char dtype[] = "tgt_vsd";
 	struct tgt_event *ev;
@@ -460,27 +465,37 @@
 	fprintf(stderr, "%s %d %s %s %Zd %Zd\n",
 		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
 
+	fd = open(path, O_RDWR | O_LARGEFILE);
+	if (fd < 0) {
+		log_error("Could not open %s errno %d\n", path, errno);
+		return errno;
+	}
+
 	memset(nlm_ev, 0, sizeof(nlm_ev));
 	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_CREATE,
-		   NLMSG_SPACE(sizeof(*ev) + strlen(path)), 0);
+		   NLMSG_SPACE(sizeof(*ev)), 0);
 
+	log_error("pid %d\n", nlh->nlmsg_pid);
+
 	ev = NLMSG_DATA(nlh);
 	ev->u.c_device.tid = tid;
 	ev->u.c_device.dev_id = lun;
+	ev->u.c_device.fd = fd;
 	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
-	memcpy((char *) ev + sizeof(*ev), path, strlen(path));
 
 	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
-
+	if (err)
+		close(fd);
 	return err;
 }
 
 static int iscsi_lunit_destroy(u32 tid, u32 lun)
 {
-	int err;
+	int err, fd;
 	char nlm_ev[8912];
 	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+	char path[PATH_MAX], buf[PATH_MAX];
 
 	fprintf(stderr, "%s %d %d %u\n", __FUNCTION__, __LINE__, tid, lun);
 
@@ -488,12 +503,27 @@
 	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
+	sprintf(path, "/sys/class/tgt_device/device%d:%d/fd", tid, lun);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		perror("iscsi_lunit_destroy could not open fd file");
+		return errno;
+	}
+
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		perror("iscsi_lunit_destroy could not read fd file");
+		return errno;
+	}
+	sscanf(buf, "%d\n", &fd);
+
 	ev = NLMSG_DATA(nlh);
 	ev->u.d_device.tid = tid;
 	ev->u.d_device.dev_id = lun;
 
 	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
-
+	close(fd);
 	return err;
 }
 

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/kernel/tgt.c	2005-09-20 03:12:46 UTC (rev 82)
@@ -438,13 +438,14 @@
 }
 
 static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
-			      char *path, unsigned long dflags)
+			     int fd, unsigned long dflags)
 {
 	struct tgt_target *target;
 	struct tgt_device *device;
 	unsigned long flags;
 
-	dprintk("%d %llu %s %s\n", tid, dev_id, device_type, path);
+	dprintk("tid %d dev_id %llu type %s fd %d\n",
+		tid, dev_id, device_type, fd);
 
 	target = target_find(tid);
 	if (!target)
@@ -457,14 +458,12 @@
 	memset(device, 0, sizeof(*device));
 	device->dev_id = dev_id;
 	device->target = target;
-	device->path = kstrdup(path, GFP_KERNEL);
-	if (!device->path)
-		goto free_device;
+	device->fd = fd;
 
 	device->dt = device_template_get(device_type);
 	if (!device->dt) {
 		eprintk("Could not get devive type %s\n", device_type);
-		goto free_path;
+		goto free_device;
 	}
 
 	device->dt_data = kmalloc(device->dt->priv_data_size,
@@ -492,8 +491,6 @@
 	kfree(device->dt_data);
 put_template:
 	device_template_put(device->dt);
-free_path:
-	kfree(device->path);
 free_device:
 	kfree(device);
 	return -EINVAL;
@@ -784,12 +781,12 @@
 	struct tgt_cmnd *cmnd;
 	struct tgt_target *target;
 
-	daemon_pid  = NETLINK_CREDS(skb)->pid;
+	dprintk("%d %d %d %d\n", daemon_pid, nlh->nlmsg_type,
+		nlh->nlmsg_pid, current->pid);
 
-	dprintk("%d %d\n", daemon_pid, nlh->nlmsg_type);
-
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
+		daemon_pid  = NETLINK_CREDS(skb)->pid;
 		dprintk("start %d\n", daemon_pid);
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
@@ -808,14 +805,10 @@
 			err = -EINVAL;
 		break;
 	case TGT_UEVENT_DEVICE_CREATE:
-		if (nlh->nlmsg_len <= NLMSG_SPACE(sizeof(*ev))) {
-			err = -EINVAL;
-			break;
-		}
 		err = tgt_device_create(ev->u.c_device.tid,
 					ev->u.c_device.dev_id,
 					ev->u.c_device.type,
-					(char *) ev + sizeof(*ev),
+					ev->u.c_device.fd,
 					ev->u.c_device.flags);
 		break;
 	case TGT_UEVENT_DEVICE_DESTROY:

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/kernel/tgt_device.h	2005-09-20 03:12:46 UTC (rev 82)
@@ -35,7 +35,7 @@
 
 	struct class_device cdev;
 
-	char *path;
+	int fd;
 	uint64_t dev_id;
 	uint32_t blk_shift;
 	uint64_t size;

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/kernel/tgt_scsi.c	2005-09-20 03:12:46 UTC (rev 82)
@@ -8,6 +8,7 @@
 #include <linux/fs.h>
 #include <linux/module.h>
 #include <linux/mm.h>
+#include <linux/highmem.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 
@@ -130,11 +131,15 @@
 		data[12] = ascode;
 		data[13] = ascodeq;
 	} else {
+		char *addr;
 		/* uspace command failure */
 
 		len = min(cmnd->bufflen, sizeof(scsi_tgt_cmnd->sense_buff));
 		alen = 0;
-		memcpy(data, page_address(cmnd->sg[0].page), len);
+
+		addr = kmap_atomic(cmnd->sg[0].page, KM_SOFTIRQ0);
+		memcpy(data, addr, len);
+		kunmap_atomic(addr, KM_SOFTIRQ0);
 	}
 
 	cmnd->error_buff = data;

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/kernel/tgt_sysfs.c	2005-09-20 03:12:46 UTC (rev 82)
@@ -154,11 +154,11 @@
 	tgt_device_show_fn(field, format_string)		\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
-tgt_device_rd_attr(path, "%s\n");
+tgt_device_rd_attr(fd, "%d\n");
 tgt_device_rd_attr(size, "%llu\n");
 
 static struct class_device_attribute *tgt_device_attrs[] = {
-	&class_device_attr_path,
+	&class_device_attr_fd,
 	&class_device_attr_size,
 	NULL,
 };
@@ -171,7 +171,6 @@
 
 	class_device_put(&target->cdev);
 	kfree(device->dt_data);
-	kfree(device->path);
 	kfree(device);
 }
 

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-20 00:23:02 UTC (rev 81)
+++ trunk/kernel/tgt_vsd.c	2005-09-20 03:12:46 UTC (rev 82)
@@ -8,9 +8,9 @@
 
 #include <linux/types.h>
 #include <linux/blkdev.h>
-#include <linux/namei.h>
 #include <linux/uio.h>
 #include <linux/fs.h>
+#include <linux/file.h>
 #include <linux/writeback.h>
 
 #include <tgt.h>
@@ -23,36 +23,30 @@
 static void tgt_vsd_destroy(struct tgt_device *device)
 {
 	struct tgt_vsd_dev *vsddev = device->dt_data;
-	filp_close(vsddev->filp, NULL);
+	fput(vsddev->filp);
 }
 
-static int open_file(struct tgt_vsd_dev *vsddev, const char *path)
+static int open_file(struct tgt_vsd_dev *vsddev, int fd)
 {
 	struct file *filp;
-	mm_segment_t oldfs;
-	int err = 0;
 
-	oldfs = get_fs();
-	set_fs(get_ds());
-	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
-	set_fs(oldfs);
+	filp = fget(fd);
+	if (!filp) {
+		printk("Could not get fd %d\n", fd);
+		return -EINVAL;
+	}
 
-	if (IS_ERR(filp)) {
-		err = PTR_ERR(filp);
-		printk("Can't open %s %d\n", path, err);
-	} else
-		vsddev->filp = filp;
-
-	return err;
+	vsddev->filp = filp;
+	return 0;
 }
 
 static int tgt_vsd_create(struct tgt_device *device)
 {
 	struct tgt_vsd_dev *vsddev = device->dt_data;
 	struct inode *inode;
-	int err = 0;
+	int err;
 
-	err = open_file(vsddev, device->path);
+	err = open_file(vsddev, device->fd);
 	if (err)
 		return err;
 
@@ -67,11 +61,11 @@
 	}
 
 	device->size = inode->i_size;
-	printk("%s %llu\n", device->path, inode->i_size >> 9);
+	printk("%d %llu\n", device->fd, inode->i_size >> 9);
 
 	return 0;
 out:
-	filp_close(vsddev->filp, NULL);
+	fput(vsddev->filp);
 	return err;
 }
 



From mnc at berlios.de  Tue Sep 20 05:15:04 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 20 Sep 2005 05:15:04 +0200
Subject: [Stgt-svn] r83 - trunk/kernel
Message-ID: <200509200315.j8K3F4js022232@sheep.berlios.de>

Author: mnc
Date: 2005-09-20 05:15:02 +0200 (Tue, 20 Sep 2005)
New Revision: 83

Modified:
   trunk/kernel/tgt.c
Log:
add reminder/comment about bug found in testing

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-20 03:12:46 UTC (rev 82)
+++ trunk/kernel/tgt.c	2005-09-20 03:15:02 UTC (rev 83)
@@ -725,6 +725,11 @@
 	if (cmnd->rw == READ || cmnd->rw == WRITE)
 		err = device->dt->queue_cmnd(device, cmnd);
 	else {
+		/*
+		 * TODO: if we fail to get the command to userspace there
+		 * will be no setup sense buffer below so we need to add
+		 * something.
+		 */
 		err = uspace_cmnd_send(cmnd);
 		if (err >= 0)
 			/* sent to userspace */



From mnc at berlios.de  Tue Sep 20 06:23:49 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 20 Sep 2005 06:23:49 +0200
Subject: [Stgt-svn] r84 - in trunk: . kernel
Message-ID: <200509200423.j8K4Nnj9003436@sheep.berlios.de>

Author: mnc
Date: 2005-09-20 06:23:45 +0200 (Tue, 20 Sep 2005)
New Revision: 84

Added:
   trunk/kernel/tgt_vdev.c
Removed:
   trunk/kernel/tgt_vsd.c
Modified:
   trunk/initd
   trunk/kernel/Makefile
Log:
rename vsd to vdev. NOTE YOU MUST CHANGE YOUR IETD.CONF TO REFLECT THIS. tgt_vsd IS NOW tgt_vdev

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-20 03:15:02 UTC (rev 83)
+++ trunk/initd	2005-09-20 04:23:45 UTC (rev 84)
@@ -10,7 +10,7 @@
 {
 	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/tgt_vsd.ko
+	insmod ${PWD}/kernel/tgt_vdev.ko
 	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
@@ -26,7 +26,7 @@
 
 	rmmod iscsi_trgt
 
-	rmmod tgt_vsd
+	rmmod tgt_vdev
 	rmmod tgt_scsi
 	rmmod tgt_core
 }

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-20 03:15:02 UTC (rev 83)
+++ trunk/kernel/Makefile	2005-09-20 04:23:45 UTC (rev 84)
@@ -8,7 +8,7 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vsd.o tgt_scsi.o
+obj-m		+= tgt_vdev.o tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Copied: trunk/kernel/tgt_vdev.c (from rev 83, trunk/kernel/tgt_vsd.c)
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-20 03:15:02 UTC (rev 83)
+++ trunk/kernel/tgt_vdev.c	2005-09-20 04:23:45 UTC (rev 84)
@@ -0,0 +1,147 @@
+/*
+ * Target virtual device functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/uio.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/writeback.h>
+
+#include <tgt.h>
+#include <tgt_device.h>
+
+struct tgt_vdev {
+	struct file *filp;
+};
+
+static void tgt_vdev_destroy(struct tgt_device *device)
+{
+	struct tgt_vdev *vdev = device->dt_data;
+	fput(vdev->filp);
+}
+
+static int open_file(struct tgt_vdev *vdev, int fd)
+{
+	struct file *filp;
+
+	filp = fget(fd);
+	if (!filp) {
+		printk("Could not get fd %d\n", fd);
+		return -EINVAL;
+	}
+
+	vdev->filp = filp;
+	return 0;
+}
+
+static int tgt_vdev_create(struct tgt_device *device)
+{
+	struct tgt_vdev *vdev = device->dt_data;
+	struct inode *inode;
+	int err;
+
+	err = open_file(vdev, device->fd);
+	if (err)
+		return err;
+
+	inode = vdev->filp->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
+	else {
+		err = -EINVAL;
+		goto out;
+	}
+
+	device->size = inode->i_size;
+	printk("%d %llu\n", device->fd, inode->i_size >> 9);
+
+	return 0;
+out:
+	fput(vdev->filp);
+	return err;
+}
+
+/*
+ * TODO: We need to redo our scatter lists so they take into account
+ * this common usage, but also not violate HW limits
+ */
+static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
+{
+	struct iovec* iov;
+	int i;
+
+	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
+	if (!iov)
+		return NULL;
+
+	for (i = 0; i < sg_count; i++) {
+		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
+		iov[i].iov_len = sg[i].length;
+	}
+
+	return iov;
+}
+
+static int tgt_vdev_queue(struct tgt_device *device, struct tgt_cmnd *cmnd)
+{
+	struct tgt_vdev *vdev = device->dt_data;
+	ssize_t size;
+	struct iovec *iov;
+	loff_t pos = cmnd->offset;
+	int err = 0;
+
+	if (cmnd->bufflen + pos > device->size)
+		return -EOVERFLOW;
+
+	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+	if (!iov)
+		return -ENOMEM;
+
+	if (cmnd->rw == READ)
+		size = generic_file_readv(vdev->filp, iov, cmnd->sg_count, &pos);
+	else
+		size = generic_file_writev(vdev->filp, iov, cmnd->sg_count, &pos);
+
+	kfree(iov);
+
+/* not yet used
+	if (sync)
+		err = sync_page_range(inode, inode->i_mapping, pos,
+				      (size_t) cmnd->bufflen);
+*/
+	if ((size != cmnd->bufflen) || err)
+		return -EIO;
+	else
+		return 0;
+}
+
+static struct tgt_device_template tgt_vdev = {
+	.name = "tgt_vdev",
+	.module = THIS_MODULE,
+	.create = tgt_vdev_create,
+	.destroy = tgt_vdev_destroy,
+	.queue_cmnd = tgt_vdev_queue,
+	.priv_data_size = sizeof(struct tgt_vdev),
+};
+
+static int __init tgt_vdev_init(void)
+{
+	return tgt_device_template_register(&tgt_vdev);
+}
+
+static void __exit tgt_vdev_exit(void)
+{
+	tgt_device_template_unregister(&tgt_vdev);
+}
+
+module_init(tgt_vdev_init);
+module_exit(tgt_vdev_exit);
+MODULE_LICENSE("GPL");

Deleted: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-20 03:15:02 UTC (rev 83)
+++ trunk/kernel/tgt_vsd.c	2005-09-20 04:23:45 UTC (rev 84)
@@ -1,143 +0,0 @@
-/*
- * Target virtual device functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <tgt.h>
-#include <tgt_device.h>
-
-struct tgt_vsd_dev {
-	struct file *filp;
-};
-
-static void tgt_vsd_destroy(struct tgt_device *device)
-{
-	struct tgt_vsd_dev *vsddev = device->dt_data;
-	fput(vsddev->filp);
-}
-
-static int open_file(struct tgt_vsd_dev *vsddev, int fd)
-{
-	struct file *filp;
-
-	filp = fget(fd);
-	if (!filp) {
-		printk("Could not get fd %d\n", fd);
-		return -EINVAL;
-	}
-
-	vsddev->filp = filp;
-	return 0;
-}
-
-static int tgt_vsd_create(struct tgt_device *device)
-{
-	struct tgt_vsd_dev *vsddev = device->dt_data;
-	struct inode *inode;
-	int err;
-
-	err = open_file(vsddev, device->fd);
-	if (err)
-		return err;
-
-	inode = vsddev->filp->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else {
-		err = -EINVAL;
-		goto out;
-	}
-
-	device->size = inode->i_size;
-	printk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-out:
-	fput(vsddev->filp);
-	return err;
-}
-
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i < sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-static int tgt_vsd_queue(struct tgt_device *device, struct tgt_cmnd *cmnd)
-{
-	struct tgt_vsd_dev *vsddev = device->dt_data;
-	ssize_t size;
-	struct iovec *iov;
-	loff_t pos = cmnd->offset;
-	int err = 0;
-
-	if (cmnd->bufflen + pos > device->size)
-		return -EOVERFLOW;
-
-	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (cmnd->rw == READ)
-		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
-	else
-		size = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
-
-	kfree(iov);
-
-/* not yet used
-	if (sync)
-		err = sync_page_range(inode, inode->i_mapping, pos,
-				      (size_t) cmnd->bufflen);
-*/
-	if ((size != cmnd->bufflen) || err)
-		return -EIO;
-	else
-		return 0;
-}
-
-static struct tgt_device_template tgt_vsd = {
-	.name = "tgt_vsd",
-	.module = THIS_MODULE,
-	.create = tgt_vsd_create,
-	.destroy = tgt_vsd_destroy,
-	.queue_cmnd = tgt_vsd_queue,
-	.priv_data_size = sizeof(struct tgt_vsd_dev),
-};
-
-static int __init tgt_vsd_init(void)
-{
-	return tgt_device_template_register(&tgt_vsd);
-}
-
-static void __exit tgt_vsd_exit(void)
-{
-	tgt_device_template_unregister(&tgt_vsd);
-}
-
-module_init(tgt_vsd_init);
-module_exit(tgt_vsd_exit);
-MODULE_LICENSE("GPL");



From mnc at berlios.de  Thu Sep 22 19:59:37 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Thu, 22 Sep 2005 19:59:37 +0200
Subject: [Stgt-svn] r85 - in trunk: include iscsi/include iscsi/kernel iscsi/usr kernel usr
Message-ID: <200509221759.j8MHxbiF028974@sheep.berlios.de>

Author: mnc
Date: 2005-09-22 19:59:36 +0200 (Thu, 22 Sep 2005)
New Revision: 85

Modified:
   trunk/include/tgt_if.h
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
   trunk/iscsi/usr/ietd.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/target.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_target.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
use netlink instead of ioctl for iet, TODO - merge userspace daemons and implement hch's suggestion

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/include/tgt_if.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -14,6 +14,7 @@
 	TGT_UEVENT_START,
 	TGT_UEVENT_TARGET_CREATE,
 	TGT_UEVENT_TARGET_DESTROY,
+	TGT_UEVENT_TARGET_PASSTHRU,
 	TGT_UEVENT_DEVICE_CREATE,
 	TGT_UEVENT_DEVICE_DESTROY,
 	TGT_UEVENT_CMND_RES,
@@ -21,6 +22,7 @@
 	/* kernel -> user */
 	TGT_KEVENT_RESPONSE,
 	TGT_KEVENT_CMND_REQ,
+	TGT_KEVENT_TARGET_PASSTHRU,
 };
 
 struct tgt_event {
@@ -35,6 +37,10 @@
 		} d_target;
 		struct {
 			int tid;
+			uint32_t len;
+		} tgt_passthru;
+		struct {
+			int tid;
 			uint64_t dev_id;
 			uint32_t flags;
 			char type[32];
@@ -61,7 +67,19 @@
 			int tid;
 			uint64_t dev_id;
 		} cmnd_req;
+		struct {
+			int tid;
+			uint32_t len;
+		} tgt_passthru;
 	} k;
-};
 
+	/*
+	 * I think a pointer is a unsigned long but this struct
+	 * gets passed around from the kernel to userspace and
+	 * back again so to handle some ppc64 setups where userspace is
+	 * 32 bits but the kernel is 64 we do this odd thing
+	 */
+	uint64_t data[0];
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
 #endif

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/include/iet_u.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -92,6 +92,46 @@
 	u32 state;
 };
 
+/*
+ * TODO: merge iet_msg with iet_event
+ *
+ * the info msgs/ioctls can be done in sysfs the event
+ * could be moved too
+ */
+/*
+ * msg types
+ */
+enum {
+	IET_ADD_SESSION,
+	IET_DEL_SESSION,
+	IET_ADD_CONN,
+	IET_DEL_CONN,
+	IET_ISCSI_PARAM_SET,
+	IET_ISCSI_PARAM_GET,
+};
+
+struct iet_msg {
+	uint32_t msg_type;
+	uint32_t result;
+
+	/* user-> kernel */
+	union {
+		struct session_info sess_info;
+		struct conn_info conn_info;
+		struct iscsi_param_info param_info;
+	} u;
+
+	/* kernel -> user */
+	union {
+		struct {
+			u32 tid;
+			u64 sid;
+			u32 cid;
+			u32 state;
+		} conn_state_change;
+	} k;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
 #define	DEFAULT_NR_WTHREADS	8
 #define	MIN_NR_WTHREADS		1
 #define	MAX_NR_WTHREADS		128
@@ -102,13 +142,4 @@
 
 #define NETLINK_IET	21
 
-#define ADD_SESSION _IOW('i', 6, struct session_info)
-#define DEL_SESSION _IOW('i', 7, struct session_info)
-#define GET_SESSION_INFO _IOWR('i', 8, struct session_info)
-#define ADD_CONN _IOW('i', 9, struct conn_info)
-#define DEL_CONN _IOW('i', 10, struct conn_info)
-#define GET_CONN_INFO _IOWR('i', 11, struct conn_info)
-#define ISCSI_PARAM_SET _IOW('i', 12, struct iscsi_param_info)
-#define ISCSI_PARAM_GET _IOWR('i', 13, struct iscsi_param_info)
-
 #endif

Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/kernel/config.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -6,6 +6,10 @@
 
 #include <linux/proc_fs.h>
 
+#include <tgt.h>
+#include <tgt_target.h>
+
+#include "iet_u.h"
 #include "iscsi.h"
 #include "iscsi_dbg.h"
 
@@ -62,188 +66,73 @@
 	return -ENOMEM;
 }
 
-static int get_conn_info(struct iscsi_target *target, unsigned long ptr)
+static int add_conn(struct iscsi_target *target, struct conn_info *info)
 {
-	int err;
 	struct iscsi_session *session;
-	struct conn_info info;
-	struct iscsi_conn *conn;
 
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	session = session_lookup(target, info.sid);
+	session = session_lookup(target, info->sid);
 	if (!session)
 		return -ENOENT;
-	conn = conn_lookup(session, info.cid);
 
-	info.cid = conn->cid;
-	info.stat_sn = conn->stat_sn;
-	info.exp_stat_sn = conn->exp_stat_sn;
-
-	if (copy_to_user((void *) ptr, &info, sizeof(info)))
-		return -EFAULT;
-
-	return 0;
+	return conn_add(session, info);
 }
 
-static int add_conn(struct iscsi_target *target, unsigned long ptr)
+static int del_conn(struct iscsi_target *target, struct conn_info *info)
 {
-	int err;
 	struct iscsi_session *session;
-	struct conn_info info;
 
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	if (!(session = session_lookup(target, info.sid)))
-		return -ENOENT;
-
-	return conn_add(session, &info);
-}
-
-static int del_conn(struct iscsi_target *target, unsigned long ptr)
-{
-	int err;
-	struct iscsi_session *session;
-	struct conn_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	if (!(session = session_lookup(target, info.sid)))
-		return -ENOENT;
-
-	return conn_del(session, &info);
-}
-
-static int get_session_info(struct iscsi_target *target, unsigned long ptr)
-{
-	int err;
-	struct iscsi_session *session;
-	struct session_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	session = session_lookup(target, info.sid);
-
+	session = session_lookup(target, info->sid);
 	if (!session)
 		return -ENOENT;
 
-	info.exp_cmd_sn = session->exp_cmd_sn;
-	info.max_cmd_sn = session->max_cmd_sn;
-
-	if (copy_to_user((void *) ptr, &info, sizeof(info)))
-		return -EFAULT;
-
-	return 0;
+	return conn_del(session, info);
 }
 
-static int add_session(struct iscsi_target *target, unsigned long ptr)
+int iet_msg_recv(struct tgt_target *tgt, uint32_t len, void *data)
 {
+	struct iscsi_target *target = tgt->tt_data;
+	struct iet_msg *msg = data;
 	int err;
-	struct session_info info;
 
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	return session_add(target, &info);
-}
-
-static int del_session(struct iscsi_target *target, unsigned long ptr)
-{
-	int err;
-	struct session_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	return session_del(target, info.sid);
-}
-
-static int iscsi_param_config(struct iscsi_target *target, unsigned long ptr, int set)
-{
-	int err;
-	struct iscsi_param_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		goto out;
-
-	if ((err = iscsi_param_set(target, &info, set)) < 0)
-		goto out;
-
-	if (!set)
-		err = copy_to_user((void *) ptr, &info, sizeof(info));
-
-out:
-	return err;
-}
-
-static long ioctl(struct file *file, unsigned int cmd, unsigned long arg)
-{
-	struct iscsi_target *target = NULL;
-	long err;
-	u32 id;
-
-	if ((err = get_user(id, (u32 *) arg)) != 0)
+	err = target_lock(target, 1);
+	if (err < 0) {
+		eprintk("interrupted %u %d\n", err, msg->msg_type);
 		goto done;
-
-	target = target_lookup_by_id(id);
-	if (!target) {
-		eprintk("can't find the target %u\n", id);
-		err = -EINVAL;
-		goto done;
 	}
 
-	if ((err = target_lock(target, 1)) < 0) {
-		eprintk("interrupted %ld %d\n", err, cmd);
-		goto done;
-	}
+	eprintk("msg_type %d\n", msg->msg_type);
 
-	switch (cmd) {
-	case ADD_SESSION:
-		err = add_session(target, arg);
+	switch (msg->msg_type) {
+	case IET_ADD_SESSION:
+		err = session_add(target, &msg->u.sess_info);
 		break;
 
-	case DEL_SESSION:
-		err = del_session(target, arg);
+	case IET_DEL_SESSION:
+		err = session_del(target, msg->u.sess_info.sid);
 		break;
 
-	case GET_SESSION_INFO:
-		err = get_session_info(target, arg);
+	case IET_ISCSI_PARAM_SET:
+		err = iscsi_param_set(target, &msg->u.param_info, 1);
 		break;
 
-	case ISCSI_PARAM_SET:
-		err = iscsi_param_config(target, arg, 1);
+	case IET_ISCSI_PARAM_GET:
+		err = iscsi_param_set(target, &msg->u.param_info, 0);
 		break;
 
-	case ISCSI_PARAM_GET:
-		err = iscsi_param_config(target, arg, 0);
+	case IET_ADD_CONN:
+		err = add_conn(target, &msg->u.conn_info);
 		break;
 
-	case ADD_CONN:
-		err = add_conn(target, arg);
+	case IET_DEL_CONN:
+		err = del_conn(target, &msg->u.conn_info);
 		break;
-
-	case DEL_CONN:
-		err = del_conn(target, arg);
-		break;
-
-	case GET_CONN_INFO:
-		err = get_conn_info(target, arg);
-		break;
-
+	default:
+		err = -EINVAL;
 	}
 
-	if (target)
-		target_unlock(target);
-
+	target_unlock(target);
 done:
+	msg->result = err;
+	tgt_msg_send(tgt, msg, sizeof(*msg), GFP_KERNEL);
 	return err;
 }
-
-struct file_operations ctr_fops = {
-	.owner		= THIS_MODULE,
-	.unlocked_ioctl	= ioctl,
-};

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -10,20 +10,17 @@
 #include <scsi/scsi.h>
 #include <linux/mempool.h>
 
-#include <iscsi.h>
-#include <iscsi_dbg.h>
 #include <tgt.h>
 #include <tgt_target.h>
 
+#include <iscsi.h>
+#include <iscsi_dbg.h>
+
 unsigned long debug_enable_flags;
 
 static kmem_cache_t *iscsi_cmnd_cache;
 static char dummy_data[1024];
 
-static int ctr_major;
-static char ctr_name[] = "ietctl";
-extern struct file_operations ctr_fops;
-
 static u32 cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
 	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
@@ -1570,13 +1567,12 @@
 	.protocol = "scsi",
 	.target_create = target_add,
 	.target_destroy = target_del,
+	.msg_recv = iet_msg_recv,
 	.priv_data_size = sizeof(struct iscsi_target),
 };
 
 static void iscsi_exit(void)
 {
-	unregister_chrdev(ctr_major, ctr_name);
-
 	iet_procfs_exit();
 
 	event_exit();
@@ -1593,11 +1589,6 @@
 
 	printk("iSCSI Enterprise Target Software - version %s\n", IET_VERSION_STRING);
 
-	if ((ctr_major = register_chrdev(0, ctr_name, &ctr_fops)) < 0) {
-		eprintk("failed to register the control device %d\n", ctr_major);
-		return ctr_major;
-	}
-
 	if ((err = iet_procfs_init()) < 0)
 		goto err;
 

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -231,6 +231,7 @@
 extern void target_del(struct tgt_target *);
 
 /* config.c */
+extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
 extern int iet_procfs_init(void);
 extern void iet_procfs_exit(void);
 extern int iet_info_show(struct seq_file *, iet_show_info_t *);

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/kernel/target.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -104,8 +104,7 @@
 static int iscsi_target_create(struct tgt_target *tt)
 {
 	int err = -EINVAL;
-	struct iscsi_target *target =
-		(struct iscsi_target *) tt->tt_data;
+	struct iscsi_target *target = tt->tt_data;
 
 	memset(target, 0, sizeof(*target));
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/usr/ctldev.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -7,6 +7,7 @@
 #include <ctype.h>
 #include <errno.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <dirent.h>
@@ -22,8 +23,6 @@
 #include "iscsid.h"
 #include "tgt_if.h"
 
-#define CTL_DEVICE	"/dev/ietctl"
-
 /*
  * tomo:
  * netlink code is temporary until ietd will be integrated to stgtd
@@ -37,68 +36,118 @@
 	int (*connection_op) (int fd, u32 tid, u64 sid, u32 cid, void *arg);
 };
 
-static int ctrdev_open(void)
+/* Temporary stgt glue */
+
+static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
 {
-	FILE *f;
-	char devname[256];
-	char buf[256];
-	int devn;
-	int ctlfd;
+	int fd, err;
+	struct sockaddr_nl addr;
+	struct nlmsghdr *nlm_recv;
+	struct tgt_event *ev;
+	struct iet_msg *msg;
 
-	if (!(f = fopen("/proc/devices", "r"))) {
-		perror("Cannot open control path to the driver\n");
-		return -1;
-	}
+	nlm_recv = calloc(1, len);
+	if (!nlm_recv)
+		return -ENOMEM;
 
-	devn = 0;
-	while (!feof(f)) {
-		if (!fgets(buf, sizeof (buf), f)) {
-			break;
-		}
-		if (sscanf(buf, "%d %s", &devn, devname) != 2) {
-			continue;
-		}
-		if (!strcmp(devname, "ietctl")) {
-			break;
-		}
-		devn = 0;
+	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
+	if (fd < 0) {
+		log_error("Could not create socket %d %d\n", fd, errno);
+		err = fd;
+		goto free_nlm;
 	}
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_pid = 0;
+	addr.nl_groups = 0;
 
-	fclose(f);
-	if (!devn) {
-		printf
-		    ("cannot find iscsictl in /proc/devices - "
-		     "make sure the module is loaded\n");
-		return -1;
+	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0) {
+		log_error("Could not connect %d %d\n", err, errno);
+		goto close;
 	}
 
-	unlink(CTL_DEVICE);
-	if (mknod(CTL_DEVICE, (S_IFCHR | 0600), (devn << 8))) {
-		printf("cannot create %s %d\n", CTL_DEVICE, errno);
-		return -1;
+	err = write(fd, nlm_send, len);
+	if (err < 0) {
+		log_error("sendmsg failed %d %d\n", err, errno);
+		goto close;
 	}
 
-	ctlfd = open(CTL_DEVICE, O_RDWR);
-	if (ctlfd < 0) {
-		printf("cannot open %s %d\n", CTL_DEVICE, errno);
-		return -1;
+	err = read(fd, nlm_recv, len);
+	if (err < 0)
+		goto close;
+
+	ev = NLMSG_DATA(nlm_recv);
+	switch (nlm_recv->nlmsg_type) {
+		case TGT_KEVENT_TARGET_PASSTHRU:
+			msg = (struct iet_msg *)ev->data;
+			memcpy(nlm_send, nlm_recv, len);
+			err = msg->result;
+		default:
+			err = ev->k.event_res.err;
 	}
 
-	return ctlfd;
+close:
+	if (fd >= 0)
+		close(fd);
+free_nlm:
+	free(nlm_recv);
+	return err;
 }
 
+static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
+		       int len, int flags)
+{
+	nlh->nlmsg_pid = pid;
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_seq = seq;
+}
+
+/*
+ * this will have to be redone and made generic when we move it
+ */
+static struct nlmsghdr *get_iet_msg(u32 tid, struct iet_msg **msg)
+{
+	int len;
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+
+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iet_msg));
+	nlh = calloc(1, len);
+	if (!nlh)
+		return NULL;
+
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_PASSTHRU, len, 0);
+	ev = NLMSG_DATA(nlh);
+	ev->u.tgt_passthru.tid = tid;
+	ev->u.tgt_passthru.len = sizeof(struct iet_msg);
+	*msg = (struct iet_msg *)ev->data;
+
+	return nlh;
+}
+
+
 static int iscsi_conn_destroy(u32 tid, u64 sid, u32 cid)
 {
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct conn_info *info;
 	int err;
-	struct conn_info info;
 
-	info.tid = tid;
-	info.sid = sid;
-	info.cid = cid;
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	if ((err = ioctl(ctrl_fd, DEL_CONN, &info)) < 0)
-		err = errno;
+	info = &msg->u.conn_info;
+	info->tid = tid;
+	info->sid = sid;
+	info->cid = cid;
+	msg->msg_type = IET_DEL_CONN;
 
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	free(nlh);
 	return err;
 }
 
@@ -240,149 +289,145 @@
 
 static int iscsi_param_get(u32 tid, u64 sid, struct iscsi_param *param)
 {
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct iscsi_param_info *info;
 	int err, i;
-	struct iscsi_param_info info;
 
-	memset(&info, 0, sizeof(info));
-	info.tid = tid;
-	info.sid = sid;
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	if ((err = ioctl(ctrl_fd, ISCSI_PARAM_GET, &info)) < 0)
-		log_error("Can't set session param %d %d\n", info.tid, errno);
+	info = &msg->u.param_info;
+	info->tid = tid;
+	info->sid = sid;
 
-	for (i = 0; i < session_key_last; i++)
-		param[i].val = info.session_param[i];
+	msg->msg_type = IET_ISCSI_PARAM_GET;
 
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	if (err < 0)
+		log_error("Can't get session param %d %d\n", info->tid, err);
+	else {
+		struct tgt_event *ev;
+
+		ev = NLMSG_DATA(nlh);
+		msg = (struct iet_msg *)ev->data;
+		info = &msg->u.param_info;
+
+		for (i = 0; i < session_key_last; i++)
+			param[i].val = info->session_param[i];
+	}
+
+	free(nlh);
 	return err;
 }
 
 static int iscsi_param_set(u32 tid, u64 sid, int type, u32 partial, struct iscsi_param *param)
 {
-	int i, err;
-	struct iscsi_param_info info;
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct iscsi_param_info *info;
+	int err, i;
 
-	memset(&info, 0, sizeof(info));
-	info.tid = tid;
-	info.sid = sid;
-	info.param_type = type;
-	info.partial = partial;
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	if (info.param_type == key_session)
+	info = &msg->u.param_info;
+	info->tid = tid;
+	info->sid = sid;
+	info->param_type = type;
+	info->partial = partial;
+
+	if (type == key_session)
 		for (i = 0; i < session_key_last; i++)
-			info.session_param[i] = param[i].val;
+			info->session_param[i] = param[i].val;
 	else
 		for (i = 0; i < target_key_last; i++)
-			info.target_param[i] = param[i].val;
+			info->target_param[i] = param[i].val;
+	msg->msg_type = IET_ISCSI_PARAM_SET;
 
-	if ((err = ioctl(ctrl_fd, ISCSI_PARAM_SET, &info)) < 0)
-		fprintf(stderr, "%d %d %u " "%" PRIu64 " %d %u\n",
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	if (err)
+		fprintf(stderr, "%d %d %u %llu %d %u\n",
 			err, errno, tid, sid, type, partial);
-
+	free(nlh);
 	return err;
 }
 
 static int iscsi_session_create(u32 tid, u64 sid, u32 exp_cmd_sn, u32 max_cmd_sn, char *name)
 {
-	struct session_info info;
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct session_info *info;
+	int err;
 
-	memset(&info, 0, sizeof(info));
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	info.tid = tid;
-	info.sid = sid;
-	info.exp_cmd_sn = exp_cmd_sn;
-	info.max_cmd_sn = max_cmd_sn;
-	strncpy(info.initiator_name, name, sizeof(info.initiator_name) - 1);
+	info = &msg->u.sess_info;
+	info->tid = tid;
+	info->sid = sid;
+	info->exp_cmd_sn = exp_cmd_sn;
+	info->max_cmd_sn = max_cmd_sn;
+	strncpy(info->initiator_name, name, sizeof(info->initiator_name) - 1);
+	msg->msg_type = IET_ADD_SESSION;
 
-	return ioctl(ctrl_fd, ADD_SESSION, &info);
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	free(nlh);
+	return err;
 }
 
 static int iscsi_session_destroy(u32 tid, u64 sid)
 {
-	struct session_info info;
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct session_info *info;
+	int err;
 
-	memset(&info, 0, sizeof(info));
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	info.tid = tid;
-	info.sid = sid;
+	info = &msg->u.sess_info;
+	info->tid = tid;
+	info->sid = sid;
+	msg->msg_type = IET_DEL_SESSION;
 
-	return ioctl(ctrl_fd, DEL_SESSION, &info);
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	free(nlh);
+	return err;
 }
 
 static int iscsi_conn_create(u32 tid, u64 sid, u32 cid, u32 stat_sn, u32 exp_stat_sn,
 			     int fd, u32 hdigest, u32 ddigest)
 {
-	struct conn_info info;
+	struct iet_msg *msg;
+	struct nlmsghdr *nlh;
+	struct conn_info *info;
+	int err;
 
-	memset(&info, 0, sizeof(info));
+	nlh = get_iet_msg(tid, &msg);
+	if (!nlh)
+		return -ENOMEM;
 
-	info.tid = tid;
-	info.sid = sid;
-	info.cid = cid;
-	info.stat_sn = stat_sn;
-	info.exp_stat_sn = exp_stat_sn;
-	info.fd = fd;
-	info.header_digest = hdigest;
-	info.data_digest = ddigest;
+	info = &msg->u.conn_info;
+	info->tid = tid;
+	info->sid = sid;
+	info->cid = cid;
+	info->stat_sn = stat_sn;
+	info->exp_stat_sn = exp_stat_sn;
+	info->fd = fd;
+	info->header_digest = hdigest;
+	info->data_digest = ddigest;
+	msg->msg_type = IET_ADD_CONN;
 
-	return ioctl(ctrl_fd, ADD_CONN, &info);
-}
-
-/* Temporary stgt glue */
-
-static int ipc_cmnd_execute(char *data, int len)
-{
-	int fd, err;
-	struct sockaddr_nl addr;
-	char nlm_ev[NLMSG_SPACE(sizeof(struct tgt_event))];
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
-
-	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd < 0) {
-		log_error("Could not create socket %d %d\n", fd, errno);
-		return fd;
-	}
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
-	addr.nl_pid = 0;
-	addr.nl_groups = 0;
-
-	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0) {
-		log_error("Could not connect %d %d\n", err, errno);
-		return err;
-	}
-
-	err = write(fd, data, len);
-	if (err < 0) {
-		log_error("sendmsg failed %d %d\n", err, errno);
-		goto out;
-	}
-
-	err = read(fd, nlm_ev, sizeof(nlm_ev));
-	if (err < 0)
-		goto out;
-
-	ev = NLMSG_DATA(nlh);
-	err = ev->k.event_res.err;
-
-out:
-	if (fd > 0)
-		close(fd);
-
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+	free(nlh);
 	return err;
 }
 
-static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
-		       int len, int flags)
-{
-	nlh->nlmsg_pid = pid;
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_seq = seq;
-}
-
 static int iscsi_target_create(u32 *tid, char *name)
 {
 	int err;
@@ -398,7 +443,7 @@
 	sprintf(ev->u.c_target.type, "%s", "iet");
 	ev->u.c_target.nr_cmnds = DEFAULT_NR_QUEUED_CMNDS;
 
-	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 	if (err > 0) {
 		*tid = err;
 		err = 0;
@@ -421,7 +466,7 @@
 	ev = NLMSG_DATA(nlh);
 	ev->u.d_target.tid = tid;
 
-	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 
 	return err;
 }
@@ -429,10 +474,10 @@
 static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
 {
 	int err, fd;
-	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
+	char *p, *q, *type = NULL, *path = NULL;
 	char dtype[] = "tgt_vsd";
 	struct tgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+	struct nlmsghdr *nlh;
 
 	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
 
@@ -471,21 +516,26 @@
 		return errno;
 	}
 
-	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlh = calloc(1, NLMSG_SPACE(sizeof(*ev)));
+	if (!nlh) {
+		err = -ENOMEM;
+		goto close_fd;
+	}
 	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_CREATE,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
-	log_error("pid %d\n", nlh->nlmsg_pid);
-
 	ev = NLMSG_DATA(nlh);
 	ev->u.c_device.tid = tid;
 	ev->u.c_device.dev_id = lun;
 	ev->u.c_device.fd = fd;
 	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
 
-	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
-	if (err)
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
+close_fd:
+	if (err) {
 		close(fd);
+		free(nlh);
+	}
 	return err;
 }
 
@@ -503,6 +553,10 @@
 	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
+	ev = NLMSG_DATA(nlh);
+	ev->u.d_device.tid = tid;
+	ev->u.d_device.dev_id = lun;
+
 	sprintf(path, "/sys/class/tgt_device/device%d:%d/fd", tid, lun);
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {
@@ -518,17 +572,12 @@
 	}
 	sscanf(buf, "%d\n", &fd);
 
-	ev = NLMSG_DATA(nlh);
-	ev->u.d_device.tid = tid;
-	ev->u.d_device.dev_id = lun;
-
-	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 	close(fd);
 	return err;
 }
 
 struct iscsi_kernel_interface ioctl_ki = {
-	.ctldev_open = ctrdev_open,
 	.lunit_create = iscsi_lunit_create,
 	.lunit_destroy = iscsi_lunit_destroy,
 	.param_get = iscsi_param_get,

Modified: trunk/iscsi/usr/ietd.c
===================================================================
--- trunk/iscsi/usr/ietd.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/usr/ietd.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -412,11 +412,6 @@
 		exit(-1);
 	};
 
-	if ((ctrl_fd = ki->ctldev_open()) < 0) {
-		perror("ctldev fd\n");
-		exit(-1);
-	}
-
 	if ((ipc_fd = ietadm_request_listen()) < 0) {
 		perror("ipc fd\n");
 		exit(-1);

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/usr/iscsid.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -198,7 +198,6 @@
 
 /* ctldev.c */
 struct iscsi_kernel_interface {
-	int (*ctldev_open) (void);
 	int (*lunit_create) (u32 tid, u32 lun, char *args);
 	int (*lunit_destroy) (u32 tid, u32 lun);
 	int (*param_get) (u32, u64, struct iscsi_param *);

Modified: trunk/iscsi/usr/target.c
===================================================================
--- trunk/iscsi/usr/target.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/iscsi/usr/target.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -112,7 +112,7 @@
 	memcpy(target->name, name, sizeof(target->name) - 1);
 
 	if ((err = ki->target_create(tid, name)) < 0) {
-		log_warning("can't create a target %d %u\n", errno, *tid);
+		log_warning("can't create a target %d %u\n", err, *tid);
 		goto out;
 	}
 

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/kernel/tgt.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -47,7 +47,11 @@
 static spinlock_t device_tmpl_lock;
 static LIST_HEAD(device_tmpl_list);
 
-static int daemon_pid;
+/*
+ * when we merge the daemons we will not need both of these
+ * this is just a tmp hack
+ */
+static int tgt_pid, daemon_pid;
 static struct sock *nls;
 
 static kmem_cache_t *cmnd_slab;
@@ -158,7 +162,7 @@
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
-	if (!daemon_pid) {
+	if (!tgt_pid) {
 		eprintk("%s\n", "Run the user-space daemon first!");
 		return NULL;
 	}
@@ -523,8 +527,8 @@
 }
 
 struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
-				   uint8_t *proto_data,
-				   uint8_t *id_buff, int buff_size)
+				 uint8_t *proto_data,
+				 uint8_t *id_buff, int buff_size)
 {
 	struct tgt_protocol *proto = session->target->proto;
 	struct tgt_cmnd *cmnd;
@@ -536,11 +540,19 @@
 	 * However, how can we guarantee the specified number of commands ?
 	 */
 	pcmnd_data = kmalloc(proto->priv_cmd_data_size, GFP_ATOMIC);
-	if (!pcmnd_data)
+	if (!pcmnd_data) {
+		eprintk("Could not allocate command private data for %p",
+			 session);
 		return NULL;
+	}
 
 	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
-	BUG_ON(!cmnd);
+	if (!cmnd) {
+		eprintk("Could not allocate tgt_cmnd for %p\n", session);
+		kfree(pcmnd_data);
+		return NULL;
+	}
+
 	memset(cmnd, 0, sizeof(*cmnd));
 	cmnd->tgt_protocol_private = pcmnd_data;
 	cmnd->session = session;
@@ -565,6 +577,8 @@
 	unsigned long flags;
 	int i;
 
+	dprintk("cid %llu\n", cmnd->cid);
+
 	kfree(cmnd->tgt_protocol_private);
 
 	for (i = 0; i < cmnd->sg_count; i++)
@@ -590,6 +604,9 @@
 	cmnd->sg_count = pgcnt(len, offset);
 	offset &= ~PAGE_CACHE_MASK;
 
+	dprintk("cid %llu pg_count %d offset %llu len %d\n", cmnd->cid,
+		cmnd->sg_count, cmnd->offset, cmnd->bufflen);
+
 	cmnd->sg = kmalloc(cmnd->sg_count * sizeof(struct scatterlist),
 			   GFP_KERNEL | __GFP_NOFAIL);
 
@@ -654,19 +671,19 @@
 		return -ENOMEM;
 
 	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, daemon_pid, 0,
-			  TGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
+	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMND_REQ,
+			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 
-	pdu = (char *) ev + sizeof(*ev);
+	pdu = (char *) ev->data;
 	ev->k.cmnd_req.tid = cmnd->session->target->tid;
 	ev->k.cmnd_req.dev_id = cmnd->dev_id;
 	ev->k.cmnd_req.cid = cmnd->cid;
 
 	proto->build_uspace_pdu(cmnd, pdu);
 
-	return netlink_unicast(nls, skb, daemon_pid, 0);
+	return netlink_unicast(nls, skb, tgt_pid, 0);
 }
 
 static void cmnd_done(struct tgt_cmnd *cmnd, int result)
@@ -683,12 +700,16 @@
 	done(cmnd);
 }
 
-static void uspace_cmnd_done(struct tgt_cmnd *cmnd, char *data,
+static void uspace_cmnd_done(struct tgt_cmnd *cmnd, void *data,
 			     int result, uint32_t len)
 {
+	char *p = data;
 	int i;
 	BUG_ON(!cmnd->done);
 
+	dprintk("cid %llu result %d len %d\n",
+		cmnd->cid, result, len);
+
 	if (len) {
 		cmnd->bufflen = len;
 		cmnd->offset = 0;
@@ -696,12 +717,8 @@
 
 		for (i = 0; i < cmnd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-			char *dest, *p = data;
 
-			dest = kmap_atomic(cmnd->sg[i].page, KM_SOFTIRQ0);
-			memcpy(dest, p, copy);
-			kunmap_atomic(dest, KM_SOFTIRQ0);
-
+			memcpy(page_address(cmnd->sg[i].page), p, copy);
 			p += copy;
 			len -= copy;
 		}
@@ -717,6 +734,8 @@
 	struct tgt_target *target = cmnd->session->target;
 	struct tgt_device *device;
 
+	dprintk("cid %llu rw %d\n", cmnd->cid, cmnd->rw);
+
 	/* Should we do this earlier? */
 	device = tgt_device_find(target, cmnd->dev_id);
 	if (device)
@@ -779,6 +798,33 @@
 	return cmnd;
 }
 
+int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
+		 unsigned int gfp_flags)
+{
+	struct tgt_event *ev;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	int len;
+
+	len = NLMSG_SPACE(sizeof(*ev) + data_len);
+	skb = alloc_skb(len, gfp_flags);
+	if (!skb)
+		return -ENOMEM;
+
+	dprintk("%d %Zd %d\n", len, sizeof(*ev), data_len);
+	nlh = __nlmsg_put(skb, daemon_pid, 0, TGT_KEVENT_TARGET_PASSTHRU,
+			 len - sizeof(*nlh), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+
+	memcpy(ev->data, data, data_len);
+	ev->k.tgt_passthru.tid = target->tid;
+	ev->k.tgt_passthru.len = data_len;
+
+	return netlink_unicast(nls, skb, daemon_pid, 0);
+}
+EXPORT_SYMBOL_GPL(tgt_msg_send);
+
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;
@@ -789,10 +835,15 @@
 	dprintk("%d %d %d %d\n", daemon_pid, nlh->nlmsg_type,
 		nlh->nlmsg_pid, current->pid);
 
+	/*
+	 * stupid hack until we merge daemons
+	 */
+	daemon_pid = NETLINK_CREDS(skb)->pid;
+
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
-		daemon_pid  = NETLINK_CREDS(skb)->pid;
-		dprintk("start %d\n", daemon_pid);
+		tgt_pid  = NETLINK_CREDS(skb)->pid;
+		dprintk("start %d\n", tgt_pid);
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
@@ -809,6 +860,18 @@
 		else
 			err = -EINVAL;
 		break;
+	case TGT_UEVENT_TARGET_PASSTHRU:
+		target = target_find(ev->u.tgt_passthru.tid);
+		if (!target || !target->tt->msg_recv) {
+			dprintk("Could not find target %d for passthru\n",
+				ev->u.tgt_passthru.tid);
+			err = -EINVAL;
+			break;
+		}
+
+		err = target->tt->msg_recv(target, ev->u.tgt_passthru.len,
+					   ev->data);
+		break;
 	case TGT_UEVENT_DEVICE_CREATE:
 		err = tgt_device_create(ev->u.c_device.tid,
 					ev->u.c_device.dev_id,
@@ -823,7 +886,7 @@
 	case TGT_UEVENT_CMND_RES:
 		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
 		if (cmnd)
-			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
+			uspace_cmnd_done(cmnd, ev->data,
 					 ev->u.cmnd_res.result,
 					 ev->u.cmnd_res.len);
 		else {
@@ -870,11 +933,17 @@
 		err = event_recv_msg(skb, nlh);
 
 		eprintk("%d %d\n", nlh->nlmsg_type, err);
-		ev->k.event_res.err = err;
-		if (nlh->nlmsg_type != TGT_UEVENT_CMND_RES)
+		/*
+		 * TODO for passthru commands the lower level should
+		 * probably handle the result or we should modify this
+		 */
+		if (nlh->nlmsg_type != TGT_UEVENT_CMND_RES &&
+		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
+			ev->k.event_res.err = err;
 			send_event_res(NETLINK_CREDS(skb)->pid,
 				       TGT_KEVENT_RESPONSE,
 				       ev, sizeof(*ev));
+		}
 		skb_pull(skb, rlen);
 	}
 	return 0;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/kernel/tgt.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -57,6 +57,8 @@
 		   void (*done)(void *, struct tgt_session *), void *arg);
 extern int tgt_session_destroy(struct tgt_session *session);
 
+extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
+			unsigned int gfp_flags);
 extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
 					uint8_t *proto_data,
 					uint8_t *id_buff, int buff_size);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/kernel/tgt_scsi.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -113,9 +113,31 @@
 	cmnd->dev_id = scsi_tgt_translate_lun(id_buff, buff_size);
 }
 
-static int sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
-			    uint8_t ascode, uint8_t ascodeq)
+/*
+ * TODO: better error handling
+ * We should get ASC and ASCQ from the device code.
+ */
+static uint8_t error_to_sense_key(int err)
 {
+	uint8_t key;
+
+	switch (err) {
+	case -ENOMEM:
+		key = ABORTED_COMMAND;
+		break;
+	case -EOVERFLOW:
+		key = HARDWARE_ERROR;
+		break;
+	default:
+		key = HARDWARE_ERROR;
+		break;
+	}
+
+	return key;
+}
+
+static int sense_data_build(struct tgt_cmnd *cmnd, int err)
+{
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
 	int len = 8, alen = 6;
 	uint8_t *data = scsi_tgt_cmnd->sense_buff;
@@ -123,23 +145,26 @@
 	memset(data, 0, sizeof(scsi_tgt_cmnd->sense_buff));
 
 	if (cmnd->rw == READ || cmnd->rw == WRITE) {
+		uint8_t key = error_to_sense_key(err);
 		/* kspace command failure */
 
 		data[0] = 0x70 | 1U << 7;
 		data[2] = key;
 		data[7] = alen;
-		data[12] = ascode;
-		data[13] = ascodeq;
+		/*
+		 * TODO
+		 */
+		data[12] = 0;
+		data[13] = 0;
+		cmnd->result = SAM_STAT_CHECK_CONDITION;
 	} else {
-		char *addr;
 		/* uspace command failure */
 
 		len = min(cmnd->bufflen, sizeof(scsi_tgt_cmnd->sense_buff));
 		alen = 0;
 
-		addr = kmap_atomic(cmnd->sg[0].page, KM_SOFTIRQ0);
-		memcpy(data, addr, len);
-		kunmap_atomic(addr, KM_SOFTIRQ0);
+		memcpy(data, page_address(cmnd->sg[0].page), len);
+		cmnd->result = err;
 	}
 
 	cmnd->error_buff = data;
@@ -148,38 +173,11 @@
 	return len + alen;
 }
 
-/*
- * TODO: better error handling
- * We should get ASC and ASCQ from the device code.
- */
-static uint8_t error_to_sense_key(int err)
-{
-	uint8_t key;
-
-	switch (err) {
-	case -ENOMEM:
-		key = ABORTED_COMMAND;
-		break;
-	case -EOVERFLOW:
-		key = HARDWARE_ERROR;
-		break;
-	default:
-		key = HARDWARE_ERROR;
-		break;
-	}
-
-	return key;
-}
-
 static void scsi_tgt_cmnd_done(struct tgt_cmnd *cmnd, int err)
 {
-	if (err < 0) {
-		uint8_t key;
-
-		key = error_to_sense_key(err);
-		sense_data_build(cmnd, key, 0, 0);
-		cmnd->result = SAM_STAT_CHECK_CONDITION;
-	} else
+	if (err != 0)
+		sense_data_build(cmnd, err);
+	else
 		cmnd->result = SAM_STAT_GOOD;
 }
 

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/kernel/tgt_target.h	2005-09-22 17:59:36 UTC (rev 85)
@@ -21,7 +21,7 @@
 
 	int (* target_create) (struct tgt_target *);
 	void (* target_destroy) (struct tgt_target *);
-
+	int (* msg_recv) (struct tgt_target *, uint32_t, void *);
 	/*
 	 * name of protocol to use
 	 */

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/usr/netlink.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -30,36 +30,26 @@
 static struct sockaddr_nl src_addr, dest_addr;
 static char *recvbuf, *sendbuf;
 
-static int nl_write(int fd, int type, struct iovec *iovp, int count)
+static int nl_write(int fd, int type, char *data, int len)
 {
-	int i, datalen;
-	struct iovec iov[8];
+	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
+	struct iovec iov;
 	struct msghdr msg;
-	struct nlmsghdr nlh;
 
-	for (datalen = 0, i = 0; i < count; i++)
-		datalen += iovp[i].iov_len;
+	memset(nlh, 0, sizeof(*nlh));
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = getpid();
 
-	memset(&nlh, 0, sizeof(nlh));
-	nlh.nlmsg_len = NLMSG_SPACE(datalen);
-	nlh.nlmsg_type = type;
-	nlh.nlmsg_flags = 0;
-	nlh.nlmsg_pid = getpid();
+	iov.iov_base = data;
+	iov.iov_len = len;
 
-	iov[0].iov_base = &nlh;
-	iov[0].iov_len = sizeof(nlh);
-
-	for (i = 1; i <= count; i++) {
-		iov[i].iov_base = iovp->iov_base;
-		iov[i].iov_len = iovp->iov_len;
-		iovp++;
-	}
-
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_name= (void*) &dest_addr;
 	msg.msg_namelen = sizeof(dest_addr);
 	msg.msg_iov = (void *) &iov;
-	msg.msg_iovlen = count + 1;
+	msg.msg_iovlen = 1;
 
 	return sendmsg(fd, &msg, 0);
 }
@@ -87,14 +77,10 @@
 int nl_cmnd_call(int fd, int type, char *data, int size, int *res)
 {
 	int err;
-	struct iovec iov;
 	struct tgt_event *ev;
 	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
 
-	iov.iov_base = data;
-	iov.iov_len = size;
-
-	err = nl_write(fd, type, &iov, 1);
+	err = nl_write(fd, type, data, size);
 	if (err < 0)
 		return err;
 
@@ -108,34 +94,34 @@
 
 static int cmnd_queue(int fd, char *reqbuf, char *resbuf)
 {
-	int result, len;
-	struct iovec iov[2];
-	struct tgt_event *ev = (struct tgt_event *) reqbuf;
-	uint64_t cid = ev->k.cmnd_req.cid;
+	int result, len = 0;
+	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
+	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+	uint64_t cid = ev_req->k.cmnd_req.cid;
 	uint8_t *scb;
 
 	memset(resbuf, 0, NL_BUFSIZE);
-	scb = reqbuf + sizeof(*ev);
+	scb = (uint8_t *) ev_req->data;
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
 	/*
 	 * TODO match tid to protocol and route cmnd to correct userspace
 	 * protocol module
 	 */
-	result = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.dev_id,
-				scb, resbuf, &len);
+	result = scsi_cmnd_process(ev_req->k.cmnd_req.tid,
+				   ev_req->k.cmnd_req.dev_id, scb,
+				   (uint8_t *) ev_res->data, &len);
 
-	memset(ev, 0, sizeof(*ev));
-	ev->u.cmnd_res.cid = cid;
-	ev->u.cmnd_res.len = len;
-	ev->u.cmnd_res.result = result;
+	memset(ev_res, 0, sizeof(*ev_res));
+	ev_res->u.cmnd_res.cid = cid;
+	ev_res->u.cmnd_res.len = len;
+	ev_res->u.cmnd_res.result = result;
 
-	iov[0].iov_base = ev;
-	iov[0].iov_len = sizeof(*ev);
-	iov[1].iov_base = resbuf;
-	iov[1].iov_len = len;
 
-	return nl_write(fd, TGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
+	log_error("scsi_cmnd_process res %d len %d\n", result, len);
+
+	return nl_write(fd, TGT_UEVENT_CMND_RES, resbuf,
+			NLMSG_SPACE(sizeof(*ev_res) + len));
 }
 
 void nl_event_handle(int fd)
@@ -158,7 +144,7 @@
 	nlh = (struct nlmsghdr *) recvbuf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	dprintf("%d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
+	dprintf("nl_event_handle %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
 
 read_again:
 	err = nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
@@ -186,9 +172,10 @@
 static void nl_start(int fd)
 {
 	int err, res;
-	struct tgt_event ev;
+	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
-	err = nl_cmnd_call(fd, TGT_UEVENT_START, (char *) &ev, sizeof(ev), &res);
+	err = nl_cmnd_call(fd, TGT_UEVENT_START, nlmsg, 
+			   NLMSG_SPACE(sizeof(struct tgt_event)), &res);
 	if (err < 0 || res < 0) {
 		eprintf("%d %d\n", err, res);
 		exit(-1);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-20 04:23:45 UTC (rev 84)
+++ trunk/usr/scsi.c	2005-09-22 17:59:36 UTC (rev 85)
@@ -401,11 +401,13 @@
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/path", tid, lun);
+	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/fd",
+		tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {
-		perror("scsi sync_cache could not get LU's path");
+		log_error("scsi sync_cache could not get LU's fd err %d",
+			  errno);
 		err = EINVAL;
 		goto einval;
 	}
@@ -413,24 +415,32 @@
 	err = read(fd, buf, sizeof(buf));
 	close(fd);
 	if (err < 0) {
-		perror("scsi sync_cache could not read LUN path");
+		log_error("scsi sync_cache could not read LUN path err %d",
+			  errno);
 		err = EIO;
 		goto eio;
 	}
 	/*
 	 * yuck! wtf should I be using
 	 */
-	memset(path, 0, PATH_MAX);
-	sscanf(buf, "%s\n", path);
+	fd = 0;
+	sscanf(buf, "%d\n", &fd);
 
-	fd = open(path, O_RDWR);
-	if (fd < 0) {
-		perror("scsi sync_cache could not open device");
-		err = EIO;
-		goto eio;
+	/*
+	 * this will work when we merge the daemons (fd's are associated
+	 * with procssess so this will fail when ietd opens the fd and
+	 * this thread syncs it).
+	 */
+	err = fsync(fd);
+	if (err) {
+		log_error("scsi sync_cache fsync of fd %d failed err %d",
+			   fd, errno);
+		/*
+		 * this is what we should do but for now we lie.
+		 * err = errno;
+		 */
+		err = 0;
 	}
-	err = fsync(fd);
-	close(fd);
 
 	switch (err) {
 	case EROFS:



From mnc at berlios.de  Thu Sep 22 21:48:30 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Thu, 22 Sep 2005 21:48:30 +0200
Subject: [Stgt-svn] r86 - trunk/kernel
Message-ID: <200509221948.j8MJmUG7003587@sheep.berlios.de>

Author: mnc
Date: 2005-09-22 21:48:27 +0200 (Thu, 22 Sep 2005)
New Revision: 86

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
prep for module/struct reorg by moving command allocation to protocol so that it can account for its priv size in the kmemcache

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-22 17:59:36 UTC (rev 85)
+++ trunk/kernel/tgt.c	2005-09-22 19:48:27 UTC (rev 86)
@@ -54,8 +54,6 @@
 static int tgt_pid, daemon_pid;
 static struct sock *nls;
 
-static kmem_cache_t *cmnd_slab;
-
 /* TODO: lock per session */
 static spinlock_t cmnd_hash_lock;
 #define TGT_HASH_ORDER		8
@@ -245,10 +243,11 @@
 static int session_init(struct tgt_session *session, int max_cmnds)
 {
 	struct tgt_target *target = session->target;
+	struct tgt_protocol *proto = session->target->proto;
 	unsigned long flags;
 
 	session->cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, cmnd_slab);
+					mempool_free_slab, proto->cmnd_cache);
 	if (!session->cmnd_pool)
 		goto out;
 
@@ -532,29 +531,15 @@
 {
 	struct tgt_protocol *proto = session->target->proto;
 	struct tgt_cmnd *cmnd;
-	void *pcmnd_data;
 	unsigned long flags;
 
-	/*
-	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
-	 * However, how can we guarantee the specified number of commands ?
-	 */
-	pcmnd_data = kmalloc(proto->priv_cmd_data_size, GFP_ATOMIC);
-	if (!pcmnd_data) {
-		eprintk("Could not allocate command private data for %p",
-			 session);
-		return NULL;
-	}
-
 	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
 	if (!cmnd) {
 		eprintk("Could not allocate tgt_cmnd for %p\n", session);
-		kfree(pcmnd_data);
 		return NULL;
 	}
 
 	memset(cmnd, 0, sizeof(*cmnd));
-	cmnd->tgt_protocol_private = pcmnd_data;
 	cmnd->session = session;
 	cmnd->cid = (uint64_t) (unsigned long) cmnd;
 	INIT_LIST_HEAD(&cmnd->clist);
@@ -579,8 +564,6 @@
 
 	dprintk("cid %llu\n", cmnd->cid);
 
-	kfree(cmnd->tgt_protocol_private);
-
 	for (i = 0; i < cmnd->sg_count; i++)
 		__free_page(cmnd->sg[i].page);
 	kfree(cmnd->sg);
@@ -963,9 +946,6 @@
 
 static void __exit tgt_exit(void)
 {
-	if (cmnd_slab)
-		kmem_cache_destroy(cmnd_slab);
-
 	if (nls)
 		sock_release(nls->sk_socket);
 
@@ -987,12 +967,6 @@
 	if (err)
 		return err;
 
-	cmnd_slab = kmem_cache_create("tgt_cmnd", sizeof(struct tgt_cmnd), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!cmnd_slab)
-		goto out;
-
 	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
 	if (!nls)
 		goto out;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-22 17:59:36 UTC (rev 85)
+++ trunk/kernel/tgt.h	2005-09-22 19:48:27 UTC (rev 86)
@@ -48,7 +48,10 @@
 	 */
 	void *private;
 
-	void *tgt_protocol_private;
+	/*
+	 * is the alignment still needed?  See scsi_host.h
+	 */
+	unsigned long proto_priv[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
 extern struct tgt_session *

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-22 17:59:36 UTC (rev 85)
+++ trunk/kernel/tgt_protocol.h	2005-09-22 19:48:27 UTC (rev 86)
@@ -8,6 +8,8 @@
 #ifndef __TGT_PROTOCOL_H
 #define __TGT_PROTOCOL_H
 
+#include <linux/slab.h>
+
 struct module;
 struct tgt_cmnd;
 
@@ -15,7 +17,7 @@
 	const char *name;
 	struct module *module;
 
-	int priv_cmd_data_size;
+	kmem_cache_t *cmnd_cache;
 	int uspace_pdu_size;
 
 	/*

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-22 17:59:36 UTC (rev 85)
+++ trunk/kernel/tgt_scsi.c	2005-09-22 19:48:27 UTC (rev 86)
@@ -15,6 +15,8 @@
 #include <tgt.h>
 #include <tgt_protocol.h>
 
+static kmem_cache_t *scsi_tgt_cmnd_cache;
+
 struct scsi_tgt_cmnd {
 	uint8_t scb[MAX_COMMAND_SIZE];
 	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
@@ -46,8 +48,8 @@
 
 static void scsi_tgt_init_cmnd_buffer(struct tgt_cmnd *cmnd)
 {
-	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
-	uint8_t *scb = scsi_tgt_cmnd->scb;
+	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
+	uint8_t *scb = scmnd->scb;
 	uint64_t off = 0;
 	uint32_t len = 0;
 
@@ -87,10 +89,10 @@
 static void scsi_tgt_init_cmnd(struct tgt_cmnd *cmnd, uint8_t *proto_data,
 			       uint8_t *id_buff, int buff_size)
 {
-	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
-	uint8_t *scb = scsi_tgt_cmnd->scb;
+	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
+	uint8_t *scb = scmnd->scb;
 
-	memcpy(scb, proto_data, sizeof(scsi_tgt_cmnd->scb));
+	memcpy(scb, proto_data, sizeof(scmnd->scb));
 
 	/* set operation */
 	switch (scb[0]) {
@@ -138,11 +140,11 @@
 
 static int sense_data_build(struct tgt_cmnd *cmnd, int err)
 {
-	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
+	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
 	int len = 8, alen = 6;
-	uint8_t *data = scsi_tgt_cmnd->sense_buff;
+	uint8_t *data = scmnd->sense_buff;
 
-	memset(data, 0, sizeof(scsi_tgt_cmnd->sense_buff));
+	memset(data, 0, sizeof(scmnd->sense_buff));
 
 	if (cmnd->rw == READ || cmnd->rw == WRITE) {
 		uint8_t key = error_to_sense_key(err);
@@ -160,7 +162,7 @@
 	} else {
 		/* uspace command failure */
 
-		len = min(cmnd->bufflen, sizeof(scsi_tgt_cmnd->sense_buff));
+		len = min(cmnd->bufflen, sizeof(scmnd->sense_buff));
 		alen = 0;
 
 		memcpy(data, page_address(cmnd->sg[0].page), len);
@@ -183,9 +185,8 @@
 
 void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
 {
-	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd->tgt_protocol_private;
-
-	memcpy(data, scsi_tgt_cmnd->scb, sizeof(scsi_tgt_cmnd->scb));
+	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
+	memcpy(data, scmnd->scb, sizeof(scmnd->scb));
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
@@ -195,17 +196,30 @@
 	.init_cmnd_buffer = scsi_tgt_init_cmnd_buffer,
 	.cmnd_done = scsi_tgt_cmnd_done,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
-	.priv_cmd_data_size = sizeof(struct scsi_tgt_cmnd),
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 
 static int __init scsi_tgt_init(void)
 {
-	return tgt_protocol_register(&scsi_tgt_proto);
+	int err;
+
+	scsi_tgt_cmnd_cache = kmem_cache_create("scsi_tgt_cmnd",
+			sizeof(struct tgt_cmnd) + sizeof(struct scsi_tgt_cmnd),
+			0, SLAB_HWCACHE_ALIGN | SLAB_NO_REAP, NULL, NULL);
+	if (!scsi_tgt_cmnd_cache)
+		return -ENOMEM;
+	scsi_tgt_proto.cmnd_cache = scsi_tgt_cmnd_cache;
+
+	err = tgt_protocol_register(&scsi_tgt_proto);
+	if (err)
+		kmem_cache_destroy(scsi_tgt_cmnd_cache);
+
+	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
+	kmem_cache_destroy(scsi_tgt_cmnd_cache);
 	tgt_protocol_unregister(&scsi_tgt_proto);
 }
 



From mnc at berlios.de  Fri Sep 23 02:33:43 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Fri, 23 Sep 2005 02:33:43 +0200
Subject: [Stgt-svn] r87 - in trunk: . iscsi/kernel kernel
Message-ID: <200509230033.j8N0XhGI019506@sheep.berlios.de>

Author: mnc
Date: 2005-09-23 02:33:42 +0200 (Fri, 23 Sep 2005)
New Revision: 87

Added:
   trunk/kernel/tgt_vsd.c
Removed:
   trunk/kernel/tgt_vdev.c
Modified:
   trunk/initd
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
Do tgt_type/lld -> transport/sub-protocol (iscsi, fc, etc (not done yet) ->  protocol (scsi/ide) -> device (this is protocol specific device like SCSI Tape, or SCSI Disk) -> tgt_core (sometimes we can bypass a layer like for sending/recieving target driver messages since those are not device or protocol specific). Move some scsi disk things to tgt_vsd (NOTE CHANGE YOUR IETD.CONF TO REFLECT NAME CHANGE), and moved some things around to fix sense bug and allow devices to be able to better control sense/error-values 

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/initd	2005-09-23 00:33:42 UTC (rev 87)
@@ -10,7 +10,7 @@
 {
 	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/tgt_vdev.ko
+	insmod ${PWD}/kernel/tgt_vsd.ko
 	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
@@ -26,7 +26,7 @@
 
 	rmmod iscsi_trgt
 
-	rmmod tgt_vdev
+	rmmod tgt_vsd
 	rmmod tgt_scsi
 	rmmod tgt_core
 }

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-23 00:33:42 UTC (rev 87)
@@ -12,6 +12,8 @@
 
 #include <tgt.h>
 #include <tgt_target.h>
+#include <tgt_scsi.h>
+#include <tgt_protocol.h>
 
 #include <iscsi.h>
 #include <iscsi_dbg.h>
@@ -261,6 +263,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
+	struct scsi_tgt_cmnd *stc;
 	struct scatterlist *sg = &req->sense_sg;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
@@ -272,13 +275,17 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	sense = (struct iscsi_sense_data *) req->tc->error_buff;
-	memmove(sense->data, sense, req->tc->error_buff_len);
-	sense->length = cpu_to_be16(req->tc->error_buff_len);
+	stc = tgt_cmnd_to_scsi(req->tc);
+	sense = (struct iscsi_sense_data *) stc->sense_buff;
+	memmove(sense->data, sense, stc->sense_len);
+	/*
+	 * this looks broken for ppc
+	 */
+	sense->length = cpu_to_be16(stc->sense_len);
 
-	sg->page = virt_to_page(req->tc->error_buff);
-	sg->offset = offset_in_page(req->tc->error_buff);
-	sg->length = req->tc->error_buff_len + sizeof(struct iscsi_sense_data);
+	sg->page = virt_to_page(stc->sense_buff);
+	sg->offset = offset_in_page(stc->sense_buff);
+	sg->length = stc->sense_len + sizeof(struct iscsi_sense_data);
 	rsp->pdu.datasize = sg->length;
 	rsp->sg = sg;
 
@@ -288,6 +295,7 @@
 static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
 					   u8 sense_key, u8 asc, u8 ascq)
 {
+	struct scsi_tgt_cmnd *stc;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
@@ -302,11 +310,12 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	sg->page = virt_to_page(req->tc->error_buff);
-	sg->offset = offset_in_page(req->tc->error_buff);
-	sg->length = req->tc->error_buff_len;
+	stc = tgt_cmnd_to_scsi(req->tc);
+	sg->page = virt_to_page(stc->sense_buff);
+	sg->offset = offset_in_page(stc->sense_buff);
+	sg->length = stc->sense_len;
 
-	sense = (struct iscsi_sense_data *) req->tc->error_buff;
+	sense = (struct iscsi_sense_data *) stc->sense_buff;
 	sense->length = cpu_to_be16(14);
 	sense->data[0] = 0xf0;
 	sense->data[2] = sense_key;
@@ -746,9 +755,12 @@
 		if (!cmnd->is_unsolicited_data)
 			send_r2t(cmnd);
 	} else {
+		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
+ 
 		set_cmnd_waitio(cmnd);
 		cmnd->tc->private = cmnd;
-		tgt_cmnd_queue(cmnd->tc, scsi_cmnd_done);
+
+		proto->queue_cmnd(cmnd->tc, scsi_cmnd_done);
 	}
 }
 
@@ -829,15 +841,15 @@
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
+	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
 
 	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
 
 	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
-	req->tc = tgt_cmnd_create(conn->session->ts, req_hdr->cdb,
-				   req_hdr->lun,
-				   sizeof(req_hdr->lun));
+	req->tc = proto->create_cmnd(conn->session->ts, req_hdr->cdb,
+				     req_hdr->lun, sizeof(req_hdr->lun));
 	assert(req->tc);
 
 	switch (req_hdr->cdb[0]) {
@@ -881,8 +893,7 @@
 			cmnd_skip_data(req);
 		}
 
-		tgt_cmnd_alloc_buffer(req->tc, NULL);
-
+		proto->alloc_cmnd_buffer(req->tc, NULL);
 		break;
 	}
 	case WRITE_6:
@@ -907,7 +918,7 @@
 		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
 			eprintk("Verification is ignored %x\n", cmnd_itt(req));
 
-		tgt_cmnd_alloc_buffer(req->tc, NULL);
+		proto->alloc_cmnd_buffer(req->tc, NULL);
 
 		if (req->pdu.datasize) {
 			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/Makefile	2005-09-23 00:33:42 UTC (rev 87)
@@ -8,7 +8,7 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vdev.o tgt_scsi.o
+obj-m		+= tgt_vsd.o tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt.c	2005-09-23 00:33:42 UTC (rev 87)
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/mempool.h>
 #include <linux/netlink.h>
+#include <linux/file.h>
 #include <asm/scatterlist.h>
 #include <net/tcp.h>
 
@@ -427,8 +428,7 @@
 	return NULL;
 }
 
-static struct tgt_device *
-tgt_device_find(struct tgt_target *target, uint64_t dev_id)
+struct tgt_device *tgt_device_find(struct tgt_target *target, uint64_t dev_id)
 {
 	static struct tgt_device *device;
 	unsigned long flags;
@@ -439,6 +439,7 @@
 
 	return device;
 }
+EXPORT_SYMBOL_GPL(tgt_device_find);
 
 static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags)
@@ -463,14 +464,19 @@
 	device->target = target;
 	device->fd = fd;
 
+	device->file = fget(fd);
+	if (!device->file) {
+		eprintk("Could not get fd %d\n", fd);
+		goto free_device;
+	}
+
 	device->dt = device_template_get(device_type);
 	if (!device->dt) {
 		eprintk("Could not get devive type %s\n", device_type);
-		goto free_device;
+		goto put_fd;
 	}
 
-	device->dt_data = kmalloc(device->dt->priv_data_size,
-				  GFP_KERNEL);
+	device->dt_data = kmalloc(device->dt->priv_data_size, GFP_KERNEL);
 	if (!device->dt_data)
 		goto put_template;
 
@@ -494,6 +500,8 @@
 	kfree(device->dt_data);
 put_template:
 	device_template_put(device->dt);
+put_fd:
+	fput(device->file);
 free_device:
 	kfree(device);
 	return -EINVAL;
@@ -519,17 +527,15 @@
 	if (device->dt->destroy)
 		device->dt->destroy(device);
 
+	fput(device->file);
 	device_template_put(device->dt);
 	tgt_sysfs_unregister_device(device);
 
 	return 0;
 }
 
-struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
-				 uint8_t *proto_data,
-				 uint8_t *id_buff, int buff_size)
+struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session)
 {
-	struct tgt_protocol *proto = session->target->proto;
 	struct tgt_cmnd *cmnd;
 	unsigned long flags;
 
@@ -547,8 +553,6 @@
 
 	dprintk("%p %llu\n", session, cmnd->cid);
 
-	proto->init_cmnd(cmnd, proto_data, id_buff, buff_size);
-
 	spin_lock_irqsave(&cmnd_hash_lock, flags);
 	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);
 	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
@@ -620,12 +624,8 @@
 
 void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
 {
-	struct tgt_protocol *proto = cmnd->session->target->proto;
-
 	BUG_ON(!list_empty(&cmnd->clist));
 
-	proto->init_cmnd_buffer(cmnd);
-
 	if (done) {
 		struct tgt_session *session = cmnd->session;
 
@@ -639,7 +639,7 @@
 }
 EXPORT_SYMBOL_GPL(tgt_cmnd_alloc_buffer);
 
-static int uspace_cmnd_send(struct tgt_cmnd *cmnd)
+int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd)
 {
 	struct tgt_protocol *proto = cmnd->session->target->proto;
 	struct sk_buff *skb;
@@ -668,16 +668,12 @@
 
 	return netlink_unicast(nls, skb, tgt_pid, 0);
 }
+EXPORT_SYMBOL_GPL(tgt_uspace_cmnd_send);
 
-static void cmnd_done(struct tgt_cmnd *cmnd, int result)
+static void cmnd_done(struct tgt_cmnd *cmnd)
 {
-	struct tgt_target *target = cmnd->session->target;
-	struct tgt_protocol *proto = target->proto;
 	void (*done)(struct tgt_cmnd *);
 
-	proto->cmnd_done(cmnd, result);
-	cmnd->result = result;
-
 	done = cmnd->done;
 	cmnd->done = NULL;
 	done(cmnd);
@@ -686,6 +682,7 @@
 static void uspace_cmnd_done(struct tgt_cmnd *cmnd, void *data,
 			     int result, uint32_t len)
 {
+	struct tgt_device *device = cmnd->device;
 	char *p = data;
 	int i;
 	BUG_ON(!cmnd->done);
@@ -707,7 +704,10 @@
 		}
 	}
 
-	cmnd_done(cmnd, result);
+	cmnd->result = result;
+	if (device->dt->complete_uspace_cmnd)
+		device->dt->complete_uspace_cmnd(cmnd);
+	cmnd_done(cmnd);
 }
 
 static void queuecommand(void *data)
@@ -715,34 +715,28 @@
 	int err = 0;
 	struct tgt_cmnd *cmnd = data;
 	struct tgt_target *target = cmnd->session->target;
-	struct tgt_device *device;
+	struct tgt_device *device = cmnd->device;
 
-	dprintk("cid %llu rw %d\n", cmnd->cid, cmnd->rw);
+	dprintk("cid %llu\n", cmnd->cid);
 
 	/* Should we do this earlier? */
-	device = tgt_device_find(target, cmnd->dev_id);
+	if (!device)
+		cmnd->device = device = tgt_device_find(target, cmnd->dev_id);
 	if (device)
 		dprintk("found %llu\n", cmnd->dev_id);
 
-	if (cmnd->rw == READ || cmnd->rw == WRITE)
-		err = device->dt->queue_cmnd(device, cmnd);
-	else {
-		/*
-		 * TODO: if we fail to get the command to userspace there
-		 * will be no setup sense buffer below so we need to add
-		 * something.
-		 */
-		err = uspace_cmnd_send(cmnd);
-		if (err >= 0)
-			/* sent to userspace */
-			return;
-	}
+	err = device->dt->queue_cmnd(cmnd);
 
-	/* kspace command failure or failed to send commands to space. */
-	if (unlikely(err))
-		eprintk("failed cmnd %llu %d %d\n", cmnd->cid, err, cmnd->rw);
-
-	cmnd_done(cmnd, err);
+	switch (err) {
+	case TGT_CMND_FAILED:
+	case TGT_CMND_COMPLETED:
+		dprintk("command completed %d\n", err);
+		if (device->dt->complete_kern_cmnd)
+			device->dt->complete_kern_cmnd(cmnd);
+		cmnd_done(cmnd);
+	default:
+		dprintk("command %llu queued\n", cmnd->cid);
+	};
 }
 
 int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt.h	2005-09-23 00:33:42 UTC (rev 87)
@@ -11,6 +11,9 @@
 
 #include <linux/mempool.h>
 
+struct tgt_device;
+struct tgt_protocol;
+
 struct tgt_session {
 	struct tgt_target *target;
 	struct list_head slist;
@@ -20,13 +23,13 @@
 
 struct tgt_cmnd {
 	struct tgt_session *session;
+	struct tgt_device *device;
+	struct tgt_protocol *proto;
 
 	uint32_t state;
 	uint64_t dev_id;
 	uint64_t cid;
 
-	int rw;
-
 	struct work_struct work;
 	void (*done) (struct tgt_cmnd *);
 
@@ -39,10 +42,6 @@
 	uint64_t offset;
 	int result;
 
-	/* TODO: there should be a better way. */
-	uint8_t *error_buff;
-	int error_buff_len;
-
 	/*
 	 * target driver private
 	 */
@@ -62,9 +61,8 @@
 
 extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
 			unsigned int gfp_flags);
-extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
-					uint8_t *proto_data,
-					uint8_t *id_buff, int buff_size);
+extern int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd);
+extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session);
 extern void tgt_cmnd_destroy(struct tgt_cmnd *cmnd);
 extern void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd,
 				  void (*done)(struct tgt_cmnd *));

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt_device.h	2005-09-23 00:33:42 UTC (rev 87)
@@ -14,14 +14,47 @@
 struct tgt_device;
 struct tgt_cmnd;
 
+enum {
+	TGT_CMND_COMPLETED,
+	TGT_CMND_FAILED,
+	/*
+	 * if the device has queued the command it is responsible for
+	 * for completing it
+	 */
+	TGT_CMND_USPACE_QUEUED,
+	TGT_CMND_KERN_QUEUED
+};
+
 struct tgt_device_template {
 	const char *name;
 	struct module *module;
 	unsigned priv_data_size;
 
+	/*
+	 * setup and destroy private structures
+	 */
 	int (* create)(struct tgt_device *);
 	void (* destroy)(struct tgt_device *);
-	int (* queue_cmnd)(struct tgt_device *device, struct tgt_cmnd *cmnd);
+	/*
+	 * queue or execute command. Return TGT_CMND*.
+	 * If returning TGT_CMND_COMPLETED or TGT_CMND_FAILED the result
+	 * field must be set.
+	 */
+	int (* queue_cmnd)(struct tgt_cmnd *cmnd);
+	/*
+	 * complete a userspace command
+	 */
+	void ( *complete_uspace_cmnd)(struct tgt_cmnd *cmnd);
+	/*
+	 * complete a kernel command if your queue_command was async
+	 * and the device used one of the tgt threads to process the
+	 * command
+	 */
+	void (*complete_kern_cmnd)(struct tgt_cmnd *cmnd);
+	/*
+	 * setup buffer or device fields if needed
+	 */
+	void (* prep_cmnd)(struct tgt_cmnd *cmnd);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
@@ -36,6 +69,7 @@
 	struct class_device cdev;
 
 	int fd;
+	struct file *file;
 	uint64_t dev_id;
 	uint32_t blk_shift;
 	uint64_t size;
@@ -47,6 +81,8 @@
 #define cdev_to_tgt_device(cdev) \
         container_of(cdev, struct tgt_device, cdev)
 
+extern struct tgt_device *tgt_device_find(struct tgt_target *target,
+					  uint64_t dev_id);
 extern int tgt_sysfs_register_device(struct tgt_device *device);
 extern void tgt_sysfs_unregister_device(struct tgt_device *device);
 extern int tgt_device_template_register(struct tgt_device_template *dt);

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt_protocol.h	2005-09-23 00:33:42 UTC (rev 87)
@@ -12,7 +12,13 @@
 
 struct module;
 struct tgt_cmnd;
+struct tgt_session;
 
+/*
+ * The target driver will interact with tgt core through the protocol
+ * handler. The protocol handler can then use the default tgt_core functions
+ * or build wrappers around them.
+ */
 struct tgt_protocol {
 	const char *name;
 	struct module *module;
@@ -21,20 +27,31 @@
 	int uspace_pdu_size;
 
 	/*
-	 * perform command preparation, such as setting the rw field
-	 * and dev_id
+	 * create a command.
 	 */
-	void (* init_cmnd)(struct tgt_cmnd *cmnd, uint8_t *proto_data,
-			   uint8_t *id_buff, int buff_size);
+	struct tgt_cmnd *(* create_cmnd)(struct tgt_session *session,
+					uint8_t *cmd, uint8_t *dev_id_buff,
+					int buff_size);
 	/*
-	 * setup buffer fields like offset and len
+	 * destroy a command. This will free the command and buffer
 	 */
-	void (* init_cmnd_buffer)(struct tgt_cmnd *cmd);
+	void (* destroy_cmnd)(struct tgt_cmnd *cmd); 
 	/*
-	 * process completion of a command
+	 * allocoate a comand buffer. If this is called from irq context
+	 * a done callback can be set so the allocation is done in process
+	 * context.
 	 */
-	void (* cmnd_done)(struct tgt_cmnd *cmd, int err);
-
+	void (* alloc_cmnd_buffer)(struct tgt_cmnd *cmnd,
+				   void (*done)(struct tgt_cmnd *));
+	/*
+	 * queue a command to be executed in a workqueue. A done() callback
+	 * must be passed in.
+	 */
+	int (* queue_cmnd)(struct tgt_cmnd *cmnd,
+			   void (*done)(struct tgt_cmnd *));
+	/*
+	 * build userspace packet
+	 */
 	void (* build_uspace_pdu)(struct tgt_cmnd *cmnd, void *data);
 };
 

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt_scsi.c	2005-09-23 00:33:42 UTC (rev 87)
@@ -13,16 +13,12 @@
 #include <scsi/scsi_cmnd.h>
 
 #include <tgt.h>
+#include <tgt_scsi.h>
+#include <tgt_device.h>
 #include <tgt_protocol.h>
 
 static kmem_cache_t *scsi_tgt_cmnd_cache;
 
-struct scsi_tgt_cmnd {
-	uint8_t scb[MAX_COMMAND_SIZE];
-	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
-	int tags;
-};
-
 /*
  * we should be able to use scsi-ml's functions for this
  */
@@ -46,143 +42,81 @@
 	return lun;
 }
 
-static void scsi_tgt_init_cmnd_buffer(struct tgt_cmnd *cmnd)
+/*
+ * we may have to add a wrapper becuase people are passing the lun in
+ * differently
+ */
+static struct tgt_cmnd *
+scsi_tgt_create_cmnd(struct tgt_session *session, uint8_t *scb, uint8_t *lun,
+		     int lun_size)
 {
-	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
-	uint8_t *scb = scmnd->scb;
-	uint64_t off = 0;
-	uint32_t len = 0;
+	struct tgt_device *device;
+	struct tgt_cmnd *cmnd;
+	struct scsi_tgt_cmnd *scmnd;
 
-	/*
-	 * set bufflen and offset
-	 */
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		len = scb[4];
-		if (!len)
-			len = 256;
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(u32 *) &scb[2]);
-		len = (scb[7] << 8) + scb[8];
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(u64 *)&scb[2]);
-		len = be32_to_cpu(*(u32 *)&scb[10]);
-		break;
-	default:
-		break;
+	cmnd = tgt_cmnd_create(session);
+	if (!cmnd) {
+		printk(KERN_ERR "Could not allocate command\n");
+		return NULL;
 	}
+	scmnd = tgt_cmnd_to_scsi(cmnd);
+	memcpy(scmnd->scb, scb, sizeof(scmnd->scb));
 
-	off <<= 9;
-	len <<= 9;
-
-	cmnd->bufflen = len;
-	cmnd->offset = off;
-}
-
-static void scsi_tgt_init_cmnd(struct tgt_cmnd *cmnd, uint8_t *proto_data,
-			       uint8_t *id_buff, int buff_size)
-{
-	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
-	uint8_t *scb = scmnd->scb;
-
-	memcpy(scb, proto_data, sizeof(scmnd->scb));
-
-	/* set operation */
-	switch (scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		cmnd->rw = READ;
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		cmnd->rw = WRITE;
-		break;
-	default:
-		cmnd->rw = SPECIAL;
-	};
-
 	/* translate target driver LUN to device id */
-	cmnd->dev_id = scsi_tgt_translate_lun(id_buff, buff_size);
-}
-
-/*
- * TODO: better error handling
- * We should get ASC and ASCQ from the device code.
- */
-static uint8_t error_to_sense_key(int err)
-{
-	uint8_t key;
-
-	switch (err) {
-	case -ENOMEM:
-		key = ABORTED_COMMAND;
-		break;
-	case -EOVERFLOW:
-		key = HARDWARE_ERROR;
-		break;
-	default:
-		key = HARDWARE_ERROR;
-		break;
+	cmnd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
+	device = tgt_device_find(session->target, cmnd->dev_id);
+	if (!device) {
+		printk(KERN_ERR "Could not find device if %llu\n",
+		       cmnd->dev_id);
+		return NULL;
 	}
+	cmnd->device = device;
 
-	return key;
+	/* do scsi device specific setup */
+	device->dt->prep_cmnd(cmnd);
+	return cmnd;
 }
 
-static int sense_data_build(struct tgt_cmnd *cmnd, int err)
+/* kspace command failure */
+int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+			      uint8_t ascode, uint8_t ascodeq)
 {
-	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
 	int len = 8, alen = 6;
 	uint8_t *data = scmnd->sense_buff;
 
 	memset(data, 0, sizeof(scmnd->sense_buff));
 
-	if (cmnd->rw == READ || cmnd->rw == WRITE) {
-		uint8_t key = error_to_sense_key(err);
-		/* kspace command failure */
+	data[0] = 0x70 | 1U << 7;
+	data[2] = key;
+	data[7] = alen;
+	data[12] = ascode;
+	data[13] = ascodeq;
+	cmnd->result = SAM_STAT_CHECK_CONDITION;
+	scmnd->sense_len = len + alen;
 
-		data[0] = 0x70 | 1U << 7;
-		data[2] = key;
-		data[7] = alen;
-		/*
-		 * TODO
-		 */
-		data[12] = 0;
-		data[13] = 0;
-		cmnd->result = SAM_STAT_CHECK_CONDITION;
-	} else {
-		/* uspace command failure */
+	return len + alen;
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_sense_data_build);
 
-		len = min(cmnd->bufflen, sizeof(scmnd->sense_buff));
-		alen = 0;
+/* uspace command failure */
+int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd)
+{
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	uint8_t *data = scmnd->sense_buff;
+	int len;
 
-		memcpy(data, page_address(cmnd->sg[0].page), len);
-		cmnd->result = err;
-	}
+	memset(data, 0, sizeof(scmnd->sense_buff));
+	len = min(cmnd->bufflen, sizeof(scmnd->sense_buff));
 
-	cmnd->error_buff = data;
-	cmnd->error_buff_len = len + alen;
+	/* userspace did everything for us */
+	memcpy(data, page_address(cmnd->sg[0].page), len);
+	scmnd->sense_len = len;
 
-	return len + alen;
+	return len;
 }
+EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-static void scsi_tgt_cmnd_done(struct tgt_cmnd *cmnd, int err)
-{
-	if (err != 0)
-		sense_data_build(cmnd, err);
-	else
-		cmnd->result = SAM_STAT_GOOD;
-}
-
 void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
 {
 	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
@@ -192,9 +126,10 @@
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
-	.init_cmnd = scsi_tgt_init_cmnd,
-	.init_cmnd_buffer = scsi_tgt_init_cmnd_buffer,
-	.cmnd_done = scsi_tgt_cmnd_done,
+	.create_cmnd = scsi_tgt_create_cmnd,
+	.destroy_cmnd = tgt_cmnd_destroy,
+	.alloc_cmnd_buffer = tgt_cmnd_alloc_buffer,
+	.queue_cmnd = tgt_cmnd_queue,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };

Deleted: trunk/kernel/tgt_vdev.c
===================================================================
--- trunk/kernel/tgt_vdev.c	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt_vdev.c	2005-09-23 00:33:42 UTC (rev 87)
@@ -1,147 +0,0 @@
-/*
- * Target virtual device functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <tgt.h>
-#include <tgt_device.h>
-
-struct tgt_vdev {
-	struct file *filp;
-};
-
-static void tgt_vdev_destroy(struct tgt_device *device)
-{
-	struct tgt_vdev *vdev = device->dt_data;
-	fput(vdev->filp);
-}
-
-static int open_file(struct tgt_vdev *vdev, int fd)
-{
-	struct file *filp;
-
-	filp = fget(fd);
-	if (!filp) {
-		printk("Could not get fd %d\n", fd);
-		return -EINVAL;
-	}
-
-	vdev->filp = filp;
-	return 0;
-}
-
-static int tgt_vdev_create(struct tgt_device *device)
-{
-	struct tgt_vdev *vdev = device->dt_data;
-	struct inode *inode;
-	int err;
-
-	err = open_file(vdev, device->fd);
-	if (err)
-		return err;
-
-	inode = vdev->filp->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else {
-		err = -EINVAL;
-		goto out;
-	}
-
-	device->size = inode->i_size;
-	printk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-out:
-	fput(vdev->filp);
-	return err;
-}
-
-/*
- * TODO: We need to redo our scatter lists so they take into account
- * this common usage, but also not violate HW limits
- */
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i < sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-static int tgt_vdev_queue(struct tgt_device *device, struct tgt_cmnd *cmnd)
-{
-	struct tgt_vdev *vdev = device->dt_data;
-	ssize_t size;
-	struct iovec *iov;
-	loff_t pos = cmnd->offset;
-	int err = 0;
-
-	if (cmnd->bufflen + pos > device->size)
-		return -EOVERFLOW;
-
-	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (cmnd->rw == READ)
-		size = generic_file_readv(vdev->filp, iov, cmnd->sg_count, &pos);
-	else
-		size = generic_file_writev(vdev->filp, iov, cmnd->sg_count, &pos);
-
-	kfree(iov);
-
-/* not yet used
-	if (sync)
-		err = sync_page_range(inode, inode->i_mapping, pos,
-				      (size_t) cmnd->bufflen);
-*/
-	if ((size != cmnd->bufflen) || err)
-		return -EIO;
-	else
-		return 0;
-}
-
-static struct tgt_device_template tgt_vdev = {
-	.name = "tgt_vdev",
-	.module = THIS_MODULE,
-	.create = tgt_vdev_create,
-	.destroy = tgt_vdev_destroy,
-	.queue_cmnd = tgt_vdev_queue,
-	.priv_data_size = sizeof(struct tgt_vdev),
-};
-
-static int __init tgt_vdev_init(void)
-{
-	return tgt_device_template_register(&tgt_vdev);
-}
-
-static void __exit tgt_vdev_exit(void)
-{
-	tgt_device_template_unregister(&tgt_vdev);
-}
-
-module_init(tgt_vdev_init);
-module_exit(tgt_vdev_exit);
-MODULE_LICENSE("GPL");

Added: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-22 19:48:27 UTC (rev 86)
+++ trunk/kernel/tgt_vsd.c	2005-09-23 00:33:42 UTC (rev 87)
@@ -0,0 +1,215 @@
+/*
+ * virtual scsi disk functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/uio.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/writeback.h>
+
+#include <scsi/scsi.h>
+
+#include <tgt.h>
+#include <tgt_device.h>
+#include <tgt_scsi.h>
+
+static int tgt_vsd_create(struct tgt_device *device)
+{
+	struct inode *inode;
+
+	inode = device->file->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
+	else
+		return -EINVAL;
+
+	device->size = inode->i_size;
+	printk("%d %llu\n", device->fd, inode->i_size >> 9);
+
+	return 0;
+}
+
+/*
+ * is this device specific or common? Should it be moved to the protocol.
+ */
+static void tgt_vsd_prep(struct tgt_cmnd *cmnd)
+{
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	uint8_t *scb = scmnd->scb;
+	uint64_t off = 0;
+	uint32_t len = 0;
+
+	/*
+	 * set bufflen and offset
+	 */
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		len = scb[4];
+		if (!len)
+			len = 256;
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(u32 *) &scb[2]);
+		len = (scb[7] << 8) + scb[8];
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(u64 *)&scb[2]);
+		len = be32_to_cpu(*(u32 *)&scb[10]);
+		break;
+	default:
+		break;
+	}
+
+	off <<= 9;
+	len <<= 9;
+
+	cmnd->bufflen = len;
+	cmnd->offset = off;
+}
+
+static void tgt_vsd_uspace_complete(struct tgt_cmnd *cmnd)
+{
+	/* userspace did everything for us just copy the buffer */
+	if (cmnd->result != SAM_STAT_GOOD)
+		scsi_tgt_sense_copy(cmnd);
+}
+
+/*
+ * TODO: We need to redo our scatter lists so they take into account
+ * this common usage, but also not violate HW limits
+ */
+static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
+{
+	struct iovec* iov;
+	int i;
+
+	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
+	if (!iov)
+		return NULL;
+
+	for (i = 0; i < sg_count; i++) {
+		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
+		iov[i].iov_len = sg[i].length;
+	}
+
+	return iov;
+}
+
+/*
+ * TODO this will move to a io_handler callout
+ */
+static int vsd_queue_file_io(struct tgt_cmnd *cmnd, int op)
+{
+	struct file *file = cmnd->device->file;
+	ssize_t size;
+	struct iovec *iov;
+	loff_t pos = cmnd->offset;
+
+	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+	if (!iov)
+		return -ENOMEM;
+
+	if (op == READ)
+		size = generic_file_readv(file, iov, cmnd->sg_count, &pos);
+	else
+		size = generic_file_writev(file, iov, cmnd->sg_count, &pos);
+
+	kfree(iov);
+
+/* not yet used
+	if (sync)
+		err = sync_page_range(inode, inode->i_mapping, pos,
+				      (size_t) cmnd->bufflen);
+*/
+	return size;
+}
+
+static int tgt_vsd_queue(struct tgt_cmnd *cmnd)
+{
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct tgt_device *device = cmnd->device;
+	loff_t pos = cmnd->offset;
+	int err = 0, rw;
+
+	if (cmnd->bufflen + pos > device->size) {
+		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMND_FAILED;
+	}
+
+	switch (scmnd->scb[0]) {
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		rw = READ;
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		rw = WRITE;
+		break;
+	default:
+		err = tgt_uspace_cmnd_send(cmnd);
+		/*
+		 * successfully queued
+		 */
+		if (err >= 0)
+			return TGT_CMND_USPACE_QUEUED;
+
+		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMND_FAILED;
+	};
+
+	/*
+	 * TODO this will become device->io_handler->queue_cmnd
+	 * when we seperate the io_handlers
+	 */
+	err = vsd_queue_file_io(cmnd, rw);
+	/*
+	 * we should to a switch but I am not sure of all the err values
+	 * returned. If you find one add it
+	 */
+	if (err != cmnd->bufflen) {
+		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMND_FAILED;
+	} else {
+		cmnd->result = SAM_STAT_GOOD;
+		return TGT_CMND_COMPLETED;
+	}
+}
+
+static struct tgt_device_template tgt_vsd = {
+	.name = "tgt_vsd",
+	.module = THIS_MODULE,
+	.create = tgt_vsd_create,
+	.queue_cmnd = tgt_vsd_queue,
+	.prep_cmnd = tgt_vsd_prep,
+	.complete_uspace_cmnd = tgt_vsd_uspace_complete,
+};
+
+static int __init tgt_vsd_init(void)
+{
+	return tgt_device_template_register(&tgt_vsd);
+}
+
+static void __exit tgt_vsd_exit(void)
+{
+	tgt_device_template_unregister(&tgt_vsd);
+}
+
+module_init(tgt_vsd_init);
+module_exit(tgt_vsd_exit);
+MODULE_LICENSE("GPL");



From mnc at berlios.de  Fri Sep 23 02:35:42 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Fri, 23 Sep 2005 02:35:42 +0200
Subject: [Stgt-svn] r88 - trunk/kernel
Message-ID: <200509230035.j8N0Zg3w021976@sheep.berlios.de>

Author: mnc
Date: 2005-09-23 02:35:37 +0200 (Fri, 23 Sep 2005)
New Revision: 88

Added:
   trunk/kernel/tgt_scsi.h
Log:
we moved some scsi things to a lib to allow different scsi devices (like tape or disk or cd etc) to be able to use them

Added: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-09-23 00:33:42 UTC (rev 87)
+++ trunk/kernel/tgt_scsi.h	2005-09-23 00:35:37 UTC (rev 88)
@@ -0,0 +1,30 @@
+/*
+ * SCSI target helpers
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#ifndef __TGT_SCSI_H
+#define __TGT_SCSI_H
+
+#include <tgt.h>
+#include <scsi/scsi_cmnd.h>
+
+struct scsi_tgt_cmnd {
+	uint8_t scb[MAX_COMMAND_SIZE];
+	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
+	int sense_len;
+	int tags;
+};
+
+static inline struct scsi_tgt_cmnd *tgt_cmnd_to_scsi(struct tgt_cmnd *cmnd)
+{
+	return (struct scsi_tgt_cmnd *) cmnd->proto_priv;
+}
+
+extern int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd);
+extern int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+				     uint8_t ascode, uint8_t ascodeq);
+#endif



From mnc at berlios.de  Fri Sep 23 22:36:39 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Fri, 23 Sep 2005 22:36:39 +0200
Subject: [Stgt-svn] r89 - in trunk: iscsi/kernel kernel
Message-ID: <200509232036.j8NKadWA004457@sheep.berlios.de>

Author: mnc
Date: 2005-09-23 22:36:38 +0200 (Fri, 23 Sep 2005)
New Revision: 89

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_vsd.c
Log:
create buffer from create cmnd; for now trust expected transfer length. This allows us to have a vsd or sd get a buffer for the transfer without completely parsing the command (can we completely trust this value, HW cards have something similar). This is needed to make passthrough very simple. Target drivers should konw when they have to allocate or not allocate a buffer since it should not know if the command is going to userpscace, a passthrough device etc. The should just magically receive a buffer whenever they need it and let the target framework do the magic

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-23 20:36:38 UTC (rev 89)
@@ -843,13 +843,26 @@
 {
 	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	enum dma_data_direction data_dir;
 
 	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
 
 	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
+	/*
+	 * handle bidi later
+	 */
+	if (req_hdr->flags & ISCSI_FLAG_CMD_WRITE)
+		data_dir = DMA_TO_DEVICE;
+	else if (req_hdr->flags & ISCSI_FLAG_CMD_READ)
+		data_dir = DMA_FROM_DEVICE;
+	else
+		data_dir = DMA_NONE;
+
 	req->tc = proto->create_cmnd(conn->session->ts, req_hdr->cdb,
-				     req_hdr->lun, sizeof(req_hdr->lun));
+				     be32_to_cpu(req_hdr->data_length),
+				     data_dir, req_hdr->lun,
+				     sizeof(req_hdr->lun), NULL);
 	assert(req->tc);
 
 	switch (req_hdr->cdb[0]) {
@@ -893,7 +906,6 @@
 			cmnd_skip_data(req);
 		}
 
-		proto->alloc_cmnd_buffer(req->tc, NULL);
 		break;
 	}
 	case WRITE_6:
@@ -918,8 +930,6 @@
 		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
 			eprintk("Verification is ignored %x\n", cmnd_itt(req));
 
-		proto->alloc_cmnd_buffer(req->tc, NULL);
-
 		if (req->pdu.datasize) {
 			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)
 				assert(0);

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt.c	2005-09-23 20:36:38 UTC (rev 89)
@@ -561,15 +561,21 @@
 }
 EXPORT_SYMBOL_GPL(tgt_cmnd_create);
 
+static void tgt_free_buffer(struct tgt_cmnd *cmnd)
+{
+	int i;
+	
+	for (i = 0; i < cmnd->sg_count; i++)
+		__free_page(cmnd->sg[i].page);
+	kfree(cmnd->sg);
+}
+
 void tgt_cmnd_destroy(struct tgt_cmnd *cmnd)
 {
 	unsigned long flags;
-	int i;
 
 	dprintk("cid %llu\n", cmnd->cid);
 
-	for (i = 0; i < cmnd->sg_count; i++)
-		__free_page(cmnd->sg[i].page);
 	kfree(cmnd->sg);
 
 	spin_lock_irqsave(&cmnd_hash_lock, flags);
@@ -687,14 +693,24 @@
 	int i;
 	BUG_ON(!cmnd->done);
 
-	dprintk("cid %llu result %d len %d\n",
-		cmnd->cid, result, len);
+	dprintk("cid %llu result %d len %d bufflen %u\n",
+		cmnd->cid, result, len, cmnd->bufflen);
 
 	if (len) {
-		cmnd->bufflen = len;
-		cmnd->offset = 0;
-		__tgt_alloc_buffer(cmnd);
+		/*
+		 * yuck TODO fix.
+		 * This will happen if we though we were going to do some
+		 * IO but we ended up just gettting some sense back
+		 */
+		if (len != cmnd->bufflen) {
+			tgt_free_buffer(cmnd);
 
+			cmnd->bufflen = len;
+			cmnd->offset = 0;
+
+			__tgt_alloc_buffer(cmnd);
+		}
+
 		for (i = 0; i < cmnd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
 

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt.h	2005-09-23 20:36:38 UTC (rev 89)
@@ -10,6 +10,7 @@
 #define __TGT_H
 
 #include <linux/mempool.h>
+#include <linux/dma-mapping.h>
 
 struct tgt_device;
 struct tgt_protocol;
@@ -36,6 +37,7 @@
 	struct list_head clist;
 	struct list_head hash_list;
 
+	enum dma_data_direction data_dir;
 	int sg_count;
 	struct scatterlist *sg;
 	uint32_t bufflen;

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt_device.h	2005-09-23 20:36:38 UTC (rev 89)
@@ -54,7 +54,7 @@
 	/*
 	 * setup buffer or device fields if needed
 	 */
-	void (* prep_cmnd)(struct tgt_cmnd *cmnd);
+	void (* prep_cmnd)(struct tgt_cmnd *cmnd, uint32_t data_len);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt_protocol.h	2005-09-23 20:36:38 UTC (rev 89)
@@ -9,6 +9,7 @@
 #define __TGT_PROTOCOL_H
 
 #include <linux/slab.h>
+#include <linux/dma-mapping.h>
 
 struct module;
 struct tgt_cmnd;
@@ -27,23 +28,25 @@
 	int uspace_pdu_size;
 
 	/*
-	 * create a command.
+	 * create a command and allocate a buffer of size data_len for
+	 * for transfer. The buffer will be allocated with GFP_KERNEL
+	 * so if you cannot sleep the caller must pass in a done() function.
+	 * The done function will be called from process context.
+	 *
+	 * TODO: This dual behavior is a little strange. We will convert
+	 * iet to open-iscsi's model so eventually the done() function
+	 * will be a requirement so we can have a common path.
 	 */
 	struct tgt_cmnd *(* create_cmnd)(struct tgt_session *session,
-					uint8_t *cmd, uint8_t *dev_id_buff,
-					int buff_size);
+					uint8_t *cmd, uint32_t data_len,
+					enum dma_data_direction data_dir,
+					uint8_t *dev_id_buff, int id_buff_size,
+					void (*done)(struct tgt_cmnd *));
 	/*
 	 * destroy a command. This will free the command and buffer
 	 */
 	void (* destroy_cmnd)(struct tgt_cmnd *cmd); 
 	/*
-	 * allocoate a comand buffer. If this is called from irq context
-	 * a done callback can be set so the allocation is done in process
-	 * context.
-	 */
-	void (* alloc_cmnd_buffer)(struct tgt_cmnd *cmnd,
-				   void (*done)(struct tgt_cmnd *));
-	/*
 	 * queue a command to be executed in a workqueue. A done() callback
 	 * must be passed in.
 	 */

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt_scsi.c	2005-09-23 20:36:38 UTC (rev 89)
@@ -47,8 +47,10 @@
  * differently
  */
 static struct tgt_cmnd *
-scsi_tgt_create_cmnd(struct tgt_session *session, uint8_t *scb, uint8_t *lun,
-		     int lun_size)
+scsi_tgt_create_cmnd(struct tgt_session *session, uint8_t *scb,
+		     uint32_t data_len, enum dma_data_direction data_dir,
+		     uint8_t *lun, int lun_size,
+		     void (*done)(struct tgt_cmnd *))
 {
 	struct tgt_device *device;
 	struct tgt_cmnd *cmnd;
@@ -72,8 +74,17 @@
 	}
 	cmnd->device = device;
 
+	/* is this device specific */
+	cmnd->data_dir = data_dir;
+	/*
+	 * set bufflen based on data_len for now, but let device specific
+	 * handler overide just in case
+	 */
+	cmnd->bufflen = data_len;
 	/* do scsi device specific setup */
-	device->dt->prep_cmnd(cmnd);
+	device->dt->prep_cmnd(cmnd, data_len);
+	if (cmnd->bufflen)
+		tgt_cmnd_alloc_buffer(cmnd, done);
 	return cmnd;
 }
 
@@ -128,7 +139,6 @@
 	.module = THIS_MODULE,
 	.create_cmnd = scsi_tgt_create_cmnd,
 	.destroy_cmnd = tgt_cmnd_destroy,
-	.alloc_cmnd_buffer = tgt_cmnd_alloc_buffer,
 	.queue_cmnd = tgt_cmnd_queue,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/kernel/tgt_vsd.c	2005-09-23 20:36:38 UTC (rev 89)
@@ -40,12 +40,12 @@
 /*
  * is this device specific or common? Should it be moved to the protocol.
  */
-static void tgt_vsd_prep(struct tgt_cmnd *cmnd)
+static void tgt_vsd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
 {
 	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
 	uint8_t *scb = scmnd->scb;
 	uint64_t off = 0;
-	uint32_t len = 0;
+/*	uint32_t len = 0; */
 
 	/*
 	 * set bufflen and offset
@@ -54,29 +54,32 @@
 	case READ_6:
 	case WRITE_6:
 		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		len = scb[4];
+/*		len = scb[4];
 		if (!len)
-			len = 256;
+			len = 256;*/
 		break;
 	case READ_10:
 	case WRITE_10:
 	case WRITE_VERIFY:
 		off = be32_to_cpu(*(u32 *) &scb[2]);
-		len = (scb[7] << 8) + scb[8];
+/*		len = (scb[7] << 8) + scb[8]; */
 		break;
 	case READ_16:
 	case WRITE_16:
 		off = be64_to_cpu(*(u64 *)&scb[2]);
-		len = be32_to_cpu(*(u32 *)&scb[10]);
+/*		len = be32_to_cpu(*(u32 *)&scb[10]); */
 		break;
 	default:
 		break;
 	}
 
 	off <<= 9;
-	len <<= 9;
+/*	len <<= 9; */
 
-	cmnd->bufflen = len;
+	/*
+	 * we trust the data_len passed in for now
+	 */
+	cmnd->bufflen = data_len;
 	cmnd->offset = off;
 }
 



From mnc at berlios.de  Sat Sep 24 02:06:04 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 02:06:04 +0200
Subject: [Stgt-svn] r90 - in trunk: . iscsi/kernel kernel
Message-ID: <200509240006.j8O064P1004295@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 02:05:45 +0200 (Sat, 24 Sep 2005)
New Revision: 90

Modified:
   trunk/initd
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
Log:
initial passthru scsi device (only tested with scsi disk). TODO: handle queue limits (segments, max_sectors etc), fix up async completion support, rename cmnd_done stacks and make target callouts

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-23 20:36:38 UTC (rev 89)
+++ trunk/initd	2005-09-24 00:05:45 UTC (rev 90)
@@ -11,6 +11,7 @@
 	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
 	insmod ${PWD}/kernel/tgt_vsd.ko
+#	insmod ${PWD}/kernel/tgt_sd.ko
 	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
@@ -26,6 +27,7 @@
 
 	rmmod iscsi_trgt
 
+#	rmmod tgt_sd
 	rmmod tgt_vsd
 	rmmod tgt_scsi
 	rmmod tgt_core

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-23 20:36:38 UTC (rev 89)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 00:05:45 UTC (rev 90)
@@ -63,7 +63,7 @@
 	struct iscsi_cmnd *cmnd;
 
 	/* TODO: async interface is necessary ? */
-	cmnd = kmem_cache_alloc(iscsi_cmnd_cache, GFP_KERNEL|__GFP_NOFAIL);
+	cmnd = kmem_cache_alloc(iscsi_cmnd_cache, GFP_KERNEL | __GFP_NOFAIL);
 
 	memset(cmnd, 0, sizeof(*cmnd));
 	INIT_LIST_HEAD(&cmnd->list);

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-23 20:36:38 UTC (rev 89)
+++ trunk/kernel/Makefile	2005-09-24 00:05:45 UTC (rev 90)
@@ -8,7 +8,7 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vsd.o tgt_scsi.o
+obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-23 20:36:38 UTC (rev 89)
+++ trunk/kernel/tgt.c	2005-09-24 00:05:45 UTC (rev 90)
@@ -588,6 +588,11 @@
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
+/*
+ * TODO: this will have to obey at least the target driver's limits,
+ * but to support passthrough commands we will need to obey the
+ * something like's tgt_sd devices's queue's limits.
+ */
 void __tgt_alloc_buffer(struct tgt_cmnd *cmnd)
 {
 	uint64_t offset = cmnd->offset;
@@ -676,8 +681,20 @@
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmnd_send);
 
-static void cmnd_done(struct tgt_cmnd *cmnd)
+/*
+ * TODO we should make cmnd->done a target callback instead. Maybe
+ * target->tt->queuecommand. We need this becuase a target driver
+ * may not have the resources to execute the command. We also need
+ * a real queue, I guess, and some queue limits.
+ *
+ * NOTE THIS WILL NOT EXECUTE FROM A THREAD FOR LONG. IT APPEARS
+ * TO BE HORRIBLE FOR PERF AND ONLY NEEDED BECAUSE OF IET. THE LLD SHOULD
+ * BE ABLE TO EXECUTE FROM A SOFTIRQ SINCE WE WILL EVENTUALLY GO ALL ASYNC
+ *
+ */
+static void tgt_notify_cmnd_ready(void *data)
 {
+	struct tgt_cmnd *cmnd = data;
 	void (*done)(struct tgt_cmnd *);
 
 	done = cmnd->done;
@@ -685,6 +702,15 @@
 	done(cmnd);
 }
 
+void tgt_cmnd_done(struct tgt_cmnd *cmnd)
+{
+	struct tgt_session *session = cmnd->session;
+
+	INIT_WORK(&cmnd->work, tgt_notify_cmnd_ready, cmnd);
+	queue_work(session->target->twq, &cmnd->work);
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_done);
+
 static void uspace_cmnd_done(struct tgt_cmnd *cmnd, void *data,
 			     int result, uint32_t len)
 {
@@ -723,7 +749,7 @@
 	cmnd->result = result;
 	if (device->dt->complete_uspace_cmnd)
 		device->dt->complete_uspace_cmnd(cmnd);
-	cmnd_done(cmnd);
+	tgt_cmnd_done(cmnd);
 }
 
 static void queuecommand(void *data)
@@ -747,9 +773,7 @@
 	case TGT_CMND_FAILED:
 	case TGT_CMND_COMPLETED:
 		dprintk("command completed %d\n", err);
-		if (device->dt->complete_kern_cmnd)
-			device->dt->complete_kern_cmnd(cmnd);
-		cmnd_done(cmnd);
+		tgt_cmnd_done(cmnd);
 	default:
 		dprintk("command %llu queued\n", cmnd->cid);
 	};

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-23 20:36:38 UTC (rev 89)
+++ trunk/kernel/tgt.h	2005-09-24 00:05:45 UTC (rev 90)
@@ -70,6 +70,7 @@
 				  void (*done)(struct tgt_cmnd *));
 extern int tgt_cmnd_queue(struct tgt_cmnd *cmnd,
 			  void (*done)(struct tgt_cmnd *));
+extern void tgt_cmnd_done(struct tgt_cmnd *cmnd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 #endif



From mnc at berlios.de  Sat Sep 24 02:08:44 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 02:08:44 +0200
Subject: [Stgt-svn] r91 - trunk/kernel
Message-ID: <200509240008.j8O08iK1005049@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 02:08:37 +0200 (Sat, 24 Sep 2005)
New Revision: 91

Added:
   trunk/kernel/tgt_sd.c
Log:
add passthru disk. It may be able to handle other devices like scsi tape or cd but I do not have one of them and I need to read those specs. So note that it is temporarily named tgt_sd.c but if we can get it to work for any scsi device then we should rename it to tgt_passthru_dev or something generic

Added: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-09-24 00:05:45 UTC (rev 90)
+++ trunk/kernel/tgt_sd.c	2005-09-24 00:08:37 UTC (rev 91)
@@ -0,0 +1,267 @@
+/*
+ * scsi disk functions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/uio.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/writeback.h>
+
+#include <scsi/scsi.h>
+
+#include <tgt.h>
+#include <tgt_device.h>
+#include <tgt_scsi.h>
+
+/*
+ * TODO set per device segment, max_sectors, etc limits
+ */
+static int tgt_sd_create(struct tgt_device *device)
+{
+	struct inode *inode;
+
+	inode = device->file->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
+	else
+		/*
+		 * can we handle scsi tape too actually?
+		 */
+		return -EINVAL;
+
+	device->size = inode->i_size;
+	printk("%d %llu\n", device->fd, inode->i_size >> 9);
+
+	return 0;
+}
+
+static void tgt_sd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
+{
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	uint8_t *scb = scmnd->scb;
+	uint64_t off = 0;
+
+	/*
+	 * set offset
+	 */
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(u32 *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(u64 *)&scb[2]);
+		break;
+	default:
+		break;
+	}
+
+	off <<= 9;
+
+	/*
+	 * we trust the data_len passed in for now
+	 */
+	cmnd->bufflen = data_len;
+	cmnd->offset = off;
+}
+
+static void tgt_sd_end_rq(struct request *rq)
+{
+	struct tgt_cmnd *cmnd = rq->end_io_data;
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	void (*done)(struct tgt_cmnd *);
+
+	if (rq->sense_len) {
+		memcpy(scmnd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);
+		cmnd->result = SAM_STAT_CHECK_CONDITION;
+	} else if (rq->errors) {
+		/*
+		 * TODO check *_byte and just send error upwards
+		 */
+		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+		cmnd->result = SAM_STAT_CHECK_CONDITION;
+	} else
+		cmnd->result = SAM_STAT_GOOD;
+
+
+	tgt_cmnd_done(cmnd);
+	__blk_put_request(rq->q, rq);
+}
+
+/*
+ * this is going to the bio layer
+ */
+static struct bio *bio_map_pages(request_queue_t *q, struct page *page,
+				 unsigned int len, unsigned int offset,
+				 unsigned int gfp_mask)
+{
+	int nr_pages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	struct bio *bio;
+
+	bio = bio_alloc(gfp_mask, nr_pages);
+	if (!bio)
+		return ERR_PTR(-ENOMEM);
+
+	while (len) {
+		unsigned int bytes = PAGE_SIZE - offset;
+
+		if (bytes > len)
+			bytes = len;
+
+		if (__bio_add_page(q, bio, page, bytes, offset) < bytes)
+			goto free_bio;
+
+		offset = 0;
+		len -= bytes;
+		page++;
+	}
+
+	return bio;
+
+ free_bio:
+	bio_put(bio);
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * this is going to scsi-ml or the block layer
+ */
+static int req_map_sg(request_queue_t *q, struct request *rq,
+		      struct scatterlist *sg, int nsegs, unsigned int gfp)
+{
+	struct bio *bio;
+	int i, err = 0;
+	unsigned int len = 0;
+
+	for (i = 0; i < nsegs; i++) {
+		bio = bio_map_pages(q, sg[i].page, sg[i].length, sg[i].offset,
+				    gfp);
+		if (IS_ERR(bio)) {
+			err = PTR_ERR(bio);
+			goto free_bios;
+		}
+		len += sg[i].length;
+
+		bio->bi_flags &= ~(1 << BIO_SEG_VALID);
+		if (rq_data_dir(rq) == WRITE)
+			bio->bi_rw |= (1 << BIO_RW);
+		blk_queue_bounce(q, &bio);
+
+		if (i == 0)
+			blk_rq_bio_prep(q, rq, bio);
+		else if (!q->back_merge_fn(q, rq, bio)) {
+			bio_endio(bio, bio->bi_size, 0);
+			err = -EINVAL;
+			goto free_bios;
+		} else {
+			rq->biotail->bi_next = bio;
+			rq->biotail = bio;
+			rq->hard_nr_sectors += bio_sectors(bio);
+			rq->nr_sectors = rq->hard_nr_sectors;
+		}
+	}
+
+	rq->buffer = rq->data = NULL;
+	rq->data_len = len;
+	return 0;
+
+ free_bios:
+	while ((bio = rq->bio) != NULL) {
+		rq->bio = bio->bi_next;
+		/*
+		 * call endio instead of bio_put incase it was bounced
+		 */
+		bio_endio(bio, bio->bi_size, 0);
+	}
+
+	return err;
+}
+
+/*
+ * TODO part of this will move to a io_handler callout
+ */
+static int tgt_sd_queue_rq(struct tgt_cmnd *cmnd)
+{
+	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct file *file = cmnd->device->file;
+	request_queue_t *q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
+	struct request *rq;
+	int write = (cmnd->data_dir == DMA_TO_DEVICE);
+
+	rq = blk_get_request(q, write, GFP_KERNEL | __GFP_NOFAIL);
+	if (!rq)
+		goto hw_error;
+
+	if (req_map_sg(q, rq, cmnd->sg, cmnd->sg_count,
+			GFP_KERNEL | __GFP_NOFAIL))
+		goto free_request;
+
+	rq->cmd_len = COMMAND_SIZE(scmnd->scb[0]);
+	memcpy(rq->cmd, scmnd->scb, rq->cmd_len);
+	rq->sense_len = 0;
+	rq->sense = scmnd->sense_buff;
+	rq->end_io_data = cmnd;
+	rq->timeout = 60 * HZ; /* TODO */
+	rq->flags |= REQ_BLOCK_PC;
+
+	blk_execute_rq_nowait(q, NULL, rq, 0, tgt_sd_end_rq);
+	return 0;
+
+ free_request:
+	blk_put_request(rq);
+ hw_error:
+	scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+	return -ENOMEM;
+}
+
+static int tgt_sd_queue(struct tgt_cmnd *cmnd)
+{
+	struct tgt_device *device = cmnd->device;
+	loff_t pos = cmnd->offset;
+
+	if (cmnd->bufflen + pos > device->size) {
+		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMND_FAILED;
+	}
+	/*
+	 * TODO this will become device->io_handler->queue_cmnd
+	 * when we seperate the io_handlers
+	 */
+	return tgt_sd_queue_rq(cmnd) ? TGT_CMND_FAILED : TGT_CMND_KERN_QUEUED;
+}
+
+static struct tgt_device_template tgt_sd = {
+	.name = "tgt_sd",
+	.module = THIS_MODULE,
+	.create = tgt_sd_create,
+	.queue_cmnd = tgt_sd_queue,
+	.prep_cmnd = tgt_sd_prep,
+};
+
+static int __init tgt_sd_init(void)
+{
+	return tgt_device_template_register(&tgt_sd);
+}
+
+static void __exit tgt_sd_exit(void)
+{
+	tgt_device_template_unregister(&tgt_sd);
+}
+
+module_init(tgt_sd_init);
+module_exit(tgt_sd_exit);
+MODULE_LICENSE("GPL");



From mnc at berlios.de  Sat Sep 24 02:11:42 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 02:11:42 +0200
Subject: [Stgt-svn] r92 - trunk/kernel
Message-ID: <200509240011.j8O0BgQR007124@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 02:11:39 +0200 (Sat, 24 Sep 2005)
New Revision: 92

Modified:
   trunk/kernel/Makefile
   trunk/kernel/tgt_sd.c
Log:
You need to EXPORT_SYMBOL some mainline functions before you can use tgt_sd.c so do not compile by default

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-24 00:08:37 UTC (rev 91)
+++ trunk/kernel/Makefile	2005-09-24 00:11:39 UTC (rev 92)
@@ -8,7 +8,8 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o
+obj-m		+= tgt_vsd.o tgt_scsi.o
+#obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-09-24 00:08:37 UTC (rev 91)
+++ trunk/kernel/tgt_sd.c	2005-09-24 00:11:39 UTC (rev 92)
@@ -83,7 +83,6 @@
 {
 	struct tgt_cmnd *cmnd = rq->end_io_data;
 	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	void (*done)(struct tgt_cmnd *);
 
 	if (rq->sense_len) {
 		memcpy(scmnd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);



From mnc at berlios.de  Sat Sep 24 02:14:57 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 02:14:57 +0200
Subject: [Stgt-svn] r93 - trunk/kernel
Message-ID: <200509240014.j8O0Evlb007985@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 02:14:51 +0200 (Sat, 24 Sep 2005)
New Revision: 93

Modified:
   trunk/kernel/tgt.c
Log:
we are already running from a workqueue in queuecommand so dont queue more work

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 00:11:39 UTC (rev 92)
+++ trunk/kernel/tgt.c	2005-09-24 00:14:51 UTC (rev 93)
@@ -773,7 +773,7 @@
 	case TGT_CMND_FAILED:
 	case TGT_CMND_COMPLETED:
 		dprintk("command completed %d\n", err);
-		tgt_cmnd_done(cmnd);
+		tgt_notify_cmnd_ready(cmnd);
 	default:
 		dprintk("command %llu queued\n", cmnd->cid);
 	};



From mnc at berlios.de  Sat Sep 24 02:30:22 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 02:30:22 +0200
Subject: [Stgt-svn] r94 - in trunk: include iscsi/kernel iscsi/usr kernel usr
Message-ID: <200509240030.j8O0UMSE017677@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 02:30:13 +0200 (Sat, 24 Sep 2005)
New Revision: 94

Modified:
   trunk/include/tgt_if.h
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
   trunk/usr/ipc.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
rename cmnd to cmd to better match the block layer and scsi

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/include/tgt_if.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,11 +17,11 @@
 	TGT_UEVENT_TARGET_PASSTHRU,
 	TGT_UEVENT_DEVICE_CREATE,
 	TGT_UEVENT_DEVICE_DESTROY,
-	TGT_UEVENT_CMND_RES,
+	TGT_UEVENT_CMD_RES,
 
 	/* kernel -> user */
 	TGT_KEVENT_RESPONSE,
-	TGT_KEVENT_CMND_REQ,
+	TGT_KEVENT_CMD_REQ,
 	TGT_KEVENT_TARGET_PASSTHRU,
 };
 
@@ -30,7 +30,7 @@
 	union {
 		struct {
 			char type[32];
-			int nr_cmnds;
+			int nr_cmds;
 		} c_target;
 		struct {
 			int tid;
@@ -54,7 +54,7 @@
 			uint64_t cid;
 			uint32_t len;
 			int result;
-		} cmnd_res;
+		} cmd_res;
 	} u;
 
 	/* kernel -> user */
@@ -66,7 +66,7 @@
 			uint64_t cid;
 			int tid;
 			uint64_t dev_id;
-		} cmnd_req;
+		} cmd_req;
 		struct {
 			int tid;
 			uint32_t len;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -263,7 +263,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
-	struct scsi_tgt_cmnd *stc;
+	struct scsi_tgt_cmd *stc;
 	struct scatterlist *sg = &req->sense_sg;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
@@ -275,7 +275,7 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	stc = tgt_cmnd_to_scsi(req->tc);
+	stc = tgt_cmd_to_scsi(req->tc);
 	sense = (struct iscsi_sense_data *) stc->sense_buff;
 	memmove(sense->data, sense, stc->sense_len);
 	/*
@@ -295,7 +295,7 @@
 static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
 					   u8 sense_key, u8 asc, u8 ascq)
 {
-	struct scsi_tgt_cmnd *stc;
+	struct scsi_tgt_cmd *stc;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
@@ -310,7 +310,7 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmnd_hdr(req)->itt;
 
-	stc = tgt_cmnd_to_scsi(req->tc);
+	stc = tgt_cmd_to_scsi(req->tc);
 	sg->page = virt_to_page(stc->sense_buff);
 	sg->offset = offset_in_page(stc->sense_buff);
 	sg->length = stc->sense_len;
@@ -368,9 +368,10 @@
 	list_del(&cmnd->conn_list);
 	spin_unlock(&conn->list_lock);
 
-	if (cmnd->tc)
-		tgt_cmnd_destroy(cmnd->tc);
-
+	if (cmnd->tc) {
+		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
+		proto->destroy_cmd(cmnd->tc);
+	}
 	kmem_cache_free(iscsi_cmnd_cache, cmnd);
 }
 
@@ -598,7 +599,7 @@
 	cmnd_skip_pdu(req);
 }
 
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmnd *tc,
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmd *tc,
 			 u32 offset, u32 size)
 {
 	int idx, i;
@@ -703,7 +704,7 @@
 	iscsi_cmnds_init_write(&send);
 }
 
-static void scsi_cmnd_done(struct tgt_cmnd *tc)
+static void scsi_cmnd_done(struct tgt_cmd *tc)
 {
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
@@ -760,7 +761,7 @@
 		set_cmnd_waitio(cmnd);
 		cmnd->tc->private = cmnd;
 
-		proto->queue_cmnd(cmnd->tc, scsi_cmnd_done);
+		proto->queue_cmd(cmnd->tc, scsi_cmnd_done);
 	}
 }
 
@@ -859,10 +860,10 @@
 	else
 		data_dir = DMA_NONE;
 
-	req->tc = proto->create_cmnd(conn->session->ts, req_hdr->cdb,
-				     be32_to_cpu(req_hdr->data_length),
-				     data_dir, req_hdr->lun,
-				     sizeof(req_hdr->lun), NULL);
+	req->tc = proto->create_cmd(conn->session->ts, req_hdr->cdb,
+				    be32_to_cpu(req_hdr->data_length),
+				    data_dir, req_hdr->lun,
+				    sizeof(req_hdr->lun), NULL);
 	assert(req->tc);
 
 	switch (req_hdr->cdb[0]) {

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -192,7 +192,7 @@
 	u32 ddigest;
 
 	struct iscsi_cmnd *req;
-	struct tgt_cmnd *tc;
+	struct tgt_cmd *tc;
 };
 
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/usr/ctldev.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -441,7 +441,7 @@
 
 	ev = NLMSG_DATA(nlh);
 	sprintf(ev->u.c_target.type, "%s", "iet");
-	ev->u.c_target.nr_cmnds = DEFAULT_NR_QUEUED_CMNDS;
+	ev->u.c_target.nr_cmds = DEFAULT_NR_QUEUED_CMNDS;
 
 	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 	if (err > 0) {

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -56,10 +56,10 @@
 static struct sock *nls;
 
 /* TODO: lock per session */
-static spinlock_t cmnd_hash_lock;
+static spinlock_t cmd_hash_lock;
 #define TGT_HASH_ORDER		8
-#define	cmnd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
-static struct list_head cmnd_hash[1 << TGT_HASH_ORDER];
+#define	cmd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
+static struct list_head cmd_hash[1 << TGT_HASH_ORDER];
 
 struct target_type_internal {
 	struct list_head list;
@@ -154,7 +154,7 @@
 	return target;
 }
 
-struct tgt_target *tgt_target_create(char *target_type, int queued_cmnds)
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmds)
 {
 	char name[16];
 	static int target_id;
@@ -184,7 +184,7 @@
 	INIT_LIST_HEAD(&target->device_list);
 	INIT_LIST_HEAD(&target->work_list);
 
-	target->queued_cmnds = queued_cmnds;
+	target->queued_cmds = queued_cmds;
 
 	snprintf(name, sizeof(name), "tgtd%d", target->tid);
 	target->twq = create_workqueue(name);
@@ -241,15 +241,15 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_destroy);
 
-static int session_init(struct tgt_session *session, int max_cmnds)
+static int session_init(struct tgt_session *session, int max_cmds)
 {
 	struct tgt_target *target = session->target;
 	struct tgt_protocol *proto = session->target->proto;
 	unsigned long flags;
 
-	session->cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					mempool_free_slab, proto->cmnd_cache);
-	if (!session->cmnd_pool)
+	session->cmd_pool = mempool_create(max_cmds, mempool_alloc_slab,
+					mempool_free_slab, proto->cmd_cache);
+	if (!session->cmd_pool)
 		goto out;
 
 	spin_lock_irqsave(&target->lock, flags);
@@ -258,8 +258,8 @@
 
 	return 0;
 out:
-	if (session->cmnd_pool)
-		mempool_destroy(session->cmnd_pool);
+	if (session->cmd_pool)
+		mempool_destroy(session->cmd_pool);
 
 	return -ENOMEM;
 }
@@ -287,7 +287,7 @@
 
 struct tgt_session *
 tgt_session_create(struct tgt_target *target,
-		   int max_cmnds,
+		   int max_cmds,
 		   void (*done)(void *, struct tgt_session *),
 		   void *arg)
 {
@@ -301,7 +301,7 @@
 		return NULL;
 	}
 
-	dprintk("%p %d\n", target, max_cmnds);
+	dprintk("%p %d\n", target, max_cmds);
 
 	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
 	if (!session)
@@ -316,7 +316,7 @@
 			goto out;
 
 		async->session = session;
-		async->cmds = max_cmnds;
+		async->cmds = max_cmds;
 		async->done = done;
 		async->arg = arg;
 
@@ -325,7 +325,7 @@
 		return session;
 	}
 
-	if (session_init(session, max_cmnds) < 0)
+	if (session_init(session, max_cmds) < 0)
 		goto out;
 
 	return session;
@@ -338,7 +338,7 @@
 
 int tgt_session_destroy(struct tgt_session *session)
 {
-	mempool_destroy(session->cmnd_pool);
+	mempool_destroy(session->cmd_pool);
 	kfree(session);
 
 	return 0;
@@ -534,57 +534,57 @@
 	return 0;
 }
 
-struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session)
+struct tgt_cmd *tgt_cmd_create(struct tgt_session *session)
 {
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	unsigned long flags;
 
-	cmnd = mempool_alloc(session->cmnd_pool, GFP_ATOMIC);
-	if (!cmnd) {
-		eprintk("Could not allocate tgt_cmnd for %p\n", session);
+	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
+	if (!cmd) {
+		eprintk("Could not allocate tgt_cmd for %p\n", session);
 		return NULL;
 	}
 
-	memset(cmnd, 0, sizeof(*cmnd));
-	cmnd->session = session;
-	cmnd->cid = (uint64_t) (unsigned long) cmnd;
-	INIT_LIST_HEAD(&cmnd->clist);
-	INIT_LIST_HEAD(&cmnd->hash_list);
+	memset(cmd, 0, sizeof(*cmd));
+	cmd->session = session;
+	cmd->cid = (uint64_t) (unsigned long) cmd;
+	INIT_LIST_HEAD(&cmd->clist);
+	INIT_LIST_HEAD(&cmd->hash_list);
 
-	dprintk("%p %llu\n", session, cmnd->cid);
+	dprintk("%p %llu\n", session, cmd->cid);
 
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
-	list_add_tail(&cmnd->hash_list, &cmnd_hash[cmnd_hashfn(cmnd->cid)]);
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+	spin_lock_irqsave(&cmd_hash_lock, flags);
+	list_add_tail(&cmd->hash_list, &cmd_hash[cmd_hashfn(cmd->cid)]);
+	spin_unlock_irqrestore(&cmd_hash_lock, flags);
 
-	return cmnd;
+	return cmd;
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_create);
+EXPORT_SYMBOL_GPL(tgt_cmd_create);
 
-static void tgt_free_buffer(struct tgt_cmnd *cmnd)
+static void tgt_free_buffer(struct tgt_cmd *cmd)
 {
 	int i;
 	
-	for (i = 0; i < cmnd->sg_count; i++)
-		__free_page(cmnd->sg[i].page);
-	kfree(cmnd->sg);
+	for (i = 0; i < cmd->sg_count; i++)
+		__free_page(cmd->sg[i].page);
+	kfree(cmd->sg);
 }
 
-void tgt_cmnd_destroy(struct tgt_cmnd *cmnd)
+void tgt_cmd_destroy(struct tgt_cmd *cmd)
 {
 	unsigned long flags;
 
-	dprintk("cid %llu\n", cmnd->cid);
+	dprintk("cid %llu\n", cmd->cid);
 
-	kfree(cmnd->sg);
+	kfree(cmd->sg);
 
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
-	list_del(&cmnd->hash_list);
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+	spin_lock_irqsave(&cmd_hash_lock, flags);
+	list_del(&cmd->hash_list);
+	spin_unlock_irqrestore(&cmd_hash_lock, flags);
 
-	mempool_free(cmnd, cmnd->session->cmnd_pool);
+	mempool_free(cmd, cmd->session->cmd_pool);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_destroy);
+EXPORT_SYMBOL_GPL(tgt_cmd_destroy);
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
@@ -593,23 +593,23 @@
  * but to support passthrough commands we will need to obey the
  * something like's tgt_sd devices's queue's limits.
  */
-void __tgt_alloc_buffer(struct tgt_cmnd *cmnd)
+void __tgt_alloc_buffer(struct tgt_cmd *cmd)
 {
-	uint64_t offset = cmnd->offset;
-	uint32_t len = cmnd->bufflen;
+	uint64_t offset = cmd->offset;
+	uint32_t len = cmd->bufflen;
 	int i;
 
-	cmnd->sg_count = pgcnt(len, offset);
+	cmd->sg_count = pgcnt(len, offset);
 	offset &= ~PAGE_CACHE_MASK;
 
-	dprintk("cid %llu pg_count %d offset %llu len %d\n", cmnd->cid,
-		cmnd->sg_count, cmnd->offset, cmnd->bufflen);
+	dprintk("cid %llu pg_count %d offset %llu len %d\n", cmd->cid,
+		cmd->sg_count, cmd->offset, cmd->bufflen);
 
-	cmnd->sg = kmalloc(cmnd->sg_count * sizeof(struct scatterlist),
+	cmd->sg = kmalloc(cmd->sg_count * sizeof(struct scatterlist),
 			   GFP_KERNEL | __GFP_NOFAIL);
 
-	for (i = 0; i < cmnd->sg_count; i++) {
-		struct scatterlist *sg = &cmnd->sg[i];
+	for (i = 0; i < cmd->sg_count; i++) {
+		struct scatterlist *sg = &cmd->sg[i];
 
 		sg->page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
 		sg->offset = offset;
@@ -622,37 +622,37 @@
 
 static void tgt_alloc_buffer(void *data)
 {
-	struct tgt_cmnd *cmnd = data;
+	struct tgt_cmd *cmd = data;
 
-	__tgt_alloc_buffer(cmnd);
+	__tgt_alloc_buffer(cmd);
 
-	if (cmnd->done) {
-		void (*done)(struct tgt_cmnd *) = cmnd->done;
-		cmnd->done = NULL;
-		done(cmnd);
+	if (cmd->done) {
+		void (*done)(struct tgt_cmd *) = cmd->done;
+		cmd->done = NULL;
+		done(cmd);
 	}
 }
 
-void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
 {
-	BUG_ON(!list_empty(&cmnd->clist));
+	BUG_ON(!list_empty(&cmd->clist));
 
 	if (done) {
-		struct tgt_session *session = cmnd->session;
+		struct tgt_session *session = cmd->session;
 
-		INIT_WORK(&cmnd->work, tgt_alloc_buffer, cmnd);
-		cmnd->done = done;
-		queue_work(session->target->twq, &cmnd->work);
+		INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
+		cmd->done = done;
+		queue_work(session->target->twq, &cmd->work);
 		return;
 	}
 
-	tgt_alloc_buffer(cmnd);
+	tgt_alloc_buffer(cmd);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_alloc_buffer);
+EXPORT_SYMBOL_GPL(tgt_cmd_alloc_buffer);
 
-int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd)
+int tgt_uspace_cmd_send(struct tgt_cmd *cmd)
 {
-	struct tgt_protocol *proto = cmnd->session->target->proto;
+	struct tgt_protocol *proto = cmd->session->target->proto;
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
@@ -665,24 +665,24 @@
 		return -ENOMEM;
 
 	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMND_REQ,
+	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMD_REQ,
 			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 
 	pdu = (char *) ev->data;
-	ev->k.cmnd_req.tid = cmnd->session->target->tid;
-	ev->k.cmnd_req.dev_id = cmnd->dev_id;
-	ev->k.cmnd_req.cid = cmnd->cid;
+	ev->k.cmd_req.tid = cmd->session->target->tid;
+	ev->k.cmd_req.dev_id = cmd->dev_id;
+	ev->k.cmd_req.cid = cmd->cid;
 
-	proto->build_uspace_pdu(cmnd, pdu);
+	proto->build_uspace_pdu(cmd, pdu);
 
 	return netlink_unicast(nls, skb, tgt_pid, 0);
 }
-EXPORT_SYMBOL_GPL(tgt_uspace_cmnd_send);
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
 /*
- * TODO we should make cmnd->done a target callback instead. Maybe
+ * TODO we should make cmd->done a target callback instead. Maybe
  * target->tt->queuecommand. We need this becuase a target driver
  * may not have the resources to execute the command. We also need
  * a real queue, I guess, and some queue limits.
@@ -692,35 +692,35 @@
  * BE ABLE TO EXECUTE FROM A SOFTIRQ SINCE WE WILL EVENTUALLY GO ALL ASYNC
  *
  */
-static void tgt_notify_cmnd_ready(void *data)
+static void tgt_notify_cmd_ready(void *data)
 {
-	struct tgt_cmnd *cmnd = data;
-	void (*done)(struct tgt_cmnd *);
+	struct tgt_cmd *cmd = data;
+	void (*done)(struct tgt_cmd *);
 
-	done = cmnd->done;
-	cmnd->done = NULL;
-	done(cmnd);
+	done = cmd->done;
+	cmd->done = NULL;
+	done(cmd);
 }
 
-void tgt_cmnd_done(struct tgt_cmnd *cmnd)
+void tgt_cmd_done(struct tgt_cmd *cmd)
 {
-	struct tgt_session *session = cmnd->session;
+	struct tgt_session *session = cmd->session;
 
-	INIT_WORK(&cmnd->work, tgt_notify_cmnd_ready, cmnd);
-	queue_work(session->target->twq, &cmnd->work);
+	INIT_WORK(&cmd->work, tgt_notify_cmd_ready, cmd);
+	queue_work(session->target->twq, &cmd->work);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_done);
+EXPORT_SYMBOL_GPL(tgt_cmd_done);
 
-static void uspace_cmnd_done(struct tgt_cmnd *cmnd, void *data,
+static void uspace_cmd_done(struct tgt_cmd *cmd, void *data,
 			     int result, uint32_t len)
 {
-	struct tgt_device *device = cmnd->device;
+	struct tgt_device *device = cmd->device;
 	char *p = data;
 	int i;
-	BUG_ON(!cmnd->done);
+	BUG_ON(!cmd->done);
 
 	dprintk("cid %llu result %d len %d bufflen %u\n",
-		cmnd->cid, result, len, cmnd->bufflen);
+		cmd->cid, result, len, cmd->bufflen);
 
 	if (len) {
 		/*
@@ -728,91 +728,91 @@
 		 * This will happen if we though we were going to do some
 		 * IO but we ended up just gettting some sense back
 		 */
-		if (len != cmnd->bufflen) {
-			tgt_free_buffer(cmnd);
+		if (len != cmd->bufflen) {
+			tgt_free_buffer(cmd);
 
-			cmnd->bufflen = len;
-			cmnd->offset = 0;
+			cmd->bufflen = len;
+			cmd->offset = 0;
 
-			__tgt_alloc_buffer(cmnd);
+			__tgt_alloc_buffer(cmd);
 		}
 
-		for (i = 0; i < cmnd->sg_count; i++) {
+		for (i = 0; i < cmd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
 
-			memcpy(page_address(cmnd->sg[i].page), p, copy);
+			memcpy(page_address(cmd->sg[i].page), p, copy);
 			p += copy;
 			len -= copy;
 		}
 	}
 
-	cmnd->result = result;
-	if (device->dt->complete_uspace_cmnd)
-		device->dt->complete_uspace_cmnd(cmnd);
-	tgt_cmnd_done(cmnd);
+	cmd->result = result;
+	if (device->dt->complete_uspace_cmd)
+		device->dt->complete_uspace_cmd(cmd);
+	tgt_cmd_done(cmd);
 }
 
 static void queuecommand(void *data)
 {
 	int err = 0;
-	struct tgt_cmnd *cmnd = data;
-	struct tgt_target *target = cmnd->session->target;
-	struct tgt_device *device = cmnd->device;
+	struct tgt_cmd *cmd = data;
+	struct tgt_target *target = cmd->session->target;
+	struct tgt_device *device = cmd->device;
 
-	dprintk("cid %llu\n", cmnd->cid);
+	dprintk("cid %llu\n", cmd->cid);
 
 	/* Should we do this earlier? */
 	if (!device)
-		cmnd->device = device = tgt_device_find(target, cmnd->dev_id);
+		cmd->device = device = tgt_device_find(target, cmd->dev_id);
 	if (device)
-		dprintk("found %llu\n", cmnd->dev_id);
+		dprintk("found %llu\n", cmd->dev_id);
 
-	err = device->dt->queue_cmnd(cmnd);
+	err = device->dt->queue_cmd(cmd);
 
 	switch (err) {
-	case TGT_CMND_FAILED:
-	case TGT_CMND_COMPLETED:
+	case TGT_CMD_FAILED:
+	case TGT_CMD_COMPLETED:
 		dprintk("command completed %d\n", err);
-		tgt_notify_cmnd_ready(cmnd);
+		tgt_notify_cmd_ready(cmd);
 	default:
-		dprintk("command %llu queued\n", cmnd->cid);
+		dprintk("command %llu queued\n", cmd->cid);
 	};
 }
 
-int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+int tgt_cmd_queue(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
 {
-	struct tgt_session *session = cmnd->session;
+	struct tgt_session *session = cmd->session;
 
-	BUG_ON(cmnd->done);
+	BUG_ON(cmd->done);
 	BUG_ON(!done);
 
-	cmnd->done = done;
-	INIT_WORK(&cmnd->work, queuecommand, cmnd);
-	queue_work(session->target->twq, &cmnd->work);
+	cmd->done = done;
+	INIT_WORK(&cmd->work, queuecommand, cmd);
+	queue_work(session->target->twq, &cmd->work);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_queue);
+EXPORT_SYMBOL_GPL(tgt_cmd_queue);
 
-static struct tgt_cmnd *find_cmnd_by_id(uint64_t cid)
+static struct tgt_cmd *find_cmd_by_id(uint64_t cid)
 {
 	struct list_head *head;
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	unsigned long flags;
 
-	head = &cmnd_hash[cmnd_hashfn(cid)];
+	head = &cmd_hash[cmd_hashfn(cid)];
 
-	spin_lock_irqsave(&cmnd_hash_lock, flags);
+	spin_lock_irqsave(&cmd_hash_lock, flags);
 
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd->cid == cid)
+	list_for_each_entry(cmd, head, hash_list) {
+		if (cmd->cid == cid)
 			goto found;
 	}
-	cmnd = NULL;
+	cmd = NULL;
 found:
-	spin_unlock_irqrestore(&cmnd_hash_lock, flags);
+	spin_unlock_irqrestore(&cmd_hash_lock, flags);
 
-	return cmnd;
+	return cmd;
 }
 
 int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
@@ -846,7 +846,7 @@
 {
 	int err = 0;
 	struct tgt_event *ev = NLMSG_DATA(nlh);
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	struct tgt_target *target;
 
 	dprintk("%d %d %d %d\n", daemon_pid, nlh->nlmsg_type,
@@ -864,7 +864,7 @@
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
-					   ev->u.c_target.nr_cmnds);
+					   ev->u.c_target.nr_cmds);
 		if (target)
 			err = target->tid;
 		else
@@ -900,14 +900,14 @@
 		err = tgt_device_destroy(ev->u.d_device.tid,
 					 ev->u.d_device.dev_id);
 		break;
-	case TGT_UEVENT_CMND_RES:
-		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
-		if (cmnd)
-			uspace_cmnd_done(cmnd, ev->data,
-					 ev->u.cmnd_res.result,
-					 ev->u.cmnd_res.len);
+	case TGT_UEVENT_CMD_RES:
+		cmd = find_cmd_by_id(ev->u.cmd_res.cid);
+		if (cmd)
+			uspace_cmd_done(cmd, ev->data,
+					 ev->u.cmd_res.result,
+					 ev->u.cmd_res.len);
 		else {
-			eprintk("cannot found %llu\n", ev->u.cmnd_res.cid);
+			eprintk("cannot found %llu\n", ev->u.cmd_res.cid);
 			err = -EEXIST;
 		}
 		break;
@@ -954,7 +954,7 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMND_RES &&
+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
 		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
 			ev->k.event_res.err = err;
 			send_event_res(NETLINK_CREDS(skb)->pid,
@@ -991,7 +991,7 @@
 	int i, err = -ENOMEM;
 
 	spin_lock_init(&all_targets_lock);
-	spin_lock_init(&cmnd_hash_lock);
+	spin_lock_init(&cmd_hash_lock);
 	spin_lock_init(&target_tmpl_lock);
 	spin_lock_init(&device_tmpl_lock);
 
@@ -1005,8 +1005,8 @@
 	if (!nls)
 		goto out;
 
-	for (i = 0; i < ARRAY_SIZE(cmnd_hash); i++)
-		INIT_LIST_HEAD(&cmnd_hash[i]);
+	for (i = 0; i < ARRAY_SIZE(cmd_hash); i++)
+		INIT_LIST_HEAD(&cmd_hash[i]);
 
 	return 0;
 out:

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -19,10 +19,10 @@
 	struct tgt_target *target;
 	struct list_head slist;
 
-	mempool_t *cmnd_pool;
+	mempool_t *cmd_pool;
 };
 
-struct tgt_cmnd {
+struct tgt_cmd {
 	struct tgt_session *session;
 	struct tgt_device *device;
 	struct tgt_protocol *proto;
@@ -32,7 +32,7 @@
 	uint64_t cid;
 
 	struct work_struct work;
-	void (*done) (struct tgt_cmnd *);
+	void (*done) (struct tgt_cmd *);
 
 	struct list_head clist;
 	struct list_head hash_list;
@@ -57,20 +57,20 @@
 
 extern struct tgt_session *
 tgt_session_create(struct tgt_target *target,
-		   int max_cmnds,
+		   int max_cmds,
 		   void (*done)(void *, struct tgt_session *), void *arg);
 extern int tgt_session_destroy(struct tgt_session *session);
 
 extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
 			unsigned int gfp_flags);
-extern int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd);
-extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session);
-extern void tgt_cmnd_destroy(struct tgt_cmnd *cmnd);
-extern void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd,
-				  void (*done)(struct tgt_cmnd *));
-extern int tgt_cmnd_queue(struct tgt_cmnd *cmnd,
-			  void (*done)(struct tgt_cmnd *));
-extern void tgt_cmnd_done(struct tgt_cmnd *cmnd);
+extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
+extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session);
+extern void tgt_cmd_destroy(struct tgt_cmd *cmd);
+extern void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd,
+				  void (*done)(struct tgt_cmd *));
+extern int tgt_cmd_queue(struct tgt_cmd *cmd,
+			  void (*done)(struct tgt_cmd *));
+extern void tgt_cmd_done(struct tgt_cmd *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 #endif

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_device.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,17 +12,17 @@
 #include <linux/list.h>
 
 struct tgt_device;
-struct tgt_cmnd;
+struct tgt_cmd;
 
 enum {
-	TGT_CMND_COMPLETED,
-	TGT_CMND_FAILED,
+	TGT_CMD_COMPLETED,
+	TGT_CMD_FAILED,
 	/*
 	 * if the device has queued the command it is responsible for
 	 * for completing it
 	 */
-	TGT_CMND_USPACE_QUEUED,
-	TGT_CMND_KERN_QUEUED
+	TGT_CMD_USPACE_QUEUED,
+	TGT_CMD_KERN_QUEUED
 };
 
 struct tgt_device_template {
@@ -36,25 +36,25 @@
 	int (* create)(struct tgt_device *);
 	void (* destroy)(struct tgt_device *);
 	/*
-	 * queue or execute command. Return TGT_CMND*.
-	 * If returning TGT_CMND_COMPLETED or TGT_CMND_FAILED the result
+	 * queue or execute command. Return TGT_CMD*.
+	 * If returning TGT_CMD_COMPLETED or TGT_CMD_FAILED the result
 	 * field must be set.
 	 */
-	int (* queue_cmnd)(struct tgt_cmnd *cmnd);
+	int (* queue_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a userspace command
 	 */
-	void ( *complete_uspace_cmnd)(struct tgt_cmnd *cmnd);
+	void ( *complete_uspace_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a kernel command if your queue_command was async
 	 * and the device used one of the tgt threads to process the
 	 * command
 	 */
-	void (*complete_kern_cmnd)(struct tgt_cmnd *cmnd);
+	void (*complete_kern_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * setup buffer or device fields if needed
 	 */
-	void (* prep_cmnd)(struct tgt_cmnd *cmnd, uint32_t data_len);
+	void (* prep_cmd)(struct tgt_cmd *cmd, uint32_t data_len);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_protocol.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,7 +12,7 @@
 #include <linux/dma-mapping.h>
 
 struct module;
-struct tgt_cmnd;
+struct tgt_cmd;
 struct tgt_session;
 
 /*
@@ -24,7 +24,7 @@
 	const char *name;
 	struct module *module;
 
-	kmem_cache_t *cmnd_cache;
+	kmem_cache_t *cmd_cache;
 	int uspace_pdu_size;
 
 	/*
@@ -37,25 +37,25 @@
 	 * iet to open-iscsi's model so eventually the done() function
 	 * will be a requirement so we can have a common path.
 	 */
-	struct tgt_cmnd *(* create_cmnd)(struct tgt_session *session,
+	struct tgt_cmd *(* create_cmd)(struct tgt_session *session,
 					uint8_t *cmd, uint32_t data_len,
 					enum dma_data_direction data_dir,
 					uint8_t *dev_id_buff, int id_buff_size,
-					void (*done)(struct tgt_cmnd *));
+					void (*done)(struct tgt_cmd *));
 	/*
 	 * destroy a command. This will free the command and buffer
 	 */
-	void (* destroy_cmnd)(struct tgt_cmnd *cmd); 
+	void (* destroy_cmd)(struct tgt_cmd *cmd); 
 	/*
 	 * queue a command to be executed in a workqueue. A done() callback
 	 * must be passed in.
 	 */
-	int (* queue_cmnd)(struct tgt_cmnd *cmnd,
-			   void (*done)(struct tgt_cmnd *));
+	int (* queue_cmd)(struct tgt_cmd *cmd,
+			   void (*done)(struct tgt_cmd *));
 	/*
 	 * build userspace packet
 	 */
-	void (* build_uspace_pdu)(struct tgt_cmnd *cmnd, void *data);
+	void (* build_uspace_pdu)(struct tgt_cmd *cmd, void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_scsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,7 +17,7 @@
 #include <tgt_device.h>
 #include <tgt_protocol.h>
 
-static kmem_cache_t *scsi_tgt_cmnd_cache;
+static kmem_cache_t *scsi_tgt_cmd_cache;
 
 /*
  * we should be able to use scsi-ml's functions for this
@@ -46,100 +46,100 @@
  * we may have to add a wrapper becuase people are passing the lun in
  * differently
  */
-static struct tgt_cmnd *
-scsi_tgt_create_cmnd(struct tgt_session *session, uint8_t *scb,
+static struct tgt_cmd *
+scsi_tgt_create_cmd(struct tgt_session *session, uint8_t *scb,
 		     uint32_t data_len, enum dma_data_direction data_dir,
 		     uint8_t *lun, int lun_size,
-		     void (*done)(struct tgt_cmnd *))
+		     void (*done)(struct tgt_cmd *))
 {
 	struct tgt_device *device;
-	struct tgt_cmnd *cmnd;
-	struct scsi_tgt_cmnd *scmnd;
+	struct tgt_cmd *cmd;
+	struct scsi_tgt_cmd *scmd;
 
-	cmnd = tgt_cmnd_create(session);
-	if (!cmnd) {
+	cmd = tgt_cmd_create(session);
+	if (!cmd) {
 		printk(KERN_ERR "Could not allocate command\n");
 		return NULL;
 	}
-	scmnd = tgt_cmnd_to_scsi(cmnd);
-	memcpy(scmnd->scb, scb, sizeof(scmnd->scb));
+	scmd = tgt_cmd_to_scsi(cmd);
+	memcpy(scmd->scb, scb, sizeof(scmd->scb));
 
 	/* translate target driver LUN to device id */
-	cmnd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
-	device = tgt_device_find(session->target, cmnd->dev_id);
+	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
+	device = tgt_device_find(session->target, cmd->dev_id);
 	if (!device) {
 		printk(KERN_ERR "Could not find device if %llu\n",
-		       cmnd->dev_id);
+		       cmd->dev_id);
 		return NULL;
 	}
-	cmnd->device = device;
+	cmd->device = device;
 
 	/* is this device specific */
-	cmnd->data_dir = data_dir;
+	cmd->data_dir = data_dir;
 	/*
 	 * set bufflen based on data_len for now, but let device specific
 	 * handler overide just in case
 	 */
-	cmnd->bufflen = data_len;
+	cmd->bufflen = data_len;
 	/* do scsi device specific setup */
-	device->dt->prep_cmnd(cmnd, data_len);
-	if (cmnd->bufflen)
-		tgt_cmnd_alloc_buffer(cmnd, done);
-	return cmnd;
+	device->dt->prep_cmd(cmd, data_len);
+	if (cmd->bufflen)
+		tgt_cmd_alloc_buffer(cmd, done);
+	return cmd;
 }
 
 /* kspace command failure */
-int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 			      uint8_t ascode, uint8_t ascodeq)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	int len = 8, alen = 6;
-	uint8_t *data = scmnd->sense_buff;
+	uint8_t *data = scmd->sense_buff;
 
-	memset(data, 0, sizeof(scmnd->sense_buff));
+	memset(data, 0, sizeof(scmd->sense_buff));
 
 	data[0] = 0x70 | 1U << 7;
 	data[2] = key;
 	data[7] = alen;
 	data[12] = ascode;
 	data[13] = ascodeq;
-	cmnd->result = SAM_STAT_CHECK_CONDITION;
-	scmnd->sense_len = len + alen;
+	cmd->result = SAM_STAT_CHECK_CONDITION;
+	scmd->sense_len = len + alen;
 
 	return len + alen;
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_data_build);
 
 /* uspace command failure */
-int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd)
+int scsi_tgt_sense_copy(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *data = scmnd->sense_buff;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *data = scmd->sense_buff;
 	int len;
 
-	memset(data, 0, sizeof(scmnd->sense_buff));
-	len = min(cmnd->bufflen, sizeof(scmnd->sense_buff));
+	memset(data, 0, sizeof(scmd->sense_buff));
+	len = min(cmd->bufflen, sizeof(scmd->sense_buff));
 
 	/* userspace did everything for us */
-	memcpy(data, page_address(cmnd->sg[0].page), len);
-	scmnd->sense_len = len;
+	memcpy(data, page_address(cmd->sg[0].page), len);
+	scmd->sense_len = len;
 
 	return len;
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
+void scsi_tgt_build_uspace_pdu(struct tgt_cmd *cmd, void *data)
 {
-	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd->proto_priv;
-	memcpy(data, scmnd->scb, sizeof(scmnd->scb));
+	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
+	memcpy(data, scmd->scb, sizeof(scmd->scb));
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
-	.create_cmnd = scsi_tgt_create_cmnd,
-	.destroy_cmnd = tgt_cmnd_destroy,
-	.queue_cmnd = tgt_cmnd_queue,
+	.create_cmd = scsi_tgt_create_cmd,
+	.destroy_cmd = tgt_cmd_destroy,
+	.queue_cmd = tgt_cmd_queue,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
@@ -148,23 +148,23 @@
 {
 	int err;
 
-	scsi_tgt_cmnd_cache = kmem_cache_create("scsi_tgt_cmnd",
-			sizeof(struct tgt_cmnd) + sizeof(struct scsi_tgt_cmnd),
+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
+			sizeof(struct tgt_cmd) + sizeof(struct scsi_tgt_cmd),
 			0, SLAB_HWCACHE_ALIGN | SLAB_NO_REAP, NULL, NULL);
-	if (!scsi_tgt_cmnd_cache)
+	if (!scsi_tgt_cmd_cache)
 		return -ENOMEM;
-	scsi_tgt_proto.cmnd_cache = scsi_tgt_cmnd_cache;
+	scsi_tgt_proto.cmd_cache = scsi_tgt_cmd_cache;
 
 	err = tgt_protocol_register(&scsi_tgt_proto);
 	if (err)
-		kmem_cache_destroy(scsi_tgt_cmnd_cache);
+		kmem_cache_destroy(scsi_tgt_cmd_cache);
 
 	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
-	kmem_cache_destroy(scsi_tgt_cmnd_cache);
+	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	tgt_protocol_unregister(&scsi_tgt_proto);
 }
 

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_scsi.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,19 +12,19 @@
 #include <tgt.h>
 #include <scsi/scsi_cmnd.h>
 
-struct scsi_tgt_cmnd {
+struct scsi_tgt_cmd {
 	uint8_t scb[MAX_COMMAND_SIZE];
 	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
 	int sense_len;
 	int tags;
 };
 
-static inline struct scsi_tgt_cmnd *tgt_cmnd_to_scsi(struct tgt_cmnd *cmnd)
+static inline struct scsi_tgt_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)
 {
-	return (struct scsi_tgt_cmnd *) cmnd->proto_priv;
+	return (struct scsi_tgt_cmd *) cmd->proto_priv;
 }
 
-extern int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd);
-extern int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
+extern int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 				     uint8_t ascode, uint8_t ascodeq);
 #endif

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_sd.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -43,10 +43,10 @@
 	return 0;
 }
 
-static void tgt_sd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
+static void tgt_sd_prep(struct tgt_cmd *cmd, uint32_t data_len)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *scb = scmnd->scb;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *scb = scmd->scb;
 	uint64_t off = 0;
 
 	/*
@@ -75,29 +75,29 @@
 	/*
 	 * we trust the data_len passed in for now
 	 */
-	cmnd->bufflen = data_len;
-	cmnd->offset = off;
+	cmd->bufflen = data_len;
+	cmd->offset = off;
 }
 
 static void tgt_sd_end_rq(struct request *rq)
 {
-	struct tgt_cmnd *cmnd = rq->end_io_data;
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct tgt_cmd *cmd = rq->end_io_data;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
 	if (rq->sense_len) {
-		memcpy(scmnd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);
-		cmnd->result = SAM_STAT_CHECK_CONDITION;
+		memcpy(scmd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);
+		cmd->result = SAM_STAT_CHECK_CONDITION;
 	} else if (rq->errors) {
 		/*
 		 * TODO check *_byte and just send error upwards
 		 */
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		cmnd->result = SAM_STAT_CHECK_CONDITION;
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		cmd->result = SAM_STAT_CHECK_CONDITION;
 	} else
-		cmnd->result = SAM_STAT_GOOD;
+		cmd->result = SAM_STAT_GOOD;
 
 
-	tgt_cmnd_done(cmnd);
+	tgt_cmd_done(cmd);
 	__blk_put_request(rq->q, rq);
 }
 
@@ -193,27 +193,27 @@
 /*
  * TODO part of this will move to a io_handler callout
  */
-static int tgt_sd_queue_rq(struct tgt_cmnd *cmnd)
+static int tgt_sd_queue_rq(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	struct file *file = cmnd->device->file;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct file *file = cmd->device->file;
 	request_queue_t *q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
 	struct request *rq;
-	int write = (cmnd->data_dir == DMA_TO_DEVICE);
+	int write = (cmd->data_dir == DMA_TO_DEVICE);
 
 	rq = blk_get_request(q, write, GFP_KERNEL | __GFP_NOFAIL);
 	if (!rq)
 		goto hw_error;
 
-	if (req_map_sg(q, rq, cmnd->sg, cmnd->sg_count,
+	if (req_map_sg(q, rq, cmd->sg, cmd->sg_count,
 			GFP_KERNEL | __GFP_NOFAIL))
 		goto free_request;
 
-	rq->cmd_len = COMMAND_SIZE(scmnd->scb[0]);
-	memcpy(rq->cmd, scmnd->scb, rq->cmd_len);
+	rq->cmd_len = COMMAND_SIZE(scmd->scb[0]);
+	memcpy(rq->cmd, scmd->scb, rq->cmd_len);
 	rq->sense_len = 0;
-	rq->sense = scmnd->sense_buff;
-	rq->end_io_data = cmnd;
+	rq->sense = scmd->sense_buff;
+	rq->end_io_data = cmd;
 	rq->timeout = 60 * HZ; /* TODO */
 	rq->flags |= REQ_BLOCK_PC;
 
@@ -223,32 +223,32 @@
  free_request:
 	blk_put_request(rq);
  hw_error:
-	scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
 	return -ENOMEM;
 }
 
-static int tgt_sd_queue(struct tgt_cmnd *cmnd)
+static int tgt_sd_queue(struct tgt_cmd *cmd)
 {
-	struct tgt_device *device = cmnd->device;
-	loff_t pos = cmnd->offset;
+	struct tgt_device *device = cmd->device;
+	loff_t pos = cmd->offset;
 
-	if (cmnd->bufflen + pos > device->size) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (cmd->bufflen + pos > device->size) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	}
 	/*
-	 * TODO this will become device->io_handler->queue_cmnd
+	 * TODO this will become device->io_handler->queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	return tgt_sd_queue_rq(cmnd) ? TGT_CMND_FAILED : TGT_CMND_KERN_QUEUED;
+	return tgt_sd_queue_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
 }
 
 static struct tgt_device_template tgt_sd = {
 	.name = "tgt_sd",
 	.module = THIS_MODULE,
 	.create = tgt_sd_create,
-	.queue_cmnd = tgt_sd_queue,
-	.prep_cmnd = tgt_sd_prep,
+	.queue_cmd = tgt_sd_queue,
+	.prep_cmd = tgt_sd_prep,
 };
 
 static int __init tgt_sd_init(void)

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_sysfs.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -35,12 +35,12 @@
 	tgt_target_template_show_fn(field, format_string)		\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
-tgt_target_rd_attr(queued_cmnds, "%u\n");
+tgt_target_rd_attr(queued_cmds, "%u\n");
 tgt_target_template_rd_attr(name, "%s\n");
 tgt_target_template_rd_attr(protocol, "%s\n");
 
 static struct class_device_attribute *tgt_target_attrs[] = {
-	&class_device_attr_queued_cmnds,
+	&class_device_attr_queued_cmds,
 	&class_device_attr_name,
 	&class_device_attr_protocol,
 	NULL

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_target.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -41,7 +41,7 @@
 
 	struct class_device cdev;
 
-	int queued_cmnds;
+	int queued_cmds;
 
 	/* Protects session_list, work_list, device_list */
 	spinlock_t lock;
@@ -58,7 +58,7 @@
 #define cdev_to_tgt_target(cdev) \
 	container_of(cdev, struct tgt_target, cdev)
 
-extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmnds);
+extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds);
 extern int tgt_target_destroy(struct tgt_target *target);
 extern int tgt_sysfs_register_target(struct tgt_target *target);
 extern void tgt_sysfs_unregister_target(struct tgt_target *target);

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_vsd.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -40,10 +40,10 @@
 /*
  * is this device specific or common? Should it be moved to the protocol.
  */
-static void tgt_vsd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
+static void tgt_vsd_prep(struct tgt_cmd *cmd, uint32_t data_len)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *scb = scmnd->scb;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *scb = scmd->scb;
 	uint64_t off = 0;
 /*	uint32_t len = 0; */
 
@@ -79,15 +79,15 @@
 	/*
 	 * we trust the data_len passed in for now
 	 */
-	cmnd->bufflen = data_len;
-	cmnd->offset = off;
+	cmd->bufflen = data_len;
+	cmd->offset = off;
 }
 
-static void tgt_vsd_uspace_complete(struct tgt_cmnd *cmnd)
+static void tgt_vsd_uspace_complete(struct tgt_cmd *cmd)
 {
 	/* userspace did everything for us just copy the buffer */
-	if (cmnd->result != SAM_STAT_GOOD)
-		scsi_tgt_sense_copy(cmnd);
+	if (cmd->result != SAM_STAT_GOOD)
+		scsi_tgt_sense_copy(cmd);
 }
 
 /*
@@ -114,45 +114,45 @@
 /*
  * TODO this will move to a io_handler callout
  */
-static int vsd_queue_file_io(struct tgt_cmnd *cmnd, int op)
+static int vsd_queue_file_io(struct tgt_cmd *cmd, int op)
 {
-	struct file *file = cmnd->device->file;
+	struct file *file = cmd->device->file;
 	ssize_t size;
 	struct iovec *iov;
-	loff_t pos = cmnd->offset;
+	loff_t pos = cmd->offset;
 
-	iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+	iov = sg_to_iovec(cmd->sg, cmd->sg_count);
 	if (!iov)
 		return -ENOMEM;
 
 	if (op == READ)
-		size = generic_file_readv(file, iov, cmnd->sg_count, &pos);
+		size = generic_file_readv(file, iov, cmd->sg_count, &pos);
 	else
-		size = generic_file_writev(file, iov, cmnd->sg_count, &pos);
+		size = generic_file_writev(file, iov, cmd->sg_count, &pos);
 
 	kfree(iov);
 
 /* not yet used
 	if (sync)
 		err = sync_page_range(inode, inode->i_mapping, pos,
-				      (size_t) cmnd->bufflen);
+				      (size_t) cmd->bufflen);
 */
 	return size;
 }
 
-static int tgt_vsd_queue(struct tgt_cmnd *cmnd)
+static int tgt_vsd_queue(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	struct tgt_device *device = cmnd->device;
-	loff_t pos = cmnd->offset;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct tgt_device *device = cmd->device;
+	loff_t pos = cmd->offset;
 	int err = 0, rw;
 
-	if (cmnd->bufflen + pos > device->size) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (cmd->bufflen + pos > device->size) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	}
 
-	switch (scmnd->scb[0]) {
+	switch (scmd->scb[0]) {
 	case READ_6:
 	case READ_10:
 	case READ_16:
@@ -165,32 +165,32 @@
 		rw = WRITE;
 		break;
 	default:
-		err = tgt_uspace_cmnd_send(cmnd);
+		err = tgt_uspace_cmd_send(cmd);
 		/*
 		 * successfully queued
 		 */
 		if (err >= 0)
-			return TGT_CMND_USPACE_QUEUED;
+			return TGT_CMD_USPACE_QUEUED;
 
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	};
 
 	/*
-	 * TODO this will become device->io_handler->queue_cmnd
+	 * TODO this will become device->io_handler->queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	err = vsd_queue_file_io(cmnd, rw);
+	err = vsd_queue_file_io(cmd, rw);
 	/*
 	 * we should to a switch but I am not sure of all the err values
 	 * returned. If you find one add it
 	 */
-	if (err != cmnd->bufflen) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (err != cmd->bufflen) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	} else {
-		cmnd->result = SAM_STAT_GOOD;
-		return TGT_CMND_COMPLETED;
+		cmd->result = SAM_STAT_GOOD;
+		return TGT_CMD_COMPLETED;
 	}
 }
 
@@ -198,9 +198,9 @@
 	.name = "tgt_vsd",
 	.module = THIS_MODULE,
 	.create = tgt_vsd_create,
-	.queue_cmnd = tgt_vsd_queue,
-	.prep_cmnd = tgt_vsd_prep,
-	.complete_uspace_cmnd = tgt_vsd_uspace_complete,
+	.queue_cmd = tgt_vsd_queue,
+	.prep_cmd = tgt_vsd_prep,
+	.complete_uspace_cmd = tgt_vsd_uspace_complete,
 };
 
 static int __init tgt_vsd_init(void)

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/ipc.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -78,9 +78,9 @@
 		goto out;
 	data = NLMSG_DATA(nlh);
 
-	err = nl_cmnd_call(nl_fd, nlh->nlmsg_type, data,
-			   nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
-			   &res);
+	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, data,
+			  nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
+			  &res);
 
 	dprintf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, res);
 

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/netlink.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -74,7 +74,7 @@
 	return rc;
 }
 
-int nl_cmnd_call(int fd, int type, char *data, int size, int *res)
+int nl_cmd_call(int fd, int type, char *data, int size, int *res)
 {
 	int err;
 	struct tgt_event *ev;
@@ -92,12 +92,12 @@
 	return err;
 }
 
-static int cmnd_queue(int fd, char *reqbuf, char *resbuf)
+static int cmd_queue(int fd, char *reqbuf, char *resbuf)
 {
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t cid = ev_req->k.cmnd_req.cid;
+	uint64_t cid = ev_req->k.cmd_req.cid;
 	uint8_t *scb;
 
 	memset(resbuf, 0, NL_BUFSIZE);
@@ -105,22 +105,22 @@
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
 	/*
-	 * TODO match tid to protocol and route cmnd to correct userspace
+	 * TODO match tid to protocol and route cmd to correct userspace
 	 * protocol module
 	 */
-	result = scsi_cmnd_process(ev_req->k.cmnd_req.tid,
-				   ev_req->k.cmnd_req.dev_id, scb,
+	result = scsi_cmd_process(ev_req->k.cmd_req.tid,
+				   ev_req->k.cmd_req.dev_id, scb,
 				   (uint8_t *) ev_res->data, &len);
 
 	memset(ev_res, 0, sizeof(*ev_res));
-	ev_res->u.cmnd_res.cid = cid;
-	ev_res->u.cmnd_res.len = len;
-	ev_res->u.cmnd_res.result = result;
+	ev_res->u.cmd_res.cid = cid;
+	ev_res->u.cmd_res.len = len;
+	ev_res->u.cmd_res.result = result;
 
 
-	log_error("scsi_cmnd_process res %d len %d\n", result, len);
+	log_error("scsi_cmd_process res %d len %d\n", result, len);
 
-	return nl_write(fd, TGT_UEVENT_CMND_RES, resbuf,
+	return nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
 			NLMSG_SPACE(sizeof(*ev_res) + len));
 }
 
@@ -158,8 +158,8 @@
 	}
 
 	switch (nlh->nlmsg_type) {
-	case TGT_KEVENT_CMND_REQ:
-		cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
+	case TGT_KEVENT_CMD_REQ:
+		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	default:
 		/* kernel module bug */
@@ -174,7 +174,7 @@
 	int err, res;
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
-	err = nl_cmnd_call(fd, TGT_UEVENT_START, nlmsg, 
+	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg, 
 			   NLMSG_SPACE(sizeof(struct tgt_event)), &res);
 	if (err < 0 || res < 0) {
 		eprintf("%d %d\n", err, res);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/scsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -492,7 +492,7 @@
 	return SAM_STAT_GOOD;
 }
 
-int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_GOOD;
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/tgtd.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,12 +17,12 @@
 
 extern int nl_open(void);
 extern void nl_event_handle(int fd);
-extern int nl_cmnd_call(int fd, int type, char *data, int size, int *res);
+extern int nl_cmd_call(int fd, int type, char *data, int size, int *res);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-extern int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb,
-			     uint8_t *data, int *len);
+extern int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb,
+			    uint8_t *data, int *len);
 
 #endif



From mnc at berlios.de  Sat Sep 24 07:32:16 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Sat, 24 Sep 2005 07:32:16 +0200
Subject: [Stgt-svn] r95 - in trunk: iscsi/kernel kernel
Message-ID: <200509240532.j8O5WGvx007614@sheep.berlios.de>

Author: mnc
Date: 2005-09-24 07:32:09 +0200 (Sat, 24 Sep 2005)
New Revision: 95

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
Log:
pass in tgt private cmd data so we can have it in the done callback

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-24 00:30:13 UTC (rev 94)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 05:32:09 UTC (rev 95)
@@ -759,8 +759,6 @@
 		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
  
 		set_cmnd_waitio(cmnd);
-		cmnd->tc->private = cmnd;
-
 		proto->queue_cmd(cmnd->tc, scsi_cmnd_done);
 	}
 }
@@ -860,7 +858,7 @@
 	else
 		data_dir = DMA_NONE;
 
-	req->tc = proto->create_cmd(conn->session->ts, req_hdr->cdb,
+	req->tc = proto->create_cmd(conn->session->ts, req, req_hdr->cdb,
 				    be32_to_cpu(req_hdr->data_length),
 				    data_dir, req_hdr->lun,
 				    sizeof(req_hdr->lun), NULL);

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 00:30:13 UTC (rev 94)
+++ trunk/kernel/tgt.c	2005-09-24 05:32:09 UTC (rev 95)
@@ -534,7 +534,7 @@
 	return 0;
 }
 
-struct tgt_cmd *tgt_cmd_create(struct tgt_session *session)
+struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *tgt_priv)
 {
 	struct tgt_cmd *cmd;
 	unsigned long flags;
@@ -548,6 +548,7 @@
 	memset(cmd, 0, sizeof(*cmd));
 	cmd->session = session;
 	cmd->cid = (uint64_t) (unsigned long) cmd;
+	cmd->private = tgt_priv;
 	INIT_LIST_HEAD(&cmd->clist);
 	INIT_LIST_HEAD(&cmd->hash_list);
 

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-24 00:30:13 UTC (rev 94)
+++ trunk/kernel/tgt.h	2005-09-24 05:32:09 UTC (rev 95)
@@ -64,7 +64,7 @@
 extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
 			unsigned int gfp_flags);
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
-extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session);
+extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *priv);
 extern void tgt_cmd_destroy(struct tgt_cmd *cmd);
 extern void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd,
 				  void (*done)(struct tgt_cmd *));

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-24 00:30:13 UTC (rev 94)
+++ trunk/kernel/tgt_protocol.h	2005-09-24 05:32:09 UTC (rev 95)
@@ -38,7 +38,8 @@
 	 * will be a requirement so we can have a common path.
 	 */
 	struct tgt_cmd *(* create_cmd)(struct tgt_session *session,
-					uint8_t *cmd, uint32_t data_len,
+					void *tgt_priv, uint8_t *cmd,
+					uint32_t data_len,
 					enum dma_data_direction data_dir,
 					uint8_t *dev_id_buff, int id_buff_size,
 					void (*done)(struct tgt_cmd *));

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-24 00:30:13 UTC (rev 94)
+++ trunk/kernel/tgt_scsi.c	2005-09-24 05:32:09 UTC (rev 95)
@@ -47,7 +47,7 @@
  * differently
  */
 static struct tgt_cmd *
-scsi_tgt_create_cmd(struct tgt_session *session, uint8_t *scb,
+scsi_tgt_create_cmd(struct tgt_session *session, void *tgt_priv, uint8_t *scb,
 		     uint32_t data_len, enum dma_data_direction data_dir,
 		     uint8_t *lun, int lun_size,
 		     void (*done)(struct tgt_cmd *))
@@ -56,7 +56,7 @@
 	struct tgt_cmd *cmd;
 	struct scsi_tgt_cmd *scmd;
 
-	cmd = tgt_cmd_create(session);
+	cmd = tgt_cmd_create(session, tgt_priv);
 	if (!cmd) {
 		printk(KERN_ERR "Could not allocate command\n");
 		return NULL;



From tomo at berlios.de  Sat Sep 24 10:32:57 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 24 Sep 2005 10:32:57 +0200
Subject: [Stgt-svn] r96 - in trunk: . include iscsi/include iscsi/kernel iscsi/usr kernel usr
Message-ID: <200509240832.j8O8WvhX020159@sheep.berlios.de>

Author: tomo
Date: 2005-09-24 10:32:55 +0200 (Sat, 24 Sep 2005)
New Revision: 96

Added:
   trunk/iscsi/usr/istgt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Removed:
   trunk/iscsi/usr/event.c
   trunk/iscsi/usr/ietadm.c
   trunk/iscsi/usr/ietadm.h
   trunk/iscsi/usr/ietd.c
   trunk/iscsi/usr/log.c
   trunk/iscsi/usr/message.c
   trunk/iscsi/usr/plain.c
Modified:
   trunk/Makefile
   trunk/include/tgt_if.h
   trunk/initd
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/Makefile
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/nthread.c
   trunk/iscsi/usr/Makefile
   trunk/iscsi/usr/chap.c
   trunk/iscsi/usr/config.h
   trunk/iscsi/usr/conn.c
   trunk/iscsi/usr/ctldev.c
   trunk/iscsi/usr/iscsid.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/session.c
   trunk/iscsi/usr/target.c
   trunk/kernel/tgt.c
   trunk/usr/Makefile
   trunk/usr/ipc.c
   trunk/usr/log.h
   trunk/usr/netlink.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Merged the daemons. There is huge room for further improvement (maybe we need to redesign the iSCSI target code). The current iSCSI code does not support authentication or changing iSCSI parameters.


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/Makefile	2005-09-24 08:32:55 UTC (rev 96)
@@ -7,10 +7,10 @@
 export KERNELSRC
 
 all:
+	make -C iscsi
+
 	make -C usr
 	make -C kernel
-
-	make -C iscsi
 clean:
 	make -C usr clean
 	make -C kernel clean

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/include/tgt_if.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -7,8 +7,6 @@
 #ifndef TARGET_FRAMEWORK_IF_H
 #define TARGET_FRAMEWORK_IF_H
 
-#define TGT_IPC_NAMESPACE "TGT_IPC_ABSTRACT_NAMESPACE"
-
 enum tgt_event_type {
 	/* user -> kernel */
 	TGT_UEVENT_START,

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/initd	2005-09-24 08:32:55 UTC (rev 96)
@@ -12,17 +12,16 @@
 	insmod ${PWD}/kernel/tgt_scsi.ko
 	insmod ${PWD}/kernel/tgt_vsd.ko
 #	insmod ${PWD}/kernel/tgt_sd.ko
-	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
 	insmod ${PWD}/iscsi/kernel/iscsi_trgt.ko
-	${PWD}/iscsi/usr/ietd
+
+	${PWD}/usr/tgtd
 }
 	
 stop_server()
 {
-	${PWD}/iscsi/usr/ietadm --op delete
-	killall -9 ietd
+	${PWD}/usr/tgtadm --op delete
 	killall -9 tgtd
 
 	rmmod iscsi_trgt

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/include/iet_u.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -85,20 +85,7 @@
 	E_CONN_CLOSE,
 };
 
-struct iet_event {
-	u32 tid;
-	u64 sid;
-	u32 cid;
-	u32 state;
-};
-
 /*
- * TODO: merge iet_msg with iet_event
- *
- * the info msgs/ioctls can be done in sysfs the event
- * could be moved too
- */
-/*
  * msg types
  */
 enum {

Modified: trunk/iscsi/kernel/Makefile
===================================================================
--- trunk/iscsi/kernel/Makefile	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/kernel/Makefile	2005-09-24 08:32:55 UTC (rev 96)
@@ -12,7 +12,7 @@
 ifneq ($(KERNELRELEASE),)
 obj-m		+= iscsi_trgt.o
 iscsi_trgt-objs	:= iscsi.o nthread.o config.o digest.o\
-			conn.o session.o target.o event.o param.o
+			conn.o session.o target.o param.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/kernel/config.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -136,3 +136,15 @@
 	tgt_msg_send(tgt, msg, sizeof(*msg), GFP_KERNEL);
 	return err;
 }
+
+int event_send(struct tgt_target *tgt, u32 tid, u64 sid, u32 cid, u32 state)
+{
+	struct iet_msg msg;
+
+	msg.k.conn_state_change.tid = tid;
+	msg.k.conn_state_change.sid = sid;
+	msg.k.conn_state_change.cid = cid;
+	msg.k.conn_state_change.state = state;
+
+	return tgt_msg_send(tgt, &msg, sizeof(msg), GFP_ATOMIC);
+}

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1595,8 +1595,6 @@
 {
 	iet_procfs_exit();
 
-	event_exit();
-
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
 
@@ -1612,9 +1610,6 @@
 	if ((err = iet_procfs_init()) < 0)
 		goto err;
 
-	if ((err = event_init()) < 0)
-		goto err;
-
 	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
 					     0, 0, NULL, NULL);
 	if (!iscsi_cmnd_cache)

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -235,6 +235,7 @@
 extern int iet_procfs_init(void);
 extern void iet_procfs_exit(void);
 extern int iet_info_show(struct seq_file *, iet_show_info_t *);
+extern int event_send(struct tgt_target *tgt, u32 tid, u64 sid, u32 cid, u32 state);
 
 /* session.c */
 extern struct file_operations session_seq_fops;
@@ -245,18 +246,6 @@
 /* params.c */
 extern int iscsi_param_set(struct iscsi_target *, struct iscsi_param_info *, int);
 
-/* extern int tio_init(void); */
-/* extern void tio_exit(void); */
-/* extern struct tio *tio_alloc(int); */
-/* extern void tio_get(struct tio *); */
-/* extern void tio_put(struct tio *); */
-/* extern void tio_set(struct tio *, u32, loff_t); */
-
-/* event.c */
-extern int event_send(u32, u64, u32, u32, int);
-extern int event_init(void);
-extern void event_exit(void);
-
 #define get_pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
 static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)

Modified: trunk/iscsi/kernel/nthread.c
===================================================================
--- trunk/iscsi/kernel/nthread.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/kernel/nthread.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -607,7 +607,10 @@
 		assert(0);
 	}
 
-	event_send(session->target->tid, session->sid, conn->cid, E_CONN_CLOSE, 0);
+	eprintk("%d %llu %u\n", session->target->tid, session->sid, conn->cid);
+
+	event_send(session->target->tt, session->target->tid,
+		   session->sid, conn->cid, E_CONN_CLOSE);
 	conn_free(conn);
 
 	if (list_empty(&session->conn_list))

Modified: trunk/iscsi/usr/Makefile
===================================================================
--- trunk/iscsi/usr/Makefile	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/Makefile	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,15 +1,10 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include -I../../include -DNETLINK_TGT=20
-PROGRAMS = ietd ietadm
-LIBS = -lcrypto
+CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I../include -I../../include -I../../usr
+#LIBS = -lcrypto
+OBJS = istgt.o conn.o param.o iscsid.o session.o target.o chap.o ctldev.o
+SHAREDLIB = istgt.so
 
-all: $(PROGRAMS)
+$(SHAREDLIB): $(OBJS)
+	$(CC) -shared -o $@ $(OBJS)
 
-ietd: ietd.o iscsid.o conn.o session.o target.o message.o ctldev.o log.o chap.o event.o param.o plain.o
-
-	$(CC) $^ -o $@ $(LIBS)
-
-ietadm: ietadm.o param.o
-	$(CC) $^ -o $@
-
 clean:
-	rm -f *.o $(PROGRAMS)
+	rm -f *.o $(PROGRAMS) $(SHAREDLIB)

Modified: trunk/iscsi/usr/chap.c
===================================================================
--- trunk/iscsi/usr/chap.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/chap.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -381,12 +381,12 @@
 	char pass[ISCSI_NAME_LEN];
 
 	memset(pass, 0, sizeof(pass));
-	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, pass, pass) < 0) {
-		log_warning("CHAP initiator auth.: "
-			    "No CHAP credentials configured");
-		retval = CHAP_TARGET_ERROR;
-		goto out;
-	}
+/* 	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, pass, pass) < 0) { */
+/* 		log_warning("CHAP initiator auth.: " */
+/* 			    "No CHAP credentials configured"); */
+/* 		retval = CHAP_TARGET_ERROR; */
+/* 		goto out; */
+/* 	} */
 
 	if (!(value = text_key_find(conn, "CHAP_N"))) {
 		retval = CHAP_INITIATOR_ERROR;
@@ -394,13 +394,13 @@
 	}
 
 	memset(pass, 0, sizeof(pass));
-	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, value, pass) < 0) {
-		log_warning("CHAP initiator auth.: "
-			    "No valid user/pass combination for initiator %s "
-			    "found", conn->initiator);
-		retval = CHAP_AUTH_ERROR;
-		goto out;
-	}
+/* 	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, value, pass) < 0) { */
+/* 		log_warning("CHAP initiator auth.: " */
+/* 			    "No valid user/pass combination for initiator %s " */
+/* 			    "found", conn->initiator); */
+/* 		retval = CHAP_AUTH_ERROR; */
+/* 		goto out; */
+/* 	} */
 
 	if (!(value = text_key_find(conn, "CHAP_R"))) {
 		retval = CHAP_INITIATOR_ERROR;
@@ -491,13 +491,13 @@
 
 	memset(pass, 0, sizeof(pass));
 	memset(name, 0, sizeof(name));
-	if (cops->account_query(conn->tid, AUTH_DIR_OUTGOING, name, pass) < 0) {
-		log_warning("CHAP target auth.: "
-			    "no outgoing credentials configured%s",
-			    conn->tid ? "." : " for discovery.");
-		retval = CHAP_AUTH_ERROR;
-		goto out;
-	}
+/* 	if (cops->account_query(conn->tid, AUTH_DIR_OUTGOING, name, pass) < 0) { */
+/* 		log_warning("CHAP target auth.: " */
+/* 			    "no outgoing credentials configured%s", */
+/* 			    conn->tid ? "." : " for discovery."); */
+/* 		retval = CHAP_AUTH_ERROR; */
+/* 		goto out; */
+/* 	} */
 
 	if (!(value = text_key_find(conn, "CHAP_C"))) {
 		log_warning("CHAP target auth.: "

Modified: trunk/iscsi/usr/config.h
===================================================================
--- trunk/iscsi/usr/config.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/config.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -3,13 +3,13 @@
 
 struct config_operations {
 	int (*init) (char *);
-	int (*target_add) (u32 *, char *);
-	int (*target_stop) (u32);
-	int (*target_del) (u32);
-	int (*lunit_add) (u32, u32, char *);
-	int (*lunit_stop) (u32, u32);
-	int (*lunit_del) (u32, u32);
-	int (*param_set) (u32, u64, int, u32, struct iscsi_param *);
+/* 	int (*target_add) (u32 *, char *); */
+/* 	int (*target_stop) (u32); */
+/* 	int (*target_del) (u32); */
+/* 	int (*lunit_add) (u32, u32, char *); */
+/* 	int (*lunit_stop) (u32, u32); */
+/* 	int (*lunit_del) (u32, u32); */
+/* 	int (*param_set) (u32, u64, int, u32, struct iscsi_param *); */
 	int (*account_add) (u32, int, char *, char *);
 	int (*account_del) (u32, int, char *);
 	int (*account_query) (u32, int, char *, char *);

Modified: trunk/iscsi/usr/conn.c
===================================================================
--- trunk/iscsi/usr/conn.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/conn.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -106,7 +106,7 @@
 	int err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
-	log_debug(1, "conn_take_fd: %d %u %u %u %" PRIx64,
+	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
 		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/ctldev.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -17,66 +17,32 @@
 #include <sys/stat.h>
 #include <sys/socket.h>
 #include <sys/un.h>
-#include <asm/fcntl.h>
+#include <fcntl.h>
 #include <linux/netlink.h>
 
 #include "iscsid.h"
 #include "tgt_if.h"
+#include "tgtadm.h"
 
-/*
- * tomo:
- * netlink code is temporary until ietd will be integrated to stgtd
- */
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0100000
+#endif
 
-extern int ctrl_fd;
+extern int nl_fd;
+extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
 
-struct session_file_operations {
-	int (*target_op) (int fd, u32 tid, void *arg);
-	int (*session_op) (int fd, u32 tid, u64 sid, void *arg);
-	int (*connection_op) (int fd, u32 tid, u64 sid, u32 cid, void *arg);
-};
-
-/* Temporary stgt glue */
-
 static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
 {
-	int fd, err;
-	struct sockaddr_nl addr;
+	int err;
+	char rbuf[8192];
 	struct nlmsghdr *nlm_recv;
 	struct tgt_event *ev;
 	struct iet_msg *msg;
 
-	nlm_recv = calloc(1, len);
-	if (!nlm_recv)
-		return -ENOMEM;
+	err = nl_cmd_call(nl_fd, nlm_send->nlmsg_type,
+			  (char *) nlm_send, len, rbuf);
 
-	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd < 0) {
-		log_error("Could not create socket %d %d\n", fd, errno);
-		err = fd;
-		goto free_nlm;
-	}
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
-	addr.nl_pid = 0;
-	addr.nl_groups = 0;
-
-	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0) {
-		log_error("Could not connect %d %d\n", err, errno);
-		goto close;
-	}
-
-	err = write(fd, nlm_send, len);
-	if (err < 0) {
-		log_error("sendmsg failed %d %d\n", err, errno);
-		goto close;
-	}
-
-	err = read(fd, nlm_recv, len);
-	if (err < 0)
-		goto close;
-
+	nlm_recv = (struct nlmsghdr *) rbuf;
 	ev = NLMSG_DATA(nlm_recv);
 	switch (nlm_recv->nlmsg_type) {
 		case TGT_KEVENT_TARGET_PASSTHRU:
@@ -87,14 +53,34 @@
 			err = ev->k.event_res.err;
 	}
 
-close:
-	if (fd >= 0)
-		close(fd);
-free_nlm:
-	free(nlm_recv);
 	return err;
 }
 
+void async_event(char *data)
+{
+	struct tgt_event *ev = (struct tgt_event *) data;
+	struct iet_msg *msg = (struct iet_msg *) ev->data;
+	struct session *session;
+
+	eprintf("%u %u\n", msg->msg_type, msg->result);
+
+	switch (msg->k.conn_state_change.state) {
+	case E_CONN_CLOSE:
+		if (!(session = session_find_id(msg->k.conn_state_change.tid,
+						msg->k.conn_state_change.sid))) {
+			eprintf("session %#" PRIx64 " not found?",
+				msg->k.conn_state_change.sid);
+		}
+
+		if (!--session->conn_cnt)
+			session_remove(session);
+		break;
+	default:
+		eprintf("%u\n", msg->k.conn_state_change.state);
+		break;
+	}
+}
+
 static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
 		       int len, int flags)
 {
@@ -151,142 +137,6 @@
 	return err;
 }
 
-static int __conn_close(int fd, u32 tid, u64 sid, u32 cid, void *arg)
-{
-	return ki->conn_destroy(tid, sid, cid);
-}
-
-static int proc_session_parse(int fd, struct session_file_operations *ops, void *arg)
-{
-	FILE *f;
-	char buf[8192], *p;
-	u32 tid, cid;
-	u64 sid;
-	int err;
-
-	if ((f = fopen(PROC_SESSION, "r")) == NULL) {
-		fprintf(stderr, "Can't open %s\n", PROC_SESSION);
-		return errno;
-	}
-
-	while (fgets(buf, sizeof(buf), f)) {
-		p = buf;
-		while (isspace((int) *p))
-			p++;
-
-		if (!strncmp(p, "tid:", 4)) {
-			if (sscanf(p, "tid:%u", &tid) != 1)
-				break;
-			if (ops->target_op)
-				if ((err = ops->target_op(fd, tid, arg)) < 0)
-					goto out;
-
-		} else if (!strncmp(p, "sid:", 4)) {
-			if (sscanf(p, "sid:%" SCNu64, &sid) != 1)
-				break;
-			if (ops->session_op)
-				if ((err = ops->session_op(fd, tid, sid, arg)) < 0)
-					goto out;
-
-		} else if (!strncmp(p, "cid:", 4)) {
-			if (sscanf(p, "cid:%u", &cid) != 1)
-				break;
-			if (ops->connection_op)
-				if ((err = ops->connection_op(fd, tid, sid, cid, arg)) < 0)
-					goto out;
-		}
-	}
-
-	err = 0;
-out:
-	fclose(f);
-
-	return err;
-}
-
-static int session_retry (int fd, u32 tid, u64 sid, void *arg)
-{
-	return -EAGAIN;
-}
-
-static int conn_retry (int fd, u32 tid, u64 sid, u32 cid, void *arg)
-{
-	return -EAGAIN;
-}
-
-struct session_file_operations conn_close_ops = {
-	.connection_op = __conn_close,
-};
-
-struct session_file_operations shutdown_wait_ops = {
-	.session_op = session_retry,
-	.connection_op = conn_retry,
-};
-
-int server_stop(void)
-{
-	DIR *dir;
-	struct dirent *ent;
-	int tid, err;
-	int32_t lun;
-
-	dir = opendir("/sys/class/tgt_device");
-	if (!dir)
-		return errno;
-
-	while ((ent = readdir(dir))) {
-		err = sscanf(ent->d_name, "device%d:%u", &tid, &lun);
-		if (err == 2)
-			err = cops->lunit_del(tid, lun);
-	}
-
-	closedir(dir);
-
-	dir = opendir("/sys/class/tgt_target");
-	if (!dir)
-		return errno;
-
-	while ((ent = readdir(dir))) {
-		err = sscanf(ent->d_name, "target%d", &tid);
-		if (err == 1)
-			err = cops->target_del(tid);
-	}
-
-	closedir(dir);
-
-	return 0;
-}
-
-struct session_conn_close_arg {
-	u32 tid;
-	u64 sid;
-};
-
-static int session_conn_close(int fd, u32 tid, u64 sid, u32 cid, void *opaque)
-{
-	struct session_conn_close_arg *arg = (struct session_conn_close_arg *) opaque;
-	int err;
-
-	if (arg->tid == tid && arg->sid == sid)
-		err = ki->conn_destroy(tid, sid, cid);
-
-	return 0;
-}
-
-struct session_file_operations session_conns_close_ops = {
-	.connection_op = session_conn_close,
-};
-
-int session_conns_close(u32 tid, u64 sid)
-{
-	int err;
-	struct session_conn_close_arg arg = {tid, sid};
-
-	err = proc_session_parse(ctrl_fd, &session_conns_close_ops, &arg);
-
-	return err;
-}
-
 static int iscsi_param_get(u32 tid, u64 sid, struct iscsi_param *param)
 {
 	struct iet_msg *msg;
@@ -428,7 +278,7 @@
 	return err;
 }
 
-static int iscsi_target_create(u32 *tid, char *name)
+static int iscsi_target_create(int *tid, char *name)
 {
 	int err;
 	char nlm_ev[8912];
@@ -577,6 +427,249 @@
 	return err;
 }
 
+
+static int target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL, tid = req->tid;
+
+	switch (req->op) {
+	case OP_NEW:
+		err = target_add(&tid, params);
+		break;
+	case OP_DELETE:
+		err = target_del(tid);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int device_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL;
+
+	switch (req->op) {
+	case OP_NEW:
+		err = iscsi_lunit_create(req->tid, req->lun, params);
+		break;
+	case OP_DELETE:
+		err = iscsi_lunit_destroy(req->tid, req->lun);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int user_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	return 0;
+}
+
+static int conn_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	return 0;
+}
+
+static int session_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	return 0;
+}
+
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static void all_devices_destroy(int tid)
+{
+	struct dirent **namelist;
+	char *p;
+	int i, nr;
+	uint32_t lun;
+
+	nr = scandir("/sys/class/tgt_device", &namelist, filter, alphasort);
+	if (!nr)
+		return;
+
+	for (i = 0; i < nr; i++) {
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		eprintf("%d\n", atoi(p));
+		if (tid != atoi(p))
+			continue;
+		p = strchr(p, ':');
+		if (!p)
+			continue;
+		lun = strtoul(++p, NULL, 10);
+		iscsi_lunit_destroy(tid, lun);
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+}
+
+static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+{
+	int err = -EINVAL, i, nr, fd;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], *p;
+
+	if (req->op != OP_DELETE)
+		return err;
+
+	nr = scandir("/sys/class/tgt_target", &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		memset(path, 0, sizeof(path));
+		strncpy(path, "/sys/class/tgt_target/", sizeof(path));
+		strncat(&path[strlen(path)], namelist[i]->d_name, sizeof(path));
+		strncat(&path[strlen(path)], "/name", sizeof(path));
+		eprintf("%s\n", path);
+		fd = open(path, O_RDONLY);
+		if (fd < 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0)
+			continue;
+		eprintf("%s\n", buf);
+		if (!strncmp(buf, "iet", 3)) {
+			int tid;
+
+			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+				;
+			tid = atoi(p);
+			all_devices_destroy(tid);
+			target_del(tid);
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return 0;
+}
+
+int ipc_mgmt(char *sbuf, char *rbuf)
+{
+	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
+	struct tgtadm_req *req;
+	struct tgtadm_res *res;
+	int err = -EINVAL, rlen = 0;
+	char *params;
+
+	req = NLMSG_DATA(nlh);
+	params = (char *) req + sizeof(*req);
+
+	eprintf("%d %d %d %d %llu %llu %s\n", nlh->nlmsg_len,
+		req->set, req->op, req->tid, req->sid, req->lun, params);
+
+	if (req->set & SET_USER)
+		err = user_mgmt(req, params, rbuf, &rlen);
+	else if (req->set & SET_DEVICE)
+		err = device_mgmt(req, params, rbuf, &rlen);
+	else if (req->set & SET_CONNECTION)
+		err = conn_mgmt(req, params, rbuf, &rlen);
+	else if (req->set & SET_SESSION)
+		err = session_mgmt(req, params, rbuf, &rlen);
+	else if (req->set & SET_TARGET)
+		err = target_mgmt(req, params, rbuf, &rlen);
+	else if (!req->set)
+		err = system_mgmt(req, params, rbuf, &rlen);
+
+	nlh = (struct nlmsghdr *) rbuf;
+	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
+	res = NLMSG_DATA(nlh);
+	res->err = err;
+
+	return err;
+}
+
+/* This is temporary. */
+
+#define CONFIG_FILE	"/etc/ietd.conf"
+#define BUFSIZE	8192
+
+/* this is the orignal Ardis code. */
+static char *target_sep_string(char **pp)
+{
+	char *p = *pp;
+	char *q;
+
+	for (p = *pp; isspace(*p); p++)
+		;
+	for (q = p; *q && !isspace(*q); q++)
+		;
+	if (*q)
+		*q++ = 0;
+	else
+		p = NULL;
+	*pp = q;
+	return p;
+}
+
+void initial_config_load(void)
+{
+	FILE *config;
+	char buf[BUFSIZE];
+	char *p, *q;
+	int idx;
+	u32 tid, val;
+
+	eprintf("%s\n", "load config");
+
+	if (!(config = fopen(CONFIG_FILE, "r")))
+		return;
+
+	tid = -1;
+	while (fgets(buf, BUFSIZE, config)) {
+		q = buf;
+		p = target_sep_string(&q);
+		if (!p || *p == '#')
+			continue;
+		if (!strcasecmp(p, "Target")) {
+			tid = 0;
+			if (!(p = target_sep_string(&q)))
+				continue;
+			eprintf("creaing target %s\n", p);
+			if (target_add(&tid, p) < 0)
+				tid = -1;
+		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
+			;
+		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
+			/* target->max_sessions = strtol(q, &q, 0); */
+		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
+			u32 lun = strtol(q, &q, 10);
+			eprintf("creaing lun %d %u %s\n", tid, lun, p);
+			iscsi_lunit_create(tid, lun, q);
+		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
+/* 			val = strtol(q, &q, 0); */
+/* 			if (param_check_val(target_keys, idx, &val) < 0) */
+/* 				log_warning("%s, %u\n", target_keys[idx].name, val); */
+/* 			iscsi_param_partial_set(tid, 0, key_target, idx, val); */
+		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
+/* 			char *str = target_sep_string(&q); */
+/* 			if (param_str_to_val(session_keys, idx, str, &val) < 0) */
+/* 				continue; */
+/* 			if (param_check_val(session_keys, idx, &val) < 0) */
+/* 				log_warning("%s, %u\n", session_keys[idx].name, val); */
+/* 			iscsi_param_partial_set(tid, 0, key_session, idx, val); */
+		}
+	}
+
+	fclose(config);
+
+	return;
+}
+
 struct iscsi_kernel_interface ioctl_ki = {
 	.lunit_create = iscsi_lunit_create,
 	.lunit_destroy = iscsi_lunit_destroy,

Deleted: trunk/iscsi/usr/event.c
===================================================================
--- trunk/iscsi/usr/event.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/event.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,131 +0,0 @@
-/*
- * Event notification code.
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * This code is licenced under the GPL.
- *
- * Some functions are based on open-iscsi code
- * written by Dmitry Yusupov, Alex Aizman.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <asm/types.h>
-#include <sys/socket.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-
-static struct sockaddr_nl src_addr, dest_addr;
-
-static int nl_write(int fd, void *data, int len)
-{
-	struct iovec iov[2];
-	struct msghdr msg;
-	struct nlmsghdr nlh;
-
-	iov[0].iov_base = &nlh;
-	iov[0].iov_len = sizeof(nlh);
-	iov[1].iov_base = data;
-	iov[1].iov_len = NLMSG_SPACE(len) - sizeof(nlh);
-
-	nlh.nlmsg_len = NLMSG_SPACE(len);
-	nlh.nlmsg_pid = getpid();
-	nlh.nlmsg_flags = 0;
-	nlh.nlmsg_type = 0;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*)&dest_addr;
-	msg.msg_namelen = sizeof(dest_addr);
-	msg.msg_iov = iov;
-	msg.msg_iovlen = 2;
-
-	return sendmsg(fd, &msg, 0);
-}
-
-static int nl_read(int fd, void *data, int len)
-{
-	struct iovec iov[2];
-	struct msghdr msg;
-	struct nlmsghdr nlh;
-
-	iov[0].iov_base = &nlh;
-	iov[0].iov_len = sizeof(nlh);
-	iov[1].iov_base = data;
-	iov[1].iov_len = len;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*)&src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = iov;
-	msg.msg_iovlen = 2;
-
-	return recvmsg(fd, &msg, MSG_DONTWAIT);
-}
-
-void handle_iscsi_events(int fd)
-{
-	struct session *session;
-	struct iet_event event;
-	int res;
-
-retry:
-	if ((res = nl_read(fd, &event, sizeof(event))) < 0) {
-		if (errno == EAGAIN)
-			return;
-		if (errno == EINTR)
-			goto retry;
-		log_error("read netlink fd (%d)", errno);
-		exit(1);
-	}
-
-	log_debug(1, "close conn %u session %#" PRIx64 " target %u, state %u",
-		  event.cid, event.sid, event.tid, event.state);
-
-	switch (event.state) {
-	case E_CONN_CLOSE:
-		if (!(session = session_find_id(event.tid, event.sid))) {
-			log_warning("session %#" PRIx64 " not found?", event.sid);
-			goto retry;
-		}
-
-		if (!--session->conn_cnt)
-			session_remove(session);
-		break;
-	default:
-		log_warning("%s(%d) %u\n", __FUNCTION__, __LINE__, event.state);
-		exit(-1);
-		break;
-	}
-}
-
-int nl_open(void)
-{
-	int nl_fd, res;
-
-	if (!(nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_IET)))
-		return -1;
-
-	memset(&src_addr, 0, sizeof(src_addr));
-	src_addr.nl_family = AF_NETLINK;
-	src_addr.nl_pid = getpid();
-	src_addr.nl_groups = 0; /* not in mcast groups */
-	if (bind(nl_fd, (struct sockaddr *)&src_addr, sizeof(src_addr))) {
-		return -1;
-	}
-
-	memset(&dest_addr, 0, sizeof(dest_addr));
-	dest_addr.nl_family = AF_NETLINK;
-	dest_addr.nl_pid = 0; /* kernel */
-	dest_addr.nl_groups = 0; /* unicast */
-
-	if ((res = nl_write(nl_fd, NULL, 0)) < 0) {
-		log_error("%s %d\n", __FUNCTION__, res);
-		return res;
-	}
-
-	return nl_fd;
-}

Deleted: trunk/iscsi/usr/ietadm.c
===================================================================
--- trunk/iscsi/usr/ietadm.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/ietadm.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,539 +0,0 @@
-/*
- * ietadm - manage iSCSI Enterprise Target software.
- *
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This code is licenced under the GPL.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-
-#include "iscsid.h"
-#include "ietadm.h"
-
-#define	SET_TARGET	(1 << 0)
-#define	SET_SESSION	(1 << 1)
-#define	SET_CONNECTION	(1 << 2)
-#define	SET_LUNIT	(1 << 3)
-#define	SET_USER	(1 << 4)
-
-enum ietadm_op {
-	OP_NEW,
-	OP_DELETE,
-	OP_UPDATE,
-	OP_SHOW,
-};
-
-static char program_name[] = "ietadm";
-
-static struct option const long_options[] =
-{
-	{"op", required_argument, NULL, 'o'},
-	{"tid", required_argument, NULL, 't'},
-	{"sid", required_argument, NULL, 's'},
-	{"cid", required_argument, NULL, 'c'},
-	{"lun", required_argument, NULL, 'l'},
-	{"params", required_argument, NULL, 'p'},
-	{"user", no_argument, NULL, 'u'},
-	{"version", no_argument, NULL, 'v'},
-	{"help", no_argument, NULL, 'h'},
-	{NULL, 0, NULL, 0},
-};
-
-static void usage(int status)
-{
-	if (status != 0)
-		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
-	else {
-		printf("Usage: %s [OPTION]\n", program_name);
-		printf("\
-iSCSI Enterprise Target Administration Utility.\n\
-\n\
-  --op new --tid=[id] --params Name=[name]\n\
-                        add a new target with [id]. [id] must not be zero.\n\
-  --op delete --tid=[id]\n\
-                        delete specific target with [id]. The target must\n\
-                        have no active sessions.\n\
-  --op new --tid=[id] --lun=[lun] --params Path=[path]\n\
-                        add a new logical unit with [lun] to specific\n\
-                        target with [id]. The logical unit is offered\n\
-                        to the initiators. [path] must be block device files\n\
-                        (including LVM and RAID devices) or regular files.\n\
-  --op delete --tid=[id] --lun=[lun]\n\
-                        delete specific logical unit with [lun] that\n\
-                        the target with [id] has.\n\
-  --op delete --tid=[id] --sid=[sid] --cid=[cid]\n\
-                        delete specific connection with [cid] in a session\n\
-                        with [sid] that the target with [id] has.\n\
-                        If the session has no connections after\n\
-                        the operation, the session will be deleted\n\
-                        automatically.\n\
-  --op delete           stop all activity.\n\
-  --op update --tid=[id] --params=key1=value1,key2=value2,...\n\
-                        change iSCSI IET target parameters of specific\n\
-                        target with [id]. You can use parameters in ietd.conf\n\
-                        as a key.\n\
-  --op new --tid=[id] --user --params=[user]=[name],Password=[pass]\n\
-                        add a new account with [pass] for specific target.\n\
-                        [user] could be [IncomingUser] or [OutgoingUser].\n\
-                        If you don't specify a target (omit --tid option),\n\
-                        you add a new account for discovery sessions.\n\
-  --op delete --tid=[id] --user --params=[user]=[name]\n\
-                        delete specific account having [name] of specific\n\
-                        target. [user] could be [IncomingUser] or\n\
-                        [OutgoingUser].\n\
-                        If you don't specify a target (omit --tid option),\n\
-                        you delete the account for discovery sessions.\n\
-  --version             display version and exit\n\
-  --help                display this help and exit\n\
-\n\
-Report bugs to <iscsitarget-devel at sourceforge.net>.\n");
-	}
-	exit(status == 0 ? 0 : -1);
-}
-
-static int str_to_op(char *str)
-{
-	int op;
-
-	if (!strcmp("new", str))
-		op = OP_NEW;
-	else if (!strcmp("delete", str))
-		op = OP_DELETE;
-	else if (!strcmp("update", str))
-		op = OP_UPDATE;
-	else if (!strcmp("show", str))
-		op = OP_SHOW;
-	else
-		op = -1;
-
-	return op;
-}
-
-static int ietd_request_send(int fd, struct ietadm_req *req)
-{
-	int err;
-
-	if ((err = write(fd, req, sizeof(*req))) != sizeof(*req)) {
-		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, err);
-		if (err >= 0)
-			err = -EIO;
-	}
-	return err;
-}
-
-static int ietd_response_recv(int fd)
-{
-	int err;
-	struct ietadm_rsp rsp;
-
-	if ((err = read(fd, &rsp, sizeof(rsp))) != sizeof(rsp)) {
-		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, err);
-		if (err >= 0)
-			err = -EIO;
-	} else
-		err = rsp.err;
-
-	return err;
-}
-
-static int ietd_connect(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, IETADM_NAMESPACE, strlen(IETADM_NAMESPACE));
-
-	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		fd = err;
-
-	return fd;
-}
-
-static int ietd_request(struct ietadm_req *req)
-{
-	int fd = -1, err = -EIO;
-
-	if ((fd = ietd_connect()) < 0) {
-		err = fd;
-		goto out;
-	}
-
-	if ((err = ietd_request_send(fd, req)) < 0)
-		goto out;
-
-	err = ietd_response_recv(fd);
-
-out:
-	if (fd > 0)
-		close(fd);
-
-	if (err < 0)
-		fprintf(stderr, "%s %d %d %d\n", __FUNCTION__, __LINE__, req->rcmnd, err);
-	return err;
-}
-
-static int parse_trgt_params(struct msg_trgt *msg, char *params)
-{
-	char *p, *q;
-
-	while ((p = strsep(&params, ",")) != NULL) {
-		int idx;
-		u32 val;
-		if (!*p)
-			continue;
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-		val = strtol(q, NULL, 0);
-
-		if (!((idx = param_index_by_name(p, target_keys)) < 0)) {
-			if (!param_check_val(target_keys, idx, &val))
-				msg->target_partial |= (1 << idx);
-			msg->target_param[idx].val = val;
-			msg->type |= 1 << key_target;
-
-			continue;
-		}
-
-		if (!((idx = param_index_by_name(p, session_keys)) < 0)) {
-			if (!param_check_val(session_keys, idx, &val))
-				msg->session_partial |= (1 << idx);
-			msg->session_param[idx].val = val;
-			msg->type |= 1 << key_session;
-		}
-	}
-
-	return 0;
-}
-
-static int trgt_handle(int op, u32 set, u32 tid, char *params)
-{
-	int err = -EINVAL;
-	struct ietadm_req req;
-
-	if (!(set & SET_TARGET))
-		goto out;
-
-	memset(&req, 0, sizeof(req));
-	req.tid = tid;
-
-	switch (op) {
-	case OP_NEW:
-	{
-		char *p = params;
-
-		if (!params || !(p = strchr(params, '=')))
-			goto out;
-		*p++ = '\0';
-		if (strcmp(params, "Name"))
-			goto out;
-		req.rcmnd = C_TRGT_NEW;
-		strncpy(req.u.trgt.name, p, sizeof(req.u.trgt.name) - 1);
-		break;
-	}
-	case OP_DELETE:
-		req.rcmnd = C_TRGT_DEL;
-		break;
-	case OP_UPDATE:
-		req.rcmnd = C_TRGT_UPDATE;
-		if ((err = parse_trgt_params(&req.u.trgt, params)) < 0)
-			goto out;
-		break;
-	case OP_SHOW:
-		req.rcmnd = C_TRGT_SHOW;
-		break;
-	}
-
-	err = ietd_request(&req);
-
-out:
-	return err;
-}
-
-static int lunit_handle(int op, u32 set, u32 tid, u32 lun, char *params)
-{
-	int err = -EINVAL;
-	struct ietadm_req req;
-
-	if (op == OP_UPDATE) {
-		fprintf(stderr, "Unsupported.\n");
-		goto out;
-	}
-
-	if (!(set & SET_TARGET))
-		goto out;
-
-	memset(&req, 0, sizeof(req));
-	req.tid = tid;
-	req.lun = lun;
-
-	switch (op) {
-	case OP_NEW:
-		req.rcmnd = C_LUNIT_NEW;
-		strncpy(req.u.lunit.args, params, sizeof(req.u.lunit.args) - 1);
-		break;
-	case OP_DELETE:
-		req.rcmnd = C_LUNIT_DEL;
-		break;
-	case OP_SHOW:
-		req.rcmnd = C_LUNIT_SHOW;
-		/* TODO */
-		break;
-	}
-
-	err = ietd_request(&req);
-out:
-	return err;
-}
-
-static int sess_handle(int op, u32 set, u32 tid, u64 sid, char *params)
-{
-	int err = -EINVAL;
-
-	if (op == OP_NEW || op == OP_UPDATE) {
-		fprintf(stderr, "Unsupported.\n");
-		goto out;
-	}
-
-	if (!((set & SET_TARGET) && (set & SET_SESSION)))
-		goto out;
-
-	switch (op) {
-	case OP_DELETE:
-		/* close all connections */
-		break;
-	case OP_SHOW:
-		/* TODO */
-		break;
-	}
-
-out:
-	return err;
-}
-
-static int user_handle(int op, u32 set, u32 tid, char *params)
-{
-	int err = -EINVAL;
-	char *p, *q, *user = NULL, *pass = NULL;
-	struct ietadm_req req;
-
-	if (set & ~(SET_TARGET | SET_USER))
-		goto out;
-
-	memset(&req, 0, sizeof(req));
-	req.tid = tid;
-
-	switch (op) {
-	case OP_NEW:
-		req.rcmnd = C_ACCT_NEW;
-		break;
-	case OP_DELETE:
-		req.rcmnd = C_ACCT_DEL;
-		break;
-	case OP_UPDATE:
-	case OP_SHOW:
-		fprintf(stderr, "Unsupported.\n");
-		goto out;
-	}
-
-	while ((p = strsep(&params, ",")) != NULL) {
-		if (!*p)
-			continue;
-
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-		if (isspace(*q))
-			q++;
-
-		if (!strcasecmp(p, "IncomingUser")) {
-			if (user)
-				fprintf(stderr, "Already specified user %s\n", q);
-			user = q;
-			req.u.acnt.auth_dir = AUTH_DIR_INCOMING;
-		} else if (!strcasecmp(p, "OutgoingUser")) {
-			if (user)
-				fprintf(stderr, "Already specified user %s\n", q);
-			user = q;
-			req.u.acnt.auth_dir = AUTH_DIR_OUTGOING;
-		} else if (!strcasecmp(p, "Password")) {
-			if (pass)
-				fprintf(stderr, "Already specified pass %s\n", q);
-			pass = q;
-		} else {
-			fprintf(stderr, "Unknown parameter %p\n", q);
-			goto out;
-		}
-	}
-
-	if ((op == OP_NEW && ((user && !pass) || (!user && pass) || (!user && !pass))) ||
-	    (op == OP_DELETE && ((!user && pass) || (!user && !pass)))) {
-		fprintf(stderr,
-			"You need to specify a user and its password %s %s\n", pass, user);
-		goto out;
-	}
-
-	strncpy(req.u.acnt.user, user, sizeof(req.u.acnt.user) - 1);
-	if (pass)
-		strncpy(req.u.acnt.pass, pass, sizeof(req.u.acnt.pass) - 1);
-
-	err = ietd_request(&req);
-out:
-	return err;
-}
-
-static int conn_handle(int op, u32 set, u32 tid, u64 sid, u32 cid, char *params)
-{
-	int err = -EINVAL;
-	struct ietadm_req req;
-
-	if (op == OP_NEW || op == OP_UPDATE) {
-		fprintf(stderr, "Unsupported.\n");
-		goto out;
-	}
-
-	if (!((set & SET_TARGET) && (set & SET_SESSION) && (set & SET_CONNECTION)))
-		goto out;
-
-	memset(&req, 0, sizeof(req));
-	req.tid = tid;
-	req.sid = sid;
-	req.cid = cid;
-
-	switch (op) {
-	case OP_DELETE:
-		req.rcmnd = C_CONN_DEL;
-		break;
-	case OP_SHOW:
-		req.rcmnd = C_CONN_SHOW;
-		/* TODO */
-		break;
-	}
-
-	err = ietd_request(&req);
-out:
-	return err;
-}
-
-static int sys_handle(int op, u32 set, char *params)
-{
-	int err = -EINVAL;
-	struct ietadm_req req;
-
-	memset(&req, 0, sizeof(req));
-
-	switch (op) {
-	case OP_NEW:
-		break;
-	case OP_DELETE:
-		req.rcmnd = C_SYS_DEL;
-		break;
-	case OP_UPDATE:
-		break;
-	case OP_SHOW:
-		break;
-	}
-
-	err = ietd_request(&req);
-
-	return err;
-}
-
-int main(int argc, char **argv)
-{
-	int ch, longindex;
-	int err = -EINVAL, op = -1;
-	u32 tid = -1, cid = 0, lun = 0, set = 0;
-	u64 sid = 0;
-	char *params = NULL;
-
-	while ((ch = getopt_long(argc, argv, "o:t:s:c:l:p:uvh",
-				 long_options, &longindex)) >= 0) {
-		switch (ch) {
-		case 'o':
-			op = str_to_op(optarg);
-			break;
-		case 't':
-			tid = strtoul(optarg, NULL, 10);
-			set |= SET_TARGET;
-			break;
-		case 's':
-			sid = strtoull(optarg, NULL, 10);
-			set |= SET_SESSION;
-			break;
-		case 'c':
-			cid = strtoul(optarg, NULL, 10);
-			set |= SET_CONNECTION;
-			break;
-		case 'l':
-			lun = strtoul(optarg, NULL, 10);
-			set |= SET_LUNIT;
-			break;
-		case 'p':
-			params = optarg;
-			break;
-		case 'u':
-			set |= SET_USER;
-			break;
-		case 'v':
-			printf("%s version %s\n", program_name, IET_VERSION_STRING);
-			exit(0);
-			break;
-		case 'h':
-			usage(0);
-			break;
-		default:
-			usage(-1);
-		}
-	}
-
-	if (op < 0) {
-		fprintf(stderr, "You must specify the operation type\n");
-		goto out;
-	}
-
-	if (optind < argc) {
-		fprintf(stderr, "unrecognized: ");
-		while (optind < argc)
-			fprintf(stderr, "%s", argv[optind++]);
-		fprintf(stderr, "\n");
-		usage(-1);
-	}
-
-	if (set & SET_USER)
-		err = user_handle(op, set, tid, params);
-	else if (set & SET_LUNIT)
-		err = lunit_handle(op, set, tid, lun, params);
-	else if (set & SET_CONNECTION)
-		err = conn_handle(op, set, tid, sid, cid, params);
-	else if (set & SET_SESSION)
-		err = sess_handle(op, set, tid, sid, params);
-	else if (set & SET_TARGET)
-		err = trgt_handle(op, set, tid, params);
-	else if (!set)
-		err = sys_handle(op, set, params);
-	else
-		usage(-1);
-
-out:
-	return err;
-}

Deleted: trunk/iscsi/usr/ietadm.h
===================================================================
--- trunk/iscsi/usr/ietadm.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/ietadm.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,78 +0,0 @@
-#ifndef _IET_ADM_H
-#define _IET_ADM_H
-
-#define IETADM_NAMESPACE "IET_ABSTRACT_NAMESPACE"
-
-struct msg_trgt {
-	char name[ISCSI_NAME_LEN];
-	char alias[ISCSI_NAME_LEN];
-
-	u32 type;
-	u32 session_partial;
-	u32 target_partial;
-	struct iscsi_param session_param[session_key_last];
-	struct iscsi_param target_param[session_key_last];
-};
-
-struct msg_acnt {
-	u32 auth_dir;
-	char user[ISCSI_NAME_LEN];
-	char pass[ISCSI_NAME_LEN];
-};
-
-struct msg_lunit {
-	char args[ISCSI_ARGS_LEN];
-};
-
-enum ietadm_cmnd {
-	C_TRGT_NEW,
-	C_TRGT_DEL,
-	C_TRGT_UPDATE,
-	C_TRGT_SHOW,
-
-	C_SESS_NEW,
-	C_SESS_DEL,
-	C_SESS_UPDATE,
-	C_SESS_SHOW,
-
-	C_CONN_NEW,
-	C_CONN_DEL,
-	C_CONN_UPDATE,
-	C_CONN_SHOW,
-
-	C_LUNIT_NEW,
-	C_LUNIT_DEL,
-	C_LUNIT_UPDATE,
-	C_LUNIT_SHOW,
-
-	C_ACCT_NEW,
-	C_ACCT_DEL,
-	C_ACCT_UPDATE,
-	C_ACCT_SHOW,
-
-	C_SYS_NEW,
-	C_SYS_DEL,
-	C_SYS_UPDATE,
-	C_SYS_SHOW,
-};
-
-struct ietadm_req {
-	enum ietadm_cmnd rcmnd;
-
-	u32 tid;
-	u64 sid;
-	u32 cid;
-	u32 lun;
-
-	union {
-		struct msg_trgt trgt;
-		struct msg_acnt acnt;
-		struct msg_lunit lunit;
-	} u;
-};
-
-struct ietadm_rsp {
-	int err;
-};
-
-#endif

Deleted: trunk/iscsi/usr/ietd.c
===================================================================
--- trunk/iscsi/usr/ietd.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/ietd.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,465 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <getopt.h>
-#include <netdb.h>
-
-#include <sys/poll.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netinet/ip.h>
-#include <arpa/inet.h>
-
-#include "iscsid.h"
-#include "ietadm.h"
-
-#define LISTEN_MAX		8
-#define INCOMING_MAX		32
-
-enum {
-	POLL_LISTEN,
-	POLL_IPC = POLL_LISTEN + LISTEN_MAX,
-	POLL_NL,
-	POLL_INCOMING,
-	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
-};
-
-static struct pollfd poll_array[POLL_MAX];
-static struct connection *incoming[INCOMING_MAX];
-static int incoming_cnt;
-int ctrl_fd, ipc_fd, nl_fd;
-
-static char program_name[] = "iscsid";
-
-static struct option const long_options[] =
-{
-	{"config", required_argument, 0, 'c'},
-	{"foreground", no_argument, 0, 'f'},
-	{"debug", required_argument, 0, 'd'},
-	{"uid", required_argument, 0, 'u'},
-	{"gid", required_argument, 0, 'g'},
-	{"version", no_argument, 0, 'v'},
-	{"help", no_argument, 0, 'h'},
-	{0, 0, 0, 0},
-};
-
-/* This will be comfigurable by command line options */
-extern struct config_operations plain_ops;
-struct config_operations *cops = &plain_ops;
-
-static void usage(int status)
-{
-	if (status != 0)
-		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
-	else {
-		printf("Usage: %s [OPTION]\n", program_name);
-		printf("\
-iSCSI target daemon.\n\
-  -c, --config=[path]     Execute in the config file.\n");
-		printf("\
-  -f, --foreground        make the program run in the foreground\n\
-  -d, --debug debuglevel  print debugging information\n\
-  -u, --uid=uid           run as uid, default is current user\n\
-  -g, --gid=gid           run as gid, default is current user group\n\
-  -h, --help              display this help and exit\n\
-");
-	}
-	exit(1);
-}
-
-static void set_non_blocking(int fd)
-{
-	int res = fcntl(fd, F_GETFL);
-
-	if (res != -1) {
-		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
-		if (res)
-			log_warning("unable to set fd flags (%s)!", strerror(errno));
-	} else
-		log_warning("unable to get fd flags (%s)!", strerror(errno));
-}
-
-static void create_listen_socket(struct pollfd *array)
-{
-	struct addrinfo hints, *res, *res0;
-	char servname[64];
-	int i, sock, opt;
-
-	memset(servname, 0, sizeof(servname));
-	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_flags = AI_PASSIVE;
-
-	if (getaddrinfo(NULL, servname, &hints, &res0)) {
-		log_error("unable to get address info (%s)!", strerror(errno));
-		exit(1);
-	}
-
-	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
-		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-		if (sock < 0) {
-			log_error("unable to create server socket (%s) %d %d %d!",
-				  strerror(errno), res->ai_family,
-				  res->ai_socktype, res->ai_protocol);
-			continue;
-		}
-
-		opt = 1;
-		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
-			log_warning("unable to set SO_REUSEADDR on server socket (%s)!",
-				    strerror(errno));
-		opt = 1;
-		if (res->ai_family == AF_INET6 &&
-		    setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)))
-			continue;
-
-		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
-			log_error("unable to bind server socket (%s)!", strerror(errno));
-			continue;
-		}
-
-		if (listen(sock, INCOMING_MAX)) {
-			log_error("unable to listen to server socket (%s)!", strerror(errno));
-			continue;
-		}
-
-		set_non_blocking(sock);
-
-		array[i].fd = sock;
-		array[i].events = POLLIN;
-	}
-
-	freeaddrinfo(res0);
-}
-
-static void accept_connection(int listen)
-{
-	struct sockaddr_storage from;
-	socklen_t namesize;
-	struct pollfd *pollfd;
-	struct connection *conn;
-	int fd, i;
-
-	namesize = sizeof(from);
-	if ((fd = accept(listen, (struct sockaddr *) &from, &namesize)) < 0) {
-		if (errno != EINTR && errno != EAGAIN) {
-			perror("accept(incoming_socket)");
-			exit(1);
-		}
-		return;
-	}
-
-	for (i = 0; i < INCOMING_MAX; i++) {
-		if (!incoming[i])
-			break;
-	}
-	if (i >= INCOMING_MAX) {
-		log_error("unable to find incoming slot? %d\n", i);
-		exit(1);
-	}
-
-	if (!(conn = conn_alloc())) {
-		log_error("fail to allocate %s", "conn\n");
-		exit(1);
-	}
-	conn->fd = fd;
-	incoming[i] = conn;
-	conn_read_pdu(conn);
-
-	set_non_blocking(fd);
-	pollfd = &poll_array[POLL_INCOMING + i];
-	pollfd->fd = fd;
-	pollfd->events = POLLIN;
-	pollfd->revents = 0;
-
-	incoming_cnt++;
-	if (incoming_cnt >= INCOMING_MAX)
-		poll_array[POLL_LISTEN].events = 0;
-}
-
-void event_loop(void)
-{
-	int res, i, opt;
-	struct connection *conn;
-	struct pollfd *pollfd;
-
-	create_listen_socket(poll_array + POLL_LISTEN);
-
-	poll_array[POLL_IPC].fd = ipc_fd;
-	poll_array[POLL_IPC].events = POLLIN;
-	poll_array[POLL_NL].fd = nl_fd;
-	poll_array[POLL_NL].events = POLLIN;
-
-	for (i = 0; i < INCOMING_MAX; i++) {
-		poll_array[POLL_INCOMING + i].fd = -1;
-		poll_array[POLL_INCOMING + i].events = 0;
-		incoming[i] = NULL;
-	}
-
-	while (1) {
-		res = poll(poll_array, POLL_MAX, -1);
-		if (res <= 0) {
-			if (res < 0 && errno != EINTR) {
-				perror("poll()");
-				exit(1);
-			}
-			continue;
-		}
-
-		for (i = 0; i < LISTEN_MAX; i++) {
-			if (poll_array[POLL_LISTEN + i].revents
-			    && incoming_cnt < INCOMING_MAX)
-				accept_connection(poll_array[POLL_LISTEN + i].fd);
-		}
-
-		if (poll_array[POLL_NL].revents)
-			handle_iscsi_events(nl_fd);
-
-		if (poll_array[POLL_IPC].revents)
-			ietadm_request_handle(ipc_fd);
-
-		for (i = 0; i < INCOMING_MAX; i++) {
-			conn = incoming[i];
-			pollfd = &poll_array[POLL_INCOMING + i];
-			if (!conn || !pollfd->revents)
-				continue;
-
-			pollfd->revents = 0;
-
-			switch (conn->iostate) {
-			case IOSTATE_READ_BHS:
-			case IOSTATE_READ_AHS_DATA:
-			read_again:
-				res = read(pollfd->fd, conn->buffer, conn->rwsize);
-				if (res <= 0) {
-					if (res == 0 || (errno != EINTR && errno != EAGAIN))
-						conn->state = STATE_CLOSE;
-					else if (errno == EINTR)
-						goto read_again;
-					break;
-				}
-				conn->rwsize -= res;
-				conn->buffer += res;
-				if (conn->rwsize)
-					break;
-
-				switch (conn->iostate) {
-				case IOSTATE_READ_BHS:
-					conn->iostate = IOSTATE_READ_AHS_DATA;
-					conn->req.ahssize =
-						conn->req.bhs.hlength * 4;
-					conn->req.datasize =
-						ntoh24(conn->req.bhs.dlength);
-					conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
-					if (conn->rwsize) {
-						if (!conn->req_buffer)
-							conn->req_buffer = malloc(INCOMING_BUFSIZE);
-						conn->buffer = conn->req_buffer;
-						conn->req.ahs = conn->buffer;
-						conn->req.data = conn->buffer + conn->req.ahssize;
-						goto read_again;
-					}
-
-				case IOSTATE_READ_AHS_DATA:
-					conn_write_pdu(conn);
-					pollfd->events = POLLOUT;
-
-					log_pdu(2, &conn->req);
-					if (!cmnd_execute(conn))
-						conn->state = STATE_CLOSE;
-					break;
-				}
-				break;
-
-			case IOSTATE_WRITE_BHS:
-			case IOSTATE_WRITE_AHS:
-			case IOSTATE_WRITE_DATA:
-			write_again:
-				opt = 1;
-				setsockopt(pollfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-				res = write(pollfd->fd, conn->buffer, conn->rwsize);
-				if (res < 0) {
-					if (errno != EINTR && errno != EAGAIN)
-						conn->state = STATE_CLOSE;
-					else if (errno == EINTR)
-						goto write_again;
-					break;
-				}
-
-				conn->rwsize -= res;
-				conn->buffer += res;
-				if (conn->rwsize)
-					goto write_again;
-
-				switch (conn->iostate) {
-				case IOSTATE_WRITE_BHS:
-					if (conn->rsp.ahssize) {
-						conn->iostate = IOSTATE_WRITE_AHS;
-						conn->buffer = conn->rsp.ahs;
-						conn->rwsize = conn->rsp.ahssize;
-						goto write_again;
-					}
-				case IOSTATE_WRITE_AHS:
-					if (conn->rsp.datasize) {
-						int o;
-
-						conn->iostate = IOSTATE_WRITE_DATA;
-						conn->buffer = conn->rsp.data;
-						conn->rwsize = conn->rsp.datasize;
-						o = conn->rwsize & 3;
-						if (o) {
-							for (o = 4 - o; o; o--)
-								*((u8 *)conn->buffer + conn->rwsize++) = 0;
-						}
-						goto write_again;
-					}
-				case IOSTATE_WRITE_DATA:
-					opt = 0;
-					setsockopt(pollfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-					cmnd_finish(conn);
-
-					switch (conn->state) {
-					case STATE_KERNEL:
-						conn_take_fd(conn, pollfd->fd);
-						conn->state = STATE_CLOSE;
-						break;
-					case STATE_EXIT:
-					case STATE_CLOSE:
-						break;
-					default:
-						conn_read_pdu(conn);
-						pollfd->events = POLLIN;
-						break;
-					}
-					break;
-				}
-
-				break;
-			default:
-				log_error("illegal iostate %d for port %d!\n", conn->iostate, i);
-				exit(1);
-			}
-
-			if (conn->state == STATE_CLOSE) {
-				log_debug(0, "connection closed");
-				conn_free_pdu(conn);
-				conn_free(conn);
-				close(pollfd->fd);
-				pollfd->fd = -1;
-				incoming[i] = NULL;
-				incoming_cnt--;
-			}
-		}
-	}
-}
-
-int main(int argc, char **argv)
-{
-	int ch, longindex;
-	char *config = NULL;
-	uid_t uid = 0;
-	gid_t gid = 0;
-
-	while ((ch = getopt_long(argc, argv, "c:fd:u:g:vh", long_options, &longindex)) >= 0) {
-		switch (ch) {
-		case 'c':
-			config = optarg;
-			break;
-		case 'f':
-			log_daemon = 0;
-			break;
-		case 'd':
-			log_level = atoi(optarg);
-			break;
-		case 'u':
-			uid = strtoul(optarg, NULL, 10);
-			break;
-		case 'g':
-			gid = strtoul(optarg, NULL, 10);
-			break;
-		case 'v':
-			printf("%s version %s\n", program_name, IET_VERSION_STRING);
-			exit(0);
-			break;
-		case 'h':
-			usage(0);
-			break;
-		default:
-			usage(1);
-			break;
-		}
-	}
-
-	if ((nl_fd = nl_open()) < 0) {
-		perror("netlink fd\n");
-		exit(-1);
-	};
-
-	if ((ipc_fd = ietadm_request_listen()) < 0) {
-		perror("ipc fd\n");
-		exit(-1);
-	}
-
-	log_init();
-	if (log_daemon) {
-		char buf[64];
-		pid_t pid;
-		int fd;
-
-		fd = open("/var/run/iscsi_trgt.pid", O_WRONLY|O_CREAT, 0644);
-		if (fd < 0) {
-			log_error("unable to create pid file");
-			exit(1);
-		}
-		pid = fork();
-		if (pid < 0) {
-			log_error("starting daemon failed");
-			exit(1);
-		} else if (pid)
-			exit(0);
-
-		chdir("/");
-		if (lockf(fd, F_TLOCK, 0) < 0) {
-			log_error("unable to lock pid file");
-			exit(1);
-		}
-		ftruncate(fd, 0);
-		sprintf(buf, "%d\n", getpid());
-		write(fd, buf, strlen(buf));
-
-		close(0);
-		open("/dev/null", O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
-
-	cops->init(config);
-
-	if (uid && setuid(uid) < 0)
-		perror("setuid\n");
-
-	if (gid && setgid(gid) < 0)
-		perror("setgid\n");
-
-	event_loop();
-
-	return 0;
-}

Modified: trunk/iscsi/usr/iscsid.c
===================================================================
--- trunk/iscsi/usr/iscsid.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/iscsid.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -118,7 +118,8 @@
 	char pass[ISCSI_NAME_LEN];
 
 	memset(pass, 0, sizeof(pass));
-	return cops->account_query(tid, dir, pass, pass) < 0 ? 1 : 0;
+/* 	return cops->account_query(tid, dir, pass, pass) < 0 ? 1 : 0; */
+	return 1;
 }
 
 static void text_scan_security(struct connection *conn)
@@ -180,7 +181,7 @@
 		if (!req->tsih) {
 			uint64_t sid = sid64(session->isid, session->tsih);
 			/* do session reinstatement */
-			session_conns_close(conn->tid, sid);
+/* 			session_conns_close(conn->tid, sid); */
 			session = NULL;
 		} else if (req->tsih != session->tsih) {
 			/* fail the login */
@@ -356,8 +357,9 @@
 			return;
 		}
 
-		if (target_find_by_name(target_name, &conn->tid) < 0 ||
-		    cops->initiator_access(conn->tid, conn->fd) < 0) {
+/* 		if (target_find_by_name(target_name, &conn->tid) < 0 || */
+/* 		    cops->initiator_access(conn->tid, conn->fd) < 0) { */
+		if (target_find_by_name(target_name, &conn->tid) < 0) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
@@ -375,7 +377,7 @@
 
 		ki->param_get(conn->tid, 0, conn->session_param);
 		conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
-		log_debug(1, "exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmdsn);
+		log_debug("exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmdsn);
 		conn->max_cmd_sn = conn->exp_cmd_sn;
 	}
 	text_key_add(conn, "TargetPortalGroupTag", "1");
@@ -443,7 +445,7 @@
 
 	switch (ISCSI_LOGIN_CURRENT_STAGE(req->flags)) {
 	case ISCSI_SECURITY_NEGOTIATION_STAGE:
-		log_debug(1, "Login request (security negotiation): %d", conn->state);
+		log_debug("Login request (security negotiation): %d", conn->state);
 		rsp->flags = ISCSI_SECURITY_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
@@ -479,7 +481,7 @@
 
 		break;
 	case ISCSI_OP_PARMS_NEGOTIATION_STAGE:
-		log_debug(1, "Login request (operational negotiation): %d", conn->state);
+		log_debug("Login request (operational negotiation): %d", conn->state);
 		rsp->flags = ISCSI_OP_PARMS_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
@@ -640,7 +642,7 @@
 	if (!(req->opcode & ISCSI_OP_IMMEDIATE))
 		conn->exp_cmd_sn++;
 
-	log_debug(1, "Text request: %d", conn->state);
+	log_debug("Text request: %d", conn->state);
 	text_scan_text(conn);
 
 	if (req->flags & ISCSI_FLAG_CMD_FINAL)

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/iscsid.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -13,12 +13,10 @@
 #include "types.h"
 #include "iet_u.h"
 #include "param.h"
-#include "config.h"
 #include "misc.h"
+#include "log.h"
 #include <iscsi_proto.h>
 
-#define PROC_SESSION	"/proc/net/iet/session"
-
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
@@ -27,6 +25,8 @@
 	(uint64_t) tsih << 48;					\
 })
 
+#define PROC_SESSION	"/proc/net/iet/session"
+
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;
@@ -142,8 +142,6 @@
 
 	int max_nr_sessions;
 	int nr_sessions;
-
-	struct storage_node *isns_node;
 };
 
 /* chap.c */
@@ -166,19 +164,6 @@
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
 
-/* log.c */
-extern int log_daemon;
-extern int log_level;
-
-extern void log_init(void);
-extern void log_warning(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_error(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_debug(int level, const char *fmt, ...)
-	__attribute__ ((format (printf, 2, 3)));
-extern void log_pdu(int level, struct PDU *pdu);
-
 /* session.c */
 extern struct session *session_find_name(u32 tid, const char *iname, uint8_t *isid);
 extern struct session *session_find_id(u32 tid, u64 sid);
@@ -186,23 +171,19 @@
 extern void session_remove(struct session *session);
 
 /* target.c */
-extern int target_add(u32 *, char *);
-extern int target_del(u32);
+extern int target_add(int *tid, char *name);
+extern int target_del(int tid);
 extern int target_find_by_name(const char *name, u32 *tid);
 struct target * target_find_by_id(u32);
 extern void target_list_build(struct connection *, char *, char *);
 
-/* message.c */
-extern int ietadm_request_listen(void);
-extern int ietadm_request_handle(int accept_fd);
-
 /* ctldev.c */
 struct iscsi_kernel_interface {
 	int (*lunit_create) (u32 tid, u32 lun, char *args);
 	int (*lunit_destroy) (u32 tid, u32 lun);
 	int (*param_get) (u32, u64, struct iscsi_param *);
 	int (*param_set) (u32, u64, int, u32, struct iscsi_param *);
-	int (*target_create) (u32 *, char *);
+	int (*target_create) (int *, char *);
 	int (*target_destroy) (u32);
 	int (*session_create) (u32, u64, u32, u32, char *);
 	int (*session_destroy) (u32, u64);
@@ -212,15 +193,23 @@
 
 extern struct iscsi_kernel_interface *ki;
 
-/* the following functions should be killed */
-extern int session_conns_close(u32 tid, u64 sid);
-extern int server_stop(void);
-
-/* event.c */
-extern void handle_iscsi_events(int fd);
-extern int nl_open(void);
-
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 
+/* #define log_error(fmt, args...)						\ */
+/* do {									\ */
+/* } while (0) */
+
+/* #define log_warning(fmt, args...)					\ */
+/* do {									\ */
+/* } while (0) */
+
+/* #define log_debug(fmt, args...)						\ */
+/* do {									\ */
+/* } while (0) */
+
+#define log_pdu(x, y)							\
+do {									\
+} while (0)
+
 #endif	/* ISCSID_H */

Added: trunk/iscsi/usr/istgt.c
===================================================================
--- trunk/iscsi/usr/istgt.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/istgt.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -0,0 +1,315 @@
+/*
+ * Software iSCSI target library
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ *
+ * This is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <netdb.h>
+
+#include <sys/poll.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/un.h>
+
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
+
+#include "iscsid.h"
+
+#define ISCSI_LISTEN_PORT	3260
+
+#define LISTEN_MAX	4
+#define INCOMING_MAX	32
+
+enum {
+	POLL_LISTEN,
+	POLL_INCOMING = POLL_LISTEN + LISTEN_MAX,
+	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
+};
+
+static struct connection *incoming[INCOMING_MAX];
+
+static void set_non_blocking(int fd)
+{
+	int res = fcntl(fd, F_GETFL);
+
+	if (res != -1) {
+		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
+		if (res)
+			log_warning("unable to set fd flags (%s)!", strerror(errno));
+	} else
+		log_warning("unable to get fd flags (%s)!", strerror(errno));
+}
+
+static void listen_socket_create(struct pollfd *pfds)
+{
+	struct addrinfo hints, *res, *res0;
+	char servname[64];
+	int i, sock, opt;
+
+	memset(servname, 0, sizeof(servname));
+	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_PASSIVE;
+
+	if (getaddrinfo(NULL, servname, &hints, &res0)) {
+		log_error("unable to get address info (%s)!", strerror(errno));
+		exit(1);
+	}
+
+	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
+		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (sock < 0) {
+			log_error("unable to create server socket (%s) %d %d %d!",
+				  strerror(errno), res->ai_family,
+				  res->ai_socktype, res->ai_protocol);
+			continue;
+		}
+
+		opt = 1;
+		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
+			log_warning("unable to set SO_REUSEADDR on server socket (%s)!",
+				    strerror(errno));
+		opt = 1;
+		if (res->ai_family == AF_INET6 &&
+		    setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)))
+			continue;
+
+		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
+			log_error("unable to bind server socket (%s)!", strerror(errno));
+			continue;
+		}
+
+		if (listen(sock, INCOMING_MAX)) {
+			log_error("unable to listen to server socket (%s)!", strerror(errno));
+			continue;
+		}
+
+		set_non_blocking(sock);
+
+		pfds[i].fd = sock;
+		pfds[i].events = POLLIN;
+	}
+
+	freeaddrinfo(res0);
+}
+
+void poll_init(struct pollfd *pfds, int nr)
+{
+	eprintf("%d\n", nr);
+	listen_socket_create(pfds + POLL_LISTEN);
+}
+
+static void accept_connection(struct pollfd *pfds, int afd)
+{
+	struct sockaddr_storage from;
+	socklen_t namesize;
+	struct pollfd *pfd;
+	struct connection *conn;
+	int fd, i;
+
+	eprintf("%d\n", afd);
+
+	namesize = sizeof(from);
+	if ((fd = accept(afd, (struct sockaddr *) &from, &namesize)) < 0) {
+		if (errno != EINTR && errno != EAGAIN) {
+			log_error("accept(incoming_socket)");
+			exit(1);
+		}
+		return;
+	}
+
+	for (i = 0; i < INCOMING_MAX; i++) {
+		if (!incoming[i])
+			break;
+	}
+	if (i >= INCOMING_MAX) {
+		log_error("unable to find incoming slot? %d\n", i);
+		goto out;
+	}
+
+	conn = conn_alloc();
+	if (!conn) {
+		log_error("fail to allocate %s", "conn\n");
+		goto out;
+	}
+	conn->fd = fd;
+	incoming[i] = conn;
+	conn_read_pdu(conn);
+
+	set_non_blocking(fd);
+	pfd = &pfds[POLL_INCOMING + i];
+	pfd->fd = fd;
+	pfd->events = POLLIN;
+	pfd->revents = 0;
+
+	return;
+out:
+	close(fd);
+	return;
+}
+
+void poll_event(struct pollfd *pfds, int nr)
+{
+	struct connection *conn;
+	struct pollfd *pfd;
+	int i, res, opt;
+
+	eprintf("%d\n", nr);
+
+	for (i = 0; i < LISTEN_MAX; i++) {
+		if (pfds[POLL_LISTEN + i].revents)
+			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
+	}
+
+	for (i = 0; i < INCOMING_MAX; i++) {
+		conn = incoming[i];
+		pfd = &pfds[POLL_INCOMING + i];
+		if (!conn || !pfd->revents)
+			continue;
+
+		pfd->revents = 0;
+
+		switch (conn->iostate) {
+		case IOSTATE_READ_BHS:
+		case IOSTATE_READ_AHS_DATA:
+		read_again:
+			res = read(pfd->fd, conn->buffer, conn->rwsize);
+			if (res <= 0) {
+				if (res == 0 || (errno != EINTR && errno != EAGAIN))
+					conn->state = STATE_CLOSE;
+				else if (errno == EINTR)
+					goto read_again;
+				break;
+			}
+			conn->rwsize -= res;
+			conn->buffer += res;
+			if (conn->rwsize)
+				break;
+
+			switch (conn->iostate) {
+			case IOSTATE_READ_BHS:
+				conn->iostate = IOSTATE_READ_AHS_DATA;
+				conn->req.ahssize =
+					conn->req.bhs.hlength * 4;
+				conn->req.datasize =
+					ntoh24(conn->req.bhs.dlength);
+				conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
+				if (conn->rwsize) {
+					if (!conn->req_buffer)
+						conn->req_buffer = malloc(INCOMING_BUFSIZE);
+					conn->buffer = conn->req_buffer;
+					conn->req.ahs = conn->buffer;
+					conn->req.data = conn->buffer + conn->req.ahssize;
+					goto read_again;
+				}
+
+			case IOSTATE_READ_AHS_DATA:
+				conn_write_pdu(conn);
+				pfd->events = POLLOUT;
+
+				if (!cmnd_execute(conn))
+					conn->state = STATE_CLOSE;
+				break;
+			}
+			break;
+
+		case IOSTATE_WRITE_BHS:
+		case IOSTATE_WRITE_AHS:
+		case IOSTATE_WRITE_DATA:
+		write_again:
+			opt = 1;
+			setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+			res = write(pfd->fd, conn->buffer, conn->rwsize);
+			if (res < 0) {
+				if (errno != EINTR && errno != EAGAIN)
+					conn->state = STATE_CLOSE;
+				else if (errno == EINTR)
+					goto write_again;
+				break;
+			}
+
+			conn->rwsize -= res;
+			conn->buffer += res;
+			if (conn->rwsize)
+				goto write_again;
+
+			switch (conn->iostate) {
+			case IOSTATE_WRITE_BHS:
+				if (conn->rsp.ahssize) {
+					conn->iostate = IOSTATE_WRITE_AHS;
+					conn->buffer = conn->rsp.ahs;
+					conn->rwsize = conn->rsp.ahssize;
+					goto write_again;
+				}
+			case IOSTATE_WRITE_AHS:
+				if (conn->rsp.datasize) {
+					int o;
+
+					conn->iostate = IOSTATE_WRITE_DATA;
+					conn->buffer = conn->rsp.data;
+					conn->rwsize = conn->rsp.datasize;
+					o = conn->rwsize & 3;
+					if (o) {
+						for (o = 4 - o; o; o--)
+							*((u8 *)conn->buffer + conn->rwsize++) = 0;
+					}
+					goto write_again;
+				}
+			case IOSTATE_WRITE_DATA:
+				opt = 0;
+				setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+				cmnd_finish(conn);
+
+				switch (conn->state) {
+				case STATE_KERNEL:
+					conn_take_fd(conn, pfd->fd);
+					conn->state = STATE_CLOSE;
+					break;
+				case STATE_EXIT:
+				case STATE_CLOSE:
+					break;
+				default:
+					conn_read_pdu(conn);
+					pfd->events = POLLIN;
+					break;
+				}
+				break;
+			}
+
+			break;
+		default:
+			log_error("illegal iostate %d for port %d!\n", conn->iostate, i);
+			exit(1);
+		}
+
+		if (conn->state == STATE_CLOSE) {
+			log_debug("connection closed");
+			conn_free_pdu(conn);
+			conn_free(conn);
+			close(pfd->fd);
+			pfd->fd = -1;
+			incoming[i] = NULL;
+		}
+	}
+}

Deleted: trunk/iscsi/usr/log.c
===================================================================
--- trunk/iscsi/usr/log.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/log.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <ctype.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <syslog.h>
-#include <sys/time.h>
-
-#include "iscsid.h"
-
-int log_daemon = 1;
-int log_level = 0;
-
-void log_init(void)
-{
-	if (log_daemon)
-		openlog("iscsid", 0, LOG_DAEMON);
-}
-
-static void dolog(int prio, const char *fmt, va_list ap)
-{
-	if (log_daemon)
-		vsyslog(prio, fmt, ap);
-	else {
-		struct timeval time;
-
-		gettimeofday(&time, NULL);
-		fprintf(stderr, "%ld.%06ld: ", time.tv_sec, time.tv_usec);
-		vfprintf(stderr, fmt, ap);
-		fprintf(stderr, "\n");
-		fflush(stderr);
-	}
-}
-
-void log_warning(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_WARNING, fmt, ap);
-	va_end(ap);
-}
-
-void log_error(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_ERR, fmt, ap);
-	va_end(ap);
-}
-
-void log_debug(int level, const char *fmt, ...)
-{
-	if (log_level > level) {
-		va_list ap;
-		va_start(ap, fmt);
-		dolog(LOG_DEBUG, fmt, ap);
-		va_end(ap);
-	}
-}
-
-static void __dump_line(int level, unsigned char *buf, int *cp)
-{
-	char line[16*3+5], *lp = line;
-	int i, cnt;
-
-	cnt = *cp;
-	if (!cnt)
-		return;
-	for (i = 0; i < 16; i++) {
-		if (i < cnt)
-			lp += sprintf(lp, " %02x", buf[i]);
-		else
-			lp += sprintf(lp, "   ");
-		if ((i % 4) == 3)
-			lp += sprintf(lp, " |");
-		if (i >= cnt || !isprint(buf[i]))
-			buf[i] =  ' ';
-	}
-	log_debug(level, "%s %.16s |", line, buf);
-	*cp = 0;
-}
-
-static void __dump_char(int level, unsigned char *buf, int *cp, int ch)
-{
-	int cnt = (*cp)++;
-
-	buf[cnt] = ch;
-	if (cnt == 15)
-		__dump_line(level, buf, cp);
-}
-
-#define dump_line() __dump_line(level, char_buf, &char_cnt)
-#define dump_char(ch) __dump_char(level, char_buf, &char_cnt, ch)
-
-void log_pdu(int level, struct PDU *pdu)
-{
-	unsigned char char_buf[16];
-	int char_cnt = 0;
-	unsigned char *buf;
-	int i;
-	return;
-
-	if (log_level <= level)
-		return;
-
-	buf = (void *)&pdu->bhs;
-	log_debug(level, "BHS: (%p)", buf);
-	for (i = 0; i < BHS_SIZE; i++)
-		dump_char(*buf++);
-	dump_line();
-
-	buf = (void *)pdu->ahs;
-	log_debug(level, "AHS: (%p)", buf);
-	for (i = 0; i < pdu->ahssize; i++)
-		dump_char(*buf++);
-	dump_line();
-
-	buf = (void *)pdu->data;
-	log_debug(level, "Data: (%p)", buf);
-	for (i = 0; i < pdu->datasize; i++)
-		dump_char(*buf++);
-	dump_line();
-}

Deleted: trunk/iscsi/usr/message.c
===================================================================
--- trunk/iscsi/usr/message.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/message.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,169 +0,0 @@
-/*
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This code is licenced under the GPL.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <unistd.h>
-
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/un.h>
-
-#include "iscsid.h"
-#include "ietadm.h"
-
-int ietadm_request_listen(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, IETADM_NAMESPACE, strlen(IETADM_NAMESPACE));
-
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		return err;
-
-	if ((err = listen(fd, 32)) < 0)
-		return err;
-
-	return fd;
-}
-
-static void ietadm_request_exec(struct ietadm_req *req, struct ietadm_rsp *rsp)
-{
-	int err = 0;
-
-	log_debug(1, "%u %u %" PRIu64 " %u %u", req->rcmnd, req->tid,
-		  req->sid, req->cid, req->lun);
-
-	switch (req->rcmnd) {
-	case C_TRGT_NEW:
-		err = cops->target_add(&req->tid, req->u.trgt.name);
-		break;
-	case C_TRGT_DEL:
-		err = cops->target_del(req->tid);
-		break;
-	case C_TRGT_UPDATE:
-		if (req->u.trgt.type & (1 << key_session))
-			err = cops->param_set(req->tid, req->sid,
-					      key_session,
-					      req->u.trgt.session_partial,
-					      req->u.trgt.session_param);
-
-		if (err < 0)
-			goto out;
-
-		if (req->u.trgt.type & (1 << key_target))
-			err = cops->param_set(req->tid, req->sid, key_target,
-					      req->u.trgt.target_partial,
-					      req->u.trgt.target_param);
-		break;
-	case C_TRGT_SHOW:
-		break;
-
-	case C_SESS_NEW:
-	case C_SESS_DEL:
-	case C_SESS_UPDATE:
-	case C_SESS_SHOW:
-		break;
-
-	case C_LUNIT_NEW:
-		err = cops->lunit_add(req->tid, req->lun, req->u.lunit.args);
-		break;
-	case C_LUNIT_DEL:
-		err = cops->lunit_del(req->tid, req->lun);
-		break;
-	case C_LUNIT_UPDATE:
-	case C_LUNIT_SHOW:
-		break;
-
-	case C_CONN_NEW:
-	case C_CONN_DEL:
-		err = ki->conn_destroy(req->tid, req->sid, req->cid);
-		break;
-	case C_CONN_UPDATE:
-	case C_CONN_SHOW:
-		break;
-
-	case C_ACCT_NEW:
-		err = cops->account_add(req->tid, req->u.acnt.auth_dir, req->u.acnt.user,
-					req->u.acnt.pass);
-		break;
-	case C_ACCT_DEL:
-		err = cops->account_del(req->tid, req->u.acnt.auth_dir, req->u.acnt.user);
-		break;
-	case C_ACCT_UPDATE:
-	case C_ACCT_SHOW:
-		break;
-	case C_SYS_NEW:
-		break;
-	case C_SYS_DEL:
-		err = server_stop();
-		break;
-	case C_SYS_UPDATE:
-	case C_SYS_SHOW:
-		break;
-	default:
-		break;
-	}
-
-out:
-	rsp->err = err;
-}
-
-int ietadm_request_handle(int accept_fd)
-{
-	struct sockaddr addr;
-	struct ucred cred;
-	int fd, err;
-	socklen_t len;
-	struct ietadm_req req;
-	struct ietadm_rsp rsp;
-
-	memset(&rsp, 0, sizeof(rsp));
-	len = sizeof(addr);
-	if ((fd = accept(accept_fd, (struct sockaddr *) &addr, &len)) < 0) {
-		if (errno == EINTR)
-			err = -EINTR;
-		else
-			err = -EIO;
-
-		goto out;
-	}
-
-	len = sizeof(cred);
-	if ((err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len)) < 0) {
-		rsp.err = -EPERM;
-		goto send;
-	}
-
-	if (cred.uid || cred.gid) {
-		rsp.err = -EPERM;
-		goto send;
-	}
-
-	if ((err = read(fd, &req, sizeof(req))) != sizeof(req)) {
-		if (err >= 0)
-			err = -EIO;
-		goto out;
-	}
-
-	ietadm_request_exec(&req, &rsp);
-
-send:
-	if ((err = write(fd, &rsp, sizeof(rsp))) != sizeof(rsp))
-		if (err >= 0)
-			err = -EIO;
-out:
-	if (fd > 0)
-		close(fd);
-	return err;
-}

Deleted: trunk/iscsi/usr/plain.c
===================================================================
--- trunk/iscsi/usr/plain.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/plain.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,572 +0,0 @@
-/*
- * Plain file-based configuration file code.
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * This code is licenced under the GPL.
- */
-
-#include <ctype.h>
-#include <dirent.h>
-#include <errno.h>
-#include <netdb.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <linux/netlink.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netinet/ip.h>
-#include <arpa/inet.h>
-
-#include "iscsid.h"
-
-#define BUFSIZE		4096
-#define CONFIG_FILE	"/etc/ietd.conf"
-#define ACCT_CONFIG_FILE	CONFIG_FILE
-
-/*
- * Account configuration code
- */
-
-struct user {
-	struct qelem ulist;
-
-	u32 tid;
-	char *name;
-	char *password;
-};
-
-/* this is the orignal Ardis code. */
-static char *target_sep_string(char **pp)
-{
-	char *p = *pp;
-	char *q;
-
-	for (p = *pp; isspace(*p); p++)
-		;
-	for (q = p; *q && !isspace(*q); q++)
-		;
-	if (*q)
-		*q++ = 0;
-	else
-		p = NULL;
-	*pp = q;
-	return p;
-}
-
-static struct iscsi_key user_keys[] = {
-	{"IncomingUser",},
-	{"OutgoingUser",},
-	{NULL,},
-};
-
-static struct qelem discovery_users_in = LIST_HEAD_INIT(discovery_users_in);
-static struct qelem discovery_users_out = LIST_HEAD_INIT(discovery_users_out);
-
-#define HASH_ORDER	4
-#define acct_hash(x)	((x) & ((1 << HASH_ORDER) - 1))
-
-static struct qelem trgt_acct_in[1 << HASH_ORDER];
-static struct qelem trgt_acct_out[1 << HASH_ORDER];
-
-static struct qelem *account_list_get(u32 tid, int dir)
-{
-	struct qelem *list = NULL;
-
-	if (tid) {
-		list = (dir == AUTH_DIR_INCOMING) ?
-			&trgt_acct_in[acct_hash(tid)] : &trgt_acct_out[acct_hash(tid)];
-	} else
-		list = (dir == AUTH_DIR_INCOMING) ?
-			&discovery_users_in : &discovery_users_out;
-
-	return list;
-}
-
-static int plain_account_init(char *filename)
-{
-	FILE *fp;
-	char buf[BUFSIZE], *p, *q;
-	u32 tid;
-	int i, idx;
-
-	for (i = 0; i < 1 << HASH_ORDER; i++) {
-		INIT_LIST_HEAD(&trgt_acct_in[i]);
-		INIT_LIST_HEAD(&trgt_acct_out[i]);
-	}
-
-	if (!(fp = fopen(filename, "r")))
-		return -EIO;
-
-	tid = 0;
-	while (fgets(buf, sizeof(buf), fp)) {
-		q = buf;
-		p = target_sep_string(&q);
-		if (!p || *p == '#')
-			continue;
-
-		if (!strcasecmp(p, "Target")) {
-			if (!(p = target_sep_string(&q)))
-				continue;
-			if (target_find_by_name(p, &tid) < 0)
-				continue;
-		} else if (!((idx = param_index_by_name(p, user_keys)) < 0)) {
-			char *name, *pass;
-			name = target_sep_string(&q);
-			pass = target_sep_string(&q);
-
-			if (cops->account_add(tid, idx, name, pass) < 0)
-				fprintf(stderr, "%s %s\n", name, pass);
-		}
-	}
-
-	fclose(fp);
-
-	return 0;
-}
-
-/* Return the first account if the length of name is zero */
-static struct user *account_lookup_by_name(u32 tid, int dir, char *name)
-{
-	struct qelem *list = account_list_get(tid, dir);
-	struct user *user = NULL;
-
-	list_for_each_entry(user, list, ulist) {
-		fprintf(stderr, "%u %s %s\n", user->tid, user->password, user->name);
-		if (user->tid != tid)
-			continue;
-		if (!strlen(name))
-			return user;
-		if (!strcmp(user->name, name))
-			return user;
-	}
-
-	return NULL;
-}
-
-static int plain_account_query(u32 tid, int dir, char *name, char *pass)
-{
-	struct user *user;
-
-	if (!(user = account_lookup_by_name(tid, dir, name)))
-		return -ENOENT;
-
-	if (!strlen(name))
-		strncpy(name, user->name, ISCSI_NAME_LEN);
-
-	strncpy(pass, user->password, ISCSI_NAME_LEN);
-
-	return 0;
-}
-
-static void account_destroy(struct user *user)
-{
-	if (!user)
-		return;
-	remque(&user->ulist);
-	free(user->name);
-	free(user->password);
-	free(user);
-}
-
-static int plain_account_del(u32 tid, int dir, char *name)
-{
-	struct user *user;
-
-	if (!name || !(user = account_lookup_by_name(tid, dir, name)))
-		return -ENOENT;
-
-	account_destroy(user);
-
-	/* update the file here. */
-	return 0;
-}
-
-static struct user *account_create(void)
-{
-	struct user *user;
-
-	if (!(user = malloc(sizeof(*user))))
-		return NULL;
-
-	memset(user, 0, sizeof(*user));
-	INIT_LIST_HEAD(&user->ulist);
-
-	return user;
-}
-
-static int plain_account_add(u32 tid, int dir, char *name, char *pass)
-{
-	int err = -ENOMEM;
-	struct user *user;
-	struct qelem *list;
-
-	if (!name || !pass)
-		return -EINVAL;
-
-	if (tid) {
-		/* check here */
-/* 		return -ENOENT; */
-	}
-
-	if (!(user = account_create()) ||
-	    !(user->name = strdup(name)) ||
-	    !(user->password = strdup(pass)))
-		goto out;
-
-	user->tid = tid;
-	list = account_list_get(tid, dir);
-
-	if (dir == AUTH_DIR_OUTGOING && !list_empty(list)) {
-		struct user *old;
-		log_warning("Only one outgoing %s account is supported."
-			    " Replacing the old one.\n",
-			    tid ? "target" : "discovery");
-
-		old = (struct user *) list->q_forw;
-		account_destroy(old);
-	}
-
-	insque(user, list);
-
-	/* update the file here. */
-	return 0;
-out:
-	account_destroy(user);
-
-	return err;
-}
-
-/*
- * Access control code
- */
-
-static int netmask_match_v6(struct sockaddr *sa1, struct sockaddr *sa2, uint32_t mbit)
-{
-	uint16_t mask, a1[8], a2[8];
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		a1[i] = ntohs(((struct sockaddr_in6 *) sa1)->sin6_addr.s6_addr16[i]);
-		a2[i] = ntohs(((struct sockaddr_in6 *) sa2)->sin6_addr.s6_addr16[i]);
-	}
-
-	for (i = 0; i < mbit / 16; i++)
-		if (a1[i] ^ a2[i])
-			return 0;
-
-	if (mbit % 16) {
-		mask = ~((1 << (16 - (mbit % 16))) - 1);
-		if ((mask & a1[mbit / 16]) ^ (mask & a2[mbit / 16]))
-			return 0;
-	}
-
-	return 1;
-}
-
-static int netmask_match_v4(struct sockaddr *sa1, struct sockaddr *sa2, uint32_t mbit)
-{
-	uint32_t s1, s2, mask = ~((1 << (32 - mbit)) - 1);
-
-	s1 = htonl(((struct sockaddr_in *) sa1)->sin_addr.s_addr);
-	s2 = htonl(((struct sockaddr_in *) sa2)->sin_addr.s_addr);
-
-	if (~mask & s1)
-		return 0;
-
-	if (!((mask & s2) ^ (mask & s1)))
-		return 1;
-
-	return 0;
-}
-
-static int netmask_match(struct sockaddr *sa1, struct sockaddr *sa2, char *buf)
-{
-	uint32_t mbit;
-	uint8_t family = sa1->sa_family;
-
-	mbit = strtoul(buf, NULL, 0);
-	if (mbit < 0 ||
-	    (family == AF_INET && mbit > 31) ||
-	    (family == AF_INET6 && mbit > 127))
-		return 0;
-
-	if (family == AF_INET)
-		return netmask_match_v4(sa1, sa2, mbit);
-
-	return netmask_match_v6(sa1, sa2, mbit);
-}
-
-static int address_match(struct sockaddr *sa1, struct sockaddr *sa2)
-{
-	if (sa1->sa_family == AF_INET)
-		return ((struct sockaddr_in *) sa1)->sin_addr.s_addr ==
-			((struct sockaddr_in *) sa2)->sin_addr.s_addr;
-	else {
-		struct in6_addr *a1, *a2;
-
-		a1 = &((struct sockaddr_in6 *) sa1)->sin6_addr;
-		a2 = &((struct sockaddr_in6 *) sa2)->sin6_addr;
-
-		return (a1->s6_addr32[0] == a2->s6_addr32[0] &&
-			a1->s6_addr32[1] == a2->s6_addr32[1] &&
-			a1->s6_addr32[2] == a2->s6_addr32[2] &&
-			a1->s6_addr32[3] == a2->s6_addr32[3]);
-	}
-
-	return 0;
-}
-
-static int __initiator_match(int fd, char *str)
-{
-	struct sockaddr_storage from;
-	struct addrinfo hints, *res;
-	socklen_t len;
-	char *p, *q;
-	int err = 0;
-
-	len = sizeof(from);
-	if (getpeername(fd, (struct sockaddr *) &from, &len) < 0)
-		return 0;
-
-	while ((p = strsep(&str, ","))) {
-		if (isspace(*p))
-			p++;
-
-		if (!strcmp(p, "ALL"))
-			return 1;
-
-		if (*p == '[') {
-			p++;
-			if (!(q = strchr(p, ']')))
-				return 0;
-			*(q++) = '\0';
-		} else
-			q = p;
-
-		if ((q = strchr(q, '/')))
-			*(q++) = '\0';
-
-		memset(&hints, 0, sizeof(hints));
-		hints.ai_socktype = SOCK_STREAM;
-		hints.ai_flags = AI_NUMERICHOST;
-
-		if (getaddrinfo(p, NULL, &hints, &res) < 0)
-			return 0;
-
-		if (q)
-			err = netmask_match(res->ai_addr,
-					    (struct sockaddr *) &from, q);
-		else
-			err = address_match(res->ai_addr,
-					    (struct sockaddr *) &from);
-
-		freeaddrinfo(res);
-
-		if (err)
-			break;
-	}
-
-	return err;
-}
-
-static int initiator_match(u32 tid, int fd, char *filename)
-{
-	int err = 0, tmp;
-	FILE *fp;
-	char buf[BUFSIZE], *p;
-
-	if (!(fp = fopen(filename, "r")))
-		return err;
-
-	/*
-	 * Every time we are called, we read the file. So we don't need to
-	 * implement 'reload feature'. It's slow, however, it doesn't matter.
-	 */
-	while ((p = fgets(buf, sizeof(buf), fp))) {
-		if (!p || *p == '#')
-			continue;
-
-		p = &buf[strlen(buf) - 1];
-		if (*p != '\n')
-			continue;
-		*p = '\0';
-
-		if (!(p = strchr(buf, ' ')))
-			continue;
-		*(p++) = '\0';
-
-		if (target_find_by_name(buf, &tmp) < 0)
-			continue;
-
-		err = __initiator_match(fd, p);
-		break;
-	}
-
-	fclose(fp);
-	return err;
-}
-
-static int plain_initiator_access(u32 tid, int fd)
-{
-	if (initiator_match(tid, fd, "/etc/initiators.deny") &&
-	    !initiator_match(tid, fd, "/etc/initiators.allow"))
-		return -EPERM;
-	else
-		return 0;
-}
-
-/*
- * Main configuration code
- */
-
-static int __plain_target_create(u32 *tid, char *name, int update)
-{
-	return target_add(tid, name);
-}
-
-static int plain_target_create(u32 *tid, char *name)
-{
-	return __plain_target_create(tid, name, 1);
-}
-
-static int plain_target_destroy(u32 tid)
-{
-	int err;
-
-	if ((err = target_del(tid)) < 0)
-		return err;
-
-	/* Update the config file here. */
-	return err;
-}
-
-static int plain_lunit_create(u32 tid, u32 lun, char *args)
-{
-	return ki->lunit_create(tid, lun, args);
-}
-
-static int plain_lunit_destroy(u32 tid, u32 lun)
-{
-	return ki->lunit_destroy(tid, lun);
-}
-
-static int __plain_param_set(u32 tid, u64 sid, int type,
-			   u32 partial, struct iscsi_param *param, int update)
-{
-	int err;
-
-	if ((err = ki->param_set(tid, sid, type, partial, param)) < 0)
-		return err;
-
-	if (update)
-		;
-
-	return err;
-}
-
-static int plain_param_set(u32 tid, u64 sid, int type,
-			   u32 partial, struct iscsi_param *param)
-{
-	return __plain_param_set(tid, sid, type, partial, param, 1);
-}
-
-static int iscsi_param_partial_set(u32 tid, u64 sid, int type, int key, u32 val)
-{
-	struct iscsi_param *param;
-	struct iscsi_param session_param[session_key_last];
-	struct iscsi_param target_param[target_key_last];
-
-	if (type == key_session)
-		param = session_param;
-	else
-		param = target_param;
-
-	param[key].val = val;
-
-	return __plain_param_set(tid, sid, type, 1 << key, param, 0);
-}
-
-static int plain_main_init(char *filename)
-{
-	FILE *config;
-	char buf[BUFSIZE];
-	char *p, *q;
-	int idx, tid;
-	u32 val;
-
-	if (!(config = fopen(filename, "r")))
-		return -errno;
-
-	tid = -1;
-	while (fgets(buf, BUFSIZE, config)) {
-		q = buf;
-		p = target_sep_string(&q);
-		if (!p || *p == '#')
-			continue;
-		if (!strcasecmp(p, "Target")) {
-			tid = 0;
-			if (!(p = target_sep_string(&q)))
-				continue;
-			log_debug(1, "creaing target %s", p);
-			if (__plain_target_create(&tid, p, 0) < 0)
-				tid = -1;
-		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
-			;
-		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
-			/* target->max_sessions = strtol(q, &q, 0); */
-		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
-			u32 lun = strtol(q, &q, 10);
-			plain_lunit_create(tid, lun, q);
-		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
-			val = strtol(q, &q, 0);
-			if (param_check_val(target_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", target_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_target, idx, val);
-		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
-			char *str = target_sep_string(&q);
-			if (param_str_to_val(session_keys, idx, str, &val) < 0)
-				continue;
-			if (param_check_val(session_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", session_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_session, idx, val);
-		}
-	}
-
-	fclose(config);
-	return 0;
-}
-
-static int plain_init(char *params)
-{
-	int err;
-
-	/* First, we must finish the main configuration. */
-	if ((err = plain_main_init(params ? params : CONFIG_FILE)))
-		return err;
-
-	if ((err = plain_account_init(ACCT_CONFIG_FILE)) < 0)
-		return err;
-
-	/* TODO: error handling */
-
-	return err;
-}
-
-struct config_operations plain_ops = {
-	.init			= plain_init,
-	.target_add		= plain_target_create,
-	.target_del		= plain_target_destroy,
-	.lunit_add		= plain_lunit_create,
-	.lunit_del		= plain_lunit_destroy,
-	.param_set		= plain_param_set,
-	.account_add		= plain_account_add,
-	.account_del		= plain_account_del,
-	.account_query		= plain_account_query,
-	.initiator_access	= plain_initiator_access,
-};

Modified: trunk/iscsi/usr/session.c
===================================================================
--- trunk/iscsi/usr/session.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/session.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -42,7 +42,7 @@
 	if (!(target = target_find_by_id(tid)))
 		return NULL;
 
-	log_debug(1, "session_find_name: %s %x %x %x %x %x %x", iname,
+	log_debug("session_find_name: %s %x %x %x %x %x %x", iname,
 		  isid[0], isid[1], isid[2], isid[3], isid[4], isid[5]);
 	list_for_each_entry(session, &target->sessions_list, slist) {
 		if (!memcmp(isid, session->isid, sizeof(session->isid)) &&
@@ -61,7 +61,7 @@
 	if (!(target = target_find_by_id(tid)))
 		return NULL;
 
-	log_debug(1, "session_find_id: %#" PRIx64, sid);
+	log_debug("session_find_id: %#" PRIx64, sid);
 	list_for_each_entry(session, &target->sessions_list, slist) {
 		if (sid64(session->isid, session->tsih) == sid)
 			return session;
@@ -145,7 +145,7 @@
 	conn->session = session;
 	conn->session->initiator = strdup(conn->initiator);
 
-	log_debug(1, "session_create: %#" PRIx64, sid);
+	log_debug("session_create: %#" PRIx64, sid);
 
 	ki->session_create(conn->tid, sid, conn->exp_cmd_sn,
 			   conn->max_cmd_sn, session->initiator);
@@ -156,7 +156,7 @@
 {
 	uint64_t sid = sid64(session->isid, session->tsih);
 
-	log_debug(1, "session_remove: %#"  PRIx64, sid);
+	eprintf("session_remove: %#"  PRIx64, sid);
 
 	if (!session->tsih)
 		ki->session_destroy(session->target->tid, sid);

Modified: trunk/iscsi/usr/target.c
===================================================================
--- trunk/iscsi/usr/target.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/iscsi/usr/target.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -13,6 +13,7 @@
 #include <sys/stat.h>
 
 #include "iscsid.h"
+#include "tgtadm.h"
 
 static struct qelem targets_list = LIST_HEAD_INIT(targets_list);
 
@@ -23,8 +24,8 @@
 	list_for_each_entry(target, &targets_list, tlist) {
 		if (name && strcmp(target->name, name))
 			continue;
-		if (cops->initiator_access(target->tid, conn->fd) < 0)
-			continue;
+/* 		if (cops->initiator_access(target->tid, conn->fd) < 0) */
+/* 			continue; */
 
 		text_key_add(conn, "TargetName", target->name);
 		text_key_add(conn, "TargetAddress", addr);
@@ -59,16 +60,15 @@
 
 static void all_accounts_del(u32 tid, int dir)
 {
-	char name[ISCSI_NAME_LEN], pass[ISCSI_NAME_LEN];
+/* 	char name[ISCSI_NAME_LEN], pass[ISCSI_NAME_LEN]; */
 
-	for (memset(name, 0, sizeof(name));
-	     cops->account_query(tid, dir, name, pass) != -ENOENT;) {
-		cops->account_del(tid, dir, name);
-	}
-
+/* 	for (memset(name, 0, sizeof(name)); */
+/* 	     cops->account_query(tid, dir, name, pass) != -ENOENT;) { */
+/* 		cops->account_del(tid, dir, name); */
+/* 	} */
 }
 
-int target_del(u32 tid)
+int target_del(int tid)
 {
 	int err;
 	struct target* target;
@@ -97,7 +97,7 @@
 	return 0;
 }
 
-int target_add(u32 *tid, char *name)
+int target_add(int *tid, char *name)
 {
 	struct target *target;
 	int err;

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/kernel/tgt.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -48,11 +48,7 @@
 static spinlock_t device_tmpl_lock;
 static LIST_HEAD(device_tmpl_list);
 
-/*
- * when we merge the daemons we will not need both of these
- * this is just a tmp hack
- */
-static int tgt_pid, daemon_pid;
+static int tgtd_pid;
 static struct sock *nls;
 
 /* TODO: lock per session */
@@ -161,7 +157,7 @@
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
-	if (!tgt_pid) {
+	if (!tgtd_pid) {
 		eprintk("%s\n", "Run the user-space daemon first!");
 		return NULL;
 	}
@@ -666,7 +662,7 @@
 		return -ENOMEM;
 
 	dprintk("%d %Zd %d\n", len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMD_REQ,
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
 			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
@@ -678,7 +674,7 @@
 
 	proto->build_uspace_pdu(cmd, pdu);
 
-	return netlink_unicast(nls, skb, tgt_pid, 0);
+	return netlink_unicast(nls, skb, tgtd_pid, 0);
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
@@ -830,7 +826,7 @@
 		return -ENOMEM;
 
 	dprintk("%d %Zd %d\n", len, sizeof(*ev), data_len);
-	nlh = __nlmsg_put(skb, daemon_pid, 0, TGT_KEVENT_TARGET_PASSTHRU,
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_TARGET_PASSTHRU,
 			 len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
@@ -839,7 +835,7 @@
 	ev->k.tgt_passthru.tid = target->tid;
 	ev->k.tgt_passthru.len = data_len;
 
-	return netlink_unicast(nls, skb, daemon_pid, 0);
+	return netlink_unicast(nls, skb, tgtd_pid, 0);
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
@@ -850,18 +846,13 @@
 	struct tgt_cmd *cmd;
 	struct tgt_target *target;
 
-	dprintk("%d %d %d %d\n", daemon_pid, nlh->nlmsg_type,
+	dprintk("%d %d %d\n", nlh->nlmsg_type,
 		nlh->nlmsg_pid, current->pid);
 
-	/*
-	 * stupid hack until we merge daemons
-	 */
-	daemon_pid = NETLINK_CREDS(skb)->pid;
-
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
-		tgt_pid  = NETLINK_CREDS(skb)->pid;
-		dprintk("start %d\n", tgt_pid);
+		tgtd_pid  = NETLINK_CREDS(skb)->pid;
+		dprintk("start %d\n", tgtd_pid);
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/Makefile	2005-09-24 08:32:55 UTC (rev 96)
@@ -1,10 +1,12 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_TGT=20
-PROGRAMS = tgtd
+PROGRAMS = tgtd tgtadm
 
 all: $(PROGRAMS)
 
 tgtd: tgtd.o scsi.o netlink.o ipc.o log.o
-	$(CC) $^ -o $@ $(LIBS)
+	$(CC) -rdynamic -ldl $^ -o $@
 
+tgtadm: tgtadm.o
+	$(CC) -rdynamic -ldl $^ -o $@
 clean:
 	rm -f *.o $(PROGRAMS)

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/ipc.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -9,6 +9,7 @@
 #include <errno.h>
 #include <stdio.h>
 #include <unistd.h>
+#include <dlfcn.h>
 #include <errno.h>
 #include <inttypes.h>
 #include <sys/socket.h>
@@ -18,43 +19,61 @@
 #include <sys/socket.h>
 #include <linux/netlink.h>
 
-#include <tgt_if.h>
 #include "tgtd.h"
+#include "tgtadm.h"
 
-void ipc_event_handle(int accept_fd)
+static int ipc_accept(int afd)
 {
 	struct sockaddr addr;
-	struct ucred cred;
-	int fd, err, res;
 	socklen_t len;
-	struct tgt_event *ev;
-	char nlm_ev[8192], *data;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
-	struct iovec iov;
-	struct msghdr msg;
 
-	dprintf("%s %d\n", __FUNCTION__, __LINE__);
-
 	len = sizeof(addr);
-	if ((fd = accept(accept_fd, (struct sockaddr *) &addr, &len)) < 0) {
-		if (errno == EINTR)
-			err = -EINTR;
-		else
-			err = -EIO;
+	return accept(afd, (struct sockaddr *) &addr, &len);
+}
 
-		goto out;
-	}
+static int ipc_perm(int fd)
+{
+	struct ucred cred;
+	socklen_t len;
+	int err;
 
 	len = sizeof(cred);
 	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
 	if (err < 0)
-		goto send;
+		goto out;
 
 	if (cred.uid || cred.gid) {
 		err = -EPERM;
-		goto send;
+		goto out;
 	}
+out:
+	return err;
+}
 
+void ipc_event_handle(int accept_fd)
+{
+	int fd, err;
+	char sbuf[4096], rbuf[4096];
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	struct tgtadm_res *res;
+	int (*fn) (char *, char *);
+
+	fd = ipc_accept(accept_fd);
+	if (fd < 0) {
+		eprintf("%d\n", fd);
+		return;
+	}
+
+	err = ipc_perm(fd);
+	if (err < 0)
+		goto fail;
+
+	memset(sbuf, 0, sizeof(sbuf));
+	memset(rbuf, 0, sizeof(rbuf));
+
+	nlh = (struct nlmsghdr *) sbuf;
 	iov.iov_base = nlh;
 	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
 	memset(&msg, 0, sizeof(msg));
@@ -64,7 +83,7 @@
 	err = recvmsg(fd, &msg, MSG_PEEK);
 	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
 		err = -EIO;
-		goto out;
+		goto fail;
 	}
 
 	iov.iov_base = nlh;
@@ -75,28 +94,34 @@
 
 	err = recvmsg(fd, &msg, MSG_DONTWAIT);
 	if (err < 0)
-		goto out;
-	data = NLMSG_DATA(nlh);
+		goto fail;
 
-	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, data,
-			  nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
-			  &res);
+	eprintf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, nlh->nlmsg_len);
 
-	dprintf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, res);
+	fn = dlsym(dl_handles[0], "ipc_mgmt");
+	if (!fn) {
+		eprintf("%s\n", dlerror());
+		err = -EINVAL;
+		goto fail;
+	}
+	err = fn((char *) nlh, rbuf);
 
 send:
-	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
-	nlh->nlmsg_type = TGT_KEVENT_RESPONSE;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = 0;
-	ev = NLMSG_DATA(nlh);
-	ev->k.event_res.err = res;
+	err = write(fd, nlh, nlh->nlmsg_len);
 
-	err = write(fd, nlh, NLMSG_SPACE(sizeof(*ev)));
-
-out:
 	if (fd > 0)
 		close(fd);
+
+	if (err < 0)
+		eprintf("%d\n", err);
+
+	return;
+fail:
+	nlh = (struct nlmsghdr *) rbuf;
+	res = NLMSG_DATA(nlh);
+	res->err = err;
+	nlh->nlmsg_len = NLMSG_LENGTH(0);
+	goto send;
 }
 
 int ipc_open(void)

Modified: trunk/usr/log.h
===================================================================
--- trunk/usr/log.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/log.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -71,4 +71,14 @@
 extern void log_debug(const char *fmt, ...)
 	__attribute__ ((format (printf, 1, 2)));
 
+#define eprintf(fmt, args...)						\
+do {									\
+	log_error("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#define dprintf(fmt, args...)						\
+do {									\
+	log_debug("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
 #endif	/* LOG_H */

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/netlink.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -21,6 +21,7 @@
 #include <sys/socket.h>
 #include <asm/types.h>
 #include <linux/netlink.h>
+#include <dlfcn.h>
 
 #include <tgt_if.h>
 #include "tgtd.h"
@@ -30,7 +31,7 @@
 static struct sockaddr_nl src_addr, dest_addr;
 static char *recvbuf, *sendbuf;
 
-static int nl_write(int fd, int type, char *data, int len)
+static int __nl_write(int fd, int type, char *data, int len)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
 	struct iovec iov;
@@ -54,7 +55,7 @@
 	return sendmsg(fd, &msg, 0);
 }
 
-static int nl_read(int fd, void *data, int size, int flags)
+static int __nl_read(int fd, void *data, int size, int flags)
 {
 	int rc;
 	struct iovec iov;
@@ -74,21 +75,35 @@
 	return rc;
 }
 
-int nl_cmd_call(int fd, int type, char *data, int size, int *res)
+int nl_read(int fd)
 {
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
 	int err;
-	struct tgt_event *ev;
-	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
 
-	err = nl_write(fd, type, data, size);
-	if (err < 0)
+peek_again:
+	err = __nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN || errno == EINTR)
+			goto peek_again;
 		return err;
+	}
 
-	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
+	nlh = (struct nlmsghdr *) recvbuf;
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	ev = (struct tgt_event *) NLMSG_DATA(nlm_ev);
-	*res = ev->k.event_res.err;
+	dprintf("nl_event_handle %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
 
+read_again:
+	err = __nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN || errno == EINTR)
+			goto read_again;
+		return err;
+	}
+
 	return err;
 }
 
@@ -120,8 +135,8 @@
 
 	log_error("scsi_cmd_process res %d len %d\n", result, len);
 
-	return nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			NLMSG_SPACE(sizeof(*ev_res) + len));
+	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
+			  NLMSG_SPACE(sizeof(*ev_res) + len));
 }
 
 void nl_event_handle(int fd)
@@ -129,38 +144,24 @@
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	int err;
+	void (*fn) (char *);
 
-peek_again:
-	err = nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN)
-			return;
-		if (errno == EINTR)
-			goto peek_again;
+	err = nl_read(fd);
+	if (err < 0)
 		return;
-	}
 
 	nlh = (struct nlmsghdr *) recvbuf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	dprintf("nl_event_handle %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
-
-read_again:
-	err = nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN)
-			return;
-		if (errno == EINTR)
-			goto read_again;
-		return;
-	}
-
 	switch (nlh->nlmsg_type) {
 	case TGT_KEVENT_CMD_REQ:
 		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
+	case TGT_KEVENT_TARGET_PASSTHRU:
+		fn = dlsym(dl_handles[0], "async_event");
+		if (fn)
+			fn(NLMSG_DATA(recvbuf));
+		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);
@@ -169,15 +170,41 @@
 	}
 }
 
+int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf)
+{
+	int err;
+	struct nlmsghdr *nlh;
+
+	err = __nl_write(fd, type, data, size);
+	if (err < 0)
+		return err;
+
+	err = nl_read(fd);
+
+	if (rbuf) {
+		nlh = (struct nlmsghdr *) recvbuf;
+		memcpy(rbuf, nlh, nlh->nlmsg_len);
+	}
+
+	return err;
+}
+
 static void nl_start(int fd)
 {
-	int err, res;
+	int err;
+	struct tgt_event *ev;
+	struct nlmsghdr *nlh;
+	char rbuf[8192];
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
-	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg, 
-			   NLMSG_SPACE(sizeof(struct tgt_event)), &res);
-	if (err < 0 || res < 0) {
-		eprintf("%d %d\n", err, res);
+	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
+			  NLMSG_SPACE(sizeof(struct tgt_event)), rbuf);
+
+	nlh = (struct nlmsghdr *) rbuf;
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
+
+	if (err < 0 || ev->k.event_res.err < 0) {
+		eprintf("%d %d\n", err, ev->k.event_res.err);
 		exit(-1);
 	}
 }

Copied: trunk/usr/tgtadm.c (from rev 88, trunk/iscsi/usr/ietadm.c)
===================================================================
--- trunk/iscsi/usr/ietadm.c	2005-09-23 00:35:37 UTC (rev 88)
+++ trunk/usr/tgtadm.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -0,0 +1,280 @@
+/*
+ * ietadm - manage iSCSI Enterprise Target software.
+ *
+ * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
+ *
+ * This code is licenced under the GPL.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <dlfcn.h>
+#include <inttypes.h>
+
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
+
+#include "tgtadm.h"
+
+static char program_name[] = "tgtadm";
+
+static struct option const long_options[] =
+{
+	{"op", required_argument, NULL, 'o'},
+	{"tid", required_argument, NULL, 't'},
+	{"sid", required_argument, NULL, 's'},
+	{"cid", required_argument, NULL, 'c'},
+	{"lun", required_argument, NULL, 'l'},
+	{"params", required_argument, NULL, 'p'},
+	{"user", no_argument, NULL, 'u'},
+	{"version", no_argument, NULL, 'v'},
+	{"help", no_argument, NULL, 'h'},
+	{NULL, 0, NULL, 0},
+};
+
+static void usage(int status)
+{
+	if (status != 0)
+		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
+	else {
+		printf("Usage: %s [OPTION]\n", program_name);
+		printf("\
+iSCSI Enterprise Target Administration Utility.\n\
+\n\
+  --op new --tid=[id] --params [name]\n\
+                        add a new target with [id]. [id] must not be zero.\n\
+  --op delete --tid=[id]\n\
+                        delete specific target with [id]. The target must\n\
+                        have no active sessions.\n\
+  --op new --tid=[id] --lun=[lun] --params Path=[path]\n\
+                        add a new logical unit with [lun] to specific\n\
+                        target with [id]. The logical unit is offered\n\
+                        to the initiators. [path] must be block device files\n\
+                        (including LVM and RAID devices) or regular files.\n\
+  --op delete --tid=[id] --lun=[lun]\n\
+                        delete specific logical unit with [lun] that\n\
+                        the target with [id] has.\n\
+  --op delete --tid=[id] --sid=[sid] --cid=[cid]\n\
+                        delete specific connection with [cid] in a session\n\
+                        with [sid] that the target with [id] has.\n\
+                        If the session has no connections after\n\
+                        the operation, the session will be deleted\n\
+                        automatically.\n\
+  --op delete           stop all activity.\n\
+  --op update --tid=[id] --params=key1=value1,key2=value2,...\n\
+                        change iSCSI IET target parameters of specific\n\
+                        target with [id]. You can use parameters in ietd.conf\n\
+                        as a key.\n\
+  --op new --tid=[id] --user --params=[user]=[name],Password=[pass]\n\
+                        add a new account with [pass] for specific target.\n\
+                        [user] could be [IncomingUser] or [OutgoingUser].\n\
+                        If you don't specify a target (omit --tid option),\n\
+                        you add a new account for discovery sessions.\n\
+  --op delete --tid=[id] --user --params=[user]=[name]\n\
+                        delete specific account having [name] of specific\n\
+                        target. [user] could be [IncomingUser] or\n\
+                        [OutgoingUser].\n\
+                        If you don't specify a target (omit --tid option),\n\
+                        you delete the account for discovery sessions.\n\
+  --version             display version and exit\n\
+  --help                display this help and exit\n\
+\n\
+Report bugs to <iscsitarget-devel at sourceforge.net>.\n");
+	}
+	exit(status == 0 ? 0 : -1);
+}
+
+static int ipc_mgmt_connect(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE, strlen(TGT_IPC_NAMESPACE));
+
+	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0)
+		return err;
+
+	return fd;
+}
+
+static void ipc_mgmt_result(char *rbuf)
+{
+	struct nlmsghdr *nlh = (struct nlmsghdr *) rbuf;
+	struct tgtadm_res *res = NLMSG_DATA(nlh);
+
+	if (res->err < 0)
+		fprintf(stderr, "%d\n", res->err);
+
+	if (nlh->nlmsg_len > NLMSG_LENGTH(0))
+		fprintf(stderr, "%s\n", (char *) res + sizeof(*res));
+}
+
+static int ipc_mgmt_call(char *data, int len, char *rbuf)
+{
+	int fd, err;
+	char sbuf[8192];
+	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
+	struct iovec iov;
+	struct msghdr msg;
+
+	memset(sbuf, 0, sizeof(sbuf));
+	memcpy(NLMSG_DATA(nlh), data, len);
+
+	nlh->nlmsg_len = NLMSG_LENGTH(len);
+	nlh->nlmsg_type = 0;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = getpid();
+
+	fd = ipc_mgmt_connect();
+	if (fd < 0)
+		return fd;
+
+	err = write(fd, sbuf, nlh->nlmsg_len);
+	if (err < 0)
+		goto out;
+
+	nlh = (struct nlmsghdr *) rbuf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err < 0)
+		return err;
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		return err;
+
+out:
+	close(fd);
+	return err;
+}
+
+static int str_to_op(char *str)
+{
+	int op;
+
+	if (!strcmp("new", str))
+		op = OP_NEW;
+	else if (!strcmp("delete", str))
+		op = OP_DELETE;
+	else if (!strcmp("update", str))
+		op = OP_UPDATE;
+	else if (!strcmp("show", str))
+		op = OP_SHOW;
+	else
+		op = -1;
+
+	return op;
+}
+
+int main(int argc, char **argv)
+{
+	int ch, longindex;
+	int err = -EINVAL, op = -1, len;
+	int tid = -1;
+	uint32_t cid = 0, set = 0;
+	uint64_t sid = 0, lun = 0;
+	char *params = NULL;
+	struct tgtadm_req *req;
+	char sbuf[8192], rbuf[8912];
+
+	while ((ch = getopt_long(argc, argv, "o:t:s:c:l:p:uvh",
+				 long_options, &longindex)) >= 0) {
+		switch (ch) {
+		case 'o':
+			op = str_to_op(optarg);
+			break;
+		case 't':
+			tid = strtoul(optarg, NULL, 10);
+			set |= SET_TARGET;
+			break;
+		case 's':
+			sid = strtoull(optarg, NULL, 10);
+			set |= SET_SESSION;
+			break;
+		case 'c':
+			cid = strtoul(optarg, NULL, 10);
+			set |= SET_CONNECTION;
+			break;
+		case 'l':
+			lun = strtoull(optarg, NULL, 10);
+			set |= SET_DEVICE;
+			break;
+		case 'p':
+			params = optarg;
+			break;
+		case 'u':
+			set |= SET_USER;
+			break;
+		case 'v':
+/* 			printf("%s version %s\n", program_name, IET_VERSION_STRING); */
+			exit(0);
+			break;
+		case 'h':
+			usage(0);
+			break;
+		default:
+			usage(-1);
+		}
+	}
+
+	if (op < 0) {
+		fprintf(stderr, "You must specify the operation type\n");
+		goto out;
+	}
+
+	if (optind < argc) {
+		fprintf(stderr, "unrecognized: ");
+		while (optind < argc)
+			fprintf(stderr, "%s", argv[optind++]);
+		fprintf(stderr, "\n");
+		usage(-1);
+	}
+
+	memset(sbuf, 0, sizeof(sbuf));
+	memset(rbuf, 0, sizeof(rbuf));
+
+	req = (struct tgtadm_req *) sbuf;
+	req->op = op;
+	req->set = set;
+	req->tid = tid;
+	req->sid = sid;
+	req->lun = lun;
+
+	len = sizeof(struct tgtadm_req);
+	if (params) {
+		memcpy(sbuf + sizeof(struct tgtadm_req), params, strlen(params));
+		len += strlen(params);
+	}
+
+	err = ipc_mgmt_call(sbuf, len, rbuf);
+	ipc_mgmt_result(rbuf);
+out:
+	return err;
+}

Added: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/tgtadm.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -0,0 +1,33 @@
+#ifndef TGTADM_H
+#define TGTADM_H
+
+#define TGT_IPC_NAMESPACE "TGT_IPC_ABSTRACT_NAMESPACE"
+
+#define	SET_TARGET	(1 << 0)
+#define	SET_SESSION	(1 << 1)
+#define	SET_CONNECTION	(1 << 2)
+#define	SET_DEVICE	(1 << 3)
+#define	SET_USER	(1 << 4)
+
+enum tgtadm_op {
+	OP_NEW,
+	OP_DELETE,
+	OP_UPDATE,
+	OP_SHOW,
+};
+
+struct tgtadm_req {
+	int op;
+	uint32_t set;
+
+	int tid;
+	uint64_t sid;
+	int cid;
+	uint64_t lun;
+};
+
+struct tgtadm_res {
+	int err;
+};
+
+#endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/tgtd.c	2005-09-24 08:32:55 UTC (rev 96)
@@ -16,20 +16,26 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <dlfcn.h>
 #include <asm/types.h>
 #include <sys/poll.h>
 #include <sys/signal.h>
 #include <sys/stat.h>
+#include <dirent.h>
 
 #include <tgt_if.h>
 #include "tgtd.h"
 
 int nl_fd, ipc_fd;
 
+#define	MAX_DL_HANDLES	32
+void *dl_handles[MAX_DL_HANDLES];
+
+#define	POLLS_PER_DL	64
+
 enum {
 	POLL_NL,
 	POLL_IPC,
-	POLL_MAX,
 };
 
 static struct option const long_options[] =
@@ -59,6 +65,51 @@
 	exit(1);
 }
 
+/* TODO : proper handling of libraries.*/
+
+static int dl_init(void)
+{
+	char path[PATH_MAX];
+
+	getcwd(path, sizeof(path));
+	strcat(path, "/iscsi/usr/istgt.so");
+
+	dl_handles[0] = dlopen(path, RTLD_LAZY);
+	if (!dl_handles[0]) {
+		fprintf(stderr, "%s\n", dlerror());
+		exit(-1);
+	}
+
+	return 1;
+}
+
+static void dl_config_load(int nr)
+{
+	void (* fn)(void);
+
+	fn = dlsym(dl_handles[0], "initial_config_load");
+	if (!fn) {
+		eprintf("fail to dlsym %s\n", dlerror());
+		exit(-1);
+	}
+
+	fn();
+}
+
+static void dl_poll_init(int nr, struct pollfd *poll_array)
+{
+	int i;
+	void (* fn)(struct pollfd *, int);
+
+	fn = dlsym(dl_handles[0], "poll_init");
+	if (!fn) {
+		eprintf("fail to dlsym %s\n", dlerror());
+		exit(-1);
+	}
+
+	fn(poll_array, POLLS_PER_DL);
+}
+
 static void signal_catch(int signo) {
 }
 
@@ -96,12 +147,13 @@
 	}
 }
 
-static void event_loop(struct pollfd *poll_array)
+static void event_loop(int nr_dls, struct pollfd *poll_array)
 {
-	int err;
+	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DL;
+	void (* fn)(struct pollfd *, int);
 
 	while (1) {
-		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
+		if ((err = poll(poll_array, poll_max, -1)) < 0) {
 			if (errno != EINTR) {
 				eprintf("%d %d\n", err, errno);
 				exit(1);
@@ -115,16 +167,28 @@
 		if (poll_array[POLL_IPC].revents)
 			ipc_event_handle(ipc_fd);
 
+		for (i = 0; i < nr_dls && dl_handles[i]; i++) {
+			fn = dlsym(dl_handles[i], "poll_event");
+			if (!fn) {
+				eprintf("%s\n", dlerror());
+				continue;
+			}
+			fn(poll_array + ((i + 1) * POLLS_PER_DL), POLLS_PER_DL);
+		}
 	}
 }
 
 int main(int argc, char **argv)
 {
 	int ch, longindex;
-	int is_daemon = 1, is_debug = 1;
+	int nr_dls, is_daemon = 1, is_debug = 1;
 	pid_t pid;
-	struct pollfd poll_array[POLL_MAX + 1];
+	struct pollfd *poll_array;
 
+	nr_dls = dl_init();
+	if (nr_dls < 0)
+		nr_dls = 0;
+
 	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':
@@ -163,7 +227,9 @@
 		setsid();
 	}
 
-	memset(poll_array, 0, sizeof(poll_array));
+	poll_array = calloc((nr_dls + 1) * POLLS_PER_DL, sizeof(struct pollfd));
+	if (!poll_array)
+		exit(-ENOMEM);
 
 	nl_fd = nl_open();
 	if (nl_fd < 0)
@@ -178,7 +244,11 @@
 	poll_array[POLL_IPC].fd = ipc_fd;
 	poll_array[POLL_IPC].events = POLLIN;
 
-	event_loop(poll_array);
+	dl_poll_init(nr_dls, poll_array + POLLS_PER_DL);
 
+	dl_config_load(nr_dls);
+
+	event_loop(nr_dls, poll_array);
+
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-09-24 05:32:09 UTC (rev 95)
+++ trunk/usr/tgtd.h	2005-09-24 08:32:55 UTC (rev 96)
@@ -3,26 +3,16 @@
 
 #include "log.h"
 
-#define eprintf(fmt, args...)						\
-do {									\
-	log_error("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#define dprintf(fmt, args...)						\
-do {									\
-	log_debug("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
 extern int nl_fd;
+extern void *dl_handles[];
 
 extern int nl_open(void);
 extern void nl_event_handle(int fd);
-extern int nl_cmd_call(int fd, int type, char *data, int size, int *res);
+extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
 extern int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb,
 			    uint8_t *data, int *len);
-
 #endif



From mchristi at redhat.com  Fri Sep 23 22:50:08 2005
From: mchristi at redhat.com (Mike Christie)
Date: Fri, 23 Sep 2005 15:50:08 -0500
Subject: [Stgt-svn] r89 - in trunk: iscsi/kernel kernel
In-Reply-To: <200509232036.j8NKadWA004457@sheep.berlios.de>
References: <200509232036.j8NKadWA004457@sheep.berlios.de>
Message-ID: <43346A80.7050702@redhat.com>

sorry to post on this but I must ammend the log:


Mike Christie at BerliOS wrote:
> Author: mnc
> Date: 2005-09-23 22:36:38 +0200 (Fri, 23 Sep 2005)
> New Revision: 89
> 
> Modified:
>    trunk/iscsi/kernel/iscsi.c
>    trunk/kernel/tgt.c
>    trunk/kernel/tgt.h
>    trunk/kernel/tgt_device.h
>    trunk/kernel/tgt_protocol.h
>    trunk/kernel/tgt_scsi.c
>    trunk/kernel/tgt_vsd.c
> Log:
> create buffer from create cmnd; for now trust expected transfer length. This allows us to have a vsd or
sd get a buffer for the transfer without completely parsing the command (can we completely trust this value,
HW cards have something similar). This is needed to make passthrough very simple. Target drivers should
konw when they have to allocate or not allocate a buffer since it should not know if the command is going

This should state that target drivers should _not_ know when they have to allocate or allocate a buffer.
They should jsut get one when they need it. I just mean that they should not have to check the
scb/cdb to know anything about this. TGT should just do all this for it.


From tomo at berlios.de  Sat Sep 24 14:12:38 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 24 Sep 2005 14:12:38 +0200
Subject: [Stgt-svn] r97 - in trunk: iscsi/kernel kernel
Message-ID: <200509241212.j8OCCcnL021333@sheep.berlios.de>

Author: tomo
Date: 2005-09-24 14:12:38 +0200 (Sat, 24 Sep 2005)
New Revision: 97

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt_scsi.c
Log:
Fix memory leak.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-24 08:32:55 UTC (rev 96)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 12:12:38 UTC (rev 97)
@@ -757,7 +757,7 @@
 			send_r2t(cmnd);
 	} else {
 		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
- 
+
 		set_cmnd_waitio(cmnd);
 		proto->queue_cmd(cmnd->tc, scsi_cmnd_done);
 	}

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 08:32:55 UTC (rev 96)
+++ trunk/kernel/tgt.c	2005-09-24 12:12:38 UTC (rev 97)
@@ -561,7 +561,7 @@
 static void tgt_free_buffer(struct tgt_cmd *cmd)
 {
 	int i;
-	
+
 	for (i = 0; i < cmd->sg_count; i++)
 		__free_page(cmd->sg[i].page);
 	kfree(cmd->sg);
@@ -573,7 +573,7 @@
 
 	dprintk("cid %llu\n", cmd->cid);
 
-	kfree(cmd->sg);
+	tgt_free_buffer(cmd);
 
 	spin_lock_irqsave(&cmd_hash_lock, flags);
 	list_del(&cmd->hash_list);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-24 08:32:55 UTC (rev 96)
+++ trunk/kernel/tgt_scsi.c	2005-09-24 12:12:38 UTC (rev 97)
@@ -48,9 +48,9 @@
  */
 static struct tgt_cmd *
 scsi_tgt_create_cmd(struct tgt_session *session, void *tgt_priv, uint8_t *scb,
-		     uint32_t data_len, enum dma_data_direction data_dir,
-		     uint8_t *lun, int lun_size,
-		     void (*done)(struct tgt_cmd *))
+		    uint32_t data_len, enum dma_data_direction data_dir,
+		    uint8_t *lun, int lun_size,
+		    void (*done)(struct tgt_cmd *))
 {
 	struct tgt_device *device;
 	struct tgt_cmd *cmd;



From tomo at berlios.de  Sat Sep 24 15:29:42 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 24 Sep 2005 15:29:42 +0200
Subject: [Stgt-svn] r98 - in trunk/iscsi: include kernel usr
Message-ID: <200509241329.j8ODTgnH026444@sheep.berlios.de>

Author: tomo
Date: 2005-09-24 15:29:42 +0200 (Sat, 24 Sep 2005)
New Revision: 98

Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/param.c
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/param.c
Log:
Kill unused IET old 'wthreads' parameter.

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-24 12:12:38 UTC (rev 97)
+++ trunk/iscsi/include/iet_u.h	2005-09-24 13:29:42 UTC (rev 98)
@@ -59,7 +59,6 @@
 };
 
 enum {
-	key_wthreads,
 	key_target_type,
 	key_queued_cmnds,
 	target_key_last,
@@ -119,14 +118,8 @@
 	} k;
 } __attribute__ ((aligned (sizeof(uint64_t))));
 
-#define	DEFAULT_NR_WTHREADS	8
-#define	MIN_NR_WTHREADS		1
-#define	MAX_NR_WTHREADS		128
-
 #define	DEFAULT_NR_QUEUED_CMNDS	32
 #define	MIN_NR_QUEUED_CMNDS	1
 #define	MAX_NR_QUEUED_CMNDS	256
 
-#define NETLINK_IET	21
-
 #endif

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-24 12:12:38 UTC (rev 97)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-24 13:29:42 UTC (rev 98)
@@ -40,7 +40,6 @@
 };
 
 struct iscsi_trgt_param {
-	int wthreads;
 	int target_type;
 	int queued_cmnds;
 };
@@ -148,7 +147,6 @@
 	struct iovec write_iov[ISCSI_CONN_IOV_MAX];
 	struct iovec *write_iop;
 
-/* 	struct tio *write_tcmnd; */
 	struct scatterlist *write_tcmnd;
 
 	u32 write_size;
@@ -297,6 +295,7 @@
 #define clear_cmnd_pending(cmnd)	clear_bit(CMND_pending, &(cmnd)->flags)
 #define cmnd_pending(cmnd)	test_bit(CMND_pending, &(cmnd)->flags)
 
+/* We still use 'IET' id. Maybe someday, we get own id. */
 
 #define VENDOR_ID	"IET"
 #define PRODUCT_ID	"VIRTUAL-DISK"

Modified: trunk/iscsi/kernel/param.c
===================================================================
--- trunk/iscsi/kernel/param.c	2005-09-24 12:12:38 UTC (rev 97)
+++ trunk/iscsi/kernel/param.c	2005-09-24 13:29:42 UTC (rev 98)
@@ -109,7 +109,6 @@
 {
 	u32 *iparam = info->target_param;
 
-	CHECK_PARAM(info, iparam, wthreads, MIN_NR_WTHREADS, MAX_NR_WTHREADS);
 	CHECK_PARAM(info, iparam, queued_cmnds, MIN_NR_QUEUED_CMNDS, MAX_NR_QUEUED_CMNDS);
 }
 

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-24 12:12:38 UTC (rev 97)
+++ trunk/iscsi/kernel/target.c	2005-09-24 13:29:42 UTC (rev 98)
@@ -42,7 +42,6 @@
 };
 
 static struct iscsi_trgt_param default_target_param = {
-	.wthreads = DEFAULT_NR_WTHREADS,
 	.target_type = 0,
 	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
 };

Modified: trunk/iscsi/usr/param.c
===================================================================
--- trunk/iscsi/usr/param.c	2005-09-24 12:12:38 UTC (rev 97)
+++ trunk/iscsi/usr/param.c	2005-09-24 13:29:42 UTC (rev 98)
@@ -284,7 +284,6 @@
 #define	SET_KEY_VALUES(x)	DEFAULT_NR_##x,MIN_NR_##x, MAX_NR_##x
 
 struct iscsi_key target_keys[] = {
-	{"Wthreads", SET_KEY_VALUES(WTHREADS), &minimum_ops},
 	{"Type", 0, 0, 16, &minimum_ops},
 	{"QueuedCommands", SET_KEY_VALUES(QUEUED_CMNDS), &minimum_ops},
 	{NULL,},



From tomo at berlios.de  Sun Sep 25 10:42:02 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 10:42:02 +0200
Subject: [Stgt-svn] r99 - trunk/iscsi/usr
Message-ID: <200509250842.j8P8g2eY032734@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 10:42:02 +0200 (Sun, 25 Sep 2005)
New Revision: 99

Modified:
   trunk/iscsi/usr/session.c
Log:
Kill session_test requring kernel service.

Modified: trunk/iscsi/usr/session.c
===================================================================
--- trunk/iscsi/usr/session.c	2005-09-24 13:29:42 UTC (rev 98)
+++ trunk/iscsi/usr/session.c	2005-09-25 08:42:02 UTC (rev 99)
@@ -70,78 +70,27 @@
 	return NULL;
 }
 
-static int session_test(u32 t_tid, u64 t_sid)
-{
-	FILE *f;
-	char buf[8192], *p;
-	u32 tid;
-	u64 sid;
-	int err = -ENOENT, find = 0;
-
-	if ((f = fopen(PROC_SESSION, "r")) == NULL) {
-		fprintf(stderr, "Can't open %s\n", PROC_SESSION);
-		return -errno;
-	}
-
-	while (fgets(buf, sizeof(buf), f)) {
-		p = buf;
-		while (isspace((int) *p))
-			p++;
-
-		if (!strncmp(p, "tid:", 4)) {
-			if (sscanf(p, "tid:%u", &tid) != 1) {
-				err = -EIO;
-				goto out;
-			}
-			if (tid == t_tid)
-				find = 1;
-			else
-				find = 0;
-		} else if (!strncmp(p, "sid:", 4)) {
-			if (!find)
-				continue;
-			if (sscanf(p, "sid:%" SCNu64, &sid) != 1) {
-				err = -EIO;
-				goto out;
-			}
-
-			if (sid == t_sid) {
-				err = 0;
-				goto out;
-			}
-		}
-	}
-
-out:
-	fclose(f);
-
-	return err;
-}
-
 void session_create(struct connection *conn)
 {
 	struct session *session;
 	uint64_t sid;
-	static u16 tsih = 1;
+	static uint16_t tsih = 1;
 
-	if (!(session = session_alloc(conn->tid)))
-		return;
-
-	memcpy(session->isid, conn->isid, sizeof(session->isid));
-	session->tsih = tsih;
-
+	/* First, we need to get an available sid. */
 	while (1) {
-		sid = sid64(session->isid, session->tsih);
-		int err = session_test(conn->tid, sid);
-
-		if (err == -ENOENT)
+		sid = sid64(conn->isid, tsih);
+		if (!session_find_id(conn->tid, sid))
 			break;
-		else if (err < 0)
-			return;
-		session->tsih++;
+		tsih++;
 	}
-	tsih = session->tsih + 1;
 
+	session = session_alloc(conn->tid);
+	if (!session)
+		return;
+
+	memcpy(session->isid, conn->isid, sizeof(session->isid));
+	session->tsih = tsih++;
+
 	conn->session = session;
 	conn->session->initiator = strdup(conn->initiator);
 



From tomo at berlios.de  Sun Sep 25 12:06:53 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 12:06:53 +0200
Subject: [Stgt-svn] r100 - trunk/iscsi/usr
Message-ID: <200509251006.j8PA6r5H007920@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 12:06:52 +0200 (Sun, 25 Sep 2005)
New Revision: 100

Modified:
   trunk/iscsi/usr/conn.c
   trunk/iscsi/usr/iscsid.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/session.c
Log:
Kill conn_test requring kernel service.

Modified: trunk/iscsi/usr/conn.c
===================================================================
--- trunk/iscsi/usr/conn.c	2005-09-25 08:42:02 UTC (rev 99)
+++ trunk/iscsi/usr/conn.c	2005-09-25 10:06:52 UTC (rev 100)
@@ -17,6 +17,18 @@
 #define ISCSI_CONN_NEW		1
 #define ISCSI_CONN_EXIT		5
 
+void conn_add_to_session(struct connection *conn, struct session *session)
+{
+	if (!list_empty(&conn->clist)) {
+		eprintf("%" PRIx64 " %u\n",
+			sid64(session->isid, session->tsih), conn->cid);
+		exit(0);
+	}
+
+	conn->session = session;
+	insque(&conn->clist, &session->conn_list);
+}
+
 struct connection *conn_alloc(void)
 {
 	struct connection *conn;
@@ -28,77 +40,28 @@
 	conn->state = STATE_FREE;
 	param_set_defaults(conn->session_param, session_keys);
 
+	INIT_LIST_HEAD(&conn->clist);
+
 	return conn;
 }
 
 void conn_free(struct connection *conn)
 {
+	remque(&conn->clist);
 	free(conn->initiator);
 	free(conn);
 }
 
-int conn_test(struct connection *conn)
+struct connection *conn_find(struct session *session, u32 cid)
 {
-	FILE *f;
-	char buf[8192], *p;
-	u32 tid, t_tid, cid, t_cid;
-	u64 sid, t_sid;
-	int err = -ENOENT, find = 0;
+	struct connection *conn;
 
-	t_tid = conn->tid;
-	t_sid = sid64(conn->session->isid, conn->session->tsih);
-	t_cid = conn->cid;
-
-	if ((f = fopen(PROC_SESSION, "r")) == NULL) {
-		fprintf(stderr, "Can't open %s\n", PROC_SESSION);
-		return -errno;
+	list_for_each_entry(conn, &session->conn_list, clist) {
+		if (conn->cid == cid)
+			return conn;
 	}
 
-	while (fgets(buf, sizeof(buf), f)) {
-		p = buf;
-		while (isspace((int) *p))
-			p++;
-
-		if (!strncmp(p, "tid:", 4)) {
-			if (sscanf(p, "tid:%u", &tid) != 1) {
-				err = -EIO;
-				goto out;
-			}
-			if (tid == t_tid)
-				find = 1;
-			else
-				find = 0;
-		} else if (!strncmp(p, "sid:", 4)) {
-			if (!find)
-				continue;
-			if (sscanf(p, "sid:%" SCNu64, &sid) != 1) {
-				err = -EIO;
-				goto out;
-			}
-
-			if (sid == t_sid)
-				find = 1;
-			else
-				find = 0;
-		} else if (!strncmp(p, "cid:", 4)) {
-			if (!find)
-				continue;
-			if (sscanf(p, "cid:%u", &cid) != 1) {
-				err = -EIO;
-				goto out;
-			}
-
-			if (cid == t_cid) {
-				err = 0;
-				goto out;
-			}
-		}
-	}
-
-out:
-	fclose(f);
-
-	return err;
+	return NULL;
 }
 
 void conn_take_fd(struct connection *conn, int fd)

Modified: trunk/iscsi/usr/iscsid.c
===================================================================
--- trunk/iscsi/usr/iscsid.c	2005-09-25 08:42:02 UTC (rev 99)
+++ trunk/iscsi/usr/iscsid.c	2005-09-25 10:06:52 UTC (rev 100)
@@ -169,7 +169,6 @@
 
 static void login_security_done(struct connection *conn)
 {
-	int err;
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
 	struct session *session;
@@ -177,23 +176,24 @@
 	if (!conn->tid)
 		return;
 
-	if ((session = session_find_name(conn->tid, conn->initiator, req->isid))) {
+	session = session_find_name(conn->tid, conn->initiator, req->isid);
+	if (session) {
 		if (!req->tsih) {
-			uint64_t sid = sid64(session->isid, session->tsih);
 			/* do session reinstatement */
+			/* We need to close all connections in this session */
 /* 			session_conns_close(conn->tid, sid); */
-			session = NULL;
+/* 			session = NULL; */
 		} else if (req->tsih != session->tsih) {
 			/* fail the login */
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
 			return;
-		} else if ((err = conn_test(conn)) == -ENOENT) {
+		} else if (conn_find(session, conn->cid)) {
 			/* do connection reinstatement */
 		}
 		/* add a new connection to the session */
-		conn->session = session;
+		conn_add_to_session(conn, session);
 	} else {
 		if (req->tsih) {
 			/* fail the login */
@@ -202,7 +202,10 @@
 			conn->state = STATE_EXIT;
 			return;
 		}
-		/* instantiate a new session */
+		/*
+		 * We do nothing here and instantiate a new session
+		 * later at login_finish().
+		 */
 	}
 }
 

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-25 08:42:02 UTC (rev 99)
+++ trunk/iscsi/usr/iscsid.h	2005-09-25 10:06:52 UTC (rev 100)
@@ -47,6 +47,7 @@
 	uint8_t isid[6];
 	uint16_t tsih;
 
+	struct qelem conn_list;
 	int conn_cnt;
 };
 
@@ -55,6 +56,7 @@
 	int iostate;
 	int fd;
 
+	struct qelem clist;
 	struct session *session;
 
 	u32 tid;
@@ -150,11 +152,12 @@
 /* conn.c */
 extern struct connection *conn_alloc(void);
 extern void conn_free(struct connection *conn);
-extern int conn_test(struct connection *conn);
+extern struct connection * conn_find(struct session *session, u32 cid);
 extern void conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
 extern void conn_free_pdu(struct connection *conn);
+extern void conn_add_to_session(struct connection *conn, struct session *session);
 
 /* iscsid.c */
 extern int iscsi_debug;

Modified: trunk/iscsi/usr/session.c
===================================================================
--- trunk/iscsi/usr/session.c	2005-09-25 08:42:02 UTC (rev 99)
+++ trunk/iscsi/usr/session.c	2005-09-25 10:06:52 UTC (rev 100)
@@ -31,6 +31,8 @@
 	INIT_LIST_HEAD(&session->slist);
 	insque(&session->slist, &target->sessions_list);
 
+	INIT_LIST_HEAD(&session->conn_list);
+
 	return session;
 }
 
@@ -91,7 +93,7 @@
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = tsih++;
 
-	conn->session = session;
+	conn_add_to_session(conn, session);
 	conn->session->initiator = strdup(conn->initiator);
 
 	log_debug("session_create: %#" PRIx64, sid);
@@ -105,8 +107,11 @@
 {
 	uint64_t sid = sid64(session->isid, session->tsih);
 
-	eprintf("session_remove: %#"  PRIx64, sid);
+	eprintf("%#"  PRIx64 "\n", sid);
 
+	if (!list_empty(&session->conn_list))
+		eprintf("%" PRIx64 " conn_list is not null\n", sid);
+
 	if (!session->tsih)
 		ki->session_destroy(session->target->tid, sid);
 



From tomo at berlios.de  Sun Sep 25 12:20:56 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 12:20:56 +0200
Subject: [Stgt-svn] r101 - in trunk/iscsi: kernel usr
Message-ID: <200509251020.j8PAKu10009120@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 12:20:55 +0200 (Sun, 25 Sep 2005)
New Revision: 101

Removed:
   trunk/iscsi/kernel/event.c
Modified:
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/conn.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/session.c
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/iscsid.h
Log:
The target software does not use /proc anymore.


Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/config.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -4,8 +4,6 @@
  * This code is licenced under the GPL.
  */
 
-#include <linux/proc_fs.h>
-
 #include <tgt.h>
 #include <tgt_target.h>
 
@@ -13,59 +11,6 @@
 #include "iscsi.h"
 #include "iscsi_dbg.h"
 
-struct proc_entries {
-	const char *name;
-	struct file_operations *fops;
-};
-
-static struct proc_entries iet_proc_entries[] =
-{
-/* 	{"volume", &volume_seq_fops}, */
-	{"session", &session_seq_fops},
-};
-
-static struct proc_dir_entry *proc_iet_dir;
-
-void iet_procfs_exit(void)
-{
-	int i;
-
-	if (!proc_iet_dir)
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(iet_proc_entries); i++)
-		remove_proc_entry(iet_proc_entries[i].name, proc_iet_dir);
-
-	remove_proc_entry(proc_iet_dir->name, proc_iet_dir->parent);
-}
-
-int iet_procfs_init(void)
-{
-	int i;
-	struct proc_dir_entry *ent;
-
-	if (!(proc_iet_dir = proc_mkdir("net/iet", 0)))
-		goto err;
-
-	proc_iet_dir->owner = THIS_MODULE;
-
-	for (i = 0; i < ARRAY_SIZE(iet_proc_entries); i++) {
-		ent = create_proc_entry(iet_proc_entries[i].name, 0, proc_iet_dir);
-		if (ent)
-			ent->proc_fops = iet_proc_entries[i].fops;
-		else
-			goto err;
-	}
-
-	return 0;
-
-err:
-	if (proc_iet_dir)
-		iet_procfs_exit();
-
-	return -ENOMEM;
-}
-
 static int add_conn(struct iscsi_target *target, struct conn_info *info)
 {
 	struct iscsi_session *session;

Modified: trunk/iscsi/kernel/conn.c
===================================================================
--- trunk/iscsi/kernel/conn.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/conn.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -12,57 +12,6 @@
 #include "iscsi_dbg.h"
 #include "digest.h"
 
-static void print_conn_state(char *p, size_t size, unsigned long state)
-{
-	if (test_bit(CONN_ACTIVE, &state))
-		snprintf(p, size, "%s", "active");
-	else if (test_bit(CONN_CLOSING, &state))
-		snprintf(p, size, "%s", "closing");
-	else
-		snprintf(p, size, "%s", "unknown");
-}
-
-static void print_digest_state(char *p, size_t size, unsigned long flags)
-{
-	if (DIGEST_NONE & flags)
-		snprintf(p, size, "%s", "none");
-	else if (DIGEST_CRC32C & flags)
-		snprintf(p, size, "%s", "crc32c");
-	else
-		snprintf(p, size, "%s", "unknown");
-}
-
-void conn_info_show(struct seq_file *seq, struct iscsi_session *session)
-{
-	struct iscsi_conn *conn;
-	struct sock *sk;
-	char buf[64];
-
-	list_for_each_entry(conn, &session->conn_list, list) {
-		sk = conn->sock->sk;
-		switch (sk->sk_family) {
-		case AF_INET:
-			snprintf(buf, sizeof(buf),
-				 "%u.%u.%u.%u", NIPQUAD(inet_sk(sk)->daddr));
-			break;
-		case AF_INET6:
-			snprintf(buf, sizeof(buf),
-				 "[%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x]",
-				 NIP6(inet6_sk(sk)->daddr));
-			break;
-		default:
-			break;
-		}
-		seq_printf(seq, "\t\tcid:%u ip:%s ", conn->cid, buf);
-		print_conn_state(buf, sizeof(buf), conn->state);
-		seq_printf(seq, "state:%s ", buf);
-		print_digest_state(buf, sizeof(buf), conn->hdigest_type);
-		seq_printf(seq, "hd:%s ", buf);
-		print_digest_state(buf, sizeof(buf), conn->ddigest_type);
-		seq_printf(seq, "dd:%s\n", buf);
-	}
-}
-
 struct iscsi_conn *conn_lookup(struct iscsi_session *session, u16 cid)
 {
 	struct iscsi_conn *conn;

Deleted: trunk/iscsi/kernel/event.c
===================================================================
--- trunk/iscsi/kernel/event.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/event.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -1,109 +0,0 @@
-/*
- * Event notification code.
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * This code is licenced under the GPL.
- *
- * Some functions are based on audit code.
- */
-
-#include <net/tcp.h>
-#include "iet_u.h"
-#include "iscsi_dbg.h"
-
-static struct sock *nl;
-static u32 ietd_pid;
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	u32 uid, pid, seq;
-	char *data;
-
-	pid  = NETLINK_CREDS(skb)->pid;
-	uid  = NETLINK_CREDS(skb)->uid;
-	seq  = nlh->nlmsg_seq;
-	data = NLMSG_DATA(nlh);
-
-	ietd_pid = pid;
-
-	return 0;
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	struct nlmsghdr	*nlh;
-	u32 rlen;
-
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *)skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		if ((err = event_recv_msg(skb, nlh))) {
-			netlink_ack(skb, nlh, -err);
-		} else if (nlh->nlmsg_flags & NLM_F_ACK)
-			netlink_ack(skb, nlh, 0);
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
-static int notify(void *data, int len, int gfp_mask)
-{
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	static u32 seq = 0;
-
-	if (!(skb = alloc_skb(NLMSG_SPACE(len), gfp_mask)))
-		return -ENOMEM;
-
-	nlh = __nlmsg_put(skb, ietd_pid, seq++, NLMSG_DONE,
-			  len - sizeof(*nlh), 0);
-	memcpy(NLMSG_DATA(nlh), data, len);
-
-	return netlink_unicast(nl, skb, ietd_pid, 0);
-}
-
-int event_send(u32 tid, u64 sid, u32 cid, u32 state, int atomic)
-{
-	int err;
-	struct iet_event event;
-
-	event.tid = tid;
-	event.sid = sid;
-	event.cid = cid;
-	event.state = state;
-
-	err = notify(&event, NLMSG_SPACE(sizeof(struct iet_event)), 0);
-
-	return err;
-}
-
-int event_init(void)
-{
-	nl = netlink_kernel_create(NETLINK_IET, 1, event_recv, THIS_MODULE);
-	if (!nl)
-		return -ENOMEM;
-	else
-		return 0;
-}
-
-void event_exit(void)
-{
-	if (nl)
-		sock_release(nl->sk_socket);
-}

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -1593,8 +1593,6 @@
 
 static void iscsi_exit(void)
 {
-	iet_procfs_exit();
-
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
 
@@ -1607,9 +1605,6 @@
 
 	printk("iSCSI Enterprise Target Software - version %s\n", IET_VERSION_STRING);
 
-	if ((err = iet_procfs_init()) < 0)
-		goto err;
-
 	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
 					     0, 0, NULL, NULL);
 	if (!iscsi_cmnd_cache)

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-25 10:20:55 UTC (rev 101)
@@ -8,7 +8,6 @@
 #define __ISCSI_H__
 
 #include <linux/pagemap.h>
-#include <linux/seq_file.h>
 #include <linux/mm.h>
 #include <linux/crypto.h>
 #include <net/sock.h>
@@ -56,7 +55,6 @@
 };
 
 struct iscsi_cmnd;
-struct tgt_target;
 
 enum iscsi_device_state {
 	IDEV_RUNNING,
@@ -65,15 +63,12 @@
 
 struct iscsi_target {
 	int tid;
-	struct list_head t_list;
 
 	struct iscsi_sess_param sess_param;
 	struct iscsi_trgt_param trgt_param;
 
 	struct list_head session_list;
-
 	struct network_thread_info nthread_info;
-
 	struct semaphore target_sem;
 
 	struct tgt_target *tt;
@@ -164,8 +159,6 @@
 	unsigned int datasize;
 };
 
-typedef void (iet_show_info_t)(struct seq_file *seq, struct iscsi_target *target);
-
 struct iscsi_cmnd {
 	struct list_head list;
 	struct list_head conn_list;
@@ -213,7 +206,6 @@
 extern int conn_del(struct iscsi_session *, struct conn_info *);
 extern int conn_free(struct iscsi_conn *);
 extern void conn_close(struct iscsi_conn *);
-extern void conn_info_show(struct seq_file *, struct iscsi_session *);
 
 /* nthread.c */
 extern int nthread_init(struct iscsi_target *);
@@ -224,19 +216,14 @@
 /* target.c */
 extern int target_lock(struct iscsi_target *, int);
 extern void target_unlock(struct iscsi_target *);
-struct iscsi_target *target_lookup_by_id(u32);
 extern int target_add(struct tgt_target *);
 extern void target_del(struct tgt_target *);
 
 /* config.c */
 extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
-extern int iet_procfs_init(void);
-extern void iet_procfs_exit(void);
-extern int iet_info_show(struct seq_file *, iet_show_info_t *);
 extern int event_send(struct tgt_target *tgt, u32 tid, u64 sid, u32 cid, u32 state);
 
 /* session.c */
-extern struct file_operations session_seq_fops;
 extern struct iscsi_session *session_lookup(struct iscsi_target *, u64);
 extern int session_add(struct iscsi_target *, struct session_info *);
 extern int session_del(struct iscsi_target *, u64);

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/session.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -119,32 +119,3 @@
 
 	return session_free(session);
 }
-
-static void iet_session_info_show(struct seq_file *seq, struct iscsi_target *target)
-{
-	struct iscsi_session *session;
-
-	list_for_each_entry(session, &target->session_list, list) {
-		seq_printf(seq, "\tsid:%llu initiator:%s\n",
-			   (unsigned long long) session->sid, session->initiator);
-		conn_info_show(seq, session);
-	}
-}
-
-static int iet_sessions_info_show(struct seq_file *seq, void *v)
-{
-	return iet_info_show(seq, iet_session_info_show);
-}
-
-static int iet_session_seq_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, iet_sessions_info_show, NULL);
-}
-
-struct file_operations session_seq_fops = {
-	.owner		= THIS_MODULE,
-	.open		= iet_session_seq_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/kernel/target.c	2005-09-25 10:20:55 UTC (rev 101)
@@ -13,11 +13,7 @@
 #include <tgt_device.h>
 #include <tgt_target.h>
 
-#define	MAX_NR_TARGETS	(1UL << 30)
-
-static LIST_HEAD(target_list);
 static DECLARE_MUTEX(target_list_sem);
-static u32 nr_targets;
 
 static struct iscsi_sess_param default_session_param = {
 	.initial_r2t = 1,
@@ -63,83 +59,27 @@
 	up(&target->target_sem);
 }
 
-static struct iscsi_target *__target_lookup_by_id(u32 id)
+int target_add(struct tgt_target *tt)
 {
-	struct iscsi_target *target;
-
-	list_for_each_entry(target, &target_list, t_list) {
-		if (target->tid == id)
-			return target;
-	}
-	return NULL;
-}
-
-struct iscsi_target *target_lookup_by_id(u32 id)
-{
-	struct iscsi_target *target;
-
-	down(&target_list_sem);
-	target = __target_lookup_by_id(id);
-	up(&target_list_sem);
-
-	return target;
-}
-
-static int target_thread_start(struct iscsi_target *target)
-{
-	int err;
-
-	if ((err = nthread_start(target)) < 0)
-		return err;
-
-	return err;
-}
-
-static void target_thread_stop(struct iscsi_target *target)
-{
-	nthread_stop(target);
-}
-
-static int iscsi_target_create(struct tgt_target *tt)
-{
 	int err = -EINVAL;
 	struct iscsi_target *target = tt->tt_data;
 
+	down(&target_list_sem);
+
 	memset(target, 0, sizeof(*target));
 
 	target->tt = tt;
+	target->tid = target->tt->tid;
+
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
 	init_MUTEX(&target->target_sem);
-
 	INIT_LIST_HEAD(&target->session_list);
-	list_add(&target->t_list, &target_list);
 
 	nthread_init(target);
+	err = nthread_start(target);
 
-	err = target_thread_start(target);
-	if (err < 0)
-		return err;
-
-	target->tid = target->tt->tid;
-	return 0;
-}
-
-int target_add(struct tgt_target *tt)
-{
-	int err = -EEXIST;
-
-	down(&target_list_sem);
-
-	if (nr_targets > MAX_NR_TARGETS) {
-		err = -EBUSY;
-		goto out;
-	}
-
-	if (!(err = iscsi_target_create(tt)))
-		nr_targets++;
-out:
 	up(&target_list_sem);
 
 	return err;
@@ -154,38 +94,11 @@
 
 	target_lock(target, 0);
 
-	if (!list_empty(&target->session_list))
-		BUG();
+	/* kernel may crash until tgt supports lifetime management. */
+	BUG_ON(!list_empty(&target->session_list));
 
-	list_del(&target->t_list);
-	nr_targets--;
-
 	target_unlock(target);
 	up(&target_list_sem);
 
-	target_thread_stop(target);
+	nthread_stop(target);
 }
-
-int iet_info_show(struct seq_file *seq, iet_show_info_t *func)
-{
-	int err;
-	struct iscsi_target *target;
-
-	if ((err = down_interruptible(&target_list_sem)) < 0)
-		return err;
-
-	list_for_each_entry(target, &target_list, t_list) {
-		seq_printf(seq, "tid:%u\n", target->tid);
-
-		if ((err = target_lock(target, 1)) < 0)
-			break;
-
-		func(seq, target);
-
-		target_unlock(target);
-	}
-
-	up(&target_list_sem);
-
-	return 0;
-}

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-25 10:06:52 UTC (rev 100)
+++ trunk/iscsi/usr/iscsid.h	2005-09-25 10:20:55 UTC (rev 101)
@@ -25,8 +25,6 @@
 	(uint64_t) tsih << 48;					\
 })
 
-#define PROC_SESSION	"/proc/net/iet/session"
-
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;



From tomo at berlios.de  Sun Sep 25 12:42:10 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 12:42:10 +0200
Subject: [Stgt-svn] r102 - trunk/iscsi/kernel
Message-ID: <200509251042.j8PAgAVm026945@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 12:42:08 +0200 (Sun, 25 Sep 2005)
New Revision: 102

Modified:
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/session.c
Log:
Cleanup of iscsi session stuff.

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-25 10:20:55 UTC (rev 101)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-25 10:42:08 UTC (rev 102)
@@ -81,7 +81,6 @@
 	struct list_head list;
 	struct iscsi_target *target;
 
-	char *initiator;
 	u64 sid;
 
 	u32 exp_cmd_sn;

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-09-25 10:20:55 UTC (rev 101)
+++ trunk/iscsi/kernel/session.c	2005-09-25 10:42:08 UTC (rev 102)
@@ -21,17 +21,21 @@
 	return NULL;
 }
 
-static int iet_session_alloc(struct iscsi_target *target, struct session_info *info)
+int session_add(struct iscsi_target *target, struct session_info *info)
 {
-	int err, i;
 	struct iscsi_session *session;
+	int i;
 
 	dprintk(D_SETUP, "%p %u %#Lx\n", target, target->tid,
 		(unsigned long long) info->sid);
 
-	if (!(session = kmalloc(sizeof(*session), GFP_KERNEL)))
+	session = session_lookup(target, info->sid);
+	if (session)
+		return -EEXIST;
+
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
+	if (!session)
 		return -ENOMEM;
-	memset(session, 0, sizeof(*session));
 
 	session->target = target;
 	session->sid = info->sid;
@@ -41,13 +45,6 @@
 	session->exp_cmd_sn = info->exp_cmd_sn;
 	session->max_cmd_sn = info->max_cmd_sn;
 
-	session->initiator = kmalloc(sizeof(info->initiator_name), GFP_KERNEL);
-	if (!session->initiator) {
-		err = -ENOMEM;
-		goto err;
-	}
-	memcpy(session->initiator, info->initiator_name, sizeof(info->initiator_name));
-
 	INIT_LIST_HEAD(&session->conn_list);
 	INIT_LIST_HEAD(&session->pending_list);
 
@@ -62,60 +59,36 @@
 	session->ts = tgt_session_create(target->tt, 64, NULL, NULL);
 
 	return 0;
-err:
-	if (session) {
-		kfree(session->initiator);
-		kfree(session);
-	}
-	return err;
 }
 
-int session_add(struct iscsi_target *target, struct session_info *info)
+int session_del(struct iscsi_target *target, u64 sid)
 {
+	int i;
 	struct iscsi_session *session;
-	int err = -EEXIST;
 
-	if ((session = session_lookup(target, info->sid)))
-		return err;
+	session = session_lookup(target, sid);
+	if (!session)
+		return -ENOENT;
 
-	err = iet_session_alloc(target, info);
-
-	return err;
-}
-
-static int session_free(struct iscsi_session *session)
-{
-	int i;
-
 	dprintk(D_SETUP, "%#Lx\n", (unsigned long long) session->sid);
 
-	assert(list_empty(&session->conn_list));
+	if (!list_empty(&session->conn_list)) {
+		eprintk("%llu still have connections\n",
+			(unsigned long long) session->sid);
+		return -EBUSY;
+	}
 
+	BUG_ON(!list_empty(&session->conn_list));
+
 	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++) {
 		if (!list_empty(&session->cmnd_hash[i]))
 			BUG();
 	}
 
 	list_del(&session->list);
-	kfree(session->initiator);
 
 	tgt_session_destroy(session->ts);
 	kfree(session);
 
 	return 0;
 }
-
-int session_del(struct iscsi_target *target, u64 sid)
-{
-	struct iscsi_session *session;
-
-	if (!(session = session_lookup(target, sid)))
-		return -ENOENT;
-
-	if (!list_empty(&session->conn_list)) {
-		eprintk("%llu still have connections\n", (unsigned long long) session->sid);
-		return -EBUSY;
-	}
-
-	return session_free(session);
-}



From tomo at berlios.de  Sun Sep 25 13:02:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 13:02:13 +0200
Subject: [Stgt-svn] r103 - trunk/iscsi/kernel
Message-ID: <200509251102.j8PB2CW7005619@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 13:02:11 +0200 (Sun, 25 Sep 2005)
New Revision: 103

Modified:
   trunk/iscsi/kernel/conn.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/session.c
Log:
Cleanup of iSCSI connection code.

Modified: trunk/iscsi/kernel/conn.c
===================================================================
--- trunk/iscsi/kernel/conn.c	2005-09-25 10:42:08 UTC (rev 102)
+++ trunk/iscsi/kernel/conn.c	2005-09-25 11:02:11 UTC (rev 103)
@@ -12,7 +12,7 @@
 #include "iscsi_dbg.h"
 #include "digest.h"
 
-struct iscsi_conn *conn_lookup(struct iscsi_session *session, u16 cid)
+static struct iscsi_conn *conn_lookup(struct iscsi_session *session, u16 cid)
 {
 	struct iscsi_conn *conn;
 
@@ -23,7 +23,7 @@
 	return NULL;
 }
 
-static void iet_state_change(struct sock *sk)
+static void state_change(struct sock *sk)
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
 	struct iscsi_target *target = conn->session->target;
@@ -36,7 +36,7 @@
 	target->nthread_info.old_state_change(sk);
 }
 
-static void iet_data_ready(struct sock *sk, int len)
+static void data_ready(struct sock *sk, int len)
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
 	struct iscsi_target *target = conn->session->target;
@@ -45,7 +45,7 @@
 	target->nthread_info.old_data_ready(sk, len);
 }
 
-static void iet_socket_bind(struct iscsi_conn *conn)
+static void socket_bind(struct iscsi_conn *conn)
 {
 	int opt = 1;
 	mm_segment_t oldfs;
@@ -59,15 +59,16 @@
 
 	write_lock(&conn->sock->sk->sk_callback_lock);
 	target->nthread_info.old_state_change = conn->sock->sk->sk_state_change;
-	conn->sock->sk->sk_state_change = iet_state_change;
+	conn->sock->sk->sk_state_change = state_change;
 
 	target->nthread_info.old_data_ready = conn->sock->sk->sk_data_ready;
-	conn->sock->sk->sk_data_ready = iet_data_ready;
+	conn->sock->sk->sk_data_ready = data_ready;
 	write_unlock(&conn->sock->sk->sk_callback_lock);
 
 	oldfs = get_fs();
 	set_fs(get_ds());
-	conn->sock->ops->setsockopt(conn->sock, SOL_TCP, TCP_NODELAY, (void *)&opt, sizeof(opt));
+	conn->sock->ops->setsockopt(conn->sock, SOL_TCP, TCP_NODELAY,
+				    (void *)&opt, sizeof(opt));
 	set_fs(oldfs);
 }
 
@@ -76,9 +77,9 @@
 	dprintk(D_GENERIC, "%p %#Lx %u\n", conn->session,
 		(unsigned long long) conn->session->sid, conn->cid);
 
-	assert(atomic_read(&conn->nr_cmnds) == 0);
-	assert(list_empty(&conn->pdu_list));
-	assert(list_empty(&conn->write_list));
+	BUG_ON(atomic_read(&conn->nr_cmnds));
+	BUG_ON(!list_empty(&conn->pdu_list));
+	BUG_ON(!list_empty(&conn->write_list));
 
 	list_del(&conn->list);
 	list_del(&conn->poll_list);
@@ -89,16 +90,28 @@
 	return 0;
 }
 
-static int iet_conn_alloc(struct iscsi_session *session, struct conn_info *info)
+void conn_close(struct iscsi_conn *conn)
 {
+	if (test_and_clear_bit(CONN_ACTIVE, &conn->state))
+		set_bit(CONN_CLOSING, &conn->state);
+
+	nthread_wakeup(conn->session->target);
+}
+
+int conn_add(struct iscsi_session *session, struct conn_info *info)
+{
 	struct iscsi_conn *conn;
 
-	dprintk(D_SETUP, "%#Lx:%u\n", (unsigned long long) session->sid, info->cid);
+	dprintk(D_SETUP, "%#Lx:%u\n",
+		(unsigned long long) session->sid, info->cid);
 
-	conn = kmalloc(sizeof(*conn), GFP_KERNEL);
+	conn = conn_lookup(session, info->cid);
+	if (conn)
+		return -EEXIST;
+
+	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
 	if (!conn)
 		return -ENOMEM;
-	memset(conn, 0, sizeof(*conn));
 
 	conn->session = session;
 	conn->cid = info->cid;
@@ -124,7 +137,7 @@
 	set_bit(CONN_ACTIVE, &conn->state);
 
 	conn->file = fget(info->fd);
-	iet_socket_bind(conn);
+	socket_bind(conn);
 
 	list_add(&conn->poll_list, &session->target->nthread_info.active_conns);
 
@@ -133,25 +146,6 @@
 	return 0;
 }
 
-void conn_close(struct iscsi_conn *conn)
-{
-	if (test_and_clear_bit(CONN_ACTIVE, &conn->state))
-		set_bit(CONN_CLOSING, &conn->state);
-
-	nthread_wakeup(conn->session->target);
-}
-
-int conn_add(struct iscsi_session *session, struct conn_info *info)
-{
-	struct iscsi_conn *conn;
-	int err = -EEXIST;
-
-	if ((conn = conn_lookup(session, info->cid)))
-		return err;
-
-	return iet_conn_alloc(session, info);
-}
-
 int conn_del(struct iscsi_session *session, struct conn_info *info)
 {
 	struct iscsi_conn *conn;

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-25 10:42:08 UTC (rev 102)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-25 11:02:11 UTC (rev 103)
@@ -200,7 +200,6 @@
 extern void send_scsi_rsp(struct iscsi_cmnd *);
 
 /* conn.c */
-extern struct iscsi_conn *conn_lookup(struct iscsi_session *, u16);
 extern int conn_add(struct iscsi_session *, struct conn_info *);
 extern int conn_del(struct iscsi_session *, struct conn_info *);
 extern int conn_free(struct iscsi_conn *);

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-09-25 10:42:08 UTC (rev 102)
+++ trunk/iscsi/kernel/session.c	2005-09-25 11:02:11 UTC (rev 103)
@@ -80,10 +80,8 @@
 
 	BUG_ON(!list_empty(&session->conn_list));
 
-	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++) {
-		if (!list_empty(&session->cmnd_hash[i]))
-			BUG();
-	}
+	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++)
+		BUG_ON(!list_empty(&session->cmnd_hash[i]));
 
 	list_del(&session->list);
 



From tomo at berlios.de  Sun Sep 25 13:44:21 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 13:44:21 +0200
Subject: [Stgt-svn] r104 - trunk/iscsi/kernel
Message-ID: <200509251144.j8PBiLCu032160@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 13:44:19 +0200 (Sun, 25 Sep 2005)
New Revision: 104

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi_dbg.h
   trunk/iscsi/kernel/nthread.c
Log:
Replace assert with BUG_ON.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-25 11:02:11 UTC (rev 103)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-25 11:44:19 UTC (rev 104)
@@ -79,8 +79,8 @@
 	cmnd->sg = NULL;
 
 	if (req) {
-		assert(conn->session);
-		assert(conn->session->ts);
+		BUG_ON(!conn->session);
+		BUG_ON(!conn->session->ts);
 	}
 
 	dprintk(D_GENERIC, "%p:%p\n", conn, cmnd);
@@ -127,7 +127,7 @@
 		dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
 
 		list_del_init(&cmnd->list);
-		assert(conn == cmnd->conn);
+		BUG_ON(conn != cmnd->conn);
 		list_add_tail(&cmnd->list, &conn->write_list);
 	}
 
@@ -149,7 +149,7 @@
 			cmnd->hdigest, cmnd->ddigest,
 			list_empty(&cmnd->pdu_list), list_empty(&cmnd->hash_list));
 
-		assert(list_empty(&cmnd->list));
+		BUG_ON(!list_empty(&cmnd->list));
 	}
 	list_add(&cmnd->list, &head);
 	iscsi_cmnds_init_write(&head);
@@ -168,13 +168,13 @@
 	dprintk(D_GENERIC, "%p\n", cmnd);
 	pdusize = conn->session->param.max_xmit_data_length;
 	expsize = cmnd_read_size(cmnd);
-	assert(cmnd->tc);
+	BUG_ON(!cmnd->tc);
 	size = min(expsize, cmnd->tc->bufflen);
 	eprintk("%u %u\n", expsize, cmnd->tc->bufflen);
 	offset = 0;
 	sn = 0;
 
-	assert(sg);
+	BUG_ON(!sg);
 
 	while (1) {
 		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
@@ -383,7 +383,7 @@
 /* 	u32 size; */
 /* 	int i; */
 
-	assert(0);
+	BUG_ON(1);
 
 /* 	eprintk("%x %x %x %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd), */
 /* 		cmnd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
@@ -418,7 +418,7 @@
 /* 	struct tio *tio; */
 /* 	char *addr; */
 
-	assert(0);
+	BUG_ON(1);
 
 /* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
 /* 	rsp_hdr = (struct iscsi_reject_hdr *)&rsp->pdu.bhs; */
@@ -745,7 +745,7 @@
 		send_scsi_rsp(cmnd);
 		break;
 	default:
-		assert(0);
+		BUG_ON(1);
 		break;
 	}
 }
@@ -796,8 +796,8 @@
 /* 			struct tio *tio; */
 			int pg_cnt = get_pgcnt(size, 0);
 
-			assert(pg_cnt < ISCSI_CONN_IOV_MAX);
-			assert(0);
+			BUG_ON(pg_cnt >= ISCSI_CONN_IOV_MAX);
+			BUG_ON(1);
 /* 			cmnd->tio = tio = tio_alloc(pg_cnt); */
 /* 			tio_set(tio, size, 0); */
 
@@ -818,7 +818,7 @@
 				size -= tmp;
 			}
 		}
-		assert(!size);
+		BUG_ON(size);
 		conn->read_overflow = size;
 		conn->read_msg.msg_iovlen = i;
 	}
@@ -862,7 +862,7 @@
 				    be32_to_cpu(req_hdr->data_length),
 				    data_dir, req_hdr->lun,
 				    sizeof(req_hdr->lun), NULL);
-	assert(req->tc);
+	BUG_ON(!req->tc);
 
 	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
@@ -931,7 +931,7 @@
 
 		if (req->pdu.datasize) {
 			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)
-				assert(0);
+				BUG_ON(1);
 		}
 		break;
 	}
@@ -1003,17 +1003,16 @@
 	struct iscsi_cmnd *scsi_cmnd;
 	u32 offset;
 
-	assert(cmnd);
+	BUG_ON(!cmnd);
 	scsi_cmnd = cmnd->req;
-	assert(scsi_cmnd);
+	BUG_ON(!scsi_cmnd);
 
 	if (conn->read_overflow) {
 		eprintk("%x %u\n", cmnd_itt(cmnd), conn->read_overflow);
-/* 		assert(scsi_cmnd->tio); */
 		offset = be32_to_cpu(req->offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
 		if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, conn->read_overflow) < 0)
-			assert(0);
+			BUG_ON(1);
 		return;
 	}
 
@@ -1035,7 +1034,7 @@
 		scsi_cmnd->outstanding_r2t--;
 
 		if (scsi_cmnd->r2t_length == 0)
-			assert(list_empty(&scsi_cmnd->pdu_list));
+			BUG_ON(!list_empty(&scsi_cmnd->pdu_list));
 
 		scsi_cmnd_exec(scsi_cmnd);
 	}
@@ -1199,7 +1198,7 @@
 /* 			rsp->tio = req->tio; */
 /* 		} */
 
-		assert(get_pgcnt(req->pdu.datasize, 0) < ISCSI_CONN_IOV_MAX);
+		BUG_ON(get_pgcnt(req->pdu.datasize, 0) >= ISCSI_CONN_IOV_MAX);
 		rsp->pdu.datasize = req->pdu.datasize;
 		iscsi_cmnd_init_write(rsp);
 	} else
@@ -1274,7 +1273,7 @@
 		return;
 
 	size = (cmnd->pdu.datasize + 3) & -4;
-	assert(cmnd->sg);
+	BUG_ON(!cmnd->sg);
 	__cmnd_send_pdu(conn, cmnd->sg, 0, size);
 }
 
@@ -1320,8 +1319,8 @@
 	iscsi_cmnd_remove(cmnd);
 
 	if (is_last) {
-		assert(!force);
-		assert(req);
+		BUG_ON(force);
+		BUG_ON(!req);
 		cmnd_release(req, 0);
 	}
 
@@ -1334,7 +1333,7 @@
 	struct iovec *iop;
 
 	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
-	assert(cmnd);
+	BUG_ON(!cmnd);
 	iscsi_cmnd_set_length(&cmnd->pdu);
 
 	set_cork(conn->sock, 1);
@@ -1368,7 +1367,7 @@
 		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
 		offset = rsp->offset;
 		rsp->offset = cpu_to_be32(offset);
-		assert(cmnd->sg);
+		BUG_ON(!cmnd->sg);
 		__cmnd_send_pdu(conn, cmnd->sg, offset, cmnd->pdu.datasize);
 		break;
 	}
@@ -1415,7 +1414,7 @@
 		break;
 	default:
 		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
-		assert(0);
+		BUG_ON(1);
 		break;
 	}
 
@@ -1483,7 +1482,7 @@
 				break;
 		}
 
-		assert(list_empty(&cmnd->list));
+		BUG_ON(!list_empty(&cmnd->list));
 
 		list_add_tail(&cmnd->list, entry);
 	}

Modified: trunk/iscsi/kernel/iscsi_dbg.h
===================================================================
--- trunk/iscsi/kernel/iscsi_dbg.h	2005-09-25 11:02:11 UTC (rev 103)
+++ trunk/iscsi/kernel/iscsi_dbg.h	2005-09-25 11:44:19 UTC (rev 104)
@@ -27,15 +27,6 @@
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
 } while (0)
 
-#define assert(p) do {						\
-	if (!(p)) {						\
-		printk(KERN_CRIT "BUG at %s:%d assert(%s)\n",	\
-		       __FILE__, __LINE__, #p);			\
-		dump_stack();					\
-		BUG();						\
-	}							\
-} while (0)
-
 #ifdef D_IOV
 static inline void iscsi_dump_iov(struct msghdr *msg)
 {

Modified: trunk/iscsi/kernel/nthread.c
===================================================================
--- trunk/iscsi/kernel/nthread.c	2005-09-25 11:02:11 UTC (rev 103)
+++ trunk/iscsi/kernel/nthread.c	2005-09-25 11:44:19 UTC (rev 104)
@@ -44,7 +44,7 @@
 static void iscsi_conn_read_ahs(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
 	cmnd->pdu.ahs = kmalloc(cmnd->pdu.ahssize, __GFP_NOFAIL|GFP_KERNEL);
-	assert(cmnd->pdu.ahs);
+	BUG_ON(!cmnd->pdu.ahs);
 	iscsi_conn_init_read(conn, cmnd->pdu.ahs, cmnd->pdu.ahssize);
 }
 
@@ -207,7 +207,7 @@
 
 	switch (conn->read_state) {
 	case RX_INIT_BHS:
-		assert(!cmnd);
+		BUG_ON(cmnd);
 		cmnd = conn->read_cmnd = create_cmnd(conn);
 	case RX_BHS:
 		res = do_recv(conn, RX_INIT_AHS);
@@ -259,7 +259,7 @@
 		break;
 	default:
 		eprintk("%d %d %x\n", res, conn->read_state, cmnd_opcode(cmnd));
-		assert(0);
+		BUG_ON(1);
 	}
 
 	if (res <= 0)
@@ -270,7 +270,7 @@
 
 	if (conn->read_size) {
 		eprintk("%d %x %d\n", res, cmnd_opcode(cmnd), conn->read_size);
-		assert(0);
+		BUG_ON(1);
 	}
 
 	cmnd_rx_end(cmnd);
@@ -503,7 +503,7 @@
 
 	switch (conn->write_state) {
 	case TX_INIT:
-		assert(!cmnd);
+		BUG_ON(cmnd);
 		cmnd = conn->write_cmnd = iscsi_get_send_cmnd(conn);
 		if (!cmnd)
 			return 0;
@@ -516,7 +516,7 @@
 			break;
 	case TX_INIT_DDIGEST:
 		digest_tx_data(cmnd);
-		assert(!cmnd->conn->write_size);
+		BUG_ON(cmnd->conn->write_size);
 		cmnd->conn->write_size += sizeof(u32);
 		conn->write_state = TX_DDIGEST;
 	case TX_DDIGEST:
@@ -524,7 +524,7 @@
 		break;
 	default:
 		eprintk("%d %d %x\n", res, conn->write_state, cmnd_opcode(cmnd));
-		assert(0);
+		BUG_ON(1);
 	}
 
 	if (res <= 0)
@@ -535,7 +535,7 @@
 
 	if (conn->write_size) {
 		eprintk("%d %x %u\n", res, cmnd_opcode(cmnd), conn->write_size);
-		assert(!conn->write_size);
+		BUG_ON(conn->write_size);
 	}
 	cmnd_tx_end(cmnd);
 	cmnd_release(cmnd, 0);
@@ -577,8 +577,6 @@
 	struct iscsi_session *session = conn->session;
 	struct iscsi_cmnd *cmnd;
 
-	assert(conn);
-
 	conn->sock->ops->shutdown(conn->sock, 2);
 
 	write_lock(&conn->sock->sk->sk_callback_lock);
@@ -604,7 +602,7 @@
 		eprintk("%u\n", atomic_read(&conn->nr_cmnds));
 		list_for_each_entry(cmnd, &conn->pdu_list, conn_list)
 			eprintk("%x %x\n", cmnd_opcode(cmnd), cmnd_itt(cmnd));
-		assert(0);
+		BUG_ON(1);
 	}
 
 	eprintk("%d %llu %u\n", session->target->tid, session->sid, conn->cid);



From tomo at berlios.de  Sun Sep 25 14:00:14 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 14:00:14 +0200
Subject: [Stgt-svn] r105 - in trunk/iscsi: include kernel usr
Message-ID: <200509251200.j8PC0EXa016836@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 14:00:13 +0200 (Sun, 25 Sep 2005)
New Revision: 105

Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
   trunk/iscsi/usr/iscsid.h
Log:
Kill unused code.

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-09-25 11:44:19 UTC (rev 104)
+++ trunk/iscsi/include/iet_u.h	2005-09-25 12:00:13 UTC (rev 105)
@@ -14,7 +14,6 @@
 	u32 tid;
 
 	u64 sid;
-	char initiator_name[ISCSI_NAME_LEN];
 	u32 exp_cmd_sn;
 	u32 max_cmd_sn;
 };
@@ -59,7 +58,6 @@
 };
 
 enum {
-	key_target_type,
 	key_queued_cmnds,
 	target_key_last,
 };

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-25 11:44:19 UTC (rev 104)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-25 12:00:13 UTC (rev 105)
@@ -39,7 +39,6 @@
 };
 
 struct iscsi_trgt_param {
-	int target_type;
 	int queued_cmnds;
 };
 

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-25 11:44:19 UTC (rev 104)
+++ trunk/iscsi/kernel/target.c	2005-09-25 12:00:13 UTC (rev 105)
@@ -38,7 +38,6 @@
 };
 
 static struct iscsi_trgt_param default_target_param = {
-	.target_type = 0,
 	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
 };
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-25 11:44:19 UTC (rev 104)
+++ trunk/iscsi/usr/ctldev.c	2005-09-25 12:00:13 UTC (rev 105)
@@ -221,7 +221,6 @@
 	info->sid = sid;
 	info->exp_cmd_sn = exp_cmd_sn;
 	info->max_cmd_sn = max_cmd_sn;
-	strncpy(info->initiator_name, name, sizeof(info->initiator_name) - 1);
 	msg->msg_type = IET_ADD_SESSION;
 
 	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-09-25 11:44:19 UTC (rev 104)
+++ trunk/iscsi/usr/iscsid.h	2005-09-25 12:00:13 UTC (rev 105)
@@ -197,18 +197,6 @@
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 
-/* #define log_error(fmt, args...)						\ */
-/* do {									\ */
-/* } while (0) */
-
-/* #define log_warning(fmt, args...)					\ */
-/* do {									\ */
-/* } while (0) */
-
-/* #define log_debug(fmt, args...)						\ */
-/* do {									\ */
-/* } while (0) */
-
 #define log_pdu(x, y)							\
 do {									\
 } while (0)



From tomo at berlios.de  Sun Sep 25 14:03:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 25 Sep 2005 14:03:13 +0200
Subject: [Stgt-svn] r106 - trunk/iscsi/usr
Message-ID: <200509251203.j8PC3DSW021738@sheep.berlios.de>

Author: tomo
Date: 2005-09-25 14:03:02 +0200 (Sun, 25 Sep 2005)
New Revision: 106

Modified:
   trunk/iscsi/usr/param.c
Log:
Fix the bug in the previous commit.

Modified: trunk/iscsi/usr/param.c
===================================================================
--- trunk/iscsi/usr/param.c	2005-09-25 12:00:13 UTC (rev 105)
+++ trunk/iscsi/usr/param.c	2005-09-25 12:03:02 UTC (rev 106)
@@ -284,7 +284,6 @@
 #define	SET_KEY_VALUES(x)	DEFAULT_NR_##x,MIN_NR_##x, MAX_NR_##x
 
 struct iscsi_key target_keys[] = {
-	{"Type", 0, 0, 16, &minimum_ops},
 	{"QueuedCommands", SET_KEY_VALUES(QUEUED_CMNDS), &minimum_ops},
 	{NULL,},
 };



From tomo at berlios.de  Mon Sep 26 16:10:04 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Mon, 26 Sep 2005 16:10:04 +0200
Subject: [Stgt-svn] r107 - in trunk: iscsi/usr usr
Message-ID: <200509261410.j8QEA4wa007728@sheep.berlios.de>

Author: tomo
Date: 2005-09-26 16:10:03 +0200 (Mon, 26 Sep 2005)
New Revision: 107

Modified:
   trunk/iscsi/usr/ctldev.c
   trunk/usr/tgtd.c
Log:
The iSCSI parameters are changeable again, though we need to redesign this part later on.


Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-25 12:03:02 UTC (rev 106)
+++ trunk/iscsi/usr/ctldev.c	2005-09-26 14:10:03 UTC (rev 107)
@@ -205,6 +205,73 @@
 	return err;
 }
 
+static int iscsi_param_partial_set(u32 tid, u64 sid, int type, int key, u32 val)
+{
+	struct iscsi_param *param;
+	struct iscsi_param s_param[session_key_last];
+	struct iscsi_param t_param[target_key_last];
+
+	if (type == key_session)
+		param = s_param;
+	else
+		param = t_param;
+
+	param[key].val = val;
+
+	return iscsi_param_set(tid, sid, type, 1 << key, param);
+}
+
+static int trgt_mgmt_params(int tid, uint64_t sid, char *params)
+{
+	char *p, *q;
+	uint32_t s_partial = 0, t_partial = 0;
+	struct iscsi_param s_param[session_key_last];
+	struct iscsi_param t_param[target_key_last];
+
+	while ((p = strsep(&params, ",")) != NULL) {
+		int idx;
+		u32 val;
+		if (!*p)
+			continue;
+		if (!(q = strchr(p, '=')))
+			continue;
+		*q++ = '\0';
+		val = strtol(q, NULL, 0);
+
+		if (!((idx = param_index_by_name(p, target_keys)) < 0)) {
+			if (!param_check_val(target_keys, idx, &val))
+				t_partial |= (1 << idx);
+			else
+				eprintf("invalid val %s, %u\n",
+					target_keys[idx].name, val);
+			t_param[idx].val = val;
+
+			continue;
+		}
+
+		if (!((idx = param_index_by_name(p, session_keys)) < 0)) {
+			if (!param_check_val(session_keys, idx, &val))
+				s_partial |= (1 << idx);
+			else
+				eprintf("invalid val %s, %u\n",
+					session_keys[idx].name, val);
+			s_param[idx].val = val;
+		}
+	}
+
+	if (t_partial && s_partial) {
+		eprintf("%s", "Cannot change both at the same time\n");
+		return -EINVAL;
+	} else if (t_partial)
+		return iscsi_param_set(tid, sid, key_target, t_partial, t_param);
+	else if (s_partial)
+		return iscsi_param_set(tid, sid, key_session, s_partial, s_param);
+	else
+		eprintf("%s", "Nothing to do\n");
+
+	return 0;
+}
+
 static int iscsi_session_create(u32 tid, u64 sid, u32 exp_cmd_sn, u32 max_cmd_sn, char *name)
 {
 	struct iet_msg *msg;
@@ -426,7 +493,6 @@
 	return err;
 }
 
-
 static int target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
 {
 	int err = -EINVAL, tid = req->tid;
@@ -438,6 +504,9 @@
 	case OP_DELETE:
 		err = target_del(tid);
 		break;
+	case OP_UPDATE:
+		err = trgt_mgmt_params(tid, req->sid, params);
+		break;
 	default:
 		break;
 	}
@@ -650,17 +719,17 @@
 			eprintf("creaing lun %d %u %s\n", tid, lun, p);
 			iscsi_lunit_create(tid, lun, q);
 		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
-/* 			val = strtol(q, &q, 0); */
-/* 			if (param_check_val(target_keys, idx, &val) < 0) */
-/* 				log_warning("%s, %u\n", target_keys[idx].name, val); */
-/* 			iscsi_param_partial_set(tid, 0, key_target, idx, val); */
+			val = strtol(q, &q, 0);
+			if (param_check_val(target_keys, idx, &val) < 0)
+				log_warning("%s, %u\n", target_keys[idx].name, val);
+			iscsi_param_partial_set(tid, 0, key_target, idx, val);
 		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
-/* 			char *str = target_sep_string(&q); */
-/* 			if (param_str_to_val(session_keys, idx, str, &val) < 0) */
-/* 				continue; */
-/* 			if (param_check_val(session_keys, idx, &val) < 0) */
-/* 				log_warning("%s, %u\n", session_keys[idx].name, val); */
-/* 			iscsi_param_partial_set(tid, 0, key_session, idx, val); */
+			char *str = target_sep_string(&q);
+			if (param_str_to_val(session_keys, idx, str, &val) < 0)
+				continue;
+			if (param_check_val(session_keys, idx, &val) < 0)
+				log_warning("%s, %u\n", session_keys[idx].name, val);
+			iscsi_param_partial_set(tid, 0, key_session, idx, val);
 		}
 	}
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-09-25 12:03:02 UTC (rev 106)
+++ trunk/usr/tgtd.c	2005-09-26 14:10:03 UTC (rev 107)
@@ -98,7 +98,6 @@
 
 static void dl_poll_init(int nr, struct pollfd *poll_array)
 {
-	int i;
 	void (* fn)(struct pollfd *, int);
 
 	fn = dlsym(dl_handles[0], "poll_init");



From tomo at berlios.de  Tue Sep 27 05:21:25 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 27 Sep 2005 05:21:25 +0200
Subject: [Stgt-svn] r108 - in trunk: iscsi/kernel kernel
Message-ID: <200509270321.j8R3LPfA018215@sheep.berlios.de>

Author: tomo
Date: 2005-09-27 05:21:21 +0200 (Tue, 27 Sep 2005)
New Revision: 108

Modified:
   trunk/iscsi/kernel/target.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt_protocol.c
Log:
Replace some kmalloc with kzalloc.

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-26 14:10:03 UTC (rev 107)
+++ trunk/iscsi/kernel/target.c	2005-09-27 03:21:21 UTC (rev 108)
@@ -65,8 +65,6 @@
 
 	down(&target_list_sem);
 
-	memset(target, 0, sizeof(*target));
-
 	target->tt = tt;
 	target->tid = target->tt->tid;
 

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-26 14:10:03 UTC (rev 107)
+++ trunk/kernel/tgt.c	2005-09-27 03:21:21 UTC (rev 108)
@@ -93,10 +93,10 @@
 	unsigned long flags;
 	struct target_type_internal *ti;
 
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
 	if (!ti)
 		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
+
 	INIT_LIST_HEAD(&ti->list);
 	ti->tt = tt;
 
@@ -162,10 +162,9 @@
 		return NULL;
 	}
 
-	target = kmalloc(sizeof(*target), GFP_KERNEL);
+	target = kzalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
-	memset(target, 0, sizeof(*target));
 
 	ti = target_template_get(target_type);
 	if (!ti)
@@ -187,7 +186,7 @@
 	if (!target->twq)
 		goto put_template;
 
-	target->tt_data = kmalloc(target->tt->priv_data_size, GFP_KERNEL);
+	target->tt_data = kzalloc(target->tt->priv_data_size, GFP_KERNEL);
 	if (!target->tt_data)
 		goto free_workqueue;
 
@@ -299,10 +298,10 @@
 
 	dprintk("%p %d\n", target, max_cmds);
 
-	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
+	session = kzalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
 	if (!session)
 		return NULL;
-	memset(session, 0, sizeof(*session));
+
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 
@@ -376,10 +375,10 @@
 	unsigned long flags;
 	struct device_type_internal *ti;
 
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
 	if (!ti)
 		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
+
 	INIT_LIST_HEAD(&ti->list);
 	ti->sdt = sdt;
 
@@ -451,11 +450,10 @@
 	if (!target)
 		return -EINVAL;
 
-	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	device = kzalloc(sizeof(*device), GFP_KERNEL);
 	if (!device)
 		return -ENOMEM;
 
-	memset(device, 0, sizeof(*device));
 	device->dev_id = dev_id;
 	device->target = target;
 	device->fd = fd;
@@ -472,7 +470,7 @@
 		goto put_fd;
 	}
 
-	device->dt_data = kmalloc(device->dt->priv_data_size, GFP_KERNEL);
+	device->dt_data = kzalloc(device->dt->priv_data_size, GFP_KERNEL);
 	if (!device->dt_data)
 		goto put_template;
 

Modified: trunk/kernel/tgt_protocol.c
===================================================================
--- trunk/kernel/tgt_protocol.c	2005-09-26 14:10:03 UTC (rev 107)
+++ trunk/kernel/tgt_protocol.c	2005-09-27 03:21:21 UTC (rev 108)
@@ -46,10 +46,9 @@
 	unsigned long flags;
 	struct tgt_proto_internal *tp;
 
-	tp = kmalloc(sizeof(*tp), GFP_KERNEL);
+	tp = kzalloc(sizeof(*tp), GFP_KERNEL);
 	if (!tp)
 		return -ENOMEM;
-	memset(tp, 0, sizeof(*tp));
 	INIT_LIST_HEAD(&tp->list);
 	tp->proto = proto;
 



From tomo at berlios.de  Tue Sep 27 05:49:08 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 27 Sep 2005 05:49:08 +0200
Subject: [Stgt-svn] r109 - trunk/usr
Message-ID: <200509270349.j8R3n86C025540@sheep.berlios.de>

Author: tomo
Date: 2005-09-27 05:49:05 +0200 (Tue, 27 Sep 2005)
New Revision: 109

Modified:
   trunk/usr/tgtadm.c
Log:
Remove old ietadm stuff from tgtadm.

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-09-27 03:21:21 UTC (rev 108)
+++ trunk/usr/tgtadm.c	2005-09-27 03:49:05 UTC (rev 109)
@@ -1,11 +1,16 @@
 /*
- * ietadm - manage iSCSI Enterprise Target software.
+ * tgtadm - manage Target Framework software.
  *
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
 
+/*
+ * This is just taken from ietadm. Possibly, we need to redesign the
+ * greater part of this to handle every target driver.
+ */
+
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -48,7 +53,7 @@
 	else {
 		printf("Usage: %s [OPTION]\n", program_name);
 		printf("\
-iSCSI Enterprise Target Administration Utility.\n\
+Linux Target Framework Administration Utility.\n\
 \n\
   --op new --tid=[id] --params [name]\n\
                         add a new target with [id]. [id] must not be zero.\n\
@@ -71,9 +76,8 @@
                         automatically.\n\
   --op delete           stop all activity.\n\
   --op update --tid=[id] --params=key1=value1,key2=value2,...\n\
-                        change iSCSI IET target parameters of specific\n\
-                        target with [id]. You can use parameters in ietd.conf\n\
-                        as a key.\n\
+                        change the target parameters of specific\n\
+                        target with [id].\n\
   --op new --tid=[id] --user --params=[user]=[name],Password=[pass]\n\
                         add a new account with [pass] for specific target.\n\
                         [user] could be [IncomingUser] or [OutgoingUser].\n\
@@ -88,7 +92,7 @@
   --version             display version and exit\n\
   --help                display this help and exit\n\
 \n\
-Report bugs to <iscsitarget-devel at sourceforge.net>.\n");
+Report bugs to <stgt-devel at lists.berlios.de>.\n");
 	}
 	exit(status == 0 ? 0 : -1);
 }



