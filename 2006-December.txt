From tomo at mail.berlios.de  Sat Dec 16 15:12:38 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 16 Dec 2006 15:12:38 +0100
Subject: [Stgt-svn] r682 - in trunk: . patch
Message-ID: <200612161412.kBGECcZk021684@sheep.berlios.de>

Author: tomo
Date: 2006-12-16 15:12:37 +0100 (Sat, 16 Dec 2006)
New Revision: 682

Added:
   trunk/patch/aioepoll-2.6.20-rc1.diff
Removed:
   trunk/patch/epoll-2.6.18.diff
   trunk/patch/epoll-git.diff
Modified:
   trunk/README
Log:
Update for 2.6.20-rc1.

Modified: trunk/README
===================================================================
--- trunk/README	2006-11-26 16:53:24 UTC (rev 681)
+++ trunk/README	2006-12-16 14:12:37 UTC (rev 682)
@@ -19,15 +19,14 @@
 
 Preparation
 -------------
-First, get kernel sources from linux-2.6-target git tree:
+First, get kernel sources from 2.6.20-rc1.
 
-master.kernel.org:/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
+Second, apply aioepoll-2.6.20-rc1.diff in the patches directory.
 
-Second, apply epoll-git.diff in the patchset directory.
+Third, rebuild the kernel and reboot with the new kernel. Note you
+need to enable SCSI_TGT, SCSI_SRP, and SCSI_IBMVSCSIS kernel options
+in order to use the IBM VIO target driver, 
 
-Third, rebuild the kernel and reboot with the new kernel. Note if you
-plan to use the IBM VIO target driver, please enable SCSI_TGT,
-SCSI_SRP, and SCSI_IBMVSCSIS kernel options.
 
 Now you are ready to build target drivers. If you like to use the
 iSCSI target driver:

Added: trunk/patch/aioepoll-2.6.20-rc1.diff
===================================================================
--- trunk/patch/aioepoll-2.6.20-rc1.diff	2006-11-26 16:53:24 UTC (rev 681)
+++ trunk/patch/aioepoll-2.6.20-rc1.diff	2006-12-16 14:12:37 UTC (rev 682)
@@ -0,0 +1,233 @@
+diff --git a/fs/aio.c b/fs/aio.c
+index 5f577a6..236c94a 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -30,6 +30,7 @@ #include <linux/aio.h>
+ #include <linux/highmem.h>
+ #include <linux/workqueue.h>
+ #include <linux/security.h>
++#include <linux/eventpoll.h>
+ 
+ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+@@ -1487,6 +1488,9 @@ static ssize_t aio_setup_iocb(struct kio
+ 		if (file->f_op->aio_fsync)
+ 			kiocb->ki_retry = aio_fsync;
+ 		break;
++	case IOCB_CMD_EPOLL_WAIT:
++		kiocb->ki_retry = eventpoll_aio_wait;
++		break;
+ 	default:
+ 		dprintk("EINVAL: io_submit: no operation provided\n");
+ 		ret = -EINVAL;
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index 3ae644e..6b78ada 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
+ #include <linux/mount.h>
+ #include <linux/bitops.h>
+ #include <linux/mutex.h>
++#include <linux/aio.h>
+ #include <asm/uaccess.h>
+ #include <asm/system.h>
+ #include <asm/io.h>
+@@ -642,6 +643,150 @@ eexit_1:
+ 	return error;
+ }
+ 
++static void eventpoll_aio_timer(unsigned long data)
++{
++	struct kiocb *iocb = (struct kiocb *)data;
++	struct timer_list *timer = (struct timer_list *)iocb->private;
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	unsigned long flags;
++
++	(void)del_timer(timer);
++	write_lock_irqsave(&ep->lock, flags);
++	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
++	write_unlock_irqrestore(&ep->lock, flags);
++}
++
++static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
++{
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	int ret = -1;
++	struct list_head *list;
++	int seen = 0;
++
++	write_lock_irq(&ep->lock);
++
++	if (iocb->private)
++		del_timer((struct timer_list *)iocb->private);
++	/*
++	 *  We need to know whether the event was removed from the wait
++	 *  queue in order to return the proper status to the cancellation
++	 *  code.
++	 */
++	list = &ep->wq.task_list;
++
++	do {
++		struct list_head *next;
++		if (list == &iocb->ki_wait.task_list)
++			seen++;
++		next = list->next;
++		if (next->prev != list) {
++			seen += 2;
++			break;
++		}
++		list = next;
++	} while (list != &ep->wq.task_list);
++
++	if (seen == 1) {
++		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
++		ret = 0;
++	}
++	write_unlock_irq(&ep->lock);
++
++	if (ret == 0) {
++		/* successfully cancelled request */
++		kfree(iocb->private);
++		iocb->private = NULL;
++		/* drop the i/o reference */
++		aio_put_req(iocb);
++	} else
++		ret = -EAGAIN;
++
++	event->res = event->res2 = 0;
++	/* drop the cancel reference */
++	aio_put_req(iocb);
++
++	return ret;
++}
++
++/*
++ * iocb->ki_nbytes -- number of events
++ * iocb->ki_pos    -- relative timeout in milliseconds
++ * iocb->private   -- NULL first go;  after that, it's set to the the
++ *                    absolute timeout in jiffies.
++ */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb)
++{
++	struct file *file = iocb->ki_filp;
++	ssize_t ret = -EINVAL;
++	int relative_ms;
++	unsigned long expires;
++	unsigned long now;
++	struct timer_list *timer;
++
++	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
++	    iocb->ki_nbytes <= 0)
++		return -EINVAL;
++
++	if (!iocb->private) {
++		/*
++		 *  Note that we unconditionally allocate a timer, but we
++		 *  only use it if a timeout was specified.  Otherwise, it
++		 *  is just a holder for the "infinite" value.
++		 */
++		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++		if (!timer)
++			return -ENOMEM;
++
++		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++			expires = MAX_SCHEDULE_TIMEOUT;
++		else
++			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
++
++		init_timer(timer);
++		timer->function = eventpoll_aio_timer;
++		timer->data = (unsigned long)iocb;
++		timer->expires = expires;
++	} else {
++		timer = (struct timer_list *)iocb->private;
++		expires = timer->expires;
++	}
++
++	now = jiffies;
++	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
++		relative_ms = EP_MAX_MSTIMEO;
++	else if (time_before(now, expires))
++		relative_ms = jiffies_to_msecs(expires - now);
++	else
++		relative_ms = 0;
++
++	iocb->ki_cancel = aio_epoll_cancel;
++	ret = ep_poll(file->private_data,
++		      (struct epoll_event __user *)iocb->ki_buf,
++		      iocb->ki_nbytes, relative_ms);
++
++	/*
++	 *  If a timeout was specified, ep_poll returned retry, and we have
++	 *  not yet registered a timer, go ahead and register one.
++	 */
++	if (ret == -EIOCBRETRY && !iocb->private) {
++		iocb->private = timer;
++		add_timer(timer);
++	}
++
++	/*
++	 *  Did we get any events?
++	 */
++	if (ret >= 0) {
++		iocb->ki_cancel = NULL;
++		(void)del_timer(timer);
++		kfree(timer);
++		iocb->private = NULL;
++	}
++
++	return ret;
++}
+ 
+ /*
+  * Implement the event wait interface for the eventpoll file. It is the kernel
+@@ -1564,6 +1709,12 @@ retry:
+ 
+ 	res = 0;
+ 	if (list_empty(&ep->rdllist)) {
++		if (in_aio() && jtimeout) {
++			__add_wait_queue(&ep->wq, current->io_wait);
++			res = -EIOCBRETRY;
++			write_unlock_irqrestore(&ep->lock, flags);
++			goto out;
++		}
+ 		/*
+ 		 * We don't have any available event to return to the caller.
+ 		 * We need to sleep here, and we will be wake up by
+@@ -1608,7 +1759,7 @@ retry:
+ 	if (!res && eavail &&
+ 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
+ 		goto retry;
+-
++out:
+ 	return res;
+ }
+ 
+diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
+index e3ca0a4..292c811 100644
+--- a/include/linux/aio_abi.h
++++ b/include/linux/aio_abi.h
+@@ -43,6 +43,7 @@ enum {
+ 	IOCB_CMD_NOOP = 6,
+ 	IOCB_CMD_PREADV = 7,
+ 	IOCB_CMD_PWRITEV = 8,
++  	IOCB_CMD_EPOLL_WAIT = 9,
+ };
+ 
+ /* read() from /dev/aio returns these structures. */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..ed04500 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
+ /* Used to release the epoll bits inside the "struct file" */
+ void eventpoll_release_file(struct file *file);
+ 
++/* Used to provide epoll_wait() to sys_io_submit() */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb);
++
+ /*
+  * This is called from inside fs/file_table.c:__fput() to unlink files
+  * from the eventpoll interface. We need to have this facility to cleanup

Deleted: trunk/patch/epoll-2.6.18.diff
===================================================================
--- trunk/patch/epoll-2.6.18.diff	2006-11-26 16:53:24 UTC (rev 681)
+++ trunk/patch/epoll-2.6.18.diff	2006-12-16 14:12:37 UTC (rev 682)
@@ -1,233 +0,0 @@
-diff --git a/fs/aio.c b/fs/aio.c
-index 9506301..aacb38e 100644
---- a/fs/aio.c
-+++ b/fs/aio.c
-@@ -29,6 +29,7 @@ #include <linux/aio.h>
- #include <linux/highmem.h>
- #include <linux/workqueue.h>
- #include <linux/security.h>
-+#include <linux/eventpoll.h>
- 
- #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
-@@ -1434,6 +1435,9 @@ static ssize_t aio_setup_iocb(struct kio
- 		if (file->f_op->aio_fsync)
- 			kiocb->ki_retry = aio_fsync;
- 		break;
-+	case IOCB_CMD_EPOLL_WAIT:
-+		kiocb->ki_retry = eventpoll_aio_wait;
-+		break;
- 	default:
- 		dprintk("EINVAL: io_submit: no operation provided\n");
- 		ret = -EINVAL;
-diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index 3a35674..729a753 100644
---- a/fs/eventpoll.c
-+++ b/fs/eventpoll.c
-@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
- #include <linux/mount.h>
- #include <linux/bitops.h>
- #include <linux/mutex.h>
-+#include <linux/aio.h>
- #include <asm/uaccess.h>
- #include <asm/system.h>
- #include <asm/io.h>
-@@ -698,6 +699,150 @@ eexit_1:
- 	return error;
- }
- 
-+static void eventpoll_aio_timer(unsigned long data)
-+{
-+	struct kiocb *iocb = (struct kiocb *)data;
-+	struct timer_list *timer = (struct timer_list *)iocb->private;
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	unsigned long flags;
-+
-+	(void)del_timer(timer);
-+	write_lock_irqsave(&ep->lock, flags);
-+	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
-+	write_unlock_irqrestore(&ep->lock, flags);
-+}
-+
-+static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
-+{
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	int ret = -1;
-+	struct list_head *list;
-+	int seen = 0;
-+
-+	write_lock_irq(&ep->lock);
-+
-+	if (iocb->private)
-+		del_timer((struct timer_list *)iocb->private);
-+	/*
-+	 *  We need to know whether the event was removed from the wait
-+	 *  queue in order to return the proper status to the cancellation
-+	 *  code.
-+	 */
-+	list = &ep->wq.task_list;
-+
-+	do {
-+		struct list_head *next;
-+		if (list == &iocb->ki_wait.task_list)
-+			seen++;
-+		next = list->next;
-+		if (next->prev != list) {
-+			seen += 2;
-+			break;
-+		}
-+		list = next;
-+	} while (list != &ep->wq.task_list);
-+
-+	if (seen == 1) {
-+		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
-+		ret = 0;
-+	}
-+	write_unlock_irq(&ep->lock);
-+
-+	if (ret == 0) {
-+		/* successfully cancelled request */
-+		kfree(iocb->private);
-+		iocb->private = NULL;
-+		/* drop the i/o reference */
-+		aio_put_req(iocb);
-+	} else
-+		ret = -EAGAIN;
-+
-+	event->res = event->res2 = 0;
-+	/* drop the cancel reference */
-+	aio_put_req(iocb);
-+
-+	return ret;
-+}
-+
-+/*
-+ * iocb->ki_nbytes -- number of events
-+ * iocb->ki_pos    -- relative timeout in milliseconds
-+ * iocb->private   -- NULL first go;  after that, it's set to the the
-+ *                    absolute timeout in jiffies.
-+ */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb)
-+{
-+	struct file *file = iocb->ki_filp;
-+	ssize_t ret = -EINVAL;
-+	int relative_ms;
-+	unsigned long expires;
-+	unsigned long now;
-+	struct timer_list *timer;
-+
-+	if (!is_file_epoll(file) || iocb->ki_nbytes > MAX_EVENTS ||
-+	    iocb->ki_nbytes <= 0)
-+		return -EINVAL;
-+
-+	if (!iocb->private) {
-+		/*
-+		 *  Note that we unconditionally allocate a timer, but we
-+		 *  only use it if a timeout was specified.  Otherwise, it
-+		 *  is just a holder for the "infinite" value.
-+		 */
-+		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-+		if (!timer)
-+			return -ENOMEM;
-+
-+		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
-+			expires = MAX_SCHEDULE_TIMEOUT;
-+		else
-+			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
-+
-+		init_timer(timer);
-+		timer->function = eventpoll_aio_timer;
-+		timer->data = (unsigned long)iocb;
-+		timer->expires = expires;
-+	} else {
-+		timer = (struct timer_list *)iocb->private;
-+		expires = timer->expires;
-+	}
-+
-+	now = jiffies;
-+	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
-+		relative_ms = EP_MAX_MSTIMEO;
-+	else if (time_before(now, expires))
-+		relative_ms = jiffies_to_msecs(expires - now);
-+	else
-+		relative_ms = 0;
-+
-+	iocb->ki_cancel = aio_epoll_cancel;
-+	ret = ep_poll(file->private_data,
-+		      (struct epoll_event __user *)iocb->ki_buf,
-+		      iocb->ki_nbytes, relative_ms);
-+
-+	/*
-+	 *  If a timeout was specified, ep_poll returned retry, and we have
-+	 *  not yet registered a timer, go ahead and register one.
-+	 */
-+	if (ret == -EIOCBRETRY && !iocb->private) {
-+		iocb->private = timer;
-+		add_timer(timer);
-+	}
-+
-+	/*
-+	 *  Did we get any events?
-+	 */
-+	if (ret >= 0) {
-+		iocb->ki_cancel = NULL;
-+		(void)del_timer(timer);
-+		kfree(timer);
-+		iocb->private = NULL;
-+	}
-+
-+	return ret;
-+}
- 
- /*
-  * Creates the file descriptor to be used by the epoll interface.
-@@ -1513,6 +1658,12 @@ retry:
- 
- 	res = 0;
- 	if (list_empty(&ep->rdllist)) {
-+		if (in_aio() && jtimeout) {
-+			__add_wait_queue(&ep->wq, current->io_wait);
-+			res = -EIOCBRETRY;
-+			write_unlock_irqrestore(&ep->lock, flags);
-+			goto out;
-+		}
- 		/*
- 		 * We don't have any available event to return to the caller.
- 		 * We need to sleep here, and we will be wake up by
-@@ -1557,7 +1708,7 @@ retry:
- 	if (!res && eavail &&
- 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
- 		goto retry;
--
-+out:
- 	return res;
- }
- 
-diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
-index 30fdcc8..bb67d5b 100644
---- a/include/linux/aio_abi.h
-+++ b/include/linux/aio_abi.h
-@@ -41,6 +41,7 @@ enum {
- 	 * IOCB_CMD_POLL = 5,
- 	 */
- 	IOCB_CMD_NOOP = 6,
-+ 	IOCB_CMD_EPOLL_WAIT = 9,
- };
- 
- /* read() from /dev/aio returns these structures. */
-diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
-index 84cfa8b..ed04500 100644
---- a/include/linux/eventpoll.h
-+++ b/include/linux/eventpoll.h
-@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
- /* Used to release the epoll bits inside the "struct file" */
- void eventpoll_release_file(struct file *file);
- 
-+/* Used to provide epoll_wait() to sys_io_submit() */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb);
-+
- /*
-  * This is called from inside fs/file_table.c:__fput() to unlink files
-  * from the eventpoll interface. We need to have this facility to cleanup

Deleted: trunk/patch/epoll-git.diff
===================================================================
--- trunk/patch/epoll-git.diff	2006-11-26 16:53:24 UTC (rev 681)
+++ trunk/patch/epoll-git.diff	2006-12-16 14:12:37 UTC (rev 682)
@@ -1,233 +0,0 @@
-diff --git a/fs/aio.c b/fs/aio.c
-index 9476659..e2eec22 100644
---- a/fs/aio.c
-+++ b/fs/aio.c
-@@ -30,6 +30,7 @@ #include <linux/aio.h>
- #include <linux/highmem.h>
- #include <linux/workqueue.h>
- #include <linux/security.h>
-+#include <linux/eventpoll.h>
- 
- #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
-@@ -1504,6 +1505,9 @@ static ssize_t aio_setup_iocb(struct kio
- 		if (file->f_op->aio_fsync)
- 			kiocb->ki_retry = aio_fsync;
- 		break;
-+	case IOCB_CMD_EPOLL_WAIT:
-+		kiocb->ki_retry = eventpoll_aio_wait;
-+		break;
- 	default:
- 		dprintk("EINVAL: io_submit: no operation provided\n");
- 		ret = -EINVAL;
-diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index ae228ec..6269c9e 100644
---- a/fs/eventpoll.c
-+++ b/fs/eventpoll.c
-@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
- #include <linux/mount.h>
- #include <linux/bitops.h>
- #include <linux/mutex.h>
-+#include <linux/aio.h>
- #include <asm/uaccess.h>
- #include <asm/system.h>
- #include <asm/io.h>
-@@ -642,6 +643,150 @@ eexit_1:
- 	return error;
- }
- 
-+static void eventpoll_aio_timer(unsigned long data)
-+{
-+	struct kiocb *iocb = (struct kiocb *)data;
-+	struct timer_list *timer = (struct timer_list *)iocb->private;
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	unsigned long flags;
-+
-+	(void)del_timer(timer);
-+	write_lock_irqsave(&ep->lock, flags);
-+	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
-+	write_unlock_irqrestore(&ep->lock, flags);
-+}
-+
-+static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
-+{
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	int ret = -1;
-+	struct list_head *list;
-+	int seen = 0;
-+
-+	write_lock_irq(&ep->lock);
-+
-+	if (iocb->private)
-+		del_timer((struct timer_list *)iocb->private);
-+	/*
-+	 *  We need to know whether the event was removed from the wait
-+	 *  queue in order to return the proper status to the cancellation
-+	 *  code.
-+	 */
-+	list = &ep->wq.task_list;
-+
-+	do {
-+		struct list_head *next;
-+		if (list == &iocb->ki_wait.task_list)
-+			seen++;
-+		next = list->next;
-+		if (next->prev != list) {
-+			seen += 2;
-+			break;
-+		}
-+		list = next;
-+	} while (list != &ep->wq.task_list);
-+
-+	if (seen == 1) {
-+		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
-+		ret = 0;
-+	}
-+	write_unlock_irq(&ep->lock);
-+
-+	if (ret == 0) {
-+		/* successfully cancelled request */
-+		kfree(iocb->private);
-+		iocb->private = NULL;
-+		/* drop the i/o reference */
-+		aio_put_req(iocb);
-+	} else
-+		ret = -EAGAIN;
-+
-+	event->res = event->res2 = 0;
-+	/* drop the cancel reference */
-+	aio_put_req(iocb);
-+
-+	return ret;
-+}
-+
-+/*
-+ * iocb->ki_nbytes -- number of events
-+ * iocb->ki_pos    -- relative timeout in milliseconds
-+ * iocb->private   -- NULL first go;  after that, it's set to the the
-+ *                    absolute timeout in jiffies.
-+ */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb)
-+{
-+	struct file *file = iocb->ki_filp;
-+	ssize_t ret = -EINVAL;
-+	int relative_ms;
-+	unsigned long expires;
-+	unsigned long now;
-+	struct timer_list *timer;
-+
-+	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
-+	    iocb->ki_nbytes <= 0)
-+		return -EINVAL;
-+
-+	if (!iocb->private) {
-+		/*
-+		 *  Note that we unconditionally allocate a timer, but we
-+		 *  only use it if a timeout was specified.  Otherwise, it
-+		 *  is just a holder for the "infinite" value.
-+		 */
-+		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-+		if (!timer)
-+			return -ENOMEM;
-+
-+		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
-+			expires = MAX_SCHEDULE_TIMEOUT;
-+		else
-+			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
-+
-+		init_timer(timer);
-+		timer->function = eventpoll_aio_timer;
-+		timer->data = (unsigned long)iocb;
-+		timer->expires = expires;
-+	} else {
-+		timer = (struct timer_list *)iocb->private;
-+		expires = timer->expires;
-+	}
-+
-+	now = jiffies;
-+	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
-+		relative_ms = EP_MAX_MSTIMEO;
-+	else if (time_before(now, expires))
-+		relative_ms = jiffies_to_msecs(expires - now);
-+	else
-+		relative_ms = 0;
-+
-+	iocb->ki_cancel = aio_epoll_cancel;
-+	ret = ep_poll(file->private_data,
-+		      (struct epoll_event __user *)iocb->ki_buf,
-+		      iocb->ki_nbytes, relative_ms);
-+
-+	/*
-+	 *  If a timeout was specified, ep_poll returned retry, and we have
-+	 *  not yet registered a timer, go ahead and register one.
-+	 */
-+	if (ret == -EIOCBRETRY && !iocb->private) {
-+		iocb->private = timer;
-+		add_timer(timer);
-+	}
-+
-+	/*
-+	 *  Did we get any events?
-+	 */
-+	if (ret >= 0) {
-+		iocb->ki_cancel = NULL;
-+		(void)del_timer(timer);
-+		kfree(timer);
-+		iocb->private = NULL;
-+	}
-+
-+	return ret;
-+}
- 
- /*
-  * Implement the event wait interface for the eventpoll file. It is the kernel
-@@ -1564,6 +1709,12 @@ retry:
- 
- 	res = 0;
- 	if (list_empty(&ep->rdllist)) {
-+		if (in_aio() && jtimeout) {
-+			__add_wait_queue(&ep->wq, current->io_wait);
-+			res = -EIOCBRETRY;
-+			write_unlock_irqrestore(&ep->lock, flags);
-+			goto out;
-+		}
- 		/*
- 		 * We don't have any available event to return to the caller.
- 		 * We need to sleep here, and we will be wake up by
-@@ -1608,7 +1759,7 @@ retry:
- 	if (!res && eavail &&
- 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
- 		goto retry;
--
-+out:
- 	return res;
- }
- 
-diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
-index e3ca0a4..292c811 100644
---- a/include/linux/aio_abi.h
-+++ b/include/linux/aio_abi.h
-@@ -43,6 +43,7 @@ enum {
- 	IOCB_CMD_NOOP = 6,
- 	IOCB_CMD_PREADV = 7,
- 	IOCB_CMD_PWRITEV = 8,
-+  	IOCB_CMD_EPOLL_WAIT = 9,
- };
- 
- /* read() from /dev/aio returns these structures. */
-diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
-index 84cfa8b..ed04500 100644
---- a/include/linux/eventpoll.h
-+++ b/include/linux/eventpoll.h
-@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
- /* Used to release the epoll bits inside the "struct file" */
- void eventpoll_release_file(struct file *file);
- 
-+/* Used to provide epoll_wait() to sys_io_submit() */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb);
-+
- /*
-  * This is called from inside fs/file_table.c:__fput() to unlink files
-  * from the eventpoll interface. We need to have this facility to cleanup



From tomo at mail.berlios.de  Sat Dec 16 15:13:20 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 16 Dec 2006 15:13:20 +0100
Subject: [Stgt-svn] r683 - trunk
Message-ID: <200612161413.kBGEDKRf021766@sheep.berlios.de>

Author: tomo
Date: 2006-12-16 15:13:20 +0100 (Sat, 16 Dec 2006)
New Revision: 683

Added:
   trunk/patches/
Removed:
   trunk/patch/
Log:
Rename patch patches dir.

Copied: trunk/patches (from rev 682, trunk/patch)



From tomo at mail.berlios.de  Sat Dec 16 18:38:34 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 16 Dec 2006 18:38:34 +0100
Subject: [Stgt-svn] r684 - in trunk/usr: . xen
Message-ID: <200612161738.kBGHcYN2028990@sheep.berlios.de>

Author: tomo
Date: 2006-12-16 18:38:32 +0100 (Sat, 16 Dec 2006)
New Revision: 684

Added:
   trunk/usr/bd_xen.c
   trunk/usr/xen/
   trunk/usr/xen/xen.c
   trunk/usr/xen/xen.h
   trunk/usr/xen/xenbus.c
   trunk/usr/xen/xs_api.c
   trunk/usr/xen/xs_api.h
Modified:
   trunk/usr/Makefile
Log:
Add xen stuff


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/Makefile	2006-12-16 17:38:32 UTC (rev 684)
@@ -1,43 +1,59 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
-	-I$(KERNELSRC)/include -I../include -I.
-
-PROGRAMS = tgtd tgtadm tgtadm-iscsi
-TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o bd_sg.o
+ifneq ($(XEN),)
+XEN_ROOT = ../..
+include $(XEN_ROOT)/tools/Rules.mk
+LINUX_ROOT := $(wildcard $(XEN_ROOT)/linux-2.6.*-xen)
+INCLUDES += -I$(XEN_LIBXC) -I$(XEN_XENSTORE) -I$(XEN_ROOT)/xen/include
+INCLUDES += -I$(LINUX_ROOT)/include -I.
+LIBAIO_DIR = ../libaio/src
+AIOLIBS := $(LIBAIO_DIR)/libaio.a
+CFLAGS += -I$(XEN_LIBXC) -I$(LIBAIO_DIR)
+CFLAGS += $(INCLUDES) -I. -I../../xenstore 
+CFLAGS += -DXEN -DUSE_KERNEL
+LIBS := -L. -L.. -L../lib
+LIBS += -L$(XEN_LIBXC)
+LIBS += -lxenctrl
+LIBS += -L$(XEN_XENSTORE) -lxenstore $(AIOLIBS)
+TGTD_OBJS += $(addprefix xen/, xen.o xs_api.o xenbus.o)
+TGTD_OBJS += tgtif.o bd_xen.o
+else
+INCLUDES += -I../include -I$(KERNELSRC)/include
 LIBS += -laio
+endif
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
+TGTD_OBJS += bd_mmap.o tgtif.o
 BD_MMAP=1
 endif
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
-	account.o chap.o transport.o)
-TGTD_OBJS += $(addprefix iscsi/, iscsi_tcp.o)
+	account.o chap.o transport.o iscsi_tcp.o)
+TGTD_OBJS += bd_aio.o
 LIBS += -lcrypto
 BD_AIO=1
 endif
 
-ifneq ($(BD_MMAP),)
-TGTD_OBJS += bd_mmap.o tgtif.o
-endif
+INCLUDES += -I.
+CFLAGS += -Wall -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
-ifneq ($(BD_AIO),)
-TGTD_OBJS += bd_aio.o
-endif
+PROGRAMS += tgtd tgtadm
+TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o bd_sg.o
 
 all: $(PROGRAMS)
 
 tgtd: $(TGTD_OBJS)
-	$(CC) $^ -g -o $@ $(LIBS)
+	$(CC) $^ -o $@ $(LIBS)
 
 tgtadm: tgtadm.o
 	$(CC) $^ -o $@
 
-tgtadm-iscsi: tgtadm-iscsi.o
-	$(CC) $^ -o $@
+ifneq ($(XEN),)
+install: $(PROGRAMS)
+	install -m0755 $(PROGRAMS) $(DESTDIR)/usr/sbin
+endif
 
 clean:
-	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o
+	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o

Added: trunk/usr/bd_xen.c
===================================================================
--- trunk/usr/bd_xen.c	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/bd_xen.c	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,67 @@
+/*
+ * Xen file backed routine
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <libaio.h>
+
+#include <linux/fs.h>
+#include <sys/epoll.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+
+static int bd_xen_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+{
+	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
+
+	return *fd >= 0 ? 0 : *fd;
+}
+
+static void bd_xen_close(struct tgt_device *dev)
+{
+	close(dev->fd);
+}
+
+static int bd_xen_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
+			     uint32_t datalen, unsigned long *uaddr,
+			     uint64_t offset, int *async, void *key)
+{
+	return 0;
+}
+
+static int bd_xen_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	return 0;
+}
+
+struct backedio_template xen_bdt = {
+	.bd_open		= bd_xen_open,
+	.bd_close		= bd_xen_close,
+	.bd_cmd_submit		= bd_xen_cmd_submit,
+	.bd_cmd_done		= bd_xen_cmd_done,
+};

Added: trunk/usr/xen/xen.c
===================================================================
--- trunk/usr/xen/xen.c	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/xen/xen.c	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,43 @@
+#include <string.h>
+#include <sys/epoll.h>
+#include <xs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "xs_api.h"
+
+/* xenstore/xenbus: */
+extern int add_blockdevice_probe_watch(struct xs_handle *h,
+                                       const char *domname);
+extern int xs_fire_next_watch(struct xs_handle *h);
+
+static void xen_event_handle(int fd, int events, void *data)
+{
+	xs_fire_next_watch((struct xs_handle *) data);
+}
+
+int xen_init(int index)
+{
+	int err;
+	struct xs_handle *xsh;
+
+	xsh = xs_daemon_open();
+	if (!xsh) {
+		eprintf("xs_daemon_open\n");
+		goto open_failed;
+	}
+
+	err = add_blockdevice_probe_watch(xsh, "Domain-0");
+	if (err) {
+		eprintf("adding device probewatch\n");
+		goto open_failed;
+	}
+
+	err = tgt_event_add(xs_fileno(xsh), EPOLLIN, xen_event_handle, xsh);
+
+	return 0;
+
+open_failed:
+	return -1;
+}

Added: trunk/usr/xen/xen.h
===================================================================
--- trunk/usr/xen/xen.h	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/xen/xen.h	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,15 @@
+#ifndef __TGTXEN_H__
+#define __TGTXEN_H__
+
+extern int xen_init(void);
+
+struct tgt_driver xen = {
+	.name			= "xen",
+	.use_kernel		= 1,
+	.init			= xen_init,
+	.cmd_end_notify		= kspace_send_cmd_res,
+	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
+	.default_bdt		= &xen_bdt,
+};
+
+#endif

Added: trunk/usr/xen/xenbus.c
===================================================================
--- trunk/usr/xen/xenbus.c	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/xen/xenbus.c	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,398 @@
+/*
+ * xenbus.c
+ *
+ * xenbus interface to the blocktap.
+ *
+ * this handles the top-half of integration with block devices through the
+ * store -- the tap driver negotiates the device channel etc, while the
+ * userland tap client needs to sort out the disk parameters etc.
+ *
+ * (c) 2005 Andrew Warfield and Julian Chesterfield
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <printf.h>
+#include <string.h>
+#include <err.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <errno.h>
+#include <xs.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <time.h>
+#include <sys/time.h>
+
+/* FIXME */
+#define SRP_RING_PAGES 1
+#define SRP_MAPPED_PAGES 88
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "xs_api.h"
+
+struct backend_info
+{
+	int frontend_id;
+
+	char *path;
+	char *backpath;
+	char *frontpath;
+
+	struct list_head list;
+};
+
+static LIST_HEAD(belist);
+
+static int strsep_len(const char *str, char c, unsigned int len)
+{
+	unsigned int i;
+
+	for (i = 0; str[i]; i++)
+		if (str[i] == c) {
+			if (len == 0)
+				return i;
+			len--;
+		}
+	return (len == 0) ? i : -ERANGE;
+}
+
+static int get_be_id(const char *str)
+{
+	int len,end;
+	const char *ptr;
+	char *tptr, num[10];
+
+	len = strsep_len(str, '/', 6);
+	end = strlen(str);
+	if((len < 0) || (end < 0)) return -1;
+
+	ptr = str + len + 1;
+	strncpy(num,ptr,end - len);
+	tptr = num + (end - (len + 1));
+	*tptr = '\0';
+
+	return atoi(num);
+}
+
+static struct backend_info *be_lookup_be(const char *bepath)
+{
+	struct backend_info *be;
+
+	list_for_each_entry(be, &belist, list)
+		if (strcmp(bepath, be->backpath) == 0)
+			return be;
+	return (struct backend_info *)NULL;
+}
+
+static int be_exists_be(const char *bepath)
+{
+	return (be_lookup_be(bepath) != NULL);
+}
+
+static struct backend_info *be_lookup_fe(const char *fepath)
+{
+	struct backend_info *be;
+
+	list_for_each_entry(be, &belist, list)
+		if (strcmp(fepath, be->frontpath) == 0)
+			return be;
+	return (struct backend_info *)NULL;
+}
+
+#if 0
+static int backend_remove(struct xs_handle *h, struct backend_info *be)
+{
+	/* Unhook from be list. */
+	list_del(&be->list);
+	dprintf("Removing backend\n");
+
+	/* Free everything else. */
+	if (be->blkif) {
+		dprintf("Freeing blkif dev [%d]\n",be->blkif->devnum);
+		free_blkif(be->blkif);
+	}
+	if (be->frontpath)
+		free(be->frontpath);
+	if (be->backpath)
+		free(be->backpath);
+	free(be);
+	return 0;
+}
+#endif
+
+static int tgt_device_setup(struct xs_handle *h, char *bepath)
+{
+	struct backend_info *be;
+	char *path = NULL, *p, *dev;
+	int len, err = -EINVAL;
+	long int handle;
+	uint64_t lun;
+
+	be = be_lookup_be(bepath);
+	if (!be) {
+		dprintf("ERROR: backend changed called for nonexistent "
+			"backend! (%s)\n", bepath);
+		return err;
+	}
+
+        err = xs_gather(h, bepath, "dev", NULL, &path, NULL);
+        if (err) {
+                eprintf("cannot get dev %d\n", err);
+		return err;
+	}
+
+	/* TODO: we need to lun param. */
+	lun = 0;
+
+	err = tgt_device_create(be->frontend_id, lun);
+	{
+		char line[1024];
+		int len;
+
+		memset(line, 0, sizeof(line));
+		len = snprintf(line, sizeof(line), "path");
+		len += 1;
+		snprintf(line + len, sizeof(line) - len, "%s", path);
+		err = tgt_device_update(be->frontend_id, lun, line);
+	}
+
+	dprintf("%d path %s\n", err, path);
+	if (err)
+		return err;
+
+	err = xs_printf(h, be->backpath, "info", "%d", be->frontend_id);
+	if (!err)
+		dprintf("ERROR: Failed writing info");
+
+	dprintf("[SETUP] Complete\n\n");
+
+	return err;
+}
+
+static int xen_chrdev_open(char *name, uint8_t minor)
+{
+	FILE *f;
+	char devname[256];
+	char buf[256];
+	int devn;
+	int ctlfd;
+
+	f = fopen("/proc/devices", "r");
+	if (!f) {
+		eprintf("Cannot open control path to the driver\n");
+		return -1;
+	}
+
+	devn = 0;
+	while (!feof(f)) {
+		if (!fgets(buf, sizeof (buf), f))
+			break;
+
+		if (sscanf(buf, "%d %s", &devn, devname) != 2)
+			continue;
+
+		if (!strcmp(devname, name))
+			break;
+
+		devn = 0;
+	}
+
+	fclose(f);
+	if (!devn) {
+		eprintf("cannot find %s in /proc/devices - "
+			"make sure the module is loaded\n", name);
+		return -1;
+	}
+
+	snprintf(devname, sizeof(devname), "/dev/%s%d", name, minor);
+
+	unlink(devname);
+	if (mknod(devname, (S_IFCHR | 0600), (devn << 8) | minor)) {
+		eprintf("cannot create %s %s\n", devname, strerror(errno));
+		return -1;
+	}
+
+	ctlfd = open(devname, O_RDWR);
+	if (ctlfd < 0) {
+		eprintf("cannot open %s %s\n", devname, strerror(errno));
+		return -1;
+	}
+
+	return ctlfd;
+}
+
+/*
+ * Xenstore watch callback entry point. This code replaces the hotplug scripts,
+ * and as soon as the xenstore backend driver entries are created, this script
+ * gets called.
+ */
+static void tgt_probe(struct xs_handle *h, struct xenbus_watch *w,
+		      const char *bepath_im)
+{
+	struct backend_info *be = NULL;
+	char *frontend = NULL, *bepath = NULL, *p;
+	int err, len, fd, msize = (SRP_RING_PAGES + SRP_MAPPED_PAGES) * PAGE_SIZE;
+	void *addr;
+	uint32_t hostno;
+
+	bepath = strdup(bepath_im);
+	if (!bepath) {
+		dprintf("No path\n");
+		return;
+	}
+
+	/*
+	 *asserts that xenstore structure is always 7 levels deep
+	 *e.g. /local/domain/0/backend/vbd/1/2049
+	 */
+        len = strsep_len(bepath, '/', 7);
+        if (len < 0)
+		goto free_be;
+        bepath[len] = '\0';
+
+	be = calloc(1, sizeof(*be));
+	if (!be) {
+		dprintf("ERROR: allocating backend structure\n");
+		goto free_be;
+	}
+
+	err = xs_gather(h, bepath,
+			"frontend-id", "%d", &be->frontend_id,
+			"frontend", NULL, &frontend,
+			NULL);
+
+	dprintf("%d %d %s\n", err, be->frontend_id, frontend);
+	if (err) {
+		/*
+		 *Unable to find frontend entries,
+		 *bus-id is no longer valid
+		 */
+		dprintf("ERROR: Frontend-id check failed, removing backend: [%s]\n",bepath);
+
+		/*BE info should already exist, free new mem and find old entry*/
+		free(be);
+		be = be_lookup_be(bepath);
+/* 		if (be && be->blkif) */
+/* 			backend_remove(h, be); */
+/* 		else */
+/* 			goto free_be; */
+	        if (bepath)
+			free(bepath);
+		return;
+	}
+
+        /* Are we already tracking this device? */
+        if (be_exists_be(bepath))
+		goto free_be;
+
+        err = xs_gather(h, bepath, "hostno", "%u", &hostno, NULL);
+	if (err)
+		goto free_be;
+
+	fd = xen_chrdev_open("scsiback", hostno);
+	if (fd < 0)
+		goto free_be;
+
+	addr = mmap(NULL, msize, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (addr == MAP_FAILED) {
+		eprintf("failed to mmap %u %s\n", msize, strerror(errno));
+		goto close_fd;
+	}
+	dprintf("addr: %p size: %d\n", addr, msize);
+
+	err = tgt_target_create(0, be->frontend_id);
+	if (err && err != -EEXIST)
+		goto close_fd;
+
+	be->backpath = bepath;
+       	be->frontpath = frontend;
+
+	/* FIXME */
+	err = tgt_target_bind(be->frontend_id, hostno, 0);
+
+        list_add(&be->list, &belist);
+
+        dprintf("[PROBE]\tADDED NEW DEVICE (%s)\n", bepath);
+	dprintf("\tFRONTEND (%s),(%d)\n", frontend, be->frontend_id);
+
+	tgt_device_setup(h, bepath);
+	return;
+
+close_fd:
+	close(fd);
+free_be:
+	if (frontend)
+		free(frontend);
+        if (bepath)
+		free(bepath);
+	if(be)
+		free(be);
+	return;
+}
+
+/*
+ *We set a general watch on the backend vbd directory
+ *ueblktap_probe is called for every update
+ *Our job is simply to monitor for new entries, and to
+ *create the state and attach a disk.
+ */
+
+int add_blockdevice_probe_watch(struct xs_handle *h, const char *domname)
+{
+	char *domid, *path;
+	struct xenbus_watch *watch;
+	int er;
+
+	domid = get_dom_domid(h, domname);
+
+	dprintf("%s: %s\n", domname, (domid != NULL) ? domid : "[ not found! ]");
+
+	asprintf(&path, "/local/domain/%s/backend/scsi", domid);
+	if (path == NULL)
+		return -ENOMEM;
+
+	watch = (struct xenbus_watch *)malloc(sizeof(struct xenbus_watch));
+	if (!watch) {
+		dprintf("ERROR: unable to malloc vbd_watch [%s]\n", path);
+		return -EINVAL;
+	}
+	watch->node = path;
+	watch->callback = tgt_probe;
+	er = register_xenbus_watch(h, watch);
+	if (er == 0) {
+		dprintf("ERROR: adding vbd probe watch %s\n", path);
+		return -EINVAL;
+	}
+	return 0;
+}

Added: trunk/usr/xen/xs_api.c
===================================================================
--- trunk/usr/xen/xs_api.c	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/xen/xs_api.c	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,352 @@
+/*
+ * xs_api.c
+ * 
+ * blocktap interface functions to xenstore
+ *
+ * (c) 2005 Andrew Warfield and Julian Chesterfield
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <printf.h>
+#include <string.h>
+#include <err.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <xs.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+/* #include "blktaplib.h" */
+#include "list.h"
+#include "xs_api.h"
+
+#if 0
+#define DPRINTF(_f, _a...) printf ( _f , ## _a )
+#else
+#define DPRINTF(_f, _a...) ((void)0)
+#endif
+
+static LIST_HEAD(watches);
+#define BASE_DEV_VAL 2048
+
+int xs_gather(struct xs_handle *xs, const char *dir, ...)
+{
+	va_list ap;
+	const char *name;
+	char *path, **e;
+	int ret = 0, num,i;
+	unsigned int len;
+	xs_transaction_t xth;
+
+again:
+	if( (xth = xs_transaction_start(xs)) == XBT_NULL ) {
+		printf("unable to start xs trasanction\n");
+		ret = ENOMEM;
+		return ret;
+	}
+	
+	va_start(ap, dir);
+	while (ret == 0 && (name = va_arg(ap, char *)) != NULL) {
+		const char *fmt = va_arg(ap, char *);
+		void *result = va_arg(ap, void *);
+		char *p;
+		
+		if (asprintf(&path, "%s/%s", dir, name) == -1)
+		{
+			printf("allocation error in xs_gather!\n");
+			ret = ENOMEM;
+			break;
+		}
+		
+		p = xs_read(xs, xth, path, &len);
+		
+		
+		free(path);
+		if (p == NULL) {
+			ret = ENOENT;
+			break;
+		}
+		if (fmt) {
+			if (sscanf(p, fmt, result) == 0)
+				ret = EINVAL;
+			free(p);
+		} else
+			*(char **)result = p;
+	}
+	va_end(ap);
+
+	if (!xs_transaction_end(xs, xth, ret)) {
+		if (ret == 0 && errno == EAGAIN)
+			goto again;
+                else
+			ret = errno;
+	}
+
+	return ret;
+}
+
+
+/* Single printf and write: returns -errno or 0. */
+int xs_printf(struct xs_handle *h, const char *dir, const char *node, 
+	      const char *fmt, ...)
+{
+        char *buf, *path;
+        va_list ap;
+        int ret;
+	
+        va_start(ap, fmt);
+        ret = vasprintf(&buf, fmt, ap);
+        va_end(ap);
+	
+        asprintf(&path, "%s/%s", dir, node);
+	
+        if ((path == NULL) || (buf == NULL))
+		return 0;
+
+        ret = xs_write(h, XBT_NULL, path, buf, strlen(buf)+1);
+	
+        free(buf);
+        free(path);
+	
+        return ret;
+}
+
+
+int xs_exists(struct xs_handle *h, const char *path)
+{
+	char **d;
+	unsigned int num;
+	xs_transaction_t xth;
+	
+	if( (xth = xs_transaction_start(h)) == XBT_NULL ) {
+		printf("unable to start xs trasanction\n");
+		return 0;
+	}	
+	
+	d = xs_directory(h, xth, path, &num);
+	xs_transaction_end(h, xth, 0);
+	if (d == NULL)
+		return 0;
+	free(d);
+	return 1;
+}
+
+
+
+/* This assumes that the domain name we are looking for is unique! Name parameter Domain-0 */
+char *get_dom_domid(struct xs_handle *h, const char *name)
+{
+	char **e, *val, *domid = NULL;
+	unsigned int num, len;
+	int i;
+	char *path;
+	xs_transaction_t xth;
+	
+	if ( (xth = xs_transaction_start(h)) == XBT_NULL ) {
+		warn("unable to start xs trasanction\n");
+		return NULL;
+	}
+	
+	e = xs_directory(h, xth, "/local/domain", &num);
+	
+	i=0;
+	while (i < num) {
+		asprintf(&path, "/local/domain/%s/name", e[i]);
+		val = xs_read(h, xth, path, &len);
+		free(path);
+		if (val == NULL)
+			continue;
+		
+		if (strcmp(val, name) == 0) {
+			/* match! */
+			asprintf(&path, "/local/domain/%s/domid", e[i]);
+			domid = xs_read(h, xth, path, &len);
+			free(val);
+			free(path);
+			break;
+		}
+		free(val);
+		i++;
+	}
+	xs_transaction_end(h, xth, 0);
+	
+	free(e);
+	return domid;
+}
+
+int convert_dev_name_to_num(char *name) {
+	char *p_sd, *p_hd, *p_xvd, *p_plx, *p, *alpha,*ptr;
+	int majors[10] = {3,22,33,34,56,57,88,89,90,91};
+	int maj,i;
+
+	asprintf(&p_sd,"/dev/sd");
+	asprintf(&p_hd,"/dev/hd");
+	asprintf(&p_xvd,"/dev/xvd");
+	asprintf(&p_plx,"plx");
+	asprintf(&alpha,"abcdefghijklmnop");
+	
+
+	if(strstr(name,p_sd)!=NULL) {
+		p = name + strlen(p_sd);
+		for(i=0,ptr=alpha;i<strlen(alpha);i++) {
+			if(*ptr==*p)
+				break;
+			*ptr++;
+		}
+		*p++;
+		return BASE_DEV_VAL + (16*i) + atoi(p);
+	} else if(strstr(name,p_hd)!=NULL) {
+		p = name + strlen(p_hd);
+		for(i=0,ptr=alpha;i<strlen(alpha);i++) {
+			if(*ptr==*p) break;
+			*ptr++;
+		}
+		*p++;
+		return (majors[i/2]*256) + atoi(p);
+
+	} else if(strstr(name,p_xvd)!=NULL) {
+		p = name + strlen(p_xvd);
+		for(i=0,ptr=alpha;i<strlen(alpha);i++) {
+			if(*ptr==*p) break;
+			*ptr++;
+		}
+		*p++;
+		return (202*256) + (16*i) + atoi(p);
+
+	} else if(strstr(name,p_plx)!=NULL) {
+		p = name + strlen(p_plx);
+		return atoi(p);
+
+	} else {
+		DPRINTF("Unknown device type, setting to default.\n");
+		return BASE_DEV_VAL;
+	}
+	return 0;
+}
+
+/* A little paranoia: we don't just trust token. */
+static struct xenbus_watch *find_watch(const char *token)
+{
+	struct xenbus_watch *i, *cmp;
+	
+	cmp = (void *)strtoul(token, NULL, 16);
+	
+	list_for_each_entry(i, &watches, list)
+		if (i == cmp)
+			return i;
+	return NULL;
+}
+
+/* Register callback to watch this node. like xs_watch, return 0 on failure */
+int register_xenbus_watch(struct xs_handle *h, struct xenbus_watch *watch)
+{
+	/* Pointer in ascii is the token. */
+	char token[sizeof(watch) * 2 + 1];
+	int er;
+	
+	sprintf(token, "%lX", (long)watch);
+	if (find_watch(token)) 
+	{
+		warn("watch collision!");
+		return -EINVAL;
+	}
+	
+	er = xs_watch(h, watch->node, token);
+	if (er != 0) {
+		list_add(&watch->list, &watches);
+	} 
+        
+	return er;
+}
+
+int unregister_xenbus_watch(struct xs_handle *h, struct xenbus_watch *watch)
+{
+	char token[sizeof(watch) * 2 + 1];
+	int er;
+	
+	sprintf(token, "%lX", (long)watch);
+	if (!find_watch(token))
+	{
+		warn("no such watch!");
+		return -EINVAL;
+	}
+	
+	
+	er = xs_unwatch(h, watch->node, token);
+	list_del(&watch->list);
+	
+	if (er == 0)
+		warn("XENBUS Failed to release watch %s: %i",
+		     watch->node, er);
+	return 0;
+}
+
+/* Re-register callbacks to all watches. */
+void reregister_xenbus_watches(struct xs_handle *h)
+{
+	struct xenbus_watch *watch;
+	char token[sizeof(watch) * 2 + 1];
+	
+	list_for_each_entry(watch, &watches, list) {
+		sprintf(token, "%lX", (long)watch);
+		xs_watch(h, watch->node, token);
+	}
+}
+
+/* based on watch_thread() */
+int xs_fire_next_watch(struct xs_handle *h)
+{
+	char **res;
+	char *token;
+	char *node = NULL;
+	struct xenbus_watch *w;
+	int er;
+	unsigned int num;
+	
+	res = xs_read_watch(h, &num);
+	if (res == NULL) 
+		return -EAGAIN; /* in O_NONBLOCK, read_watch returns 0... */
+	
+	node  = res[XS_WATCH_PATH];
+	token = res[XS_WATCH_TOKEN];
+	
+	w = find_watch(token);
+	if (!w)
+	{
+		warn("unregistered watch fired");
+		goto done;
+	}
+	w->callback(h, w, node);
+	
+ done:
+	free(res);
+	return 1;
+}

Added: trunk/usr/xen/xs_api.h
===================================================================
--- trunk/usr/xen/xs_api.h	2006-12-16 14:13:20 UTC (rev 683)
+++ trunk/usr/xen/xs_api.h	2006-12-16 17:38:32 UTC (rev 684)
@@ -0,0 +1,50 @@
+/*
+ * xs_api.h
+ *
+ * (c) 2005 Andrew Warfield and Julian Chesterfield
+ *
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+struct xenbus_watch
+{
+        struct list_head list;
+        char *node;
+        void (*callback)(struct xs_handle *h, 
+                         struct xenbus_watch *, 
+                         const  char *node);
+};
+
+int xs_gather(struct xs_handle *xs, const char *dir, ...);
+int xs_printf(struct xs_handle *h, const char *dir, const char *node, 
+	      const char *fmt, ...);
+int xs_exists(struct xs_handle *h, const char *path);
+char *get_dom_domid(struct xs_handle *h, const char *name);
+int convert_dev_name_to_num(char *name);
+int register_xenbus_watch(struct xs_handle *h, struct xenbus_watch *watch);
+int unregister_xenbus_watch(struct xs_handle *h, struct xenbus_watch *watch);
+void reregister_xenbus_watches(struct xs_handle *h);
+int xs_fire_next_watch(struct xs_handle *h);



From tomo at mail.berlios.de  Sat Dec 16 18:39:07 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 16 Dec 2006 18:39:07 +0100
Subject: [Stgt-svn] r685 - trunk
Message-ID: <200612161739.kBGHd7B4029470@sheep.berlios.de>

Author: tomo
Date: 2006-12-16 18:39:02 +0100 (Sat, 16 Dec 2006)
New Revision: 685

Modified:
   trunk/README
Log:
Fix README


Modified: trunk/README
===================================================================
--- trunk/README	2006-12-16 17:38:32 UTC (rev 684)
+++ trunk/README	2006-12-16 17:39:02 UTC (rev 685)
@@ -31,11 +31,11 @@
 Now you are ready to build target drivers. If you like to use the
 iSCSI target driver:
 
-host:~/tgt$ make KERNELSRC=<kernel-src-directory> ISCSI=1
+host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1
 
 Or if you like to use the IBM VIO target driver:
 
-host:~/tgt$ make KERNELSRC=<kernel-src-directory> IBMVIO=1
+host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> IBMVIO=1
 
 Make sure that everything is built successfully.
 



From tomo at mail.berlios.de  Sat Dec 16 18:42:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 16 Dec 2006 18:42:02 +0100
Subject: [Stgt-svn] r686 - trunk/usr
Message-ID: <200612161742.kBGHg2KD032623@sheep.berlios.de>

Author: tomo
Date: 2006-12-16 18:41:55 +0100 (Sat, 16 Dec 2006)
New Revision: 686

Modified:
   trunk/usr/Makefile
Log:
Fix Makefile.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-12-16 17:39:02 UTC (rev 685)
+++ trunk/usr/Makefile	2006-12-16 17:41:55 UTC (rev 686)
@@ -16,7 +16,7 @@
 TGTD_OBJS += $(addprefix xen/, xen.o xs_api.o xenbus.o)
 TGTD_OBJS += tgtif.o bd_xen.o
 else
-INCLUDES += -I../include -I$(KERNELSRC)/include
+INCLUDES += -I$(KERNELSRC)/include
 LIBS += -laio
 endif
 



From tomo at mail.berlios.de  Mon Dec 18 07:31:45 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 07:31:45 +0100
Subject: [Stgt-svn] r687 - trunk/patches
Message-ID: <200612180631.kBI6Vjac020907@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 07:31:44 +0100 (Mon, 18 Dec 2006)
New Revision: 687

Removed:
   trunk/patches/README
Log:
Remove patch README.

Deleted: trunk/patches/README
===================================================================
--- trunk/patches/README	2006-12-16 17:41:55 UTC (rev 686)
+++ trunk/patches/README	2006-12-18 06:31:44 UTC (rev 687)
@@ -1,6 +0,0 @@
-This patchset for scsi-rc-fixes git tree:
-
-http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-rc-fixes-2.6.git;a=summary
-
-Get the tree and apply all the patches. Sorry for the
-inconvenience. We will create our own git tree shortly.



From tomo at mail.berlios.de  Mon Dec 18 13:54:05 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 13:54:05 +0100
Subject: [Stgt-svn] r688 - trunk/usr
Message-ID: <200612181254.kBICs54p004830@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 13:54:04 +0100 (Mon, 18 Dec 2006)
New Revision: 688

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Add backing-store option to tgtadm.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-18 06:31:44 UTC (rev 687)
+++ trunk/usr/mgmt.c	2006-12-18 12:54:04 UTC (rev 688)
@@ -114,7 +114,7 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun);
+		err = tgt_device_create(req->tid, req->lun, params);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 06:31:44 UTC (rev 687)
+++ trunk/usr/target.c	2006-12-18 12:54:04 UTC (rev 688)
@@ -131,10 +131,37 @@
 	INIT_LIST_HEAD(&q->queue);
 }
 
-int tgt_device_create(int tid, uint64_t lun)
+static int tgt_device_path_update(struct target *target,
+				  struct tgt_device *device, char *path)
 {
+	char *p;
+	int err, dev_fd;
+	uint64_t size;
+
+	p = strdup(path);
+	if (!p)
+		return -ENOMEM;
+
+	err = target->bdt->bd_open(device, path, &dev_fd, &size);
+	if (err) {
+		free(p);
+		return -EINVAL;
+	}
+
+	device->fd = dev_fd;
+	device->addr = 0;
+	device->size = size;
+	device->path = p;
+
+	return 0;
+}
+
+int tgt_device_create(int tid, uint64_t lun, char *args)
+{
 	struct target *target;
 	struct tgt_device *device;
+	char *val = args + strlen(args) + 1;
+	int err;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -148,15 +175,28 @@
 		return -EINVAL;
 	}
 
+	if (!*args)
+		return -EINVAL;
+
 	device = zalloc(sizeof(*device) + target->bdt->bd_datasize);
 	if (!device)
 		return -ENOMEM;
 
+	if (!strcmp(args, "path")) {
+		err = tgt_device_path_update(target, device, val);
+		if (err) {
+			free(device);
+			return -EINVAL;
+		}
+	} else {
+		free(device);
+		return -EINVAL;
+	}
+
 	device->lun = lun;
 
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, lun);
-	memset(device->scsi_sn, 0, sizeof(device->scsi_sn));
 
 	tgt_cmd_queue_init(&device->cmd_queue);
 	device_hlist_insert(target, device);
@@ -232,36 +272,6 @@
 	return rest;
 }
 
-static int tgt_device_path_update(struct target *target,
-				  struct tgt_device *device, char *path)
-{
-	char *p;
-	int err, dev_fd;
-	uint64_t size;
-
-	if (device->path) {
-		eprintf("path is already set %p\n", device->path);
-		return -EINVAL;
-	}
-
-	p = strdup(path);
-	if (!p)
-		return -ENOMEM;
-
-	err = target->bdt->bd_open(device, path, &dev_fd, &size);
-	if (err) {
-		free(p);
-		return -EINVAL;
-	}
-
-	device->fd = dev_fd;
-	device->addr = 0;
-	device->size = size;
-	device->path = p;
-
-	return 0;
-}
-
 int tgt_device_update(int tid, uint64_t dev_id, char *name)
 {
 	int err = 0;
@@ -279,9 +289,7 @@
 		return -EINVAL;
 	}
 
-	if (!strcmp(name, "path"))
-		err = tgt_device_path_update(target, device, val);
-	else if (!strcmp(name, "scsi_id"))
+	if (!strcmp(name, "scsi_id"))
 		memcpy(device->scsi_id, val, sizeof(device->scsi_id) - 1);
 	else if (!strcmp(name, "scsi_sn"))
 		memcpy(device->scsi_sn, val, sizeof(device->scsi_sn) - 1);

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-18 06:31:44 UTC (rev 687)
+++ trunk/usr/tgtadm.c	2006-12-18 12:54:04 UTC (rev 688)
@@ -71,9 +71,10 @@
 	{"lun", required_argument, NULL, 'u'},
 	{"aid", required_argument, NULL, 'a'},
 	{"hostno", required_argument, NULL, 'i'},
-	{"bus", required_argument, NULL, 'b'},
+	{"bus", required_argument, NULL, 'B'},
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
+	{"backing-store", required_argument, NULL, 'b'},
 	{"debug", no_argument, NULL, 'd'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
@@ -303,11 +304,11 @@
 	char *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
-	char *name, *value;
+	char *name, *value, *path;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
-	lldname = name = value = NULL;
+	lldname = name = value = path = NULL;
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
@@ -340,9 +341,12 @@
 		case 'i':
 			hostno = strtol(optarg, NULL, 10);
 			break;
-		case 'b':
+		case 'B':
 			hostno = bus_to_host(optarg);
 			break;
+		case 'b':
+			path = optarg;
+			break;
 		case 'n':
 			name = optarg;
 			break;
@@ -356,7 +360,7 @@
 			usage(0);
 			break;
 		default:
-			usage(-1);
+			usage(1);
 		}
 	}
 	if (op < 0) {
@@ -369,12 +373,12 @@
 		while (optind < argc)
 			fprintf(stderr, "%s", argv[optind++]);
 		fprintf(stderr, "\n");
-		usage(-1);
+		usage(1);
 	}
 
 	if (mode < 0) {
 		fprintf(stderr, "unknown mode\n");
-		usage(-1);
+		usage(1);
 	}
 
 	memset(buf, 0, sizeof(buf));
@@ -390,10 +394,18 @@
 	req->aid = aid;
 	req->host_no = hostno;
 
-	if (name && value) {
-		int rest = sizeof(buf) - sizeof(*req);
+	/* FIXME */
+	if ((name && value) || path) {
+		int rest;
 		char *p = (char *) req->data;
 
+		if (path) {
+			name = "path";
+			value = path;
+		}
+		rest = sizeof(buf) - sizeof(*req);
+		p = (char *) req->data;
+
 		len = snprintf(p, rest, "%s", name);
 		len += 1;
 		len += snprintf(p + len, rest - len, "%s", value);

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-18 06:31:44 UTC (rev 687)
+++ trunk/usr/tgtadm.h	2006-12-18 12:54:04 UTC (rev 688)
@@ -23,6 +23,19 @@
 	MODE_ACCOUNT,
 };
 
+enum tgtadm_target_type {
+	TARGET_SBC, /* disk */
+	TARGET_SSC, /* tape */
+	TARGET_MMC, /* cdrom */
+	TARGET_OSD, /* object storage device */
+};
+
+/* backing store type */
+enum tgtadm_lu_bs_type {
+	LU_BS_FILE,
+	LU_BS_RAW, /* pass through */
+};
+
 struct tgtadm_req {
 	enum tgtadm_mode mode;
 	enum tgtadm_op op;
@@ -36,12 +49,12 @@
 	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;
 	uint64_t data[0];
-} __attribute__ ((aligned (sizeof(uint64_t))));
+};
 
 struct tgtadm_res {
 	uint32_t err;
 	uint32_t len;
 	uint64_t data[0];
-} __attribute__ ((aligned (sizeof(uint64_t))));;
+};
 
 #endif

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-18 06:31:44 UTC (rev 687)
+++ trunk/usr/tgtd.h	2006-12-18 12:54:04 UTC (rev 688)
@@ -64,7 +64,7 @@
 extern int kspace_send_cmd_res(int host_no, int len, int result,
 			       int rw, uint64_t addr, uint64_t tag);
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun);
+extern int tgt_device_create(int tid, uint64_t lun, char *args);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);



From tomo at mail.berlios.de  Mon Dec 18 15:22:06 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 15:22:06 +0100
Subject: [Stgt-svn] r689 - in trunk/usr: . iscsi
Message-ID: <200612181422.kBIEM6kb016880@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 15:22:05 +0100 (Mon, 18 Dec 2006)
New Revision: 689

Modified:
   trunk/usr/iscsi/account.c
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
Log:
tgtadm uses 'name=value' format.


Modified: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-12-18 12:54:04 UTC (rev 688)
+++ trunk/usr/iscsi/account.c	2006-12-18 14:22:05 UTC (rev 689)
@@ -91,8 +91,12 @@
 	if (!ac)
 		return ENOENT;
 
-	str = name + strlen(name) + 1;
+	str = strchr(name, '=');
+	if (!str)
+		return EINVAL;
 
+	*str++ = '\0';
+
 	if (!strcmp(name, "Type")) {
 		if (ac->type != ACCOUNT_INVALID)
 			return err;

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-12-18 12:54:04 UTC (rev 688)
+++ trunk/usr/iscsi/target.c	2006-12-18 14:22:05 UTC (rev 689)
@@ -155,6 +155,8 @@
 
 	str = name + strlen(name) + 1;
 
+	dprintf("%s:%s\n", name, str);
+
 	idx = param_index_by_name(name, session_keys);
 	if (idx >= 0)
 		err = iscsi_session_param_update(target, idx, str);

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-18 12:54:04 UTC (rev 688)
+++ trunk/usr/mgmt.c	2006-12-18 14:22:05 UTC (rev 689)
@@ -73,16 +73,21 @@
 		err = tgt_target_bind(req->tid, req->host_no, lld_no);
 		break;
 	case OP_UPDATE:
+	{
+		char *p;
 		err = -EINVAL;
+
+		p = strchr(params, '=');
+		if (!p)
+			break;
+		*p++ = '\0';
+
 		if (!strcmp(params, "state"))
-			err = tgt_set_target_state(req->tid,
-						   params + strlen(params) + 1);
-		else if (!strcmp(params, "iotype"))
-			err = tgt_set_target_iotype(req->tid,
-						    params + strlen(params) + 1);
+			err = tgt_set_target_state(req->tid, p);
 		else if (tgt_drivers[lld_no]->target_update)
 			err = tgt_drivers[lld_no]->target_update(req->tid, params);
 		break;
+	}
 	case OP_SHOW:
 		if (req->tid < 0)
 			err = tgt_target_show_all((char *)res->data,

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 12:54:04 UTC (rev 688)
+++ trunk/usr/target.c	2006-12-18 14:22:05 UTC (rev 689)
@@ -134,24 +134,23 @@
 static int tgt_device_path_update(struct target *target,
 				  struct tgt_device *device, char *path)
 {
-	char *p;
 	int err, dev_fd;
 	uint64_t size;
 
-	p = strdup(path);
-	if (!p)
+	path = strdup(path);
+	if (!path)
 		return -ENOMEM;
 
 	err = target->bdt->bd_open(device, path, &dev_fd, &size);
 	if (err) {
-		free(p);
+		free(path);
 		return -EINVAL;
 	}
 
 	device->fd = dev_fd;
 	device->addr = 0;
 	device->size = size;
-	device->path = p;
+	device->path = path;
 
 	return 0;
 }
@@ -160,7 +159,7 @@
 {
 	struct target *target;
 	struct tgt_device *device;
-	char *val = args + strlen(args) + 1;
+	char *p;
 	int err;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
@@ -178,17 +177,17 @@
 	if (!*args)
 		return -EINVAL;
 
+	p = strchr(args, '=');
+	if (!p)
+		return -EINVAL;
+	p++;
+
 	device = zalloc(sizeof(*device) + target->bdt->bd_datasize);
 	if (!device)
 		return -ENOMEM;
 
-	if (!strcmp(args, "path")) {
-		err = tgt_device_path_update(target, device, val);
-		if (err) {
-			free(device);
-			return -EINVAL;
-		}
-	} else {
+	err = tgt_device_path_update(target, device, p);
+	if (err) {
 		free(device);
 		return -EINVAL;
 	}
@@ -275,7 +274,6 @@
 int tgt_device_update(int tid, uint64_t dev_id, char *name)
 {
 	int err = 0;
-	char *val = name + strlen(name) + 1;
 	struct target *target;
 	struct tgt_device *device;
 
@@ -289,10 +287,10 @@
 		return -EINVAL;
 	}
 
-	if (!strcmp(name, "scsi_id"))
-		memcpy(device->scsi_id, val, sizeof(device->scsi_id) - 1);
-	else if (!strcmp(name, "scsi_sn"))
-		memcpy(device->scsi_sn, val, sizeof(device->scsi_sn) - 1);
+	if (!strcmp(name, "scsi_id="))
+		memcpy(device->scsi_id, name + 8, sizeof(device->scsi_id) - 1);
+	else if (!strcmp(name, "scsi_sn="))
+		memcpy(device->scsi_sn, name + 8, sizeof(device->scsi_sn) - 1);
 	else
 		err = -EINVAL;
 

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-18 12:54:04 UTC (rev 688)
+++ trunk/usr/tgtadm.c	2006-12-18 14:22:05 UTC (rev 689)
@@ -89,9 +89,9 @@
 	else {
 		printf("Usage: %s [OPTION]\n", program_name);
 		printf("\
-Linux Target Framework Administration Utility.\n\
+Linux SCSI Target Framework Administration Utility.\n\
 \n\
-  --op new --tid=[id] --params [name]\n\
+  --op create --tid=[id] --params [name]\n\
                         add a new target with [id]. [id] must not be zero.\n\
   --op delete --tid=[id]\n\
                         delete specific target with [id]. The target must\n\
@@ -397,18 +397,14 @@
 	/* FIXME */
 	if ((name && value) || path) {
 		int rest;
-		char *p = (char *) req->data;
 
 		if (path) {
 			name = "path";
 			value = path;
 		}
 		rest = sizeof(buf) - sizeof(*req);
-		p = (char *) req->data;
 
-		len = snprintf(p, rest, "%s", name);
-		len += 1;
-		len += snprintf(p + len, rest - len, "%s", value);
+		len = snprintf((char *)req->data, rest, "%s=%s", name, value);
 	}
 
 	req->len = sizeof(*req) + len;



From tomo at mail.berlios.de  Mon Dec 18 15:46:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 15:46:17 +0100
Subject: [Stgt-svn] r690 - trunk/usr
Message-ID: <200612181446.kBIEkHJx019787@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 15:46:16 +0100 (Mon, 18 Dec 2006)
New Revision: 690

Modified:
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Add backing store type.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-18 14:22:05 UTC (rev 689)
+++ trunk/usr/tgtadm.c	2006-12-18 14:46:16 UTC (rev 690)
@@ -75,12 +75,13 @@
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
 	{"backing-store", required_argument, NULL, 'b'},
+	{"backing-store-type", required_argument, NULL, 'S'},
 	{"debug", no_argument, NULL, 'd'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:b:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:B:b:S:n:v:dh";
 
 static void usage(int status)
 {
@@ -256,9 +257,19 @@
 	return host;
 }
 
+static int backing_store_type(char *str)
+{
+	if (!strcmp(str, "file"))
+		return LU_BS_FILE;
+	else if (!strcmp(str, "raw"))
+		return LU_BS_RAW;
+	else
+		return -1;
+}
+
 static int str_to_mode(char *str)
 {
-	int mode = -1;
+	int mode;
 
 	if (!strcmp("target", str) || !strcmp("tgt", str))
 		mode = MODE_TARGET;
@@ -270,6 +281,8 @@
 		mode = MODE_CONNECTION;
 	else if (!strcmp("account", str))
 		mode = MODE_ACCOUNT;
+	else
+		mode = -1;
 
 	return mode;
 }
@@ -298,7 +311,7 @@
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len = 0;
-	int tid = -1;
+	int tid = -1, bs_type = LU_BS_FILE;
 	uint32_t cid, hostno, aid;
 	uint64_t sid, lun;
 	char *lldname;
@@ -347,6 +360,9 @@
 		case 'b':
 			path = optarg;
 			break;
+		case 'S':
+			bs_type = backing_store_type(optarg);
+			break;
 		case 'n':
 			name = optarg;
 			break;
@@ -393,6 +409,7 @@
 	req->lun = lun;
 	req->aid = aid;
 	req->host_no = hostno;
+	req->bs_type = bs_type;
 
 	/* FIXME */
 	if ((name && value) || path) {

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-18 14:22:05 UTC (rev 689)
+++ trunk/usr/tgtadm.h	2006-12-18 14:46:16 UTC (rev 690)
@@ -45,6 +45,7 @@
 	uint64_t sid;
 	uint32_t cid;
 	uint64_t lun;
+	uint32_t bs_type;
 	uint32_t aid;
 	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-18 14:22:05 UTC (rev 689)
+++ trunk/usr/tgtd.h	2006-12-18 14:46:16 UTC (rev 690)
@@ -100,6 +100,5 @@
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);
-extern int tgt_set_target_iotype(int tid, char *str);
 
 #endif



From tomo at mail.berlios.de  Mon Dec 18 17:12:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 17:12:10 +0100
Subject: [Stgt-svn] r691 - trunk/usr
Message-ID: <200612181612.kBIGCAg3028928@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 17:12:09 +0100 (Mon, 18 Dec 2006)
New Revision: 691

Modified:
   trunk/usr/target.c
Log:
Update show format.

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 14:46:16 UTC (rev 690)
+++ trunk/usr/target.c	2006-12-18 16:12:09 UTC (rev 691)
@@ -741,8 +741,8 @@
 	enum scsi_target_iotype value;
 	char *name;
 } target_iotype[] = {
-	{SCSI_TARGET_FILEIO, "fileio"},
-	{SCSI_TARGET_RAWIO, "rawio"},
+	{SCSI_TARGET_FILEIO, "file"},
+	{SCSI_TARGET_RAWIO, "raw"},
 };
 
 static char *target_iotype_name(enum scsi_target_state state)
@@ -835,6 +835,24 @@
 	return err;
 }
 
+static char *print_disksize(uint64_t size)
+{
+	static char buf[64];
+	char *format[] = {"", "K", "M", "G", "T"};
+	int i;
+
+	memset(buf, 0, sizeof(buf));
+	for (i = 1; size >= (1ULL << (i * 10)) && i < ARRAY_SIZE(format); i++)
+		;
+	i--;
+	sprintf(buf, "%" PRIu64 "%s", size >> (i * 10), format[i]);
+	return buf;
+}
+
+#define TAB1 "    "
+#define TAB2 TAB1 TAB1
+#define TAB3 TAB1 TAB1 TAB1
+
 int tgt_target_show_all(char *buf, int rest)
 {
 	int i, len, total;
@@ -843,9 +861,11 @@
 
 	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "tid %d: lld name %s: iotype %s: state %s\n",
+			len = snprintf(buf, rest, "Target: %d\n"
+				       TAB1 "System information:\n"
+				       TAB2 "Driver name: %s\n"
+				       TAB2 "Status: %s\n",
 				       target->tid, tgt_drivers[target->lid]->name,
-				       target_iotype_name(target->target_iotype),
 				       target_state_name(target->target_state));
 			buf += len;
 			total += len;
@@ -853,9 +873,27 @@
 			if (!rest)
 				goto out;
 
+			len = snprintf(buf, rest, TAB1 "LUN information:\n");
+			buf += len;
+			total += len;
+			rest -= len;
+			if (!rest)
+				goto out;
+
 			list_for_each_entry(device, &target->device_list, d_list) {
-				len = snprintf(buf, rest, "\tlun %" PRIu64 ": path %s\n",
-					       device->lun, device->path);
+				len = snprintf(buf, rest,
+					       TAB2 "LUN: %" PRIu64 "\n"
+					       TAB3 "SCSI ID: %s\n"
+					       TAB3 "SCSI SN: %s\n"
+					       TAB3 "Size: %s\n"
+					       TAB3 "Backing store: %s\n"
+					       TAB3 "Backing store type: %s\n",
+					       device->lun,
+					       device->scsi_id,
+					       device->scsi_sn,
+					       print_disksize(device->size),
+					       device->path,
+					       target_iotype_name(target->target_iotype));
 				buf += len;
 				total += len;
 				rest -= len;



From tomo at mail.berlios.de  Mon Dec 18 17:53:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 17:53:04 +0100
Subject: [Stgt-svn] r692 - trunk/usr
Message-ID: <200612181653.kBIGr4DY001749@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 17:53:04 +0100 (Mon, 18 Dec 2006)
New Revision: 692

Modified:
   trunk/usr/target.c
   trunk/usr/tgtadm.c
Log:
Add target type to tgtadm.

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 16:12:09 UTC (rev 691)
+++ trunk/usr/target.c	2006-12-18 16:53:04 UTC (rev 692)
@@ -863,7 +863,7 @@
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
 			len = snprintf(buf, rest, "Target: %d\n"
 				       TAB1 "System information:\n"
-				       TAB2 "Driver name: %s\n"
+				       TAB2 "Driver: %s\n"
 				       TAB2 "Status: %s\n",
 				       target->tid, tgt_drivers[target->lid]->name,
 				       target_state_name(target->target_state));

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-18 16:12:09 UTC (rev 691)
+++ trunk/usr/tgtadm.c	2006-12-18 16:53:04 UTC (rev 692)
@@ -267,6 +267,20 @@
 		return -1;
 }
 
+static int target_type(char *str)
+{
+	if (!strcmp(str, "disk"))
+		return TARGET_SBC;
+	else if (!strcmp(str, "tape"))
+		return TARGET_SSC;
+	else if (!strcmp(str, "cd"))
+		return TARGET_MMC;
+	else if (!strcmp(str, "osd"))
+		return TARGET_OSD;
+	else
+		return -1;
+}
+
 static int str_to_mode(char *str)
 {
 	int mode;



From tomo at mail.berlios.de  Mon Dec 18 18:33:45 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 18:33:45 +0100
Subject: [Stgt-svn] r693 - in trunk/usr: . iscsi xen
Message-ID: <200612181733.kBIHXj9u016401@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 18:33:33 +0100 (Mon, 18 Dec 2006)
New Revision: 693

Modified:
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.h
   trunk/usr/xen/xenbus.c
Log:
Add name to tgt_target structure.

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/iscsi/iscsid.h	2006-12-18 17:33:33 UTC (rev 693)
@@ -214,7 +214,6 @@
 	struct param session_param[ISCSI_PARAM_MAX];
 
 	int tid;
-	char name[ISCSI_NAME_LEN];
 	char *alias;
 
 	int max_nr_sessions;

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/iscsi/target.c	2006-12-18 17:33:33 UTC (rev 693)
@@ -17,6 +17,7 @@
 #include <sys/socket.h>
 #include "iscsid.h"
 #include "tgtadm.h"
+#include "tgtd.h"
 
 static LIST_HEAD(targets_list);
 
@@ -25,12 +26,12 @@
 	struct iscsi_target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
-		if (name && strcmp(target->name, name))
+		if (name && strcmp(tgt_targetname(target->tid), name))
 			continue;
 /* 		if (cops->initiator_access(target->tid, conn->fd) < 0) */
 /* 			continue; */
 
-		text_key_add(conn, "TargetName", target->name);
+		text_key_add(conn, "TargetName", tgt_targetname(target->tid));
 		text_key_add(conn, "TargetAddress", addr);
 	}
 }
@@ -40,7 +41,7 @@
 	struct iscsi_target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
-		if (!strcmp(target->name, name))
+		if (!strcmp(tgt_targetname(target->tid), name))
 			return target;
 	}
 
@@ -160,13 +161,6 @@
 	idx = param_index_by_name(name, session_keys);
 	if (idx >= 0)
 		err = iscsi_session_param_update(target, idx, str);
-	else {
-		if (!strcmp(name, "iqn")) {
-			memcpy(target->name, str, sizeof(target->name) - 1);
-			err = 0;
-		}
-	}
-
 	return err;
 }
 
@@ -254,12 +248,6 @@
 
 	switch (mode) {
 	case MODE_TARGET:
-		len = snprintf(buf, rest, "iqn=%s\n", target->name);
-		buf += len;
-		total += len;
-		rest -= len;
-		if (!rest)
-			goto out;
 		len = show_iscsi_param(buf, target->session_param, rest);
 		total += len;
 		break;
@@ -274,6 +262,6 @@
 	default:
 		break;
 	}
-out:
+
 	return total;
 }

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/mgmt.c	2006-12-18 17:33:33 UTC (rev 693)
@@ -60,7 +60,7 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(lld_no, req->tid);
+		err = tgt_target_create(lld_no, req->tid, params);
 		if (!err && tgt_drivers[lld_no]->target_create)
 			tgt_drivers[lld_no]->target_create(req->tid, params);
 		break;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/target.c	2006-12-18 17:33:33 UTC (rev 693)
@@ -678,11 +678,17 @@
 	return 0;
 }
 
-int tgt_target_create(int lld, int tid)
+int tgt_target_create(int lld, int tid, char *args)
 {
 	int i;
 	struct target *target;
+	char *targetname;
 
+	targetname = strchr(args, '=');
+	if (!targetname)
+		return -EINVAL;
+	targetname++;
+
 	target = target_lookup(tid);
 	if (target) {
 		eprintf("Target id %d already exists\n", tid);
@@ -693,6 +699,12 @@
 	if (!target)
 		return -ENOMEM;
 
+	target->name = strdup(targetname);
+	if (!target->name) {
+		free(target);
+		return -ENOMEM;
+	}
+
 	target->tid = tid;
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
 		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
@@ -861,11 +873,13 @@
 
 	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "Target: %d\n"
+			len = snprintf(buf, rest, "Target %d: %s\n"
 				       TAB1 "System information:\n"
 				       TAB2 "Driver: %s\n"
 				       TAB2 "Status: %s\n",
-				       target->tid, tgt_drivers[target->lid]->name,
+				       target->tid,
+				       target->name,
+				       tgt_drivers[target->lid]->name,
 				       target_state_name(target->target_state));
 			buf += len;
 			total += len;
@@ -906,6 +920,17 @@
 	return total;
 }
 
+char *tgt_targetname(int tid)
+{
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return NULL;
+
+	return target->name;
+}
+
 __attribute__((constructor)) static void target_init(void)
 {
 	int i;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/target.h	2006-12-18 17:33:33 UTC (rev 693)
@@ -21,6 +21,8 @@
 };
 
 struct target {
+	char *name;
+
 	int tid;
 	int lid;
 

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/tgtadm.c	2006-12-18 17:33:33 UTC (rev 693)
@@ -74,6 +74,7 @@
 	{"bus", required_argument, NULL, 'B'},
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
+	{"targetname", required_argument, NULL, 'T'},
 	{"backing-store", required_argument, NULL, 'b'},
 	{"backing-store-type", required_argument, NULL, 'S'},
 	{"debug", no_argument, NULL, 'd'},
@@ -81,7 +82,7 @@
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:B:b:S:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:b:S:n:v:dh";
 
 static void usage(int status)
 {
@@ -331,11 +332,11 @@
 	char *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
-	char *name, *value, *path;
+	char *name, *value, *path, *targetname;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
-	lldname = name = value = path = NULL;
+	lldname = name = value = path = targetname = NULL;
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
@@ -371,6 +372,9 @@
 		case 'B':
 			hostno = bus_to_host(optarg);
 			break;
+		case 'T':
+			targetname = optarg;
+			break;
 		case 'b':
 			path = optarg;
 			break;
@@ -426,13 +430,19 @@
 	req->bs_type = bs_type;
 
 	/* FIXME */
-	if ((name && value) || path) {
+	if ((name && value) || path || targetname) {
 		int rest;
 
 		if (path) {
 			name = "path";
 			value = path;
 		}
+
+		if (targetname) {
+			name = "targetname";
+			value = targetname;
+		}
+
 		rest = sizeof(buf) - sizeof(*req);
 
 		len = snprintf((char *)req->data, rest, "%s=%s", name, value);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/tgtd.h	2006-12-18 17:33:33 UTC (rev 693)
@@ -68,9 +68,10 @@
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
-extern int tgt_target_create(int lld, int tid);
+extern int tgt_target_create(int lld, int tid, char *targetname);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);
+extern char *tgt_targetname(int tid);
 extern int tgt_target_show_all(char *buf, int rest);
 
 typedef void (event_handler_t)(int fd, int events, void *data);

Modified: trunk/usr/xen/xenbus.c
===================================================================
--- trunk/usr/xen/xenbus.c	2006-12-18 16:53:04 UTC (rev 692)
+++ trunk/usr/xen/xenbus.c	2006-12-18 17:33:33 UTC (rev 693)
@@ -265,6 +265,7 @@
 	int err, len, fd, msize = (SRP_RING_PAGES + SRP_MAPPED_PAGES) * PAGE_SIZE;
 	void *addr;
 	uint32_t hostno;
+	char targetname[16];
 
 	bepath = strdup(bepath_im);
 	if (!bepath) {
@@ -331,7 +332,8 @@
 	}
 	dprintf("addr: %p size: %d\n", addr, msize);
 
-	err = tgt_target_create(0, be->frontend_id);
+	snprintf(targetname, sizeof(targetname), "xen %d", be->frontend_id);
+	err = tgt_target_create(0, be->frontend_id, targetname);
 	if (err && err != -EEXIST)
 		goto close_fd;
 



From tomo at mail.berlios.de  Mon Dec 18 18:55:21 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 18 Dec 2006 18:55:21 +0100
Subject: [Stgt-svn] r694 - trunk/usr
Message-ID: <200612181755.kBIHtLDd018653@sheep.berlios.de>

Author: tomo
Date: 2006-12-18 18:55:20 +0100 (Mon, 18 Dec 2006)
New Revision: 694

Modified:
   trunk/usr/target.c
Log:
Fix device order.

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-18 17:33:33 UTC (rev 693)
+++ trunk/usr/target.c	2006-12-18 17:55:20 UTC (rev 694)
@@ -86,7 +86,7 @@
 		if (device->lun < pos->lun)
 			break;
 	}
-	list_add(&device->d_list, &pos->d_list);
+	list_add_tail(&device->d_list, &pos->d_list);
 }
 
 static void device_list_remove(struct tgt_device *device)



From tomo at mail.berlios.de  Wed Dec 20 00:38:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 00:38:10 +0100
Subject: [Stgt-svn] r695 - trunk/doc
Message-ID: <200612192338.kBJNcAas031341@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 00:38:09 +0100 (Wed, 20 Dec 2006)
New Revision: 695

Modified:
   trunk/doc/README.ibmvstgt
Log:
Update README.ibmvstgt for the new UI


Modified: trunk/doc/README.ibmvstgt
===================================================================
--- trunk/doc/README.ibmvstgt	2006-12-18 17:55:20 UTC (rev 694)
+++ trunk/doc/README.ibmvstgt	2006-12-19 23:38:09 UTC (rev 695)
@@ -27,10 +27,13 @@
 The following example creates a target with id 1, adds a logical unit
 (backed by /dev/sdb1) with lun 0, and then bind the target with #1 scsi host.
 
-host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op new --tid 1
-host:~/tgt# ./usr/tgtadm --lld ibmvio --mode logicalunit --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+You need to targetname to create a new target just as a reference.
+
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op new --tid 1 --targetname volume1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode logicalunit --op new --tid 1 --lun 0 -b /dev/sdb1
 host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op bind --tid 1 --host 1
 
+
 Please see /var/log/daemon.log (your Linux distributions may use the
 different log file name again) to make sure that everything is
 fine. You should see something like the followings:



From tomo at mail.berlios.de  Wed Dec 20 00:40:12 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 00:40:12 +0100
Subject: [Stgt-svn] r696 - trunk/doc
Message-ID: <200612192340.kBJNeCGc003192@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 00:40:10 +0100 (Wed, 20 Dec 2006)
New Revision: 696

Modified:
   trunk/doc/README.iscsi
Log:
Update README.iscsi for the new UI


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-12-19 23:38:09 UTC (rev 695)
+++ trunk/doc/README.iscsi	2006-12-19 23:40:10 UTC (rev 696)
@@ -1,10 +1,7 @@
 Preface
 -------------
-This document describes how to configure the iSCSI target driver with
-tgtadm-iscsi, which is a wrapper of tgtadm, protocol-independent
-management tool.
-
-If you are interested in management with tgtadm, refer to
+This show a simple example to set up some targets. If you are
+interested in advanced management, please refer to
 README.iscsi.advance.
 
 
@@ -27,35 +24,56 @@
 Let's create one target devce and add a logical unit to it:
 
 host:~/tgt$ su
-host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --iqn iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --lun 0 --path /dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/hdc1
 
 
 You can get the current configuration:
 
-host:~/tgt# ./usr/tgtadm-iscsi --op show
-tid 1: lld name iscsi: state suspended
-        lun 0: path /dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: suspended
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN: 
+            Size: 1G
+            Backing store: /dev/hdc1
+            Backing store type: file
 
 
 If you don't need no more configuration (iSCSI parameters, security,
 etc), you are ready to accept initiators. In this case, you can go to
 `accepting initiators` session.
 
-
 You can add lots of logical units:
 
-host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --lun 1 --path /var/tmp/image
-host:~/tgt# ./usr/tgtadm-iscsi --op show
-tid 1: lld name iscsi: state suspended
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /dev/hdd1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: suspended
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN: 
+            Size: 1G
+            Backing store: /dev/hdc1
+            Backing store type: file
+        LUN: 1
+            SCSI ID: deadbeaf1:1
+            SCSI SN: 
+            Size: 20G
+            Backing store: /dev/hdd1
+            Backing store type: file
 
 
 You can get iSCSI parameters of the target:
 
-host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1
-iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target --tid 1
 MaxRecvDataSegmentLength=8192
 MaxXmitDataSegmentLength=8192
 HeaderDigest=None
@@ -80,12 +98,11 @@
 You can chage iSCSI parameters like the folloing (e.g. set
 MaxRecvDataSegmentLength to 16384):
 
-host:~/tgt# ./usr/tgtadm-iscsi --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
 
 You can get iSCSI parameters again to see it change:
 
-host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1
-iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target --tid 1
 MaxRecvDataSegmentLength=16384
 MaxXmitDataSegmentLength=8192
 HeaderDigest=None
@@ -134,27 +151,32 @@
 
 Accepting initiators
 -------------
-Now this target is ready to accept initiators. Make sure what you have
-now once again:
+Now this target is ready to accept initiators. If you've done the configuration:
 
-host:~/tgt# ./usr/tgtadm-iscsi --op show
-tid 1: lld name iscsi: state suspended
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN: 
+            Size: 42M
+            Backing store: /dev/hdc1
+            Backing store type: file
+        LUN: 1
+            SCSI ID: deadbeaf1:1
+            SCSI SN: 
+            Size: 40M
+            Backing store: /dev/hdd1
+            Backing store type: file
 
 
-If you've done the configuration:
+Now your target is ready to accept initiators.
 
-host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --start
-host:~/tgt# ./usr/tgtadm-iscsi --op show
-tid 1: lld name iscsi: state running
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
 
-
-Now your target accepts initiators.
-
-
 After the target the target accepted some initiators, you can see them:
 
 host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --sid 0



From tomo at mail.berlios.de  Wed Dec 20 00:41:41 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 00:41:41 +0100
Subject: [Stgt-svn] r697 - trunk/doc
Message-ID: <200612192341.kBJNff7s004259@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 00:41:40 +0100 (Wed, 20 Dec 2006)
New Revision: 697

Modified:
   trunk/doc/README.iscsi
Log:
Remove old stuff from README.iSCSI


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-12-19 23:40:10 UTC (rev 696)
+++ trunk/doc/README.iscsi	2006-12-19 23:41:40 UTC (rev 697)
@@ -124,31 +124,6 @@
 MaxConnections=1
 
 
-Security
--------------
-Let's create a new incoming account:
-
-host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --aid 0 --user tomo --password jfeo --in
-
-Make another one:
-
-host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --aid 1 --user apple --password orange --in
-
-
-You can see the result:
-
-host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1 --aid 0
-aid:0 Type:Incoming User:tomo Password:jfeo
-aid:1 Type:Incoming User:apple Password:orange
-
-
-Specifying aid (account id) to see all the accounts is a bit
-strange. Probably, this will be changed later on.
-
-You can assign one account to lots of targets. Each target can have 16
-accounts. We don't support removing or unbinding accounts now.
-
-
 Accepting initiators
 -------------
 Now this target is ready to accept initiators. If you've done the configuration:
@@ -176,39 +151,6 @@
 
 Now your target is ready to accept initiators.
 
-
-After the target the target accepted some initiators, you can see them:
-
-host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --sid 0
-sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel
-sid:281474980708864 initiator:iqn.1987-05.com.cisco:01.4438aca09387
-
-
-You can see the negotiated iSCSI parameters between the target and the
-initiator by specifying sid:
-
-host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --sid  281474980708864
-MaxRecvDataSegmentLength=8192
-MaxXmitDataSegmentLength=1024
-HeaderDigest=None
-DataDigest=None
-InitialR2T=Yes
-MaxOutstandingR2T=1
-ImmediateData=Yes
-FirstBurstLength=65536
-MaxBurstLength=262144
-DataPDUInOrder=Yes
-DataSequenceInOrder=Yes
-ErrorRecoveryLevel=0
-IFMarker=No
-OFMarker=No
-DefaultTime2Wait=2
-DefaultTime2Retain=0
-OFMarkInt=Reject
-IFMarkInt=Reject
-MaxConnections=1
-
-
 Shutdown
 -------------
 host:~/tgt# killall -9 tgtd



From tomo at mail.berlios.de  Wed Dec 20 00:44:58 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 00:44:58 +0100
Subject: [Stgt-svn] r698 - trunk/usr
Message-ID: <200612192344.kBJNiwXu006827@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 00:44:57 +0100 (Wed, 20 Dec 2006)
New Revision: 698

Modified:
   trunk/usr/bd_sg.c
Log:
Fix bd_sg fail path.


Modified: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2006-12-19 23:41:40 UTC (rev 697)
+++ trunk/usr/bd_sg.c	2006-12-19 23:44:57 UTC (rev 698)
@@ -83,6 +83,7 @@
 
 	if(!S_ISBLK(st.st_mode)) {
 		eprintf("only scsi devices are supported %s\n", path);
+		err = -EINVAL;
 		goto close_fd;
 	}
 



From tomo at mail.berlios.de  Wed Dec 20 00:49:26 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 00:49:26 +0100
Subject: [Stgt-svn] r699 - trunk/usr
Message-ID: <200612192349.kBJNnQ6o016927@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 00:49:25 +0100 (Wed, 20 Dec 2006)
New Revision: 699

Modified:
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Add raw option support to target creation.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-19 23:44:57 UTC (rev 698)
+++ trunk/usr/target.c	2006-12-19 23:49:25 UTC (rev 699)
@@ -34,6 +34,7 @@
 #include "tgtd.h"
 #include "driver.h"
 #include "target.h"
+#include "tgtadm.h"
 
 static struct target *hostt[MAX_NR_HOST];
 static struct list_head target_hash_list[1 << HASH_ORDER];
@@ -678,77 +679,6 @@
 	return 0;
 }
 
-int tgt_target_create(int lld, int tid, char *args)
-{
-	int i;
-	struct target *target;
-	char *targetname;
-
-	targetname = strchr(args, '=');
-	if (!targetname)
-		return -EINVAL;
-	targetname++;
-
-	target = target_lookup(tid);
-	if (target) {
-		eprintf("Target id %d already exists\n", tid);
-		return -EINVAL;
-	}
-
-	target = zalloc(sizeof(*target));
-	if (!target)
-		return -ENOMEM;
-
-	target->name = strdup(targetname);
-	if (!target->name) {
-		free(target);
-		return -ENOMEM;
-	}
-
-	target->tid = tid;
-	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
-		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
-
-	INIT_LIST_HEAD(&target->device_list);
-	for (i = 0; i < ARRAY_SIZE(target->device_hash_list); i++)
-		INIT_LIST_HEAD(&target->device_hash_list[i]);
-
-	target->target_iotype = SCSI_TARGET_FILEIO;
-	target->target_state = SCSI_TARGET_SUSPENDED;
-
-	target->bdt = tgt_drivers[lld]->default_bdt;
-	target->lid = lld;
-
-	tgt_cmd_queue_init(&target->cmd_queue);
-	target_hlist_insert(target);
-
-	eprintf("Succeed to create a new target %d\n", tid);
-
-	return 0;
-}
-
-int tgt_target_destroy(int tid)
-{
-	struct target *target;
-
-	target = target_lookup(tid);
-	if (!target)
-		return -ENOENT;
-
-	if (!list_empty(&target->device_list)) {
-		eprintf("target %d still has devices\n", tid);
-		return -EBUSY;
-	}
-
-	if (!list_empty(&target->cmd_queue.queue))
-		return -EBUSY;
-
-	target_hlist_remove(target);
-	free(target);
-
-	return 0;
-}
-
 static struct {
 	enum scsi_target_iotype value;
 	char *name;
@@ -771,30 +701,6 @@
 	return name;
 }
 
-int tgt_set_target_iotype(int tid, char *str)
-{
-	int i, err = -EINVAL;
-	struct target *target;
-
-	target = target_lookup(tid);
-	if (!target)
-		return -ENOENT;
-
-	for (i = 0; i < ARRAY_SIZE(target_iotype); i++) {
-		if (!strcmp(target_iotype[i].name, str)) {
-			target->target_iotype = target_iotype[i].value;
-			err = 0;
-
-			/* FIXME */
-			if (target->target_iotype == SCSI_TARGET_RAWIO)
-				target->bdt = &sg_bdt;
-			break;
-		}
-	}
-
-	return err;
-}
-
 enum scsi_target_state tgt_get_target_state(int tid)
 {
 	struct target *target;
@@ -931,6 +837,100 @@
 	return target->name;
 }
 
+int tgt_target_create(int lld, int tid, char *args)
+{
+	int i, t_type = TARGET_SBC, bs_type = LU_BS_FILE;
+	struct target *target;
+	char *p, *q, *targetname = NULL;
+
+	p = args;
+	while ((q = strsep(&p, ","))) {
+		char *str;
+
+		str = strchr(q, '=');
+		if (str) {
+			*str++ = '\0';
+
+			if (!strcmp("targetname", q))
+				targetname = str;
+			else if (!strcmp("target-type", q))
+				t_type = strtol(str, NULL, 10);
+			else if (!strcmp("backing-store-type", q))
+				bs_type = strtol(str, NULL, 10);
+			else
+				eprintf("Unknow option %s\n", q);
+		}
+	};
+
+	if (!targetname)
+		return -EINVAL;
+
+	target = target_lookup(tid);
+	if (target) {
+		eprintf("Target id %d already exists\n", tid);
+		return -EINVAL;
+	}
+
+	target = zalloc(sizeof(*target));
+	if (!target)
+		return -ENOMEM;
+
+	target->name = strdup(targetname);
+	if (!target->name) {
+		free(target);
+		return -ENOMEM;
+	}
+
+	target->tid = tid;
+	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
+		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
+
+	INIT_LIST_HEAD(&target->device_list);
+	for (i = 0; i < ARRAY_SIZE(target->device_hash_list); i++)
+          		INIT_LIST_HEAD(&target->device_hash_list[i]);
+
+	/* FIXME */
+	if (bs_type == LU_BS_RAW) {
+		target->target_iotype = SCSI_TARGET_RAWIO;
+		target->bdt = &sg_bdt;
+	} else {
+		target->target_iotype = SCSI_TARGET_FILEIO;
+		target->bdt = tgt_drivers[lld]->default_bdt;
+	}
+
+	target->target_state = SCSI_TARGET_SUSPENDED;
+	target->lid = lld;
+
+	tgt_cmd_queue_init(&target->cmd_queue);
+	target_hlist_insert(target);
+
+	eprintf("Succeed to create a new target %d\n", tid);
+
+	return 0;
+}
+
+int tgt_target_destroy(int tid)
+{
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	if (!list_empty(&target->device_list)) {
+		eprintf("target %d still has devices\n", tid);
+		return -EBUSY;
+	}
+
+	if (!list_empty(&target->cmd_queue.queue))
+		return -EBUSY;
+
+	target_hlist_remove(target);
+	free(target);
+
+	return 0;
+}
+
 __attribute__((constructor)) static void target_init(void)
 {
 	int i;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-19 23:44:57 UTC (rev 698)
+++ trunk/usr/tgtadm.c	2006-12-19 23:49:25 UTC (rev 699)
@@ -75,6 +75,7 @@
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
 	{"targetname", required_argument, NULL, 'T'},
+	{"target-type", required_argument, NULL, 'p'},
 	{"backing-store", required_argument, NULL, 'b'},
 	{"backing-store-type", required_argument, NULL, 'S'},
 	{"debug", no_argument, NULL, 'd'},
@@ -82,7 +83,7 @@
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:b:S:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:p:b:S:n:v:dh";
 
 static void usage(int status)
 {
@@ -326,12 +327,13 @@
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len = 0;
-	int tid = -1, bs_type = LU_BS_FILE;
+	int tid = -1, rest = BUFSIZE;
+	int t_type = TARGET_SBC, bs_type = LU_BS_FILE;
 	uint32_t cid, hostno, aid;
 	uint64_t sid, lun;
 	char *lldname;
 	struct tgtadm_req *req;
-	char buf[BUFSIZE];
+	char buf[BUFSIZE + sizeof(*req)];
 	char *name, *value, *path, *targetname;
 	int mode = MODE_SYSTEM;
 
@@ -375,6 +377,9 @@
 		case 'T':
 			targetname = optarg;
 			break;
+		case 'p':
+			t_type = target_type(optarg);
+			break;
 		case 'b':
 			path = optarg;
 			break;
@@ -427,12 +432,9 @@
 	req->lun = lun;
 	req->aid = aid;
 	req->host_no = hostno;
-	req->bs_type = bs_type;
 
 	/* FIXME */
 	if ((name && value) || path || targetname) {
-		int rest;
-
 		if (path) {
 			name = "path";
 			value = path;
@@ -443,11 +445,17 @@
 			value = targetname;
 		}
 
-		rest = sizeof(buf) - sizeof(*req);
-
 		len = snprintf((char *)req->data, rest, "%s=%s", name, value);
 	}
 
+	if (t_type != TARGET_SBC)
+		len += snprintf((char *)req->data + len, rest - len,
+				"%starget-type=%d", len ? "," : "", t_type);
+
+	if (bs_type != LU_BS_FILE)
+		len += snprintf((char *)req->data + len, rest - len,
+				"%sbacking-store-type=%d", len ? "," : "", bs_type);
+
 	req->len = sizeof(*req) + len;
 
 	err = ipc_mgmt_req(req);

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-19 23:44:57 UTC (rev 698)
+++ trunk/usr/tgtadm.h	2006-12-19 23:49:25 UTC (rev 699)
@@ -45,7 +45,6 @@
 	uint64_t sid;
 	uint32_t cid;
 	uint64_t lun;
-	uint32_t bs_type;
 	uint32_t aid;
 	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;



From tomo at mail.berlios.de  Wed Dec 20 13:48:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 20 Dec 2006 13:48:50 +0100
Subject: [Stgt-svn] r700 - trunk/usr
Message-ID: <200612201248.kBKCmoSL011580@sheep.berlios.de>

Author: tomo
Date: 2006-12-20 13:48:49 +0100 (Wed, 20 Dec 2006)
New Revision: 700

Modified:
   trunk/usr/bd_aio.c
Log:
Fix bd_aio_close bug.

Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-12-19 23:49:25 UTC (rev 699)
+++ trunk/usr/bd_aio.c	2006-12-20 12:48:49 UTC (rev 700)
@@ -65,7 +65,6 @@
 
 static void bd_aio_close(struct tgt_device *dev)
 {
-	tgt_event_del(dev->fd);
 	close(dev->fd);
 }
 



From tomo at mail.berlios.de  Sun Dec 24 09:57:35 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 09:57:35 +0100
Subject: [Stgt-svn] r701 - trunk/patches
Message-ID: <200612240857.kBO8vZZe027489@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 09:57:34 +0100 (Sun, 24 Dec 2006)
New Revision: 701

Added:
   trunk/patches/aioepoll-2.6.20-rc2.diff
Log:
Add EPOLL patch for 2.6.20-rc2 (with aio_queue_work dealy disabled).


Added: trunk/patches/aioepoll-2.6.20-rc2.diff
===================================================================
--- trunk/patches/aioepoll-2.6.20-rc2.diff	2006-12-20 12:48:49 UTC (rev 700)
+++ trunk/patches/aioepoll-2.6.20-rc2.diff	2006-12-24 08:57:34 UTC (rev 701)
@@ -0,0 +1,242 @@
+diff --git a/fs/aio.c b/fs/aio.c
+index 5f577a6..b546104 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -30,6 +30,7 @@ #include <linux/aio.h>
+ #include <linux/highmem.h>
+ #include <linux/workqueue.h>
+ #include <linux/security.h>
++#include <linux/eventpoll.h>
+ 
+ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+@@ -802,6 +803,8 @@ static void aio_queue_work(struct kioctx
+ 		timeout = 1;
+ 	else
+ 		timeout = HZ/10;
++
++	timeout = 1;
+ 	queue_delayed_work(aio_wq, &ctx->wq, timeout);
+ }
+ 
+@@ -1487,6 +1490,9 @@ static ssize_t aio_setup_iocb(struct kio
+ 		if (file->f_op->aio_fsync)
+ 			kiocb->ki_retry = aio_fsync;
+ 		break;
++	case IOCB_CMD_EPOLL_WAIT:
++		kiocb->ki_retry = eventpoll_aio_wait;
++		break;
+ 	default:
+ 		dprintk("EINVAL: io_submit: no operation provided\n");
+ 		ret = -EINVAL;
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index 3ae644e..6b78ada 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
+ #include <linux/mount.h>
+ #include <linux/bitops.h>
+ #include <linux/mutex.h>
++#include <linux/aio.h>
+ #include <asm/uaccess.h>
+ #include <asm/system.h>
+ #include <asm/io.h>
+@@ -642,6 +643,150 @@ eexit_1:
+ 	return error;
+ }
+ 
++static void eventpoll_aio_timer(unsigned long data)
++{
++	struct kiocb *iocb = (struct kiocb *)data;
++	struct timer_list *timer = (struct timer_list *)iocb->private;
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	unsigned long flags;
++
++	(void)del_timer(timer);
++	write_lock_irqsave(&ep->lock, flags);
++	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
++	write_unlock_irqrestore(&ep->lock, flags);
++}
++
++static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
++{
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	int ret = -1;
++	struct list_head *list;
++	int seen = 0;
++
++	write_lock_irq(&ep->lock);
++
++	if (iocb->private)
++		del_timer((struct timer_list *)iocb->private);
++	/*
++	 *  We need to know whether the event was removed from the wait
++	 *  queue in order to return the proper status to the cancellation
++	 *  code.
++	 */
++	list = &ep->wq.task_list;
++
++	do {
++		struct list_head *next;
++		if (list == &iocb->ki_wait.task_list)
++			seen++;
++		next = list->next;
++		if (next->prev != list) {
++			seen += 2;
++			break;
++		}
++		list = next;
++	} while (list != &ep->wq.task_list);
++
++	if (seen == 1) {
++		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
++		ret = 0;
++	}
++	write_unlock_irq(&ep->lock);
++
++	if (ret == 0) {
++		/* successfully cancelled request */
++		kfree(iocb->private);
++		iocb->private = NULL;
++		/* drop the i/o reference */
++		aio_put_req(iocb);
++	} else
++		ret = -EAGAIN;
++
++	event->res = event->res2 = 0;
++	/* drop the cancel reference */
++	aio_put_req(iocb);
++
++	return ret;
++}
++
++/*
++ * iocb->ki_nbytes -- number of events
++ * iocb->ki_pos    -- relative timeout in milliseconds
++ * iocb->private   -- NULL first go;  after that, it's set to the the
++ *                    absolute timeout in jiffies.
++ */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb)
++{
++	struct file *file = iocb->ki_filp;
++	ssize_t ret = -EINVAL;
++	int relative_ms;
++	unsigned long expires;
++	unsigned long now;
++	struct timer_list *timer;
++
++	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
++	    iocb->ki_nbytes <= 0)
++		return -EINVAL;
++
++	if (!iocb->private) {
++		/*
++		 *  Note that we unconditionally allocate a timer, but we
++		 *  only use it if a timeout was specified.  Otherwise, it
++		 *  is just a holder for the "infinite" value.
++		 */
++		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++		if (!timer)
++			return -ENOMEM;
++
++		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++			expires = MAX_SCHEDULE_TIMEOUT;
++		else
++			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
++
++		init_timer(timer);
++		timer->function = eventpoll_aio_timer;
++		timer->data = (unsigned long)iocb;
++		timer->expires = expires;
++	} else {
++		timer = (struct timer_list *)iocb->private;
++		expires = timer->expires;
++	}
++
++	now = jiffies;
++	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
++		relative_ms = EP_MAX_MSTIMEO;
++	else if (time_before(now, expires))
++		relative_ms = jiffies_to_msecs(expires - now);
++	else
++		relative_ms = 0;
++
++	iocb->ki_cancel = aio_epoll_cancel;
++	ret = ep_poll(file->private_data,
++		      (struct epoll_event __user *)iocb->ki_buf,
++		      iocb->ki_nbytes, relative_ms);
++
++	/*
++	 *  If a timeout was specified, ep_poll returned retry, and we have
++	 *  not yet registered a timer, go ahead and register one.
++	 */
++	if (ret == -EIOCBRETRY && !iocb->private) {
++		iocb->private = timer;
++		add_timer(timer);
++	}
++
++	/*
++	 *  Did we get any events?
++	 */
++	if (ret >= 0) {
++		iocb->ki_cancel = NULL;
++		(void)del_timer(timer);
++		kfree(timer);
++		iocb->private = NULL;
++	}
++
++	return ret;
++}
+ 
+ /*
+  * Implement the event wait interface for the eventpoll file. It is the kernel
+@@ -1564,6 +1709,12 @@ retry:
+ 
+ 	res = 0;
+ 	if (list_empty(&ep->rdllist)) {
++		if (in_aio() && jtimeout) {
++			__add_wait_queue(&ep->wq, current->io_wait);
++			res = -EIOCBRETRY;
++			write_unlock_irqrestore(&ep->lock, flags);
++			goto out;
++		}
+ 		/*
+ 		 * We don't have any available event to return to the caller.
+ 		 * We need to sleep here, and we will be wake up by
+@@ -1608,7 +1759,7 @@ retry:
+ 	if (!res && eavail &&
+ 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
+ 		goto retry;
+-
++out:
+ 	return res;
+ }
+ 
+diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
+index e3ca0a4..292c811 100644
+--- a/include/linux/aio_abi.h
++++ b/include/linux/aio_abi.h
+@@ -43,6 +43,7 @@ enum {
+ 	IOCB_CMD_NOOP = 6,
+ 	IOCB_CMD_PREADV = 7,
+ 	IOCB_CMD_PWRITEV = 8,
++  	IOCB_CMD_EPOLL_WAIT = 9,
+ };
+ 
+ /* read() from /dev/aio returns these structures. */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..ed04500 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
+ /* Used to release the epoll bits inside the "struct file" */
+ void eventpoll_release_file(struct file *file);
+ 
++/* Used to provide epoll_wait() to sys_io_submit() */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb);
++
+ /*
+  * This is called from inside fs/file_table.c:__fput() to unlink files
+  * from the eventpoll interface. We need to have this facility to cleanup



From tomo at mail.berlios.de  Sun Dec 24 09:59:53 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 09:59:53 +0100
Subject: [Stgt-svn] r702 - trunk/patches
Message-ID: <200612240859.kBO8xr1x027745@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 09:59:53 +0100 (Sun, 24 Dec 2006)
New Revision: 702

Removed:
   trunk/patches/aioepoll-2.6.20-rc1.diff
Log:
Remove the old EPOLL patch for 2.6.20-rc1.

Deleted: trunk/patches/aioepoll-2.6.20-rc1.diff
===================================================================
--- trunk/patches/aioepoll-2.6.20-rc1.diff	2006-12-24 08:57:34 UTC (rev 701)
+++ trunk/patches/aioepoll-2.6.20-rc1.diff	2006-12-24 08:59:53 UTC (rev 702)
@@ -1,233 +0,0 @@
-diff --git a/fs/aio.c b/fs/aio.c
-index 5f577a6..236c94a 100644
---- a/fs/aio.c
-+++ b/fs/aio.c
-@@ -30,6 +30,7 @@ #include <linux/aio.h>
- #include <linux/highmem.h>
- #include <linux/workqueue.h>
- #include <linux/security.h>
-+#include <linux/eventpoll.h>
- 
- #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
-@@ -1487,6 +1488,9 @@ static ssize_t aio_setup_iocb(struct kio
- 		if (file->f_op->aio_fsync)
- 			kiocb->ki_retry = aio_fsync;
- 		break;
-+	case IOCB_CMD_EPOLL_WAIT:
-+		kiocb->ki_retry = eventpoll_aio_wait;
-+		break;
- 	default:
- 		dprintk("EINVAL: io_submit: no operation provided\n");
- 		ret = -EINVAL;
-diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index 3ae644e..6b78ada 100644
---- a/fs/eventpoll.c
-+++ b/fs/eventpoll.c
-@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
- #include <linux/mount.h>
- #include <linux/bitops.h>
- #include <linux/mutex.h>
-+#include <linux/aio.h>
- #include <asm/uaccess.h>
- #include <asm/system.h>
- #include <asm/io.h>
-@@ -642,6 +643,150 @@ eexit_1:
- 	return error;
- }
- 
-+static void eventpoll_aio_timer(unsigned long data)
-+{
-+	struct kiocb *iocb = (struct kiocb *)data;
-+	struct timer_list *timer = (struct timer_list *)iocb->private;
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	unsigned long flags;
-+
-+	(void)del_timer(timer);
-+	write_lock_irqsave(&ep->lock, flags);
-+	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
-+	write_unlock_irqrestore(&ep->lock, flags);
-+}
-+
-+static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
-+{
-+	struct file *file = iocb->ki_filp;
-+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
-+	int ret = -1;
-+	struct list_head *list;
-+	int seen = 0;
-+
-+	write_lock_irq(&ep->lock);
-+
-+	if (iocb->private)
-+		del_timer((struct timer_list *)iocb->private);
-+	/*
-+	 *  We need to know whether the event was removed from the wait
-+	 *  queue in order to return the proper status to the cancellation
-+	 *  code.
-+	 */
-+	list = &ep->wq.task_list;
-+
-+	do {
-+		struct list_head *next;
-+		if (list == &iocb->ki_wait.task_list)
-+			seen++;
-+		next = list->next;
-+		if (next->prev != list) {
-+			seen += 2;
-+			break;
-+		}
-+		list = next;
-+	} while (list != &ep->wq.task_list);
-+
-+	if (seen == 1) {
-+		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
-+		ret = 0;
-+	}
-+	write_unlock_irq(&ep->lock);
-+
-+	if (ret == 0) {
-+		/* successfully cancelled request */
-+		kfree(iocb->private);
-+		iocb->private = NULL;
-+		/* drop the i/o reference */
-+		aio_put_req(iocb);
-+	} else
-+		ret = -EAGAIN;
-+
-+	event->res = event->res2 = 0;
-+	/* drop the cancel reference */
-+	aio_put_req(iocb);
-+
-+	return ret;
-+}
-+
-+/*
-+ * iocb->ki_nbytes -- number of events
-+ * iocb->ki_pos    -- relative timeout in milliseconds
-+ * iocb->private   -- NULL first go;  after that, it's set to the the
-+ *                    absolute timeout in jiffies.
-+ */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb)
-+{
-+	struct file *file = iocb->ki_filp;
-+	ssize_t ret = -EINVAL;
-+	int relative_ms;
-+	unsigned long expires;
-+	unsigned long now;
-+	struct timer_list *timer;
-+
-+	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
-+	    iocb->ki_nbytes <= 0)
-+		return -EINVAL;
-+
-+	if (!iocb->private) {
-+		/*
-+		 *  Note that we unconditionally allocate a timer, but we
-+		 *  only use it if a timeout was specified.  Otherwise, it
-+		 *  is just a holder for the "infinite" value.
-+		 */
-+		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
-+		if (!timer)
-+			return -ENOMEM;
-+
-+		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
-+			expires = MAX_SCHEDULE_TIMEOUT;
-+		else
-+			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
-+
-+		init_timer(timer);
-+		timer->function = eventpoll_aio_timer;
-+		timer->data = (unsigned long)iocb;
-+		timer->expires = expires;
-+	} else {
-+		timer = (struct timer_list *)iocb->private;
-+		expires = timer->expires;
-+	}
-+
-+	now = jiffies;
-+	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
-+		relative_ms = EP_MAX_MSTIMEO;
-+	else if (time_before(now, expires))
-+		relative_ms = jiffies_to_msecs(expires - now);
-+	else
-+		relative_ms = 0;
-+
-+	iocb->ki_cancel = aio_epoll_cancel;
-+	ret = ep_poll(file->private_data,
-+		      (struct epoll_event __user *)iocb->ki_buf,
-+		      iocb->ki_nbytes, relative_ms);
-+
-+	/*
-+	 *  If a timeout was specified, ep_poll returned retry, and we have
-+	 *  not yet registered a timer, go ahead and register one.
-+	 */
-+	if (ret == -EIOCBRETRY && !iocb->private) {
-+		iocb->private = timer;
-+		add_timer(timer);
-+	}
-+
-+	/*
-+	 *  Did we get any events?
-+	 */
-+	if (ret >= 0) {
-+		iocb->ki_cancel = NULL;
-+		(void)del_timer(timer);
-+		kfree(timer);
-+		iocb->private = NULL;
-+	}
-+
-+	return ret;
-+}
- 
- /*
-  * Implement the event wait interface for the eventpoll file. It is the kernel
-@@ -1564,6 +1709,12 @@ retry:
- 
- 	res = 0;
- 	if (list_empty(&ep->rdllist)) {
-+		if (in_aio() && jtimeout) {
-+			__add_wait_queue(&ep->wq, current->io_wait);
-+			res = -EIOCBRETRY;
-+			write_unlock_irqrestore(&ep->lock, flags);
-+			goto out;
-+		}
- 		/*
- 		 * We don't have any available event to return to the caller.
- 		 * We need to sleep here, and we will be wake up by
-@@ -1608,7 +1759,7 @@ retry:
- 	if (!res && eavail &&
- 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
- 		goto retry;
--
-+out:
- 	return res;
- }
- 
-diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
-index e3ca0a4..292c811 100644
---- a/include/linux/aio_abi.h
-+++ b/include/linux/aio_abi.h
-@@ -43,6 +43,7 @@ enum {
- 	IOCB_CMD_NOOP = 6,
- 	IOCB_CMD_PREADV = 7,
- 	IOCB_CMD_PWRITEV = 8,
-+  	IOCB_CMD_EPOLL_WAIT = 9,
- };
- 
- /* read() from /dev/aio returns these structures. */
-diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
-index 84cfa8b..ed04500 100644
---- a/include/linux/eventpoll.h
-+++ b/include/linux/eventpoll.h
-@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
- /* Used to release the epoll bits inside the "struct file" */
- void eventpoll_release_file(struct file *file);
- 
-+/* Used to provide epoll_wait() to sys_io_submit() */
-+ssize_t eventpoll_aio_wait(struct kiocb *iocb);
-+
- /*
-  * This is called from inside fs/file_table.c:__fput() to unlink files
-  * from the eventpoll interface. We need to have this facility to cleanup



From tomo at mail.berlios.de  Sun Dec 24 10:34:03 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 10:34:03 +0100
Subject: [Stgt-svn] r703 - trunk/usr
Message-ID: <200612240934.kBO9Y3Cc031376@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 10:34:02 +0100 (Sun, 24 Dec 2006)
New Revision: 703

Modified:
   trunk/usr/bd_sg.c
Log:
Use gettimeofday instead of tempnam since gcc complains.


Modified: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2006-12-24 08:59:53 UTC (rev 702)
+++ trunk/usr/bd_sg.c	2006-12-24 09:34:02 UTC (rev 703)
@@ -31,6 +31,7 @@
 #include <limits.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
+#include <sys/time.h>
 
 #include "list.h"
 #include "util.h"
@@ -66,8 +67,9 @@
 		      char *path, int *fd, uint64_t *size)
 {
 	int err, maj, min;
-	char *sd, *bsgdev, buf[128];
+	char *sd, buf[256];
 	struct stat64 st;
+	struct timeval t;
 
 	/* we assume something like /dev/sda */
 
@@ -117,27 +119,28 @@
 	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
 	close(*fd);
 
-	bsgdev = tempnam("/tmp", NULL);
-	if (!bsgdev) {
+	err = gettimeofday(&t, NULL);
+	if (err) {
 		eprintf("can't get temporary name for bsg device, %m\n");
 		return -errno;
 	}
 
-	err = mknod(bsgdev, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
+	memset(buf, 0, sizeof(buf));
+	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
+	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
 		    maj << 8 | min);
 	if (err < 0) {
-		eprintf("can't create the bsg device %s, %m\n", bsgdev);
+		eprintf("can't create the bsg device %s, %m\n", buf);
 		return -errno;
 	}
 
-	*fd = open(bsgdev, O_RDWR | O_NONBLOCK);
+	*fd = open(buf, O_RDWR | O_NONBLOCK);
 
-	dprintf("%d %s\n", *fd, bsgdev);
-	unlink(bsgdev);
-	free(bsgdev);
+	dprintf("%d %s\n", *fd, buf);
+	unlink(buf);
 
 	if (*fd < 0) {
-		eprintf("can't open the bsg device %s, %m\n", bsgdev);
+		eprintf("can't open the bsg device %s, %m\n", buf);
 		return -errno;
 	}
 



From tomo at mail.berlios.de  Sun Dec 24 11:54:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 11:54:43 +0100
Subject: [Stgt-svn] r704 - trunk/usr
Message-ID: <200612241054.kBOAsh6x006015@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 11:54:41 +0100 (Sun, 24 Dec 2006)
New Revision: 704

Removed:
   trunk/usr/tgtadm-iscsi.c
Log:
Remove tgtadm-iscsi

Deleted: trunk/usr/tgtadm-iscsi.c
===================================================================
--- trunk/usr/tgtadm-iscsi.c	2006-12-24 09:34:02 UTC (rev 703)
+++ trunk/usr/tgtadm-iscsi.c	2006-12-24 10:54:41 UTC (rev 704)
@@ -1,494 +0,0 @@
-/*
- * iSCSI target management interface
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <ctype.h>
-#include <dirent.h>
-#include <dlfcn.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "util.h"
-#include "list.h"
-#include "tgtd.h"
-#include "tgtadm.h"
-#include "driver.h"
-
-/*
- * This program is just a wrapper of tgtadm. Maybe it would be better
- * to implement this program by using Python or Perl.
- */
-
-/* static char cmdstr[] = "tgtadm --lld iscsi"; */
-static char cmdstr[256];
-static char cmdline[2048];
-
-static struct option const long_options[] =
-{
-	{"op", required_argument, NULL, 'o'},
-	{"tid", required_argument, NULL, 't'},
-	{"sid", required_argument, NULL, 's'},
-	{"cid", required_argument, NULL, 'c'},
-	{"lun", required_argument, NULL, 'u'},
-	{"aid", required_argument, NULL, 'a'},
-	{"iqn", required_argument, NULL, 'i'},
-	{"path", required_argument, NULL, 'p'},
-	{"name", required_argument, NULL, 'n'},
-	{"value", required_argument, NULL, 'v'},
-	{"start", no_argument, NULL, 'S'},
-	{"stop", no_argument, NULL, 'P'},
-	{"user", required_argument, NULL, 'r'},
-	{"password", required_argument, NULL, 'w'},
-	{"in", no_argument, NULL, 'I'},
-	{"out", no_argument, NULL, 'O'},
-	{"debug", no_argument, NULL, 'd'},
-	{"help", no_argument, NULL, 'h'},
-	{NULL, 0, NULL, 0},
-};
-
-static char *short_options = "o:t:s:c:u:a:n:i:p:v:SPr:w:IOdh";
-
-static void usage(int status)
-{
-}
-
-static int target_op(int op, int tid, char *iqn, char *name, char *value,
-		     int start, int stop)
-{
-	int err = -EINVAL;
-	FILE *fp;
-
-	if (start && stop) {
-		fprintf(stderr,
-			"Cannot start and stop a target at the same time\n");
-		exit(1);
-	}
-
-	if (start || stop)
-		op = OP_UPDATE;
-
-	switch (op) {
-	case OP_NEW:
-		if (!iqn) {
-			fprintf(stderr, "specifiy target's iqn\n");
-			exit(1);
-		}
-
-		snprintf(cmdline, sizeof(cmdline), "%s -o new -m tgt -t %d",
-			 cmdstr, tid);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to create a new target\n");
-			exit(1);
-		}
-
-		snprintf(cmdline, sizeof(cmdline), "%s -o update -m tgt -t %d"
-			 " -n iqn -v %s", cmdstr, tid, iqn);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-			/* remove the target. */
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to create a new target\n");
-			exit(1);
-			/* remove the target. */
-		}
-		break;
-	case OP_SHOW:
-		if (tid == -1)
-			snprintf(cmdline, sizeof(cmdline), "%s -o show -m tgt",
-				 cmdstr);
-		else
-			snprintf(cmdline, sizeof(cmdline),
-				 "%s -o show -m tgt -t %d", cmdstr, tid);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		while (fgets(cmdline, sizeof(cmdline), fp))
-			fputs(cmdline, stdout);
-
-		err = pclose(fp);
-
-		break;
-	case OP_UPDATE:
-		if (start || stop)
-			snprintf(cmdline, sizeof(cmdline),
-				 "%s -o update -m tgt -t %d -n state -v %s",
-				 cmdstr, tid, start ? "running" : "suspended");
-		else
-			snprintf(cmdline, sizeof(cmdline),
-				 "%s -o update -m tgt -t %d -n %s -v %s",
-				 cmdstr, tid, name, value);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to change the state\n");
-			exit(1);
-		}
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
-static int session_op(int op, int tid, uint64_t sid, char *name, char *value)
-{
-	int err = -EINVAL;
-	FILE *fp;
-
-	switch (op) {
-	case OP_SHOW:
-		if (sid)
-			snprintf(cmdline, sizeof(cmdline),
-				 "%s -o show -m sess -t %d -s %" PRIu64,
-				 cmdstr, tid, sid);
-		else
-			snprintf(cmdline, sizeof(cmdline),
-				 "%s -o show -m sess -t %d", cmdstr, tid);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		while (fgets(cmdline, sizeof(cmdline), fp))
-			fputs(cmdline, stdout);
-
-		err = pclose(fp);
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
-static int logicalunit_op(int op, int tid, uint64_t lun, char *path,
-			  char *name, char *value)
-{
-	int err = -EINVAL;
-	FILE *fp;
-
-	switch (op) {
-	case OP_NEW:
-		if (!path) {
-			fprintf(stderr, "specifiy logical unit's path\n");
-			exit(1);
-		}
-
-		snprintf(cmdline, sizeof(cmdline), "%s -o new -m lu -t %d -u %" PRIu64,
-			 cmdstr, tid, lun);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to create a logical unit\n");
-			exit(1);
-			/* remove the lu. */
-		}
-
-		snprintf(cmdline, sizeof(cmdline), "%s -o update -m lu -t %d -u %" PRIu64
-			 " -n path -v %s", cmdstr, tid, lun, path);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-
-			/* remove the lu */
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to create a logical unit\n");
-			exit(1);
-			/* remove the lu. */
-		}
-		break;
-	case OP_SHOW:
-		snprintf(cmdline, sizeof(cmdline),
-			 "%s -o show -m lu -t %d -u %" PRIu64,
-			 cmdstr, tid, lun);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		while (fgets(cmdline, sizeof(cmdline), fp))
-			fputs(cmdline, stdout);
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to show a logical unit\n");
-			exit(1);
-			/* remove the lu. */
-		}
-	}
-
-	return err;
-}
-
-static int account_op(int op, int tid, int in, int out, int aid,
-		      char *user, char *password, char *name, char *value)
-{
-	int err = -EINVAL;
-	FILE *fp;
-
-	switch (op) {
-	case OP_NEW:
-		/* TODO: error handling */
-
-		if ((!in && !out) || (in && out)) {
-			fprintf(stderr, "specify incoming or outgoing\n");
-			exit(1);
-		}
-
-		snprintf(cmdline, sizeof(cmdline), "%s -o new -m account -a %u",
-			 cmdstr, aid);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		err = pclose(fp);
-		if (err) {
-			fprintf(stderr, "fail to create a logical unit\n");
-			exit(1);
-		}
-
-		snprintf(cmdline, sizeof(cmdline),
-			 "%s -o update -m account -a %u -n User -v %s",
-			 cmdstr, aid, user);
-
-		fp = popen(cmdline, "r");
-		if (!fp)
-			exit(1);
-
-		err = pclose(fp);
-		if (err)
-			exit(1);
-
-		snprintf(cmdline, sizeof(cmdline),
-			 "%s -o update -m account -a %u -n Password -v %s",
-			 cmdstr, aid, password);
-		fp = popen(cmdline, "r");
-		if (!fp)
-			exit(1);
-
-		err = pclose(fp);
-		if (err)
-			exit(1);
-
-		snprintf(cmdline, sizeof(cmdline),
-			 "%s -o update -m account -a %u -n Type -v %s",
-			 cmdstr, aid, in ? "Incoming" : "Outgoing");
-		fp = popen(cmdline, "r");
-		if (!fp)
-			exit(1);
-
-		err = pclose(fp);
-		if (err)
-			exit(1);
-
-		snprintf(cmdline, sizeof(cmdline),
-			 "%s -o bind -m account -t %d -a %u",
-			 cmdstr, tid, aid);
-		fp = popen(cmdline, "r");
-		if (!fp)
-			exit(1);
-
-		err = pclose(fp);
-		if (err)
-			exit(1);
-		break;
-	case OP_SHOW:
-		snprintf(cmdline, sizeof(cmdline), "%s -o show -m account -t %d",
-			 cmdstr, tid);
-		fp = popen(cmdline, "r");
-		if (!fp) {
-			fprintf(stderr, "fail to exec %s\n", cmdstr);
-			exit(1);
-		}
-
-		while (fgets(cmdline, sizeof(cmdline), fp))
-			fputs(cmdline, stdout);
-
-		err = pclose(fp);
-		if (err)
-			exit(1);
-	}
-
-	return err;
-}
-
-static int str_to_op(char *str)
-{
-	int op;
-
-	if (!strcmp("new", str))
-		op = OP_NEW;
-	else if (!strcmp("delete", str))
-		op = OP_DELETE;
-	else if (!strcmp("bind", str))
-		op = OP_BIND;
-	else if (!strcmp("show", str))
-		op = OP_SHOW;
-	else if (!strcmp("update", str))
-		op = OP_UPDATE;
-	else
-		op = -1;
-
-	return op;
-}
-
-int main(int argc, char **argv)
-{
-	int ch, longindex;
-	char *name, *value, *iqn, *path, *user, *password;
-	int err = -EINVAL, op = -1, tid = -1, mode = 0;
-	uint32_t cid, aid = 0;
-	uint64_t sid = 0, lun = -1;
-	int start, stop, in, out;
-
-	start = stop = in = out = 0;
-	name = value = iqn = path = user = password = NULL;
-
-	/* workaround */
-	{
-		char *p;
-
-		if (*argv[0] == '.') {
-			getcwd(cmdstr, sizeof(cmdstr));
-			sprintf(cmdstr + strlen(cmdstr), "/%s", argv[0] + 1);
-		} else
-			strcpy(cmdstr, argv[0]);
-
-		p = strstr(cmdstr, "tgtadm-iscsi");
-		sprintf(p, "tgtadm --lld iscsi");
-	}
-
-	while ((ch = getopt_long(argc, argv, short_options,
-				 long_options, &longindex)) >= 0) {
-		switch (ch) {
-		case 'o':
-			op = str_to_op(optarg);
-			break;
-		case 't':
-			tid = strtol(optarg, NULL, 10);
-			mode |= (1 << MODE_TARGET);
-			break;
-		case 's':
-			sid = strtoull(optarg, NULL, 10);
-			mode |= (1 << MODE_SESSION);
-			break;
-		case 'c':
-			cid = strtoul(optarg, NULL, 10);
-			mode |= (1 << MODE_CONNECTION);
-			break;
-		case 'u':
-			lun = strtoull(optarg, NULL, 10);
-			mode |= (1 << MODE_DEVICE);
-			break;
-		case 'a':
-			aid = strtol(optarg, NULL, 10);
-			mode |= (1 << MODE_ACCOUNT);
-			break;
-		case 'i':
-			iqn = optarg;
-			break;
-		case 'p':
-			path = optarg;
-			break;
-		case 'n':
-			name = optarg;
-			break;
-		case 'v':
-			value = optarg;
-			break;
-		case 'S':
-			start = 1;
-			break;
-		case 'P':
-			stop = 1;
-			break;
-		case 'r':
-			user = optarg;
-			break;
-		case 'w':
-			password = optarg;
-			break;
-		case 'I':
-			in = 1;
-			break;
-		case 'O':
-			out = 1;
-			break;
-		case 'h':
-			usage(0);
-			break;
-		default:
-			usage(-1);
-		}
-	}
-
-	if (mode & (1 << MODE_ACCOUNT))
-		account_op(op, tid, in, out, aid, user, password, name, value);
-	else if (mode & (1 << MODE_DEVICE))
-		err = logicalunit_op(op, tid, lun, path, name, value);
-	else if (mode & (1 << MODE_CONNECTION))
-		;
-	else if (mode & (1 << MODE_SESSION))
-		err = session_op(op, tid, sid, name, value);
-	else
-		err = target_op(op, tid, iqn, name, value, start, stop);
-
-	return err;
-}



From tomo at mail.berlios.de  Sun Dec 24 14:32:29 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 14:32:29 +0100
Subject: [Stgt-svn] r705 - in trunk/usr: . iscsi
Message-ID: <200612241332.kBODWTTk000226@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 14:32:28 +0100 (Sun, 24 Dec 2006)
New Revision: 705

Modified:
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/util.c
   trunk/usr/util.h
Log:
Move set_non_blocking to util.c


Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2006-12-24 10:54:41 UTC (rev 704)
+++ trunk/usr/iscsi/iscsi_tcp.c	2006-12-24 13:32:28 UTC (rev 705)
@@ -40,20 +40,6 @@
 #define LISTEN_MAX		4
 #define INCOMING_MAX		32
 
-static void set_non_blocking(int fd)
-{
-	int err;
-
-	err = fcntl(fd, F_GETFL);
-	if (err < 0) {
-		eprintf("unable to get fd flags, %m\n");
-	} else {
-		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
-		if (err == -1)
-			eprintf("unable to set fd flags, %m\n");
-	}
-}
-
 static void accept_connection(int afd, int events, void *data)
 {
 	struct sockaddr_storage from;

Modified: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2006-12-24 10:54:41 UTC (rev 704)
+++ trunk/usr/util.c	2006-12-24 13:32:28 UTC (rev 705)
@@ -97,3 +97,19 @@
 	return err;
 }
 
+int set_non_blocking(int fd)
+{
+	int err;
+
+	err = fcntl(fd, F_GETFL);
+	if (err < 0) {
+		eprintf("unable to get fd flags, %m\n");
+	} else {
+		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
+		if (err == -1)
+			eprintf("unable to set fd flags, %m\n");
+		else
+			err = 0;
+	}
+	return err;
+}

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-12-24 10:54:41 UTC (rev 704)
+++ trunk/usr/util.h	2006-12-24 13:32:28 UTC (rev 705)
@@ -36,6 +36,7 @@
 
 extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
 extern int backed_file_open(char *path, int oflag, uint64_t *size);
+extern int set_non_blocking(int fd);
 
 #define zalloc(size)			\
 ({					\



From tomo at mail.berlios.de  Sun Dec 24 17:59:00 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 24 Dec 2006 17:59:00 +0100
Subject: [Stgt-svn] r706 - trunk/usr
Message-ID: <200612241659.kBOGx0Iu019023@sheep.berlios.de>

Author: tomo
Date: 2006-12-24 17:58:58 +0100 (Sun, 24 Dec 2006)
New Revision: 706

Modified:
   trunk/usr/mgmt.c
Log:
Convert mgmt handling asynchronous


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-24 13:32:28 UTC (rev 705)
+++ trunk/usr/mgmt.c	2006-12-24 16:58:58 UTC (rev 706)
@@ -39,9 +39,26 @@
 #include "log.h"
 #include "tgtadm.h"
 #include "driver.h"
+#include "util.h"
 
 #define BUFSIZE 4096
 
+enum mgmt_task_state {
+	MTASK_STATE_HDR_RECV,
+	MTASK_STATE_PDU_RECV,
+	MTASK_STATE_RSP_SEND,
+};
+
+struct mgmt_task {
+	enum mgmt_task_state mtask_state;
+	int retry;
+	int done;
+	char *buf;
+/* 	struct tgt_work work; */
+	struct tgtadm_req *req;
+	struct tgtadm_res *rsp;
+};
+
 static void set_show_results(struct tgtadm_res *res, int *err)
 {
 	if (err < 0)
@@ -145,12 +162,19 @@
 	return err;
 }
 
-int tgt_mgmt(int lld_no, struct tgtadm_req *req, struct tgtadm_res *res,
-	     int len)
+static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_res *res, int len)
 {
-	int err = -EINVAL;
+	int lld_no, err = -EINVAL;
 	char *params = (char *) req->data;
 
+	lld_no = get_driver_index(req->lld);
+	if (lld_no < 0) {
+		eprintf("can't find the driver\n");
+		res->err = ENOENT;
+		res->len = sizeof(*res);
+		return 0;
+	}
+
 	dprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
 		req->len, lld_no, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
@@ -226,36 +250,83 @@
 	return 0;
 }
 
-static void ipc_send_res(int fd, struct tgtadm_res *res)
+static void mtask_handler(int fd, int events, void *data)
 {
-	struct iovec iov;
-	struct msghdr msg;
-	int err;
+	int err, len;
+	char *pdu;
+	struct mgmt_task *mtask = data;
+	struct tgtadm_req *req = (struct tgtadm_req *) mtask->buf;
+	struct tgtadm_res *rsp = (struct tgtadm_res *) mtask->buf;
 
-	iov.iov_base = res;
-	iov.iov_len = res->len;
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
+	switch (mtask->mtask_state) {
+	case MTASK_STATE_HDR_RECV:
+		len = sizeof(*req) - mtask->done;
+		err = read(fd, mtask->buf + mtask->done, len);
+		if (err > 0) {
+			mtask->done += err;
+			if (mtask->done == sizeof(*req)) {
+				if (req->len == sizeof(*req)) {
+					tgt_mgmt(req, rsp, BUFSIZE);
+					mtask->mtask_state =
+						MTASK_STATE_RSP_SEND;
+					tgt_event_modify(fd, EPOLLOUT);
+					mtask->done = 0;
+				} else {
+					mtask->mtask_state =
+						MTASK_STATE_PDU_RECV;
+					mtask->done = 0;
+				}
+			}
+		} else
+			if (errno != EAGAIN)
+				goto out;
 
-	err = sendmsg(fd, &msg, MSG_DONTWAIT);
-	if (err != res->len)
-		eprintf("can't write, %m\n");
+		break;
+	case MTASK_STATE_PDU_RECV:
+		len = req->len - (sizeof(*req) + mtask->done);
+		pdu = mtask->buf + sizeof(*req);
+		err = read(fd, pdu + mtask->done, len);
+		if (err > 0) {
+			mtask->done += err;
+			if (mtask->done == req->len - (sizeof(*req))) {
+				tgt_mgmt(req, rsp, BUFSIZE);
+				mtask->mtask_state = MTASK_STATE_RSP_SEND;
+				tgt_event_modify(fd, EPOLLOUT);
+				mtask->done = 0;
+			}
+		} else
+			if (errno != EAGAIN)
+				goto out;
+
+		break;
+	case MTASK_STATE_RSP_SEND:
+		len = rsp->len - mtask->done;
+		err = write(fd, mtask->buf + mtask->done, len);
+		if (err > 0) {
+			mtask->done += err;
+
+			if (mtask->done == rsp->len)
+				goto out;
+		} else
+			if (errno != EAGAIN)
+				goto out;
+		break;
+	default:
+		eprintf("unknown state %d\n", mtask->mtask_state);
+	}
+
+	return;
+out:
+	tgt_event_del(fd);
+	free(mtask);
+	close(fd);
 }
 
 static void mgmt_event_handler(int accept_fd, int events, void *data)
 {
 	int fd, err;
-	char sbuf[BUFSIZE], rbuf[BUFSIZE];
-	struct iovec iov;
-	struct msghdr msg;
-	struct tgtadm_req *req;
-	struct tgtadm_res *res;
-	int lld_no, len;
+	struct mgmt_task *mtask;
 
-	req = (struct tgtadm_req *) sbuf;
-	memset(sbuf, 0, sizeof(sbuf));
-
 	fd = ipc_accept(accept_fd);
 	if (fd < 0)
 		return;
@@ -264,63 +335,25 @@
 	if (err < 0)
 		goto out;
 
-	len = (char *) req->data - (char *) req;
-	iov.iov_base = req;
-	iov.iov_len = len;
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-retry:
-	err = recvmsg(fd, &msg, MSG_PEEK | MSG_DONTWAIT);
-	if (err != len) {
-		/*
-		 * workaround. We need to put this request to
-		 * scheduler and wait for timeout or data.
-		 */
-		if (errno == EAGAIN)
-			goto retry;
-
-		eprintf("can't read, %m\n");
+	err = set_non_blocking(fd);
+	if (err)
 		goto out;
-	}
 
-	if (req->len > sizeof(sbuf) - len) {
-		eprintf("too long data %d\n", req->len);
+	mtask = zalloc(sizeof(*mtask) + sizeof(struct tgtadm_req) + BUFSIZE);
+	if (!mtask) {
+		eprintf("can't allocate mtask\n");
 		goto out;
 	}
 
-	iov.iov_base = req;
-	iov.iov_len = req->len;
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err != req->len) {
-		eprintf("can't read, %m\n");
-		err = -EIO;
+	mtask->mtask_state = MTASK_STATE_HDR_RECV;
+	mtask->buf = (char *) mtask + sizeof(*mtask);
+	err = tgt_event_add(fd, EPOLLIN, mtask_handler, mtask);
+	if (err) {
+		free(mtask);
 		goto out;
 	}
 
-	dprintf("%d %s %d %d %d\n", req->mode, req->lld, err, req->len, fd);
-	res = (struct tgtadm_res *) rbuf;
-	memset(rbuf, 0, sizeof(rbuf));
-
-	lld_no = get_driver_index(req->lld);
-	if (lld_no < 0) {
-		eprintf("can't find the driver\n");
-		res->err = ENOENT;
-		res->len = (char *) res->data - (char *) res;
-		goto send;
-	}
-
-	err = tgt_mgmt(lld_no, req, res, sizeof(rbuf));
-	if (err)
-		eprintf("%d %d %d %d\n", req->mode, lld_no, err, res->len);
-
-send:
-	ipc_send_res(fd, res);
+	return;
 out:
 	if (fd > 0)
 		close(fd);



From tomo at mail.berlios.de  Mon Dec 25 04:56:14 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 04:56:14 +0100
Subject: [Stgt-svn] r707 - trunk/usr
Message-ID: <200612250356.kBP3uE8p007017@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 04:56:14 +0100 (Mon, 25 Dec 2006)
New Revision: 707

Modified:
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Rename tgtadm_res tgtadm_rsp


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-24 16:58:58 UTC (rev 706)
+++ trunk/usr/mgmt.c	2006-12-25 03:56:14 UTC (rev 707)
@@ -56,10 +56,10 @@
 	char *buf;
 /* 	struct tgt_work work; */
 	struct tgtadm_req *req;
-	struct tgtadm_res *rsp;
+	struct tgtadm_rsp *rsp;
 };
 
-static void set_show_results(struct tgtadm_res *res, int *err)
+static void set_show_results(struct tgtadm_rsp *res, int *err)
 {
 	if (err < 0)
 		res->err = *err;
@@ -71,7 +71,7 @@
 }
 
 static int target_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       struct tgtadm_res *res, int *rlen)
+		       struct tgtadm_rsp *res, int *rlen)
 {
 	int err = -EINVAL;
 
@@ -130,7 +130,7 @@
 }
 
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       struct tgtadm_res *res, int *rlen)
+		       struct tgtadm_rsp *res, int *rlen)
 {
 	int err = -EINVAL;
 
@@ -162,7 +162,7 @@
 	return err;
 }
 
-static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_res *res, int len)
+static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_rsp *res, int len)
 {
 	int lld_no, err = -EINVAL;
 	char *params = (char *) req->data;
@@ -256,7 +256,7 @@
 	char *pdu;
 	struct mgmt_task *mtask = data;
 	struct tgtadm_req *req = (struct tgtadm_req *) mtask->buf;
-	struct tgtadm_res *rsp = (struct tgtadm_res *) mtask->buf;
+	struct tgtadm_rsp *rsp = (struct tgtadm_rsp *) mtask->buf;
 
 	switch (mtask->mtask_state) {
 	case MTASK_STATE_HDR_RECV:

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-24 16:58:58 UTC (rev 706)
+++ trunk/usr/tgtadm.c	2006-12-25 03:56:14 UTC (rev 707)
@@ -162,7 +162,7 @@
 
 static int ipc_mgmt_res(int fd)
 {
-	struct tgtadm_res *res;
+	struct tgtadm_rsp *res;
 	char buf[BUFSIZE];
 	int err, len;
 
@@ -172,7 +172,7 @@
 		return -1;
 	}
 
-	res = (struct tgtadm_res *) buf;
+	res = (struct tgtadm_rsp *) buf;
 	if (res->err) {
 		eprintf("Error %d\n", res->err);
 		return -1;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-24 16:58:58 UTC (rev 706)
+++ trunk/usr/tgtadm.h	2006-12-25 03:56:14 UTC (rev 707)
@@ -51,7 +51,7 @@
 	uint64_t data[0];
 };
 
-struct tgtadm_res {
+struct tgtadm_rsp {
 	uint32_t err;
 	uint32_t len;
 	uint64_t data[0];



From tomo at mail.berlios.de  Mon Dec 25 05:18:37 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 05:18:37 +0100
Subject: [Stgt-svn] r708 - trunk/usr
Message-ID: <200612250418.kBP4Ib7i008947@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 05:18:37 +0100 (Mon, 25 Dec 2006)
New Revision: 708

Modified:
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Clean up tgtadm_req and tgtadm_rsp


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 03:56:14 UTC (rev 707)
+++ trunk/usr/mgmt.c	2006-12-25 04:18:37 UTC (rev 708)
@@ -59,21 +59,22 @@
 	struct tgtadm_rsp *rsp;
 };
 
-static void set_show_results(struct tgtadm_rsp *res, int *err)
+static void set_show_results(struct tgtadm_rsp *rsp, int *err)
 {
 	if (err < 0)
-		res->err = *err;
+		rsp->err = *err;
 	else {
-		res->err = 0;
-		res->len = *err + sizeof(*res);
+		rsp->err = 0;
+		rsp->len = *err + sizeof(*rsp);
 		*err = 0;
 	}
 }
 
 static int target_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       struct tgtadm_rsp *res, int *rlen)
+		       struct tgtadm_rsp *rsp, int *rlen)
 {
 	int err = -EINVAL;
+	char *pdu = (char *)rsp + sizeof(*rsp);
 
 	switch (req->op) {
 	case OP_NEW:
@@ -107,32 +108,32 @@
 	}
 	case OP_SHOW:
 		if (req->tid < 0)
-			err = tgt_target_show_all((char *)res->data,
-						  *rlen - sizeof(*res));
+			err = tgt_target_show_all(pdu, *rlen - sizeof(*rsp));
 		else if (tgt_drivers[lld_no]->show)
 			err = tgt_drivers[lld_no]->show(req->mode,
 							req->tid, req->sid,
 							req->cid, req->lun,
-							(char *)res->data,
-							*rlen - sizeof(*res));
+							pdu,
+							*rlen - sizeof(*rsp));
 		break;
 	default:
 		break;
 	}
 
 	if (req->op == OP_SHOW)
-		set_show_results(res, &err);
+		set_show_results(rsp, &err);
 	else {
-		res->err = err;
-		res->len = (char *) res->data - (char *) res;
+		rsp->err = err;
+		rsp->len = sizeof(*rsp);
 	}
 	return err;
 }
 
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       struct tgtadm_rsp *res, int *rlen)
+		       struct tgtadm_rsp *rsp, int *rlen)
 {
 	int err = -EINVAL;
+	char *pdu = (char *)rsp + sizeof(*rsp);
 
 	switch (req->op) {
 	case OP_NEW:
@@ -145,33 +146,34 @@
 		err = tgt_device_update(req->tid, req->lun, params);
 		break;
 	case OP_SHOW:
-		err = tgt_device_show(req->tid, req->lun, (char *) res->data,
-				      *rlen - sizeof(*res));
+		err = tgt_device_show(req->tid, req->lun, pdu,
+				      *rlen - sizeof(*rsp));
 		break;
 	default:
 		break;
 	}
 
 	if (req->op == OP_SHOW)
-		set_show_results(res, &err);
+		set_show_results(rsp, &err);
 	else {
-		res->err = err;
-		res->len = sizeof(*res);
+		rsp->err = err;
+		rsp->len = sizeof(*rsp);
 	}
 
 	return err;
 }
 
-static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_rsp *res, int len)
+static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_rsp *rsp, int len)
 {
 	int lld_no, err = -EINVAL;
-	char *params = (char *) req->data;
+	char *params = (char *) req + sizeof(*req);
+	char *pdu = (char *) rsp + sizeof(*rsp);
 
 	lld_no = get_driver_index(req->lld);
 	if (lld_no < 0) {
 		eprintf("can't find the driver\n");
-		res->err = ENOENT;
-		res->len = sizeof(*res);
+		rsp->err = ENOENT;
+		rsp->len = sizeof(*rsp);
 		return 0;
 	}
 
@@ -183,23 +185,22 @@
 	case MODE_SYSTEM:
 		break;
 	case MODE_TARGET:
-		err = target_mgmt(lld_no, req, params, res, &len);
+		err = target_mgmt(lld_no, req, params, rsp, &len);
 		break;
 	case MODE_DEVICE:
-		err = device_mgmt(lld_no, req, params, res, &len);
+		err = device_mgmt(lld_no, req, params, rsp, &len);
 		break;
 	case MODE_ACCOUNT:
 		if (tgt_drivers[lld_no]->account)
 			err = tgt_drivers[lld_no]->account(req->op, req->tid, req->aid,
-							   params,
-							   (char *)res->data,
-							   len - sizeof(*res));
+							   params, pdu,
+							   len - sizeof(*rsp));
 		if (req->op == OP_SHOW) {
-			set_show_results(res, &err);
+			set_show_results(rsp, &err);
 			err = 0;
 		} else {
-			res->err = err;
-			res->len = sizeof(*res);
+			rsp->err = err;
+			rsp->len = sizeof(*rsp);
 		}
 		break;
 	default:
@@ -207,10 +208,10 @@
 			err = tgt_drivers[lld_no]->show(req->mode,
 							req->tid, req->sid,
 							req->cid, req->lun,
-							(char *)res->data,
-							len - sizeof(*res));
+							pdu,
+							len - sizeof(*rsp));
 
-			set_show_results(res, &err);
+			set_show_results(rsp, &err);
 		}
 		break;
 	}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 03:56:14 UTC (rev 707)
+++ trunk/usr/tgtadm.c	2006-12-25 04:18:37 UTC (rev 708)
@@ -162,25 +162,25 @@
 
 static int ipc_mgmt_res(int fd)
 {
-	struct tgtadm_rsp *res;
+	struct tgtadm_rsp *rsp;
 	char buf[BUFSIZE];
 	int err, len;
 
-	err = read(fd, buf, sizeof(*res));
+	err = read(fd, buf, sizeof(*rsp));
 	if (err < 0) {
 		eprintf("Cannot read from tgtd, %m\n");
 		return -1;
 	}
 
-	res = (struct tgtadm_rsp *) buf;
-	if (res->err) {
-		eprintf("Error %d\n", res->err);
+	rsp = (struct tgtadm_rsp *) buf;
+	if (rsp->err) {
+		eprintf("Error %d\n", rsp->err);
 		return -1;
 	}
 
-	dprintf("got the response %d %d\n", res->err, res->len);
+	dprintf("got the response %d %d\n", rsp->err, rsp->len);
 
-	len = res->len - sizeof(*res);
+	len = rsp->len - sizeof(*rsp);
 	if (!len)
 		return 0;
 
@@ -334,7 +334,7 @@
 	char *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE + sizeof(*req)];
-	char *name, *value, *path, *targetname;
+	char *name, *value, *path, *targetname, *params;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
@@ -433,6 +433,10 @@
 	req->aid = aid;
 	req->host_no = hostno;
 
+	params = buf + sizeof(*req);
+
+	printf("size %d\n", sizeof(*req));
+
 	/* FIXME */
 	if ((name && value) || path || targetname) {
 		if (path) {
@@ -445,15 +449,15 @@
 			value = targetname;
 		}
 
-		len = snprintf((char *)req->data, rest, "%s=%s", name, value);
+		len = snprintf(params, rest, "%s=%s", name, value);
 	}
 
 	if (t_type != TARGET_SBC)
-		len += snprintf((char *)req->data + len, rest - len,
+		len += snprintf(params + len, rest - len,
 				"%starget-type=%d", len ? "," : "", t_type);
 
 	if (bs_type != LU_BS_FILE)
-		len += snprintf((char *)req->data + len, rest - len,
+		len += snprintf(params + len, rest - len,
 				"%sbacking-store-type=%d", len ? "," : "", bs_type);
 
 	req->len = sizeof(*req) + len;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-25 03:56:14 UTC (rev 707)
+++ trunk/usr/tgtadm.h	2006-12-25 04:18:37 UTC (rev 708)
@@ -44,17 +44,16 @@
 	int32_t tid;
 	uint64_t sid;
 	uint32_t cid;
-	uint64_t lun;
 	uint32_t aid;
+	uint64_t lun;
 	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;
-	uint64_t data[0];
+	uint32_t pack;
 };
 
 struct tgtadm_rsp {
 	uint32_t err;
 	uint32_t len;
-	uint64_t data[0];
 };
 
 #endif



From tomo at mail.berlios.de  Mon Dec 25 05:41:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 05:41:57 +0100
Subject: [Stgt-svn] r709 - trunk/usr
Message-ID: <200612250441.kBP4fv24010964@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 05:41:57 +0100 (Mon, 25 Dec 2006)
New Revision: 709

Modified:
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Just add error messages.

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 04:18:37 UTC (rev 708)
+++ trunk/usr/tgtadm.c	2006-12-25 04:41:57 UTC (rev 709)
@@ -60,6 +60,22 @@
 static char program_name[] = "tgtadm";
 static int debug;
 
+static char *tgtadm_error_msg[] = {
+	"",
+	"unknown error",
+	"out of memory"
+	"can't find the driver"
+	"can't find the target"
+
+	"can't find the logical unit",
+	"can't find the session",
+	"can't find the connection",
+	"the target already exists",
+	"the logical unit already exists",
+
+	"unknown parameter",
+};
+
 static struct option const long_options[] =
 {
 	{"lld", required_argument, NULL, 'l'},

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-25 04:18:37 UTC (rev 708)
+++ trunk/usr/tgtadm.h	2006-12-25 04:41:57 UTC (rev 709)
@@ -4,6 +4,22 @@
 #define TGT_IPC_NAMESPACE	"TGT_IPC_ABSTRACT_NAMESPACE"
 #define TGT_LLD_NAME_LEN	64
 
+enum tgtadm_errno {
+	TGTADM_SUCCESS,
+	TGTADM_UNKNOWN_ERR,
+	TGTADM_OOM,
+	TGTADM_NO_DRIVER,
+	TGTADM_NO_TARGET,
+
+	TGTADM_NO_LUN,
+	TGTADM_NO_SESSION,
+	TGTADM_NO_CONNECTION,
+	TGTADM_TARGET_EXIST,
+	TGTADM_LUN_EXIST,
+
+	TGTADM_UNKNOWN_PARAM,
+};
+
 enum tgtadm_op {
 	OP_NEW,
 	OP_DELETE,



From tomo at mail.berlios.de  Mon Dec 25 06:18:09 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 06:18:09 +0100
Subject: [Stgt-svn] r710 - trunk/usr
Message-ID: <200612250518.kBP5I9Pp013472@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 06:18:08 +0100 (Mon, 25 Dec 2006)
New Revision: 710

Modified:
   trunk/usr/tgtadm.c
Log:
Can print a very long response.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 04:41:57 UTC (rev 709)
+++ trunk/usr/tgtadm.c	2006-12-25 05:18:08 UTC (rev 710)
@@ -60,7 +60,7 @@
 static char program_name[] = "tgtadm";
 static int debug;
 
-static char *tgtadm_error_msg[] = {
+static char *tgtadm_err_msg[] = {
 	"",
 	"unknown error",
 	"out of memory"
@@ -165,7 +165,8 @@
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE, strlen(TGT_IPC_NAMESPACE));
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
 
 	err = connect(*fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
@@ -176,41 +177,37 @@
 	return 0;
 }
 
-static int ipc_mgmt_res(int fd)
+static int ipc_mgmt_rsp(int fd)
 {
-	struct tgtadm_rsp *rsp;
-	char buf[BUFSIZE];
-	int err, len;
+	struct tgtadm_rsp rsp;
+	int err, rest, len;
 
-	err = read(fd, buf, sizeof(*rsp));
+	err = read(fd, &rsp, sizeof(rsp));
 	if (err < 0) {
-		eprintf("Cannot read from tgtd, %m\n");
+		eprintf("Can't get the response, %m\n");
 		return -1;
 	}
 
-	rsp = (struct tgtadm_rsp *) buf;
-	if (rsp->err) {
-		eprintf("Error %d\n", rsp->err);
+	if (rsp.err != TGTADM_SUCCESS) {
+		eprintf("%s\n", tgtadm_err_msg[rsp.err]);
 		return -1;
 	}
 
-	dprintf("got the response %d %d\n", rsp->err, rsp->len);
-
-	len = rsp->len - sizeof(*rsp);
-	if (!len)
+	rest = rsp.len - sizeof(rsp);
+	if (!rest)
 		return 0;
 
-	while (len) {
-		int t;
+	while (rest) {
+		char buf[BUFSIZE];
 		memset(buf, 0, sizeof(buf));
-		t = min_t(int, sizeof(buf), len);
-		err = read(fd, buf, t);
-		if (err < 0) {
-			eprintf("Cannot read from tgtd, %m\n");
+		len = min_t(int, sizeof(buf) - 1, rest);
+		err = read(fd, buf, len);
+		if (err <= 0) {
+			eprintf("Can't get the response, %m\n");
 			return -1;
 		}
-		printf("%s", buf);
-		len -= t;
+		fputs(buf, stdout);
+		rest -= len;
 	}
 
 	return 0;
@@ -232,7 +229,7 @@
 
 	dprintf("sent to tgtd %d\n", err);
 
-	err = ipc_mgmt_res(fd);
+	err = ipc_mgmt_rsp(fd);
 out:
 	if (fd > 0)
 		close(fd);
@@ -451,8 +448,6 @@
 
 	params = buf + sizeof(*req);
 
-	printf("size %d\n", sizeof(*req));
-
 	/* FIXME */
 	if ((name && value) || path || targetname) {
 		if (path) {



From tomo at mail.berlios.de  Mon Dec 25 06:28:12 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 06:28:12 +0100
Subject: [Stgt-svn] r711 - trunk/usr
Message-ID: <200612250528.kBP5SCdF014457@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 06:28:12 +0100 (Mon, 25 Dec 2006)
New Revision: 711

Modified:
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
Log:
Fix error messages.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 05:18:08 UTC (rev 710)
+++ trunk/usr/mgmt.c	2006-12-25 05:28:12 UTC (rev 711)
@@ -172,7 +172,7 @@
 	lld_no = get_driver_index(req->lld);
 	if (lld_no < 0) {
 		eprintf("can't find the driver\n");
-		rsp->err = ENOENT;
+		rsp->err = TGTADM_NO_DRIVER;
 		rsp->len = sizeof(*rsp);
 		return 0;
 	}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 05:18:08 UTC (rev 710)
+++ trunk/usr/tgtadm.c	2006-12-25 05:28:12 UTC (rev 711)
@@ -60,12 +60,12 @@
 static char program_name[] = "tgtadm";
 static int debug;
 
-static char *tgtadm_err_msg[] = {
+static char *tgtadm_emsg[] = {
 	"",
 	"unknown error",
-	"out of memory"
-	"can't find the driver"
-	"can't find the target"
+	"out of memory",
+	"can't find the driver",
+	"can't find the target",
 
 	"can't find the logical unit",
 	"can't find the session",
@@ -189,7 +189,7 @@
 	}
 
 	if (rsp.err != TGTADM_SUCCESS) {
-		eprintf("%s\n", tgtadm_err_msg[rsp.err]);
+		fprintf(stderr, "%s: %s\n", program_name, tgtadm_emsg[rsp.err]);
 		return -1;
 	}
 



From tomo at mail.berlios.de  Mon Dec 25 06:43:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 06:43:17 +0100
Subject: [Stgt-svn] r712 - trunk/usr
Message-ID: <200612250543.kBP5hHVA009714@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 06:43:13 +0100 (Mon, 25 Dec 2006)
New Revision: 712

Modified:
   trunk/usr/tgtadm.c
Log:
Clean up error messages.

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 05:28:12 UTC (rev 711)
+++ trunk/usr/tgtadm.c	2006-12-25 05:43:13 UTC (rev 712)
@@ -159,7 +159,7 @@
 
 	*fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (*fd < 0) {
-		eprintf("Cannot create a socket, %m\n");
+		eprintf("can't create a socket, %m\n");
 		return -1;
 	}
 
@@ -170,7 +170,7 @@
 
 	err = connect(*fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
-		eprintf("Cannot connect to tgtd, %m\n");
+		eprintf("can't connect to tgtd, %m\n");
 		return -1;
 	}
 
@@ -184,7 +184,7 @@
 
 	err = read(fd, &rsp, sizeof(rsp));
 	if (err < 0) {
-		eprintf("Can't get the response, %m\n");
+		eprintf("can't get the response, %m\n");
 		return -1;
 	}
 
@@ -203,7 +203,7 @@
 		len = min_t(int, sizeof(buf) - 1, rest);
 		err = read(fd, buf, len);
 		if (err <= 0) {
-			eprintf("Can't get the response, %m\n");
+			eprintf("can't get the response, %m\n");
 			return -1;
 		}
 		fputs(buf, stdout);
@@ -223,7 +223,7 @@
 
 	err = write(fd, (char *) req, req->len);
 	if (err < 0) {
-		eprintf("Cannot send to tgtd, %m\n");
+		eprintf("can't send to tgtd, %m\n");
 		goto out;
 	}
 
@@ -421,7 +421,7 @@
 	}
 
 	if (optind < argc) {
-		fprintf(stderr, "unrecognized: ");
+		fprintf(stderr, "unrecognized options: ");
 		while (optind < argc)
 			fprintf(stderr, "%s", argv[optind++]);
 		fprintf(stderr, "\n");



From tomo at mail.berlios.de  Mon Dec 25 09:30:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 09:30:02 +0100
Subject: [Stgt-svn] r713 - trunk/usr
Message-ID: <200612250830.kBP8U2eJ008433@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 09:30:02 +0100 (Mon, 25 Dec 2006)
New Revision: 713

Modified:
   trunk/usr/tgtadm.c
Log:
Fix error message.

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-25 05:43:13 UTC (rev 712)
+++ trunk/usr/tgtadm.c	2006-12-25 08:30:02 UTC (rev 713)
@@ -203,7 +203,7 @@
 		len = min_t(int, sizeof(buf) - 1, rest);
 		err = read(fd, buf, len);
 		if (err <= 0) {
-			eprintf("can't get the response, %m\n");
+			eprintf("can't get the full response, %m\n");
 			return -1;
 		}
 		fputs(buf, stdout);



From tomo at mail.berlios.de  Mon Dec 25 10:19:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 10:19:25 +0100
Subject: [Stgt-svn] r714 - trunk/usr
Message-ID: <200612250919.kBP9JPet013407@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 10:19:24 +0100 (Mon, 25 Dec 2006)
New Revision: 714

Modified:
   trunk/usr/mgmt.c
Log:
Remove req and rsp in mtask structure.

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 08:30:02 UTC (rev 713)
+++ trunk/usr/mgmt.c	2006-12-25 09:19:24 UTC (rev 714)
@@ -55,8 +55,6 @@
 	int done;
 	char *buf;
 /* 	struct tgt_work work; */
-	struct tgtadm_req *req;
-	struct tgtadm_rsp *rsp;
 };
 
 static void set_show_results(struct tgtadm_rsp *rsp, int *err)



From tomo at mail.berlios.de  Mon Dec 25 11:57:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 11:57:04 +0100
Subject: [Stgt-svn] r715 - trunk/usr
Message-ID: <200612251057.kBPAv4xm022450@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 11:57:04 +0100 (Mon, 25 Dec 2006)
New Revision: 715

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.h
Log:
tgt_target_show_all can handle long responses.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 09:19:24 UTC (rev 714)
+++ trunk/usr/mgmt.c	2006-12-25 10:57:04 UTC (rev 715)
@@ -41,8 +41,6 @@
 #include "driver.h"
 #include "util.h"
 
-#define BUFSIZE 4096
-
 enum mgmt_task_state {
 	MTASK_STATE_HDR_RECV,
 	MTASK_STATE_PDU_RECV,
@@ -54,6 +52,9 @@
 	int retry;
 	int done;
 	char *buf;
+	int bsize;
+	struct tgtadm_req req;
+	struct tgtadm_rsp rsp;
 /* 	struct tgt_work work; */
 };
 
@@ -68,17 +69,17 @@
 	}
 }
 
-static int target_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       struct tgtadm_rsp *rsp, int *rlen)
+static int target_mgmt(int lld_no, struct mgmt_task *mtask)
 {
+	struct tgtadm_req *req = &mtask->req;
+	struct tgtadm_rsp *rsp = &mtask->rsp;
 	int err = -EINVAL;
-	char *pdu = (char *)rsp + sizeof(*rsp);
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(lld_no, req->tid, params);
+		err = tgt_target_create(lld_no, req->tid, mtask->buf);
 		if (!err && tgt_drivers[lld_no]->target_create)
-			tgt_drivers[lld_no]->target_create(req->tid, params);
+			tgt_drivers[lld_no]->target_create(req->tid, mtask->buf);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);
@@ -93,26 +94,36 @@
 		char *p;
 		err = -EINVAL;
 
-		p = strchr(params, '=');
+		p = strchr(mtask->buf, '=');
 		if (!p)
 			break;
 		*p++ = '\0';
 
-		if (!strcmp(params, "state"))
+		if (!strcmp(mtask->buf, "state"))
 			err = tgt_set_target_state(req->tid, p);
 		else if (tgt_drivers[lld_no]->target_update)
-			err = tgt_drivers[lld_no]->target_update(req->tid, params);
+			err = tgt_drivers[lld_no]->target_update(req->tid, mtask->buf);
 		break;
 	}
 	case OP_SHOW:
-		if (req->tid < 0)
-			err = tgt_target_show_all(pdu, *rlen - sizeof(*rsp));
-		else if (tgt_drivers[lld_no]->show)
+		if (req->tid < 0) {
+			retry:
+			err = tgt_target_show_all(mtask->buf, mtask->bsize);
+			if (err == mtask->bsize) {
+				char *p;
+				mtask->bsize <<= 1;
+				p = realloc(mtask->buf, mtask->bsize);
+				if (p) {
+					mtask->buf = p;
+					goto retry;
+				} else
+					err = TGTADM_NOMEM;
+			}
+		} else if (tgt_drivers[lld_no]->show)
 			err = tgt_drivers[lld_no]->show(req->mode,
 							req->tid, req->sid,
 							req->cid, req->lun,
-							pdu,
-							*rlen - sizeof(*rsp));
+							mtask->buf, mtask->bsize);
 		break;
 	default:
 		break;
@@ -161,11 +172,11 @@
 	return err;
 }
 
-static int tgt_mgmt(struct tgtadm_req *req, struct tgtadm_rsp *rsp, int len)
+static int tgt_mgmt(struct mgmt_task *mtask)
 {
-	int lld_no, err = -EINVAL;
-	char *params = (char *) req + sizeof(*req);
-	char *pdu = (char *) rsp + sizeof(*rsp);
+	struct tgtadm_req *req = &mtask->req;
+	struct tgtadm_rsp *rsp = &mtask->rsp;
+	int lld_no, err = -EINVAL, len = mtask->bsize;
 
 	lld_no = get_driver_index(req->lld);
 	if (lld_no < 0) {
@@ -177,22 +188,21 @@
 
 	dprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
 		req->len, lld_no, req->mode, req->op,
-		req->tid, req->sid, req->lun, params, getpid());
+		req->tid, req->sid, req->lun, mtask->buf, getpid());
 
 	switch (req->mode) {
 	case MODE_SYSTEM:
 		break;
 	case MODE_TARGET:
-		err = target_mgmt(lld_no, req, params, rsp, &len);
+		err = target_mgmt(lld_no, mtask);
 		break;
 	case MODE_DEVICE:
-		err = device_mgmt(lld_no, req, params, rsp, &len);
+		err = device_mgmt(lld_no, req, mtask->buf, rsp, &len);
 		break;
 	case MODE_ACCOUNT:
 		if (tgt_drivers[lld_no]->account)
 			err = tgt_drivers[lld_no]->account(req->op, req->tid, req->aid,
-							   params, pdu,
-							   len - sizeof(*rsp));
+							   mtask->buf, mtask->buf, len);
 		if (req->op == OP_SHOW) {
 			set_show_results(rsp, &err);
 			err = 0;
@@ -206,8 +216,7 @@
 			err = tgt_drivers[lld_no]->show(req->mode,
 							req->tid, req->sid,
 							req->cid, req->lun,
-							pdu,
-							len - sizeof(*rsp));
+							mtask->buf, len);
 
 			set_show_results(rsp, &err);
 		}
@@ -252,28 +261,34 @@
 static void mtask_handler(int fd, int events, void *data)
 {
 	int err, len;
-	char *pdu;
+	char *p;
 	struct mgmt_task *mtask = data;
-	struct tgtadm_req *req = (struct tgtadm_req *) mtask->buf;
-	struct tgtadm_rsp *rsp = (struct tgtadm_rsp *) mtask->buf;
+	struct tgtadm_req *req = &mtask->req;
+	struct tgtadm_rsp *rsp = &mtask->rsp;
 
 	switch (mtask->mtask_state) {
 	case MTASK_STATE_HDR_RECV:
 		len = sizeof(*req) - mtask->done;
-		err = read(fd, mtask->buf + mtask->done, len);
+		err = read(fd, (char *)req + mtask->done, len);
 		if (err > 0) {
 			mtask->done += err;
 			if (mtask->done == sizeof(*req)) {
 				if (req->len == sizeof(*req)) {
-					tgt_mgmt(req, rsp, BUFSIZE);
+					tgt_mgmt(mtask);
 					mtask->mtask_state =
 						MTASK_STATE_RSP_SEND;
 					tgt_event_modify(fd, EPOLLOUT);
 					mtask->done = 0;
 				} else {
+					/* the pdu exists */
+					mtask->done = 0;
 					mtask->mtask_state =
 						MTASK_STATE_PDU_RECV;
-					mtask->done = 0;
+
+					if (mtask->bsize < req->len) {
+						eprintf("FIXME: %d\n", req->len);
+						goto out;
+					}
 				}
 			}
 		} else
@@ -283,12 +298,11 @@
 		break;
 	case MTASK_STATE_PDU_RECV:
 		len = req->len - (sizeof(*req) + mtask->done);
-		pdu = mtask->buf + sizeof(*req);
-		err = read(fd, pdu + mtask->done, len);
+		err = read(fd, mtask->buf + mtask->done, len);
 		if (err > 0) {
 			mtask->done += err;
 			if (mtask->done == req->len - (sizeof(*req))) {
-				tgt_mgmt(req, rsp, BUFSIZE);
+				tgt_mgmt(mtask);
 				mtask->mtask_state = MTASK_STATE_RSP_SEND;
 				tgt_event_modify(fd, EPOLLOUT);
 				mtask->done = 0;
@@ -299,8 +313,15 @@
 
 		break;
 	case MTASK_STATE_RSP_SEND:
-		len = rsp->len - mtask->done;
-		err = write(fd, mtask->buf + mtask->done, len);
+		if (mtask->done < sizeof(*rsp)) {
+			p = (char *)rsp + mtask->done;
+			len = sizeof(*rsp) - mtask->done;
+		} else {
+			p = mtask->buf + (mtask->done - sizeof(*rsp));
+			len = rsp->len - mtask->done;
+		}
+
+		err = write(fd, p, len);
 		if (err > 0) {
 			mtask->done += err;
 
@@ -317,10 +338,13 @@
 	return;
 out:
 	tgt_event_del(fd);
+	free(mtask->buf);
 	free(mtask);
 	close(fd);
 }
 
+#define BUFSIZE 1024
+
 static void mgmt_event_handler(int accept_fd, int events, void *data)
 {
 	int fd, err;
@@ -338,14 +362,20 @@
 	if (err)
 		goto out;
 
-	mtask = zalloc(sizeof(*mtask) + sizeof(struct tgtadm_req) + BUFSIZE);
+	mtask = zalloc(sizeof(*mtask));
 	if (!mtask) {
 		eprintf("can't allocate mtask\n");
 		goto out;
 	}
 
+	mtask->buf = zalloc(BUFSIZE);
+	if (!mtask->buf) {
+		free(mtask);
+		goto out;
+	}
+
+	mtask->bsize = BUFSIZE;
 	mtask->mtask_state = MTASK_STATE_HDR_RECV;
-	mtask->buf = (char *) mtask + sizeof(*mtask);
 	err = tgt_event_add(fd, EPOLLIN, mtask_handler, mtask);
 	if (err) {
 		free(mtask);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-25 09:19:24 UTC (rev 714)
+++ trunk/usr/target.c	2006-12-25 10:57:04 UTC (rev 715)
@@ -773,7 +773,7 @@
 
 int tgt_target_show_all(char *buf, int rest)
 {
-	int i, len, total;
+	int i, len, total, max = rest;
 	struct target *target;
 	struct tgt_device *device;
 
@@ -787,18 +787,24 @@
 				       target->name,
 				       tgt_drivers[target->lid]->name,
 				       target_state_name(target->target_state));
+			if (len > rest) {
+				total = max;
+				goto out;
+			}
+
 			buf += len;
 			total += len;
 			rest -= len;
-			if (!rest)
+
+			len = snprintf(buf, rest, TAB1 "LUN information:\n");
+			if (len > rest) {
+				total = max;
 				goto out;
+			}
 
-			len = snprintf(buf, rest, TAB1 "LUN information:\n");
 			buf += len;
 			total += len;
 			rest -= len;
-			if (!rest)
-				goto out;
 
 			list_for_each_entry(device, &target->device_list, d_list) {
 				len = snprintf(buf, rest,
@@ -814,11 +820,14 @@
 					       print_disksize(device->size),
 					       device->path,
 					       target_iotype_name(target->target_iotype));
+				if (len > rest) {
+					total = max;
+					goto out;
+				}
+
 				buf += len;
 				total += len;
 				rest -= len;
-				if (!rest)
-					goto out;
 			}
 		}
 	}

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-25 09:19:24 UTC (rev 714)
+++ trunk/usr/tgtadm.h	2006-12-25 10:57:04 UTC (rev 715)
@@ -7,7 +7,7 @@
 enum tgtadm_errno {
 	TGTADM_SUCCESS,
 	TGTADM_UNKNOWN_ERR,
-	TGTADM_OOM,
+	TGTADM_NOMEM,
 	TGTADM_NO_DRIVER,
 	TGTADM_NO_TARGET,
 



From tomo at mail.berlios.de  Mon Dec 25 11:59:08 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 25 Dec 2006 11:59:08 +0100
Subject: [Stgt-svn] r716 - trunk/usr
Message-ID: <200612251059.kBPAx8pa022645@sheep.berlios.de>

Author: tomo
Date: 2006-12-25 11:59:08 +0100 (Mon, 25 Dec 2006)
New Revision: 716

Modified:
   trunk/usr/mgmt.c
Log:
Fix mtask->buf memory leak.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 10:57:04 UTC (rev 715)
+++ trunk/usr/mgmt.c	2006-12-25 10:59:08 UTC (rev 716)
@@ -378,6 +378,7 @@
 	mtask->mtask_state = MTASK_STATE_HDR_RECV;
 	err = tgt_event_add(fd, EPOLLIN, mtask_handler, mtask);
 	if (err) {
+		free(mtask->buf);
 		free(mtask);
 		goto out;
 	}



From tomo at mail.berlios.de  Tue Dec 26 03:45:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 26 Dec 2006 03:45:19 +0100
Subject: [Stgt-svn] r717 - trunk/usr
Message-ID: <200612260245.kBQ2jJXd022069@sheep.berlios.de>

Author: tomo
Date: 2006-12-26 03:45:18 +0100 (Tue, 26 Dec 2006)
New Revision: 717

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
Log:
Add target_list for show operation.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-25 10:59:08 UTC (rev 716)
+++ trunk/usr/mgmt.c	2006-12-26 02:45:18 UTC (rev 717)
@@ -116,8 +116,10 @@
 				if (p) {
 					mtask->buf = p;
 					goto retry;
-				} else
+				} else {
+					eprintf("out of memory\n");
 					err = TGTADM_NOMEM;
+				}
 			}
 		} else if (tgt_drivers[lld_no]->show)
 			err = tgt_drivers[lld_no]->show(req->mode,

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-25 10:59:08 UTC (rev 716)
+++ trunk/usr/target.c	2006-12-26 02:45:18 UTC (rev 717)
@@ -38,6 +38,7 @@
 
 static struct target *hostt[MAX_NR_HOST];
 static struct list_head target_hash_list[1 << HASH_ORDER];
+static LIST_HEAD(target_list);
 
 static struct target *target_lookup(int tid)
 {
@@ -773,30 +774,53 @@
 
 int tgt_target_show_all(char *buf, int rest)
 {
-	int i, len, total, max = rest;
+	int len, total, max = rest;
 	struct target *target;
 	struct tgt_device *device;
 
-	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
-		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "Target %d: %s\n"
-				       TAB1 "System information:\n"
-				       TAB2 "Driver: %s\n"
-				       TAB2 "Status: %s\n",
-				       target->tid,
-				       target->name,
-				       tgt_drivers[target->lid]->name,
-				       target_state_name(target->target_state));
-			if (len > rest) {
-				total = max;
-				goto out;
-			}
+	total = 0;
+	list_for_each_entry(target, &target_list, t_list) {
+		len = snprintf(buf, rest, "Target %d: %s\n"
+			       TAB1 "System information:\n"
+			       TAB2 "Driver: %s\n"
+			       TAB2 "Status: %s\n",
+			       target->tid,
+			       target->name,
+			       tgt_drivers[target->lid]->name,
+			       target_state_name(target->target_state));
+		if (len > rest) {
+			total = max;
+			goto out;
+		}
 
-			buf += len;
-			total += len;
-			rest -= len;
+		buf += len;
+		total += len;
+		rest -= len;
 
-			len = snprintf(buf, rest, TAB1 "LUN information:\n");
+		len = snprintf(buf, rest, TAB1 "LUN information:\n");
+		if (len > rest) {
+			total = max;
+			goto out;
+		}
+
+		buf += len;
+		total += len;
+		rest -= len;
+
+		list_for_each_entry(device, &target->device_list, d_list) {
+			len = snprintf(buf, rest,
+				       TAB2 "LUN: %" PRIu64 "\n"
+				       TAB3 "SCSI ID: %s\n"
+				       TAB3 "SCSI SN: %s\n"
+				       TAB3 "Size: %s\n"
+				       TAB3 "Backing store: %s\n"
+				       TAB3 "Backing store type: %s\n",
+				       device->lun,
+				       device->scsi_id,
+				       device->scsi_sn,
+				       print_disksize(device->size),
+				       device->path,
+				       target_iotype_name(target->target_iotype));
 			if (len > rest) {
 				total = max;
 				goto out;
@@ -805,30 +829,6 @@
 			buf += len;
 			total += len;
 			rest -= len;
-
-			list_for_each_entry(device, &target->device_list, d_list) {
-				len = snprintf(buf, rest,
-					       TAB2 "LUN: %" PRIu64 "\n"
-					       TAB3 "SCSI ID: %s\n"
-					       TAB3 "SCSI SN: %s\n"
-					       TAB3 "Size: %s\n"
-					       TAB3 "Backing store: %s\n"
-					       TAB3 "Backing store type: %s\n",
-					       device->lun,
-					       device->scsi_id,
-					       device->scsi_sn,
-					       print_disksize(device->size),
-					       device->path,
-					       target_iotype_name(target->target_iotype));
-				if (len > rest) {
-					total = max;
-					goto out;
-				}
-
-				buf += len;
-				total += len;
-				rest -= len;
-			}
 		}
 	}
 out:
@@ -849,7 +849,7 @@
 int tgt_target_create(int lld, int tid, char *args)
 {
 	int i, t_type = TARGET_SBC, bs_type = LU_BS_FILE;
-	struct target *target;
+	struct target *target, *pos;
 	char *p, *q, *targetname = NULL;
 
 	p = args;
@@ -913,6 +913,12 @@
 	tgt_cmd_queue_init(&target->cmd_queue);
 	target_hlist_insert(target);
 
+	list_for_each_entry(pos, &target_list, t_list) {
+		if (target->tid < pos->tid)
+			break;
+	}
+	list_add_tail(&target->t_list, &pos->t_list);
+
 	eprintf("Succeed to create a new target %d\n", tid);
 
 	return 0;
@@ -935,6 +941,7 @@
 		return -EBUSY;
 
 	target_hlist_remove(target);
+	list_del(&target->t_list);
 	free(target);
 
 	return 0;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-12-25 10:59:08 UTC (rev 716)
+++ trunk/usr/target.h	2006-12-26 02:45:18 UTC (rev 717)
@@ -29,6 +29,7 @@
 	enum scsi_target_iotype target_iotype;
 	enum scsi_target_state target_state;
 
+	struct list_head t_list;
 	struct list_head t_hlist;
 
 	struct list_head device_hash_list[1 << HASH_ORDER];



From tomo at mail.berlios.de  Tue Dec 26 13:40:20 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 26 Dec 2006 13:40:20 +0100
Subject: [Stgt-svn] r718 - in trunk: doc usr
Message-ID: <200612261240.kBQCeK46032326@sheep.berlios.de>

Author: tomo
Date: 2006-12-26 13:40:19 +0100 (Tue, 26 Dec 2006)
New Revision: 718

Modified:
   trunk/doc/README.passthrough
   trunk/usr/Makefile
   trunk/usr/bd_sg.c
Log:
Update bd_sg.c for the current bsg tree.


Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-12-26 02:45:18 UTC (rev 717)
+++ trunk/doc/README.passthrough	2006-12-26 12:40:19 UTC (rev 718)
@@ -18,9 +18,9 @@
 
 The passthrough mode support is not finished yet. tgt can pass SCSI
 commands but transport-layer commands. So tgt cannot handle TMFs
-now. This is mainly because Linux kernel does not enable user space to
-send transport-layer commands to LLDs yet. The sg version 4 will
-support this. We need to wait for some time.
+now. This is because Linux kernel does not enable user space to send
+transport-layer commands to LLDs yet. The sg version 4 will support
+this. We need to wait for some time.
 
 
 Starting
@@ -32,17 +32,13 @@
 
 http://www.kernel.org/git/?p=linux/kernel/git/axboe/linux-2.6-block.git;a=summary
 
+Second, apply the IOCB_CMD_EPOLL_WAIT patch in the patch directory,
+rebuild the kernel and reboot with the new kernel.
 
-Secondly, if you want to the passthrough mode with the ibmvio driver,
-pick up the tgt patches in the tgt tree, and apply them. If you use
-the iscsi driver, you can skip this.
+Third, modify usr/Makefile to complile bd_sg.c.
 
-Thirdly, apply the IOCB_CMD_EPOLL_WAIT patch in the patch directory.
+The following example is to export /dev/sdb via the iscsi driver.
 
-You are ready. The following example is to export /dev/sda via the
-iscsi driver. Good luck.
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iotype --value rawio
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 --params Path=/dev/sda
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --backing-store-type raw -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sdb
 host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-12-26 02:45:18 UTC (rev 717)
+++ trunk/usr/Makefile	2006-12-26 12:40:19 UTC (rev 718)
@@ -40,7 +40,8 @@
 CFLAGS += -Wall -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o bd_sg.o
+TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o
+#TGTD_OBJS += bd_sg.o
 
 all: $(PROGRAMS)
 

Modified: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2006-12-26 02:45:18 UTC (rev 717)
+++ trunk/usr/bd_sg.c	2006-12-26 12:40:19 UTC (rev 718)
@@ -26,26 +26,23 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <scsi/sg.h>
 #include <sys/epoll.h>
 #include <limits.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <sys/time.h>
+#include <linux/types.h>
+#include <linux/bsg.h>
 
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
 
-/*
- * this uses sg4, so you need to Jens' bsg tree now.
- */
-
 static void sg_handler(int fd, int events, void *data)
 {
 	int i, err;
-	struct sg_io_hdr hdrs[64];
+	struct sg_io_v4 hdrs[64];
 	struct tgt_device *dev = data;
 
 	err = read(dev->fd, hdrs, sizeof(hdrs));
@@ -53,13 +50,10 @@
 		return;
 
 	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
-		struct cmd *cmd = (void *) hdrs[i].usr_ptr;
-		dprintf("%d %p %u %u %x\n", i, hdrs[i].usr_ptr,
-			hdrs[i].status, hdrs[i].resid,
-			hdrs[i].info);
-		if (hdrs[i].resid)
-			cmd->len = hdrs[i].resid;
-		target_cmd_io_done(hdrs[i].usr_ptr, 0);
+		struct cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
+		if (hdrs[i].din_resid)
+			cmd->len = hdrs[i].din_resid;
+		target_cmd_io_done(cmd, 0);
 	}
 }
 
@@ -70,8 +64,10 @@
 	char *sd, buf[256];
 	struct stat64 st;
 	struct timeval t;
+	struct sg_io_v4 hdr, *h;
 
 	/* we assume something like /dev/sda */
+	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
 
 	*fd = backed_file_open(path, 0, size);
 	if (*fd < 0)
@@ -172,23 +168,29 @@
 			    uint64_t offset, int *async, void *key)
 {
 	int err;
-	struct sg_io_hdr hdr;
+	struct sg_io_v4 hdr;
 
 	/* TODO sense */
 
 	dprintf("%x %d %u %lx\n", scb[0], rw, datalen, *uaddr);
 	memset(&hdr, 0, sizeof(hdr));
-	hdr.interface_id = 'S';
-	hdr.cmd_len = 16;
-	hdr.cmdp = scb;
-	hdr.dxfer_direction = rw ? SG_DXFER_TO_DEV : SG_DXFER_FROM_DEV;
-	hdr.dxfer_len = datalen;
-	hdr.dxferp = (void *) *uaddr;
-/* 	hdr.mx_sb_len = sizeof(sense); */
-/* 	hdr.sbp = sense; */
-	hdr.timeout = 30000;
-	hdr.usr_ptr = key;
+	hdr.guard = 'Q';
+	hdr.request_len = 16;
+	hdr.request = (unsigned long) scb;
 
+	if (rw) {
+		hdr.dout_xfer_len = datalen;
+		hdr.dout_xferp = *uaddr;
+	} else {
+		hdr.din_xfer_len = datalen;
+		hdr.din_xferp = *uaddr;
+	}
+
+/* 	hdr.max_response_len = sizeof(sense); */
+/* 	hdr.response = (unsigned long) sense; */
+
+	hdr.usr_ptr = (unsigned long) key;
+
 	*async = 1;
 
 	err = write(dev->fd, &hdr, sizeof(hdr));



From tomo at mail.berlios.de  Tue Dec 26 15:43:01 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 26 Dec 2006 15:43:01 +0100
Subject: [Stgt-svn] r719 - in trunk: doc patches
Message-ID: <200612261443.kBQEh1Jv014850@sheep.berlios.de>

Author: tomo
Date: 2006-12-26 15:43:00 +0100 (Tue, 26 Dec 2006)
New Revision: 719

Added:
   trunk/patches/bsg_large_queue.diff
Modified:
   trunk/doc/README.passthrough
Log:
Add workaround for too small bsg queue.


Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-12-26 12:40:19 UTC (rev 718)
+++ trunk/doc/README.passthrough	2006-12-26 14:43:00 UTC (rev 719)
@@ -32,8 +32,8 @@
 
 http://www.kernel.org/git/?p=linux/kernel/git/axboe/linux-2.6-block.git;a=summary
 
-Second, apply the IOCB_CMD_EPOLL_WAIT patch in the patch directory,
-rebuild the kernel and reboot with the new kernel.
+Second, apply aioepoll and bsg_large_queue patches in the patch
+directory, rebuild the kernel and reboot with the new kernel.
 
 Third, modify usr/Makefile to complile bd_sg.c.
 

Added: trunk/patches/bsg_large_queue.diff
===================================================================
--- trunk/patches/bsg_large_queue.diff	2006-12-26 12:40:19 UTC (rev 718)
+++ trunk/patches/bsg_large_queue.diff	2006-12-26 14:43:00 UTC (rev 719)
@@ -0,0 +1,13 @@
+diff --git a/block/bsg.c b/block/bsg.c
+index 9d77a0c..f915cb6 100644
+--- a/block/bsg.c
++++ b/block/bsg.c
+@@ -63,7 +63,7 @@ enum {
+ /*
+  * command allocation bitmap defines
+  */
+-#define BSG_CMDS_PAGE_ORDER	(1)
++#define BSG_CMDS_PAGE_ORDER	(3)
+ #define BSG_CMDS_PER_LONG	(sizeof(unsigned long) * 8)
+ #define BSG_CMDS_MASK		(BSG_CMDS_PER_LONG - 1)
+ #define BSG_CMDS_BYTES		(PAGE_SIZE * (1 << BSG_CMDS_PAGE_ORDER))



From tomo at mail.berlios.de  Wed Dec 27 01:28:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 27 Dec 2006 01:28:50 +0100
Subject: [Stgt-svn] r720 - in trunk: doc usr
Message-ID: <200612270028.kBR0SnFl025804@sheep.berlios.de>

Author: tomo
Date: 2006-12-27 01:28:48 +0100 (Wed, 27 Dec 2006)
New Revision: 720

Modified:
   trunk/doc/README.passthrough
   trunk/usr/Makefile
   trunk/usr/tgtd.h
Log:
Add raw backing storage workaround.

Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-12-26 14:43:00 UTC (rev 719)
+++ trunk/doc/README.passthrough	2006-12-27 00:28:48 UTC (rev 720)
@@ -35,8 +35,11 @@
 Second, apply aioepoll and bsg_large_queue patches in the patch
 directory, rebuild the kernel and reboot with the new kernel.
 
-Third, modify usr/Makefile to complile bd_sg.c.
+Third, compile the code with RAW option enabled like the following
+example (for the case you use iSCSI the target driver):
 
+host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1 RAW=1
+
 The following example is to export /dev/sdb via the iscsi driver.
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --backing-store-type raw -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-12-26 14:43:00 UTC (rev 719)
+++ trunk/usr/Makefile	2006-12-27 00:28:48 UTC (rev 720)
@@ -20,6 +20,11 @@
 LIBS += -laio
 endif
 
+ifneq ($(RAW),)
+TGTD_OBJS += bd_sg.o
+CFLAGS += -DUSE_RAW
+endif
+
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
@@ -41,7 +46,6 @@
 
 PROGRAMS += tgtd tgtadm
 TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o
-#TGTD_OBJS += bd_sg.o
 
 all: $(PROGRAMS)
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-26 14:43:00 UTC (rev 719)
+++ trunk/usr/tgtd.h	2006-12-27 00:28:48 UTC (rev 720)
@@ -60,6 +60,10 @@
 }
 #endif
 
+#ifndef USE_RAW
+struct backedio_template sg_bdt;
+#endif
+
 extern int kspace_send_tsk_mgmt_res(int host_no, uint64_t mid, int result);
 extern int kspace_send_cmd_res(int host_no, int len, int result,
 			       int rw, uint64_t addr, uint64_t tag);



From tomo at mail.berlios.de  Thu Dec 28 06:45:58 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 28 Dec 2006 06:45:58 +0100
Subject: [Stgt-svn] r721 - trunk/doc
Message-ID: <200612280545.kBS5jwew014009@sheep.berlios.de>

Author: tomo
Date: 2006-12-28 06:45:56 +0100 (Thu, 28 Dec 2006)
New Revision: 721

Modified:
   trunk/doc/README.passthrough
Log:
Minor addition to README.passthrough.

Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-12-27 00:28:48 UTC (rev 720)
+++ trunk/doc/README.passthrough	2006-12-28 05:45:56 UTC (rev 721)
@@ -10,7 +10,7 @@
 
 In some cases, you need to directly pass SCSI commands to real SCSI
 devices comming from the initiators. For example, you might want to
-use the passthrough mode to provide SCSI tape drives to the
+use the passthrough mode to provide SCSI cdrom or tape drives to the
 initiators. Another example is SAN bridge (called SAN router too), to
 bind different SAN protocols. For example, an iSCSI-FC bridge can
 connect the existing FC network with a new iSCSI network, that is,



From tomo at mail.berlios.de  Thu Dec 28 06:59:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 28 Dec 2006 06:59:19 +0100
Subject: [Stgt-svn] r722 - trunk/doc
Message-ID: <200612280559.kBS5xJGH000904@sheep.berlios.de>

Author: tomo
Date: 2006-12-28 06:59:17 +0100 (Thu, 28 Dec 2006)
New Revision: 722

Modified:
   trunk/doc/README.passthrough
Log:
Another minor addition to README.passthrough


Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-12-28 05:45:56 UTC (rev 721)
+++ trunk/doc/README.passthrough	2006-12-28 05:59:17 UTC (rev 722)
@@ -40,8 +40,11 @@
 
 host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1 RAW=1
 
-The following example is to export /dev/sdb via the iscsi driver.
+The following example is to export /dev/sdb via the iscsi driver:
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --backing-store-type raw -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sdb
 host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
+
+If you want to export a cdrom drive, use /dev/sr0 instead of /dev/sdb
+in the above example.



From tomo at mail.berlios.de  Thu Dec 28 07:15:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 28 Dec 2006 07:15:18 +0100
Subject: [Stgt-svn] r723 - trunk/usr
Message-ID: <200612280615.kBS6FID3028500@sheep.berlios.de>

Author: tomo
Date: 2006-12-28 07:15:17 +0100 (Thu, 28 Dec 2006)
New Revision: 723

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Remove tgt_device_show because target_device_show handles it.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-28 05:59:17 UTC (rev 722)
+++ trunk/usr/mgmt.c	2006-12-28 06:15:17 UTC (rev 723)
@@ -144,7 +144,6 @@
 		       struct tgtadm_rsp *rsp, int *rlen)
 {
 	int err = -EINVAL;
-	char *pdu = (char *)rsp + sizeof(*rsp);
 
 	switch (req->op) {
 	case OP_NEW:
@@ -156,20 +155,12 @@
 	case OP_UPDATE:
 		err = tgt_device_update(req->tid, req->lun, params);
 		break;
-	case OP_SHOW:
-		err = tgt_device_show(req->tid, req->lun, pdu,
-				      *rlen - sizeof(*rsp));
-		break;
 	default:
 		break;
 	}
 
-	if (req->op == OP_SHOW)
-		set_show_results(rsp, &err);
-	else {
-		rsp->err = err;
-		rsp->len = sizeof(*rsp);
-	}
+	rsp->err = err;
+	rsp->len = sizeof(*rsp);
 
 	return err;
 }

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-28 05:59:17 UTC (rev 722)
+++ trunk/usr/target.c	2006-12-28 06:15:17 UTC (rev 723)
@@ -244,35 +244,6 @@
 	!rest;					\
 })
 
-int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest)
-{
-	int len, total = 0;
-	struct target *target;
-	struct tgt_device *device;
-
-	target = target_lookup(tid);
-	if (!target)
-		return rest;
-
-	device = device_lookup(target, dev_id);
-	if (!device) {
-		eprintf("device %" PRIu64 " not found\n", dev_id);
-		return rest;
-	}
-
-	len = snprintf(buf, rest, "path=%s\n", device->path);
-	if (buffer_check(buf, total, len, rest))
-		goto out;
-	len = snprintf(buf, rest, "scsi_id=%s\n", device->scsi_id);
-	if (buffer_check(buf, total, len, rest))
-		goto out;
-	len = snprintf(buf, rest, "scsi_sn=%s\n", device->scsi_sn);
-	if (buffer_check(buf, total, len, rest))
-		goto out;
-out:
-	return rest;
-}
-
 int tgt_device_update(int tid, uint64_t dev_id, char *name)
 {
 	int err = 0;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-28 05:59:17 UTC (rev 722)
+++ trunk/usr/tgtd.h	2006-12-28 06:15:17 UTC (rev 723)
@@ -70,8 +70,8 @@
 extern int ipc_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, char *args);
 extern int tgt_device_destroy(int tid, uint64_t lun);
-extern int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
+
 extern int tgt_target_create(int lld, int tid, char *targetname);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);



From tomo at mail.berlios.de  Fri Dec 29 06:34:48 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 06:34:48 +0100
Subject: [Stgt-svn] r724 - trunk/usr
Message-ID: <200612290534.kBT5YmRR019654@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 06:34:44 +0100 (Fri, 29 Dec 2006)
New Revision: 724

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Add ACL code.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/mgmt.c	2006-12-29 05:34:44 UTC (rev 724)
@@ -87,8 +87,30 @@
 			tgt_drivers[lld_no]->target_destroy(req->tid);
 		break;
 	case OP_BIND:
-		err = tgt_target_bind(req->tid, req->host_no, lld_no);
+		/* FIXME */
+		if (req->len == sizeof(*req))
+			err = tgt_target_bind(req->tid, req->host_no, lld_no);
+		else {
+			char *p;
+
+			p = strchr(mtask->buf, '=');
+			if (p)
+				err = acl_add(req->tid, p + 1);
+		}
 		break;
+	case OP_UNBIND:
+		if (req->len == sizeof(*req))
+			;
+		else {
+			char *p;
+
+			p = strchr(mtask->buf, '=');
+			if (p) {
+				err = 0;
+				acl_del(req->tid, p + 1);
+			}
+		}
+		break;
 	case OP_UPDATE:
 	{
 		char *p;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/target.c	2006-12-29 05:34:44 UTC (rev 724)
@@ -630,6 +630,55 @@
 	}
 }
 
+int acl_add(int tid, char *address)
+{
+	char *str;
+	struct target *target;
+	struct acl_entry *acl, *tmp;
+
+	target = target_lookup(tid);
+	if (!target)
+		return TGTADM_NO_TARGET;
+
+	list_for_each_entry_safe(acl, tmp, &target->acl_list, aclent_list)
+		if (!strcmp(address, acl->address))
+			return TGTADM_ACL_EXIST;
+
+	acl = zalloc(sizeof(*acl));
+	if (!acl)
+		return TGTADM_NOMEM;
+
+	str = strdup(address);
+	if (!str) {
+		free(acl);
+		return TGTADM_NOMEM;
+	}
+
+	acl->address = str;
+	list_add_tail(&acl->aclent_list, &target->acl_list);
+
+	return 0;
+}
+
+void acl_del(int tid, char *address)
+{
+	struct acl_entry *acl, *tmp;
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return;
+
+	list_for_each_entry_safe(acl, tmp, &target->acl_list, aclent_list) {
+		if (!strcmp(address, acl->address)) {
+			list_del(&acl->aclent_list);
+			free(acl->address);
+			free(acl);
+			break;
+		}
+	}
+}
+
 int tgt_target_bind(int tid, int host_no, int lid)
 {
 	struct target *target;
@@ -743,67 +792,59 @@
 #define TAB2 TAB1 TAB1
 #define TAB3 TAB1 TAB1 TAB1
 
+#define shprintf(total, buf, rest, fmt, args...)			\
+do {									\
+	int len;							\
+	len = snprintf(buf, rest, fmt, ##args);				\
+	if (len > rest)							\
+		goto overflow;						\
+	buf += len;							\
+	total += len;							\
+	rest -= len;							\
+} while (0)
+
 int tgt_target_show_all(char *buf, int rest)
 {
-	int len, total, max = rest;
+	int total, max = rest;
 	struct target *target;
 	struct tgt_device *device;
+	struct acl_entry *acl;
 
 	total = 0;
 	list_for_each_entry(target, &target_list, t_list) {
-		len = snprintf(buf, rest, "Target %d: %s\n"
-			       TAB1 "System information:\n"
-			       TAB2 "Driver: %s\n"
-			       TAB2 "Status: %s\n",
-			       target->tid,
-			       target->name,
-			       tgt_drivers[target->lid]->name,
-			       target_state_name(target->target_state));
-		if (len > rest) {
-			total = max;
-			goto out;
-		}
+		shprintf(total, buf, rest,
+			 "Target %d: %s\n"
+			 TAB1 "System information:\n"
+			 TAB2 "Driver: %s\n"
+			 TAB2 "Status: %s\n",
+			 target->tid,
+			 target->name,
+			 tgt_drivers[target->lid]->name,
+			 target_state_name(target->target_state));
 
-		buf += len;
-		total += len;
-		rest -= len;
+		shprintf(total, buf, rest, TAB1 "ACL information:\n");
+		list_for_each_entry(acl, &target->acl_list, aclent_list)
+			shprintf(total, buf, rest, TAB2 "%s\n", acl->address);
 
-		len = snprintf(buf, rest, TAB1 "LUN information:\n");
-		if (len > rest) {
-			total = max;
-			goto out;
-		}
-
-		buf += len;
-		total += len;
-		rest -= len;
-
-		list_for_each_entry(device, &target->device_list, d_list) {
-			len = snprintf(buf, rest,
-				       TAB2 "LUN: %" PRIu64 "\n"
-				       TAB3 "SCSI ID: %s\n"
-				       TAB3 "SCSI SN: %s\n"
-				       TAB3 "Size: %s\n"
-				       TAB3 "Backing store: %s\n"
-				       TAB3 "Backing store type: %s\n",
-				       device->lun,
-				       device->scsi_id,
-				       device->scsi_sn,
-				       print_disksize(device->size),
-				       device->path,
-				       target_iotype_name(target->target_iotype));
-			if (len > rest) {
-				total = max;
-				goto out;
-			}
-
-			buf += len;
-			total += len;
-			rest -= len;
-		}
+		shprintf(total, buf, rest, TAB1 "LUN information:\n");
+		list_for_each_entry(device, &target->device_list, d_list)
+			shprintf(total, buf, rest,
+				 TAB2 "LUN: %" PRIu64 "\n"
+				 TAB3 "SCSI ID: %s\n"
+				 TAB3 "SCSI SN: %s\n"
+				 TAB3 "Size: %s\n"
+				 TAB3 "Backing store: %s\n"
+				 TAB3 "Backing store type: %s\n",
+				 device->lun,
+				 device->scsi_id,
+				 device->scsi_sn,
+				 print_disksize(device->size),
+				 device->path,
+				 target_iotype_name(target->target_iotype));
 	}
-out:
 	return total;
+overflow:
+	return max;
 }
 
 char *tgt_targetname(int tid)
@@ -890,6 +931,8 @@
 	}
 	list_add_tail(&target->t_list, &pos->t_list);
 
+	INIT_LIST_HEAD(&target->acl_list);
+
 	eprintf("Succeed to create a new target %d\n", tid);
 
 	return 0;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/target.h	2006-12-29 05:34:44 UTC (rev 724)
@@ -14,6 +14,11 @@
 #define	HASH_ORDER	4
 #define	hashfn(val)	hash_long((unsigned long) (val), HASH_ORDER)
 
+struct acl_entry {
+	char *address;
+	struct list_head aclent_list;
+};
+
 struct mgmt_req {
 	uint64_t mid;
 	int busy;
@@ -40,6 +45,8 @@
 	struct tgt_cmd_queue cmd_queue;
 
 	struct backedio_template *bdt;
+
+	struct list_head acl_list;
 };
 
 struct cmd {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/tgtadm.c	2006-12-29 05:34:44 UTC (rev 724)
@@ -65,14 +65,15 @@
 	"unknown error",
 	"out of memory",
 	"can't find the driver",
-	"can't find the target",
+	"can't find the target", /* 5 */
 
 	"can't find the logical unit",
 	"can't find the session",
 	"can't find the connection",
-	"the target already exists",
-	"the logical unit already exists",
+	"this target already exists",
+	"this logical unit already exists",  /* 10 */
 
+	"this access control rule already exists",
 	"unknown parameter",
 };
 
@@ -91,6 +92,7 @@
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
 	{"targetname", required_argument, NULL, 'T'},
+	{"initiator-address", required_argument, NULL, 'I'},
 	{"target-type", required_argument, NULL, 'p'},
 	{"backing-store", required_argument, NULL, 'b'},
 	{"backing-store-type", required_argument, NULL, 'S'},
@@ -99,7 +101,7 @@
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:p:b:S:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:I:p:b:S:n:v:dh";
 
 static void usage(int status)
 {
@@ -326,6 +328,8 @@
 		op = OP_DELETE;
 	else if (!strcmp("bind", str))
 		op = OP_BIND;
+	else if (!strcmp("unbind", str))
+		op = OP_UNBIND;
 	else if (!strcmp("show", str))
 		op = OP_SHOW;
 	else if (!strcmp("update", str))
@@ -347,11 +351,11 @@
 	char *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE + sizeof(*req)];
-	char *name, *value, *path, *targetname, *params;
+	char *name, *value, *path, *targetname, *params, *address;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
-	lldname = name = value = path = targetname = NULL;
+	lldname = name = value = path = targetname = address = NULL;
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
@@ -390,6 +394,9 @@
 		case 'T':
 			targetname = optarg;
 			break;
+		case 'I':
+			address = optarg;
+			break;
 		case 'p':
 			t_type = target_type(optarg);
 			break;
@@ -449,7 +456,7 @@
 	params = buf + sizeof(*req);
 
 	/* FIXME */
-	if ((name && value) || path || targetname) {
+	if ((name && value) || path || targetname || address) {
 		if (path) {
 			name = "path";
 			value = path;
@@ -460,6 +467,11 @@
 			value = targetname;
 		}
 
+		if (address) {
+			name = "initiator-address";
+			value = address;
+		}
+
 		len = snprintf(params, rest, "%s=%s", name, value);
 	}
 

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/tgtadm.h	2006-12-29 05:34:44 UTC (rev 724)
@@ -17,6 +17,7 @@
 	TGTADM_TARGET_EXIST,
 	TGTADM_LUN_EXIST,
 
+	TGTADM_ACL_EXIST,
 	TGTADM_UNKNOWN_PARAM,
 };
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-28 06:15:17 UTC (rev 723)
+++ trunk/usr/tgtd.h	2006-12-29 05:34:44 UTC (rev 724)
@@ -106,4 +106,7 @@
 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);
 
+extern int acl_add(int tid, char *address);
+extern void acl_del(int tid, char *address);
+
 #endif



From tomo at mail.berlios.de  Fri Dec 29 07:55:37 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 07:55:37 +0100
Subject: [Stgt-svn] r725 - in trunk/usr: . iscsi
Message-ID: <200612290655.kBT6tbZu025625@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 07:55:36 +0100 (Fri, 29 Dec 2006)
New Revision: 725

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/target.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Add IP base ACL to iscsi.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-12-29 05:34:44 UTC (rev 724)
+++ trunk/usr/iscsi/iscsid.c	2006-12-29 06:55:36 UTC (rev 725)
@@ -360,9 +360,6 @@
 			return;
 		}
 
-/* 		if (target_find_by_name(target_name, &conn->tid) < 0 || */
-/* 		    cops->initiator_access(conn->tid, conn->fd) < 0) { */
-
 		target = target_find_by_name(target_name);
 		if (!target) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
@@ -379,6 +376,13 @@
 			return;
 		}
 
+		if (ip_acl(conn->tid, conn->fd)) {
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
+			conn->state = STATE_EXIT;
+			return;
+		}
+
 /* 		if (conn->target->max_sessions && */
 /* 		    (++conn->target->session_cnt > conn->target->max_sessions)) { */
 /* 			conn->target->session_cnt--; */

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-12-29 05:34:44 UTC (rev 724)
+++ trunk/usr/iscsi/iscsid.h	2006-12-29 06:55:36 UTC (rev 725)
@@ -267,6 +267,7 @@
 struct iscsi_target * target_find_by_name(const char *name);
 struct iscsi_target * target_find_by_id(int tid);
 extern void target_list_build(struct iscsi_connection *, char *, char *);
+extern int ip_acl(int tid, int fd);
 
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-12-29 05:34:44 UTC (rev 724)
+++ trunk/usr/iscsi/target.c	2006-12-29 06:55:36 UTC (rev 725)
@@ -11,16 +11,173 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <netdb.h>
 #include <sys/stat.h>
 #include <sys/un.h>
 #include <linux/netlink.h>
+#include <netinet/in.h>
 #include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <netinet/ip.h>
+#include <arpa/inet.h>
 #include "iscsid.h"
 #include "tgtadm.h"
 #include "tgtd.h"
 
 static LIST_HEAD(targets_list);
 
+static int netmask_match_v6(struct sockaddr *sa1, struct sockaddr *sa2, uint32_t mbit)
+{
+	uint16_t mask, a1[8], a2[8];
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		a1[i] = ntohs(((struct sockaddr_in6 *) sa1)->sin6_addr.s6_addr16[i]);
+		a2[i] = ntohs(((struct sockaddr_in6 *) sa2)->sin6_addr.s6_addr16[i]);
+	}
+
+	for (i = 0; i < mbit / 16; i++)
+		if (a1[i] ^ a2[i])
+			return 0;
+
+	if (mbit % 16) {
+		mask = ~((1 << (16 - (mbit % 16))) - 1);
+		if ((mask & a1[mbit / 16]) ^ (mask & a2[mbit / 16]))
+			return 0;
+	}
+
+	return 1;
+}
+
+static int netmask_match_v4(struct sockaddr *sa1, struct sockaddr *sa2, uint32_t mbit)
+{
+	uint32_t s1, s2, mask = ~((1 << (32 - mbit)) - 1);
+
+	s1 = htonl(((struct sockaddr_in *) sa1)->sin_addr.s_addr);
+	s2 = htonl(((struct sockaddr_in *) sa2)->sin_addr.s_addr);
+
+	if (~mask & s1)
+		return 0;
+
+	if (!((mask & s2) ^ (mask & s1)))
+		return 1;
+
+	return 0;
+}
+
+static int netmask_match(struct sockaddr *sa1, struct sockaddr *sa2, char *buf)
+{
+	uint32_t mbit;
+	uint8_t family = sa1->sa_family;
+
+	mbit = strtoul(buf, NULL, 0);
+	if (mbit < 0 ||
+	    (family == AF_INET && mbit > 31) ||
+	    (family == AF_INET6 && mbit > 127))
+		return 0;
+
+	if (family == AF_INET)
+		return netmask_match_v4(sa1, sa2, mbit);
+
+	return netmask_match_v6(sa1, sa2, mbit);
+}
+
+static int address_match(struct sockaddr *sa1, struct sockaddr *sa2)
+{
+	if (sa1->sa_family == AF_INET)
+		return ((struct sockaddr_in *) sa1)->sin_addr.s_addr ==
+			((struct sockaddr_in *) sa2)->sin_addr.s_addr;
+	else {
+		struct in6_addr *a1, *a2;
+
+		a1 = &((struct sockaddr_in6 *) sa1)->sin6_addr;
+		a2 = &((struct sockaddr_in6 *) sa2)->sin6_addr;
+
+		return (a1->s6_addr32[0] == a2->s6_addr32[0] &&
+			a1->s6_addr32[1] == a2->s6_addr32[1] &&
+			a1->s6_addr32[2] == a2->s6_addr32[2] &&
+			a1->s6_addr32[3] == a2->s6_addr32[3]);
+	}
+
+	return 0;
+}
+
+static int ip_match(int fd, char *address)
+{
+	struct sockaddr_storage from;
+	struct addrinfo hints, *res;
+	socklen_t len;
+	char *str, *p, *q;
+	int err;
+
+	len = sizeof(from);
+	err = getpeername(fd, (struct sockaddr *) &from, &len);
+	if (err < 0)
+		return -EPERM;
+
+	str = p = strdup(address);
+	if (!p)
+		return -EPERM;
+
+	if (!strcmp(p, "ALL")) {
+		err = 0;
+		goto out;
+	}
+
+	if (*p == '[') {
+		p++;
+		if (!(q = strchr(p, ']'))) {
+			err = -EPERM;
+			goto out;
+		}
+		*(q++) = '\0';
+	} else
+		q = p;
+
+	if ((q = strchr(q, '/')))
+		*(q++) = '\0';
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_NUMERICHOST;
+
+	err = getaddrinfo(p, NULL, &hints, &res);
+	if (err < 0) {
+		err = -EPERM;
+		goto out;
+	}
+
+	if (q)
+		err = netmask_match(res->ai_addr, (struct sockaddr *) &from, q);
+	else
+		err = address_match(res->ai_addr, (struct sockaddr *) &from);
+
+	err = !err;
+
+	freeaddrinfo(res);
+out:
+	free(str);
+	return err;
+}
+
+int ip_acl(int tid, int fd)
+{
+	int idx, err;
+	char *addr;
+
+	for (idx = 0;; idx++) {
+		addr = acl_get(tid, idx);
+		if (!addr)
+			break;
+
+		err = ip_match(fd, addr);
+		if (!err)
+			return 0;
+	}
+	return -EPERM;
+}
+
 void target_list_build(struct iscsi_connection *conn, char *addr, char *name)
 {
 	struct iscsi_target *target;
@@ -28,9 +185,10 @@
 	list_for_each_entry(target, &targets_list, tlist) {
 		if (name && strcmp(tgt_targetname(target->tid), name))
 			continue;
-/* 		if (cops->initiator_access(target->tid, conn->fd) < 0) */
-/* 			continue; */
 
+		if (ip_acl(target->tid, conn->fd))
+			continue;
+
 		text_key_add(conn, "TargetName", tgt_targetname(target->tid));
 		text_key_add(conn, "TargetAddress", addr);
 	}

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-29 05:34:44 UTC (rev 724)
+++ trunk/usr/target.c	2006-12-29 06:55:36 UTC (rev 725)
@@ -679,6 +679,24 @@
 	}
 }
 
+char *acl_get(int tid, int idx)
+{
+	int i = 0;
+	struct target *target;
+	struct acl_entry *acl;
+
+	target = target_lookup(tid);
+	if (!target)
+		return NULL;
+
+	list_for_each_entry(acl, &target->acl_list, aclent_list) {
+		if (idx == i++)
+			return acl->address;
+	}
+
+	return NULL;
+}
+
 int tgt_target_bind(int tid, int host_no, int lid)
 {
 	struct target *target;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-29 05:34:44 UTC (rev 724)
+++ trunk/usr/tgtd.h	2006-12-29 06:55:36 UTC (rev 725)
@@ -108,5 +108,6 @@
 
 extern int acl_add(int tid, char *address);
 extern void acl_del(int tid, char *address);
+extern char *acl_get(int tid, int idx);
 
 #endif



From tomo at mail.berlios.de  Fri Dec 29 08:14:11 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 08:14:11 +0100
Subject: [Stgt-svn] r726 - trunk/usr
Message-ID: <200612290714.kBT7EBbn028945@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 08:14:11 +0100 (Fri, 29 Dec 2006)
New Revision: 726

Modified:
   trunk/usr/target.c
Log:
Free acl entities when removing a target.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-29 06:55:36 UTC (rev 725)
+++ trunk/usr/target.c	2006-12-29 07:14:11 UTC (rev 726)
@@ -662,8 +662,8 @@
 
 void acl_del(int tid, char *address)
 {
+	struct target *target;
 	struct acl_entry *acl, *tmp;
-	struct target *target;
 
 	target = target_lookup(tid);
 	if (!target)
@@ -959,6 +959,7 @@
 int tgt_target_destroy(int tid)
 {
 	struct target *target;
+	struct acl_entry *acl, *tmp;
 
 	target = target_lookup(tid);
 	if (!target)
@@ -974,6 +975,13 @@
 
 	target_hlist_remove(target);
 	list_del(&target->t_list);
+
+	list_for_each_entry_safe(acl, tmp, &target->acl_list, aclent_list) {
+		list_del(&acl->aclent_list);
+		free(acl->address);
+		free(acl);
+	}
+
 	free(target);
 
 	return 0;



From tomo at mail.berlios.de  Fri Dec 29 10:10:31 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 10:10:31 +0100
Subject: [Stgt-svn] r727 - trunk/usr
Message-ID: <200612290910.kBT9AVTc009084@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 10:10:30 +0100 (Fri, 29 Dec 2006)
New Revision: 727

Modified:
   trunk/usr/target.c
Log:
Change the default target state to RUNNING.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-29 07:14:11 UTC (rev 726)
+++ trunk/usr/target.c	2006-12-29 09:10:30 UTC (rev 727)
@@ -937,7 +937,7 @@
 		target->bdt = tgt_drivers[lld]->default_bdt;
 	}
 
-	target->target_state = SCSI_TARGET_SUSPENDED;
+	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;
 
 	tgt_cmd_queue_init(&target->cmd_queue);



From tomo at mail.berlios.de  Fri Dec 29 10:25:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 10:25:17 +0100
Subject: [Stgt-svn] r728 - trunk/doc
Message-ID: <200612290925.kBT9PHuN010423@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 10:25:17 +0100 (Fri, 29 Dec 2006)
New Revision: 728

Modified:
   trunk/doc/README.iscsi
Log:
Update README.iscsi


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-12-29 09:10:30 UTC (rev 727)
+++ trunk/doc/README.iscsi	2006-12-29 09:25:17 UTC (rev 728)
@@ -34,20 +34,80 @@
 Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
     System information:
         Driver: iscsi
-        Status: suspended
+        Status: running
+    ACL information:
     LUN information:
         LUN: 0
             SCSI ID: deadbeaf1:0
-            SCSI SN: 
-            Size: 1G
+            SCSI SN:
+            Size: 55G
             Backing store: /dev/hdc1
             Backing store type: file
 
 
-If you don't need no more configuration (iSCSI parameters, security,
-etc), you are ready to accept initiators. In this case, you can go to
-`accepting initiators` session.
+If you don't need to configure this target any more, enable the target
+to accept any initiators:
 
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    ACL information:
+        ALL
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN:
+            Size: 55G
+            Backing store: /dev/hdc1
+            Backing store type: file
+
+
+Note "ACL information" section. "ALL" means that this target accepts
+any initiators. The ACL feature also provides the access control based
+on initiators' addresses.
+
+First, let's remove "ALL" options:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op unbind --mode target --tid 1 -I ALL
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    ACL information:
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN:
+            Size: 55G
+            Backing store: /dev/hdc1
+            Backing store type: file
+
+
+Here are some examples:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode target --tid 1 -I 192.168.2.29
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode target --tid 1 -I 192.168.11.0/24
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    ACL information:
+        192.168.2.29
+        192.168.11.0/24
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN:
+            Size: 55G
+            Backing store: /dev/hdc1
+            Backing store type: file
+
+
 You can add lots of logical units:
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /dev/hdd1
@@ -124,33 +184,6 @@
 MaxConnections=1
 
 
-Accepting initiators
--------------
-Now this target is ready to accept initiators. If you've done the configuration:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
-Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-    System information:
-        Driver: iscsi
-        Status: running
-    LUN information:
-        LUN: 0
-            SCSI ID: deadbeaf1:0
-            SCSI SN: 
-            Size: 42M
-            Backing store: /dev/hdc1
-            Backing store type: file
-        LUN: 1
-            SCSI ID: deadbeaf1:1
-            SCSI SN: 
-            Size: 40M
-            Backing store: /dev/hdd1
-            Backing store type: file
-
-
-Now your target is ready to accept initiators.
-
 Shutdown
 -------------
 host:~/tgt# killall -9 tgtd



From tomo at mail.berlios.de  Fri Dec 29 12:06:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 29 Dec 2006 12:06:02 +0100
Subject: [Stgt-svn] r729 - trunk/usr
Message-ID: <200612291106.kBTB62tN020982@sheep.berlios.de>

Author: tomo
Date: 2006-12-29 12:06:01 +0100 (Fri, 29 Dec 2006)
New Revision: 729

Modified:
   trunk/usr/tgtadm.c
Log:
Add user/password options to tgtadm.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-29 09:25:17 UTC (rev 728)
+++ trunk/usr/tgtadm.c	2006-12-29 11:06:01 UTC (rev 729)
@@ -96,12 +96,14 @@
 	{"target-type", required_argument, NULL, 'p'},
 	{"backing-store", required_argument, NULL, 'b'},
 	{"backing-store-type", required_argument, NULL, 'S'},
+	{"user", required_argument, NULL, 'y'},
+	{"password", required_argument, NULL, 'Y'},
 	{"debug", no_argument, NULL, 'd'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:I:p:b:S:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:I:p:b:S:n:v:y:Y:dh";
 
 static void usage(int status)
 {
@@ -352,10 +354,12 @@
 	struct tgtadm_req *req;
 	char buf[BUFSIZE + sizeof(*req)];
 	char *name, *value, *path, *targetname, *params, *address;
+	char *user, *password;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
 	lldname = name = value = path = targetname = address = NULL;
+	user = password = NULL;
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
@@ -412,6 +416,12 @@
 		case 'v':
 			value = optarg;
 			break;
+		case 'y':
+			user = optarg;
+			break;
+		case 'Y':
+			password = optarg;
+			break;
 		case 'd':
 			debug = 1;
 			break;
@@ -483,6 +493,10 @@
 		len += snprintf(params + len, rest - len,
 				"%sbacking-store-type=%d", len ? "," : "", bs_type);
 
+	if (password && user)
+		len += snprintf(params + len, rest - len, "user=%s,password=%s",
+				user, password);
+
 	req->len = sizeof(*req) + len;
 
 	err = ipc_mgmt_req(req);



From tomo at mail.berlios.de  Sat Dec 30 05:23:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 05:23:18 +0100
Subject: [Stgt-svn] r730 - trunk/usr
Message-ID: <200612300423.kBU4NIYS023081@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 05:23:18 +0100 (Sat, 30 Dec 2006)
New Revision: 730

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Add account code.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/mgmt.c	2006-12-30 04:23:18 UTC (rev 730)
@@ -187,6 +187,68 @@
 	return err;
 }
 
+static int account_mgmt(int lld_no,  struct mgmt_task *mtask)
+{
+	struct tgtadm_req *req = &mtask->req;
+	struct tgtadm_rsp *rsp = &mtask->rsp;
+	int err = TGTADM_INVALID_REQUEST;
+	char *user, *password;
+
+	switch (req->op) {
+	case OP_NEW:
+	case OP_DELETE:
+	case OP_BIND:
+	case OP_UNBIND:
+		user = strstr(mtask->buf, "user=");
+		if (!user)
+			goto out;
+		user += 5;
+
+		if (req->op == OP_NEW) {
+			password = strchr(user, ',');
+			if (!password)
+				goto out;
+
+			*password = '\0';
+			password += strlen("password=");
+
+			err = account_add(user, password);
+		} else {
+			if (req->op == OP_DELETE) {
+				account_del(user);
+				err = 0;
+			} else
+				err = account_ctl(req->tid, req->aid,
+						  user, req->op == OP_BIND);
+		}
+		break;
+	case OP_SHOW:
+	retry:
+		err = account_show(mtask->buf, mtask->bsize);
+		if (err == mtask->bsize) {
+			char *p;
+			mtask->bsize <<= 1;
+			p = realloc(mtask->buf, mtask->bsize);
+			if (p) {
+				mtask->buf = p;
+				goto retry;
+			} else
+				err = TGTADM_NOMEM;
+		}
+		break;
+	default:
+		break;
+	}
+out:
+	if (req->op == OP_SHOW)
+		set_show_results(rsp, &err);
+	else {
+		rsp->err = err;
+		rsp->len = sizeof(*rsp);
+	}
+	return err;
+}
+
 static int tgt_mgmt(struct mgmt_task *mtask)
 {
 	struct tgtadm_req *req = &mtask->req;
@@ -215,16 +277,7 @@
 		err = device_mgmt(lld_no, req, mtask->buf, rsp, &len);
 		break;
 	case MODE_ACCOUNT:
-		if (tgt_drivers[lld_no]->account)
-			err = tgt_drivers[lld_no]->account(req->op, req->tid, req->aid,
-							   mtask->buf, mtask->buf, len);
-		if (req->op == OP_SHOW) {
-			set_show_results(rsp, &err);
-			err = 0;
-		} else {
-			rsp->err = err;
-			rsp->len = sizeof(*rsp);
-		}
+		err = account_mgmt(lld_no, mtask);
 		break;
 	default:
 		if (req->op == OP_SHOW && tgt_drivers[lld_no]->show) {

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/target.c	2006-12-30 04:23:18 UTC (rev 730)
@@ -630,6 +630,202 @@
 	}
 }
 
+struct account_entry {
+	int aid;
+	char *user;
+	char *password;
+	struct list_head ac_list;
+};
+
+static LIST_HEAD(accounts_list);
+
+static struct account_entry *__account_lookup_id(int aid)
+{
+	struct account_entry *ac;
+
+	list_for_each_entry(ac, &accounts_list, ac_list)
+		if (ac->aid == aid)
+			return ac;
+	return NULL;
+}
+
+static struct account_entry *__account_lookup_user(char *user)
+{
+	struct account_entry *ac;
+
+	list_for_each_entry(ac, &accounts_list, ac_list)
+		if (!strcmp(ac->user, user))
+			return ac;
+	return NULL;
+}
+
+int account_lookup(int tid, int type, char *user, int ulen,
+		   char *password, int plen)
+{
+	int i;
+	struct target *target;
+	struct account_entry *ac;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	if (type == ACCOUNT_TYPE_INCOMING) {
+		for (i = 0; target->account.nr_inaccount; i++) {
+			ac = __account_lookup_id(target->account.in_aids[i]);
+			if (ac)
+				goto found;
+		}
+	} else {
+		ac = __account_lookup_id(target->account.out_aid);
+		if (ac)
+			goto found;
+	}
+
+	return -ENOENT;
+found:
+	strncpy(user, ac->user, ulen);
+	strncpy(password, ac->password, plen);
+	return 0;
+}
+
+int account_add(char *user, char *password)
+{
+	int aid;
+	struct account_entry *ac;
+
+	ac = __account_lookup_user(user);
+	if (ac)
+		return TGTADM_USER_EXIST;
+
+	for (aid = 1; __account_lookup_id(aid) && aid < INT_MAX; aid++)
+		;
+	if (aid == INT_MAX)
+		return TGTADM_TOO_MANY_USER;
+
+	ac = zalloc(sizeof(*ac));
+	if (!ac)
+		return TGTADM_NOMEM;
+
+	ac->aid = aid;
+	ac->user = strdup(user);
+	if (!ac->user)
+		goto free_account;
+
+	ac->password = strdup(password);
+	if (!ac->password)
+		goto free_username;
+
+	list_add(&ac->ac_list, &accounts_list);
+	return 0;
+free_username:
+	free(ac->user);
+free_account:
+	free(ac);
+	return TGTADM_NOMEM;
+}
+
+static int __inaccount_bind(struct target *target, int aid)
+{
+	int i;
+
+	/* first, check whether we already have this account. */
+	for (i = 0; i < target->account.max_inaccount; i++)
+		if (target->account.in_aids[i] == aid)
+			return TGTADM_USER_EXIST;
+
+	if (target->account.nr_inaccount < target->account.max_inaccount) {
+		for (i = 0; i < target->account.max_inaccount; i++)
+			if (!target->account.in_aids[i])
+				break;
+		if (i == target->account.max_inaccount) {
+			eprintf("bug %d\n", target->account.max_inaccount);
+			return TGTADM_UNKNOWN_ERR;
+		}
+
+		target->account.in_aids[i] = aid;
+		target->account.nr_inaccount++;
+	} else {
+		int new_max = target->account.max_inaccount << 1;
+		int *buf;
+
+		buf = zalloc(new_max * sizeof(int));
+		if (!buf)
+			return TGTADM_NOMEM;
+
+		memcpy(buf, target->account.in_aids,
+		       target->account.max_inaccount * sizeof(int));
+		free(target->account.in_aids);
+		target->account.in_aids = buf;
+		target->account.in_aids[target->account.max_inaccount] = aid;
+		target->account.max_inaccount = new_max;
+	}
+
+	return 0;
+}
+
+int account_ctl(int tid, int type, char *user, int bind)
+{
+	struct target *target;
+	struct account_entry *ac;
+	int i, err = 0;
+
+	target = target_lookup(tid);
+	if (!target)
+		return TGTADM_NO_TARGET;
+
+	ac = __account_lookup_user(user);
+	if (!ac)
+		return TGTADM_NO_USER;
+
+	if (bind) {
+		if (type == ACCOUNT_TYPE_INCOMING)
+			err = __inaccount_bind(target, ac->aid);
+		else {
+			if (target->account.out_aid)
+				err = TGTADM_OUTACCOUNT_EXIST;
+			else
+				target->account.out_aid = ac->aid;
+		}
+	} else
+		if (type == ACCOUNT_TYPE_INCOMING) {
+			for (i = 0; i < target->account.max_inaccount; i++)
+				if (target->account.in_aids[i] == ac->aid) {
+					target->account.in_aids[i] = 0;
+					target->account.nr_inaccount--;
+				}
+
+			if (i == target->account.max_inaccount)
+				err = TGTADM_NO_USER;
+		} else
+			if (target->account.out_aid)
+				target->account.out_aid = 0;
+			else
+				err = TGTADM_NO_USER;
+
+	return err;
+}
+
+void account_del(char *user)
+{
+	struct account_entry *ac;
+	struct target *target;
+
+	ac = __account_lookup_user(user);
+	if (!ac)
+		return;
+
+	list_for_each_entry(target, &target_list, t_list) {
+		account_ctl(target->tid, ACCOUNT_TYPE_INCOMING, ac->user, 0);
+		account_ctl(target->tid, ACCOUNT_TYPE_OUTGOING, ac->user, 0);
+	}
+
+	list_del(&ac->ac_list);
+	free(ac->user);
+	free(ac->password);
+	free(ac);
+}
+
 int acl_add(int tid, char *address)
 {
 	char *str;
@@ -823,12 +1019,11 @@
 
 int tgt_target_show_all(char *buf, int rest)
 {
-	int total, max = rest;
+	int total = 0, max = rest;
 	struct target *target;
 	struct tgt_device *device;
 	struct acl_entry *acl;
 
-	total = 0;
 	list_for_each_entry(target, &target_list, t_list) {
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
@@ -840,6 +1035,24 @@
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
+		if (tgt_drivers[target->lid]->account) {
+			int i, aid;
+
+			shprintf(total, buf, rest, TAB1
+				 "Account information:\n");
+			for (i = 0; i < target->account.nr_inaccount; i++) {
+				aid = target->account.in_aids[i];
+				shprintf(total, buf, rest, TAB2 "%s\n",
+					 __account_lookup_id(aid)->user);
+			}
+			if (target->account.out_aid) {
+				aid = target->account.out_aid;
+				shprintf(total, buf, rest,
+					 TAB2 "%s (outgoing)\n",
+					 __account_lookup_id(aid)->user);
+			}
+		}
+
 		shprintf(total, buf, rest, TAB1 "ACL information:\n");
 		list_for_each_entry(acl, &target->acl_list, aclent_list)
 			shprintf(total, buf, rest, TAB2 "%s\n", acl->address);
@@ -876,6 +1089,8 @@
 	return target->name;
 }
 
+#define DEFAULT_NR_ACCOUNT 16
+
 int tgt_target_create(int lld, int tid, char *args)
 {
 	int i, t_type = TARGET_SBC, bs_type = LU_BS_FILE;
@@ -920,6 +1135,14 @@
 		return -ENOMEM;
 	}
 
+	target->account.in_aids = zalloc(DEFAULT_NR_ACCOUNT * sizeof(int));
+	if (!target->account.in_aids) {
+		free(target->name);
+		free(target);
+		return -ENOMEM;
+	}
+	target->account.max_inaccount = DEFAULT_NR_ACCOUNT;
+
 	target->tid = tid;
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
 		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
@@ -982,11 +1205,29 @@
 		free(acl);
 	}
 
+	free(target->account.in_aids);
+
 	free(target);
 
 	return 0;
 }
 
+int account_show(char *buf, int rest)
+{
+	int total = 0, max = rest;
+	struct account_entry *ac;
+
+	if (!list_empty(&accounts_list))
+		shprintf(total, buf, rest, "Account list:\n");
+
+	list_for_each_entry(ac, &accounts_list, ac_list)
+		shprintf(total, buf, rest, TAB1 "%s\n", ac->user);
+
+	return total;
+overflow:
+	return max;
+}
+
 __attribute__((constructor)) static void target_init(void)
 {
 	int i;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/target.h	2006-12-30 04:23:18 UTC (rev 730)
@@ -19,6 +19,18 @@
 	struct list_head aclent_list;
 };
 
+enum {
+	ACCOUNT_TYPE_INCOMING,
+	ACCOUNT_TYPE_OUTGOING,
+};
+
+struct tgt_account {
+	int out_aid;
+	int nr_inaccount;
+	int max_inaccount;
+	int *in_aids;
+};
+
 struct mgmt_req {
 	uint64_t mid;
 	int busy;
@@ -47,6 +59,8 @@
 	struct backedio_template *bdt;
 
 	struct list_head acl_list;
+
+	struct tgt_account account;
 };
 
 struct cmd {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/tgtadm.c	2006-12-30 04:23:18 UTC (rev 730)
@@ -74,7 +74,13 @@
 	"this logical unit already exists",  /* 10 */
 
 	"this access control rule already exists",
-	"unknown parameter",
+	"this account already exists",
+	"can't find the account",
+	"Too many accounts",
+	"invalid request", /* 15 */
+
+	"this target already has an outgoing account",
+	"unknown parameter", /* 15 */
 };
 
 static struct option const long_options[] =
@@ -86,7 +92,6 @@
 	{"sid", required_argument, NULL, 's'},
 	{"cid", required_argument, NULL, 'c'},
 	{"lun", required_argument, NULL, 'u'},
-	{"aid", required_argument, NULL, 'a'},
 	{"hostno", required_argument, NULL, 'i'},
 	{"bus", required_argument, NULL, 'B'},
 	{"name", required_argument, NULL, 'n'},
@@ -98,12 +103,13 @@
 	{"backing-store-type", required_argument, NULL, 'S'},
 	{"user", required_argument, NULL, 'y'},
 	{"password", required_argument, NULL, 'Y'},
+	{"outgoing", no_argument, NULL, 'O'},
 	{"debug", no_argument, NULL, 'd'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:B:T:I:p:b:S:n:v:y:Y:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:B:T:I:p:b:S:n:v:y:Y:dh";
 
 static void usage(int status)
 {
@@ -386,8 +392,8 @@
 		case 'u':
 			lun = strtoull(optarg, NULL, 10);
 			break;
-		case 'a':
-			aid = strtol(optarg, NULL, 10);
+		case 'O':
+			aid = 1;
 			break;
 		case 'i':
 			hostno = strtol(optarg, NULL, 10);
@@ -493,10 +499,12 @@
 		len += snprintf(params + len, rest - len,
 				"%sbacking-store-type=%d", len ? "," : "", bs_type);
 
-	if (password && user)
-		len += snprintf(params + len, rest - len, "user=%s,password=%s",
-				user, password);
+	if (user)
+		len += snprintf(params + len, rest - len, "user=%s", user);
 
+	if (password)
+		len += snprintf(params + len, rest - len, ",password=%s", password);
+
 	req->len = sizeof(*req) + len;
 
 	err = ipc_mgmt_req(req);

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/tgtadm.h	2006-12-30 04:23:18 UTC (rev 730)
@@ -18,6 +18,12 @@
 	TGTADM_LUN_EXIST,
 
 	TGTADM_ACL_EXIST,
+	TGTADM_USER_EXIST,
+	TGTADM_NO_USER,
+	TGTADM_TOO_MANY_USER,
+	TGTADM_INVALID_REQUEST,
+
+	TGTADM_OUTACCOUNT_EXIST,
 	TGTADM_UNKNOWN_PARAM,
 };
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-29 11:06:01 UTC (rev 729)
+++ trunk/usr/tgtd.h	2006-12-30 04:23:18 UTC (rev 730)
@@ -110,4 +110,11 @@
 extern void acl_del(int tid, char *address);
 extern char *acl_get(int tid, int idx);
 
+extern int account_lookup(int tid, int type, char *user, int ulen,
+			  char *password, int plen);
+extern int account_add(char *user, char *password);
+extern void account_del(char *user);
+extern int account_ctl(int tid, int type, char *user, int bind);
+extern int account_show(char *buf, int rest);
+
 #endif



From tomo at mail.berlios.de  Sat Dec 30 06:06:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 06:06:59 +0100
Subject: [Stgt-svn] r731 - in trunk/usr: . iscsi
Message-ID: <200612300506.kBU56xqY027003@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 06:06:59 +0100 (Sat, 30 Dec 2006)
New Revision: 731

Removed:
   trunk/usr/iscsi/account.c
   trunk/usr/iscsi/account.h
Modified:
   trunk/usr/Makefile
   trunk/usr/driver.h
   trunk/usr/iscsi/chap.c
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Convert iscsi to user the new account code.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/Makefile	2006-12-30 05:06:59 UTC (rev 731)
@@ -35,7 +35,7 @@
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
-	account.o chap.o transport.o iscsi_tcp.o)
+	chap.o transport.o iscsi_tcp.o)
 TGTD_OBJS += bd_aio.o
 LIBS += -lcrypto
 BD_AIO=1

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/driver.h	2006-12-30 05:06:59 UTC (rev 731)
@@ -11,7 +11,6 @@
 	int (*target_update) (int, char *);
 
 	int (*show) (int, int, uint64_t, uint32_t, uint64_t, char *, int);
-	int (*account) (uint32_t, int, uint32_t, char *, char *, int);
 
 	uint64_t (*scsi_get_lun)(uint8_t *);
 	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,

Deleted: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/account.c	2006-12-30 05:06:59 UTC (rev 731)
@@ -1,335 +0,0 @@
-/*
- * SCSI target account management functions
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-
-#include "iscsid.h"
-#include "tgtadm.h"
-#include "util.h"
-
-enum {
-	ACCOUNT_INVALID,
-	ACCOUNT_INCOMING,
-	ACCOUNT_OUTGOING,
-};
-
-struct iscsi_account {
-	struct list_head ac_list;
-
-	char *user;
-	char *password;
-
-	int type;
-	uint32_t id;
-
-	struct ac_head ach;
-};
-
-static LIST_HEAD(accounts_list);
-
-static struct iscsi_account *iscsi_lookup_account(uint32_t id)
-{
-	struct iscsi_account *pos;
-
-	list_for_each_entry(pos, &accounts_list, ac_list) {
-		if (pos->id == id)
-			return pos;
-	}
-	return NULL;
-}
-
-static int iscsi_create_account(uint32_t uid)
-{
-	struct iscsi_account *ac;
-
-	if (iscsi_lookup_account(uid)) {
-		eprintf("aid %u already exists\n", uid);
-		return EINVAL;
-	}
-
-	ac = zalloc(sizeof(*ac));
-	if (!ac)
-		return ENOMEM;
-
-	ac->id = uid;
-	ac->type = ACCOUNT_INVALID;
-	ac->ach.first = NULL;
-
-	list_add(&ac->ac_list, &accounts_list);
-
-	return 0;
-}
-
-static int iscsi_account_update(uint32_t uid, char *name)
-{
-	int err = EINVAL;
-	char *str;
-	struct iscsi_account *ac;
-
-	ac = iscsi_lookup_account(uid);
-	if (!ac)
-		return ENOENT;
-
-	str = strchr(name, '=');
-	if (!str)
-		return EINVAL;
-
-	*str++ = '\0';
-
-	if (!strcmp(name, "Type")) {
-		if (ac->type != ACCOUNT_INVALID)
-			return err;
-
-		if (!strcmp(str, "Incoming")) {
-			err = 0;
-			ac->type = ACCOUNT_INCOMING;
-		} else if (!strcmp(str, "Outgoing")) {
-			err = 0;
-			ac->type = ACCOUNT_OUTGOING;
-		}
-
-	} else if (!strcmp(name, "User")) {
-		if (ac->user)
-			free(ac->user);
-		ac->user = strdup(str);
-		if (ac->user)
-			err = 0;
-		else
-			err = ENOMEM;
-	} else if (!strcmp(name, "Password")) {
-		if (ac->password)
-			free(ac->password);
-		ac->password = strdup(str);
-		if (ac->password)
-			err = 0;
-		else
-			err = ENOMEM;
-	}
-
-	return err;
-}
-
-static void __account_bind(struct iscsi_account *ac, struct ac_node *acn)
-{
-	acn->head = &ac->ach;
-	acn->next = ac->ach.first;
-	ac->ach.first = acn;
-}
-
-static int iscsi_account_bind(int tid, uint32_t uid)
-{
-	int i, err;
-	struct iscsi_target* target;
-	struct iscsi_account *ac, *tmp;
-	struct ac_node *acn;
-
-	target = target_find_by_id(tid);
-	if (!target)
-		return ENOENT;
-
-	ac = iscsi_lookup_account(uid);
-	if (!ac)
-		return ENOENT;
-
-	if (!ac->user || !ac->password) {
-		eprintf("You must set user and password first\n");
-		return EINVAL;
-	}
-
-	err = EINVAL;
-	if (ac->type == ACCOUNT_INCOMING) {
-		acn = target->incoming;
-		for (i = 0; i < ARRAY_SIZE(target->incoming); i++, acn++) {
-			if (acn->head) {
-				tmp = container_of(acn->head, struct iscsi_account, ach);
-				if (tmp->id == ac->id) {
-					eprintf("This target already has this account\n");
-					break;
-				}
-			} else {
-				__account_bind(ac, acn);
-				err = 0;
-				break;
-			}
-		}
-		if (err)
-			eprintf("This target cannot have any more account\n");
-
-	} else if (ac->type == ACCOUNT_OUTGOING) {
-		if (target->outgoing.head)
-			eprintf("This target already has the outgoing account\n");
-		else {
-			__account_bind(ac, &target->outgoing);
-			err = 0;
-		}
-	} else
-		eprintf("You must set account type first\n");
-
-	return err;
-}
-
-#define print_account(buf, rest, ac)				\
-snprintf(buf, rest, "aid:%u Type:%s User:%s Password:%s\n",	\
-	(ac)->id, ac_type[(ac)->type], (ac)->user ? : "Empty",	\
-	(ac)->password ? : "Empty")
-
-static int iscsi_show_account(int tid, uint32_t uid, char *buf, int rest)
-{
-	int len, i, total = 0;
-	char *ac_type[] = {"Invalid", "Incoming", "Outgoing"};
-	struct iscsi_account *ac;
-	struct ac_node *acn;
-
-	if (tid == -1) {
-		list_for_each_entry(ac, &accounts_list, ac_list) {
-			len = print_account(buf, rest, ac);
-			buffer_check(buf, total, len, rest);
-		}
-	} else {
-		struct iscsi_target* target;
-
-		target = target_find_by_id(tid);
-		if (!target)
-			goto out;
-
-		acn = target->incoming;
-		for (i = 0; i < ARRAY_SIZE(target->incoming); i++, acn++) {
-			if (!acn->head)
-				continue;
-
-			ac = container_of(acn->head, struct iscsi_account, ach);
-			len = print_account(buf, rest, ac);
-			buffer_check(buf, total, len, rest);
-		}
-
-		acn = &target->outgoing;
-		if (!acn->head)
-			goto out;
-		ac = container_of(acn->head, struct iscsi_account, ach);
-		len = print_account(buf, rest, ac);
-		total += len;
-	}
-out:
-	return total;
-}
-
-int iscsi_mgmt_account(uint32_t op, int tid, uint32_t uid, char *param, char *buf, int len)
-{
-	int err = EINVAL;
-
-	switch (op) {
-	case OP_NEW:
-		err = iscsi_create_account(uid);
-		break;
-	case OP_DELETE:
-		eprintf("Not implemented yet\n");
-		break;
-	case OP_UPDATE:
-		err = iscsi_account_update(uid, param);
-		break;
-	case OP_BIND:
-		err = iscsi_account_bind(tid, uid);
-		break;
-	case OP_UNBIND:
-		eprintf("Not implemented yet\n");
-		break;
-	case OP_SHOW:
-		err = iscsi_show_account(tid, uid, buf, len);
-		break;
-	default:
-		break;
-	}
-
-	eprintf("%d\n", err);
-
-	return err;
-}
-
-int iscsi_account_available(int tid, int dir)
-{
-	int found = 0;
-	struct iscsi_target* target;
-	struct ac_node *acn;
-
-	target = target_find_by_id(tid);
-	if (!target)
-		return 0;
-
-	if (dir == AUTH_DIR_INCOMING) {
-		int i;
-
-		acn = target->incoming;
-		for (i = 0;  i < ARRAY_SIZE(target->incoming); i++, acn++) {
-			if (acn->head) {
-				found = 1;
-				break;
-			}
-		}
-
-	} else if (dir == AUTH_DIR_OUTGOING) {
-		acn = &target->outgoing;
-		if (acn->head)
-			found = 1;
-	}
-
-	return found;
-}
-
-int iscsi_account_lookup(int tid, int dir, char *user, char *pass)
-{
-	int err = ENOENT;
-	struct iscsi_target* target;
-	struct iscsi_account *ac;
-	struct ac_node *acn;
-
-	target = target_find_by_id(tid);
-	if (!target)
-		return err;
-
-	if (dir == AUTH_DIR_INCOMING) {
-		int i;
-
-		acn = target->incoming;
-		for (i = 0;  i < ARRAY_SIZE(target->incoming); i++, acn++) {
-			if (acn->head) {
-				ac = container_of(acn->head, struct iscsi_account, ach);
-				if (!strcmp(ac->user, user)) {
-					strncpy(pass, ac->password, ISCSI_NAME_LEN);
-					err = 0;
-				}
-			}
-		}
-	} else if (dir == AUTH_DIR_OUTGOING) {
-		acn = &target->outgoing;
-		if (acn->head) {
-			ac = container_of(acn->head, struct iscsi_account, ach);
-			strncpy(user, ac->user, ISCSI_NAME_LEN);
-			strncpy(pass, ac->password, ISCSI_NAME_LEN);
-			err = 0;
-		}
-	} else
-		eprintf("Invalid direction\n");
-
-	return err;
-}

Deleted: trunk/usr/iscsi/account.h
===================================================================
--- trunk/usr/iscsi/account.h	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/account.h	2006-12-30 05:06:59 UTC (rev 731)
@@ -1,19 +0,0 @@
-#ifndef ACCOUNT_H
-#define ACCOUNT_H
-
-struct ac_node;
-
-struct ac_head {
-	struct ac_node *first;
-};
-
-struct ac_node {
-	struct ac_node *next;
-	struct ac_head *head;
-};
-
-extern int iscsi_account_lookup(int tid, int dir, char *user, char *pass);
-extern int iscsi_account_available(int tid, int dir);
-
-#endif
-

Modified: trunk/usr/iscsi/chap.c
===================================================================
--- trunk/usr/iscsi/chap.c	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/chap.c	2006-12-30 05:06:59 UTC (rev 731)
@@ -21,7 +21,7 @@
 #include <openssl/md5.h>
 
 #include "iscsid.h"
-#include "account.h"
+#include "tgtd.h"
 
 #define HEX_FORMAT    0x01
 #define BASE64_FORMAT 0x02
@@ -381,7 +381,7 @@
 
 	memset(pass, 0, sizeof(pass));
 
-	err = iscsi_account_available(conn->tid, AUTH_DIR_INCOMING);
+	err = account_available(conn->tid, AUTH_DIR_INCOMING);
 	if (!err) {
 		eprintf("No CHAP credentials configured\n");
 		retval = CHAP_TARGET_ERROR;
@@ -394,7 +394,7 @@
 	}
 
 	memset(pass, 0, sizeof(pass));
-	err = iscsi_account_lookup(conn->tid, AUTH_DIR_INCOMING, value, pass);
+	err = account_lookup(conn->tid, AUTH_DIR_INCOMING, value, pass, ISCSI_NAME_LEN);
 	if (err) {
 		eprintf("No valid user/pass combination for initiator %s "
 			    "found\n", conn->initiator);
@@ -491,7 +491,7 @@
 
 	memset(pass, 0, sizeof(pass));
 	memset(name, 0, sizeof(name));
-	err = iscsi_account_lookup(conn->tid, AUTH_DIR_OUTGOING, name, pass);
+	err = account_lookup(conn->tid, AUTH_DIR_OUTGOING, name, pass, ISCSI_NAME_LEN);
 	if (err) {
 		log_warning("CHAP target auth.: "
 			    "no outgoing credentials configured%s",

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/iscsi.h	2006-12-30 05:06:59 UTC (rev 731)
@@ -18,7 +18,6 @@
 	.target_destroy		= iscsi_target_destroy,
 	.target_update		= iscsi_target_update,
 	.show			= iscsi_target_show,
-	.account		= iscsi_mgmt_account,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
 	.default_bdt		= &aio_bdt,

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/iscsid.c	2006-12-30 05:06:59 UTC (rev 731)
@@ -21,7 +21,6 @@
 
 #include "iscsid.h"
 #include "tgtd.h"
-#include "account.h"
 #include "util.h"
 
 #define MAX_QUEUE_CMD	32
@@ -140,13 +139,13 @@
 					*nextValue++ = 0;
 
 				if (!strcmp(value, "None")) {
-					if (iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
+					if (account_available(conn->tid, AUTH_DIR_INCOMING))
 						continue;
 					conn->auth_method = AUTH_NONE;
 					text_key_add(conn, key, "None");
 					break;
 				} else if (!strcmp(value, "CHAP")) {
-					if (!iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
+					if (!account_available(conn->tid, AUTH_DIR_INCOMING))
 						continue;
 					conn->auth_method = AUTH_CHAP;
 					text_key_add(conn, key, "CHAP");
@@ -508,7 +507,7 @@
 			conn->state = STATE_LOGIN;
 
 			login_start(conn);
-			if (iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
+			if (account_available(conn->tid, AUTH_DIR_INCOMING))
 				goto auth_err;
 			if (rsp->status_class)
 				return;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/iscsi/iscsid.h	2006-12-30 05:06:59 UTC (rev 731)
@@ -15,7 +15,6 @@
 #include "transport.h"
 #include "list.h"
 #include "param.h"
-#include "account.h"
 #include "log.h"
 
 #include <scsi/iscsi_if.h>
@@ -218,10 +217,6 @@
 
 	int max_nr_sessions;
 	int nr_sessions;
-
-	/* TODO: support various account managements (like RADIUS) */
-	struct ac_node incoming[16];
-	struct ac_node outgoing;
 };
 
 enum task_flags {

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/mgmt.c	2006-12-30 05:06:59 UTC (rev 731)
@@ -209,7 +209,7 @@
 			if (!password)
 				goto out;
 
-			*password = '\0';
+			*password++ = '\0';
 			password += strlen("password=");
 
 			err = account_add(user, password);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/target.c	2006-12-30 05:06:59 UTC (rev 731)
@@ -659,13 +659,14 @@
 	return NULL;
 }
 
-int account_lookup(int tid, int type, char *user, int ulen,
-		   char *password, int plen)
+int account_lookup(int tid, int type, char *user, char *password, int plen)
 {
 	int i;
 	struct target *target;
 	struct account_entry *ac;
 
+	eprintf("%d %s\n", tid, user);
+
 	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
@@ -673,8 +674,11 @@
 	if (type == ACCOUNT_TYPE_INCOMING) {
 		for (i = 0; target->account.nr_inaccount; i++) {
 			ac = __account_lookup_id(target->account.in_aids[i]);
-			if (ac)
-				goto found;
+			if (ac) {
+				eprintf("%s %s\n", ac->user, user);
+				if (!strcmp(ac->user, user))
+					goto found;
+			}
 		}
 	} else {
 		ac = __account_lookup_id(target->account.out_aid);
@@ -684,7 +688,7 @@
 
 	return -ENOENT;
 found:
-	strncpy(user, ac->user, ulen);
+	eprintf("%s\n", ac->password);
 	strncpy(password, ac->password, plen);
 	return 0;
 }
@@ -826,6 +830,20 @@
 	free(ac);
 }
 
+int account_available(int tid, int dir)
+{
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return 0;
+
+	if (dir == ACCOUNT_TYPE_INCOMING)
+		return target->account.nr_inaccount;
+	else
+		return target->account.out_aid;
+}
+
 int acl_add(int tid, char *address)
 {
 	char *str;
@@ -1035,7 +1053,7 @@
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
-		if (tgt_drivers[target->lid]->account) {
+		if (1) {
 			int i, aid;
 
 			shprintf(total, buf, rest, TAB1

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-30 04:23:18 UTC (rev 730)
+++ trunk/usr/tgtd.h	2006-12-30 05:06:59 UTC (rev 731)
@@ -110,11 +110,11 @@
 extern void acl_del(int tid, char *address);
 extern char *acl_get(int tid, int idx);
 
-extern int account_lookup(int tid, int type, char *user, int ulen,
-			  char *password, int plen);
+extern int account_lookup(int tid, int type, char *user, char *password, int plen);
 extern int account_add(char *user, char *password);
 extern void account_del(char *user);
 extern int account_ctl(int tid, int type, char *user, int bind);
 extern int account_show(char *buf, int rest);
+extern int account_available(int tid, int dir);
 
 #endif



From tomo at mail.berlios.de  Sat Dec 30 06:31:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 06:31:57 +0100
Subject: [Stgt-svn] r732 - trunk/doc
Message-ID: <200612300531.kBU5VvSj001259@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 06:31:56 +0100 (Sat, 30 Dec 2006)
New Revision: 732

Removed:
   trunk/doc/README.iscsi-advance
Modified:
   trunk/doc/README.iscsi
Log:
Update README.iscsi and remove obsolete README.iscsi-advance


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-12-30 05:06:59 UTC (rev 731)
+++ trunk/doc/README.iscsi	2006-12-30 05:31:56 UTC (rev 732)
@@ -184,6 +184,65 @@
 MaxConnections=1
 
 
+Authentication
+-------------
+Let's create a new account:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode account --user fujita --password tomo
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account
+Account list:
+    fujita
+
+You can assign this account to any targets:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1
+ --user fujita
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    Account information:
+        fujita
+    ACL information:
+        ALL
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN:
+            Size: 1G
+            Backing store: /var/tmp/image
+            Backing store type: file
+
+
+You can set up an outgoing account. First, you need to create a new
+account like the previous example:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode account --user hoge --password deadbeaf
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account
+Account list:
+    hoge
+    fujita
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1 --user hoge --outgoing
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
+Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+    System information:
+        Driver: iscsi
+        Status: running
+    Account information:
+        fujita
+        hoge (outgoing)
+    ACL information:
+        ALL
+    LUN information:
+        LUN: 0
+            SCSI ID: deadbeaf1:0
+            SCSI SN:
+            Size: 1G
+            Backing store: /var/tmp/image
+            Backing store type: file
+
+
 Shutdown
 -------------
 host:~/tgt# killall -9 tgtd

Deleted: trunk/doc/README.iscsi-advance
===================================================================
--- trunk/doc/README.iscsi-advance	2006-12-30 05:06:59 UTC (rev 731)
+++ trunk/doc/README.iscsi-advance	2006-12-30 05:31:56 UTC (rev 732)
@@ -1,226 +0,0 @@
-Preface
--------------
-This document describes how to configure the iSCSI target driver with tgtadm.
-
-tgtadm is not so handly; you can need several commands to do one thing
-mainly because it must be generic to work for all the transport protocols.
-
-We plan to implement a frontend tool, iscsitgtadm, to wrap tgtadm and
-offer considerably more user friendly interface in the future.
-
-
-Starting the daemon
--------------
-Try the following commands:
-
-host:~/tgt$ su
-host:~/tgt# ./usr/tgtd
-
-
-Configuration
--------------
-Everyting is configured via the tgtadm management tool.
-
-The following example creates a target with id 1 (the iqn is
-iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz) and adds a
-logical unit (backed by /dev/hdc1) with lun 0.
-
-Let's create one target devce and add a logical unit to it:
-
-host:~/tgt$ su
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iqn --value iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --update logicalunit --tid 1 --lun 0 --name path --value /dev/hdc1
-
-
-You can get the current configuration:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi: state suspended
-        lun 0: path /dev/hdc1
-
-
-If you don't need no more configuration (iSCSI parameters, security,
-etc), you are ready to accept initiators. In this case, you can go to
-`accepting initiators` session.
-
-
-You can add lots of logical units:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 --params Path=/var/tmp/image
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi: state suspended
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
-
-
-You can get iSCSI parameters of the target:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
-iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-MaxRecvDataSegmentLength=8192
-MaxXmitDataSegmentLength=8192
-HeaderDigest=None
-DataDigest=None
-InitialR2T=Yes
-MaxOutstandingR2T=1
-ImmediateData=Yes
-FirstBurstLength=65536
-MaxBurstLength=262144
-DataPDUInOrder=Yes
-DataSequenceInOrder=Yes
-ErrorRecoveryLevel=0
-IFMarker=No
-OFMarker=No
-DefaultTime2Wait=2
-DefaultTime2Retain=20
-OFMarkInt=Reject
-IFMarkInt=Reject
-MaxConnections=1
-
-
-You can chage iSCSI parameters like the folloing (e.g. set
-MaxRecvDataSegmentLength to 16384):
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
-
-
-You can get iSCSI parameters again to see it change:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
-iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-MaxRecvDataSegmentLength=16384
-MaxXmitDataSegmentLength=8192
-HeaderDigest=None
-DataDigest=None
-InitialR2T=Yes
-MaxOutstandingR2T=1
-ImmediateData=Yes
-FirstBurstLength=65536
-MaxBurstLength=262144
-DataPDUInOrder=Yes
-DataSequenceInOrder=Yes
-ErrorRecoveryLevel=0
-IFMarker=No
-OFMarker=No
-DefaultTime2Wait=2
-DefaultTime2Retain=20
-OFMarkInt=Reject
-IFMarkInt=Reject
-MaxConnections=1
-
-
-After the target the target accepted some initiators, you can see them:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1
-sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel
-sid:281474980708864 initiator:iqn.1987-05.com.cisco:01.4438aca09387
-
-
-You can see the negotiated iSCSI parameters between the target and the
-initiator:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1 --sid  281474980708864
-MaxRecvDataSegmentLength=8192
-MaxXmitDataSegmentLength=1024
-HeaderDigest=None
-DataDigest=None
-InitialR2T=Yes
-MaxOutstandingR2T=1
-ImmediateData=Yes
-FirstBurstLength=65536
-MaxBurstLength=262144
-DataPDUInOrder=Yes
-DataSequenceInOrder=Yes
-ErrorRecoveryLevel=0
-IFMarker=No
-OFMarker=No
-DefaultTime2Wait=2
-DefaultTime2Retain=0
-OFMarkInt=Reject
-IFMarkInt=Reject
-MaxConnections=1
-
-
-You can see the initiator information:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode connection --op show --tid 1 --sid  281474980708864
-cid:0 ip:192.168.11.5
-
-
-Security
--------------
-Let's create a new account:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode account
-
-You need to set the user, passowrd, type of the account:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name User --value tomo
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Password --value hoge
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Type --value Incoming
-
-
-Just make sure what we have:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account
-aid:1 Type:Incoming User:tomo Password:hoge
-
-
-We have one account, however, this account does not be assigned to our target:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
-
-
-You can assign this account to your target:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1 --aid 1
-
-
-You can see the result:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
-aid:1 Type:Incoming User:tomo Password:hoge
-
-
-You can assign one account to lots of targets. Each target can have 16
-accounts. We don't support removing or unbinding accounts now.
-
-
-Accepting initiators
--------------
-Now this target is ready to accept initiators. Make sure what you have
-now once again:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi: state suspended
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
-
-
-If you are happy about it:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi: state running
-        lun 1: path /var/tmp/image
-        lun 0: path /dev/hdc1
-
-
-Now your target accepts initiators.
-
-
-Shutdown
--------------
-host:~/tgt# killall -9 tgtd
-
-
-We will support better methods later.
-
-
-Status
--------------
-It should work under normal circumstances (good initiator, no network
-problem, etc). However, don't play with important data.



From tomo at mail.berlios.de  Sat Dec 30 06:36:34 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 06:36:34 +0100
Subject: [Stgt-svn] r733 - in trunk/usr: . iscsi
Message-ID: <200612300536.kBU5aYCa014412@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 06:36:27 +0100 (Sat, 30 Dec 2006)
New Revision: 733

Modified:
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/target.c
Log:
Remove some eprintf.


Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2006-12-30 05:31:56 UTC (rev 732)
+++ trunk/usr/iscsi/iscsi_tcp.c	2006-12-30 05:36:27 UTC (rev 733)
@@ -47,7 +47,7 @@
 	struct iscsi_connection *conn;
 	int fd, err;
 
-	eprintf("%d\n", afd);
+	dprintf("%d\n", afd);
 
 	namesize = sizeof(from);
 	fd = accept(afd, (struct sockaddr *) &from, &namesize);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-30 05:31:56 UTC (rev 732)
+++ trunk/usr/target.c	2006-12-30 05:36:27 UTC (rev 733)
@@ -665,8 +665,6 @@
 	struct target *target;
 	struct account_entry *ac;
 
-	eprintf("%d %s\n", tid, user);
-
 	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
@@ -675,7 +673,6 @@
 		for (i = 0; target->account.nr_inaccount; i++) {
 			ac = __account_lookup_id(target->account.in_aids[i]);
 			if (ac) {
-				eprintf("%s %s\n", ac->user, user);
 				if (!strcmp(ac->user, user))
 					goto found;
 			}
@@ -688,7 +685,6 @@
 
 	return -ENOENT;
 found:
-	eprintf("%s\n", ac->password);
 	strncpy(password, ac->password, plen);
 	return 0;
 }
@@ -926,7 +922,7 @@
 		return -EINVAL;
 	}
 
-	eprintf("Succeed to bind the target %d to the scsi host %d\n",
+	dprintf("Succeed to bind the target %d to the scsi host %d\n",
 		tid, host_no);
 	hostt[host_no] = target;
 	return 0;



From tomo at mail.berlios.de  Sat Dec 30 06:55:20 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 06:55:20 +0100
Subject: [Stgt-svn] r734 - trunk/usr
Message-ID: <200612300555.kBU5tKb0010989@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 06:55:19 +0100 (Sat, 30 Dec 2006)
New Revision: 734

Modified:
   trunk/usr/scsi.c
Log:
Workaround for broken Windows initiators (from IET code).


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-12-30 05:36:27 UTC (rev 733)
+++ trunk/usr/scsi.c	2006-12-30 05:55:19 UTC (rev 734)
@@ -395,7 +395,7 @@
 	data64[0] = __cpu_to_be64(size - 1);
 	data[2] = __cpu_to_be32(1UL << BLK_SHIFT);
 
-	*len = 32;
+	*len = 12;
 
 	return SAM_STAT_GOOD;
 }



From tomo at mail.berlios.de  Sat Dec 30 08:13:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 08:13:33 +0100
Subject: [Stgt-svn] r735 - trunk/usr
Message-ID: <200612300713.kBU7DX5p014653@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 08:13:33 +0100 (Sat, 30 Dec 2006)
New Revision: 735

Modified:
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Add RESERVE/RELEASE code (not tested yet). This is based on
host_no. It's ok for drivers using virtual hosts (like iSCSI and
IBMVIO), but not for FC drivers (fix this later on).


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-12-30 05:55:19 UTC (rev 734)
+++ trunk/usr/scsi.c	2006-12-30 07:13:33 UTC (rev 735)
@@ -477,7 +477,7 @@
 	return fn(p);
 }
 
-int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu,
+int scsi_cmd_perform(int tid, int lid, int host_no, uint8_t *pdu,
 		     int *len, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
 		     struct tgt_device *dev, struct list_head *dev_list, int *async,
@@ -494,7 +494,7 @@
 		memset(data, 0, PAGE_SIZE);
 	}
 
-	if (!dev)
+	if (!dev) {
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:
@@ -511,7 +511,33 @@
 			result = SAM_STAT_CHECK_CONDITION;
 			goto out;
 		}
+	} else {
+		int reserved;
 
+		reserved = device_reserved(tid, dev->lun, host_no);
+		if (reserved) {
+			switch (scb[0]) {
+			case INQUIRY:
+			case RELEASE:
+			case RELEASE_10:
+			case REPORT_LUNS:
+			case REQUEST_SENSE:
+				/* these commands are always allowed. */
+				break;
+			default:
+			*offset = 0;
+			if (data) {
+				free(data);
+				data = NULL;
+			}
+
+			*len = 0;
+			result = SAM_STAT_RESERVATION_CONFLICT;
+			goto out;
+			}
+		}
+	}
+
 	switch (scb[0]) {
 	case INQUIRY:
 		result = inquiry(lid, dev, host_no, lun_buf, scb, data, len);
@@ -562,9 +588,19 @@
 		}
 		break;
 	case RESERVE:
+	case RESERVE_10:
+		result = device_reserve(tid, dev->lun, host_no);
+		if (result)
+			result = SAM_STAT_RESERVATION_CONFLICT;
+		*len = 0;
+		break;
 	case RELEASE:
-	case RESERVE_10:
 	case RELEASE_10:
+		result = device_release(tid, dev->lun, host_no, 0);
+		if (result)
+			result = SAM_STAT_RESERVATION_CONFLICT;
+		*len = 0;
+		break;
 	default:
 		eprintf("unknown command %x %u\n", scb[0], datalen);
 		*len = 0;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-30 05:55:19 UTC (rev 734)
+++ trunk/usr/target.c	2006-12-30 07:13:33 UTC (rev 735)
@@ -157,6 +157,24 @@
 	return 0;
 }
 
+static struct tgt_device *
+__device_lookup(int tid, uint64_t lun, struct target **t)
+{
+	struct target *target;
+	struct tgt_device *device;
+
+	target = target_lookup(tid);
+	if (!target)
+		return NULL;
+
+	device = device_lookup(target, lun);
+	if (!device)
+		return NULL;
+
+	*t = target;
+	return device;
+}
+
 int tgt_device_create(int tid, uint64_t lun, char *args)
 {
 	struct target *target;
@@ -203,24 +221,20 @@
 	device_hlist_insert(target, device);
 	device_list_insert(target, device);
 
-	eprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
+	dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
 	return 0;
 }
 
-int tgt_device_destroy(int tid, uint64_t dev_id)
+int tgt_device_destroy(int tid, uint64_t lun)
 {
 	struct target *target;
 	struct tgt_device *device;
 
-	dprintf("%u %" PRIu64 "\n", tid, dev_id);
+	dprintf("%u %" PRIu64 "\n", tid, lun);
 
-	target = target_lookup(tid);
-	if (!target)
-		return -ENOENT;
-
-	device = device_lookup(target, dev_id);
+	device = __device_lookup(tid, lun, &target);
 	if (!device) {
-		eprintf("device %" PRIu64 " not found\n", dev_id);
+		eprintf("device %" PRIu64 " not found\n", lun);
 		return -EINVAL;
 	}
 
@@ -236,6 +250,53 @@
 	return 0;
 }
 
+int device_reserve(int tid, uint64_t lun, uint64_t reserve_id)
+{
+	struct target *target;
+	struct tgt_device *device;
+
+	device = __device_lookup(tid, lun, &target);
+	if (!device)
+		return -EINVAL;
+
+	if (device->reserve_id && device->reserve_id != reserve_id) {
+		dprintf("already reserved %" PRIu64 " %" PRIu64 "\n",
+			device->reserve_id, reserve_id);
+		return -EBUSY;
+	}
+
+	device->reserve_id = reserve_id;
+	return 0;
+}
+
+int device_release(int tid, uint64_t lun, uint64_t reserve_id, int force)
+{
+	struct target *target;
+	struct tgt_device *device;
+
+	device = __device_lookup(tid, lun, &target);
+	if (!device)
+		return 0;
+
+	if (force || device->reserve_id == reserve_id) {
+		device->reserve_id = 0;
+		return 0;
+	}
+
+	return -EBUSY;
+}
+
+int device_reserved(int tid, uint64_t lun, uint64_t reserve_id)
+{
+	struct target *target;
+	struct tgt_device *device;
+
+	device = __device_lookup(tid, lun, &target);
+	if (!device || !device->reserve_id || device->reserve_id == reserve_id)
+		return 0;
+	return -EBUSY;
+}
+
 #define buffer_check(buf, total, len, rest)	\
 ({						\
 	buf += len;				\
@@ -377,7 +438,7 @@
 		enabled = cmd_enabled(q, cmd);
 
 	if (enabled) {
-		result = scsi_cmd_perform(target->lid,
+		result = scsi_cmd_perform(target->tid, target->lid,
 					  host_no, scb,
 					  &len, data_len,
 					  &uaddr, &rw, &mmapped, &offset,
@@ -435,7 +496,8 @@
 		if (enabled) {
 			list_del(&cmd->qlist);
 			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
-			result = scsi_cmd_perform(cmd->c_target->lid,
+			result = scsi_cmd_perform(cmd->c_target->tid,
+						  cmd->c_target->lid,
 						  cmd->hostno, cmd->scb,
 						  &len, cmd->len,
 						  (unsigned long *) &cmd->uaddr,
@@ -615,6 +677,8 @@
 		err = -EINVAL;
 		break;
 	case LOGICAL_UNIT_RESET:
+		device_release(target->tid, scsi_get_devid(target->lid, lun),
+			       host_no, 1);
 		count = abort_task_set(mreq, target, host_no, 0, lun, 0);
 		if (mreq->busy)
 			send = 0;
@@ -1188,7 +1252,7 @@
 
 	INIT_LIST_HEAD(&target->acl_list);
 
-	eprintf("Succeed to create a new target %d\n", tid);
+	dprintf("Succeed to create a new target %d\n", tid);
 
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-30 05:55:19 UTC (rev 734)
+++ trunk/usr/tgtd.h	2006-12-30 07:13:33 UTC (rev 735)
@@ -36,7 +36,7 @@
 
 	struct tgt_cmd_queue cmd_queue;
 
-	unsigned long bddata[0] __attribute__ ((aligned (sizeof(unsigned long))));
+	uint64_t reserve_id;
 };
 
 typedef int (bkio_submit_t) (struct tgt_device *dev, uint8_t *scb,
@@ -71,6 +71,9 @@
 extern int tgt_device_create(int tid, uint64_t lun, char *args);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
+extern int device_reserve(int tid, uint64_t lun, uint64_t reserve_id);
+extern int device_release(int tid, uint64_t lun, uint64_t reserve_id, int force);
+extern int device_reserved(int tid, uint64_t lun, uint64_t reserve_id);
 
 extern int tgt_target_create(int lld, int tid, char *targetname);
 extern int tgt_target_destroy(int tid);
@@ -94,7 +97,7 @@
 extern void target_cmd_io_done(void *key, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
-extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
+extern int scsi_cmd_perform(int tid, int lid, int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
 			    struct tgt_device *dev, struct list_head *dev_list,



From tomo at mail.berlios.de  Sat Dec 30 08:30:07 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 08:30:07 +0100
Subject: [Stgt-svn] r736 - trunk/usr
Message-ID: <200612300730.kBU7U73Q015757@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 08:30:07 +0100 (Sat, 30 Dec 2006)
New Revision: 736

Modified:
   trunk/usr/tgtadm.c
Log:
Fix typo.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 07:13:33 UTC (rev 735)
+++ trunk/usr/tgtadm.c	2006-12-30 07:30:07 UTC (rev 736)
@@ -80,7 +80,7 @@
 	"invalid request", /* 15 */
 
 	"this target already has an outgoing account",
-	"unknown parameter", /* 15 */
+	"unknown parameter",
 };
 
 static struct option const long_options[] =



From tomo at mail.berlios.de  Sat Dec 30 14:26:34 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 14:26:34 +0100
Subject: [Stgt-svn] r737 - in trunk: doc usr
Message-ID: <200612301326.kBUDQYuq024800@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 14:26:34 +0100 (Sat, 30 Dec 2006)
New Revision: 737

Modified:
   trunk/doc/README.iscsi
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
   trunk/usr/util.h
Log:
Cleanup (mainly tgtadm).


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/doc/README.iscsi	2006-12-30 13:26:34 UTC (rev 737)
@@ -195,8 +195,7 @@
 
 You can assign this account to any targets:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1
- --user fujita
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1 --user fujita
 host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode target
 Target 1: iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
     System information:

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/mgmt.c	2006-12-30 13:26:34 UTC (rev 737)
@@ -77,7 +77,8 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(lld_no, req->tid, mtask->buf);
+		err = tgt_target_create(lld_no, req->tid, mtask->buf,
+					req->target_type, req->bs_type);
 		if (!err && tgt_drivers[lld_no]->target_create)
 			tgt_drivers[lld_no]->target_create(req->tid, mtask->buf);
 		break;
@@ -218,7 +219,7 @@
 				account_del(user);
 				err = 0;
 			} else
-				err = account_ctl(req->tid, req->aid,
+				err = account_ctl(req->tid, req->ac_dir,
 						  user, req->op == OP_BIND);
 		}
 		break;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/target.c	2006-12-30 13:26:34 UTC (rev 737)
@@ -857,6 +857,7 @@
 				if (target->account.in_aids[i] == ac->aid) {
 					target->account.in_aids[i] = 0;
 					target->account.nr_inaccount--;
+					break;
 				}
 
 			if (i == target->account.max_inaccount)
@@ -1084,17 +1085,6 @@
 #define TAB2 TAB1 TAB1
 #define TAB3 TAB1 TAB1 TAB1
 
-#define shprintf(total, buf, rest, fmt, args...)			\
-do {									\
-	int len;							\
-	len = snprintf(buf, rest, fmt, ##args);				\
-	if (len > rest)							\
-		goto overflow;						\
-	buf += len;							\
-	total += len;							\
-	rest -= len;							\
-} while (0)
-
 int tgt_target_show_all(char *buf, int rest)
 {
 	int total = 0, max = rest;
@@ -1169,9 +1159,9 @@
 
 #define DEFAULT_NR_ACCOUNT 16
 
-int tgt_target_create(int lld, int tid, char *args)
+int tgt_target_create(int lld, int tid, char *args, int t_type, int bs_type)
 {
-	int i, t_type = TARGET_SBC, bs_type = LU_BS_FILE;
+	int i;
 	struct target *target, *pos;
 	char *p, *q, *targetname = NULL;
 
@@ -1185,10 +1175,6 @@
 
 			if (!strcmp("targetname", q))
 				targetname = str;
-			else if (!strcmp("target-type", q))
-				t_type = strtol(str, NULL, 10);
-			else if (!strcmp("backing-store-type", q))
-				bs_type = strtol(str, NULL, 10);
 			else
 				eprintf("Unknow option %s\n", q);
 		}

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/target.h	2006-12-30 13:26:34 UTC (rev 737)
@@ -19,11 +19,6 @@
 	struct list_head aclent_list;
 };
 
-enum {
-	ACCOUNT_TYPE_INCOMING,
-	ACCOUNT_TYPE_OUTGOING,
-};
-
 struct tgt_account {
 	int out_aid;
 	int nr_inaccount;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/tgtadm.c	2006-12-30 13:26:34 UTC (rev 737)
@@ -45,7 +45,7 @@
 #undef eprintf
 #define eprintf(fmt, args...)						\
 do {									\
-	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+	fprintf(stderr, "%s: " fmt, program_name, ##args);		\
 } while (0)
 
 #undef dprintf
@@ -83,33 +83,32 @@
 	"unknown parameter",
 };
 
-static struct option const long_options[] =
-{
-	{"lld", required_argument, NULL, 'l'},
+struct option const long_options[] = {
+	{"debug", no_argument, NULL, 'd'},
+	{"help", no_argument, NULL, 'h'},
+	{"lld", required_argument, NULL, 'L'},
 	{"op", required_argument, NULL, 'o'},
 	{"mode", required_argument, NULL, 'm'},
 	{"tid", required_argument, NULL, 't'},
 	{"sid", required_argument, NULL, 's'},
 	{"cid", required_argument, NULL, 'c'},
-	{"lun", required_argument, NULL, 'u'},
-	{"hostno", required_argument, NULL, 'i'},
-	{"bus", required_argument, NULL, 'B'},
+	{"lun", required_argument, NULL, 'l'},
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
+	{"backing-store", required_argument, NULL, 'b'},
 	{"targetname", required_argument, NULL, 'T'},
 	{"initiator-address", required_argument, NULL, 'I'},
-	{"target-type", required_argument, NULL, 'p'},
-	{"backing-store", required_argument, NULL, 'b'},
+	{"user", required_argument, NULL, 'u'},
+	{"password", required_argument, NULL, 'p'},
+
+	{"bus", required_argument, NULL, 'B'},
+	{"target-type", required_argument, NULL, 'Y'},
 	{"backing-store-type", required_argument, NULL, 'S'},
-	{"user", required_argument, NULL, 'y'},
-	{"password", required_argument, NULL, 'Y'},
 	{"outgoing", no_argument, NULL, 'O'},
-	{"debug", no_argument, NULL, 'd'},
-	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:B:T:I:p:b:S:n:v:y:Y:dh";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:";
 
 static void usage(int status)
 {
@@ -159,7 +158,7 @@
 \n\
 Report bugs to <stgt-devel at lists.berlios.de>.\n");
 	}
-	exit(status == 0 ? 0 : -1);
+	exit(status == 0 ? 0 : EINVAL);
 }
 
 static int ipc_mgmt_connect(int *fd)
@@ -170,7 +169,7 @@
 	*fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (*fd < 0) {
 		eprintf("can't create a socket, %m\n");
-		return -1;
+		return errno;
 	}
 
 	memset(&addr, 0, sizeof(addr));
@@ -180,8 +179,8 @@
 
 	err = connect(*fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
-		eprintf("can't connect to tgtd, %m\n");
-		return -1;
+		eprintf("can't connect to the tgt daemon, %m\n");
+		return errno;
 	}
 
 	return 0;
@@ -195,12 +194,12 @@
 	err = read(fd, &rsp, sizeof(rsp));
 	if (err < 0) {
 		eprintf("can't get the response, %m\n");
-		return -1;
+		return errno;
 	}
 
 	if (rsp.err != TGTADM_SUCCESS) {
-		fprintf(stderr, "%s: %s\n", program_name, tgtadm_emsg[rsp.err]);
-		return -1;
+		eprintf("%s\n", tgtadm_emsg[rsp.err]);
+		return EINVAL;
 	}
 
 	rest = rsp.len - sizeof(rsp);
@@ -213,8 +212,8 @@
 		len = min_t(int, sizeof(buf) - 1, rest);
 		err = read(fd, buf, len);
 		if (err <= 0) {
-			eprintf("can't get the full response, %m\n");
-			return -1;
+			eprintf("\ncan't get the full response, %m\n");
+			return errno;
 		}
 		fputs(buf, stdout);
 		rest -= len;
@@ -233,7 +232,8 @@
 
 	err = write(fd, (char *) req, req->len);
 	if (err < 0) {
-		eprintf("can't send to tgtd, %m\n");
+		eprintf("can't send the request to the tgt daemon, %m\n");
+		err = errno;
 		goto out;
 	}
 
@@ -279,6 +279,10 @@
 		free(namelist[i]);
 	free(namelist);
 
+	if (host == -1) {
+		eprintf("can't find bus: %s\n", bus);
+		exit(EINVAL);
+	}
 	return host;
 }
 
@@ -288,91 +292,98 @@
 		return LU_BS_FILE;
 	else if (!strcmp(str, "raw"))
 		return LU_BS_RAW;
-	else
-		return -1;
+	else {
+		eprintf("unknown backing store type: %s\n", str);
+		exit(EINVAL);
+	}
 }
 
 static int target_type(char *str)
 {
 	if (!strcmp(str, "disk"))
 		return TARGET_SBC;
-	else if (!strcmp(str, "tape"))
-		return TARGET_SSC;
-	else if (!strcmp(str, "cd"))
-		return TARGET_MMC;
-	else if (!strcmp(str, "osd"))
-		return TARGET_OSD;
-	else
-		return -1;
+	else if (!strcmp(str, "tape")) {
+		eprintf("type emulation isn't supported yet\n");
+		exit(EINVAL);
+	} else if (!strcmp(str, "cd")) {
+		eprintf("cdrom emulation isn't supported yet\n");
+		exit(EINVAL);
+	} else if (!strcmp(str, "osd")) {
+		eprintf("osd isn't supported yet\n");
+		exit(EINVAL);
+	} else {
+		eprintf("unknown target type: %s\n", str);
+		exit(EINVAL);
+	}
 }
 
 static int str_to_mode(char *str)
 {
-	int mode;
-
 	if (!strcmp("target", str) || !strcmp("tgt", str))
-		mode = MODE_TARGET;
+		return MODE_TARGET;
 	else if (!strcmp("logicalunit", str) || !strcmp("lu", str))
-		mode = MODE_DEVICE;
+		return MODE_DEVICE;
 	else if (!strcmp("session", str) || !strcmp("sess", str))
-		mode = MODE_SESSION;
+		return MODE_SESSION;
 	else if (!strcmp("connection", str) || !strcmp("conn", str))
-		mode = MODE_CONNECTION;
+		return MODE_CONNECTION;
 	else if (!strcmp("account", str))
-		mode = MODE_ACCOUNT;
-	else
-		mode = -1;
-
-	return mode;
+		return MODE_ACCOUNT;
+	else {
+		eprintf("unknown mode: %s\n", str);
+		exit(1);
+	}
 }
 
 static int str_to_op(char *str)
 {
-	int op;
-
 	if (!strcmp("new", str))
-		op = OP_NEW;
+		return OP_NEW;
 	else if (!strcmp("delete", str))
-		op = OP_DELETE;
+		return OP_DELETE;
 	else if (!strcmp("bind", str))
-		op = OP_BIND;
+		return OP_BIND;
 	else if (!strcmp("unbind", str))
-		op = OP_UNBIND;
+		return OP_UNBIND;
 	else if (!strcmp("show", str))
-		op = OP_SHOW;
+		return OP_SHOW;
 	else if (!strcmp("update", str))
-		op = OP_UPDATE;
-	else
-		op = -1;
-
-	return op;
+		return OP_UPDATE;
+	else {
+		eprintf("unknown operation: %s\n", str);
+		exit(1);
+	}
 }
 
 int main(int argc, char **argv)
 {
 	int ch, longindex;
-	int err = -EINVAL, op = -1, len = 0;
-	int tid = -1, rest = BUFSIZE;
-	int t_type = TARGET_SBC, bs_type = LU_BS_FILE;
-	uint32_t cid, hostno, aid;
+	int op, total, tid, rest, mode, t_type, bs_type, ac_dir;
+	uint32_t cid, hostno;
 	uint64_t sid, lun;
-	char *lldname;
-	struct tgtadm_req *req;
-	char buf[BUFSIZE + sizeof(*req)];
 	char *name, *value, *path, *targetname, *params, *address;
 	char *user, *password;
-	int mode = MODE_SYSTEM;
+	char buf[BUFSIZE + sizeof(struct tgtadm_req)];
+	struct tgtadm_req *req;
 
-	cid = hostno = aid = sid = lun = 0;
-	lldname = name = value = path = targetname = address = NULL;
+	op = tid = mode = -1;
+	total = cid = hostno = sid = lun = 0;
+	t_type = TARGET_SBC;
+	bs_type = LU_BS_FILE;
+	ac_dir = ACCOUNT_TYPE_INCOMING;
+	rest = BUFSIZE;
+	name = value = path = targetname = address = NULL;
 	user = password = NULL;
 
+	memset(buf, 0, sizeof(buf));
+	req = (struct tgtadm_req *) buf;
+
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
-		case 'l':
-			lldname = optarg;
+		case 'L':
+			strncpy(req->lld, optarg, sizeof(req->lld));
 			break;
 		case 'o':
 			op = str_to_op(optarg);
@@ -389,17 +400,17 @@
 		case 'c':
 			cid = strtoul(optarg, NULL, 10);
 			break;
-		case 'u':
+		case 'l':
 			lun = strtoull(optarg, NULL, 10);
 			break;
-		case 'O':
-			aid = 1;
+		case 'n':
+			name = optarg;
 			break;
-		case 'i':
-			hostno = strtol(optarg, NULL, 10);
+		case 'v':
+			value = optarg;
 			break;
-		case 'B':
-			hostno = bus_to_host(optarg);
+		case 'b':
+			path = optarg;
 			break;
 		case 'T':
 			targetname = optarg;
@@ -407,27 +418,24 @@
 		case 'I':
 			address = optarg;
 			break;
+		case 'u':
+			user = optarg;
+			break;
 		case 'p':
+			password = optarg;
+			break;
+		case 'B':
+			hostno = bus_to_host(optarg);
+			break;
+		case 'Y':
 			t_type = target_type(optarg);
 			break;
-		case 'b':
-			path = optarg;
-			break;
 		case 'S':
 			bs_type = backing_store_type(optarg);
 			break;
-		case 'n':
-			name = optarg;
+		case 'O':
+			ac_dir = ACCOUNT_TYPE_OUTGOING;
 			break;
-		case 'v':
-			value = optarg;
-			break;
-		case 'y':
-			user = optarg;
-			break;
-		case 'Y':
-			password = optarg;
-			break;
 		case 'd':
 			debug = 1;
 			break;
@@ -438,76 +446,114 @@
 			usage(1);
 		}
 	}
-	if (op < 0) {
-		eprintf("You must specify the operation type\n");
-		goto out;
-	}
 
 	if (optind < argc) {
-		fprintf(stderr, "unrecognized options: ");
+		eprintf("unrecognized options: ");
 		while (optind < argc)
-			fprintf(stderr, "%s", argv[optind++]);
-		fprintf(stderr, "\n");
+			eprintf("%s", argv[optind++]);
+		eprintf("\n");
 		usage(1);
 	}
 
+	if (op < 0) {
+		eprintf("specify the operation type\n");
+		exit(EINVAL);
+	}
+
 	if (mode < 0) {
-		fprintf(stderr, "unknown mode\n");
-		usage(1);
+		eprintf("specify the mode\n");
+		exit(EINVAL);
 	}
 
-	memset(buf, 0, sizeof(buf));
+	if (!*req->lld) {
+		eprintf("specify the low level driver name\n");
+		exit(EINVAL);
+	}
 
-	req = (struct tgtadm_req *) buf;
-	if (lldname)
-		strncpy(req->lld, lldname, sizeof(req->lld));
-	req->mode = mode;
-	req->op = op;
-	req->tid = tid;
-	req->sid = sid;
-	req->lun = lun;
-	req->aid = aid;
-	req->host_no = hostno;
+	if ((name || value) && op != OP_UPDATE) {
+		eprintf("only 'update' operation takes"
+			" 'name' and 'value' options\n");
+		exit(EINVAL);
+	}
 
-	params = buf + sizeof(*req);
+	if ((!name && value) || (name && !value)) {
+		eprintf("both 'name' and 'value' options must be set\n");
+		exit(EINVAL);
+	}
 
-	/* FIXME */
-	if ((name && value) || path || targetname || address) {
-		if (path) {
-			name = "path";
-			value = path;
-		}
+	if ((mode == MODE_TARGET && op == OP_NEW) && !targetname) {
+		eprintf("creating a new target needs the name\n");
+		exit(EINVAL);
+	}
 
-		if (targetname) {
-			name = "targetname";
-			value = targetname;
-		}
+	if ((mode == MODE_DEVICE && op == OP_NEW) && !path) {
+		eprintf("creating a new logical unit needs"
+			" the backing store path\n");
+		exit(EINVAL);
+	}
 
-		if (address) {
-			name = "initiator-address";
-			value = address;
+	if (mode == MODE_ACCOUNT) {
+		switch (op) {
+		case OP_NEW:
+			if (!user || !password) {
+				eprintf("creating a new account needs"
+					" user and password options\n");
+				exit(EINVAL);
+			}
+			break;
+		case OP_SHOW:
+			break;
+		case OP_DELETE:
+		case OP_BIND:
+		case OP_UNBIND:
+			if (!user) {
+				eprintf("delete/bind/unbind the account"
+					" needs user option\n");
+				exit(EINVAL);
+			}
+			break;
+		default:
+			eprintf("the update operation can't"
+				" handle accounts\n");
+			exit(EINVAL);
+			break;
 		}
-
-		len = snprintf(params, rest, "%s=%s", name, value);
 	}
 
-	if (t_type != TARGET_SBC)
-		len += snprintf(params + len, rest - len,
-				"%starget-type=%d", len ? "," : "", t_type);
+	req->op = op;
+	req->tid = tid;
+	req->sid = sid;
+	req->lun = lun;
+	req->mode = mode;
+	req->host_no = hostno;
+	req->target_type = t_type;
+	req->bs_type = bs_type;
+	req->ac_dir = ac_dir;
 
-	if (bs_type != LU_BS_FILE)
-		len += snprintf(params + len, rest - len,
-				"%sbacking-store-type=%d", len ? "," : "", bs_type);
+	params = buf + sizeof(*req);
 
+	if (name)
+		shprintf(total, params, rest, "%s=%s", name, value);
+	if (path)
+		shprintf(total, params, rest, "%spath=%s",
+			 rest == BUFSIZE ? "" : ",", path);
+	if (targetname)
+		shprintf(total, params, rest, "%stargetname=%s",
+			 rest == BUFSIZE ? "" : ",", targetname);
+	if (address)
+		shprintf(total, params, rest, "%sinitiator-address=%s",
+			 rest == BUFSIZE ? "" : ",", address);
 	if (user)
-		len += snprintf(params + len, rest - len, "user=%s", user);
-
+		shprintf(total, params, rest, "%suser=%s",
+			 rest == BUFSIZE ? "" : ",", user);
 	if (password)
-		len += snprintf(params + len, rest - len, ",password=%s", password);
+		shprintf(total, params, rest, "%spassword=%s",
+			 rest == BUFSIZE ? "" : ",", password);
 
-	req->len = sizeof(*req) + len;
+	req->len = sizeof(*req) + total;
 
-	err = ipc_mgmt_req(req);
-out:
-	return err;
+	return ipc_mgmt_req(req);
+overflow:
+	eprintf("BUFSIZE (%d bytes) isn't long enough\n", BUFSIZE);
+	return EINVAL;
 }

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/tgtadm.h	2006-12-30 13:26:34 UTC (rev 737)
@@ -59,18 +59,24 @@
 	LU_BS_RAW, /* pass through */
 };
 
+enum tgtadm_account_dir {
+	ACCOUNT_TYPE_INCOMING,
+	ACCOUNT_TYPE_OUTGOING,
+};
+
 struct tgtadm_req {
 	enum tgtadm_mode mode;
 	enum tgtadm_op op;
+	char lld[TGT_LLD_NAME_LEN];
 	uint32_t len;
-
 	int32_t tid;
 	uint64_t sid;
+	uint64_t lun;
 	uint32_t cid;
-	uint32_t aid;
-	uint64_t lun;
-	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;
+	uint32_t target_type;
+	uint32_t bs_type;
+	uint32_t ac_dir;
 	uint32_t pack;
 };
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/tgtd.h	2006-12-30 13:26:34 UTC (rev 737)
@@ -75,7 +75,7 @@
 extern int device_release(int tid, uint64_t lun, uint64_t reserve_id, int force);
 extern int device_reserved(int tid, uint64_t lun, uint64_t reserve_id);
 
-extern int tgt_target_create(int lld, int tid, char *targetname);
+extern int tgt_target_create(int lld, int tid, char *args, int t_type, int bs_type);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);
 extern char *tgt_targetname(int tid);

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-12-30 07:30:07 UTC (rev 736)
+++ trunk/usr/util.h	2006-12-30 13:26:34 UTC (rev 737)
@@ -64,4 +64,15 @@
 	return seq3 - seq2 >= seq1 - seq2;
 }
 
+#define shprintf(total, buf, rest, fmt, args...)			\
+do {									\
+	int len;							\
+	len = snprintf(buf, rest, fmt, ##args);				\
+	if (len > rest)							\
+		goto overflow;						\
+	buf += len;							\
+	total += len;							\
+	rest -= len;							\
+} while (0)
+
 #endif



From tomo at mail.berlios.de  Sat Dec 30 14:39:42 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 14:39:42 +0100
Subject: [Stgt-svn] r738 - trunk/doc
Message-ID: <200612301339.kBUDdgiQ026095@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 14:39:41 +0100 (Sat, 30 Dec 2006)
New Revision: 738

Modified:
   trunk/doc/README.ibmvstgt
Log:
Fix README.ibmvstgt


Modified: trunk/doc/README.ibmvstgt
===================================================================
--- trunk/doc/README.ibmvstgt	2006-12-30 13:26:34 UTC (rev 737)
+++ trunk/doc/README.ibmvstgt	2006-12-30 13:39:41 UTC (rev 738)
@@ -25,13 +25,14 @@
 Everyting is configured via the tgtadm management tool.
 
 The following example creates a target with id 1, adds a logical unit
-(backed by /dev/sdb1) with lun 0, and then bind the target with #1 scsi host.
+(backed by /dev/sdb1) with lun 0, and then bind the target with
+/sys/devices/vio/30000003.
 
 You need to targetname to create a new target just as a reference.
 
 host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op new --tid 1 --targetname volume1
 host:~/tgt# ./usr/tgtadm --lld ibmvio --mode logicalunit --op new --tid 1 --lun 0 -b /dev/sdb1
-host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op bind --tid 1 --host 1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op bind --tid 1 --bus vio,30000003
 
 
 Please see /var/log/daemon.log (your Linux distributions may use the



From tomo at mail.berlios.de  Sat Dec 30 15:01:35 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 15:01:35 +0100
Subject: [Stgt-svn] r739 - trunk/usr
Message-ID: <200612301401.kBUE1Z3x029748@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 15:01:35 +0100 (Sat, 30 Dec 2006)
New Revision: 739

Modified:
   trunk/usr/tgtadm.c
Log:
Add more checks to tgtadm.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 13:39:41 UTC (rev 738)
+++ trunk/usr/tgtadm.c	2006-12-30 14:01:35 UTC (rev 739)
@@ -477,27 +477,50 @@
 	}
 
 	if ((!name && value) || (name && !value)) {
-		eprintf("both 'name' and 'value' options must be set\n");
+		eprintf("'name' and 'value' options are necessary\n");
 		exit(EINVAL);
 	}
 
-	if ((mode == MODE_TARGET && op == OP_NEW) && !targetname) {
-		eprintf("creating a new target needs the name\n");
-		exit(EINVAL);
+	if (mode == MODE_TARGET) {
+		switch (op) {
+		case OP_NEW:
+		case OP_DELETE:
+		case OP_BIND:
+		case OP_UNBIND:
+		case OP_UPDATE:
+			if (op == OP_NEW && !targetname) {
+				eprintf("creating a new target needs the name\n");
+				exit(EINVAL);
+			}
+
+			if (tid < 0) {
+				eprintf("'tid' option is necessary\n");
+				exit(EINVAL);
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
-	if ((mode == MODE_DEVICE && op == OP_NEW) && !path) {
-		eprintf("creating a new logical unit needs"
-			" the backing store path\n");
-		exit(EINVAL);
+	if (mode == MODE_DEVICE) {
+		switch (op) {
+		case OP_NEW:
+			if (!path) {
+				eprintf("the backing store path is necessary\n");
+				exit(EINVAL);
+			}
+			break;
+		default:
+			break;
+		}
 	}
 
 	if (mode == MODE_ACCOUNT) {
 		switch (op) {
 		case OP_NEW:
 			if (!user || !password) {
-				eprintf("creating a new account needs"
-					" user and password options\n");
+				eprintf("'user' and 'password' options is necessary\n");
 				exit(EINVAL);
 			}
 			break;
@@ -507,10 +530,14 @@
 		case OP_BIND:
 		case OP_UNBIND:
 			if (!user) {
-				eprintf("delete/bind/unbind the account"
-					" needs user option\n");
+				eprintf("'user' option is necessary\n");
 				exit(EINVAL);
 			}
+
+			if ((op == OP_BIND || op == OP_UNBIND) && tid < 0) {
+				eprintf("'tid' option is necessary\n");
+				exit(EINVAL);
+			}
 			break;
 		default:
 			eprintf("the update operation can't"



From tomo at mail.berlios.de  Sat Dec 30 15:05:15 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 15:05:15 +0100
Subject: [Stgt-svn] r740 - trunk/usr
Message-ID: <200612301405.kBUE5F59030043@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 15:05:12 +0100 (Sat, 30 Dec 2006)
New Revision: 740

Modified:
   trunk/usr/tgtadm.c
Log:
Fix dprintf in tgtadm


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 14:01:35 UTC (rev 739)
+++ trunk/usr/tgtadm.c	2006-12-30 14:05:12 UTC (rev 740)
@@ -52,7 +52,8 @@
 #define dprintf(fmt, args...)						\
 do {									\
 	if (debug)							\
-		eprintf(fmt, args);					\
+		fprintf(stderr, "%s %d: " fmt,				\
+			__FUNCTION__, __LINE__, ##args);		\
 } while (0)
 
 #define BUFSIZE 4096



From tomo at mail.berlios.de  Sat Dec 30 15:06:29 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 15:06:29 +0100
Subject: [Stgt-svn] r741 - trunk/usr
Message-ID: <200612301406.kBUE6T29030094@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 15:06:29 +0100 (Sat, 30 Dec 2006)
New Revision: 741

Modified:
   trunk/usr/tgtadm.c
Log:
Remove tgtd.h and driver.h


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 14:05:12 UTC (rev 740)
+++ trunk/usr/tgtadm.c	2006-12-30 14:06:29 UTC (rev 741)
@@ -38,9 +38,7 @@
 
 #include "util.h"
 #include "list.h"
-#include "tgtd.h"
 #include "tgtadm.h"
-#include "driver.h"
 
 #undef eprintf
 #define eprintf(fmt, args...)						\



From tomo at mail.berlios.de  Sat Dec 30 15:36:06 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 15:36:06 +0100
Subject: [Stgt-svn] r742 - trunk/usr
Message-ID: <200612301436.kBUEa6Mc000227@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 15:36:05 +0100 (Sat, 30 Dec 2006)
New Revision: 742

Modified:
   trunk/usr/tgtadm.c
Log:
Update tgtadm's help message.


Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 14:06:29 UTC (rev 741)
+++ trunk/usr/tgtadm.c	2006-12-30 14:36:05 UTC (rev 742)
@@ -118,41 +118,43 @@
 		printf("\
 Linux SCSI Target Framework Administration Utility.\n\
 \n\
-  --op create --tid=[id] --params [name]\n\
-                        add a new target with [id]. [id] must not be zero.\n\
-  --op delete --tid=[id]\n\
-                        delete specific target with [id]. The target must\n\
-                        have no active sessions.\n\
-  --op new --tid=[id] --lun=[lun] --params Path=[path]\n\
-                        add a new logical unit with [lun] to specific\n\
+  --lld [driver] --mode target --op new --tid=[id] --targetname [name]\n\
+                        add a new target with [id] and [name]. [id] must not be zero.\n\
+  --lld [driver] --mode target --op delete --tid=[id]\n\
+                        delete the specific target with [id]. The target must\n\
+                        have no activity.\n\
+  --lld [driver] --mode target --op show\n\
+                        show all the targets.\n\
+  --lld [driver] --mode target --op show --tid=[id]\n\
+                        show the specific target's parameters.\n\
+  --lld [driver] --mode target --op update --tid=[id] --name=[param] --value=[value]\n\
+                        change the target parameters of the specific\n\
+                        target with [id].\n\
+  --lld [driver] --mode target --op bind --tid=[id] --initiator-address=[src]\n\
+                        enable the target to accept the specific initiators.\n\
+  --lld [driver] --mode target --op unbind --tid=[id] --initiator-address=[src]\n\
+                        disable the specific permitted initiators.\n\
+  --lld [driver] --mode logicalunit --op new --tid=[id] --lun=[lun] --backing-store=[path]\n\
+                        add a new logical unit with [lun] to the specific\n\
                         target with [id]. The logical unit is offered\n\
                         to the initiators. [path] must be block device files\n\
                         (including LVM and RAID devices) or regular files.\n\
-  --op delete --tid=[id] --lun=[lun]\n\
-                        delete specific logical unit with [lun] that\n\
+  --lld [driver] --mode logicalunit --op delete --tid=[id] --lun=[lun]\n\
+                        delete the specific logical unit with [lun] that\n\
                         the target with [id] has.\n\
-  --op delete --tid=[id] --sid=[sid] --cid=[cid]\n\
-                        delete specific connection with [cid] in a session\n\
-                        with [sid] that the target with [id] has.\n\
-                        If the session has no connections after\n\
-                        the operation, the session will be deleted\n\
-                        automatically.\n\
-  --op delete           stop all activity.\n\
-  --op update --tid=[id] --params=key1=value1,key2=value2,...\n\
-                        change the target parameters of specific\n\
-                        target with [id].\n\
-  --op new --tid=[id] --user --params=[user]=[name],Password=[pass]\n\
-                        add a new account with [pass] for specific target.\n\
+  --lld [driver] --mode account --op new --user=[name] --password=[pass]\n\
+                        add a new account with [name] and [pass].\n\
+  --lld [driver] --mode account --op delete --user=[name]\n\
+                        delete the specific account having [name].\n\
+  --lld [driver] --mode account --op bind --tid=[id] --user=[name] [--outgoing]\n\
+                        add the specific account having [name] to\n\
+                        the specific target with [id].\n\
                         [user] could be [IncomingUser] or [OutgoingUser].\n\
-                        If you don't specify a target (omit --tid option),\n\
-                        you add a new account for discovery sessions.\n\
-  --op delete --tid=[id] --user --params=[user]=[name]\n\
-                        delete specific account having [name] of specific\n\
-                        target. [user] could be [IncomingUser] or\n\
-                        [OutgoingUser].\n\
-                        If you don't specify a target (omit --tid option),\n\
-                        you delete the account for discovery sessions.\n\
-  --version             display version and exit\n\
+                        If you use --outgoing option, the account will\n\
+                        be added as an outgoing account.\n\
+  --lld [driver] --mode account --op unbind --tid=[id] --user=[name]\n\
+                        delete the specific account having [name] from specific\n\
+                        target.\n\
   --help                display this help and exit\n\
 \n\
 Report bugs to <stgt-devel at lists.berlios.de>.\n");



From tomo at mail.berlios.de  Sat Dec 30 16:46:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 30 Dec 2006 16:46:57 +0100
Subject: [Stgt-svn] r743 - trunk/usr
Message-ID: <200612301546.kBUFkvJb006633@sheep.berlios.de>

Author: tomo
Date: 2006-12-30 16:46:57 +0100 (Sat, 30 Dec 2006)
New Revision: 743

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Fix mgmt return values.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-12-30 14:36:05 UTC (rev 742)
+++ trunk/usr/mgmt.c	2006-12-30 15:46:57 UTC (rev 743)
@@ -73,7 +73,7 @@
 {
 	struct tgtadm_req *req = &mtask->req;
 	struct tgtadm_rsp *rsp = &mtask->rsp;
-	int err = -EINVAL;
+	int err = TGTADM_INVALID_REQUEST;
 
 	switch (req->op) {
 	case OP_NEW:
@@ -166,7 +166,7 @@
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
 		       struct tgtadm_rsp *rsp, int *rlen)
 {
-	int err = -EINVAL;
+	int err = TGTADM_UNSUPPORTED_OPERATION;
 
 	switch (req->op) {
 	case OP_NEW:
@@ -192,7 +192,7 @@
 {
 	struct tgtadm_req *req = &mtask->req;
 	struct tgtadm_rsp *rsp = &mtask->rsp;
-	int err = TGTADM_INVALID_REQUEST;
+	int err = TGTADM_UNSUPPORTED_OPERATION;
 	char *user, *password;
 
 	switch (req->op) {
@@ -254,7 +254,7 @@
 {
 	struct tgtadm_req *req = &mtask->req;
 	struct tgtadm_rsp *rsp = &mtask->rsp;
-	int lld_no, err = -EINVAL, len = mtask->bsize;
+	int lld_no, err = TGTADM_INVALID_REQUEST, len = mtask->bsize;
 
 	lld_no = get_driver_index(req->lld);
 	if (lld_no < 0) {

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-12-30 14:36:05 UTC (rev 742)
+++ trunk/usr/target.c	2006-12-30 15:46:57 UTC (rev 743)
@@ -141,12 +141,12 @@
 
 	path = strdup(path);
 	if (!path)
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	err = target->bdt->bd_open(device, path, &dev_fd, &size);
 	if (err) {
 		free(path);
-		return -EINVAL;
+		return TGTADM_INVALID_REQUEST;
 	}
 
 	device->fd = dev_fd;
@@ -186,30 +186,30 @@
 
 	target = target_lookup(tid);
 	if (!target)
-		return -ENOENT;
+		return TGTADM_NO_TARGET;
 
 	device = device_lookup(target, lun);
 	if (device) {
 		eprintf("device %" PRIu64 " already exists\n", lun);
-		return -EINVAL;
+		return TGTADM_LUN_EXIST;
 	}
 
 	if (!*args)
-		return -EINVAL;
+		return TGTADM_INVALID_REQUEST;
 
 	p = strchr(args, '=');
 	if (!p)
-		return -EINVAL;
+		return TGTADM_INVALID_REQUEST;
 	p++;
 
 	device = zalloc(sizeof(*device) + target->bdt->bd_datasize);
 	if (!device)
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	err = tgt_device_path_update(target, device, p);
 	if (err) {
 		free(device);
-		return -EINVAL;
+		return err;
 	}
 
 	device->lun = lun;
@@ -235,11 +235,11 @@
 	device = __device_lookup(tid, lun, &target);
 	if (!device) {
 		eprintf("device %" PRIu64 " not found\n", lun);
-		return -EINVAL;
+		return TGTADM_NO_LUN;
 	}
 
 	if (!list_empty(&device->cmd_queue.queue))
-		return -EBUSY;
+		return TGTADM_LUN_ACTIVE;
 
 	free(device->path);
 	device_hlist_remove(device);
@@ -313,12 +313,12 @@
 
 	target = target_lookup(tid);
 	if (!target)
-		return -ENOENT;
+		return TGTADM_NO_TARGET;
 
 	device = device_lookup(target, dev_id);
 	if (!device) {
 		eprintf("device %" PRIu64 " not found\n", dev_id);
-		return -EINVAL;
+		return TGTADM_NO_LUN;
 	}
 
 	if (!strcmp(name, "scsi_id="))
@@ -326,7 +326,7 @@
 	else if (!strcmp(name, "scsi_sn="))
 		memcpy(device->scsi_sn, name + 8, sizeof(device->scsi_sn) - 1);
 	else
-		err = -EINVAL;
+		err = TGTADM_INVALID_REQUEST;
 
 	return err;
 }
@@ -979,12 +979,12 @@
 	target = target_lookup(tid);
 	if (!target) {
 		eprintf("target is not found %d\n", tid);
-		return -EINVAL;
+		return TGTADM_NO_TARGET;
 	}
 
 	if (hostt[host_no]) {
 		eprintf("host is already binded %d %d\n", tid, host_no);
-		return -EINVAL;
+		return TGTADM_INVALID_REQUEST;
 	}
 
 	dprintf("Succeed to bind the target %d to the scsi host %d\n",
@@ -1049,12 +1049,12 @@
 
 int tgt_set_target_state(int tid, char *str)
 {
-	int i, err = -EINVAL;
+	int i, err = TGTADM_INVALID_REQUEST;
 	struct target *target;
 
 	target = target_lookup(tid);
 	if (!target)
-		return -ENOENT;
+		return TGTADM_NO_TARGET;
 
 	for (i = 0; i < ARRAY_SIZE(target_state); i++) {
 		if (!strcmp(target_state[i].name, str)) {
@@ -1181,29 +1181,29 @@
 	};
 
 	if (!targetname)
-		return -EINVAL;
+		return TGTADM_INVALID_REQUEST;
 
 	target = target_lookup(tid);
 	if (target) {
 		eprintf("Target id %d already exists\n", tid);
-		return -EINVAL;
+		return TGTADM_TARGET_EXIST;
 	}
 
 	target = zalloc(sizeof(*target));
 	if (!target)
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 	}
 
 	target->account.in_aids = zalloc(DEFAULT_NR_ACCOUNT * sizeof(int));
 	if (!target->account.in_aids) {
 		free(target->name);
 		free(target);
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 	}
 	target->account.max_inaccount = DEFAULT_NR_ACCOUNT;
 
@@ -1250,15 +1250,15 @@
 
 	target = target_lookup(tid);
 	if (!target)
-		return -ENOENT;
+		return TGTADM_NO_TARGET;
 
 	if (!list_empty(&target->device_list)) {
 		eprintf("target %d still has devices\n", tid);
-		return -EBUSY;
+		return TGTADM_TARGET_ACTIVE;
 	}
 
 	if (!list_empty(&target->cmd_queue.queue))
-		return -EBUSY;
+		return TGTADM_TARGET_ACTIVE;
 
 	target_hlist_remove(target);
 	list_del(&target->t_list);

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-12-30 14:36:05 UTC (rev 742)
+++ trunk/usr/tgtadm.c	2006-12-30 15:46:57 UTC (rev 743)
@@ -70,7 +70,7 @@
 	"can't find the session",
 	"can't find the connection",
 	"this target already exists",
-	"this logical unit already exists",  /* 10 */
+	"this logical unit number already exists",  /* 10 */
 
 	"this access control rule already exists",
 	"this account already exists",
@@ -79,7 +79,10 @@
 	"invalid request", /* 15 */
 
 	"this target already has an outgoing account",
-	"unknown parameter",
+	"this target unit is still active",
+	"this logical unit is still active",
+	"this operation isn't supported",
+	"unknown parameter", /* 20 */
 };
 
 struct option const long_options[] = {

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-12-30 14:36:05 UTC (rev 742)
+++ trunk/usr/tgtadm.h	2006-12-30 15:46:57 UTC (rev 743)
@@ -24,6 +24,9 @@
 	TGTADM_INVALID_REQUEST,
 
 	TGTADM_OUTACCOUNT_EXIST,
+	TGTADM_TARGET_ACTIVE,
+	TGTADM_LUN_ACTIVE,
+	TGTADM_UNSUPPORTED_OPERATION,
 	TGTADM_UNKNOWN_PARAM,
 };
 



