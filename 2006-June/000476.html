<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r489 - branches/use-scsi-ml/patchset
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r489%20-%20branches/use-scsi-ml/patchset&In-Reply-To=%3C200606221152.k5MBqqD1004323%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000475.html">
   <LINK REL="Next"  HREF="000477.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r489 - branches/use-scsi-ml/patchset</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r489%20-%20branches/use-scsi-ml/patchset&In-Reply-To=%3C200606221152.k5MBqqD1004323%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r489 - branches/use-scsi-ml/patchset">tomo at berlios.de
       </A><BR>
    <I>Thu Jun 22 13:52:52 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000475.html">[Stgt-svn] r488 - branches/use-scsi-ml/usr
</A></li>
        <LI>Next message: <A HREF="000477.html">[Stgt-svn] r490 - / branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#476">[ date ]</a>
              <a href="thread.html#476">[ thread ]</a>
              <a href="subject.html#476">[ subject ]</a>
              <a href="author.html#476">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-06-22 13:52:47 +0200 (Thu, 22 Jun 2006)
New Revision: 489

Removed:
   branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt
   branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt
   branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff
Log:
Remove old patches.

Deleted: branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,593 +0,0 @@
-Subject: [PATCH 1/2] scsi tgt: add libsrp
-
-There's a fair chance that we'll get several SRP target drivers (for
-IBM iSeries and OpenIB at least). They will have lots of duplicated
-code. libsrp tries to provide helper functions for them to avoid the
-duplicated code.
-
-The next step would be to add initiator support to merge the two SRP
-initiator drivers in mainline.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/Kconfig  |    9 +
- drivers/scsi/Makefile |    1 
- drivers/scsi/libsrp.c |  448 +++++++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/libsrp.h |   75 ++++++++
- 4 files changed, 533 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/libsrp.c
- create mode 100644 include/scsi/libsrp.h
-
-04bec8adfeeee4a0b0a04627d5f8b7d6261f0c4a
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 5b5eeb4..cf3558b 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -1834,6 +1834,15 @@ config ZFCP
-           called zfcp. If you want to compile it as a module, say M here
-           and read &lt;file:Documentation/modules.txt&gt;.
- 
-+config SCSI_SRP
-+	tristate &quot;SCSI RDMA Protocol helper library&quot;
-+	depends on SCSI
-+	help
-+	  If you wish to use SRP target drivers, say Y.
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called libsrp.
-+
- endmenu
- 
- source &quot;drivers/scsi/pcmcia/Kconfig&quot;
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index 3d81b8d..0779523 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -123,6 +123,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
- obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
-+obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
-diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
-new file mode 100644
-index 0000000..2a2cfd6
---- /dev/null
-+++ b/drivers/scsi/libsrp.c
-@@ -0,0 +1,448 @@
-+/*
-+ * SCSI RDAM Protocol lib functions
-+ *
-+ * Copyright (C) 2006 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include &lt;linux/err.h&gt;
-+#include &lt;linux/kfifo.h&gt;
-+#include &lt;linux/scatterlist.h&gt;
-+#include &lt;linux/dma-mapping.h&gt;
-+#include &lt;scsi/scsi.h&gt;
-+#include &lt;scsi/scsi_cmnd.h&gt;
-+#include &lt;scsi/scsi_tcq.h&gt;
-+#include &lt;scsi/scsi_tgt.h&gt;
-+#include &lt;scsi/srp.h&gt;
-+#include &lt;scsi/libsrp.h&gt;
-+
-+enum srp_task_attributes {
-+	SRP_SIMPLE_TASK = 0,
-+	SRP_HEAD_TASK = 1,
-+	SRP_ORDERED_TASK = 2,
-+	SRP_ACA_TASK = 4
-+};
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
-+			     struct srp_buf **ring)
-+{
-+	int i;
-+	struct iu_entry *iue;
-+
-+	q-&gt;pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
-+	if (!q-&gt;pool)
-+		return -ENOMEM;
-+	q-&gt;items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
-+	if (!q-&gt;items)
-+		goto free_pool;
-+
-+	spin_lock_init(&amp;q-&gt;lock);
-+	q-&gt;queue = kfifo_init((void *) q-&gt;pool, max * sizeof(void *),
-+			      GFP_KERNEL, &amp;q-&gt;lock);
-+	if (IS_ERR(q-&gt;queue))
-+		goto free_item;
-+
-+	for (i = 0, iue = q-&gt;items; i &lt; max; i++) {
-+		__kfifo_put(q-&gt;queue, (void *) &amp;iue, sizeof(void *));
-+		iue-&gt;sbuf = ring[i];
-+		iue++;
-+	}
-+	return 0;
-+
-+free_item:
-+	kfree(q-&gt;items);
-+free_pool:
-+	kfree(q-&gt;pool);
-+	return -ENOMEM;
-+}
-+
-+static void srp_iu_pool_free(struct srp_queue *q)
-+{
-+	kfree(q-&gt;items);
-+	kfree(q-&gt;pool);
-+}
-+
-+static struct srp_buf ** srp_ring_alloc(struct device *dev,
-+					size_t max, size_t size)
-+{
-+	int i;
-+	struct srp_buf **ring;
-+
-+	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
-+	if (!ring)
-+		return NULL;
-+
-+	for (i = 0; i &lt; max; i++) {
-+		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
-+		if (!ring[i])
-+			goto out;
-+		ring[i]-&gt;buf = dma_alloc_coherent(dev, size, &amp;ring[i]-&gt;dma,
-+						  GFP_KERNEL);
-+		if (!ring[i]-&gt;buf)
-+			goto out;
-+	}
-+	return ring;
-+
-+out:
-+	for (i = 0; i &lt; max &amp;&amp; ring[i]; i++) {
-+		if (ring[i]-&gt;buf)
-+			dma_free_coherent(dev, size, ring[i]-&gt;buf, ring[i]-&gt;dma);
-+		kfree(ring[i]);
-+	}
-+	kfree(ring);
-+
-+	return NULL;
-+}
-+
-+static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
-+			  size_t size)
-+{
-+	int i;
-+
-+	for (i = 0; i &lt; max; i++) {
-+		dma_free_coherent(dev, size, ring[i]-&gt;buf, ring[i]-&gt;dma);
-+		kfree(ring[i]);
-+	}
-+}
-+
-+int srp_target_alloc(struct srp_target *target, struct device *dev,
-+		     size_t nr, size_t iu_size)
-+{
-+	int err;
-+
-+	spin_lock_init(&amp;target-&gt;lock);
-+	INIT_LIST_HEAD(&amp;target-&gt;cmd_queue);
-+
-+	target-&gt;dev = dev;
-+	target-&gt;dev-&gt;driver_data = target;
-+
-+	target-&gt;srp_iu_size = iu_size;
-+	target-&gt;rx_ring_size = nr;
-+	target-&gt;rx_ring = srp_ring_alloc(target-&gt;dev, nr, iu_size);
-+	if (!target-&gt;rx_ring)
-+		return -ENOMEM;
-+	err = srp_iu_pool_alloc(&amp;target-&gt;iu_queue, nr, target-&gt;rx_ring);
-+	if (err)
-+		goto free_ring;
-+
-+	return 0;
-+
-+free_ring:
-+	srp_ring_free(target-&gt;dev, target-&gt;rx_ring, nr, iu_size);
-+	return -ENOMEM;
-+}
-+EXPORT_SYMBOL_GPL(srp_target_alloc);
-+
-+void srp_target_free(struct srp_target *target)
-+{
-+	srp_ring_free(target-&gt;dev, target-&gt;rx_ring, target-&gt;rx_ring_size,
-+		      target-&gt;srp_iu_size);
-+	srp_iu_pool_free(&amp;target-&gt;iu_queue);
-+}
-+EXPORT_SYMBOL_GPL(srp_target_free);
-+
-+struct iu_entry *srp_iu_get(struct srp_target *target)
-+{
-+	struct iu_entry *iue = NULL;
-+
-+	kfifo_get(target-&gt;iu_queue.queue, (void *) &amp;iue, sizeof(void *));
-+	BUG_ON(!iue);
-+
-+	iue-&gt;target = target;
-+	iue-&gt;scmd = NULL;
-+	INIT_LIST_HEAD(&amp;iue-&gt;ilist);
-+	iue-&gt;flags = 0;
-+	return iue;
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_get);
-+
-+void srp_iu_put(struct iu_entry *iue)
-+{
-+	kfifo_put(iue-&gt;target-&gt;iu_queue.queue, (void *) &amp;iue, sizeof(void *));
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_put);
-+
-+static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
-+		       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	struct srp_target *target = iue-&gt;target;
-+	struct scatterlist *sg = scmd-&gt;request_buffer;
-+	int nsg, err;
-+
-+	dprintk(&quot;%p %u %u %u %d\n&quot;, iue, scmd-&gt;request_bufflen, scmd-&gt;bufflen,
-+		md-&gt;len, scmd-&gt;use_sg);
-+
-+	nsg = dma_map_sg(target-&gt;dev, sg, scmd-&gt;use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		printk(&quot;fail to map %p %d\n&quot;, iue, scmd-&gt;use_sg);
-+		return 0;
-+	}
-+	err = rdma_io(iue, sg, nsg, md, 1, dir,
-+		      min(scmd-&gt;request_bufflen, md-&gt;len));
-+
-+	dma_unmap_sg(target-&gt;dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+	return err;
-+}
-+
-+static int indirect_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			 struct srp_indirect_buf *id,
-+			 enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	struct srp_target *target = iue-&gt;target;
-+	struct srp_direct_buf *md;
-+	struct scatterlist dummy, *sg = scmd-&gt;request_buffer;
-+	dma_addr_t token = 0;
-+	long err;
-+	unsigned int done = 0;
-+	int nmd, nsg;
-+
-+	nmd = id-&gt;table_desc.len / sizeof(struct srp_direct_buf);
-+
-+	dprintk(&quot;%p %u %u %u %u %d %d %d\n&quot;,
-+		iue, scmd-&gt;request_bufflen, scmd-&gt;bufflen,
-+		id-&gt;len, scmd-&gt;offset, nmd,
-+		cmd-&gt;data_in_desc_cnt, cmd-&gt;data_out_desc_cnt);
-+
-+	if ((dir == DMA_FROM_DEVICE &amp;&amp; nmd == cmd-&gt;data_in_desc_cnt) ||
-+	    (dir == DMA_TO_DEVICE &amp;&amp; nmd == cmd-&gt;data_out_desc_cnt)) {
-+		md = &amp;id-&gt;desc_list[0];
-+		goto rdma;
-+	}
-+
-+	md = dma_alloc_coherent(target-&gt;dev, id-&gt;table_desc.len,
-+				 &amp;token, GFP_KERNEL);
-+	if (!md) {
-+		eprintk(&quot;Can't get dma memory %u\n&quot;, id-&gt;table_desc.len);
-+		return 0;
-+	}
-+
-+	sg_init_one(&amp;dummy, md, id-&gt;table_desc.len);
-+	sg_dma_address(&amp;dummy) = token;
-+	err = rdma_io(iue, &amp;dummy, 1, &amp;id-&gt;table_desc, 1, DMA_TO_DEVICE,
-+		      id-&gt;table_desc.len);
-+	if (err &lt; 0) {
-+		eprintk(&quot;Error copying indirect table %ld\n&quot;, err);
-+		goto free_mem;
-+	}
-+
-+rdma:
-+	nsg = dma_map_sg(target-&gt;dev, sg, scmd-&gt;use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		eprintk(&quot;fail to map %p %d\n&quot;, iue, scmd-&gt;use_sg);
-+		goto free_mem;
-+	}
-+
-+	err = rdma_io(iue, sg, nsg, md, nmd, dir,
-+		      min(scmd-&gt;request_bufflen, id-&gt;len));
-+	dma_unmap_sg(target-&gt;dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+free_mem:
-+	if (token)
-+		dma_free_coherent(target-&gt;dev, id-&gt;table_desc.len, md, token);
-+
-+	return done;
-+}
-+
-+static int data_out_desc_size(struct srp_cmd *cmd)
-+{
-+	int size = 0;
-+	u8 fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		size = sizeof(struct srp_direct_buf);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		size = sizeof(struct srp_indirect_buf) +
-+			sizeof(struct srp_direct_buf) * cmd-&gt;data_out_desc_cnt;
-+		break;
-+	default:
-+		eprintk(&quot;client error. Invalid data_out_format %x\n&quot;, fmt);
-+		break;
-+	}
-+	return size;
-+}
-+
-+static int __srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int offset, err = 0;
-+	u8 format;
-+
-+	offset = cmd-&gt;add_cdb_len * 4;
-+	if (dir == DMA_FROM_DEVICE)
-+		offset += data_out_desc_size(cmd);
-+
-+	if (dir == DMA_TO_DEVICE)
-+		format = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	else
-+		format = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+
-+	switch (format) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *)
-+			(cmd-&gt;add_data + offset);
-+		err = direct_data(scmd, md, dir, rdma_io);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *)
-+			(cmd-&gt;add_data + offset);
-+		err = indirect_data(scmd, cmd, id, dir, rdma_io);
-+		break;
-+	default:
-+		eprintk(&quot;Unknown format %d %x\n&quot;, dir, format);
-+		break;
-+	}
-+
-+	return err;
-+}
-+
-+/* TODO: this can be called multiple times for a single command. */
-+int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+		      rdma_io_t rdma_io)
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	enum dma_data_direction dir;
-+
-+	if (test_bit(V_WRITE, &amp;iue-&gt;flags))
-+		dir = DMA_TO_DEVICE;
-+	else
-+		dir = DMA_FROM_DEVICE;
-+	__srp_transfer_data(scmd, cmd, dir, rdma_io);
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_transfer_data);
-+
-+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int len = 0, offset = cmd-&gt;add_cdb_len * 4;
-+	u8 fmt;
-+
-+	if (dir == DMA_TO_DEVICE)
-+		fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	else {
-+		fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+		offset += data_out_desc_size(cmd);
-+	}
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *) (cmd-&gt;add_data + offset);
-+		len = md-&gt;len;
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *) (cmd-&gt;add_data + offset);
-+		len = id-&gt;len;
-+		break;
-+	default:
-+		eprintk(&quot;invalid data format %x\n&quot;, fmt);
-+		break;
-+	}
-+	return len;
-+}
-+
-+static uint8_t getcontrolbyte(u8 *cdb)
-+{
-+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
-+}
-+
-+static inline uint8_t getlink(struct srp_cmd *cmd)
-+{
-+	return (getcontrolbyte(cmd-&gt;cdb) &amp; 0x01);
-+}
-+
-+int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
-+{
-+	struct Scsi_host *shost = iue-&gt;target-&gt;shost;
-+	enum dma_data_direction data_dir;
-+	struct scsi_cmnd *scmd;
-+	int tag, len;
-+
-+	if (getlink(cmd))
-+		__set_bit(V_LINKED, &amp;iue-&gt;flags);
-+
-+	tag = MSG_SIMPLE_TAG;
-+
-+	switch (cmd-&gt;task_attr) {
-+	case SRP_SIMPLE_TASK:
-+		tag = MSG_SIMPLE_TAG;
-+		break;
-+	case SRP_ORDERED_TASK:
-+		tag = MSG_ORDERED_TAG;
-+		break;
-+	case SRP_HEAD_TASK:
-+		tag = MSG_HEAD_TAG;
-+		break;
-+	default:
-+		eprintk(&quot;Task attribute %d not supported\n&quot;, cmd-&gt;task_attr);
-+		tag = MSG_ORDERED_TAG;
-+	}
-+
-+	switch (cmd-&gt;cdb[0]) {
-+	case WRITE_6:
-+	case WRITE_10:
-+	case WRITE_VERIFY:
-+	case WRITE_12:
-+	case WRITE_VERIFY_12:
-+		__set_bit(V_WRITE, &amp;iue-&gt;flags);
-+	}
-+
-+	if (cmd-&gt;buf_fmt &gt;&gt; 4)
-+		data_dir = DMA_TO_DEVICE;
-+	else
-+		data_dir = DMA_FROM_DEVICE;
-+	len = vscsis_data_length(cmd, data_dir);
-+
-+	dprintk(&quot;%p %x %lx %d %d %d %llx\n&quot;, iue, cmd-&gt;cdb[0],
-+		cmd-&gt;lun, data_dir, len, tag, (unsigned long long) cmd-&gt;tag);
-+
-+	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
-+	BUG_ON(!scmd);
-+	scmd-&gt;SCp.ptr = (char *) iue;
-+	memcpy(scmd-&gt;data_cmnd, cmd-&gt;cdb, MAX_COMMAND_SIZE);
-+	scmd-&gt;request_bufflen = len;
-+	scmd-&gt;tag = tag;
-+	iue-&gt;scmd = scmd;
-+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &amp;cmd-&gt;lun, cmd-&gt;tag);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_cmd_perform);
-+
-+MODULE_DESCRIPTION(&quot;SCSI RDAM Protocol lib functions&quot;);
-+MODULE_AUTHOR(&quot;FUJITA Tomonori&quot;);
-+MODULE_LICENSE(&quot;GPL&quot;);
-diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
-new file mode 100644
-index 0000000..9dd10ff
---- /dev/null
-+++ b/include/scsi/libsrp.h
-@@ -0,0 +1,75 @@
-+#ifndef __LIBSRP_H__
-+#define __LIBSRP_H__
-+
-+#include &lt;linux/list.h&gt;
-+#include &lt;scsi/scsi_cmnd.h&gt;
-+#include &lt;scsi/scsi_host.h&gt;
-+#include &lt;scsi/srp.h&gt;
-+
-+enum iue_flags {
-+	V_DIOVER,
-+	V_WRITE,
-+	V_LINKED,
-+	V_FLYING,
-+};
-+
-+struct srp_buf {
-+	dma_addr_t dma;
-+	void *buf;
-+};
-+
-+struct srp_queue {
-+	void *pool;
-+	void *items;
-+	struct kfifo *queue;
-+	spinlock_t lock;
-+};
-+
-+struct srp_target {
-+	struct Scsi_Host *shost;
-+	struct device *dev;
-+
-+	spinlock_t lock;
-+	struct list_head cmd_queue;
-+
-+	size_t srp_iu_size;
-+	struct srp_queue iu_queue;
-+	size_t rx_ring_size;
-+	struct srp_buf **rx_ring;
-+
-+	/* IB needs tx_ring too */
-+
-+	void *ldata;
-+};
-+
-+struct iu_entry {
-+	struct srp_target *target;
-+	struct scsi_cmnd *scmd;
-+
-+	struct list_head ilist;
-+	dma_addr_t remote_token;
-+	unsigned long flags;
-+
-+	struct srp_buf *sbuf;
-+};
-+
-+typedef int (rdma_io_t) (struct iu_entry *, struct scatterlist *, int,
-+			 struct srp_direct_buf *, int,
-+			 enum dma_data_direction, unsigned int);
-+
-+static inline struct srp_target *host_to_target(struct Scsi_Host *host)
-+{
-+	return (struct srp_target *) host-&gt;hostdata;
-+}
-+
-+extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
-+extern void srp_target_free(struct srp_target *);
-+
-+extern struct iu_entry *srp_iu_get(struct srp_target *);
-+extern void srp_iu_put(struct iu_entry *);
-+
-+extern int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd);
-+extern int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			     rdma_io_t rdma_io);
-+
-+#endif
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,1021 +0,0 @@
-Subject: [PATCH 2/2] scsi tgt: ibmvstgt driver
-
-This tgt driver provides SCSI RDMA target support for IBM Power5
-systems.
-
-tgt and libsrp allow large simplifications in the original ibmvscsis
-driver:
-
-<A HREF="http://lkml.org/lkml/2005/10/17/99">http://lkml.org/lkml/2005/10/17/99</A>
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/Kconfig             |   14 +
- drivers/scsi/Makefile            |    1 
- drivers/scsi/ibmvscsi/Makefile   |    2 
- drivers/scsi/ibmvscsi/ibmvstgt.c |  943 ++++++++++++++++++++++++++++++++++++++
- 4 files changed, 960 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/ibmvscsi/ibmvstgt.c
-
-756cba9c44e2cccbabfa9abc2e96bdbcea92e25a
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 5b5eeb4..0ad0a5b 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -897,6 +897,20 @@ config SCSI_IBMVSCSI
- 	  To compile this driver as a module, choose M here: the
- 	  module will be called ibmvscsic.
- 
-+config SCSI_IBMVSCSIS
-+	tristate &quot;IBM Virtual SCSI Server support&quot;
-+	depends on PPC_PSERIES &amp;&amp; SCSI_TGT &amp;&amp; SCSI_SRP
-+	help
-+	  This is the SRP target driver for IBM pSeries virtual environments.
-+
-+	  The userspace component needed to initialize the driver and
-+	  documentation can be found:
-+
-+	  <A HREF="http://stgt.berlios.de/">http://stgt.berlios.de/</A>
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called ibmvstgt.
-+
- config SCSI_INITIO
- 	tristate &quot;Initio 9100U(W) support&quot;
- 	depends on PCI &amp;&amp; SCSI
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index 3d81b8d..c951da1 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o l
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
- obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
-diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
-index 4e247b6..6ac0633 100644
---- a/drivers/scsi/ibmvscsi/Makefile
-+++ b/drivers/scsi/ibmvscsi/Makefile
-@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
- ibmvscsic-y			+= ibmvscsi.o
- ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
- ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
-+
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
-diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
-new file mode 100644
-index 0000000..a4891f6
---- /dev/null
-+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
-@@ -0,0 +1,943 @@
-+/*
-+ * IBM eServer i/pSeries Virtual SCSI Target Driver
-+ * Copyright (C) 2003-2005 Dave Boutcher (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">boutcher at us.ibm.com</A>) IBM Corp.
-+ *			   Santiago Leon (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">santil at us.ibm.com</A>) IBM Corp.
-+ *			   Linda Xie (<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">lxie at us.ibm.com</A>) IBM Corp.
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-+ * USA
-+ */
-+#include &lt;linux/interrupt.h&gt;
-+#include &lt;linux/module.h&gt;
-+#include &lt;scsi/scsi.h&gt;
-+#include &lt;scsi/scsi_host.h&gt;
-+#include &lt;scsi/scsi_tgt.h&gt;
-+#include &lt;scsi/libsrp.h&gt;
-+#include &lt;asm/hvcall.h&gt;
-+#include &lt;asm/iommu.h&gt;
-+#include &lt;asm/prom.h&gt;
-+#include &lt;asm/vio.h&gt;
-+
-+#include &quot;ibmvscsi.h&quot;
-+
-+#define	INITIAL_SRP_LIMIT	16
-+#define	DEFAULT_MAX_SECTORS	512
-+
-+#define	TGT_NAME	&quot;ibmvstgt&quot;
-+
-+/*
-+ * Hypervisor calls.
-+ */
-+#define h_copy_rdma(l, sa, sb, da, db) \
-+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
-+#define h_send_crq(ua, l, h) \
-+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
-+#define h_reg_crq(ua, tok, sz)\
-+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
-+#define h_free_crq(ua) \
-+			plpar_hcall_norets(H_FREE_CRQ, ua);
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+struct vio_port {
-+	struct vio_dev *dma_dev;
-+
-+	struct crq_queue crq_queue;
-+	struct work_struct crq_work;
-+
-+	unsigned long liobn;
-+	unsigned long riobn;
-+};
-+
-+static struct workqueue_struct *vtgtd;
-+
-+/*
-+ * These are fixed for the system and come from the Open Firmware device tree.
-+ * We just store them here to save getting them every time.
-+ */
-+static char system_id[64] = &quot;&quot;;
-+static char partition_name[97] = &quot;UNKNOWN&quot;;
-+static unsigned int partition_number = -1;
-+
-+static struct vio_port *target_to_port(struct srp_target *target)
-+{
-+	return (struct vio_port *) target-&gt;ldata;
-+}
-+
-+static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
-+{
-+	return (union viosrp_iu *) (iue-&gt;sbuf-&gt;buf);
-+}
-+
-+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
-+{
-+	struct srp_target *target = iue-&gt;target;
-+	struct vio_port *vport = target_to_port(target);
-+	long rc, rc1;
-+	union {
-+		struct viosrp_crq cooked;
-+		uint64_t raw[2];
-+	} crq;
-+
-+	/* First copy the SRP */
-+	rc = h_copy_rdma(length, vport-&gt;liobn, iue-&gt;sbuf-&gt;dma,
-+			 vport-&gt;riobn, iue-&gt;remote_token);
-+
-+	if (rc)
-+		eprintk(&quot;Error %ld transferring data\n&quot;, rc);
-+
-+	crq.cooked.valid = 0x80;
-+	crq.cooked.format = format;
-+	crq.cooked.reserved = 0x00;
-+	crq.cooked.timeout = 0x00;
-+	crq.cooked.IU_length = length;
-+	crq.cooked.IU_data_ptr = vio_iu(iue)-&gt;srp.rsp.tag;
-+
-+	if (rc == 0)
-+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
-+	else
-+		crq.cooked.status = 0x00;
-+
-+	rc1 = h_send_crq(vport-&gt;dma_dev-&gt;unit_address, crq.raw[0], crq.raw[1]);
-+
-+	if (rc1) {
-+		eprintk(&quot;%ld sending response\n&quot;, rc1);
-+		return rc1;
-+	}
-+
-+	return rc;
-+}
-+
-+#define SRP_RSP_SENSE_DATA_LEN	18
-+
-+static int send_rsp(struct iu_entry *iue, unsigned char status,
-+		    unsigned char asc)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	uint64_t tag = iu-&gt;srp.rsp.tag;
-+
-+	/* If the linked bit is on and status is good */
-+	if (test_bit(V_LINKED, &amp;iue-&gt;flags) &amp;&amp; (status == NO_SENSE))
-+		status = 0x10;
-+
-+	memset(iu, 0, sizeof(struct srp_rsp));
-+	iu-&gt;srp.rsp.opcode = SRP_RSP;
-+	iu-&gt;srp.rsp.req_lim_delta = 1;
-+	iu-&gt;srp.rsp.tag = tag;
-+
-+	if (test_bit(V_DIOVER, &amp;iue-&gt;flags))
-+		iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
-+
-+	iu-&gt;srp.rsp.data_in_res_cnt = 0;
-+	iu-&gt;srp.rsp.data_out_res_cnt = 0;
-+
-+	iu-&gt;srp.rsp.flags &amp;= ~SRP_RSP_FLAG_RSPVALID;
-+
-+	iu-&gt;srp.rsp.resp_data_len = 0;
-+	iu-&gt;srp.rsp.status = status;
-+	if (status) {
-+		uint8_t *sense = iu-&gt;srp.rsp.data;
-+
-+		if (iue-&gt;scmd) {
-+			iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu-&gt;srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
-+			memcpy(sense, iue-&gt;scmd-&gt;sense_buffer,
-+			       SCSI_SENSE_BUFFERSIZE);
-+		} else {
-+			iu-&gt;srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-+			iu-&gt;srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu-&gt;srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
-+
-+			/* Valid bit and 'current errors' */
-+			sense[0] = (0x1 &lt;&lt; 7 | 0x70);
-+			/* Sense key */
-+			sense[2] = status;
-+			/* Additional sense length */
-+			sense[7] = 0xa;	/* 10 bytes */
-+			/* Additional sense code */
-+			sense[12] = asc;
-+		}
-+	}
-+
-+	send_iu(iue, sizeof(iu-&gt;srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
-+		VIOSRP_SRP_FORMAT);
-+
-+	return 0;
-+}
-+
-+static void handle_cmd_queue(struct srp_target *target)
-+{
-+	struct iu_entry *iue;
-+	unsigned long flags;
-+
-+retry:
-+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-+
-+	list_for_each_entry(iue, &amp;target-&gt;cmd_queue, ilist) {
-+		if (!test_and_set_bit(V_FLYING, &amp;iue-&gt;flags)) {
-+			spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-+			srp_cmd_perform(iue, (struct srp_cmd *) iue-&gt;sbuf-&gt;buf);
-+			goto retry;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-+}
-+
-+static int ibmvstgt_rdma(struct iu_entry *iue, struct scatterlist *sg, int nsg,
-+			 struct srp_direct_buf *md, int nmd,
-+			 enum dma_data_direction dir, unsigned int rest)
-+{
-+	struct srp_target *target = iue-&gt;target;
-+	struct vio_port *vport = target_to_port(target);
-+	dma_addr_t token;
-+	long err;
-+	unsigned int done = 0;
-+	int i, sidx, soff;
-+
-+	sidx = soff = 0;
-+	token = sg_dma_address(sg + sidx);
-+
-+	for (i = 0; i &lt; nmd &amp;&amp; rest; i++) {
-+		unsigned int mdone, mlen;
-+
-+		mlen = min(rest, md[i].len);
-+		for (mdone = 0; mlen;) {
-+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
-+
-+			if (dir == DMA_TO_DEVICE)
-+				err = h_copy_rdma(slen,
-+						  vport-&gt;riobn,
-+						  md[i].va + mdone,
-+						  vport-&gt;liobn,
-+						  token + soff);
-+			else
-+				err = h_copy_rdma(slen,
-+						  vport-&gt;liobn,
-+						  token + soff,
-+						  vport-&gt;riobn,
-+						  md[i].va + mdone);
-+
-+			if (err != H_Success) {
-+				eprintk(&quot;rdma error %d %d\n&quot;, dir, slen);
-+				goto out;
-+			}
-+
-+			mlen -= slen;
-+			mdone += slen;
-+			soff += slen;
-+			done += slen;
-+
-+			if (soff == sg_dma_len(sg + sidx)) {
-+				sidx++;
-+				soff = 0;
-+				token = sg_dma_address(sg + sidx);
-+
-+				if (sidx &gt; nsg) {
-+					eprintk(&quot;out of sg %p %d %d\n&quot;,
-+						iue, sidx, nsg);
-+					goto out;
-+				}
-+			}
-+		};
-+
-+		rest -= mlen;
-+	}
-+out:
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_transfer_data(struct scsi_cmnd *scmd,
-+				  void (*done)(struct scsi_cmnd *))
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	int err;
-+
-+	err = srp_transfer_data(scmd, &amp;vio_iu(iue)-&gt;srp.cmd, ibmvstgt_rdma);
-+	done(scmd);
-+
-+	return err;
-+}
-+
-+static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
-+			     void (*done)(struct scsi_cmnd *))
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	struct srp_target *target = iue-&gt;target;
-+
-+	dprintk(&quot;%p %p %x\n&quot;, iue, target, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-+	list_del(&amp;iue-&gt;ilist);
-+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-+
-+	if (scmd-&gt;result != SAM_STAT_GOOD) {
-+		eprintk(&quot;operation failed %p %d %x\n&quot;,
-+			iue, scmd-&gt;result, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
-+		send_rsp(iue, HARDWARE_ERROR, 0x00);
-+	} else
-+		send_rsp(iue, NO_SENSE, 0x00);
-+
-+	done(scmd);
-+	srp_iu_put(iue);
-+	return 0;
-+}
-+
-+int send_adapter_info(struct iu_entry *iue,
-+		      dma_addr_t remote_buffer, uint16_t length)
-+{
-+	struct srp_target *target = iue-&gt;target;
-+	struct vio_port *vport = target_to_port(target);
-+	struct Scsi_Host *shost = target-&gt;shost;
-+	dma_addr_t data_token;
-+	struct mad_adapter_info_data *info;
-+	int err;
-+
-+	info = dma_alloc_coherent(target-&gt;dev, sizeof(*info), &amp;data_token,
-+				  GFP_KERNEL);
-+	if (!info) {
-+		eprintk(&quot;bad dma_alloc_coherent %p\n&quot;, target);
-+		return 1;
-+	}
-+
-+	/* Get remote info */
-+	err = h_copy_rdma(sizeof(*info), vport-&gt;riobn, remote_buffer,
-+			  vport-&gt;liobn, data_token);
-+	if (err == H_Success) {
-+		dprintk(&quot;Client connect: %s (%d)\n&quot;,
-+			info-&gt;partition_name, info-&gt;partition_number);
-+	}
-+
-+	memset(info, 0, sizeof(*info));
-+
-+	strcpy(info-&gt;srp_version, &quot;16.a&quot;);
-+	strncpy(info-&gt;partition_name, partition_name,
-+		sizeof(info-&gt;partition_name));
-+	info-&gt;partition_number = partition_number;
-+	info-&gt;mad_version = 1;
-+	info-&gt;os_type = 2;
-+	info-&gt;port_max_txu[0] = shost-&gt;hostt-&gt;max_sectors &lt;&lt; 9;
-+
-+	/* Send our info to remote */
-+	err = h_copy_rdma(sizeof(*info), vport-&gt;liobn, data_token,
-+			  vport-&gt;riobn, remote_buffer);
-+
-+	dma_free_coherent(target-&gt;dev, sizeof(*info), info, data_token);
-+
-+	if (err != H_Success) {
-+		eprintk(&quot;Error sending adapter info %d\n&quot;, err);
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static void process_login(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct srp_login_rsp *rsp = &amp;iu-&gt;srp.login_rsp;
-+	uint64_t tag = iu-&gt;srp.rsp.tag;
-+
-+	/* TODO handle case that requested size is wrong and
-+	 * buffer format is wrong
-+	 */
-+	memset(iu, 0, sizeof(struct srp_login_rsp));
-+	rsp-&gt;opcode = SRP_LOGIN_RSP;
-+	rsp-&gt;req_lim_delta = INITIAL_SRP_LIMIT;
-+	rsp-&gt;tag = tag;
-+	rsp-&gt;max_it_iu_len = sizeof(union srp_iu);
-+	rsp-&gt;max_ti_iu_len = sizeof(union srp_iu);
-+	/* direct and indirect */
-+	rsp-&gt;buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
-+
-+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
-+}
-+
-+static inline void queue_cmd(struct iu_entry *iue)
-+{
-+	struct srp_target *target = iue-&gt;target;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-+	list_add_tail(&amp;iue-&gt;ilist, &amp;target-&gt;cmd_queue);
-+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-+}
-+
-+static int process_tsk_mgmt(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int fn;
-+
-+	dprintk(&quot;%p %u\n&quot;, iue, iu-&gt;srp.tsk_mgmt.tsk_mgmt_func);
-+
-+	switch (iu-&gt;srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		fn = ABORT_TASK;
-+		break;
-+	case SRP_TSK_ABORT_TASK_SET:
-+		fn = ABORT_TASK_SET;
-+		break;
-+	case SRP_TSK_CLEAR_TASK_SET:
-+		fn = CLEAR_TASK_SET;
-+		break;
-+	case SRP_TSK_LUN_RESET:
-+		fn = LOGICAL_UNIT_RESET;
-+		break;
-+	case SRP_TSK_CLEAR_ACA:
-+		fn = CLEAR_ACA;
-+		break;
-+	default:
-+		fn = 0;
-+	}
-+	if (fn)
-+		scsi_tgt_tsk_mgmt_request(iue-&gt;target-&gt;shost, fn,
-+					  iu-&gt;srp.tsk_mgmt.task_tag,
-+					  (struct scsi_lun *) &amp;iu-&gt;srp.tsk_mgmt.lun,
-+					  iue);
-+	else
-+		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
-+
-+	return !fn;
-+}
-+
-+static int process_mad_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct viosrp_adapter_info *info;
-+	struct viosrp_host_config *conf;
-+
-+	switch (iu-&gt;mad.empty_iu.common.type) {
-+	case VIOSRP_EMPTY_IU_TYPE:
-+		eprintk(&quot;%s\n&quot;, &quot;Unsupported EMPTY MAD IU&quot;);
-+		break;
-+	case VIOSRP_ERROR_LOG_TYPE:
-+		eprintk(&quot;%s\n&quot;, &quot;Unsupported ERROR LOG MAD IU&quot;);
-+		iu-&gt;mad.error_log.common.status = 1;
-+		send_iu(iue, sizeof(iu-&gt;mad.error_log),	VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_ADAPTER_INFO_TYPE:
-+		info = &amp;iu-&gt;mad.adapter_info;
-+		info-&gt;common.status = send_adapter_info(iue, info-&gt;buffer,
-+							info-&gt;common.length);
-+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_HOST_CONFIG_TYPE:
-+		conf = &amp;iu-&gt;mad.host_config;
-+		conf-&gt;common.status = 1;
-+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
-+		break;
-+	default:
-+		eprintk(&quot;Unknown type %u\n&quot;, iu-&gt;srp.rsp.opcode);
-+	}
-+
-+	return 1;
-+}
-+
-+static int process_srp_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int done = 1;
-+	u8 opcode = iu-&gt;srp.rsp.opcode;
-+
-+	switch (opcode) {
-+	case SRP_LOGIN_REQ:
-+		process_login(iue);
-+		break;
-+	case SRP_TSK_MGMT:
-+		done = process_tsk_mgmt(iue);
-+		break;
-+	case SRP_CMD:
-+		queue_cmd(iue);
-+		done = 0;
-+		break;
-+	case SRP_LOGIN_RSP:
-+	case SRP_I_LOGOUT:
-+	case SRP_T_LOGOUT:
-+	case SRP_RSP:
-+	case SRP_CRED_REQ:
-+	case SRP_CRED_RSP:
-+	case SRP_AER_REQ:
-+	case SRP_AER_RSP:
-+		eprintk(&quot;Unsupported type %u\n&quot;, opcode);
-+		break;
-+	default:
-+		eprintk(&quot;Unknown type %u\n&quot;, opcode);
-+	}
-+
-+	return done;
-+}
-+
-+static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct iu_entry *iue;
-+	long err, done;
-+
-+	iue = srp_iu_get(target);
-+	if (!iue) {
-+		eprintk(&quot;Error getting IU from pool, %p\n&quot;, target);
-+		return;
-+	}
-+
-+	iue-&gt;remote_token = crq-&gt;IU_data_ptr;
-+
-+	err = h_copy_rdma(crq-&gt;IU_length, vport-&gt;riobn,
-+			  iue-&gt;remote_token, vport-&gt;liobn, iue-&gt;sbuf-&gt;dma);
-+
-+	if (err != H_Success)
-+		eprintk(&quot;%ld transferring data error %p\n&quot;, err, iue);
-+
-+	if (crq-&gt;format == VIOSRP_MAD_FORMAT)
-+		done = process_mad_iu(iue);
-+	else
-+		done = process_srp_iu(iue);
-+
-+	if (done)
-+		srp_iu_put(iue);
-+}
-+
-+static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	vio_disable_interrupts(vport-&gt;dma_dev);
-+	queue_work(vtgtd, &amp;vport-&gt;crq_work);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
-+{
-+	int err;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	queue-&gt;msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
-+	if (!queue-&gt;msgs)
-+		goto malloc_failed;
-+	queue-&gt;size = PAGE_SIZE / sizeof(*queue-&gt;msgs);
-+
-+	queue-&gt;msg_token = dma_map_single(target-&gt;dev, queue-&gt;msgs,
-+					  queue-&gt;size * sizeof(*queue-&gt;msgs),
-+					  DMA_BIDIRECTIONAL);
-+
-+	if (dma_mapping_error(queue-&gt;msg_token))
-+		goto map_failed;
-+
-+	err = h_reg_crq(vport-&gt;dma_dev-&gt;unit_address, queue-&gt;msg_token,
-+			PAGE_SIZE);
-+
-+	/* If the adapter was left active for some reason (like kexec)
-+	 * try freeing and re-registering
-+	 */
-+	if (err == H_Resource) {
-+	    do {
-+		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
-+	    } while (err == H_Busy || H_isLongBusy(err));
-+
-+	    err = h_reg_crq(vport-&gt;dma_dev-&gt;unit_address, queue-&gt;msg_token,
-+			    PAGE_SIZE);
-+	}
-+
-+	if (err != H_Success &amp;&amp; err != 2) {
-+		eprintk(&quot;Error 0x%x opening virtual adapter\n&quot;, err);
-+		goto reg_crq_failed;
-+	}
-+
-+	err = request_irq(vport-&gt;dma_dev-&gt;irq, &amp;ibmvstgt_interrupt,
-+			  SA_INTERRUPT, &quot;ibmvstgt&quot;, target);
-+	if (err)
-+		goto req_irq_failed;
-+
-+	vio_enable_interrupts(vport-&gt;dma_dev);
-+
-+	h_send_crq(vport-&gt;dma_dev-&gt;unit_address, 0xC001000000000000, 0);
-+
-+	queue-&gt;cur = 0;
-+	spin_lock_init(&amp;queue-&gt;lock);
-+
-+	return 0;
-+
-+req_irq_failed:
-+	do {
-+		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
-+	} while (err == H_Busy || H_isLongBusy(err));
-+
-+reg_crq_failed:
-+	dma_unmap_single(target-&gt;dev, queue-&gt;msg_token,
-+			 queue-&gt;size * sizeof(*queue-&gt;msgs), DMA_BIDIRECTIONAL);
-+map_failed:
-+	free_page((unsigned long) queue-&gt;msgs);
-+
-+malloc_failed:
-+	return -ENOMEM;
-+}
-+
-+static void crq_queue_destroy(struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct crq_queue *queue = &amp;vport-&gt;crq_queue;
-+	int err;
-+
-+	free_irq(vport-&gt;dma_dev-&gt;irq, target);
-+	do {
-+		err = h_free_crq(vport-&gt;dma_dev-&gt;unit_address);
-+	} while (err == H_Busy || H_isLongBusy(err));
-+
-+	dma_unmap_single(target-&gt;dev, queue-&gt;msg_token,
-+			 queue-&gt;size * sizeof(*queue-&gt;msgs), DMA_BIDIRECTIONAL);
-+
-+	free_page((unsigned long) queue-&gt;msgs);
-+}
-+
-+static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	dprintk(&quot;%x %x\n&quot;, crq-&gt;valid, crq-&gt;format);
-+
-+	switch (crq-&gt;valid) {
-+	case 0xC0:
-+		/* initialization */
-+		switch (crq-&gt;format) {
-+		case 0x01:
-+			h_send_crq(vport-&gt;dma_dev-&gt;unit_address,
-+				   0xC002000000000000, 0);
-+			break;
-+		case 0x02:
-+			break;
-+		default:
-+			eprintk(&quot;Unknown format %u\n&quot;, crq-&gt;format);
-+		}
-+		break;
-+	case 0xFF:
-+		/* transport event */
-+		break;
-+	case 0x80:
-+		/* real payload */
-+		switch (crq-&gt;format) {
-+		case VIOSRP_SRP_FORMAT:
-+		case VIOSRP_MAD_FORMAT:
-+			process_iu(crq, target);
-+			break;
-+		case VIOSRP_OS400_FORMAT:
-+		case VIOSRP_AIX_FORMAT:
-+		case VIOSRP_LINUX_FORMAT:
-+		case VIOSRP_INLINE_FORMAT:
-+			eprintk(&quot;Unsupported format %u\n&quot;, crq-&gt;format);
-+			break;
-+		default:
-+			eprintk(&quot;Unknown format %u\n&quot;, crq-&gt;format);
-+		}
-+		break;
-+	default:
-+		eprintk(&quot;unknown message type 0x%02x!?\n&quot;, crq-&gt;valid);
-+	}
-+}
-+
-+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
-+{
-+	struct viosrp_crq *crq;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&amp;queue-&gt;lock, flags);
-+	crq = &amp;queue-&gt;msgs[queue-&gt;cur];
-+	if (crq-&gt;valid &amp; 0x80) {
-+		if (++queue-&gt;cur == queue-&gt;size)
-+			queue-&gt;cur = 0;
-+	} else
-+		crq = NULL;
-+	spin_unlock_irqrestore(&amp;queue-&gt;lock, flags);
-+
-+	return crq;
-+}
-+
-+static void handle_crq(void *data)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+	struct viosrp_crq *crq;
-+	int done = 0;
-+
-+	while (!done) {
-+		while ((crq = next_crq(&amp;vport-&gt;crq_queue)) != NULL) {
-+			process_crq(crq, target);
-+			crq-&gt;valid = 0x00;
-+		}
-+
-+		vio_enable_interrupts(vport-&gt;dma_dev);
-+
-+		crq = next_crq(&amp;vport-&gt;crq_queue);
-+		if (crq) {
-+			vio_disable_interrupts(vport-&gt;dma_dev);
-+			process_crq(crq, target);
-+			crq-&gt;valid = 0x00;
-+		} else
-+			done = 1;
-+	}
-+
-+	handle_cmd_queue(target);
-+}
-+
-+
-+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd-&gt;SCp.ptr;
-+	struct srp_target *target = iue-&gt;target;
-+
-+	dprintk(&quot;%p %p %x\n&quot;, iue, target, vio_iu(iue)-&gt;srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-+	list_del(&amp;iue-&gt;ilist);
-+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-+
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
-+	union viosrp_iu *iu = vio_iu(iue);
-+	unsigned char status, asc;
-+
-+	eprintk(&quot;%p %d\n&quot;, iue, result);
-+	status = NO_SENSE;
-+	asc = 0;
-+
-+	switch (iu-&gt;srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		asc = 0x14;
-+		if (result)
-+			status = ABORTED_COMMAND;
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	send_rsp(iue, status, asc);
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static ssize_t system_id_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, system_id);
-+}
-+
-+static ssize_t partition_number_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, &quot;%x\n&quot;, partition_number);
-+}
-+
-+static ssize_t unit_address_show(struct class_device *cdev, char *buf)
-+{
-+	struct Scsi_Host *shost = class_to_shost(cdev);
-+	struct srp_target *target = host_to_target(shost);
-+	struct vio_port *vport = target_to_port(target);
-+	return snprintf(buf, PAGE_SIZE, &quot;%x\n&quot;, vport-&gt;dma_dev-&gt;unit_address);
-+}
-+
-+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
-+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
-+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
-+
-+static struct class_device_attribute *ibmvstgt_attrs[] = {
-+	&amp;class_device_attr_system_id,
-+	&amp;class_device_attr_partition_number,
-+	&amp;class_device_attr_unit_address,
-+	NULL,
-+};
-+
-+static struct scsi_host_template ibmvstgt_sht = {
-+	.name			= TGT_NAME,
-+	.module			= THIS_MODULE,
-+	.can_queue		= INITIAL_SRP_LIMIT,
-+	.sg_tablesize		= SG_ALL,
-+	.use_clustering		= DISABLE_CLUSTERING,
-+	.max_sectors		= DEFAULT_MAX_SECTORS,
-+	.transfer_response	= ibmvstgt_cmd_done,
-+	.transfer_data		= ibmvstgt_transfer_data,
-+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
-+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
-+	.shost_attrs		= ibmvstgt_attrs,
-+	.proc_name		= TGT_NAME,
-+};
-+
-+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
-+{
-+	struct Scsi_Host *shost;
-+	struct srp_target *target;
-+	struct vio_port *vport;
-+	unsigned int *dma, dma_size;
-+	int err = -ENOMEM;
-+
-+	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
-+	if (!vport)
-+		return err;
-+	shost = scsi_host_alloc(&amp;ibmvstgt_sht, sizeof(struct srp_target));
-+	if (!shost)
-+		goto free_vport;
-+	err = scsi_tgt_alloc_queue(shost);
-+	if (err)
-+		goto put_host;
-+
-+	target = host_to_target(shost);
-+	target-&gt;shost = shost;
-+	vport-&gt;dma_dev = dev;
-+	target-&gt;ldata = vport;
-+	err = srp_target_alloc(target, &amp;dev-&gt;dev, INITIAL_SRP_LIMIT,
-+			       SRP_MAX_IU_LEN);
-+	if (err)
-+		goto put_host;
-+
-+	dma = (unsigned int *) vio_get_attribute(dev, &quot;ibm,my-dma-window&quot;,
-+						 &amp;dma_size);
-+	if (!dma || dma_size != 40) {
-+		eprintk(&quot;Couldn't get window property %d\n&quot;, dma_size);
-+		err = -EIO;
-+		goto free_srp_target;
-+	}
-+	vport-&gt;liobn = dma[0];
-+	vport-&gt;riobn = dma[5];
-+
-+	INIT_WORK(&amp;vport-&gt;crq_work, handle_crq, target);
-+
-+	err = crq_queue_create(&amp;vport-&gt;crq_queue, target);
-+	if (err)
-+		goto free_srp_target;
-+
-+	err = scsi_add_host(shost, target-&gt;dev);
-+	if (err)
-+		goto destroy_queue;
-+	return 0;
-+
-+destroy_queue:
-+	crq_queue_destroy(target);
-+free_srp_target:
-+	srp_target_free(target);
-+put_host:
-+	scsi_host_put(shost);
-+free_vport:
-+	kfree(vport);
-+	return err;
-+}
-+
-+static int ibmvstgt_remove(struct vio_dev *dev)
-+{
-+	struct srp_target *target = (struct srp_target *) dev-&gt;dev.driver_data;
-+	struct Scsi_Host *shost = target-&gt;shost;
-+
-+	srp_target_free(target);
-+	crq_queue_destroy(target);
-+	scsi_remove_host(shost);
-+	scsi_host_put(shost);
-+	return 0;
-+}
-+
-+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
-+	{&quot;v-scsi-host&quot;, &quot;IBM,v-scsi-host&quot;},
-+	{&quot;&quot;,&quot;&quot;}
-+};
-+
-+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
-+
-+static struct vio_driver ibmvstgt_driver = {
-+	.id_table = ibmvstgt_device_table,
-+	.probe = ibmvstgt_probe,
-+	.remove = ibmvstgt_remove,
-+	.driver = {
-+		.name = &quot;ibmvscsi&quot;,
-+		.owner = THIS_MODULE,
-+	}
-+};
-+
-+static int get_system_info(void)
-+{
-+	struct device_node *rootdn;
-+	char *id, *model, *name;
-+	unsigned int *num;
-+
-+	rootdn = find_path_device(&quot;/&quot;);
-+	if (!rootdn)
-+		return -ENOENT;
-+
-+	model = get_property(rootdn, &quot;model&quot;, NULL);
-+	id = get_property(rootdn, &quot;system-id&quot;, NULL);
-+	if (model &amp;&amp; id)
-+		snprintf(system_id, sizeof(system_id), &quot;%s-%s&quot;, model, id);
-+
-+	name = get_property(rootdn, &quot;ibm,partition-name&quot;, NULL);
-+	if (name)
-+		strncpy(partition_name, name, sizeof(partition_name));
-+
-+	num = (unsigned int *) get_property(rootdn, &quot;ibm,partition-no&quot;, NULL);
-+	if (num)
-+		partition_number = *num;
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_init(void)
-+{
-+	int err = -ENOMEM;
-+
-+	printk(&quot;IBM eServer i/pSeries Virtual SCSI Target Driver\n&quot;);
-+
-+	vtgtd = create_workqueue(&quot;ibmvtgtd&quot;);
-+	if (!vtgtd)
-+		return err;
-+
-+	err = get_system_info();
-+	if (err)
-+		goto destroy_wq;
-+
-+	err = vio_register_driver(&amp;ibmvstgt_driver);
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(vtgtd);
-+	return err;
-+}
-+
-+static void ibmvstgt_exit(void)
-+{
-+	printk(&quot;Unregister IBM virtual SCSI driver\n&quot;);
-+
-+	destroy_workqueue(vtgtd);
-+	vio_unregister_driver(&amp;ibmvstgt_driver);
-+}
-+
-+MODULE_DESCRIPTION(&quot;IBM Virtual SCSI Target&quot;);
-+MODULE_AUTHOR(&quot;Dave Boutcher&quot;);
-+MODULE_LICENSE(&quot;GPL&quot;);
-+
-+module_init(ibmvstgt_init);
-+module_exit(ibmvstgt_exit);
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff
===================================================================
--- branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,801 +0,0 @@
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool-&gt;events[i].ext_list) {
- 			dma_free_coherent(hostdata-&gt;dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool-&gt;events[i].ext_list,
- 				  pool-&gt;events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_out_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_in_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd-&gt;data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd-&gt;data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
-+	else
-+		srp_cmd-&gt;buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i &lt; num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i &lt; num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
--	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd-&gt;additional_data;
--		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd-&gt;add_data;
-+		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd-&gt;additional_data;
--		int num_mapped = indirect-&gt;head.length / 
--			sizeof(indirect-&gt;list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd-&gt;add_data;
-+		int num_mapped = indirect-&gt;table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
-+			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i &lt; num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &amp;sg[i];
--		descr-&gt;virtual_address = sg_dma_address(sg_entry);
--		descr-&gt;length = sg_dma_len(sg_entry);
--		descr-&gt;memory_handle = 0;
-+		descr-&gt;va = sg_dma_address(sg_entry);
-+		descr-&gt;len = sg_dma_len(sg_entry);
-+		descr-&gt;key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd-&gt;request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
--		data-&gt;length = sg_dma_len(&amp;sg[0]);
--		data-&gt;memory_handle = 0;
-+		data-&gt;va = sg_dma_address(&amp;sg[0]);
-+		data-&gt;len = sg_dma_len(&amp;sg[0]);
-+		data-&gt;key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect-&gt;head.virtual_address = 0;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	indirect-&gt;head.memory_handle = 0;
-+	indirect-&gt;table_desc.va = 0;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect-&gt;table_desc.key = 0;
- 
- 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
--		indirect-&gt;total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &amp;indirect-&gt;desc_list[0]);
-+		indirect-&gt;len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct-&gt;ext_list) {
--		evt_struct-&gt;ext_list =(struct memory_descriptor*)
-+		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&amp;evt_struct-&gt;ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &amp;evt_struct-&gt;ext_list_token, 0);
- 		if (!evt_struct-&gt;ext_list) {
--		    printk(KERN_ERR
--		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
-+			printk(KERN_ERR
-+			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
- 
--	indirect-&gt;total_length = total_length;
--	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect-&gt;len = total_length;
-+	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
-+	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
- 
--	data-&gt;virtual_address =
-+	data-&gt;va =
- 		dma_map_single(dev, cmd-&gt;request_buffer,
- 			       cmd-&gt;request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data-&gt;virtual_address)) {
-+	if (dma_mapping_error(data-&gt;va)) {
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
- 		return 0;
- 	}
--	data-&gt;length = cmd-&gt;request_bufflen;
--	data-&gt;memory_handle = 0;
-+	data-&gt;len = cmd-&gt;request_bufflen;
-+	data-&gt;key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
--	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
-+	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
- 
--	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
--			       rsp-&gt;type);
-+			       rsp-&gt;opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd-&gt;result = rsp-&gt;status;
- 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd-&gt;sense_buffer,
--			       rsp-&gt;sense_and_response_data,
--			       rsp-&gt;sense_data_list_length);
-+			       rsp-&gt;data,
-+			       rsp-&gt;sense_data_len);
- 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct-&gt;hostdata-&gt;dev);
- 
--		if (rsp-&gt;doover)
--			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
--		else if (rsp-&gt;diover)
--			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
-+		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
-+		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
- 	}
- 
- 	if (evt_struct-&gt;cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
- 	u16 lun = lun_from_dev(cmnd-&gt;device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd-&gt;type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd-&gt;opcode = SRP_CMD;
- 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
- 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct-&gt;cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
--	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
--	    (indirect-&gt;head.virtual_address == 0)) {
--		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
-+	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
-+	    indirect-&gt;table_desc.va == 0) {
-+		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
--	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
- 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
--		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
-+		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
- 
--	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
-+	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
- 	    (max_requests - 2))
--		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
-+		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&amp;hostdata-&gt;request_limit,
--		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
-+		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
- 
- 	hostdata-&gt;host-&gt;can_queue =
--	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
- 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &amp;evt_struct-&gt;iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login-&gt;type = SRP_LOGIN_REQ_TYPE;
--	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login-&gt;required_buffer_formats = 0x0006;
-+	login-&gt;opcode = SRP_LOGIN_REQ;
-+	login-&gt;req_it_iu_len = sizeof(union srp_iu);
-+	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt-&gt;task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
- 
- 	evt-&gt;sync_srp = &amp;srp_rsp;
- 	init_completion(&amp;evt-&gt;comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
-+			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
- 			       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
- 		printk(KERN_INFO
- 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
--		       tsk_mgmt-&gt;managed_task_tag);
-+		       tsk_mgmt-&gt;task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;task_tag);
- 
- 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
- 	list_del(&amp;found_evt-&gt;list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
- 	       tsk_mgmt-&gt;lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
--		       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       rsp_rc, tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
- 			   &amp;hostdata-&gt;request_limit);
- 
- 	if (evt_struct-&gt;done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include &lt;linux/dma-mapping.h&gt;
- #include &lt;linux/interrupt.h&gt;
- #include &quot;ibmvscsi.h&quot;
--#include &quot;srp.h&quot;
- 
- static char partition_name[97] = &quot;UNKNOWN&quot;;
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION &quot;16.a&quot;
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include &quot;srp.h&quot;
-+#include &lt;scsi/srp.h&gt;
-+
-+#define SRP_VERSION &quot;16.a&quot;
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000475.html">[Stgt-svn] r488 - branches/use-scsi-ml/usr
</A></li>
	<LI>Next message: <A HREF="000477.html">[Stgt-svn] r490 - / branches
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#476">[ date ]</a>
              <a href="thread.html#476">[ thread ]</a>
              <a href="subject.html#476">[ subject ]</a>
              <a href="author.html#476">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
