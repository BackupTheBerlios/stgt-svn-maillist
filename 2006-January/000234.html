<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-January/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r247%20-%20branches/use-scsi-ml/istgt/kernel&In-Reply-To=%3C200601292332.k0TNW3G6007208%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000233.html">
   <LINK REL="Next"  HREF="000235.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel</H1>
    <B>mnc at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r247%20-%20branches/use-scsi-ml/istgt/kernel&In-Reply-To=%3C200601292332.k0TNW3G6007208%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel">mnc at berlios.de
       </A><BR>
    <I>Mon Jan 30 00:32:03 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000233.html">[Stgt-svn] r246 - branches/use-scsi-ml/usr
</A></li>
        <LI>Next message: <A HREF="000235.html">[Stgt-svn] r248 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#234">[ date ]</a>
              <a href="thread.html#234">[ thread ]</a>
              <a href="subject.html#234">[ subject ]</a>
              <a href="author.html#234">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mnc
Date: 2006-01-30 00:32:01 +0100 (Mon, 30 Jan 2006)
New Revision: 247

Added:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Removed:
   branches/use-scsi-ml/istgt/kernel/iscsi.c
Log:
check in iscsi_tcp_tgt.c: it does not compile. It needs to be converted to new headers and the transfer_data fn needs to be update  to account for the change in that it can be called multiple times (it needs to check the cmd-&gt;offset).

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi.c
===================================================================

Added: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-01-28 10:56:32 UTC (rev 246)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-01-29 23:32:01 UTC (rev 247)
@@ -0,0 +1,1935 @@
+/*
+ * (C) 2004 - 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * Copyright (C) 2002 - 2003 Ardis Technolgies &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">roman at ardistech.com</A>&gt;
+ * Copyright (C) 2005 - 2006 Mike Christie
+ *
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/hash.h&gt;
+#include &lt;linux/mempool.h&gt;
+#include &lt;net/tcp.h&gt;
+#include &lt;scsi/scsi.h&gt;
+#include &lt;scsi/scsi_tgt.h&gt;
+#include &lt;scsi/scsi_tcq.h&gt;
+#include &lt;scsi/scsi_transport.h&gt;
+#include &lt;scsi/scsi_transport_iscsi.h&gt;
+#include &lt;iscsi.h&gt;
+
+static kmem_cache_t *istgt_cmd_cache;
+static char dummy_data[1024];
+
+static uint32_t cmnd_write_size(struct istgt_cmd *cmnd)
+{
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
+
+	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)
+		return be32_to_cpu(hdr-&gt;data_length);
+	return 0;
+}
+
+static uint32_t cmnd_read_size(struct istgt_cmd *cmnd)
+{
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
+
+	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
+		if (!(hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE))
+			return be32_to_cpu(hdr-&gt;data_length);
+		if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
+			struct iscsi_rlength_ahdr *ahdr =
+				(struct iscsi_rlength_ahdr *)cmnd-&gt;pdu.ahs;
+			if (ahdr &amp;&amp; ahdr-&gt;ahstype == ISCSI_AHSTYPE_RLENGTH)
+				return be32_to_cpu(ahdr-&gt;read_length);
+		}
+	}
+	return 0;
+}
+
+/*
+ * create a new command.
+ *
+ * iscsi_cmnd_create - 
+ * @conn: ptr to connection (for i/o)
+ *
+ * @return    ptr to command or NULL
+ */
+
+struct istgt_cmd *cmnd_alloc(struct iscsi_conn *conn, int req)
+{
+	struct istgt_cmd *cmnd;
+
+	/* TODO: async interface is necessary ? */
+	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
+
+	memset(cmnd, 0, sizeof(*cmnd));
+	INIT_LIST_HEAD(&amp;cmnd-&gt;list);
+	INIT_LIST_HEAD(&amp;cmnd-&gt;pdu_list);
+	INIT_LIST_HEAD(&amp;cmnd-&gt;conn_list);
+	INIT_LIST_HEAD(&amp;cmnd-&gt;hash_list);
+	cmnd-&gt;conn = conn;
+	spin_lock(&amp;conn-&gt;list_lock);
+	atomic_inc(&amp;conn-&gt;nr_cmnds);
+	init_completion(&amp;cmnd-&gt;event);
+	if (req)
+		list_add_tail(&amp;cmnd-&gt;conn_list, &amp;conn-&gt;pdu_list);
+	spin_unlock(&amp;conn-&gt;list_lock);
+	cmnd-&gt;sg = NULL;
+
+	if (req)
+		BUG_ON(!conn-&gt;session);
+
+	dprintk(&quot;%p:%p\n&quot;, conn, cmnd);
+
+	return cmnd;
+}
+
+/**
+ * create a new command used as response.
+ *
+ * iscsi_cmnd_create_rsp_cmnd - 
+ * @cmnd: ptr to request command
+ *
+ * @return    ptr to response command or NULL
+ */
+
+static struct istgt_cmd *iscsi_cmnd_create_rsp_cmnd(struct istgt_cmd *cmnd, int final)
+{
+	struct istgt_cmd *rsp = cmnd_alloc(cmnd-&gt;conn, 0);
+
+	if (final)
+		set_cmd_final(rsp);
+	list_add_tail(&amp;rsp-&gt;pdu_list, &amp;cmnd-&gt;pdu_list);
+	rsp-&gt;req = cmnd;
+	return rsp;
+}
+
+static struct istgt_cmd *get_rsp_cmnd(struct istgt_cmd *req)
+{
+	return list_entry(req-&gt;pdu_list.prev, struct istgt_cmd, pdu_list);
+}
+
+static void iscsi_cmnds_init_write(struct list_head *send)
+{
+	struct istgt_cmd *cmnd = list_entry(send-&gt;next, struct istgt_cmd, list);
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	struct list_head *pos, *next;
+
+	spin_lock(&amp;conn-&gt;list_lock);
+
+	list_for_each_safe(pos, next, send) {
+		cmnd = list_entry(pos, struct istgt_cmd, list);
+
+		dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
+
+		list_del_init(&amp;cmnd-&gt;list);
+		BUG_ON(conn != cmnd-&gt;conn);
+		list_add_tail(&amp;cmnd-&gt;list, &amp;conn-&gt;write_list);
+	}
+
+	spin_unlock(&amp;conn-&gt;list_lock);
+
+	nthread_wakeup(conn-&gt;session);
+}
+
+static void iscsi_cmnd_init_write(struct istgt_cmd *cmnd)
+{
+	LIST_HEAD(head);
+
+	if (!list_empty(&amp;cmnd-&gt;list)) {
+		eprintk(&quot;%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n&quot;,
+			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
+			cmd_scsicode(cmnd), cmnd-&gt;flags,
+			cmnd-&gt;r2t_sn, cmnd-&gt;r2t_length, cmnd-&gt;is_unsolicited_data,
+			cmnd-&gt;target_task_tag, cmnd-&gt;outstanding_r2t,
+			cmnd-&gt;hdigest, cmnd-&gt;ddigest,
+			list_empty(&amp;cmnd-&gt;pdu_list), list_empty(&amp;cmnd-&gt;hash_list));
+
+		BUG_ON(!list_empty(&amp;cmnd-&gt;list));
+	}
+	list_add(&amp;cmnd-&gt;list, &amp;head);
+	iscsi_cmnds_init_write(&amp;head);
+}
+
+static void do_send_data_rsp(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	struct istgt_cmd *data_cmnd;
+	struct scatterlist *sg = cmnd-&gt;scmd-&gt;request_buffer;
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
+	struct iscsi_data_rsp *rsp;
+	uint32_t pdusize, expsize, scsisize, size, offset, sn;
+	LIST_HEAD(send);
+
+	dprintk(&quot;%p\n&quot;, cmnd);
+	pdusize = conn-&gt;session-&gt;param.max_xmit_data_length;
+	expsize = cmnd_read_size(cmnd);
+	size = min(expsize, cmnd-&gt;scmd-&gt;request_bufflen);
+	dprintk(&quot;%u %u\n&quot;, expsize, cmnd-&gt;scmd-&gt;request_bufflen);
+	offset = 0;
+	sn = 0;
+
+	BUG_ON(!sg);
+
+	while (1) {
+		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size &lt;= pdusize);
+		data_cmnd-&gt;sg = sg;
+		rsp = (struct iscsi_data_rsp *)&amp;data_cmnd-&gt;pdu.bhs;
+
+		rsp-&gt;opcode = ISCSI_OP_SCSI_DATA_IN;
+		rsp-&gt;itt = req-&gt;itt;
+		rsp-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+		rsp-&gt;offset = offset;
+		rsp-&gt;datasn = cpu_to_be32(sn);
+
+		if (size &lt;= pdusize) {
+			data_cmnd-&gt;pdu.datasize = size;
+			rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL |
+				     ISCSI_FLAG_DATA_STATUS;
+
+			scsisize = cmnd-&gt;scmd-&gt;request_bufflen;
+			if (scsisize &lt; expsize) {
+				rsp-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				size = expsize - scsisize;
+			} else if (scsisize &gt; expsize) {
+				rsp-&gt;flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				size = scsisize - expsize;
+			} else
+				size = 0;
+			rsp-&gt;residual_count = cpu_to_be32(size);
+			list_add_tail(&amp;data_cmnd-&gt;list, &amp;send);
+
+			break;
+		}
+
+		data_cmnd-&gt;pdu.datasize = pdusize;
+
+		size -= pdusize;
+		offset += pdusize;
+		sn++;
+
+		list_add_tail(&amp;data_cmnd-&gt;list, &amp;send);
+	}
+
+	iscsi_cmnds_init_write(&amp;send);
+}
+
+static struct istgt_cmd *create_scsi_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+	struct iscsi_cmd_rsp *rsp_hdr;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr-&gt;cmd_status = SAM_STAT_GOOD;
+	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
+
+	return rsp;
+}
+
+static void send_scsi_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	uint32_t size;
+
+	rsp = create_scsi_rsp(req);
+	rsp_hdr = (struct iscsi_cmd_rsp *) &amp;rsp-&gt;pdu.bhs;
+	if ((size = cmnd_read_size(req)) != 0) {
+		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
+	}
+
+	iscsi_cmnd_init_write(rsp);
+}
+
+static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct iscsi_sense_data *sense = &amp;req-&gt;sense;
+	struct scatterlist *sg = &amp;req-&gt;sense_sg;
+	struct scatterlist *sg_data = req-&gt;scmd-&gt;request_buffer;
+	struct page *page;
+
+	page = sg_data[0].page;
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
+
+	memcpy(sense-&gt;sense_buff, req-&gt;scmd-&gt;sense_buffer,
+		sizeof(sense-&gt;sense_buff));
+	/*
+	 * this looks broken for ppc
+	 */
+	sense-&gt;length = cpu_to_be16(req-&gt;scmd-&gt;request_bufflen);
+
+	sg-&gt;page = virt_to_page(sense);
+	sg-&gt;offset = offset_in_page(sense);
+	sg-&gt;length = req-&gt;scmd-&gt;request_bufflen + sizeof(uint16_t);
+	rsp-&gt;pdu.datasize = sg-&gt;length;
+	rsp-&gt;sg = sg;
+
+	return rsp;
+}
+
+static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
+					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct scatterlist *sg = &amp;req-&gt;sense_sg;
+	struct iscsi_sense_data *sense = &amp;req-&gt;sense;
+	uint8_t *data = sense-&gt;sense_buff;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
+
+	sg-&gt;page = virt_to_page(sense);
+	sg-&gt;offset = offset_in_page(sense);
+
+	sense-&gt;length = cpu_to_be16(14);
+	data[0] = 0xf0;
+	data[2] = sense_key;
+	data[7] = 6;	// Additional sense length
+	data[12] = asc;
+	data[13] = ascq;
+
+	rsp-&gt;pdu.datasize = sizeof(uint16_t) + 14;
+	rsp-&gt;sg = sg;
+
+	sg-&gt;length = (rsp-&gt;pdu.datasize + 3) &amp; -4;
+
+	return rsp;
+}
+
+/**
+ * Free a command.
+ * Also frees the additional header.
+ *
+ * iscsi_cmnd_remove - 
+ * @cmnd: ptr to command
+ */
+
+void iscsi_cmnd_remove(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn;
+
+	if (!cmnd)
+		return;
+	dprintk(&quot;%p\n&quot;, cmnd);
+	conn = cmnd-&gt;conn;
+	kfree(cmnd-&gt;pdu.ahs);
+
+	if (!list_empty(&amp;cmnd-&gt;list)) {
+		struct iscsi_cmd *req = cmd_hdr(cmnd);
+
+		eprintk(&quot;cmnd %p still on some list?, %x %x %x %x %x %x %x %lx\n&quot;,
+			cmnd, req-&gt;opcode, req-&gt;cdb[0], req-&gt;flags, req-&gt;itt,
+			be32_to_cpu(req-&gt;data_length), req-&gt;cmdsn,
+			be32_to_cpu(cmnd-&gt;pdu.datasize), conn-&gt;state);
+
+		if (cmnd-&gt;req) {
+			struct iscsi_cmd *req = cmd_hdr(cmnd-&gt;req);
+			eprintk(&quot;%p %x %u\n&quot;, req, req-&gt;opcode, req-&gt;cdb[0]);
+		}
+		BUG();
+	}
+	list_del(&amp;cmnd-&gt;list);
+	spin_lock(&amp;conn-&gt;list_lock);
+	atomic_dec(&amp;conn-&gt;nr_cmnds);
+	list_del(&amp;cmnd-&gt;conn_list);
+	spin_unlock(&amp;conn-&gt;list_lock);
+
+	if (cmnd-&gt;scmd)
+		cmnd-&gt;done(cmnd-&gt;scmd);
+	kmem_cache_free(istgt_cmd_cache, cmnd);
+}
+
+static void cmnd_skip_pdu(struct istgt_cmd *cmnd)
+{
+/* 	struct iscsi_conn *conn = cmnd-&gt;conn; */
+/* 	struct tio *tio = cmnd-&gt;tio; */
+/* 	char *addr; */
+/* 	u32 size; */
+/* 	int i; */
+
+	BUG_ON(1);
+
+/* 	eprintk(&quot;%x %x %x %u\n&quot;, cmd_itt(cmnd), cmd_opcode(cmnd), */
+/* 		cmd_hdr(cmnd)-&gt;cdb[0], cmnd-&gt;pdu.datasize); */
+
+/* 	if (!(size = cmnd-&gt;pdu.datasize)) */
+/* 		return; */
+
+/* 	if (tio) */
+/* 		assert(tio-&gt;pg_cnt &gt; 0); */
+/* 	else */
+/* 		tio = cmnd-&gt;tio = tio_alloc(1); */
+
+/* 	addr = page_address(tio-&gt;pvec[0]); */
+/* 	assert(addr); */
+/* 	size = (size + 3) &amp; -4; */
+/* 	conn-&gt;read_size = size; */
+/* 	for (i = 0; size &gt; PAGE_CACHE_SIZE; i++, size -= PAGE_CACHE_SIZE) { */
+/* 		assert(i &lt; ISCSI_CONN_IOV_MAX); */
+/* 		conn-&gt;read_iov[i].iov_base = addr; */
+/* 		conn-&gt;read_iov[i].iov_len = PAGE_CACHE_SIZE; */
+/* 	} */
+/* 	conn-&gt;read_iov[i].iov_base = addr; */
+/* 	conn-&gt;read_iov[i].iov_len = size; */
+/* 	conn-&gt;read_msg.msg_iov = conn-&gt;read_iov; */
+/* 	conn-&gt;read_msg.msg_iovlen = ++i; */
+}
+
+static void iscsi_cmnd_reject(struct istgt_cmd *req, int reason)
+{
+/* 	struct istgt_cmd *rsp; */
+/* 	struct iscsi_reject_hdr *rsp_hdr; */
+/* 	struct tio *tio; */
+/* 	char *addr; */
+
+	BUG_ON(1);
+
+/* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
+/* 	rsp_hdr = (struct iscsi_reject_hdr *)&amp;rsp-&gt;pdu.bhs; */
+
+/* 	rsp_hdr-&gt;opcode = ISCSI_OP_REJECT; */
+/* 	rsp_hdr-&gt;ffffffff = ISCSI_RESERVED_TAG; */
+/* 	rsp_hdr-&gt;reason = reason; */
+
+/* 	rsp-&gt;tio = tio = tio_alloc(1); */
+/* 	addr = page_address(tio-&gt;pvec[0]); */
+/* 	clear_page(addr); */
+/* 	memcpy(addr, &amp;req-&gt;pdu.bhs, sizeof(struct iscsi_hdr)); */
+/* 	tio-&gt;size = rsp-&gt;pdu.datasize = sizeof(struct iscsi_hdr); */
+/* 	cmnd_skip_pdu(req); */
+
+/* 	req-&gt;pdu.bhs.opcode = ISCSI_OP_PDU_REJECT; */
+}
+
+static void cmnd_set_sn(struct istgt_cmd *cmnd, int set_stat_sn)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	struct iscsi_session *sess = conn-&gt;session;
+
+	if (set_stat_sn)
+		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn++);
+	cmnd-&gt;pdu.bhs.exp_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn);
+	cmnd-&gt;pdu.bhs.max_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn +
+						sess-&gt;max_queued_cmnds);
+}
+
+static void update_stat_sn(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	uint32_t exp_stat_sn;
+
+	cmnd-&gt;pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.exp_statsn);
+	dprintk(&quot;%x,%x\n&quot;, cmd_opcode(cmnd), exp_stat_sn);
+	if ((int32_t) (exp_stat_sn - conn-&gt;exp_stat_sn) &gt; 0 &amp;&amp;
+	    (int32_t) (exp_stat_sn - conn-&gt;stat_sn) &lt;= 0) {
+		// free pdu resources
+		cmnd-&gt;conn-&gt;exp_stat_sn = exp_stat_sn;
+	}
+}
+
+static int check_cmd_sn(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
+	uint32_t cmd_sn;
+
+	cmnd-&gt;pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.statsn);
+	dprintk(&quot;%d(%d)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
+	if ((int32_t) (cmd_sn - session-&gt;exp_cmd_sn) &gt;= 0)
+		return 0;
+	eprintk(&quot;sequence error (%x,%x)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
+	return -ISCSI_REASON_PROTOCOL_ERROR;
+}
+
+static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
+					   uint32_t itt, uint32_t ttt)
+{
+	struct list_head *head;
+	struct istgt_cmd *cmnd;
+
+	head = &amp;session-&gt;cmnd_hash[cmnd_hashfn(itt)];
+
+	list_for_each_entry(cmnd, head, hash_list) {
+		if (cmnd-&gt;pdu.bhs.itt == itt) {
+			if ((ttt != ISCSI_RESERVED_TAG) &amp;&amp; (ttt != cmnd-&gt;target_task_tag))
+				continue;
+			return cmnd;
+		}
+	}
+
+	return NULL;
+}
+
+static struct istgt_cmd *cmnd_find_hash(struct iscsi_session *session,
+					 uint32_t itt, uint32_t ttt)
+{
+	struct istgt_cmd *cmnd;
+
+	spin_lock(&amp;session-&gt;cmnd_hash_lock);
+
+	cmnd = __cmnd_find_hash(session, itt, ttt);
+
+	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
+
+	return cmnd;
+}
+
+static int cmnd_insert_hash(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
+	struct istgt_cmd *tmp;
+	struct list_head *head;
+	int err = 0;
+	uint32_t itt = cmnd-&gt;pdu.bhs.itt;
+
+	dprintk(&quot;%p:%x\n&quot;, cmnd, itt);
+	if (itt == ISCSI_RESERVED_TAG) {
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		goto out;
+	}
+
+	head = &amp;session-&gt;cmnd_hash[cmnd_hashfn(cmnd-&gt;pdu.bhs.itt)];
+
+	spin_lock(&amp;session-&gt;cmnd_hash_lock);
+
+	tmp = __cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG);
+	if (!tmp) {
+		list_add_tail(&amp;cmnd-&gt;hash_list, head);
+		set_cmd_hashed(cmnd);
+	} else
+		err = -ISCSI_REASON_TASK_IN_PROGRESS;
+
+	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
+
+	if (!err) {
+		update_stat_sn(cmnd);
+		err = check_cmd_sn(cmnd);
+	}
+
+out:
+	return err;
+}
+
+static void __cmnd_remove_hash(struct istgt_cmd *cmnd)
+{
+	list_del(&amp;cmnd-&gt;hash_list);
+}
+
+static void cmnd_remove_hash(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
+	struct istgt_cmd *tmp;
+
+	spin_lock(&amp;session-&gt;cmnd_hash_lock);
+
+	tmp = __cmnd_find_hash(session, cmnd-&gt;pdu.bhs.itt, ISCSI_RESERVED_TAG);
+
+	if (tmp &amp;&amp; tmp == cmnd)
+		__cmnd_remove_hash(tmp);
+	else
+		eprintk(&quot;%p:%x not found\n&quot;, cmnd, cmd_itt(cmnd));
+
+	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
+}
+
+static void cmnd_skip_data(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	uint32_t size;
+
+	rsp = get_rsp_cmnd(req);
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	if (cmd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
+		eprintk(&quot;unexpected response command %u\n&quot;, cmd_opcode(rsp));
+		return;
+	}
+
+	size = cmnd_write_size(req);
+	if (size) {
+		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
+	}
+	size = cmnd_read_size(req);
+	if (size) {
+		if (cmd_hdr(req)-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
+			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			rsp_hdr-&gt;bi_residual_count = cpu_to_be32(size);
+		} else {
+			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			rsp_hdr-&gt;residual_count = cpu_to_be32(size);
+		}
+	}
+	req-&gt;pdu.bhs.opcode =
+		(req-&gt;pdu.bhs.opcode &amp; ~ISCSI_OPCODE_MASK) | ISCSI_OP_SCSI_REJECT;
+
+	cmnd_skip_pdu(req);
+}
+
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct scsi_cmnd *scmd,
+			 uint32_t offset, uint32_t size)
+{
+	int idx, i;
+	char *addr;
+	struct scatterlist *sg;
+
+	dprintk(&quot;%u,%u\n&quot;, offset, size);
+
+	BUG_ON(!scmd);
+	BUG_ON(!scmd-&gt;request_buffer);
+	sg = scmd-&gt;request_buffer;
+	offset += sg-&gt;offset;
+
+	if (!(offset &lt; sg-&gt;offset + scmd-&gt;request_bufflen) ||
+	    !(offset + size &lt;= sg-&gt;offset + scmd-&gt;request_bufflen)) {
+		eprintk(&quot;%u %u %u %u&quot;, offset, size, sg-&gt;offset,
+			scmd-&gt;request_bufflen);
+		return -EIO;
+	}
+	BUG_ON(!(offset &lt; sg-&gt;offset + scmd-&gt;request_bufflen));
+	BUG_ON(!(offset + size &lt;= sg-&gt;offset + scmd-&gt;request_bufflen));
+
+	idx = offset &gt;&gt; PAGE_CACHE_SHIFT;
+	offset &amp;= ~PAGE_CACHE_MASK;
+
+	conn-&gt;read_msg.msg_iov = conn-&gt;read_iov;
+	conn-&gt;read_size = (size + 3) &amp; -4;
+	conn-&gt;read_overflow = 0;
+
+	i = 0;
+	while (1) {
+		sg = scmd-&gt;request_buffer + idx;
+		BUG_ON(!sg);
+		BUG_ON(!sg-&gt;page);
+		addr = page_address(sg-&gt;page);
+		BUG_ON(!addr);
+
+		conn-&gt;read_iov[i].iov_base =  addr + offset;
+		if (offset + size &lt;= PAGE_CACHE_SIZE) {
+			conn-&gt;read_iov[i].iov_len = size;
+			conn-&gt;read_msg.msg_iovlen = ++i;
+			break;
+		}
+		conn-&gt;read_iov[i].iov_len = PAGE_CACHE_SIZE - offset;
+		size -= conn-&gt;read_iov[i].iov_len;
+		offset = 0;
+		if (++i &gt;= ISCSI_CONN_IOV_MAX) {
+			conn-&gt;read_msg.msg_iovlen = i;
+			conn-&gt;read_overflow = size;
+			conn-&gt;read_size -= size;
+			break;
+		}
+
+		idx++;
+	}
+
+	return 0;
+}
+
+static void send_r2t(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_r2t_rsp *rsp_hdr;
+	uint32_t length, offset, burst;
+	LIST_HEAD(send);
+
+	length = req-&gt;r2t_length;
+	burst = req-&gt;conn-&gt;session-&gt;param.max_burst_length;
+	offset = be32_to_cpu(cmd_hdr(req)-&gt;data_length) - length;
+
+	do {
+		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
+		rsp-&gt;pdu.bhs.ttt = req-&gt;target_task_tag;
+
+		rsp_hdr = (struct iscsi_r2t_rsp *)&amp;rsp-&gt;pdu.bhs;
+		rsp_hdr-&gt;opcode = ISCSI_OP_R2T;
+		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+		memcpy(rsp_hdr-&gt;lun, cmd_hdr(req)-&gt;lun, 8);
+		rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
+		rsp_hdr-&gt;r2tsn = cpu_to_be32(req-&gt;r2t_sn++);
+		rsp_hdr-&gt;data_offset = cpu_to_be32(offset);
+		if (length &gt; burst) {
+			rsp_hdr-&gt;data_length = cpu_to_be32(burst);
+			length -= burst;
+			offset += burst;
+		} else {
+			rsp_hdr-&gt;data_length = cpu_to_be32(length);
+			length = 0;
+		}
+
+		dprintk(&quot;%x %u %u %u %u\n&quot;, cmd_itt(req),
+			be32_to_cpu(rsp_hdr-&gt;data_length),
+			be32_to_cpu(rsp_hdr-&gt;data_offset),
+			be32_to_cpu(rsp_hdr-&gt;r2tsn), req-&gt;outstanding_r2t);
+
+		list_add_tail(&amp;rsp-&gt;list, &amp;send);
+
+		if (++req-&gt;outstanding_r2t &gt;= req-&gt;conn-&gt;session-&gt;param.max_outstanding_r2t)
+			break;
+
+	} while (length);
+
+	iscsi_cmnds_init_write(&amp;send);
+}
+
+static void __scsi_cmnd_done(void *data)
+{
+	struct scsi_cmnd *scmd = data;
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
+
+	if (scmd-&gt;result) {
+		struct istgt_cmd *rsp;
+
+		rsp = do_create_sense_rsp(cmnd);
+		iscsi_cmnd_init_write(rsp);
+		return;
+	}
+
+	switch (req-&gt;cdb[0]) {
+	case INQUIRY:
+	case REPORT_LUNS:
+	case READ_CAPACITY:
+	case MODE_SENSE:
+	case REQUEST_SENSE:
+	case SERVICE_ACTION_IN:
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		do_send_data_rsp(cmnd);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	case START_STOP:
+	case TEST_UNIT_READY:
+	case SYNCHRONIZE_CACHE:
+	case VERIFY:
+	case VERIFY_16:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+		send_scsi_rsp(cmnd);
+		break;
+	default:
+		BUG_ON(1);
+		break;
+	}
+}
+
+/* TODO : merge this with nthread. */
+static int scsi_cmnd_done(struct scsi_cmnd *scmd,
+			  void (*done)(struct scsi_cmnd *))
+{
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
+	int err;
+
+	cmnd-&gt;done = done;
+	INIT_WORK(&amp;cmnd-&gt;work, __scsi_cmnd_done, scmd);
+	err = schedule_work(&amp;cmnd-&gt;work);
+	BUG_ON(!err);
+
+	return TGT_CMD_XMIT_OK;
+}
+
+static void tgt_scsi_cmd_create(struct istgt_cmd *req)
+{
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+	struct scsi_cmnd *scmd;
+
+	scmd = scsi_host_get_command(req-&gt;conn-&gt;session-&gt;shost, GFP_KERNEL);
+	BUG_ON(!scmd);
+	req-&gt;scmd = scmd;
+
+	memcpy(scmd-&gt;data_cmnd, req_hdr-&gt;cdb, MAX_COMMAND_SIZE);
+	scmd-&gt;request_bufflen = be32_to_cpu(req_hdr-&gt;data_length);
+	scmd-&gt;SCp.ptr = (char *) req;
+
+	/*
+	 * handle bidi later
+	 */
+	if (req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)
+		scmd-&gt;sc_data_direction = DMA_TO_DEVICE;
+	else if (req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ)
+		scmd-&gt;sc_data_direction = DMA_FROM_DEVICE;
+	else
+		scmd-&gt;sc_data_direction = DMA_NONE;
+
+	switch (req-&gt;pdu.bhs.flags &amp; ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		scmd-&gt;tag = MSG_SIMPLE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+		scmd-&gt;tag = MSG_ORDERED_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		scmd-&gt;tag = MSG_HEAD_TAG;
+		break;
+	case ISCSI_ATTR_ACA:
+		scmd-&gt;tag = MSG_SIMPLE_TAG;
+		break;
+	default:
+		scmd-&gt;tag = MSG_SIMPLE_TAG;
+	}
+
+	if (scmd-&gt;sc_data_direction == DMA_TO_DEVICE &amp;&amp;
+	    be32_to_cpu(req_hdr-&gt;data_length)) {
+		switch (req_hdr-&gt;cdb[0]) {
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_16:
+		case WRITE_VERIFY:
+			break;
+		default:
+			eprintk(&quot;%x\n&quot;, req_hdr-&gt;cdb[0]);
+			break;
+		}
+	}
+
+	scsi_tgt_queue_command(scmd, (struct scsi_lun *)req_hdr-&gt;lun, 0);
+}
+
+static void scsi_cmnd_exec(struct istgt_cmd *cmnd)
+{
+	struct scsi_cmnd *scmd = cmnd-&gt;scmd;
+
+	if (cmnd-&gt;r2t_length) {
+		if (!cmnd-&gt;is_unsolicited_data)
+			send_r2t(cmnd);
+	} else {
+		set_cmd_waitio(cmnd);
+		if (scmd) {
+			if (!cmnd-&gt;done)
+				BUG();
+			else
+				cmnd-&gt;done(scmd);
+		} else
+			tgt_scsi_cmd_create(cmnd);
+	}
+}
+
+static int noop_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	uint32_t size, tmp;
+	int i = 0, err = 0;
+
+	if (cmd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/*
+		 * We don't request a NOP-Out by sending a NOP-In.
+		 * See 10.18.2 in the draft 20.
+		 */
+		eprintk(&quot;initiator bug %x\n&quot;, cmd_itt(cmnd));
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		goto out;
+	}
+
+	if (cmd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (!(cmnd-&gt;pdu.bhs.opcode &amp; ISCSI_OP_IMMEDIATE))
+			eprintk(&quot;%s\n&quot;,&quot;initiator bug!&quot;);
+		update_stat_sn(cmnd);
+		err = check_cmd_sn(cmnd);
+		goto out;
+	} else if ((err = cmnd_insert_hash(cmnd)) &lt; 0) {
+		eprintk(&quot;ignore this request %x\n&quot;, cmd_itt(cmnd));
+		goto out;
+	}
+
+	if ((size = cmnd-&gt;pdu.datasize)) {
+		size = (size + 3) &amp; -4;
+		conn-&gt;read_msg.msg_iov = conn-&gt;read_iov;
+		if (cmnd-&gt;pdu.bhs.itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+/* 			struct tio *tio; */
+			int pg_cnt = get_pgcnt(size, 0);
+
+			BUG_ON(pg_cnt &gt;= ISCSI_CONN_IOV_MAX);
+			BUG_ON(1);
+/* 			cmnd-&gt;tio = tio = tio_alloc(pg_cnt); */
+/* 			tio_set(tio, size, 0); */
+
+/* 			for (i = 0; i &lt; pg_cnt; i++) { */
+/* 				conn-&gt;read_iov[i].iov_base */
+/* 					= page_address(tio-&gt;pvec[i]); */
+/* 				tmp = min_t(u32, size, PAGE_CACHE_SIZE); */
+/* 				conn-&gt;read_iov[i].iov_len = tmp; */
+/* 				conn-&gt;read_size += tmp; */
+/* 				size -= tmp; */
+/* 			} */
+		} else {
+			for (i = 0; i &lt; ISCSI_CONN_IOV_MAX; i++) {
+				conn-&gt;read_iov[i].iov_base = dummy_data;
+				tmp = min_t(uint32_t, size, sizeof(dummy_data));
+				conn-&gt;read_iov[i].iov_len = tmp;
+				conn-&gt;read_size += tmp;
+				size -= tmp;
+			}
+		}
+		BUG_ON(size);
+		conn-&gt;read_overflow = size;
+		conn-&gt;read_msg.msg_iovlen = i;
+	}
+
+out:
+	return err;
+}
+
+static uint32_t get_next_ttt(struct iscsi_session *session)
+{
+	uint32_t ttt;
+
+	if (session-&gt;next_ttt == ISCSI_RESERVED_TAG)
+		session-&gt;next_ttt++;
+	ttt = session-&gt;next_ttt++;
+
+	return cpu_to_be32(ttt);
+}
+
+static void scsi_cmnd_start(struct iscsi_conn *conn, struct istgt_cmd *req)
+{
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+
+	dprintk(&quot;scsi command: %02x\n&quot;, req_hdr-&gt;cdb[0]);
+
+	switch (req_hdr-&gt;cdb[0]) {
+	case SERVICE_ACTION_IN:
+		if ((req_hdr-&gt;cdb[1] &amp; 0x1f) != 0x10)
+			goto error;
+
+	case INQUIRY:
+	case REPORT_LUNS:
+	case TEST_UNIT_READY:
+	case SYNCHRONIZE_CACHE:
+	case VERIFY:
+	case VERIFY_16:
+	case START_STOP:
+	case READ_CAPACITY:
+	case MODE_SENSE:
+	case REQUEST_SENSE:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+	case READ_6:
+	case READ_10:
+	case READ_16:
+	{
+		if (!(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ||
+		      req-&gt;pdu.datasize) {
+			/* unexpected unsolicited data */
+			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
+			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
+			cmnd_skip_data(req);
+		}
+		break;
+	}
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	{
+		struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
+
+		/*
+		 * We don't know this command arrives in order,
+		 * however we need to allocate buffer for immediate
+		 * and unsolicited data. tgt will not start to perform
+		 * this command until we call cmd-&gt;done so we don't
+		 * need to worry about the order of the command.
+		 */
+		tgt_scsi_cmd_create(req);
+		wait_for_completion(&amp;req-&gt;event);
+
+		req-&gt;r2t_length = be32_to_cpu(req_hdr-&gt;data_length) - req-&gt;pdu.datasize;
+		req-&gt;is_unsolicited_data = !(req_hdr-&gt;flags &amp;
+						ISCSI_FLAG_CMD_FINAL);
+		req-&gt;target_task_tag = get_next_ttt(conn-&gt;session);
+
+		if (!param-&gt;immediate_data &amp;&amp; req-&gt;pdu.datasize)
+			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
+
+		if (param-&gt;initial_r2t &amp;&amp;
+		    !(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
+			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
+
+		if (req_hdr-&gt;cdb[0] == WRITE_VERIFY &amp;&amp; req_hdr-&gt;cdb[1] &amp; 0x02)
+			eprintk(&quot;Verification is ignored %x\n&quot;, cmd_itt(req));
+
+		if (req-&gt;pdu.datasize) {
+			if (cmnd_recv_pdu(conn, req-&gt;scmd, 0,
+					  req-&gt;pdu.datasize) &lt; 0)
+				BUG_ON(1);
+		}
+		break;
+	}
+	error:
+	default:
+		eprintk(&quot;Unsupported %x\n&quot;, req_hdr-&gt;cdb[0]);
+		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
+		cmnd_skip_data(req);
+		break;
+	}
+
+	return;
+}
+
+static void data_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	struct iscsi_data *req = (struct iscsi_data *)&amp;cmnd-&gt;pdu.bhs;
+	struct istgt_cmd *scsi_cmnd = NULL;
+	uint32_t offset = be32_to_cpu(req-&gt;offset);
+
+	update_stat_sn(cmnd);
+
+	cmnd-&gt;req = scsi_cmnd = cmnd_find_hash(conn-&gt;session, req-&gt;itt, req-&gt;ttt);
+	if (!scsi_cmnd) {
+		eprintk(&quot;unable to find scsi task %x %x\n&quot;,
+			cmd_itt(cmnd), cmd_ttt(cmnd));
+		goto skip_data;
+	}
+
+	if (scsi_cmnd-&gt;r2t_length &lt; cmnd-&gt;pdu.datasize) {
+		eprintk(&quot;invalid data len %x %u %u\n&quot;,
+			cmd_itt(scsi_cmnd), cmnd-&gt;pdu.datasize, scsi_cmnd-&gt;r2t_length);
+		goto skip_data;
+	}
+
+	if (scsi_cmnd-&gt;r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
+		eprintk(&quot;%x %u %u %u\n&quot;, cmd_itt(scsi_cmnd), scsi_cmnd-&gt;r2t_length,
+			offset,	cmnd_write_size(scsi_cmnd));
+		goto skip_data;
+	}
+
+	scsi_cmnd-&gt;r2t_length -= cmnd-&gt;pdu.datasize;
+
+	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/* unsolicited burst data */
+		if (scsi_cmnd-&gt;pdu.bhs.flags &amp; ISCSI_FLAG_CMD_FINAL) {
+			eprintk(&quot;unexpected data from %x %x\n&quot;,
+				cmd_itt(cmnd), cmd_ttt(cmnd));
+			goto skip_data;
+		}
+	}
+
+	dprintk(&quot;%u %p %p %u %u\n&quot;, req-&gt;ttt, cmnd, scsi_cmnd,
+		offset, cmnd-&gt;pdu.datasize);
+
+	if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;scmd, offset, cmnd-&gt;pdu.datasize) &lt; 0)
+		goto skip_data;
+	return;
+
+skip_data:
+	cmnd-&gt;pdu.bhs.opcode = ISCSI_OP_DATA_REJECT;
+	cmnd_skip_pdu(cmnd);
+	return;
+}
+
+static void data_out_end(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	struct iscsi_data *req = (struct iscsi_data *) &amp;cmnd-&gt;pdu.bhs;
+	struct istgt_cmd *scsi_cmnd;
+	uint32_t offset;
+
+	BUG_ON(!cmnd);
+	scsi_cmnd = cmnd-&gt;req;
+	BUG_ON(!scsi_cmnd);
+
+	if (conn-&gt;read_overflow) {
+		eprintk(&quot;%x %u\n&quot;, cmd_itt(cmnd), conn-&gt;read_overflow);
+		offset = be32_to_cpu(req-&gt;offset);
+		offset += cmnd-&gt;pdu.datasize - conn-&gt;read_overflow;
+		if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;scmd, offset,
+				  conn-&gt;read_overflow) &lt; 0)
+			BUG_ON(1);
+		return;
+	}
+
+	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) {
+			scsi_cmnd-&gt;is_unsolicited_data = 0;
+			if (!cmd_pending(scsi_cmnd))
+				scsi_cmnd_exec(scsi_cmnd);
+		}
+	} else {
+		/* TODO : proper error handling */
+		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) &amp;&amp;
+		    scsi_cmnd-&gt;r2t_length == 0)
+			eprintk(&quot;initiator error %x\n&quot;, cmd_itt(scsi_cmnd));
+
+		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
+			goto out;
+
+		scsi_cmnd-&gt;outstanding_r2t--;
+
+		if (scsi_cmnd-&gt;r2t_length == 0)
+			BUG_ON(!list_empty(&amp;scsi_cmnd-&gt;pdu_list));
+
+		scsi_cmnd_exec(scsi_cmnd);
+	}
+
+out:
+	iscsi_cmnd_remove(cmnd);
+	return;
+}
+
+/* static int __cmnd_abort(struct istgt_cmd *cmnd) */
+/* { */
+/* 	if (!cmnd_waitio(cmnd)) { */
+/* 		cmnd_release(cmnd, 1); */
+/* 		return 0; */
+/* 	} else */
+/* 		return -ISCSI_RESPONSE_UNKNOWN_TASK; */
+/* } */
+
+/* static int cmnd_abort(struct iscsi_session *session, u32 itt) */
+/* { */
+/* 	struct istgt_cmd *cmnd; */
+/* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
+
+/* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
+/* 		eprintk(&quot;%x %x %x %u %u %u %u\n&quot;, cmd_itt(cmnd), cmd_opcode(cmnd), */
+/* 			cmnd-&gt;r2t_length, cmnd_scsicode(cmnd), */
+/* 			cmnd_write_size(cmnd), cmnd-&gt;is_unsolicited_data, */
+/* 			cmnd-&gt;outstanding_r2t); */
+/* 		err = __cmnd_abort(cmnd); */
+/* 	} */
+
+/* 	return err; */
+/* } */
+
+/* static int target_reset(struct istgt_cmd *req, u32 lun, int all) */
+/* { */
+/* 	struct iscsi_target *target = req-&gt;conn-&gt;session-&gt;target; */
+/* 	struct iscsi_session *session; */
+/* 	struct iscsi_conn *conn; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
+
+/* 	list_for_each_entry(session, &amp;target-&gt;session_list, list) { */
+/* 		list_for_each_entry(conn, &amp;session-&gt;conn_list, list) { */
+/* 			list_for_each_entry_safe(cmnd, tmp, &amp;conn-&gt;pdu_list, conn_list) { */
+/* 				if (cmnd == req) */
+/* 					continue; */
+
+/* 				if (all) */
+/* 					__cmnd_abort(cmnd); */
+/* 				else if (translate_lun(cmd_hdr(cmnd)-&gt;lun) == lun) */
+/* 					__cmnd_abort(cmnd); */
+/* 			} */
+/* 		} */
+/* 	} */
+
+/* 	return 0; */
+/* } */
+
+/* static void task_set_abort(struct istgt_cmd *req) */
+/* { */
+/* 	struct iscsi_session *session = req-&gt;conn-&gt;session; */
+/* 	struct iscsi_conn *conn; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
+
+/* 	list_for_each_entry(conn, &amp;session-&gt;conn_list, list) { */
+/* 		list_for_each_entry_safe(cmnd, tmp, &amp;conn-&gt;pdu_list, conn_list) { */
+/* 			if (cmnd != req) */
+/* 				__cmnd_abort(cmnd); */
+/* 		} */
+/* 	} */
+/* } */
+
+static void execute_task_management(struct istgt_cmd *req)
+{
+/* 	struct iscsi_conn *conn = req-&gt;conn; */
+/* 	struct iscsi_target *target = conn-&gt;session-&gt;target; */
+	struct istgt_cmd *rsp;
+	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&amp;req-&gt;pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
+	int function = req_hdr-&gt;flags &amp; ISCSI_FLAG_TM_FUNC_MASK;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+	rsp_hdr = (struct iscsi_tm_rsp *)&amp;rsp-&gt;pdu.bhs;
+
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
+/* 	rsp_hdr-&gt;response = ISCSI_TMF_RSP_COMPLETE; */
+	rsp_hdr-&gt;response = ISCSI_TMF_RSP_REJECTED;
+
+	eprintk(&quot;%x %d %x\n&quot;, cmd_itt(req), function, req_hdr-&gt;rtt);
+
+/* 	switch (function) { */
+/* 	case ISCSI_FUNCTION_ABORT_TASK: */
+/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
+/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
+/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
+/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
+/* 		lun = translate_lun(req_hdr-&gt;lun); */
+/* 		if (!volume_lookup(target, lun)) { */
+/* 			rsp_hdr-&gt;response = ISCSI_RESPONSE_UNKNOWN_LUN; */
+/* 			goto out; */
+/* 		} */
+/* 	} */
+
+/* 	switch (function) { */
+/* 	case ISCSI_FUNCTION_ABORT_TASK: */
+/* 		if ((err = cmnd_abort(conn-&gt;session, req_hdr-&gt;rtt)) &lt; 0) */
+/* 			rsp_hdr-&gt;response = -err; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
+/* 		task_set_abort(req); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
+/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
+/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
+/* 		target_reset(req, translate_lun(req_hdr-&gt;lun), 0); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_TARGET_WARM_RESET: */
+/* 	case ISCSI_FUNCTION_TARGET_COLD_RESET: */
+/* 		target_reset(req, 0, 1); */
+/* 		if (function == ISCSI_FUNCTION_TARGET_COLD_RESET) */
+/* 			set_cmnd_close(rsp); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_TASK_REASSIGN: */
+/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	default: */
+/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_REJECTED; */
+/* 		break; */
+/* 	} */
+/* out: */
+	iscsi_cmnd_init_write(rsp);
+}
+
+static void noop_out_exec(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_nopin *rsp_hdr;
+
+	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+		rsp_hdr = (struct iscsi_nopin *)&amp;rsp-&gt;pdu.bhs;
+		rsp_hdr-&gt;opcode = ISCSI_OP_NOOP_IN;
+		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+		rsp_hdr-&gt;itt = req-&gt;pdu.bhs.itt;
+		rsp_hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+
+/* 		if (req-&gt;pdu.datasize) */
+/* 			assert(req-&gt;tio); */
+/* 		else */
+/* 			assert(!req-&gt;tio); */
+
+/* 		if (req-&gt;tio) { */
+/* 			tio_get(req-&gt;tio); */
+/* 			rsp-&gt;tio = req-&gt;tio; */
+/* 		} */
+
+		BUG_ON(get_pgcnt(req-&gt;pdu.datasize, 0) &gt;= ISCSI_CONN_IOV_MAX);
+		rsp-&gt;pdu.datasize = req-&gt;pdu.datasize;
+		iscsi_cmnd_init_write(rsp);
+	} else
+		iscsi_cmnd_remove(req);
+}
+
+static void logout_exec(struct istgt_cmd *req)
+{
+	struct iscsi_logout *req_hdr;
+	struct istgt_cmd *rsp;
+	struct iscsi_logout_rsp *rsp_hdr;
+
+	req_hdr = (struct iscsi_logout *)&amp;req-&gt;pdu.bhs;
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+	rsp_hdr = (struct iscsi_logout_rsp *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr-&gt;opcode = ISCSI_OP_LOGOUT_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
+	set_cmd_close(rsp);
+	iscsi_cmnd_init_write(rsp);
+}
+
+static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
+{
+	dprintk(&quot;%p,%x,%u\n&quot;, cmnd, cmd_opcode(cmnd),
+		cmnd-&gt;pdu.bhs.statsn);
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_OUT:
+		noop_out_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD:
+		scsi_cmnd_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+		execute_task_management(cmnd);
+		break;
+	case ISCSI_OP_LOGOUT:
+		logout_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_REJECT:
+		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
+		break;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		break;
+	default:
+		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
+		break;
+	}
+}
+
+static void __cmnd_send_pdu(struct iscsi_conn *conn, struct scatterlist *sg,
+			    uint32_t offset, uint32_t size)
+{
+/* 	dprintk(D_GENERIC, &quot;%p %u,%u\n&quot;, tio, offset, size); */
+	offset += sg-&gt;offset;
+
+/* 	assert(offset &lt;= sg-&gt;offset + tio-&gt;size); */
+/* 	assert(offset + size &lt;= tio-&gt;offset + tio-&gt;size); */
+
+	conn-&gt;write_sg = sg;
+	conn-&gt;write_offset = offset;
+	conn-&gt;write_size += size;
+}
+
+static void cmnd_send_pdu(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	uint32_t size;
+
+	if (!cmnd-&gt;pdu.datasize)
+		return;
+
+	size = (cmnd-&gt;pdu.datasize + 3) &amp; -4;
+	BUG_ON(!cmnd-&gt;sg);
+	__cmnd_send_pdu(conn, cmnd-&gt;sg, 0, size);
+}
+
+static void set_cork(struct socket *sock, int on)
+{
+	int opt = on;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(get_ds());
+	sock-&gt;ops-&gt;setsockopt(sock, SOL_TCP, TCP_CORK, (void *)&amp;opt, sizeof(opt));
+	set_fs(oldfs);
+}
+
+void cmnd_release(struct istgt_cmd *cmnd, int force)
+{
+	struct istgt_cmd *req, *rsp;
+	int is_last = 0;
+
+	if (!cmnd)
+		return;
+
+	req = cmnd-&gt;req;
+	is_last = cmd_final(cmnd);
+
+	if (force) {
+		while (!list_empty(&amp;cmnd-&gt;pdu_list)) {
+			rsp = list_entry(cmnd-&gt;pdu_list.next, struct istgt_cmd, pdu_list);
+			list_del_init(&amp;rsp-&gt;list);
+			list_del(&amp;rsp-&gt;pdu_list);
+			iscsi_cmnd_remove(rsp);
+		}
+		list_del_init(&amp;cmnd-&gt;list);
+	}
+
+	if (cmd_hashed(cmnd))
+		cmnd_remove_hash(cmnd);
+
+	list_del_init(&amp;cmnd-&gt;pdu_list);
+	iscsi_cmnd_remove(cmnd);
+
+	if (is_last) {
+		BUG_ON(force);
+		BUG_ON(!req);
+		cmnd_release(req, 0);
+	}
+
+	return;
+}
+
+void cmnd_tx_start(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	struct iovec *iop;
+
+	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
+	BUG_ON(!cmnd);
+	iscsi_cmnd_set_length(&amp;cmnd-&gt;pdu);
+
+	set_cork(conn-&gt;sock, 1);
+
+	conn-&gt;write_iop = iop = conn-&gt;write_iov;
+	iop-&gt;iov_base = &amp;cmnd-&gt;pdu.bhs;
+	iop-&gt;iov_len = sizeof(cmnd-&gt;pdu.bhs);
+	iop++;
+	conn-&gt;write_size = sizeof(cmnd-&gt;pdu.bhs);
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_IN:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD_RSP:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_TEXT_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_SCSI_DATA_IN:
+	{
+		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&amp;cmnd-&gt;pdu.bhs;
+		uint32_t offset;
+
+		cmnd_set_sn(cmnd, (rsp-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
+		offset = rsp-&gt;offset;
+		rsp-&gt;offset = cpu_to_be32(offset);
+		BUG_ON(!cmnd-&gt;sg);
+		__cmnd_send_pdu(conn, cmnd-&gt;sg, offset, cmnd-&gt;pdu.datasize);
+		break;
+	}
+	case ISCSI_OP_LOGOUT_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_R2T:
+		cmnd_set_sn(cmnd, 0);
+		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn);
+		break;
+	case ISCSI_OP_ASYNC_EVENT:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_REJECT:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	default:
+		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
+		break;
+	}
+
+	iop-&gt;iov_len = 0;
+	// move this?
+	conn-&gt;write_size = (conn-&gt;write_size + 3) &amp; -4;
+}
+
+void cmnd_tx_end(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+
+	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_SCSI_CMD_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_R2T:
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
+	case ISCSI_OP_SCSI_DATA_IN:
+	case ISCSI_OP_LOGOUT_RSP:
+		break;
+	default:
+		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
+		BUG_ON(1);
+		break;
+	}
+
+	if (cmd_close(cmnd))
+		conn_close(conn);
+
+	list_del_init(&amp;cmnd-&gt;list);
+	set_cork(cmnd-&gt;conn-&gt;sock, 0);
+}
+
+/**
+ * Push the command for execution.
+ * This functions reorders the commands.
+ * Called from the read thread.
+ *
+ * iscsi_session_push_cmnd - 
+ * @cmnd: ptr to command
+ */
+
+static void iscsi_session_push_cmnd(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
+	struct list_head *entry;
+	uint32_t cmd_sn;
+
+	dprintk(&quot;%p:%x %u,%u\n&quot;,
+		cmnd, cmd_opcode(cmnd), cmnd-&gt;pdu.bhs.statsn,
+		session-&gt;exp_cmd_sn);
+
+	if (cmnd-&gt;pdu.bhs.opcode &amp; ISCSI_OP_IMMEDIATE) {
+		iscsi_cmnd_exec(cmnd);
+		return;
+	}
+
+	cmd_sn = cmnd-&gt;pdu.bhs.statsn;
+	if (cmd_sn == session-&gt;exp_cmd_sn) {
+		while (1) {
+			session-&gt;exp_cmd_sn = ++cmd_sn;
+			iscsi_cmnd_exec(cmnd);
+
+			if (list_empty(&amp;session-&gt;pending_list))
+				break;
+			cmnd = list_entry(session-&gt;pending_list.next, struct istgt_cmd, list);
+			if (cmnd-&gt;pdu.bhs.statsn != cmd_sn)
+				break;
+/* 			eprintk(&quot;find out-of-order %x %u %u\n&quot;, */
+/* 				cmd_itt(cmnd), cmd_sn, cmnd-&gt;pdu.bhs.statsn); */
+			list_del_init(&amp;cmnd-&gt;list);
+			clear_cmd_pending(cmnd);
+		}
+	} else {
+/* 		eprintk(&quot;out-of-order %x %u %u\n&quot;, */
+/* 			cmd_itt(cmnd), cmd_sn, session-&gt;exp_cmd_sn); */
+
+		set_cmd_pending(cmnd);
+		if (before(cmd_sn, session-&gt;exp_cmd_sn)) /* close the conn */
+			eprintk(&quot;unexpected cmd_sn (%u,%u)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
+
+		if (after(cmd_sn, session-&gt;exp_cmd_sn + session-&gt;max_queued_cmnds))
+			eprintk(&quot;too large cmd_sn (%u,%u)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
+
+		list_for_each(entry, &amp;session-&gt;pending_list) {
+			struct istgt_cmd *tmp = list_entry(entry, struct istgt_cmd, list);
+			if (before(cmd_sn, tmp-&gt;pdu.bhs.statsn))
+				break;
+		}
+
+		BUG_ON(!list_empty(&amp;cmnd-&gt;list));
+
+		list_add_tail(&amp;cmnd-&gt;list, entry);
+	}
+}
+
+static int check_segment_length(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
+
+	if (cmnd-&gt;pdu.datasize &gt; param-&gt;max_recv_data_length) {
+		eprintk(&quot;too lond data %x %u %u\n&quot;, cmd_itt(cmnd),
+			cmnd-&gt;pdu.datasize, param-&gt;max_recv_data_length);
+
+		if (get_pgcnt(cmnd-&gt;pdu.datasize, 0) &gt; ISCSI_CONN_IOV_MAX) {
+			conn_close(conn);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+void cmnd_rx_start(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+	int err = 0;
+
+	if (check_segment_length(cmnd) &lt; 0)
+		return;
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_OUT:
+		err = noop_out_start(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD:
+		if (!(err = cmnd_insert_hash(cmnd)))
+			scsi_cmnd_start(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+		err = cmnd_insert_hash(cmnd);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		data_out_start(conn, cmnd);
+		break;
+	case ISCSI_OP_LOGOUT:
+		err = cmnd_insert_hash(cmnd);
+		break;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
+		break;
+	default:
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
+		break;
+	}
+
+	if (err &lt; 0) {
+		eprintk(&quot;%x %x %d\n&quot;, cmd_opcode(cmnd), cmd_itt(cmnd), err);
+		iscsi_cmnd_reject(cmnd, -err);
+	}
+}
+
+void cmnd_rx_end(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd-&gt;conn;
+
+	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_SCSI_REJECT:
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_CMD:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_LOGOUT:
+		iscsi_session_push_cmnd(cmnd);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		data_out_end(conn, cmnd);
+		break;
+	case ISCSI_OP_SNACK:
+		break;
+	case ISCSI_OP_PDU_REJECT:
+		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
+		break;
+	case ISCSI_OP_DATA_REJECT:
+		cmnd_release(cmnd, 0);
+		break;
+	default:
+		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
+		BUG();
+		break;
+	}
+}
+
+static int buffer_ready(struct scsi_cmnd *scmd,
+			void (*done)(struct scsi_cmnd *))
+{
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
+
+	cmnd-&gt;done = done;
+	complete(&amp;cmnd-&gt;event);
+	return 0;
+}
+
+
+static struct iscsi_sess_param default_session_param = {
+	.initial_r2t = 1,
+	.immediate_data = 1,
+	.max_connections = 1,
+	.max_recv_data_length = 8192,
+	.max_xmit_data_length = 8192,
+	.max_burst_length = 262144,
+	.first_burst_length = 65536,
+	.default_wait_time = 2,
+	.default_retain_time = 20,
+	.max_outstanding_r2t = 1,
+	.data_pdu_inorder = 1,
+	.data_sequence_inorder = 1,
+	.error_recovery_level = 0,
+	.header_digest = DIGEST_NONE,
+	.data_digest = DIGEST_NONE,
+	.ofmarker = 0,
+	.ifmarker = 0,
+	.ofmarkint = 2048,
+	.ifmarkint = 2048,
+};
+
+static struct iscsi_trgt_param default_target_param = {
+	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
+};
+
+static struct iscsi_transport istgt_transport;
+
+static struct iscsi_cls_session *
+istgt_session_create(struct scsi_transport_template *scsit,
+		     uint32_t initial_cmdsn, uint32_t *sid)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_session *session;
+	nt err, i;
+
+	shost = iscsi_transport_create_session(scsit, &amp;istgt_transport);
+	if (!shost)
+		return NULL;
+
+	session = iscsi_hostdata(shost-&gt;hostdata);
+	memset(session, 0, sizeof(*session));
+
+	dprintk(&quot;%p %u %&quot; PRIx64 &quot;\n&quot;, session, session-&gt;shost-&gt;host_no);
+
+	session-&gt;shost = shost;
+	*sid = session-&gt;sid = shost-&gt;host_no;
+	memcpy(&amp;session-&gt;param, &amp;default_session_param,
+	       sizeof(default_session_param));
+	memcpy(&amp;session-&gt;trgt_param, &amp;default_target_param,
+	       sizeof(default_target_param));
+	init_MUTEX(&amp;session-&gt;target_sem);
+	INIT_LIST_HEAD(&amp;session-&gt;session_list);
+
+	session-&gt;max_queued_cmnds = session-&gt;trgt_param.queued_cmnds;
+	session-&gt;exp_cmd_sn = initial_cmdsn + 1;
+	session-&gt;max_cmd_sn = initial_cmdsn + 1;
+
+	INIT_LIST_HEAD(&amp;session-&gt;conn_list);
+	INIT_LIST_HEAD(&amp;session-&gt;pending_list);
+
+	spin_lock_init(&amp;session-&gt;cmnd_hash_lock);
+	for (i = 0; i &lt; ARRAY_SIZE(session-&gt;cmnd_hash); i++)
+		INIT_LIST_HEAD(&amp;session-&gt;cmnd_hash[i]);
+
+	session-&gt;next_ttt = 1;
+
+	nthread_init(session);
+	err = nthread_start(session);
+	if (err)
+		goto destroy_session;
+
+	return hostdata_session(shost-&gt;hostdata);
+
+destroy_session:
+	iscsi_transport_destroy_session(shost);
+	return NULL;
+}
+
+static void istgt_session_destroy(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	int i;
+
+	dprintk(&quot;%&quot; PRIx64 &quot;\n&quot;, session-&gt;sid);
+
+	if (!list_empty(&amp;session-&gt;conn_list)) {
+		eprintk(&quot;%&quot; PRIx64 &quot; still have connections\n&quot;, session-&gt;sid);
+		BUG();
+	}
+
+	BUG_ON(!list_empty(&amp;session-&gt;conn_list));
+
+	for (i = 0; i &lt; ARRAY_SIZE(session-&gt;cmnd_hash); i++)
+		BUG_ON(!list_empty(&amp;session-&gt;cmnd_hash[i]));
+
+	down(&amp;session-&gt;target_sem);
+	up(&amp;session-&gt;target_sem);
+
+	nthread_stop(session);
+	iscsi_transport_destroy_session(shost);
+}
+
+static int
+istgt_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param key, uint32_t *value)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
+
+	switch(key) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		*value = param-&gt;max_recv_data_length;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		*value = param-&gt;max_xmit_data_length;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		*value = param-&gt;header_digest;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		*value = param-&gt;data_digest;
+		break;
+	default:
+		return ISCSI_ERR_PARAM_NOT_FOUND;
+	}
+
+	return 0;
+}
+
+static int
+istgt_session_get_param(struct iscsi_cls_session *cls_session,
+			enum iscsi_param key, uint32_t *value)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	struct iscsi_sess_param *param = &amp;session-&gt;param;
+
+	switch(key) {
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		*value = param-&gt;initial_r2t;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		*value = param-&gt;max_outstanding_r2t;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		*value = param-&gt;immediate_data;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		*value = param-&gt;first_burst_length;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		*value = param-&gt;max_burst_length;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		*value = param-&gt;data_pdu_inorder;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		*value = param-&gt;data_sequence_inorder;
+		break;
+	case ISCSI_PARAM_ERL:
+		*value = param-&gt;error_recovery_level;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		*value = param-&gt;ifmarker;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		*value = param-&gt;ofmarker;
+		break;
+	default:
+		return ISCSI_ERR_PARAM_NOT_FOUND;
+	}
+
+	return 0;
+}
+
+static int
+istgt_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param key,
+		uint32_t value)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_sess_param *param = &amp;session-&gt;param;
+
+	switch(key) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		param-&gt;max_recv_data_length = value;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		param-&gt;max_xmit_data_length = value;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		param-&gt;header_digest = value;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		param-&gt;data_digest = value;
+		break;
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		param-&gt;initial_r2t = value;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		param-&gt;max_outstanding_r2t = value;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		param-&gt;immediate_data = value;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		param-&gt;first_burst_length = value;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		param-&gt;max_burst_length = value;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		param-&gt;data_pdu_inorder = value;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		param-&gt;data_sequence_inorder = value;
+		break;
+	case ISCSI_PARAM_ERL:
+		param-&gt;error_recovery_level = value;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		param-&gt;ifmarker = value;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		param-&gt;ofmarker = value;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct scsi_host_template istgt_sht = {
+	.name			= THIS_NAME,
+	.module			= THIS_MODULE,
+	.can_queue		= DEFAULT_NR_QUEUED_CMNDS,
+	.sg_tablesize		= SG_ALL,
+	.max_sectors		= 65536,	/* really no limit */
+	.use_clustering		= DISABLE_CLUSTERING, /* do we support this,  ihave to double check */
+	.transfer_response	= scsi_cmnd_done,
+	.transfer_data		= buffer_ready,
+};
+
+static struct iscsi_transport istgt_transport = {
+	.owner			= THIS_MODULE,
+	.name			= &quot;tcp_tgt&quot;,
+	.host_template		= &amp;istgt_sht,
+	.hostdata_size		= sizeof(struct iscsi_session),
+	.max_conn		= 1,
+	.max_cmd_len		= 16,
+	.create_session		= istgt_session_create,
+	.destroy_session	= istgt_session_destroy, 
+	.create_conn		= istgt_conn_create,
+	.destroy_conn		= istgt_conn_destroy,
+	.bind_conn		= istgt_conn_bind,
+	.start_conn		= istgt_conn_start,
+	.set_param		= istgt_set_param,
+	.get_session_param	= istgt_session_get_param,
+	.get_conn_param		= istgt_conn_get_param,
+
+};
+
+static void istgt_exit(void)
+{
+	kmem_cache_destroy(istgt_cmd_cache);
+	iscsi_unregister_transport(&amp;istgt_transport);
+}
+
+static int istgt_init(void)
+{
+	printk(&quot;iSCSI Target Software for Linux Target Framework %s\n&quot;,
+	       VERSION_STRING);
+
+	istgt_cmd_cache = kmem_cache_create(&quot;istgt_cmd&quot;,
+					    sizeof(struct istgt_cmd),
+					    0, 0, NULL, NULL);
+	if (!istgt_cmd_cache)
+		return -ENOMEM;
+
+	if (!iscsi_register_transport(&amp;istgt_transport))
+		goto free_cmd_cache;
+
+	return 0;
+
+free_cmd_cache:
+	kmem_cache_destroy(istgt_cmd_cache);
+	return -ENOMEM;
+
+}
+
+module_init(istgt_init);
+module_exit(istgt_exit);
+
+MODULE_LICENSE(&quot;GPL&quot;);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000233.html">[Stgt-svn] r246 - branches/use-scsi-ml/usr
</A></li>
	<LI>Next message: <A HREF="000235.html">[Stgt-svn] r248 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#234">[ date ]</a>
              <a href="thread.html#234">[ thread ]</a>
              <a href="subject.html#234">[ subject ]</a>
              <a href="author.html#234">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
