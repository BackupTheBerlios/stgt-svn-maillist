<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r246 - branches/use-scsi-ml/usr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-January/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r246%20-%20branches/use-scsi-ml/usr&In-Reply-To=%3C200601281056.k0SAufJF024296%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000232.html">
   <LINK REL="Next"  HREF="000234.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r246 - branches/use-scsi-ml/usr</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r246%20-%20branches/use-scsi-ml/usr&In-Reply-To=%3C200601281056.k0SAufJF024296%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r246 - branches/use-scsi-ml/usr">tomo at berlios.de
       </A><BR>
    <I>Sat Jan 28 11:56:41 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000232.html">[Stgt-svn] r245 - branches/use-scsi-ml/kernel
</A></li>
        <LI>Next message: <A HREF="000234.html">[Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#233">[ date ]</a>
              <a href="thread.html#233">[ thread ]</a>
              <a href="subject.html#233">[ subject ]</a>
              <a href="author.html#233">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-01-28 11:56:32 +0100 (Sat, 28 Jan 2006)
New Revision: 246

Added:
   branches/use-scsi-ml/usr/target.c
Modified:
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/dl.h
   branches/use-scsi-ml/usr/ipc.c
   branches/use-scsi-ml/usr/log.c
   branches/use-scsi-ml/usr/log.h
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/tgt_device.c
   branches/use-scsi-ml/usr/tgtadm.c
   branches/use-scsi-ml/usr/tgtadm.h
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Just sync with the main trunk.

Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/Makefile	2006-01-28 10:56:32 UTC (rev 246)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o tgt_device.o netlink.o ipc.o dl.o mgmt.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/dl.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -25,16 +25,9 @@
 #include &quot;dl.h&quot;
 #include &quot;tgt_sysfs.h&quot;
 
-struct driver_info {
-	char *name;
-	char *proto;
-	void *dl;
-	void *pdl;
-};
+struct driver_info dlinfo[MAX_DL_HANDLES];
 
-static struct driver_info dinfo[MAX_DL_HANDLES];
-
-char *typeid_to_name(int typeid)
+char *typeid_to_name(struct driver_info *dinfo, int typeid)
 {
 	return dinfo[typeid].name;
 }
@@ -71,7 +64,7 @@
 	return strcmp(dir-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(dir-&gt;d_name, &quot;..&quot;);
 }
 
-int dl_init(void)
+int dl_init(struct driver_info *dinfo)
 {
 	int i, nr, idx;
 	char path[PATH_MAX], *p;
@@ -116,38 +109,21 @@
 	return 0;
 }
 
-void dl_config_load(void)
+void *dl_poll_init_fn(struct driver_info *dinfo, int idx)
 {
-	void (* fn)(void);
-	int i;
-
-	for (i = 0; i &lt; MAX_DL_HANDLES; i++) {
-		if (!dinfo[i].dl)
-			continue;
-
-		fn = dlsym(dinfo[i].dl, &quot;initial_config_load&quot;);
-		if (!fn)
-			eprintf(&quot;%s\n&quot;, dlerror());
-		else
-			fn();
-	}
-}
-
-void *dl_poll_init_fn(int idx)
-{
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, &quot;poll_init&quot;);
 	return NULL;
 }
 
-void *dl_poll_fn(int idx)
+void *dl_poll_fn(struct driver_info *dinfo, int idx)
 {
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, &quot;poll_event&quot;);
 	return NULL;
 }
 
-void *dl_ipc_fn(int typeid)
+void *dl_ipc_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, &quot;ipc_mgmt&quot;);
@@ -155,7 +131,7 @@
 	return NULL;
 }
 
-void *dl_proto_cmd_process(int tid, int typeid)
+void *dl_proto_cmd_process(struct driver_info *dinfo, int tid, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, &quot;cmd_process&quot;);
@@ -163,15 +139,23 @@
 	return NULL;
 }
 
-void *dl_event_fn(int tid, int typeid)
+void *dl_proto_get_devid(struct driver_info *dinfo, int tid, int typeid)
 {
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, &quot;get_devid&quot;);
+
+	return NULL;
+}
+
+void *dl_event_fn(struct driver_info *dinfo, int tid, int typeid)
+{
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, &quot;async_event&quot;);
 
 	return NULL;
 }
 
-void *dl_cmd_done_fn(int typeid)
+void *dl_cmd_done_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, &quot;cmd_done&quot;);

Modified: branches/use-scsi-ml/usr/dl.h
===================================================================
--- branches/use-scsi-ml/usr/dl.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/dl.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -3,17 +3,25 @@
 
 #define	MAX_DL_HANDLES	16
 
-extern int dl_init(void);
-extern void dl_config_load(void);
-extern struct pollfd * dl_poll_init(int *nr);
+struct driver_info {
+	char *name;
+	char *proto;
+	void *dl;
+	void *pdl;
+};
 
-extern void *dl_poll_init_fn(int idx);
-extern void *dl_poll_fn(int idx);
-extern void *dl_ipc_fn(int typeid);
-extern void *dl_event_fn(int tid, int typeid);
-extern void *dl_proto_cmd_process(int tid, int typeid);
-extern void *dl_cmd_done_fn(int typeid);
+extern struct driver_info dlinfo[MAX_DL_HANDLES];
 
-extern char *typeid_to_name(int typeid);
+extern int dl_init(struct driver_info *);
+extern struct pollfd * dl_poll_init(struct driver_info *, int *nr);
 
+extern void *dl_poll_init_fn(struct driver_info *, int idx);
+extern void *dl_poll_fn(struct driver_info *, int idx);
+extern void *dl_ipc_fn(struct driver_info *, int typeid);
+extern void *dl_event_fn(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_cmd_process(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_get_devid(struct driver_info *, int tid, int typeid);
+extern void *dl_cmd_done_fn(struct driver_info *, int typeid);
+extern char *typeid_to_name(struct driver_info *, int typeid);
+
 #endif

Modified: branches/use-scsi-ml/usr/ipc.c
===================================================================
--- branches/use-scsi-ml/usr/ipc.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/ipc.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -8,9 +8,11 @@
 
 #include &lt;errno.h&gt;
 #include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;inttypes.h&gt;
+#include &lt;poll.h&gt;
 #include &lt;sys/socket.h&gt;
 #include &lt;sys/types.h&gt;
 #include &lt;sys/un.h&gt;
@@ -22,6 +24,10 @@
 #include &quot;tgtadm.h&quot;
 #include &quot;dl.h&quot;
 
+struct tgt_task {
+	int fd;
+};
+
 static int ipc_accept(int afd)
 {
 	struct sockaddr addr;
@@ -50,15 +56,61 @@
 	return err;
 }
 
-void ipc_event_handle(int accept_fd)
+void pipe_event_handle(int fd)
 {
-	int fd, err;
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	char buf[1024];
+	struct tgtadm_res *res;
+	struct tgt_task *task;
+	int err;
+
+	nlh = (struct nlmsghdr *) buf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&amp;msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &amp;msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+		return;
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
+	memset(&amp;msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &amp;msg, MSG_DONTWAIT);
+	if (err &lt; 0)
+		return;
+
+	res = NLMSG_DATA(nlh);
+	dprintf(&quot;%d %d %lx\n&quot;, err, nlh-&gt;nlmsg_len, res-&gt;addr);
+
+	task = (struct tgt_task *) res-&gt;addr;
+	if (!task)
+		return;
+
+	dprintf(&quot;%d\n&quot;, task-&gt;fd);
+
+	err = write(task-&gt;fd, nlh, nlh-&gt;nlmsg_len);
+	close(task-&gt;fd);
+	free(task);
+}
+
+void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
+{
+	int fd, err, done = 0;
 	char sbuf[4096], rbuf[4096];
 	struct nlmsghdr *nlh;
 	struct iovec iov;
 	struct msghdr msg;
 	struct tgtadm_res *res;
 	struct tgtadm_req *req;
+	struct tgt_task *task;
 	int (*fn) (char *, char *);
 
 	fd = ipc_accept(accept_fd);
@@ -97,15 +149,36 @@
 	if (err &lt; 0)
 		goto fail;
 
+	task = calloc(1, sizeof(*task));
+	if (!task) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	task-&gt;fd = fd;
+
 	req = NLMSG_DATA(nlh);
+	dprintf(&quot;%d %d %d %d %d\n&quot;, req-&gt;mode, req-&gt;typeid, err, nlh-&gt;nlmsg_len, fd);
 
-	dprintf(&quot;%d %d %d\n&quot;, req-&gt;typeid, err, nlh-&gt;nlmsg_len);
+	switch (req-&gt;mode) {
+	case MODE_DEVICE:
+		dprintf(&quot;%d %d %d %d %lx\n&quot;,
+			req-&gt;tid, req-&gt;typeid, err, nlh-&gt;nlmsg_len,
+			(unsigned long) task);
+		req-&gt;addr = (unsigned long) task;
+		write(poll_array[POLLS_PER_DRV + req-&gt;tid].fd,
+		      sbuf, NLMSG_ALIGN(nlh-&gt;nlmsg_len));
+		break;
+	default:
+		fn = dl_ipc_fn(dinfo, req-&gt;typeid);
+		if (fn)
+			err = fn((char *) nlh, rbuf);
+		else
+			err = tgt_mgmt((char *) nlh, rbuf);
+		done = 1;
+	}
 
-	fn = dl_ipc_fn(req-&gt;typeid);
-	if (fn)
-		err = fn((char *) nlh, rbuf);
-	else
-		err = tgt_mgmt((char *) nlh, rbuf);
+	if (!done)
+		return;
 
 send:
 	err = write(fd, nlh, nlh-&gt;nlmsg_len);

Modified: branches/use-scsi-ml/usr/log.c
===================================================================
--- branches/use-scsi-ml/usr/log.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/log.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -45,7 +45,7 @@
 		return 1;
 
 	if (size &lt; MAX_MSG_SIZE)
-		size = DEFAULT_AREA_SIZE;
+		size = LOG_SPACE_SIZE;
 
 	if ((shmid = shmget(IPC_PRIVATE, size,
 			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
@@ -304,13 +304,15 @@
 		openlog(log_name, 0, LOG_DAEMON);
 		setlogmask (LOG_UPTO (LOG_DEBUG));
 
-		if (logarea_init(size))
+		if (logarea_init(size)) {
+			syslog(LOG_ERR, &quot;failed to initialize the logger\n&quot;);
 			return 1;
+		}
 
 		pid = fork();
 		if (pid &lt; 0) {
-			syslog(LOG_ERR, &quot;starting logger failed\n&quot;);
-			exit(1);
+			syslog(LOG_ERR, &quot;fail to fork the logger\n&quot;);
+			return 1;
 		} else if (pid) {
 			syslog(LOG_WARNING,
 			       &quot;Target daemon logger with pid=%d started!\n&quot;, pid);

Modified: branches/use-scsi-ml/usr/log.h
===================================================================
--- branches/use-scsi-ml/usr/log.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/log.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -35,7 +35,7 @@
 	struct seminfo *__buf;
 };
 
-#define DEFAULT_AREA_SIZE 16384
+#define LOG_SPACE_SIZE 16384
 #define MAX_MSG_SIZE 256
 
 extern int log_daemon;

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -14,6 +14,7 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &lt;poll.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;sys/socket.h&gt;
 #include &lt;sys/stat.h&gt;
@@ -72,16 +73,32 @@
 
 static void __ktarget_create(struct tgt_event *ev, struct tgtadm_req *req)
 {
-	sprintf(ev-&gt;u.c_target.type, &quot;%s&quot;, typeid_to_name(req-&gt;typeid));
+	sprintf(ev-&gt;u.c_target.type, &quot;%s&quot;, typeid_to_name(dlinfo, req-&gt;typeid));
+	ev-&gt;u.c_target.pid = req-&gt;pid;
 }
 
 int ktarget_create(int typeid)
 {
 	struct tgtadm_req req;
+	int fd, err;
+
 	req.typeid = typeid;
+	req.pid = target_thread_create(&amp;fd);
+	err = tgt_event_execute(&amp;req, TGT_UEVENT_TARGET_CREATE,
+				__ktarget_create);
+	if (err &gt;= 0) {
+		dprintf(&quot;%d %d\n&quot;, err, fd);
 
-	return tgt_event_execute(&amp;req, TGT_UEVENT_TARGET_CREATE,
-				 __ktarget_create);
+		/* FIXME */
+		if (err &gt; POLLS_PER_DRV)
+			eprintf(&quot;too large tid %d\n&quot;, err);
+		else {
+			poll_array[POLLS_PER_DRV + err].fd = fd;
+			poll_array[POLLS_PER_DRV + err].events = POLLIN;
+		}
+	}
+
+	return err;
 }
 
 static void __ktarget_destroy(struct tgt_event *ev, struct tgtadm_req *req)
@@ -98,7 +115,7 @@
 				 __ktarget_destroy);
 }
 
-void kdevice_create_parser(char *args, char **path, char **devtype)
+static void kdevice_create_parser(char *args, char **path, char **devtype)
 {
 	char *p, *q;
 
@@ -122,11 +139,11 @@
 	}
 }
 
-int kdevice_create(int tid, uint64_t devid, char *path, char *devtype)
+static int kdevice_create(int tid, uint64_t devid, char *path)
 {
 	int fd, err;
 
-	dprintf(&quot;%d %&quot; PRIu64 &quot; %s %s\n&quot;, tid, devid, path, devtype);
+	dprintf(&quot;%d %&quot; PRIu64 &quot; %s\n&quot;, tid, devid, path);
 
 	fd = open(path, O_RDWR | O_LARGEFILE);
 	if (fd &lt; 0) {
@@ -141,7 +158,7 @@
 	return err;
 }
 
-int kdevice_destroy(int tid, uint64_t devid)
+static int kdevice_destroy(int tid, uint64_t devid)
 {
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
@@ -199,10 +216,10 @@
 	case OP_NEW:
 		path = devtype = NULL;
 		kdevice_create_parser(params, &amp;path, &amp;devtype);
-		if (!path || !devtype)
-			eprintf(&quot;Invalid path or device type\n&quot;);
+		if (!path)
+			eprintf(&quot;Invalid path\n&quot;);
 		else
-			err = kdevice_create(req-&gt;tid, req-&gt;lun, path,devtype);
+			err = kdevice_create(req-&gt;tid, req-&gt;lun, path);
 		break;
 	case OP_DELETE:
 		err = kdevice_destroy(req-&gt;tid, req-&gt;lun);
@@ -214,83 +231,6 @@
 	return err;
 }
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(dir-&gt;d_name, &quot;..&quot;);
-}
-
-static void all_devices_destroy(int tid)
-{
-	struct dirent **namelist;
-	char *p;
-	int i, nr;
-	uint64_t devid;
-
-	nr = scandir(TGT_DEVICE_SYSFSDIR, &amp;namelist, filter, alphasort);
-	if (!nr)
-		return;
-
-	for (i = 0; i &lt; nr; i++) {
-
-		for (p = namelist[i]-&gt;d_name; !isdigit((int) *p); p++)
-			;
-		if (tid != atoi(p))
-			continue;
-		p = strchr(p, ':');
-		if (!p)
-			continue;
-		devid = strtoull(++p, NULL, 10);
-		kdevice_destroy(tid, devid);
-	}
-
-	for (i = 0; i &lt; nr; i++)
-		free(namelist[i]);
-	free(namelist);
-}
-
-static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, i, nr, fd;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], *p;
-
-	if (req-&gt;op != OP_DELETE)
-		return err;
-
-	nr = scandir(TGT_TARGET_SYSFSDIR, &amp;namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i &lt; nr; i++) {
-		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR &quot;/%s/typeid&quot;,
-			 namelist[i]-&gt;d_name);
-
-		fd = open(path, O_RDONLY);
-		if (fd &lt; 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err &lt; 0)
-			continue;
-
-		if (req-&gt;typeid == atoi(buf)) {
-			int tid;
-
-			for (p = namelist[i]-&gt;d_name; !isdigit((int) *p); p++)
-				;
-			tid = atoi(p);
-			all_devices_destroy(tid);
-			ktarget_destroy(tid);
-		}
-	}
-
-	for (i = 0; i &lt; nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
-}
-
 int tgt_mgmt(char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
@@ -302,13 +242,11 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf(&quot;%d %d %d %d %d %&quot; PRIx64 &quot; %&quot; PRIx64 &quot; %s\n&quot;, nlh-&gt;nlmsg_len,
-		req-&gt;typeid, req-&gt;mode, req-&gt;op, req-&gt;tid, req-&gt;sid, req-&gt;lun, params);
+	eprintf(&quot;%d %d %d %d %d %&quot; PRIx64 &quot; %&quot; PRIx64 &quot; %s %d\n&quot;, nlh-&gt;nlmsg_len,
+		req-&gt;typeid, req-&gt;mode, req-&gt;op, req-&gt;tid, req-&gt;sid, req-&gt;lun,
+		params, getpid());
 
 	switch (req-&gt;mode) {
-	case MODE_SYSTEM:
-		err = system_mgmt(req, params, rbuf, &amp;rlen);
-		break;
 	case MODE_TARGET:
 		err = target_mgmt(req, params, rbuf, &amp;rlen);
 		break;
@@ -320,7 +258,7 @@
 	}
 
 	nlh = (struct nlmsghdr *) rbuf;
-	nlh-&gt;nlmsg_len = NLMSG_LENGTH(rlen);
+	nlh-&gt;nlmsg_len = NLMSG_LENGTH(sizeof(*res) + rlen);
 	res = NLMSG_DATA(nlh);
 	res-&gt;err = err;
 

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/netlink.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -26,16 +26,12 @@
 #include &quot;tgtd.h&quot;
 #include &quot;dl.h&quot;
 
-#define	NL_BUFSIZE	8192
+#define	NL_BUFSIZE	1024
 
-static struct sockaddr_nl src_addr, dest_addr;
-static char *recvbuf, *sendbuf;
-
-static int __nl_write(int fd, int type, char *data, int len)
+int __nl_write(int fd, int type, char *data, int len)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl daddr;
 
 	memset(nlh, 0, sizeof(*nlh));
 	nlh-&gt;nlmsg_len = len;
@@ -43,46 +39,36 @@
 	nlh-&gt;nlmsg_flags = 0;
 	nlh-&gt;nlmsg_pid = getpid();
 
-	iov.iov_base = data;
-	iov.iov_len = len;
+	memset(&amp;daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
+	daddr.nl_pid = 0;
+	daddr.nl_groups = 0;
 
-	memset(&amp;msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &amp;dest_addr;
-	msg.msg_namelen = sizeof(dest_addr);
-	msg.msg_iov = (void *) &iov;
-	msg.msg_iovlen = 1;
-
-	return sendmsg(fd, &amp;msg, 0);
+	return sendto(fd, data, len, 0, (struct sockaddr *) &amp;daddr,
+		      sizeof(daddr));
 }
 
-static int __nl_read(int fd, void *data, int size, int flags)
+int __nl_read(int fd, void *data, int size, int flags)
 {
-	int rc;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl saddr;
+	socklen_t slen = sizeof(saddr);
 
-	iov.iov_base = data;
-	iov.iov_len = size;
+	memset(&amp;saddr, 0, sizeof(saddr));
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = getpid();
+	saddr.nl_groups = 0; /* not in mcast groups */
 
-	memset(&amp;msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &amp;src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	rc = recvmsg(fd, &amp;msg, flags);
-
-	return rc;
+	return recvfrom(fd, data, size, flags, (struct sockaddr *) &amp;saddr, &amp;slen);
 }
 
-int nl_read(int fd)
+static int nl_read(int fd, char *buf)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	int err;
 
 peek_again:
-	err = __nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
+	err = __nl_read(fd, buf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
 	if (err &lt; 0) {
 		eprintf(&quot;%d\n&quot;, err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -90,13 +76,13 @@
 		return err;
 	}
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) buf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	dprintf(&quot;nl_event_handle %d %d\n&quot;, nlh-&gt;nlmsg_type, nlh-&gt;nlmsg_len);
+	dprintf(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type, nlh-&gt;nlmsg_len, getpid());
 
 read_again:
-	err = __nl_read(fd, recvbuf, nlh-&gt;nlmsg_len, 0);
+	err = __nl_read(fd, buf, nlh-&gt;nlmsg_len, 0);
 	if (err &lt; 0) {
 		eprintf(&quot;%d\n&quot;, err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -107,87 +93,33 @@
 	return err;
 }
 
-static int cmd_queue(int fd, char *reqbuf, char *resbuf)
+void nl_event_handle(struct driver_info *dinfo, int fd)
 {
-	int result, len = 0;
-	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
-	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t offset, cid = ev_req-&gt;k.cmd_req.cid;
-	uint8_t *pdu, rw = 0, try_map = 0;
-	unsigned long uaddr;
-	int (*fn) (int, uint8_t *, int *, uint32_t,
-		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
-
-	memset(resbuf, 0, NL_BUFSIZE);
-	pdu = (uint8_t *) ev_req-&gt;data;
-	dprintf(&quot;%&quot; PRIu64 &quot; %x\n&quot;, cid, pdu[0]);
-
-	fn = dl_proto_cmd_process(ev_req-&gt;k.cmd_req.tid,
-				  ev_req-&gt;k.cmd_req.typeid);
-
-	if (fn)
-		result = fn(ev_req-&gt;k.cmd_req.tid,
-			    pdu,
-			    &amp;len,
-			    ev_req-&gt;k.cmd_req.data_len,
-			    &amp;uaddr, &amp;rw, &amp;try_map, &amp;offset);
-	else {
-		result = -EINVAL;
-		eprintf(&quot;Cannot process cmd %d %&quot; PRIu64 &quot;\n&quot;,
-			ev_req-&gt;k.cmd_req.tid, cid);
-	}
-
-	memset(ev_res, 0, (char *) ev_res-&gt;data - (char *) ev_res);
-	ev_res-&gt;u.cmd_res.tid = ev_req-&gt;k.cmd_req.tid;
-	ev_res-&gt;u.cmd_res.cid = cid;
-	ev_res-&gt;u.cmd_res.len = len;
-	ev_res-&gt;u.cmd_res.result = result;
-	ev_res-&gt;u.cmd_res.uaddr = uaddr;
-	ev_res-&gt;u.cmd_res.rw = rw;
-	ev_res-&gt;u.cmd_res.try_map = try_map;
-	ev_res-&gt;u.cmd_res.offset = offset;
-
-	log_debug(&quot;scsi_cmd_process res %d len %d\n&quot;, result, len);
-
-	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
-}
-
-void nl_event_handle(int fd)
-{
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
+	char rbuf[NL_BUFSIZE];
 	int err;
 	void (*fn) (char *);
 
-	err = nl_read(fd);
+	err = nl_read(fd, rbuf);
 	if (err &lt; 0)
 		return;
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) rbuf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
+	dprintf(&quot;%d %d\n&quot;, getpid(), nlh-&gt;nlmsg_type);
+
 	switch (nlh-&gt;nlmsg_type) {
-	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
-		break;
 	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dl_event_fn(ev-&gt;k.tgt_passthru.tid,
+		fn = dl_event_fn(dinfo, ev-&gt;k.tgt_passthru.tid,
 				 ev-&gt;k.tgt_passthru.typeid);
 		if (fn)
-			fn(NLMSG_DATA(recvbuf));
+			fn(NLMSG_DATA(rbuf));
 		else
 			eprintf(&quot;Cannot handle async event %d\n&quot;,
 				ev-&gt;k.tgt_passthru.tid);
 		break;
-	case TGT_KEVENT_CMD_DONE:
-		fn = dl_cmd_done_fn(ev-&gt;k.cmd_done.typeid);
-		if (fn)
-			fn(NLMSG_DATA(recvbuf));
-		else
-			eprintf(&quot;Cannot handle cmd done %d\n&quot;,
-				ev-&gt;k.cmd_done.tid);
-		break;
 	default:
 		/* kernel module bug */
 		eprintf(&quot;unknown event %u\n&quot;, nlh-&gt;nlmsg_type);
@@ -200,15 +132,16 @@
 {
 	int err;
 	struct nlmsghdr *nlh;
+	char buf[NL_BUFSIZE];
 
 	err = __nl_write(fd, type, sbuf, slen);
 	if (err &lt; 0)
 		return err;
 
-	err = nl_read(fd);
+	err = nl_read(fd, buf);
 
 	if (rbuf) {
-		nlh = (struct nlmsghdr *) recvbuf;
+		nlh = (struct nlmsghdr *) buf;
 		if (rlen &lt; nlh-&gt;nlmsg_len)
 			eprintf(&quot;Too small rbuf %d %d\n&quot;, rlen, nlh-&gt;nlmsg_len);
 		else
@@ -220,18 +153,18 @@
 	return err;
 }
 
-static int nl_start(int fd)
+int nl_start(int fd)
 {
 	int err;
 	struct tgt_event *ev;
-	char rbuf[4096];
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
+	char buf[NL_BUFSIZE];
 
 	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
-			  rbuf, sizeof(rbuf));
+			  buf, NL_BUFSIZE);
 
-	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
+	ev = (struct tgt_event *) NLMSG_DATA(buf);
 	if (err &lt; 0 || ev-&gt;k.event_res.err &lt; 0) {
 		eprintf(&quot;%d %d\n&quot;, err, ev-&gt;k.event_res.err);
 		return -EINVAL;
@@ -240,38 +173,13 @@
 	return 0;
 }
 
-int nl_open(void)
+int nl_init(void)
 {
-	int fd, err;
+	int fd;
 
-	sendbuf = malloc(NL_BUFSIZE * 2);
-	if (!sendbuf)
-		return -ENOMEM;
-	recvbuf = sendbuf + NL_BUFSIZE;
-
 	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd &lt; 0) {
-		eprintf(&quot;%d\n&quot;, fd);
-		return fd;
-	}
+	if (fd &lt; 0)
+		eprintf(&quot;Fail to create the netlink socket %d\n&quot;, errno);
 
-	memset(&amp;src_addr, 0, sizeof(src_addr));
-	src_addr.nl_family = AF_NETLINK;
-	src_addr.nl_pid = getpid();
-	src_addr.nl_groups = 0; /* not in mcast groups */
-
-	memset(&amp;dest_addr, 0, sizeof(dest_addr));
-	dest_addr.nl_family = AF_NETLINK;
-	dest_addr.nl_pid = 0; /* kernel */
-	dest_addr.nl_groups = 0; /* unicast */
-
-	err = nl_start(fd);
-	if (err &lt; 0)
-		goto out;
-
 	return fd;
-
-out:
-	close(fd);
-	return err;
 }

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/scsi.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -31,7 +31,6 @@
 #include &lt;linux/netlink.h&gt;
 
 #include &quot;tgtd.h&quot;
-#include &quot;tgt_if.h&quot;
 #include &quot;tgt_scsi_if.h&quot;
 #include &quot;tgt_sysfs.h&quot;
 
@@ -544,6 +543,7 @@
 	void *p;
 	uint64_t off;
 	*len = 0;
+	int err = SAM_STAT_GOOD;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -566,14 +566,20 @@
 
 	off &lt;&lt;= 9;
 
-	p = mmap(NULL, pgcnt(datalen, off) &lt;&lt; PAGE_SHIFT,
-		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off &amp; PAGE_MASK);
+	if (*uaddr)
+		*uaddr = *uaddr + (off &amp; PAGE_MASK);
+	else {
+		p = mmap(NULL, pgcnt(datalen, off) &lt;&lt; PAGE_SHIFT,
+			 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off &amp; PAGE_MASK);
 
-	*uaddr = (unsigned long) p;
+		*uaddr = (unsigned long) p;
+		if (p == MAP_FAILED)
+			err = SAM_STAT_CHECK_CONDITION;
+	}
 	*offset = off;
 	dprintf(&quot;%lx %u %&quot; PRIu64 &quot;\n&quot;, *uaddr, datalen, off);
 
-	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
+	return err;
 }
 
 static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
@@ -598,10 +604,10 @@
 	return result;
 }
 
-#define	TGT_INVALID_DEV_ID	~0ULL
-
-static uint64_t translate_lun(uint8_t *p, int size)
+uint64_t get_devid(uint8_t *pdu)
 {
+	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
+	uint8_t *p = scmd-&gt;lun;
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
 	switch (*p &gt;&gt; 6) {
@@ -622,14 +628,12 @@
 
 int cmd_process(int tid, uint8_t *pdu, int *len,
 		uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		uint8_t *try_map, uint64_t *offset)
+		uint8_t *try_map, uint64_t *offset, uint64_t lun)
 {
 	int fd, result = SAM_STAT_GOOD;
 	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
 	uint8_t *data = NULL, *scb = scmd-&gt;scb;
-	uint64_t lun;
 
-	lun = translate_lun(scmd-&gt;lun, sizeof(scmd-&gt;lun));
 	dprintf(&quot;%d %&quot; PRIu64 &quot; %x %u\n&quot;, tid, lun, scb[0], datalen);
 
 	*offset = 0;
@@ -686,7 +690,10 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		fd = getfd(tid, lun);
+		if (*uaddr)
+			fd = 0;
+		else
+			fd = getfd(tid, lun);
 		if (fd &gt;= 0) {
 			result = mmap_device(tid, lun, scb, len, fd, datalen,
 					     uaddr, offset);
@@ -719,17 +726,16 @@
 	return result;
 }
 
-int cmd_done(struct tgt_event *ev)
+int cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 
-	if (ev-&gt;k.cmd_done.mmapped)
-		err = munmap((void *) ev-&gt;k.cmd_done.uaddr, ev-&gt;k.cmd_done.len);
-	else
-		free((void *) ev-&gt;k.cmd_done.uaddr);
+	dprintf(&quot;%d %d %&quot; PRIx64 &quot; %d\n&quot;, do_munmap, do_free, uaddr, len);
 
-	dprintf(&quot;%d %lx %u %d\n&quot;, ev-&gt;k.cmd_done.mmapped,
-		ev-&gt;k.cmd_done.uaddr, ev-&gt;k.cmd_done.len, err);
+	if (do_munmap)
+		err = munmap((void *) (unsigned long) uaddr, len);
+	else if (do_free)
+		free((void *) (unsigned long) uaddr);
 
 	return err;
 }

Copied: branches/use-scsi-ml/usr/target.c (from rev 230, trunk/usr/target.c)

Modified: branches/use-scsi-ml/usr/tgt_device.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_device.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgt_device.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -1,140 +0,0 @@
-/*
- * target framework Device
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-
-/*
- * This is just makeshift for removing device stuff in kernel space
- * and should be replaced soon.
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;asm/byteorder.h&gt;
-#include &lt;asm/page.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;sys/ioctl.h&gt;
-#include &lt;sys/types.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;linux/fs.h&gt;
-
-#include &quot;tgtd.h&quot;
-#include &quot;tgt_sysfs.h&quot;
-
-static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
-static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
-
-int tgt_device_create(int tid, uint64_t lun, int dfd)
-{
-	int err, fd;
-	struct stat st;
-	char path[PATH_MAX], buf[32];
-	uint64_t size;
-
-	err = ioctl(dfd, BLKGETSIZE64, &amp;size);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot get size %d\n&quot;, dfd);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR &quot;/target%d&quot;, tid);
-	err = stat(path, &amp;st);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot find target %d\n&quot;, tid);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64,
-		 tid, lun);
-
-	err = mkdir(path, dmode);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot create %s\n&quot;, path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64 &quot;/fd&quot;,
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd &lt; 0) {
-		eprintf(&quot;Cannot create %s\n&quot;, path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), &quot;%d&quot;, dfd);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot write %s\n&quot;, path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64 &quot;/size&quot;,
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd &lt; 0) {
-		eprintf(&quot;Cannot create %s\n&quot;, path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), &quot;%&quot; PRIu64, size);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot write %s\n&quot;, path);
-		return err;
-	}
-
-	return 0;
-}
-
-int tgt_device_destroy(int tid, uint64_t lun)
-{
-	char path[PATH_MAX];
-	int err;
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64 &quot;/fd&quot;,
-		 tid, lun);
-	err = unlink(path);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot unlink %s\n&quot;, path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64 &quot;/size&quot;,
-		 tid, lun);
-	err = unlink(path);
-	if (err &lt; 0) {
-		eprintf(&quot;Cannot unlink %s\n&quot;, path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR &quot;/device%d:%&quot; PRIu64,
-		 tid, lun);
-	err = rmdir(path);
-	if (err &lt; 0)
-		eprintf(&quot;Cannot unlink %s\n&quot;, path);
-
-out:
-	return err;
-}
-
-int tgt_device_init(void)
-{
-	int err;
-
-	rmdir(TGT_DEVICE_SYSFSDIR);
-	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
-	if (err &lt; 0)
-		perror(&quot;Cannot create&quot;);
-
-	return err;
-}

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -41,6 +41,7 @@
 #define dprintf eprintf
 
 static char program_name[] = &quot;tgtadm&quot;;
+static char *driver;
 
 static struct option const long_options[] =
 {
@@ -113,6 +114,85 @@
 	return strcmp(dir-&gt;d_name, &quot;.&quot;) &amp;&amp; strcmp(dir-&gt;d_name, &quot;..&quot;);
 }
 
+static void all_devices_destroy(int tid)
+{
+	struct dirent **namelist;
+	char *p, cmd[1024];
+	int i, nr, err;
+	uint64_t devid;
+
+	nr = scandir(TGT_DEVICE_SYSFSDIR, &amp;namelist, filter, alphasort);
+	if (!nr)
+		return;
+
+	for (i = 0; i &lt; nr; i++) {
+
+		for (p = namelist[i]-&gt;d_name; !isdigit((int) *p); p++)
+			;
+		if (tid != atoi(p))
+			continue;
+		p = strchr(p, ':');
+		if (!p)
+			continue;
+		devid = strtoull(++p, NULL, 10);
+		snprintf(cmd, sizeof(cmd),
+			 &quot;./usr/tgtadm --driver %s --op delete --tid %d --lun %&quot; PRIu64,
+			 driver, tid, devid);
+		err = system(cmd);
+	}
+
+	for (i = 0; i &lt; nr; i++)
+		free(namelist[i]);
+	free(namelist);
+}
+
+static int system_mgmt(struct tgtadm_req *req)
+{
+	int err = -EINVAL, i, nr, fd;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], cmd[PATH_MAX], *p;
+
+	if (req-&gt;op != OP_DELETE)
+		return err;
+
+	nr = scandir(TGT_TARGET_SYSFSDIR, &amp;namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i &lt; nr; i++) {
+		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR &quot;/%s/typeid&quot;,
+			 namelist[i]-&gt;d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd &lt; 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err &lt; 0)
+			continue;
+
+		if (req-&gt;typeid == atoi(buf)) {
+			int tid;
+
+			for (p = namelist[i]-&gt;d_name; !isdigit((int) *p); p++)
+				;
+			tid = atoi(p);
+			all_devices_destroy(tid);
+
+			snprintf(cmd, sizeof(cmd),
+				 &quot;./usr/tgtadm --driver %s --op delete --tid %d&quot;,
+				 driver, tid);
+			err = system(cmd);
+		}
+	}
+
+	for (i = 0; i &lt; nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return 0;
+}
+
 static int driver_to_typeid(char *name)
 {
 	int i, nr, err, fd, id = -ENOENT;
@@ -178,6 +258,8 @@
 		goto out;
 	}
 
+	driver = name;
+
 	return id;
 out:
 	exit(0);
@@ -388,8 +470,12 @@
 		len += strlen(params);
 	}
 
-	err = ipc_mgmt_call(sbuf, len, rbuf);
-	ipc_mgmt_result(rbuf);
+	if (req-&gt;mode == MODE_SYSTEM)
+		err = system_mgmt(req);
+	else {
+		err = ipc_mgmt_call(sbuf, len, rbuf);
+		ipc_mgmt_result(rbuf);
+	}
 out:
 	return err;
 }

Modified: branches/use-scsi-ml/usr/tgtadm.h
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtadm.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -30,17 +30,18 @@
 	uint64_t sid;
 	int cid;
 	uint64_t lun;
+	int pid;
+
+	unsigned long addr;
 };
 
 struct tgtadm_res {
 	int err;
+	unsigned long addr;
 };
 
-extern int tgt_mgmt(char *sbuf, char *rbuf);
 extern int ktarget_destroy(int tid);
 extern int ktarget_create(int typeid);
-extern int kdevice_destroy(int tid, uint64_t devid);
-extern int kdevice_create(int tid, uint64_t devid, char *path, char *devtype);
-extern void kdevice_create_parser(char *args, char **path, char **devtype);
+extern int tgt_mgmt(char *sbuf, char *rbuf);
 
 #endif

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -1,5 +1,5 @@
 /*
- * Core target framework user-space daemon
+ * Target framework user-space main daemon
  *
  * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
  * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
@@ -26,9 +26,8 @@
 #include &quot;tgtd.h&quot;
 #include &quot;dl.h&quot;
 
-#define	POLLS_PER_DRV	32
-
 int nl_fd, ipc_fd;
+struct pollfd *poll_array;
 
 enum {
 	POLL_NL,
@@ -46,6 +45,26 @@
 
 static char program_name[] = &quot;tgtd&quot;;
 
+static int daemon_init(void)
+{
+	pid_t pid;
+
+	pid = fork();
+	if (pid &lt; 0)
+		return -ENOMEM;
+	else if (pid)
+		exit(0);
+
+	setsid();
+	chdir(&quot;/&quot;);
+	close(0);
+	open(&quot;/dev/null&quot;, O_RDWR);
+	dup2(0, 1);
+	dup2(0, 2);
+
+	return 0;
+}
+
 static void usage(int status)
 {
 	if (status != 0)
@@ -65,7 +84,7 @@
 static void signal_catch(int signo) {
 }
 
-static void init(int daemon, int debug)
+static void tgtd_init(void)
 {
 	int fd;
 	char path[64];
@@ -92,16 +111,13 @@
 	}
 	write(fd, &quot;-17\n&quot;, 4);
 	close(fd);
-
-	if (log_init(program_name, DEFAULT_AREA_SIZE, daemon, debug) &lt; 0) {
-		fprintf(stderr, &quot;can not start the logger daemon\n&quot;);
-		exit(-1);
-	}
 }
 
+/* TODO: rewrite makeshift poll code */
+
 static void event_loop(int nr_dls, struct pollfd *poll_array)
 {
-	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
+	int err, i, poll_max = (nr_dls + 2) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
 
 	while (1) {
@@ -113,16 +129,29 @@
 			continue;
 		}
 
-		if (poll_array[POLL_NL].revents)
-			nl_event_handle(nl_fd);
+		if (poll_array[POLL_NL].revents) {
+			nl_event_handle(dlinfo, nl_fd);
+			err--;
+		}
 
-		if (poll_array[POLL_IPC].revents)
-			ipc_event_handle(ipc_fd);
+		if (poll_array[POLL_IPC].revents) {
+			ipc_event_handle(dlinfo, ipc_fd);
+			err--;
+		}
 
+		if (!err)
+			continue;
+
+		for (i = POLLS_PER_DRV; i &lt; POLLS_PER_DRV * 2; i++)
+			if (poll_array[i].revents) {
+				dprintf(&quot;target process event %d\n&quot;, i);
+				pipe_event_handle(poll_array[i].fd);
+			}
+
 		for (i = 0; i &lt; nr_dls; i++) {
-			fn = dl_poll_fn(i);
+			fn = dl_poll_fn(dlinfo, i);
 			if (fn)
-				fn(poll_array + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
+				fn(poll_array + ((i + 2) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
 	}
 }
@@ -133,8 +162,7 @@
 	void (* fn)(struct pollfd *, int);
 	int i;
 
-	array = calloc((nr + 1) * POLLS_PER_DRV,
-		       sizeof(struct pollfd));
+	array = calloc((nr + 2) * POLLS_PER_DRV, sizeof(struct pollfd));
 	if (!array)
 		exit(-ENOMEM);
 
@@ -144,9 +172,9 @@
 	array[POLL_IPC].events = POLLIN;
 
 	for (i = 0; i &lt; nr; i++) {
-		fn = dl_poll_init_fn(i);
+		fn = dl_poll_init_fn(dlinfo, i);
 		if (fn)
-			fn(array + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
+			fn(array + (i + 2) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}
 
 	return array;
@@ -156,10 +184,9 @@
 {
 	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	pid_t pid;
-	struct pollfd *poll_array;
 
-	while ((ch = getopt_long(argc, argv, &quot;fd:vh&quot;, long_options, &amp;longindex)) &gt;= 0) {
+	while ((ch = getopt_long(argc, argv, &quot;fd:vh&quot;, long_options,
+				 &amp;longindex)) &gt;= 0) {
 		switch (ch) {
 		case 'f':
 			is_daemon = 0;
@@ -179,42 +206,32 @@
 		}
 	}
 
-	init(is_daemon, is_debug);
+	if (is_daemon &amp;&amp; daemon_init())
+		exit(1);
 
-	if (is_daemon) {
-		pid = fork();
-		if (pid &lt; 0)
-			exit(-1);
-		else if (pid)
-			exit(0);
+	tgtd_init();
 
-		chdir(&quot;/&quot;);
+	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
+		exit(1);
 
-		close(0);
-		open(&quot;/dev/null&quot;, O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
+	if (tgt_device_init())
+		exit(1);
 
-	if (tgt_device_init() &lt; 0)
-		exit(0);
-
-	nl_fd = nl_open();
+	nl_fd = nl_init();
 	if (nl_fd &lt; 0)
-		exit(nl_fd);
+		exit(1);
+	if (nl_start(nl_fd))
+		exit(1);
 
 	ipc_fd = ipc_open();
 	if (ipc_fd &lt; 0)
 		exit(ipc_fd);
 
-	dl_init();
+	dl_init(dlinfo);
 
 	nr = MAX_DL_HANDLES;
 	poll_array = poll_init(nr);
 
-	dl_config_load();
-
 	event_loop(nr, poll_array);
 
 	return 0;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -2,15 +2,27 @@
 #define __TARGET_DAEMON_H
 
 #include &quot;log.h&quot;
+#include &quot;dl.h&quot;
 
+#define	TGT_INVALID_DEV_ID	~0ULL
+
+/* temporarily */
+#define	POLLS_PER_DRV	32
 extern int nl_fd;
+extern struct pollfd *poll_array;
 
-extern int nl_open(void);
-extern void nl_event_handle(int fd);
+extern int target_thread_create(int *fd);
+
+extern int nl_init(void);
+extern void nl_event_handle(struct driver_info *, int fd);
 extern int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen);
+extern int nl_start(int fd);
+extern int __nl_write(int fd, int type, char *data, int len);
+extern int __nl_read(int fd, void *data, int size, int flags);
 
 extern int ipc_open(void);
-extern void ipc_event_handle(int fd);
+extern void ipc_event_handle(struct driver_info *, int fd);
+extern void pipe_event_handle(int fd);
 
 extern int tgt_device_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, int dfd);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000232.html">[Stgt-svn] r245 - branches/use-scsi-ml/kernel
</A></li>
	<LI>Next message: <A HREF="000234.html">[Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#233">[ date ]</a>
              <a href="thread.html#233">[ thread ]</a>
              <a href="subject.html#233">[ subject ]</a>
              <a href="author.html#233">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
