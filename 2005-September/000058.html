<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r68 - in trunk: . include iscsi/kernel iscsi/usr kernel usr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r68%20-%20in%20trunk%3A%20.%20include%20iscsi/kernel%20iscsi/usr%20kernel%20usr&In-Reply-To=%3C200509120020.j8C0KDYW001076%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000057.html">
   <LINK REL="Next"  HREF="000059.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r68 - in trunk: . include iscsi/kernel iscsi/usr kernel usr</H1>
    <B>Tomonori Fujita at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r68%20-%20in%20trunk%3A%20.%20include%20iscsi/kernel%20iscsi/usr%20kernel%20usr&In-Reply-To=%3C200509120020.j8C0KDYW001076%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r68 - in trunk: . include iscsi/kernel iscsi/usr kernel usr">tomo at berlios.de
       </A><BR>
    <I>Mon Sep 12 02:20:13 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000057.html">[Stgt-svn] r64 - trunk/iscsi/include
</A></li>
        <LI>Next message: <A HREF="000059.html">[Stgt-svn] r69 - trunk/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58">[ date ]</a>
              <a href="thread.html#58">[ thread ]</a>
              <a href="subject.html#58">[ subject ]</a>
              <a href="author.html#58">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2005-09-12 02:20:00 +0200 (Mon, 12 Sep 2005)
New Revision: 68

Added:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Removed:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_target.h
   trunk/kernel/stgt_vsd.c
   trunk/usr/stgtd.c
   trunk/usr/stgtd.h
Modified:
   trunk/initd
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/session.c
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/Makefile
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/usr/Makefile
   trunk/usr/ipc.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Rename all stgt stuff to tgt.

Deleted: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/include/stgt_if.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,65 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#ifndef __SCSI_TARGET_IF_H
-#define __SCSI_TARGET_IF_H
-
-#define STGT_IPC_NAMESPACE &quot;STGT_IPC_ABSTRACT_NAMESPACE&quot;
-
-enum stgt_event_type {
-	/* user -&gt; kernel */
-	STGT_UEVENT_START,
-	STGT_UEVENT_TARGET_CREATE,
-	STGT_UEVENT_TARGET_DESTROY,
-	STGT_UEVENT_DEVICE_CREATE,
-	STGT_UEVENT_DEVICE_DESTROY,
-	STGT_UEVENT_CMND_RES,
-
-	/* kernel -&gt; user */
-	STGT_KEVENT_RESPONSE,
-	STGT_KEVENT_CMND_REQ,
-};
-
-struct stgt_event {
-	/* user-&gt; kernel */
-	union {
-		struct {
-			char type[32];
-			int nr_cmnds;
-		} c_target;
-		struct {
-			int tid;
-		} d_target;
-		struct {
-			int tid;
-			uint64_t dev_id;
-			uint32_t flags;
-			char type[32];
-		} c_device;
-		struct {
-			int tid;
-			uint64_t dev_id;
-		} d_device;
-		struct {
-			uint64_t cid;
-			uint32_t len;
-			int result;
-		} cmnd_res;
-	} u;
-
-	/* kernel -&gt; user */
-	union {
-		struct {
-			int err;
-		} event_res;
-		struct {
-			uint64_t cid;
-			int tid;
-			uint64_t dev_id;
-		} cmnd_req;
-	} k;
-};
-
-#endif

Copied: trunk/include/tgt_if.h (from rev 67, trunk/include/stgt_if.h)
===================================================================
--- trunk/include/stgt_if.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/include/tgt_if.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,66 @@
+/*
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+
+#ifndef TARGET_FRAMEWORK_IF_H
+#define TARGET_FRAMEWORK_IF_H
+
+#define TGT_IPC_NAMESPACE &quot;TGT_IPC_ABSTRACT_NAMESPACE&quot;
+
+enum tgt_event_type {
+	/* user -&gt; kernel */
+	TGT_UEVENT_START,
+	TGT_UEVENT_TARGET_CREATE,
+	TGT_UEVENT_TARGET_DESTROY,
+	TGT_UEVENT_DEVICE_CREATE,
+	TGT_UEVENT_DEVICE_DESTROY,
+	TGT_UEVENT_CMND_RES,
+
+	/* kernel -&gt; user */
+	TGT_KEVENT_RESPONSE,
+	TGT_KEVENT_CMND_REQ,
+};
+
+struct tgt_event {
+	/* user-&gt; kernel */
+	union {
+		struct {
+			char type[32];
+			int nr_cmnds;
+		} c_target;
+		struct {
+			int tid;
+		} d_target;
+		struct {
+			int tid;
+			uint64_t dev_id;
+			uint32_t flags;
+			char type[32];
+		} c_device;
+		struct {
+			int tid;
+			uint64_t dev_id;
+		} d_device;
+		struct {
+			uint64_t cid;
+			uint32_t len;
+			int result;
+		} cmnd_res;
+	} u;
+
+	/* kernel -&gt; user */
+	union {
+		struct {
+			int err;
+		} event_res;
+		struct {
+			uint64_t cid;
+			int tid;
+			uint64_t dev_id;
+		} cmnd_req;
+	} k;
+};
+
+#endif

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/initd	2005-09-12 00:20:00 UTC (rev 68)
@@ -8,10 +8,10 @@
 
 start_server()
 {
-	insmod ${PWD}/kernel/stgt_core.ko
+	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/stgt_vsd.ko
-	${PWD}/usr/stgtd
+	insmod ${PWD}/kernel/tgt_vsd.ko
+	${PWD}/usr/tgtd
 
 	modprobe -q crc32c
 	insmod ${PWD}/iscsi/kernel/iscsi_trgt.ko
@@ -21,13 +21,14 @@
 stop_server()
 {
 	${PWD}/iscsi/usr/ietadm --op delete
-	killall ietd
-	killall -9 stgtd
+	killall -9 ietd
+	killall -9 tgtd
+
 	rmmod iscsi_trgt
 
-	rmmod stgt_vsd
+	rmmod tgt_vsd
 	rmmod tgt_scsi
-	rmmod stgt_core
+	rmmod tgt_core
 }
 
 case &quot;$1&quot; in

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -12,8 +12,8 @@
 
 #include &lt;iscsi.h&gt;
 #include &lt;iscsi_dbg.h&gt;
-#include &lt;stgt.h&gt;
-#include &lt;stgt_target.h&gt;
+#include &lt;tgt.h&gt;
+#include &lt;tgt_target.h&gt;
 
 unsigned long debug_enable_flags;
 
@@ -81,7 +81,7 @@
 
 	if (req) {
 		assert(conn-&gt;session);
-		assert(conn-&gt;session-&gt;sts);
+		assert(conn-&gt;session-&gt;ts);
 	}
 
 	dprintk(D_GENERIC, &quot;%p:%p\n&quot;, conn, cmnd);
@@ -160,7 +160,7 @@
 {
 	struct iscsi_conn *conn = cmnd-&gt;conn;
 	struct iscsi_cmnd *data_cmnd;
-	struct scatterlist *sg = cmnd-&gt;stc-&gt;sg;
+	struct scatterlist *sg = cmnd-&gt;tc-&gt;sg;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
 	u32 pdusize, expsize, scsisize, size, offset, sn;
@@ -169,9 +169,9 @@
 	dprintk(D_GENERIC, &quot;%p\n&quot;, cmnd);
 	pdusize = conn-&gt;session-&gt;param.max_xmit_data_length;
 	expsize = cmnd_read_size(cmnd);
-	assert(cmnd-&gt;stc);
-	size = min(expsize, cmnd-&gt;stc-&gt;bufflen);
-	eprintk(&quot;%u %u\n&quot;, expsize, cmnd-&gt;stc-&gt;bufflen);
+	assert(cmnd-&gt;tc);
+	size = min(expsize, cmnd-&gt;tc-&gt;bufflen);
+	eprintk(&quot;%u %u\n&quot;, expsize, cmnd-&gt;tc-&gt;bufflen);
 	offset = 0;
 	sn = 0;
 
@@ -193,7 +193,7 @@
 			rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL |
 				     ISCSI_FLAG_DATA_STATUS;
 
-			scsisize = cmnd-&gt;stc-&gt;bufflen;
+			scsisize = cmnd-&gt;tc-&gt;bufflen;
 			if (scsisize &lt; expsize) {
 				rsp-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 				size = expsize - scsisize;
@@ -275,13 +275,13 @@
 	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr-&gt;itt = cmnd_hdr(req)-&gt;itt;
 
-	sense = (struct iscsi_sense_data *) req-&gt;stc-&gt;error_buff;
-	memmove(sense-&gt;data, sense, req-&gt;stc-&gt;error_buff_len);
-	sense-&gt;length = cpu_to_be16(req-&gt;stc-&gt;error_buff_len);
+	sense = (struct iscsi_sense_data *) req-&gt;tc-&gt;error_buff;
+	memmove(sense-&gt;data, sense, req-&gt;tc-&gt;error_buff_len);
+	sense-&gt;length = cpu_to_be16(req-&gt;tc-&gt;error_buff_len);
 
-	sg-&gt;page = virt_to_page(req-&gt;stc-&gt;error_buff);
-	sg-&gt;offset = offset_in_page(req-&gt;stc-&gt;error_buff);
-	sg-&gt;length = req-&gt;stc-&gt;error_buff_len + sizeof(struct iscsi_sense_data);
+	sg-&gt;page = virt_to_page(req-&gt;tc-&gt;error_buff);
+	sg-&gt;offset = offset_in_page(req-&gt;tc-&gt;error_buff);
+	sg-&gt;length = req-&gt;tc-&gt;error_buff_len + sizeof(struct iscsi_sense_data);
 	rsp-&gt;pdu.datasize = sg-&gt;length;
 	rsp-&gt;sg = sg;
 
@@ -305,11 +305,11 @@
 	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr-&gt;itt = cmnd_hdr(req)-&gt;itt;
 
-	sg-&gt;page = virt_to_page(req-&gt;stc-&gt;error_buff);
-	sg-&gt;offset = offset_in_page(req-&gt;stc-&gt;error_buff);
-	sg-&gt;length = req-&gt;stc-&gt;error_buff_len;
+	sg-&gt;page = virt_to_page(req-&gt;tc-&gt;error_buff);
+	sg-&gt;offset = offset_in_page(req-&gt;tc-&gt;error_buff);
+	sg-&gt;length = req-&gt;tc-&gt;error_buff_len;
 
-	sense = (struct iscsi_sense_data *) req-&gt;stc-&gt;error_buff;
+	sense = (struct iscsi_sense_data *) req-&gt;tc-&gt;error_buff;
 	sense-&gt;length = cpu_to_be16(14);
 	sense-&gt;data[0] = 0xf0;
 	sense-&gt;data[2] = sense_key;
@@ -362,8 +362,8 @@
 	list_del(&amp;cmnd-&gt;conn_list);
 	spin_unlock(&amp;conn-&gt;list_lock);
 
-	if (cmnd-&gt;stc)
-		stgt_cmnd_destroy(cmnd-&gt;stc);
+	if (cmnd-&gt;tc)
+		tgt_cmnd_destroy(cmnd-&gt;tc);
 
 	kmem_cache_free(iscsi_cmnd_cache, cmnd);
 }
@@ -592,7 +592,7 @@
 	cmnd_skip_pdu(req);
 }
 
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct stgt_cmnd *stc,
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmnd *tc,
 			 u32 offset, u32 size)
 {
 	int idx, i;
@@ -601,17 +601,17 @@
 
 	dprintk(D_GENERIC, &quot;%u,%u\n&quot;, offset, size);
 
-	assert(stc);
-	sg = stc-&gt;sg;
+	assert(tc);
+	sg = tc-&gt;sg;
 	offset += sg-&gt;offset;
 
-	if (!(offset &lt; sg-&gt;offset + stc-&gt;bufflen) ||
-	    !(offset + size &lt;= sg-&gt;offset + stc-&gt;bufflen)) {
-		eprintk(&quot;%u %u %u %u&quot;, offset, size, sg-&gt;offset, stc-&gt;bufflen);
+	if (!(offset &lt; sg-&gt;offset + tc-&gt;bufflen) ||
+	    !(offset + size &lt;= sg-&gt;offset + tc-&gt;bufflen)) {
+		eprintk(&quot;%u %u %u %u&quot;, offset, size, sg-&gt;offset, tc-&gt;bufflen);
 		return -EIO;
 	}
-	assert(offset &lt; sg-&gt;offset + stc-&gt;bufflen);
-	assert(offset + size &lt;= sg-&gt;offset + stc-&gt;bufflen);
+	assert(offset &lt; sg-&gt;offset + tc-&gt;bufflen);
+	assert(offset + size &lt;= sg-&gt;offset + tc-&gt;bufflen);
 
 	idx = offset &gt;&gt; PAGE_CACHE_SHIFT;
 	offset &amp;= ~PAGE_CACHE_MASK;
@@ -693,12 +693,12 @@
 	iscsi_cmnds_init_write(&amp;send);
 }
 
-static void scsi_cmnd_done(struct stgt_cmnd *stc)
+static void scsi_cmnd_done(struct tgt_cmnd *tc)
 {
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) stc-&gt;private;
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc-&gt;private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
-	if (stc-&gt;result != SAM_STAT_GOOD) {
+	if (tc-&gt;result != SAM_STAT_GOOD) {
 		struct iscsi_cmnd *rsp;
 
 		rsp = do_create_sense_rsp(cmnd);
@@ -746,8 +746,8 @@
 			send_r2t(cmnd);
 	} else {
 		set_cmnd_waitio(cmnd);
-		cmnd-&gt;stc-&gt;private = cmnd;
-		stgt_cmnd_queue(cmnd-&gt;stc, scsi_cmnd_done);
+		cmnd-&gt;tc-&gt;private = cmnd;
+		tgt_cmnd_queue(cmnd-&gt;tc, scsi_cmnd_done);
 	}
 }
 
@@ -834,10 +834,10 @@
 
 	eprintk(&quot;scsi command: %02x\n&quot;, req_hdr-&gt;cdb[0]);
 
-	req-&gt;stc = stgt_cmnd_create(conn-&gt;session-&gt;sts, req_hdr-&gt;cdb,
-				    req_hdr-&gt;lun,
-				    sizeof(req_hdr-&gt;lun));
-	assert(req-&gt;stc);
+	req-&gt;tc = tgt_cmnd_create(conn-&gt;session-&gt;ts, req_hdr-&gt;cdb,
+				   req_hdr-&gt;lun,
+				   sizeof(req_hdr-&gt;lun));
+	assert(req-&gt;tc);
 
 	switch (req_hdr-&gt;cdb[0]) {
 	case SERVICE_ACTION_IN:
@@ -880,7 +880,7 @@
 			cmnd_skip_data(req);
 		}
 
-		stgt_cmnd_alloc_buffer(req-&gt;stc, NULL);
+		tgt_cmnd_alloc_buffer(req-&gt;tc, NULL);
 
 		break;
 	}
@@ -906,10 +906,10 @@
 		if (req_hdr-&gt;cdb[0] == WRITE_VERIFY &amp;&amp; req_hdr-&gt;cdb[1] &amp; 0x02)
 			eprintk(&quot;Verification is ignored %x\n&quot;, cmnd_itt(req));
 
-		stgt_cmnd_alloc_buffer(req-&gt;stc, NULL);
+		tgt_cmnd_alloc_buffer(req-&gt;tc, NULL);
 
 		if (req-&gt;pdu.datasize) {
-			if (cmnd_recv_pdu(conn, req-&gt;stc, 0, req-&gt;pdu.datasize) &lt; 0)
+			if (cmnd_recv_pdu(conn, req-&gt;tc, 0, req-&gt;pdu.datasize) &lt; 0)
 				assert(0);
 		}
 		break;
@@ -966,7 +966,7 @@
 	dprintk(D_WRITE, &quot;%u %p %p %u %u\n&quot;, req-&gt;ttt, cmnd, scsi_cmnd,
 		offset, cmnd-&gt;pdu.datasize);
 
-	if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;stc, offset, cmnd-&gt;pdu.datasize) &lt; 0)
+	if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;tc, offset, cmnd-&gt;pdu.datasize) &lt; 0)
 		goto skip_data;
 	return;
 
@@ -991,7 +991,7 @@
 /* 		assert(scsi_cmnd-&gt;tio); */
 		offset = be32_to_cpu(req-&gt;offset);
 		offset += cmnd-&gt;pdu.datasize - conn-&gt;read_overflow;
-		if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;stc, offset, conn-&gt;read_overflow) &lt; 0)
+		if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;tc, offset, conn-&gt;read_overflow) &lt; 0)
 			assert(0);
 		return;
 	}
@@ -1559,7 +1559,7 @@
 	}
 }
 
-static struct stgt_target_template iet_stgt_target_template = {
+static struct tgt_target_template iet_tgt_target_template = {
 	.name = &quot;iet&quot;,
 	.module = THIS_MODULE,
 	.protocol = &quot;scsi&quot;,
@@ -1578,7 +1578,7 @@
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
 
-	stgt_target_template_unregister(&amp;iet_stgt_target_template);
+	tgt_target_template_unregister(&amp;iet_tgt_target_template);
 }
 
 static int iscsi_init(void)
@@ -1603,8 +1603,8 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-	iet_stgt_target_template.priv_data_size = sizeof(struct iscsi_target);
-	err = stgt_target_template_register(&amp;iet_stgt_target_template);
+	iet_tgt_target_template.priv_data_size = sizeof(struct iscsi_target);
+	err = tgt_target_template_register(&amp;iet_tgt_target_template);
 	if (err &lt; 0)
 		goto err;
 

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -57,7 +57,7 @@
 };
 
 struct iscsi_cmnd;
-struct stgt_target;
+struct tgt_target;
 
 enum iscsi_device_state {
 	IDEV_RUNNING,
@@ -77,7 +77,7 @@
 
 	struct semaphore target_sem;
 
-	struct stgt_target *stt;
+	struct tgt_target *tt;
 };
 
 #define IET_HASH_ORDER		8
@@ -104,7 +104,7 @@
 
 	u32 next_ttt;
 
-	struct stgt_session *sts;
+	struct tgt_session *ts;
 };
 
 enum connection_state_bit {
@@ -192,7 +192,7 @@
 	u32 ddigest;
 
 	struct iscsi_cmnd *req;
-	struct stgt_cmnd *stc;
+	struct tgt_cmnd *tc;
 };
 
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD
@@ -227,8 +227,8 @@
 extern int target_lock(struct iscsi_target *, int);
 extern void target_unlock(struct iscsi_target *);
 struct iscsi_target *target_lookup_by_id(u32);
-extern int target_add(struct stgt_target *);
-extern void target_del(struct stgt_target *);
+extern int target_add(struct tgt_target *);
+extern void target_del(struct tgt_target *);
 
 /* config.c */
 extern int iet_procfs_init(void);

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/session.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -8,7 +8,7 @@
 
 #include &lt;iscsi.h&gt;
 #include &lt;iscsi_dbg.h&gt;
-#include &lt;stgt.h&gt;
+#include &lt;tgt.h&gt;
 
 struct iscsi_session *session_lookup(struct iscsi_target *target, u64 sid)
 {
@@ -59,7 +59,7 @@
 
 	list_add(&amp;session-&gt;list, &amp;target-&gt;session_list);
 
-	session-&gt;sts = stgt_session_create(target-&gt;stt, 64, NULL, NULL);
+	session-&gt;ts = tgt_session_create(target-&gt;tt, 64, NULL, NULL);
 
 	return 0;
 err:
@@ -99,7 +99,7 @@
 	list_del(&amp;session-&gt;list);
 	kfree(session-&gt;initiator);
 
-	stgt_session_destroy(session-&gt;sts);
+	tgt_session_destroy(session-&gt;ts);
 	kfree(session);
 
 	return 0;

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/kernel/target.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -9,9 +9,9 @@
 #include &lt;iscsi.h&gt;
 #include &lt;digest.h&gt;
 #include &lt;iscsi_dbg.h&gt;
-#include &lt;stgt.h&gt;
-#include &lt;stgt_device.h&gt;
-#include &lt;stgt_target.h&gt;
+#include &lt;tgt.h&gt;
+#include &lt;tgt_device.h&gt;
+#include &lt;tgt_target.h&gt;
 
 #define	MAX_NR_TARGETS	(1UL &lt;&lt; 30)
 
@@ -101,15 +101,15 @@
 	nthread_stop(target);
 }
 
-static int iscsi_target_create(struct stgt_target *stt)
+static int iscsi_target_create(struct tgt_target *tt)
 {
 	int err = -EINVAL;
 	struct iscsi_target *target =
-		(struct iscsi_target *) stt-&gt;stt_data;
+		(struct iscsi_target *) tt-&gt;tt_data;
 
 	memset(target, 0, sizeof(*target));
 
-	target-&gt;stt = stt;
+	target-&gt;tt = tt;
 	memcpy(&amp;target-&gt;sess_param, &amp;default_session_param, sizeof(default_session_param));
 	memcpy(&amp;target-&gt;trgt_param, &amp;default_target_param, sizeof(default_target_param));
 
@@ -124,11 +124,11 @@
 	if (err &lt; 0)
 		return err;
 
-	target-&gt;tid = target-&gt;stt-&gt;tid;
+	target-&gt;tid = target-&gt;tt-&gt;tid;
 	return 0;
 }
 
-int target_add(struct stgt_target *stt)
+int target_add(struct tgt_target *tt)
 {
 	int err = -EEXIST;
 
@@ -139,7 +139,7 @@
 		goto out;
 	}
 
-	if (!(err = iscsi_target_create(stt)))
+	if (!(err = iscsi_target_create(tt)))
 		nr_targets++;
 out:
 	up(&amp;target_list_sem);
@@ -147,10 +147,10 @@
 	return err;
 }
 
-void target_del(struct stgt_target *stt)
+void target_del(struct tgt_target *tt)
 {
 	struct iscsi_target *target =
-		(struct iscsi_target *) stt-&gt;stt_data;
+		(struct iscsi_target *) tt-&gt;tt_data;
 
 	down(&amp;target_list_sem);
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/iscsi/usr/ctldev.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -20,7 +20,7 @@
 #include &lt;linux/netlink.h&gt;
 
 #include &quot;iscsid.h&quot;
-#include &quot;stgt_if.h&quot;
+#include &quot;tgt_if.h&quot;
 
 #define CTL_DEVICE	&quot;/dev/ietctl&quot;
 
@@ -181,7 +181,7 @@
 	int tid, err;
 	int32_t lun;
 
-	dir = opendir(&quot;/sys/class/stgt_device&quot;);
+	dir = opendir(&quot;/sys/class/tgt_device&quot;);
 	if (!dir)
 		return errno;
 
@@ -193,7 +193,7 @@
 
 	closedir(dir);
 
-	dir = opendir(&quot;/sys/class/stgt_target&quot;);
+	dir = opendir(&quot;/sys/class/tgt_target&quot;);
 	if (!dir)
 		return errno;
 
@@ -333,8 +333,8 @@
 {
 	int fd, err;
 	struct sockaddr_un addr;
-	char nlm_ev[NLMSG_SPACE(sizeof(struct stgt_event))];
-	struct stgt_event *ev;
+	char nlm_ev[NLMSG_SPACE(sizeof(struct tgt_event))];
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
@@ -343,8 +343,8 @@
 
 	memset(&amp;addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &amp;addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
+	memcpy((char *) &amp;addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
 
 	err = connect(fd, (struct sockaddr *) &amp;addr, sizeof(addr));
 	if (err &lt; 0)
@@ -382,11 +382,11 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_CREATE,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_CREATE,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -406,11 +406,11 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_TARGET_DESTROY,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -425,8 +425,8 @@
 {
 	int err;
 	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
-	char dtype[] = &quot;stgt_vsd&quot;;
-	struct stgt_event *ev;
+	char dtype[] = &quot;tgt_vsd&quot;;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fprintf(stderr, &quot;%s %d %s\n&quot;, __FUNCTION__, __LINE__, args);
@@ -461,7 +461,7 @@
 		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_CREATE,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_CREATE,
 		   NLMSG_SPACE(sizeof(*ev) + strlen(path)), 0);
 
 	ev = NLMSG_DATA(nlh);
@@ -479,13 +479,13 @@
 {
 	int err;
 	char nlm_ev[8912];
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 
 	fprintf(stderr, &quot;%s %d %d %u\n&quot;, __FUNCTION__, __LINE__, tid, lun);
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_DESTROY,
+	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/Makefile	2005-09-12 00:20:00 UTC (rev 68)
@@ -2,13 +2,13 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_STGT=20
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20
 
 ifneq ($(KERNELRELEASE),)
-obj-m		+= stgt_core.o
-stgt_core-objs	:= stgt_sysfs.o tgt_protocol.o stgt.o
+obj-m		+= tgt_core.o
+tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= stgt_vsd.o tgt_scsi.o
+obj-m		+= tgt_vsd.o tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Deleted: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,1070 +0,0 @@
-/*
- * Core Target Framework code
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#include &lt;linux/module.h&gt;
-#include &lt;linux/types.h&gt;
-#include &lt;linux/list.h&gt;
-#include &lt;linux/hash.h&gt;
-#include &lt;linux/pagemap.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/mempool.h&gt;
-#include &lt;linux/netlink.h&gt;
-#include &lt;net/tcp.h&gt;
-
-#include &lt;stgt.h&gt;
-#include &lt;stgt_target.h&gt;
-#include &lt;stgt_device.h&gt;
-#include &lt;stgt_if.h&gt;
-#include &lt;tgt_protocol.h&gt;
-
-#define DEBUG_STGT
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#ifdef DEBUG_STGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
-#endif
-
-#define assert(p) do {						\
-	if (!(p)) {						\
-		printk(KERN_CRIT &quot;BUG at %s:%d assert(%s)\n&quot;,	\
-		       __FILE__, __LINE__, #p);			\
-		dump_stack();					\
-		BUG();						\
-	}							\
-} while (0)
-
-MODULE_LICENSE(&quot;GPL&quot;);
-
-static spinlock_t all_targets_lock;
-static LIST_HEAD(all_targets);
-
-static spinlock_t target_tmpl_lock;
-static LIST_HEAD(target_tmpl_list);
-
-static spinlock_t device_tmpl_lock;
-static LIST_HEAD(device_tmpl_list);
-
-static void session_init_handler(void *data);
-static spinlock_t atomic_sessions_lock;
-static LIST_HEAD(atomic_sessions);
-static DECLARE_WORK(atomic_session_work, session_init_handler,
-		    &amp;atomic_sessions);
-
-static int daemon_pid;
-static struct sock *nls;
-
-static kmem_cache_t *cmnd_slab, *work_slab;
-
-/* TODO: lock per session */
-static spinlock_t cmnd_hash_lock;
-#define STGT_HASH_ORDER		8
-#define	cmnd_hashfn(key)	hash_long((key), STGT_HASH_ORDER)
-static struct list_head cmnd_hash[1 &lt;&lt; STGT_HASH_ORDER];
-
-struct atomic_session_args {
-	struct stgt_session *session;
-	void (*done) (void *, struct stgt_session *);
-	int max_cmnds;
-	void *arg;
-	struct list_head list;
-};
-
-struct stgt_work {
-	void (*fn) (void *);
-	void *arg;
-	mempool_t *pool;
-	struct list_head list;
-};
-
-static struct stgt_work * stgt_init_work(struct stgt_session *session,
-					 void (*fn)(void *), void *arg)
-{
-	struct stgt_work *work;
-	mempool_t *pool = session-&gt;work_pool;
-
-	work = mempool_alloc(pool, GFP_ATOMIC);
-	if (!work)
-		return NULL;
-
-	work-&gt;fn = fn;
-	work-&gt;arg = arg;
-	work-&gt;pool = pool;
-
-	return work;
-}
-
-static void stgt_worker(void *data)
-{
-	struct stgt_target *target = (struct stgt_target *) data;
-	struct stgt_work *work = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	if (!list_empty(&amp;target-&gt;work_list)) {
-		work = list_entry(target-&gt;work_list.next, struct stgt_work, list);
-		list_del(&amp;work-&gt;list);
-	}
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-
-	if (work) {
-		work-&gt;fn(work-&gt;arg);
-		mempool_free(work, work-&gt;pool);
-	}
-
-	return;
-}
-
-static void stgt_queue_work(struct stgt_target *target, struct stgt_work *work)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	list_add_tail(&amp;work-&gt;list, &amp;target-&gt;work_list);
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-
-	queue_work(target-&gt;twq, &amp;target-&gt;work);
-}
-
-struct target_type_internal {
-	struct list_head list;
-	struct stgt_target_template *stt;
-	struct tgt_protocol *proto;
-};
-
-static struct target_type_internal *target_template_get(const char *name)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &amp;target_tmpl_list, list)
-		if (!strcmp(name, ti-&gt;stt-&gt;name)) {
-			if (!try_module_get(ti-&gt;stt-&gt;module))
-				ti = NULL;
-			spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
-			return ti;
-		}
-
-	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void target_template_put(struct stgt_target_template *stt)
-{
-	module_put(stt-&gt;module);
-}
-
-int stgt_target_template_register(struct stgt_target_template *stt)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
-	INIT_LIST_HEAD(&amp;ti-&gt;list);
-	ti-&gt;stt = stt;
-
-	ti-&gt;proto = tgt_protocol_get(stt-&gt;protocol);
-	if (!ti-&gt;proto) {
-		eprintk(&quot;Could not find %s protocol\n&quot;, stt-&gt;protocol);
-		kfree(ti);
-		return -EINVAL;
-	}
-
-	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
-	list_add_tail(&amp;ti-&gt;list, &amp;target_tmpl_list);
-	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_target_template_register);
-
-void stgt_target_template_unregister(struct stgt_target_template *stt)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &amp;target_tmpl_list, list)
-		if (ti-&gt;stt == stt) {
-			list_del(&amp;ti-&gt;list);
-			tgt_protocol_put(ti-&gt;proto);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(stgt_target_template_unregister);
-
-static struct stgt_target *target_find(int tid)
-{
-	struct stgt_target *target;
-
-	spin_lock(&amp;all_targets_lock);
-	list_for_each_entry(target, &amp;all_targets, tlist) {
-		if (target-&gt;tid == tid)
-			goto found;
-	}
-	target = NULL;
-found:
-	spin_unlock(&amp;all_targets_lock);
-
-	return target;
-}
-
-struct stgt_target *stgt_target_create(char *target_type, int queued_cmnds)
-{
-	char name[16];
-	static int target_id;
-	struct stgt_target *target;
-	struct target_type_internal *tti;
-
-	if (!daemon_pid) {
-		eprintk(&quot;%s\n&quot;, &quot;Run the user-space daemon first!&quot;);
-		return NULL;
-	}
-
-	target = kmalloc(sizeof(*target), GFP_KERNEL);
-	if (!target)
-		return NULL;
-	memset(target, 0, sizeof(*target));
-
-	tti = target_template_get(target_type);
-	if (!tti)
-		goto free_target;
-
-	target-&gt;stt = tti-&gt;stt;
-	target-&gt;proto = tti-&gt;proto;
-	target-&gt;tid = target_id++;
-	spin_lock_init(&amp;target-&gt;lock);
-
-	INIT_LIST_HEAD(&amp;target-&gt;session_list);
-	INIT_LIST_HEAD(&amp;target-&gt;device_list);
-	INIT_LIST_HEAD(&amp;target-&gt;work_list);
-
-	INIT_WORK(&amp;target-&gt;work, stgt_worker, target);
-	target-&gt;queued_cmnds = queued_cmnds;
-
-	snprintf(name, sizeof(name), &quot;tgtd%d&quot;, target-&gt;tid);
-	target-&gt;twq = create_workqueue(name);
-	if (!target-&gt;twq)
-		goto put_template;
-
-	target-&gt;stt_data = kmalloc(sizeof(target-&gt;stt-&gt;priv_data_size), GFP_KERNEL);
-	if (!target-&gt;stt_data)
-		goto free_workqueue;
-
-	if (target-&gt;stt-&gt;target_create)
-		if (target-&gt;stt-&gt;target_create(target))
-			goto free_priv_stt_data;
-
-	if (stgt_sysfs_register_target(target))
-		goto stt_destroy;
-
-	spin_lock(&amp;all_targets_lock);
-	list_add(&amp;target-&gt;tlist, &amp;all_targets);
-	spin_unlock(&amp;all_targets_lock);
-	return target;
-
-stt_destroy:
-	if (target-&gt;stt-&gt;target_destroy)
-		target-&gt;stt-&gt;target_destroy(target);
-free_priv_stt_data:
-	kfree(target-&gt;stt_data);
-free_workqueue:
-	destroy_workqueue(target-&gt;twq);
-put_template:
-	target_template_put(target-&gt;stt);
-free_target:
-	kfree(target);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(stgt_target_create);
-
-int stgt_target_destroy(struct stgt_target *target)
-{
-	dprintk(&quot;%p\n&quot;, target);
-
-	spin_lock(&amp;all_targets_lock);
-	list_del(&amp;target-&gt;tlist);
-	spin_unlock(&amp;all_targets_lock);
-
-	if (target-&gt;stt-&gt;target_destroy)
-		target-&gt;stt-&gt;target_destroy(target);
-
-	destroy_workqueue(target-&gt;twq);
-	target_template_put(target-&gt;stt);
-	stgt_sysfs_unregister_target(target);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_target_destroy);
-
-static int session_init(struct stgt_session *session, int max_cmnds)
-{
-	struct stgt_target *target = session-&gt;target;
-	unsigned long flags;
-
-	session-&gt;cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, cmnd_slab);
-	if (!session-&gt;cmnd_pool)
-		goto out;
-
-	session-&gt;work_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					    mempool_free_slab, work_slab);
-	if (!session-&gt;work_pool)
-		goto out;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	list_add(&amp;session-&gt;slist, &amp;target-&gt;session_list);
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-
-	return 0;
-out:
-	if (session-&gt;cmnd_pool)
-		mempool_destroy(session-&gt;cmnd_pool);
-
-	if (session-&gt;work_pool)
-		mempool_destroy(session-&gt;work_pool);
-
-	return -ENOMEM;
-}
-
-static void session_init_handler(void *data)
-{
-	struct list_head *head = (struct list_head *) data;
-	struct atomic_session_args *ssa = NULL;
-	unsigned long flags;
-	int err;
-
-	spin_lock_irqsave(&amp;atomic_sessions_lock, flags);
-	if (!list_empty(&amp;atomic_sessions)) {
-		ssa = list_entry(head-&gt;next, struct atomic_session_args, list);
-		list_del(&amp;ssa-&gt;list);
-	}
-	spin_unlock_irqrestore(&amp;atomic_sessions_lock, flags);
-
-	if (!ssa)
-		return;
-
-	err = session_init(ssa-&gt;session, ssa-&gt;max_cmnds);
-	if (err)
-		kfree(ssa-&gt;session);
-
-	ssa-&gt;done(ssa-&gt;arg, err ? NULL : ssa-&gt;session);
-
-	kfree(ssa);
-}
-
-static int session_atomic_init(struct stgt_session *session,
-			       int max_cmnds,
-			       void (*done) (void *, struct stgt_session *),
-			       int *arg)
-{
-	struct atomic_session_args *ssa;
-	unsigned long flags;
-
-	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
-	if (!ssa)
-		return -ENOMEM;
-
-	ssa-&gt;session = session;
-	ssa-&gt;max_cmnds = max_cmnds;
-	ssa-&gt;arg = arg;
-
-	spin_lock_irqsave(&amp;atomic_sessions_lock, flags);
-	list_add(&amp;ssa-&gt;list, &amp;atomic_sessions);
-	spin_unlock_irqrestore(&amp;atomic_sessions_lock, flags);
-
-	queue_work(session-&gt;target-&gt;twq, &amp;atomic_session_work);
-
-	return 0;
-}
-
-struct stgt_session *
-stgt_session_create(struct stgt_target *target,
-		    int max_cmnds,
-		    void (*done)(void *, struct stgt_session *),
-		    void *arg)
-{
-	struct stgt_session *session;
-
-	if (!target) {
-		eprintk(&quot;%s\n&quot;, &quot;Null target pointer!&quot;);
-		return NULL;
-	}
-
-	if (done &amp;&amp; !arg) {
-		eprintk(&quot;%s\n&quot;, &quot;Need arg !&quot;);
-		return NULL;
-	}
-
-	dprintk(&quot;%p %d\n&quot;, target, max_cmnds);
-
-	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
-	if (!session)
-		return NULL;
-
-	memset(session, 0, sizeof(*session));
-	session-&gt;target = target;
-	INIT_LIST_HEAD(&amp;session-&gt;slist);
-
-	if (done) {
-		if (session_atomic_init(session, max_cmnds, done, arg) &lt; 0)
-			goto out;
-
-		return session;
-	}
-
-	if (session_init(session, max_cmnds) &lt; 0)
-		goto out;
-
-	return session;
-
-out:
-	kfree(session);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(stgt_session_create);
-
-int stgt_session_destroy(struct stgt_session *session)
-{
-	mempool_destroy(session-&gt;cmnd_pool);
-	mempool_destroy(session-&gt;work_pool);
-	kfree(session);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_session_destroy);
-
-struct device_type_internal {
-	struct stgt_device_template *sdt;
-	struct list_head list;
-};
-
-static struct stgt_device_template *device_template_get(const char *name)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &amp;device_tmpl_list, list)
-		if (!strcmp(name, ti-&gt;sdt-&gt;name)) {
-			if (!try_module_get(ti-&gt;sdt-&gt;module))
-				ti = NULL;
-			spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
-			return ti ? ti-&gt;sdt : NULL;
-		}
-
-	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void device_template_put(struct stgt_device_template *sdt)
-{
-	module_put(sdt-&gt;module);
-}
-
-int stgt_device_template_register(struct stgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-	memset(ti, 0, sizeof(*ti));
-	INIT_LIST_HEAD(&amp;ti-&gt;list);
-	ti-&gt;sdt = sdt;
-
-	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
-	list_add_tail(&amp;ti-&gt;list, &amp;device_tmpl_list);
-	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_device_template_register);
-
-void stgt_device_template_unregister(struct stgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &amp;device_tmpl_list, list)
-		if (ti-&gt;sdt == sdt) {
-			list_del(&amp;ti-&gt;list);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
-
-/*
- * TODO: use a hash or any better alg/ds
- */
-static struct stgt_device *
-stgt_device_find_nolock(struct stgt_target *target, uint64_t dev_id)
-{
-	struct stgt_device *device;
-
-	list_for_each_entry(device, &amp;target-&gt;device_list, dlist)
-		if (device-&gt;dev_id == dev_id)
-			return device;
-
-	return NULL;
-}
-
-static struct stgt_device *
-stgt_device_find(struct stgt_target *target, uint64_t dev_id)
-{
-	static struct stgt_device *device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	device = stgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-
-	return device;
-}
-
-static int stgt_device_create(int tid, uint64_t dev_id, char *device_type,
-			      char *path, unsigned long dflags)
-{
-	struct stgt_target *target;
-	struct stgt_device *device;
-	unsigned long flags;
-
-	dprintk(&quot;%d %llu %s %s\n&quot;, tid, dev_id, device_type, path);
-
-	target = target_find(tid);
-	if (!target)
-		return -EINVAL;
-
-	device = kmalloc(sizeof(*device), GFP_KERNEL);
-	if (!device)
-		return -ENOMEM;
-
-	memset(device, 0, sizeof(*device));
-	device-&gt;dev_id = dev_id;
-	device-&gt;target = target;
-	device-&gt;path = kstrdup(path, GFP_KERNEL);
-	if (!device-&gt;path)
-		goto free_device;
-
-	device-&gt;sdt = device_template_get(device_type);
-	if (!device-&gt;sdt) {
-		eprintk(&quot;Could not get devive type %s\n&quot;, device_type);
-		goto free_path;
-	}
-
-	device-&gt;sdt_data = kmalloc(sizeof(device-&gt;sdt-&gt;priv_data_size),
-				   GFP_KERNEL);
-	if (!device-&gt;sdt_data)
-		goto put_template;
-
-	if (device-&gt;sdt-&gt;create)
-		if (device-&gt;sdt-&gt;create(device))
-			goto free_priv_sdt_data;
-
-	if (stgt_sysfs_register_device(device))
-		goto sdt_destroy;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	list_add(&amp;device-&gt;dlist, &amp;target-&gt;device_list);
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-
-	return 0;
-
-sdt_destroy:
-	if (device-&gt;sdt-&gt;destroy)
-		device-&gt;sdt-&gt;destroy(device);
-free_priv_sdt_data:
-	kfree(device-&gt;sdt_data);
-put_template:
-	device_template_put(device-&gt;sdt);
-free_path:
-	kfree(device-&gt;path);
-free_device:
-	kfree(device);
-	return -EINVAL;
-}
-
-static int stgt_device_destroy(int tid, uint64_t dev_id)
-{
-	struct stgt_device *device;
-	struct stgt_target *target;
-	unsigned long flags;
-
-	target = target_find(tid);
-	if (!target)
-		return -ENOENT;
-
-	spin_lock_irqsave(&amp;target-&gt;lock, flags);
-	device = stgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
-	if (!device)
-		return -EINVAL;
-
-	list_del(&amp;device-&gt;dlist);
-	if (device-&gt;sdt-&gt;destroy)
-		device-&gt;sdt-&gt;destroy(device);
-
-	device_template_put(device-&gt;sdt);
-	stgt_sysfs_unregister_device(device);
-
-	return 0;
-}
-
-struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
-				   uint8_t *proto_data,
-				   uint8_t *id_buff, int buff_size)
-{
-	struct tgt_protocol *proto = session-&gt;target-&gt;proto;
-	struct stgt_cmnd *cmnd;
-	void *pcmnd_data;
-	unsigned long flags;
-
-	/*
-	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
-	 * However, how can we guarantee the specified number of commands ?
-	 */
-	pcmnd_data = kmalloc(proto-&gt;priv_cmd_data_size, GFP_ATOMIC);
-	if (!pcmnd_data)
-		return NULL;
-
-	cmnd = mempool_alloc(session-&gt;cmnd_pool, GFP_ATOMIC);
-	assert(cmnd);
-	memset(cmnd, 0, sizeof(*cmnd));
-	cmnd-&gt;tgt_protocol_private = pcmnd_data;
-	cmnd-&gt;session = session;
-	cmnd-&gt;cid = (uint64_t) (unsigned long) cmnd;
-	INIT_LIST_HEAD(&amp;cmnd-&gt;clist);
-	INIT_LIST_HEAD(&amp;cmnd-&gt;hash_list);
-
-	dprintk(&quot;%p %llu\n&quot;, session, cmnd-&gt;cid);
-
-	proto-&gt;init_cmnd(cmnd, proto_data, id_buff, buff_size);
-
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
-	list_add_tail(&amp;cmnd-&gt;hash_list, &amp;cmnd_hash[cmnd_hashfn(cmnd-&gt;cid)]);
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
-
-	return cmnd;
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_create);
-
-void stgt_cmnd_destroy(struct stgt_cmnd *cmnd)
-{
-	unsigned long flags;
-	int i;
-
-	kfree(cmnd-&gt;tgt_protocol_private);
-
-	for (i = 0; i &lt; cmnd-&gt;sg_count; i++)
-		__free_page(cmnd-&gt;sg[i].page);
-	kfree(cmnd-&gt;sg);
-
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
-	list_del(&amp;cmnd-&gt;hash_list);
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
-
-	mempool_free(cmnd, cmnd-&gt;session-&gt;cmnd_pool);
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_destroy);
-
-#define pgcnt(size, offset)	((((size) + ((offset) &amp; ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) &gt;&gt; PAGE_CACHE_SHIFT)
-
-void __stgt_alloc_buffer(struct stgt_cmnd *cmnd)
-{
-	uint64_t offset = cmnd-&gt;offset;
-	uint32_t len = cmnd-&gt;bufflen;
-	int i;
-
-	cmnd-&gt;sg_count = pgcnt(len, offset);
-	offset &amp;= ~PAGE_CACHE_MASK;
-
-	cmnd-&gt;sg = kmalloc(cmnd-&gt;sg_count * sizeof(struct scatterlist),
-			   GFP_KERNEL | __GFP_NOFAIL);
-
-	for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
-		struct scatterlist *sg = &amp;cmnd-&gt;sg[i];
-
-		sg-&gt;page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
-		sg-&gt;offset = offset;
-		sg-&gt;length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
-
-		offset = 0;
-		len -= sg-&gt;length;
-	}
-}
-
-static void stgt_alloc_buffer(void *data)
-{
-	struct stgt_cmnd *cmnd = data;
-
-	__stgt_alloc_buffer(cmnd);
-
-	if (cmnd-&gt;done) {
-		void (*done)(struct stgt_cmnd *) = cmnd-&gt;done;
-		cmnd-&gt;done = NULL;
-		done(cmnd);
-	}
-}
-
-void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
-{
-	struct tgt_protocol *proto = cmnd-&gt;session-&gt;target-&gt;proto;
-
-	assert(list_empty(&amp;cmnd-&gt;clist));
-
-	proto-&gt;init_cmnd_buffer(cmnd);
-
-	if (done) {
-		struct stgt_session *session = cmnd-&gt;session;
-		struct stgt_work *work;
-
-		work = stgt_init_work(session, stgt_alloc_buffer, cmnd);
-		stgt_queue_work(session-&gt;target, work);
-		return;
-	};
-
-	stgt_alloc_buffer(cmnd);
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_alloc_buffer);
-
-static int uspace_cmnd_send(struct stgt_cmnd *cmnd)
-{
-	struct tgt_protocol *proto = cmnd-&gt;session-&gt;target-&gt;proto;
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct stgt_event *ev;
-	char *pdu;
-	int len, proto_pdu_size = proto-&gt;uspace_pdu_size;
-
-	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk(&quot;%d %Zd %d\n&quot;, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, daemon_pid, 0,
-			  STGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev + sizeof(*ev);
-	ev-&gt;k.cmnd_req.tid = cmnd-&gt;session-&gt;target-&gt;tid;
-	ev-&gt;k.cmnd_req.dev_id = cmnd-&gt;dev_id;
-	ev-&gt;k.cmnd_req.cid = cmnd-&gt;cid;
-
-	proto-&gt;build_uspace_pdu(cmnd, pdu);
-
-	return netlink_unicast(nls, skb, daemon_pid, 0);
-}
-
-static void cmnd_done(struct stgt_cmnd *cmnd, int result)
-{
-	struct stgt_target *target = cmnd-&gt;session-&gt;target;
-	struct tgt_protocol *proto = target-&gt;proto;
-	void (*done)(struct stgt_cmnd *);
-
-	proto-&gt;cmnd_done(cmnd, result);
-	cmnd-&gt;result = result;
-
-	done = cmnd-&gt;done;
-	cmnd-&gt;done = NULL;
-	done(cmnd);
-}
-
-static void uspace_cmnd_done(struct stgt_cmnd *cmnd, char *data,
-			     int result, uint32_t len)
-{
-	int i;
-	assert(cmnd-&gt;done);
-
-	if (len) {
-		cmnd-&gt;bufflen = len;
-		cmnd-&gt;offset = 0;
-		__stgt_alloc_buffer(cmnd);
-
-		for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
-			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-			char *p = data;
-
-			memcpy(page_address(cmnd-&gt;sg[i].page), p, copy);
-			p += copy;
-			len -= copy;
-		}
-	}
-
-	cmnd_done(cmnd, result);
-}
-
-static void queuecommand(void *data)
-{
-	int err = 0;
-	struct stgt_cmnd *cmnd = data;
-	struct stgt_target *target = cmnd-&gt;session-&gt;target;
-	struct stgt_device *device;
-
-	/* Should we do this earlier? */
-	device = stgt_device_find(target, cmnd-&gt;dev_id);
-	if (device)
-		dprintk(&quot;found %llu\n&quot;, cmnd-&gt;dev_id);
-
-	if (cmnd-&gt;rw == READ || cmnd-&gt;rw == WRITE)
-		err = device-&gt;sdt-&gt;queue_cmnd(device, cmnd);
-	else {
-		err = uspace_cmnd_send(cmnd);
-		if (err &gt;= 0)
-			/* sent to userspace */
-			return;
-	}
-
-	/* kspace command failure or failed to send commands to space. */
-	if (unlikely(err))
-		eprintk(&quot;failed cmnd %llu %d %d\n&quot;, cmnd-&gt;cid, err, cmnd-&gt;rw);
-
-	cmnd_done(cmnd, err);
-}
-
-int stgt_cmnd_queue(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
-{
-	struct stgt_work *work;
-	struct stgt_session *session = cmnd-&gt;session;
-
-	assert(!cmnd-&gt;done);
-	cmnd-&gt;done = done;
-	if (!done) {
-		eprintk(&quot;%s\n&quot;, &quot;Null done function!&quot;);
-		return -EINVAL;
-	}
-
-	work = stgt_init_work(session, queuecommand, cmnd);
-	if (!work)
-		return -ENOMEM;
-
-	stgt_queue_work(session-&gt;target, work);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(stgt_cmnd_queue);
-
-static struct stgt_cmnd *find_cmnd_by_id(uint64_t cid)
-{
-	struct list_head *head;
-	struct stgt_cmnd *cmnd;
-	unsigned long flags;
-
-	head = &amp;cmnd_hash[cmnd_hashfn(cid)];
-
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
-
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd-&gt;cid == cid)
-			goto found;
-	}
-	cmnd = NULL;
-found:
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
-
-	return cmnd;
-}
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	int err = 0;
-	struct stgt_event *ev = NLMSG_DATA(nlh);
-	struct stgt_cmnd *cmnd;
-	struct stgt_target *target;
-
-	daemon_pid  = NETLINK_CREDS(skb)-&gt;pid;
-
-	dprintk(&quot;%d %d\n&quot;, daemon_pid, nlh-&gt;nlmsg_type);
-
-	switch (nlh-&gt;nlmsg_type) {
-	case STGT_UEVENT_START:
-		dprintk(&quot;start %d\n&quot;, daemon_pid);
-		break;
-	case STGT_UEVENT_TARGET_CREATE:
-		target = stgt_target_create(ev-&gt;u.c_target.type,
-					    ev-&gt;u.c_target.nr_cmnds);
-		if (target)
-			err = target-&gt;tid;
-		else
-			err = -EINVAL;
-		break;
-	case STGT_UEVENT_TARGET_DESTROY:
-		target = target_find(ev-&gt;u.d_target.tid);
-		if (target)
-			err = stgt_target_destroy(target);
-		else
-			err = -EINVAL;
-		break;
-	case STGT_UEVENT_DEVICE_CREATE:
-		if (nlh-&gt;nlmsg_len &lt;= NLMSG_SPACE(sizeof(*ev))) {
-			err = -EINVAL;
-			break;
-		}
-		err = stgt_device_create(ev-&gt;u.c_device.tid,
-					 ev-&gt;u.c_device.dev_id,
-					 ev-&gt;u.c_device.type,
-					 (char *) ev + sizeof(*ev),
-					 ev-&gt;u.c_device.flags);
-		break;
-	case STGT_UEVENT_DEVICE_DESTROY:
-		err = stgt_device_destroy(ev-&gt;u.d_device.tid,
-					  ev-&gt;u.d_device.dev_id);
-		break;
-	case STGT_UEVENT_CMND_RES:
-		cmnd = find_cmnd_by_id(ev-&gt;u.cmnd_res.cid);
-		if (cmnd)
-			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
-					 ev-&gt;u.cmnd_res.result,
-					 ev-&gt;u.cmnd_res.len);
-		else {
-			eprintk(&quot;cannot found %llu\n&quot;, ev-&gt;u.cmnd_res.cid);
-			err = -EEXIST;
-		}
-		break;
-	default:
-		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
-{
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len = NLMSG_SPACE(size);
-
-	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
-	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
-	memcpy(NLMSG_DATA(nlh), data, size);
-
-	return netlink_unicast(nls, skb, pid, 0);
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-	struct stgt_event *ev;
-
-	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb-&gt;data;
-		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
-			return 0;
-		ev = NLMSG_DATA(nlh);
-		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
-		if (rlen &gt; skb-&gt;len)
-			rlen = skb-&gt;len;
-		err = event_recv_msg(skb, nlh);
-
-		eprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
-		ev-&gt;k.event_res.err = err;
-		if (nlh-&gt;nlmsg_type != STGT_UEVENT_CMND_RES)
-			send_event_res(NETLINK_CREDS(skb)-&gt;pid,
-				       STGT_KEVENT_RESPONSE,
-				       ev, sizeof(*ev));
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
-		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
-			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
-static void __exit stgt_exit(void)
-{
-	if (cmnd_slab)
-		kmem_cache_destroy(cmnd_slab);
-
-	if (work_slab)
-		kmem_cache_destroy(work_slab);
-
-	if (nls)
-		sock_release(nls-&gt;sk_socket);
-
-	stgt_sysfs_exit();
-}
-
-static int __init stgt_init(void)
-{
-	int i, err = -ENOMEM;
-
-	spin_lock_init(&amp;all_targets_lock);
-	spin_lock_init(&amp;atomic_sessions_lock);
-	spin_lock_init(&amp;cmnd_hash_lock);
-	spin_lock_init(&amp;target_tmpl_lock);
-	spin_lock_init(&amp;device_tmpl_lock);
-
-	tgt_protocol_init();
-
-	err = stgt_sysfs_init();
-	if (err)
-		return err;
-
-	cmnd_slab = kmem_cache_create(&quot;stgt_cmnd&quot;, sizeof(struct stgt_cmnd), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!cmnd_slab)
-		goto out;
-
-	work_slab = kmem_cache_create(&quot;stgt_work&quot;, sizeof(struct stgt_work), 0,
-				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-				      NULL, NULL);
-	if (!work_slab)
-		goto out;
-
-	nls = netlink_kernel_create(NETLINK_STGT, event_recv);
-	if (!nls)
-		goto out;
-
-	for (i = 0; i &lt; ARRAY_SIZE(cmnd_hash); i++)
-		INIT_LIST_HEAD(&amp;cmnd_hash[i]);
-
-	return 0;
-out:
-	stgt_exit();
-	return err;
-}
-
-module_init(stgt_init);
-module_exit(stgt_exit);

Deleted: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,70 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#ifndef __SCSI_TARGET_H
-#define __SCSI_TARGET_H
-
-#include &lt;linux/mempool.h&gt;
-#include &lt;scsi/scsi_cmnd.h&gt;
-
-struct stgt_session {
-	struct stgt_target *target;
-	struct list_head slist;
-
-	mempool_t *cmnd_pool;
-	mempool_t *work_pool;
-};
-
-struct stgt_cmnd {
-	struct stgt_session *session;
-
-	uint32_t state;
-	uint64_t dev_id;
-	uint64_t cid;
-
-	int rw;
-
-	void (*done) (struct stgt_cmnd *);
-
-	struct list_head clist;
-	struct list_head hash_list;
-
-	int sg_count;
-	struct scatterlist *sg;
-	uint32_t bufflen;
-	uint64_t offset;
-
-	int result;
-
-	/* TODO: there should be a better way. */
-	uint8_t *error_buff;
-	int error_buff_len;
-
-	/*
-	 * target driver private
-	 */
-	void *private;
-
-	void *tgt_protocol_private;
-};
-
-extern struct stgt_session *
-stgt_session_create(struct stgt_target *target,
-		    int max_cmnds,
-		    void (*done)(void *, struct stgt_session *), void *arg);
-extern int stgt_session_destroy(struct stgt_session *session);
-
-extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session,
-					  uint8_t *proto_data,
-					  uint8_t *id_buff, int buff_size);
-extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
-extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
-				  void (*done)(struct stgt_cmnd *));
-extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
-			   void (*done)(struct stgt_cmnd *));
-extern int stgt_sysfs_init(void);
-extern void stgt_sysfs_exit(void);
-#endif

Deleted: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_device.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,55 +0,0 @@
-/*
- * STGT device
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-#ifndef __SCSI_STGT_DEVICE_H
-#define __SCSI_STGT_DEVICE_H
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/list.h&gt;
-
-struct stgt_device;
-struct stgt_cmnd;
-
-struct stgt_device_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	int (* create)(struct stgt_device *);
-	void (* destroy)(struct stgt_device *);
-	int (* queue_cmnd)(struct stgt_device *device, struct stgt_cmnd *cmd);
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **device_attrs;
-};
-
-struct stgt_device {
-	struct stgt_device_template *sdt;
-	void *sdt_data;
-
-	struct class_device cdev;
-
-        char *path;
-        uint64_t dev_id;
-        uint32_t blk_shift;
-        uint64_t size;
-
-        struct stgt_target *target;
-        struct list_head dlist;
-};
-
-#define cdev_to_stgt_device(cdev) \
-        container_of(cdev, struct stgt_device, cdev)
-
-extern int stgt_sysfs_register_device(struct stgt_device *device);
-extern void stgt_sysfs_unregister_device(struct stgt_device *device);
-extern int stgt_device_template_register(struct stgt_device_template *sdt);
-extern void stgt_device_template_unregister(struct stgt_device_template *sdt);
-
-#endif

Deleted: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_sysfs.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,238 +0,0 @@
-/*
- * STGT core sysfs files
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-#include &lt;stgt_target.h&gt;
-#include &lt;stgt_device.h&gt;
-
-/*
- * Target files
- */
-#define stgt_target_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct stgt_target *target = cdev_to_stgt_target(cdev);		\
-	return snprintf (buf, 20, format_string, target-&gt;field);	\
-}
-
-#define stgt_target_rd_attr(field, format_string)		\
-	stgt_target_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-stgt_target_rd_attr(queued_cmnds, &quot;%u\n&quot;);
-
-static struct class_device_attribute *stgt_target_attrs[] = {
-	&amp;class_device_attr_queued_cmnds,
-	NULL
-};
-
-static void stgt_target_class_release(struct class_device *cdev)
-{
-	struct stgt_target *target = cdev_to_stgt_target(cdev);
-	kfree(target-&gt;stt_data);
-	kfree(target);
-}
-
-static struct class stgt_target_class = {
-	.name = &quot;stgt_target&quot;,
-	.release = stgt_target_class_release,
-};
-
-static struct class_device_attribute *class_attr_overridden(
-				struct class_device_attribute **attrs,
-				struct class_device_attribute *attr)
-{
-	int i;
-
-	if (!attrs)
-		return NULL;
-
-	for (i = 0; attrs[i]; i++)
-		if (!strcmp(attrs[i]-&gt;attr.name, attr-&gt;attr.name))
-			return attrs[i];
-	return NULL;
-}
-
-static int class_attr_add(struct class_device *classdev,
-			  struct class_device_attribute *attr)
-{
-	struct class_device_attribute *base_attr;
-
-	/*
-	 * Spare the caller from having to copy things it's not interested in.
-	*/
-	base_attr = class_attr_overridden(stgt_target_attrs, attr);
-	if (base_attr) {
-		/* extend permissions */
-		attr-&gt;attr.mode |= base_attr-&gt;attr.mode;
-
-		/* override null show/store with default */
-		if (!attr-&gt;show)
-			attr-&gt;show = base_attr-&gt;show;
-		if (!attr-&gt;store)
-			attr-&gt;store = base_attr-&gt;store;
-	}
-
-	return class_device_create_file(classdev, attr);
-}
-
-int stgt_sysfs_register_target(struct stgt_target *target)
-{
-	struct class_device *cdev = &amp;target-&gt;cdev;
-	int err, i;
-
-	cdev-&gt;class = &amp;stgt_target_class;
-	snprintf(cdev-&gt;class_id, BUS_ID_SIZE, &quot;target%d&quot;, target-&gt;tid);
-
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	if (target-&gt;stt-&gt;target_attrs) {
-		for (i = 0; target-&gt;stt-&gt;target_attrs[i]; i++) {
-			err = class_attr_add(&amp;target-&gt;cdev,
-					     target-&gt;stt-&gt;target_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
-	for (i = 0; stgt_target_attrs[i]; i++) {
-		if (!class_attr_overridden(target-&gt;stt-&gt;target_attrs,
-					   stgt_target_attrs[i])) {
-			err = class_device_create_file(&amp;target-&gt;cdev,
-						       stgt_target_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-	class_device_unregister(cdev);
-	return err;
-}
-
-void stgt_sysfs_unregister_target(struct stgt_target *target)
-{
-	class_device_unregister(&amp;target-&gt;cdev);
-}
-
-/*
- * Device files
- */
-#define stgt_device_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct stgt_device *device = cdev_to_stgt_device(cdev);		\
-	return sprintf(buf, format_string, device-&gt;field);	\
-}
-
-#define stgt_device_rd_attr(field, format_string)		\
-	stgt_device_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-stgt_device_rd_attr(path, &quot;%s\n&quot;);
-stgt_device_rd_attr(size, &quot;%llu\n&quot;);
-
-static struct class_device_attribute *stgt_device_attrs[] = {
-	&amp;class_device_attr_path,
-	&amp;class_device_attr_size,
-	NULL,
-};
-
-
-static void stgt_device_class_release(struct class_device *cdev)
-{
-	struct stgt_device *device = cdev_to_stgt_device(cdev);
-	struct stgt_target *target = device-&gt;target;
-
-	class_device_put(&amp;target-&gt;cdev);
-	kfree(device-&gt;sdt_data);
-	kfree(device-&gt;path);
-	kfree(device);
-}
-
-static struct class stgt_device_class = {
-	.name = &quot;stgt_device&quot;,
-	.release = stgt_device_class_release,
-};
-
-int stgt_sysfs_register_device(struct stgt_device *device)
-{
-	struct stgt_target *target = device-&gt;target;
-	struct class_device *cdev = &amp;device-&gt;cdev;
-	int err, i;
-
-	cdev-&gt;class = &amp;stgt_device_class;
-	snprintf(cdev-&gt;class_id, BUS_ID_SIZE, &quot;device%d:%llu&quot;,
-		 target-&gt;tid, device-&gt;dev_id);
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	/*
-	 * get handle to target so our parent is never released before
-	 * us
-	 */
-	if (!class_device_get(&amp;target-&gt;cdev))
-		return -EINVAL;
-
-	if (device-&gt;sdt-&gt;device_attrs) {
-		for (i = 0; device-&gt;sdt-&gt;device_attrs[i]; i++) {
-			err = class_attr_add(&amp;device-&gt;cdev,
-					     device-&gt;sdt-&gt;device_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
-	for (i = 0; stgt_device_attrs[i]; i++) {
-		if (!class_attr_overridden(device-&gt;sdt-&gt;device_attrs,
-					   stgt_device_attrs[i])) {
-			err = class_device_create_file(&amp;device-&gt;cdev,
-						       stgt_device_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-	class_device_put(&amp;target-&gt;cdev);
-	class_device_unregister(cdev);
-	return err;
-
-}
-
-void stgt_sysfs_unregister_device(struct stgt_device *device)
-{
-	class_device_unregister(&amp;device-&gt;cdev);
-}
-
-int stgt_sysfs_init(void)
-{
-	int err;
-
-	err = class_register(&amp;stgt_target_class);
-	if (err)
-		return err;
-
-	err = class_register(&amp;stgt_device_class);
-	if (err)
-		class_unregister(&amp;stgt_target_class);
-	return err;
-}
-
-void stgt_sysfs_exit(void)
-{
-	class_unregister(&amp;stgt_target_class);
-	class_unregister(&amp;stgt_device_class);
-}

Deleted: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_target.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,69 +0,0 @@
-/*
- * STGT target definitions
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-#ifndef __SCSI_STGT_TARGET_H
-#define __SCSI_STGT_TARGET_H
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/list.h&gt;
-
-struct tgt_protocol;
-struct stgt_target;
-
-struct stgt_target_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	int (* target_create) (struct stgt_target *);
-	void (* target_destroy) (struct stgt_target *);
-
-	/*
-	 * name of protocol to use
-	 */
-	const char *protocol;
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **target_attrs;
-};
-
-struct stgt_target {
-	int tid;
-	struct stgt_target_template *stt;
-	void *stt_data;
-	struct tgt_protocol *proto;
-
-	struct class_device cdev;
-
-	int queued_cmnds;
-
-	/* Protects session_list, work_list, device_list */
-	spinlock_t lock;
-
-	struct list_head tlist;
-
-	struct list_head device_list;
-	struct list_head session_list;
-
-	struct work_struct work;
-	struct list_head work_list;
-	struct workqueue_struct *twq;
-};
-
-#define cdev_to_stgt_target(cdev) \
-	container_of(cdev, struct stgt_target, cdev)
-
-extern struct stgt_target *stgt_target_create(char *target_type, int nr_cmnds);
-extern int stgt_target_destroy(struct stgt_target *target);
-extern int stgt_sysfs_register_target(struct stgt_target *target);
-extern void stgt_sysfs_unregister_target(struct stgt_target *target);
-extern int stgt_target_template_register(struct stgt_target_template *stt);
-extern void stgt_target_template_unregister(struct stgt_target_template *stt);
-
-#endif

Deleted: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/stgt_vsd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,149 +0,0 @@
-/*
- * virtual device
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#include &lt;linux/types.h&gt;
-#include &lt;linux/blkdev.h&gt;
-#include &lt;linux/namei.h&gt;
-#include &lt;linux/uio.h&gt;
-#include &lt;linux/fs.h&gt;
-#include &lt;linux/writeback.h&gt;
-
-#include &lt;stgt.h&gt;
-#include &lt;stgt_device.h&gt;
-
-struct stgt_vsd_dev {
-	struct file *filp;
-};
-
-static void stgt_vsd_destroy(struct stgt_device *device)
-{
-	struct stgt_vsd_dev *vsddev = device-&gt;sdt_data;
-	filp_close(vsddev-&gt;filp, NULL);
-}
-
-static int open_file(struct stgt_vsd_dev *vsddev, const char *path)
-{
-	struct file *filp;
-	mm_segment_t oldfs;
-	int err = 0;
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
-	set_fs(oldfs);
-
-	if (IS_ERR(filp)) {
-		err = PTR_ERR(filp);
-		printk(&quot;Can't open %s %d\n&quot;, path, err);
-	} else
-		vsddev-&gt;filp = filp;
-
-	return err;
-}
-
-static int stgt_vsd_create(struct stgt_device *device)
-{
-	struct stgt_vsd_dev *vsddev = device-&gt;sdt_data;
-	struct inode *inode;
-	int err = 0;
-
-	err = open_file(vsddev, device-&gt;path);
-	if (err)
-		return err;
-
-	inode = vsddev-&gt;filp-&gt;f_dentry-&gt;d_inode;
-	if (S_ISREG(inode-&gt;i_mode))
-		;
-	else if (S_ISBLK(inode-&gt;i_mode))
-		inode = inode-&gt;i_bdev-&gt;bd_inode;
-	else {
-		err = -EINVAL;
-		goto out;
-	}
-
-	device-&gt;size = inode-&gt;i_size;
-	printk(&quot;%s %llu\n&quot;, device-&gt;path, inode-&gt;i_size &gt;&gt; 9);
-
-	return 0;
-out:
-	filp_close(vsddev-&gt;filp, NULL);
-	return err;
-}
-
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i &lt; sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
-{
-	struct stgt_vsd_dev *vsddev = device-&gt;sdt_data;
-	ssize_t size;
-	struct iovec *iov;
-	loff_t pos = cmnd-&gt;offset;
-	int err = 0;
-
-	if (cmnd-&gt;bufflen + pos &gt; device-&gt;size)
-		return -EOVERFLOW;
-
-	iov = sg_to_iovec(cmnd-&gt;sg, cmnd-&gt;sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (cmnd-&gt;rw == READ)
-		size = generic_file_readv(vsddev-&gt;filp, iov, cmnd-&gt;sg_count, &amp;pos);
-	else
-		size = generic_file_writev(vsddev-&gt;filp, iov, cmnd-&gt;sg_count, &amp;pos);
-
-	kfree(iov);
-
-/* not yet used
-	if (sync)
-		err = sync_page_range(inode, inode-&gt;i_mapping, pos,
-				      (size_t) cmnd-&gt;bufflen);
-*/
-	if ((size != cmnd-&gt;bufflen) || err)
-		return -EIO;
-	else
-		return 0;
-}
-
-static struct stgt_device_template stgt_vsd = {
-	.name = &quot;stgt_vsd&quot;,
-	.module = THIS_MODULE,
-	.create = stgt_vsd_create,
-	.destroy = stgt_vsd_destroy,
-	.queue_cmnd = stgt_vsd_queue,
-};
-
-static int __init stgt_vsd_init(void)
-{
-	stgt_vsd.priv_data_size = sizeof(struct stgt_vsd_dev);
-	return stgt_device_template_register(&amp;stgt_vsd);
-}
-
-static void __exit stgt_vsd_exit(void)
-{
-	stgt_device_template_unregister(&amp;stgt_vsd);
-}
-
-module_init(stgt_vsd_init);
-module_exit(stgt_vsd_exit);
-MODULE_LICENSE(&quot;GPL&quot;);

Copied: trunk/kernel/tgt.c (from rev 67, trunk/kernel/stgt.c)
===================================================================
--- trunk/kernel/stgt.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,1071 @@
+/*
+ * Core Target Framework code
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/hash.h&gt;
+#include &lt;linux/pagemap.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/mempool.h&gt;
+#include &lt;linux/netlink.h&gt;
+#include &lt;asm/scatterlist.h&gt;
+#include &lt;net/tcp.h&gt;
+
+#include &lt;tgt.h&gt;
+#include &lt;tgt_target.h&gt;
+#include &lt;tgt_device.h&gt;
+#include &lt;tgt_if.h&gt;
+#include &lt;tgt_protocol.h&gt;
+
+#define DEBUG_TGT
+
+#define eprintk(fmt, args...)					\
+do {								\
+	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#ifdef DEBUG_TGT
+#define dprintk eprintk
+#else
+#define dprintk(fmt, args...)
+#endif
+
+#define assert(p) do {						\
+	if (!(p)) {						\
+		printk(KERN_CRIT &quot;BUG at %s:%d assert(%s)\n&quot;,	\
+		       __FILE__, __LINE__, #p);			\
+		dump_stack();					\
+		BUG();						\
+	}							\
+} while (0)
+
+MODULE_LICENSE(&quot;GPL&quot;);
+
+static spinlock_t all_targets_lock;
+static LIST_HEAD(all_targets);
+
+static spinlock_t target_tmpl_lock;
+static LIST_HEAD(target_tmpl_list);
+
+static spinlock_t device_tmpl_lock;
+static LIST_HEAD(device_tmpl_list);
+
+static void session_init_handler(void *data);
+static spinlock_t atomic_sessions_lock;
+static LIST_HEAD(atomic_sessions);
+static DECLARE_WORK(atomic_session_work, session_init_handler,
+		    &amp;atomic_sessions);
+
+static int daemon_pid;
+static struct sock *nls;
+
+static kmem_cache_t *cmnd_slab, *work_slab;
+
+/* TODO: lock per session */
+static spinlock_t cmnd_hash_lock;
+#define TGT_HASH_ORDER		8
+#define	cmnd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
+static struct list_head cmnd_hash[1 &lt;&lt; TGT_HASH_ORDER];
+
+struct atomic_session_args {
+	struct tgt_session *session;
+	void (*done) (void *, struct tgt_session *);
+	int max_cmnds;
+	void *arg;
+	struct list_head list;
+};
+
+struct tgt_work {
+	void (*fn) (void *);
+	void *arg;
+	mempool_t *pool;
+	struct list_head list;
+};
+
+static struct tgt_work * tgt_init_work(struct tgt_session *session,
+					void (*fn)(void *), void *arg)
+{
+	struct tgt_work *work;
+	mempool_t *pool = session-&gt;work_pool;
+
+	work = mempool_alloc(pool, GFP_ATOMIC);
+	if (!work)
+		return NULL;
+
+	work-&gt;fn = fn;
+	work-&gt;arg = arg;
+	work-&gt;pool = pool;
+
+	return work;
+}
+
+static void tgt_worker(void *data)
+{
+	struct tgt_target *target = (struct tgt_target *) data;
+	struct tgt_work *work = NULL;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	if (!list_empty(&amp;target-&gt;work_list)) {
+		work = list_entry(target-&gt;work_list.next, struct tgt_work, list);
+		list_del(&amp;work-&gt;list);
+	}
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+
+	if (work) {
+		work-&gt;fn(work-&gt;arg);
+		mempool_free(work, work-&gt;pool);
+	}
+
+	return;
+}
+
+static void tgt_queue_work(struct tgt_target *target, struct tgt_work *work)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	list_add_tail(&amp;work-&gt;list, &amp;target-&gt;work_list);
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+
+	queue_work(target-&gt;twq, &amp;target-&gt;work);
+}
+
+struct target_type_internal {
+	struct list_head list;
+	struct tgt_target_template *tt;
+	struct tgt_protocol *proto;
+};
+
+static struct target_type_internal *target_template_get(const char *name)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &amp;target_tmpl_list, list)
+		if (!strcmp(name, ti-&gt;tt-&gt;name)) {
+			if (!try_module_get(ti-&gt;tt-&gt;module))
+				ti = NULL;
+			spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
+			return ti;
+		}
+
+	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void target_template_put(struct tgt_target_template *tt)
+{
+	module_put(tt-&gt;module);
+}
+
+int tgt_target_template_register(struct tgt_target_template *tt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&amp;ti-&gt;list);
+	ti-&gt;tt = tt;
+
+	ti-&gt;proto = tgt_protocol_get(tt-&gt;protocol);
+	if (!ti-&gt;proto) {
+		eprintk(&quot;Could not find %s protocol\n&quot;, tt-&gt;protocol);
+		kfree(ti);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
+	list_add_tail(&amp;ti-&gt;list, &amp;target_tmpl_list);
+	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_target_template_register);
+
+void tgt_target_template_unregister(struct tgt_target_template *tt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&amp;target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &amp;target_tmpl_list, list)
+		if (ti-&gt;tt == tt) {
+			list_del(&amp;ti-&gt;list);
+			tgt_protocol_put(ti-&gt;proto);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&amp;target_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
+
+static struct tgt_target *target_find(int tid)
+{
+	struct tgt_target *target;
+
+	spin_lock(&amp;all_targets_lock);
+	list_for_each_entry(target, &amp;all_targets, tlist) {
+		if (target-&gt;tid == tid)
+			goto found;
+	}
+	target = NULL;
+found:
+	spin_unlock(&amp;all_targets_lock);
+
+	return target;
+}
+
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmnds)
+{
+	char name[16];
+	static int target_id;
+	struct tgt_target *target;
+	struct target_type_internal *ti;
+
+	if (!daemon_pid) {
+		eprintk(&quot;%s\n&quot;, &quot;Run the user-space daemon first!&quot;);
+		return NULL;
+	}
+
+	target = kmalloc(sizeof(*target), GFP_KERNEL);
+	if (!target)
+		return NULL;
+	memset(target, 0, sizeof(*target));
+
+	ti = target_template_get(target_type);
+	if (!ti)
+		goto free_target;
+
+	target-&gt;tt = ti-&gt;tt;
+	target-&gt;proto = ti-&gt;proto;
+	target-&gt;tid = target_id++;
+	spin_lock_init(&amp;target-&gt;lock);
+
+	INIT_LIST_HEAD(&amp;target-&gt;session_list);
+	INIT_LIST_HEAD(&amp;target-&gt;device_list);
+	INIT_LIST_HEAD(&amp;target-&gt;work_list);
+
+	INIT_WORK(&amp;target-&gt;work, tgt_worker, target);
+	target-&gt;queued_cmnds = queued_cmnds;
+
+	snprintf(name, sizeof(name), &quot;tgtd%d&quot;, target-&gt;tid);
+	target-&gt;twq = create_workqueue(name);
+	if (!target-&gt;twq)
+		goto put_template;
+
+	target-&gt;tt_data = kmalloc(sizeof(target-&gt;tt-&gt;priv_data_size), GFP_KERNEL);
+	if (!target-&gt;tt_data)
+		goto free_workqueue;
+
+	if (target-&gt;tt-&gt;target_create)
+		if (target-&gt;tt-&gt;target_create(target))
+			goto free_priv_tt_data;
+
+	if (tgt_sysfs_register_target(target))
+		goto tt_destroy;
+
+	spin_lock(&amp;all_targets_lock);
+	list_add(&amp;target-&gt;tlist, &amp;all_targets);
+	spin_unlock(&amp;all_targets_lock);
+	return target;
+
+tt_destroy:
+	if (target-&gt;tt-&gt;target_destroy)
+		target-&gt;tt-&gt;target_destroy(target);
+free_priv_tt_data:
+	kfree(target-&gt;tt_data);
+free_workqueue:
+	destroy_workqueue(target-&gt;twq);
+put_template:
+	target_template_put(target-&gt;tt);
+free_target:
+	kfree(target);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(tgt_target_create);
+
+int tgt_target_destroy(struct tgt_target *target)
+{
+	dprintk(&quot;%p\n&quot;, target);
+
+	spin_lock(&amp;all_targets_lock);
+	list_del(&amp;target-&gt;tlist);
+	spin_unlock(&amp;all_targets_lock);
+
+	if (target-&gt;tt-&gt;target_destroy)
+		target-&gt;tt-&gt;target_destroy(target);
+
+	destroy_workqueue(target-&gt;twq);
+	target_template_put(target-&gt;tt);
+	tgt_sysfs_unregister_target(target);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_target_destroy);
+
+static int session_init(struct tgt_session *session, int max_cmnds)
+{
+	struct tgt_target *target = session-&gt;target;
+	unsigned long flags;
+
+	session-&gt;cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
+					    mempool_free_slab, cmnd_slab);
+	if (!session-&gt;cmnd_pool)
+		goto out;
+
+	session-&gt;work_pool = mempool_create(max_cmnds, mempool_alloc_slab,
+					    mempool_free_slab, work_slab);
+	if (!session-&gt;work_pool)
+		goto out;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	list_add(&amp;session-&gt;slist, &amp;target-&gt;session_list);
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+
+	return 0;
+out:
+	if (session-&gt;cmnd_pool)
+		mempool_destroy(session-&gt;cmnd_pool);
+
+	if (session-&gt;work_pool)
+		mempool_destroy(session-&gt;work_pool);
+
+	return -ENOMEM;
+}
+
+static void session_init_handler(void *data)
+{
+	struct list_head *head = (struct list_head *) data;
+	struct atomic_session_args *ssa = NULL;
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&amp;atomic_sessions_lock, flags);
+	if (!list_empty(&amp;atomic_sessions)) {
+		ssa = list_entry(head-&gt;next, struct atomic_session_args, list);
+		list_del(&amp;ssa-&gt;list);
+	}
+	spin_unlock_irqrestore(&amp;atomic_sessions_lock, flags);
+
+	if (!ssa)
+		return;
+
+	err = session_init(ssa-&gt;session, ssa-&gt;max_cmnds);
+	if (err)
+		kfree(ssa-&gt;session);
+
+	ssa-&gt;done(ssa-&gt;arg, err ? NULL : ssa-&gt;session);
+
+	kfree(ssa);
+}
+
+static int session_atomic_init(struct tgt_session *session,
+			       int max_cmnds,
+			       void (*done) (void *, struct tgt_session *),
+			       int *arg)
+{
+	struct atomic_session_args *ssa;
+	unsigned long flags;
+
+	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
+	if (!ssa)
+		return -ENOMEM;
+
+	ssa-&gt;session = session;
+	ssa-&gt;max_cmnds = max_cmnds;
+	ssa-&gt;arg = arg;
+
+	spin_lock_irqsave(&amp;atomic_sessions_lock, flags);
+	list_add(&amp;ssa-&gt;list, &amp;atomic_sessions);
+	spin_unlock_irqrestore(&amp;atomic_sessions_lock, flags);
+
+	queue_work(session-&gt;target-&gt;twq, &amp;atomic_session_work);
+
+	return 0;
+}
+
+struct tgt_session *
+tgt_session_create(struct tgt_target *target,
+		   int max_cmnds,
+		   void (*done)(void *, struct tgt_session *),
+		   void *arg)
+{
+	struct tgt_session *session;
+
+	if (!target) {
+		eprintk(&quot;%s\n&quot;, &quot;Null target pointer!&quot;);
+		return NULL;
+	}
+
+	if (done &amp;&amp; !arg) {
+		eprintk(&quot;%s\n&quot;, &quot;Need arg !&quot;);
+		return NULL;
+	}
+
+	dprintk(&quot;%p %d\n&quot;, target, max_cmnds);
+
+	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
+	if (!session)
+		return NULL;
+
+	memset(session, 0, sizeof(*session));
+	session-&gt;target = target;
+	INIT_LIST_HEAD(&amp;session-&gt;slist);
+
+	if (done) {
+		if (session_atomic_init(session, max_cmnds, done, arg) &lt; 0)
+			goto out;
+
+		return session;
+	}
+
+	if (session_init(session, max_cmnds) &lt; 0)
+		goto out;
+
+	return session;
+
+out:
+	kfree(session);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(tgt_session_create);
+
+int tgt_session_destroy(struct tgt_session *session)
+{
+	mempool_destroy(session-&gt;cmnd_pool);
+	mempool_destroy(session-&gt;work_pool);
+	kfree(session);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_session_destroy);
+
+struct device_type_internal {
+	struct tgt_device_template *sdt;
+	struct list_head list;
+};
+
+static struct tgt_device_template *device_template_get(const char *name)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &amp;device_tmpl_list, list)
+		if (!strcmp(name, ti-&gt;sdt-&gt;name)) {
+			if (!try_module_get(ti-&gt;sdt-&gt;module))
+				ti = NULL;
+			spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
+			return ti ? ti-&gt;sdt : NULL;
+		}
+
+	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void device_template_put(struct tgt_device_template *sdt)
+{
+	module_put(sdt-&gt;module);
+}
+
+int tgt_device_template_register(struct tgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&amp;ti-&gt;list);
+	ti-&gt;sdt = sdt;
+
+	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
+	list_add_tail(&amp;ti-&gt;list, &amp;device_tmpl_list);
+	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_device_template_register);
+
+void tgt_device_template_unregister(struct tgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&amp;device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &amp;device_tmpl_list, list)
+		if (ti-&gt;sdt == sdt) {
+			list_del(&amp;ti-&gt;list);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&amp;device_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_device_template_unregister);
+
+/*
+ * TODO: use a hash or any better alg/ds
+ */
+static struct tgt_device *
+tgt_device_find_nolock(struct tgt_target *target, uint64_t dev_id)
+{
+	struct tgt_device *device;
+
+	list_for_each_entry(device, &amp;target-&gt;device_list, dlist)
+		if (device-&gt;dev_id == dev_id)
+			return device;
+
+	return NULL;
+}
+
+static struct tgt_device *
+tgt_device_find(struct tgt_target *target, uint64_t dev_id)
+{
+	static struct tgt_device *device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+
+	return device;
+}
+
+static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
+			      char *path, unsigned long dflags)
+{
+	struct tgt_target *target;
+	struct tgt_device *device;
+	unsigned long flags;
+
+	dprintk(&quot;%d %llu %s %s\n&quot;, tid, dev_id, device_type, path);
+
+	target = target_find(tid);
+	if (!target)
+		return -EINVAL;
+
+	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+
+	memset(device, 0, sizeof(*device));
+	device-&gt;dev_id = dev_id;
+	device-&gt;target = target;
+	device-&gt;path = kstrdup(path, GFP_KERNEL);
+	if (!device-&gt;path)
+		goto free_device;
+
+	device-&gt;dt = device_template_get(device_type);
+	if (!device-&gt;dt) {
+		eprintk(&quot;Could not get devive type %s\n&quot;, device_type);
+		goto free_path;
+	}
+
+	device-&gt;dt_data = kmalloc(sizeof(device-&gt;dt-&gt;priv_data_size),
+				   GFP_KERNEL);
+	if (!device-&gt;dt_data)
+		goto put_template;
+
+	if (device-&gt;dt-&gt;create)
+		if (device-&gt;dt-&gt;create(device))
+			goto free_priv_dt_data;
+
+	if (tgt_sysfs_register_device(device))
+		goto dt_destroy;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	list_add(&amp;device-&gt;dlist, &amp;target-&gt;device_list);
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+
+	return 0;
+
+dt_destroy:
+	if (device-&gt;dt-&gt;destroy)
+		device-&gt;dt-&gt;destroy(device);
+free_priv_dt_data:
+	kfree(device-&gt;dt_data);
+put_template:
+	device_template_put(device-&gt;dt);
+free_path:
+	kfree(device-&gt;path);
+free_device:
+	kfree(device);
+	return -EINVAL;
+}
+
+static int tgt_device_destroy(int tid, uint64_t dev_id)
+{
+	struct tgt_device *device;
+	struct tgt_target *target;
+	unsigned long flags;
+
+	target = target_find(tid);
+	if (!target)
+		return -ENOENT;
+
+	spin_lock_irqsave(&amp;target-&gt;lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	spin_unlock_irqrestore(&amp;target-&gt;lock, flags);
+	if (!device)
+		return -EINVAL;
+
+	list_del(&amp;device-&gt;dlist);
+	if (device-&gt;dt-&gt;destroy)
+		device-&gt;dt-&gt;destroy(device);
+
+	device_template_put(device-&gt;dt);
+	tgt_sysfs_unregister_device(device);
+
+	return 0;
+}
+
+struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
+				   uint8_t *proto_data,
+				   uint8_t *id_buff, int buff_size)
+{
+	struct tgt_protocol *proto = session-&gt;target-&gt;proto;
+	struct tgt_cmnd *cmnd;
+	void *pcmnd_data;
+	unsigned long flags;
+
+	/*
+	 * slab in tgt_protocol structure like struct proto (in net/sock.h) ?
+	 * However, how can we guarantee the specified number of commands ?
+	 */
+	pcmnd_data = kmalloc(proto-&gt;priv_cmd_data_size, GFP_ATOMIC);
+	if (!pcmnd_data)
+		return NULL;
+
+	cmnd = mempool_alloc(session-&gt;cmnd_pool, GFP_ATOMIC);
+	assert(cmnd);
+	memset(cmnd, 0, sizeof(*cmnd));
+	cmnd-&gt;tgt_protocol_private = pcmnd_data;
+	cmnd-&gt;session = session;
+	cmnd-&gt;cid = (uint64_t) (unsigned long) cmnd;
+	INIT_LIST_HEAD(&amp;cmnd-&gt;clist);
+	INIT_LIST_HEAD(&amp;cmnd-&gt;hash_list);
+
+	dprintk(&quot;%p %llu\n&quot;, session, cmnd-&gt;cid);
+
+	proto-&gt;init_cmnd(cmnd, proto_data, id_buff, buff_size);
+
+	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
+	list_add_tail(&amp;cmnd-&gt;hash_list, &amp;cmnd_hash[cmnd_hashfn(cmnd-&gt;cid)]);
+	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+
+	return cmnd;
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_create);
+
+void tgt_cmnd_destroy(struct tgt_cmnd *cmnd)
+{
+	unsigned long flags;
+	int i;
+
+	kfree(cmnd-&gt;tgt_protocol_private);
+
+	for (i = 0; i &lt; cmnd-&gt;sg_count; i++)
+		__free_page(cmnd-&gt;sg[i].page);
+	kfree(cmnd-&gt;sg);
+
+	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
+	list_del(&amp;cmnd-&gt;hash_list);
+	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+
+	mempool_free(cmnd, cmnd-&gt;session-&gt;cmnd_pool);
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_destroy);
+
+#define pgcnt(size, offset)	((((size) + ((offset) &amp; ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) &gt;&gt; PAGE_CACHE_SHIFT)
+
+void __tgt_alloc_buffer(struct tgt_cmnd *cmnd)
+{
+	uint64_t offset = cmnd-&gt;offset;
+	uint32_t len = cmnd-&gt;bufflen;
+	int i;
+
+	cmnd-&gt;sg_count = pgcnt(len, offset);
+	offset &amp;= ~PAGE_CACHE_MASK;
+
+	cmnd-&gt;sg = kmalloc(cmnd-&gt;sg_count * sizeof(struct scatterlist),
+			   GFP_KERNEL | __GFP_NOFAIL);
+
+	for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
+		struct scatterlist *sg = &amp;cmnd-&gt;sg[i];
+
+		sg-&gt;page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
+		sg-&gt;offset = offset;
+		sg-&gt;length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
+
+		offset = 0;
+		len -= sg-&gt;length;
+	}
+}
+
+static void tgt_alloc_buffer(void *data)
+{
+	struct tgt_cmnd *cmnd = data;
+
+	__tgt_alloc_buffer(cmnd);
+
+	if (cmnd-&gt;done) {
+		void (*done)(struct tgt_cmnd *) = cmnd-&gt;done;
+		cmnd-&gt;done = NULL;
+		done(cmnd);
+	}
+}
+
+void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+{
+	struct tgt_protocol *proto = cmnd-&gt;session-&gt;target-&gt;proto;
+
+	assert(list_empty(&amp;cmnd-&gt;clist));
+
+	proto-&gt;init_cmnd_buffer(cmnd);
+
+	if (done) {
+		struct tgt_session *session = cmnd-&gt;session;
+		struct tgt_work *work;
+
+		work = tgt_init_work(session, tgt_alloc_buffer, cmnd);
+		tgt_queue_work(session-&gt;target, work);
+		return;
+	};
+
+	tgt_alloc_buffer(cmnd);
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_alloc_buffer);
+
+static int uspace_cmnd_send(struct tgt_cmnd *cmnd)
+{
+	struct tgt_protocol *proto = cmnd-&gt;session-&gt;target-&gt;proto;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+	char *pdu;
+	int len, proto_pdu_size = proto-&gt;uspace_pdu_size;
+
+	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
+	skb = alloc_skb(NLMSG_SPACE(len), GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+
+	dprintk(&quot;%d %Zd %d\n&quot;, len, sizeof(*ev), proto_pdu_size);
+	nlh = __nlmsg_put(skb, daemon_pid, 0,
+			  TGT_KEVENT_CMND_REQ, len - sizeof(*nlh), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+
+	pdu = (char *) ev + sizeof(*ev);
+	ev-&gt;k.cmnd_req.tid = cmnd-&gt;session-&gt;target-&gt;tid;
+	ev-&gt;k.cmnd_req.dev_id = cmnd-&gt;dev_id;
+	ev-&gt;k.cmnd_req.cid = cmnd-&gt;cid;
+
+	proto-&gt;build_uspace_pdu(cmnd, pdu);
+
+	return netlink_unicast(nls, skb, daemon_pid, 0);
+}
+
+static void cmnd_done(struct tgt_cmnd *cmnd, int result)
+{
+	struct tgt_target *target = cmnd-&gt;session-&gt;target;
+	struct tgt_protocol *proto = target-&gt;proto;
+	void (*done)(struct tgt_cmnd *);
+
+	proto-&gt;cmnd_done(cmnd, result);
+	cmnd-&gt;result = result;
+
+	done = cmnd-&gt;done;
+	cmnd-&gt;done = NULL;
+	done(cmnd);
+}
+
+static void uspace_cmnd_done(struct tgt_cmnd *cmnd, char *data,
+			     int result, uint32_t len)
+{
+	int i;
+	assert(cmnd-&gt;done);
+
+	if (len) {
+		cmnd-&gt;bufflen = len;
+		cmnd-&gt;offset = 0;
+		__tgt_alloc_buffer(cmnd);
+
+		for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
+			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
+			char *p = data;
+
+			memcpy(page_address(cmnd-&gt;sg[i].page), p, copy);
+			p += copy;
+			len -= copy;
+		}
+	}
+
+	cmnd_done(cmnd, result);
+}
+
+static void queuecommand(void *data)
+{
+	int err = 0;
+	struct tgt_cmnd *cmnd = data;
+	struct tgt_target *target = cmnd-&gt;session-&gt;target;
+	struct tgt_device *device;
+
+	/* Should we do this earlier? */
+	device = tgt_device_find(target, cmnd-&gt;dev_id);
+	if (device)
+		dprintk(&quot;found %llu\n&quot;, cmnd-&gt;dev_id);
+
+	if (cmnd-&gt;rw == READ || cmnd-&gt;rw == WRITE)
+		err = device-&gt;dt-&gt;queue_cmnd(device, cmnd);
+	else {
+		err = uspace_cmnd_send(cmnd);
+		if (err &gt;= 0)
+			/* sent to userspace */
+			return;
+	}
+
+	/* kspace command failure or failed to send commands to space. */
+	if (unlikely(err))
+		eprintk(&quot;failed cmnd %llu %d %d\n&quot;, cmnd-&gt;cid, err, cmnd-&gt;rw);
+
+	cmnd_done(cmnd, err);
+}
+
+int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+{
+	struct tgt_work *work;
+	struct tgt_session *session = cmnd-&gt;session;
+
+	assert(!cmnd-&gt;done);
+	cmnd-&gt;done = done;
+	if (!done) {
+		eprintk(&quot;%s\n&quot;, &quot;Null done function!&quot;);
+		return -EINVAL;
+	}
+
+	work = tgt_init_work(session, queuecommand, cmnd);
+	if (!work)
+		return -ENOMEM;
+
+	tgt_queue_work(session-&gt;target, work);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_cmnd_queue);
+
+static struct tgt_cmnd *find_cmnd_by_id(uint64_t cid)
+{
+	struct list_head *head;
+	struct tgt_cmnd *cmnd;
+	unsigned long flags;
+
+	head = &amp;cmnd_hash[cmnd_hashfn(cid)];
+
+	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
+
+	list_for_each_entry(cmnd, head, hash_list) {
+		if (cmnd-&gt;cid == cid)
+			goto found;
+	}
+	cmnd = NULL;
+found:
+	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+
+	return cmnd;
+}
+
+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+{
+	int err = 0;
+	struct tgt_event *ev = NLMSG_DATA(nlh);
+	struct tgt_cmnd *cmnd;
+	struct tgt_target *target;
+
+	daemon_pid  = NETLINK_CREDS(skb)-&gt;pid;
+
+	dprintk(&quot;%d %d\n&quot;, daemon_pid, nlh-&gt;nlmsg_type);
+
+	switch (nlh-&gt;nlmsg_type) {
+	case TGT_UEVENT_START:
+		dprintk(&quot;start %d\n&quot;, daemon_pid);
+		break;
+	case TGT_UEVENT_TARGET_CREATE:
+		target = tgt_target_create(ev-&gt;u.c_target.type,
+					   ev-&gt;u.c_target.nr_cmnds);
+		if (target)
+			err = target-&gt;tid;
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_TARGET_DESTROY:
+		target = target_find(ev-&gt;u.d_target.tid);
+		if (target)
+			err = tgt_target_destroy(target);
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_DEVICE_CREATE:
+		if (nlh-&gt;nlmsg_len &lt;= NLMSG_SPACE(sizeof(*ev))) {
+			err = -EINVAL;
+			break;
+		}
+		err = tgt_device_create(ev-&gt;u.c_device.tid,
+					ev-&gt;u.c_device.dev_id,
+					ev-&gt;u.c_device.type,
+					(char *) ev + sizeof(*ev),
+					ev-&gt;u.c_device.flags);
+		break;
+	case TGT_UEVENT_DEVICE_DESTROY:
+		err = tgt_device_destroy(ev-&gt;u.d_device.tid,
+					 ev-&gt;u.d_device.dev_id);
+		break;
+	case TGT_UEVENT_CMND_RES:
+		cmnd = find_cmnd_by_id(ev-&gt;u.cmnd_res.cid);
+		if (cmnd)
+			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
+					 ev-&gt;u.cmnd_res.result,
+					 ev-&gt;u.cmnd_res.len);
+		else {
+			eprintk(&quot;cannot found %llu\n&quot;, ev-&gt;u.cmnd_res.cid);
+			err = -EEXIST;
+		}
+		break;
+	default:
+		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
+{
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len = NLMSG_SPACE(size);
+
+	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
+	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
+	memcpy(NLMSG_DATA(nlh), data, size);
+
+	return netlink_unicast(nls, skb, pid, 0);
+}
+
+static int event_recv_skb(struct sk_buff *skb)
+{
+	int err;
+	uint32_t rlen;
+	struct nlmsghdr	*nlh;
+	struct tgt_event *ev;
+
+	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
+		nlh = (struct nlmsghdr *) skb-&gt;data;
+		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
+			return 0;
+		ev = NLMSG_DATA(nlh);
+		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
+		if (rlen &gt; skb-&gt;len)
+			rlen = skb-&gt;len;
+		err = event_recv_msg(skb, nlh);
+
+		eprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
+		ev-&gt;k.event_res.err = err;
+		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMND_RES)
+			send_event_res(NETLINK_CREDS(skb)-&gt;pid,
+				       TGT_KEVENT_RESPONSE,
+				       ev, sizeof(*ev));
+		skb_pull(skb, rlen);
+	}
+	return 0;
+}
+
+static void event_recv(struct sock *sk, int length)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
+		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
+			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
+		else
+			kfree_skb(skb);
+	}
+}
+
+static void __exit tgt_exit(void)
+{
+	if (cmnd_slab)
+		kmem_cache_destroy(cmnd_slab);
+
+	if (work_slab)
+		kmem_cache_destroy(work_slab);
+
+	if (nls)
+		sock_release(nls-&gt;sk_socket);
+
+	tgt_sysfs_exit();
+}
+
+static int __init tgt_init(void)
+{
+	int i, err = -ENOMEM;
+
+	spin_lock_init(&amp;all_targets_lock);
+	spin_lock_init(&amp;atomic_sessions_lock);
+	spin_lock_init(&amp;cmnd_hash_lock);
+	spin_lock_init(&amp;target_tmpl_lock);
+	spin_lock_init(&amp;device_tmpl_lock);
+
+	tgt_protocol_init();
+
+	err = tgt_sysfs_init();
+	if (err)
+		return err;
+
+	cmnd_slab = kmem_cache_create(&quot;tgt_cmnd&quot;, sizeof(struct tgt_cmnd), 0,
+				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+				      NULL, NULL);
+	if (!cmnd_slab)
+		goto out;
+
+	work_slab = kmem_cache_create(&quot;tgt_work&quot;, sizeof(struct tgt_work), 0,
+				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+				      NULL, NULL);
+	if (!work_slab)
+		goto out;
+
+	nls = netlink_kernel_create(NETLINK_TGT, event_recv);
+	if (!nls)
+		goto out;
+
+	for (i = 0; i &lt; ARRAY_SIZE(cmnd_hash); i++)
+		INIT_LIST_HEAD(&amp;cmnd_hash[i]);
+
+	return 0;
+out:
+	tgt_exit();
+	return err;
+}
+
+module_init(tgt_init);
+module_exit(tgt_exit);

Copied: trunk/kernel/tgt.h (from rev 67, trunk/kernel/stgt.h)
===================================================================
--- trunk/kernel/stgt.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,71 @@
+/*
+ * Core Target Framework definitions
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+
+#ifndef __TGT_H
+#define __TGT_H
+
+#include &lt;linux/mempool.h&gt;
+
+struct tgt_session {
+	struct tgt_target *target;
+	struct list_head slist;
+
+	mempool_t *cmnd_pool;
+	mempool_t *work_pool;
+};
+
+struct tgt_cmnd {
+	struct tgt_session *session;
+
+	uint32_t state;
+	uint64_t dev_id;
+	uint64_t cid;
+
+	int rw;
+
+	void (*done) (struct tgt_cmnd *);
+
+	struct list_head clist;
+	struct list_head hash_list;
+
+	int sg_count;
+	struct scatterlist *sg;
+	uint32_t bufflen;
+	uint64_t offset;
+
+	int result;
+
+	/* TODO: there should be a better way. */
+	uint8_t *error_buff;
+	int error_buff_len;
+
+	/*
+	 * target driver private
+	 */
+	void *private;
+
+	void *tgt_protocol_private;
+};
+
+extern struct tgt_session *
+tgt_session_create(struct tgt_target *target,
+		   int max_cmnds,
+		   void (*done)(void *, struct tgt_session *), void *arg);
+extern int tgt_session_destroy(struct tgt_session *session);
+
+extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session,
+					uint8_t *proto_data,
+					uint8_t *id_buff, int buff_size);
+extern void tgt_cmnd_destroy(struct tgt_cmnd *cmnd);
+extern void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd,
+				  void (*done)(struct tgt_cmnd *));
+extern int tgt_cmnd_queue(struct tgt_cmnd *cmnd,
+			  void (*done)(struct tgt_cmnd *));
+extern int tgt_sysfs_init(void);
+extern void tgt_sysfs_exit(void);
+#endif

Copied: trunk/kernel/tgt_device.h (from rev 67, trunk/kernel/stgt_device.h)
===================================================================
--- trunk/kernel/stgt_device.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_device.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,55 @@
+/*
+ * Target Framework Device definitions
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+#ifndef __TGT_DEVICE_H
+#define __TGT_DEVICE_H
+
+#include &lt;linux/device.h&gt;
+#include &lt;linux/list.h&gt;
+
+struct tgt_device;
+struct tgt_cmnd;
+
+struct tgt_device_template {
+	const char *name;
+	struct module *module;
+	unsigned priv_data_size;
+
+	int (* create)(struct tgt_device *);
+	void (* destroy)(struct tgt_device *);
+	int (* queue_cmnd)(struct tgt_device *device, struct tgt_cmnd *cmnd);
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **device_attrs;
+};
+
+struct tgt_device {
+	struct tgt_device_template *dt;
+	void *dt_data;
+
+	struct class_device cdev;
+
+        char *path;
+        uint64_t dev_id;
+        uint32_t blk_shift;
+        uint64_t size;
+
+        struct tgt_target *target;
+        struct list_head dlist;
+};
+
+#define cdev_to_tgt_device(cdev) \
+        container_of(cdev, struct tgt_device, cdev)
+
+extern int tgt_sysfs_register_device(struct tgt_device *device);
+extern void tgt_sysfs_unregister_device(struct tgt_device *device);
+extern int tgt_device_template_register(struct tgt_device_template *dt);
+extern void tgt_device_template_unregister(struct tgt_device_template *dt);
+
+#endif

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_protocol.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,5 +1,5 @@
 /*
- * Target protocol
+ * Target Framework Protocol definitions
  *
  * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
  * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
@@ -9,7 +9,7 @@
 #define __TGT_PROTOCOL_H
 
 struct module;
-struct stgt_cmnd;
+struct tgt_cmnd;
 
 struct tgt_protocol {
 	const char *name;
@@ -22,18 +22,18 @@
 	 * perform command preparation, such as setting the rw field
 	 * and dev_id
 	 */
-	void (* init_cmnd)(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+	void (* init_cmnd)(struct tgt_cmnd *cmnd, uint8_t *proto_data,
 			   uint8_t *id_buff, int buff_size);
 	/*
 	 * setup buffer fields like offset and len
 	 */
-	void (* init_cmnd_buffer)(struct stgt_cmnd *cmd);
+	void (* init_cmnd_buffer)(struct tgt_cmnd *cmd);
 	/*
 	 * process completion of a command
 	 */
-	void (* cmnd_done)(struct stgt_cmnd *cmd, int err);
+	void (* cmnd_done)(struct tgt_cmnd *cmd, int err);
 
-	void (* build_uspace_pdu)(struct stgt_cmnd *cmnd, void *data);
+	void (* build_uspace_pdu)(struct tgt_cmnd *cmnd, void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_scsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -7,9 +7,11 @@
  */
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/module.h&gt;
+#include &lt;linux/mm.h&gt;
 #include &lt;scsi/scsi.h&gt;
-#include &lt;linux/mm.h&gt;
-#include &lt;stgt.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
+
+#include &lt;tgt.h&gt;
 #include &lt;tgt_protocol.h&gt;
 
 struct scsi_tgt_cmnd {
@@ -41,7 +43,7 @@
 	return lun;
 }
 
-static void scsi_tgt_init_cmnd_buffer(struct stgt_cmnd *cmnd)
+static void scsi_tgt_init_cmnd_buffer(struct tgt_cmnd *cmnd)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd-&gt;tgt_protocol_private;
 	uint8_t *scb = scsi_tgt_cmnd-&gt;scb;
@@ -81,7 +83,7 @@
 	cmnd-&gt;offset = off;
 }
 
-static void scsi_tgt_init_cmnd(struct stgt_cmnd *cmnd, uint8_t *proto_data,
+static void scsi_tgt_init_cmnd(struct tgt_cmnd *cmnd, uint8_t *proto_data,
 			       uint8_t *id_buff, int buff_size)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd-&gt;tgt_protocol_private;
@@ -110,7 +112,7 @@
 	cmnd-&gt;dev_id = scsi_tgt_translate_lun(id_buff, buff_size);
 }
 
-static int sense_data_build(struct stgt_cmnd *cmnd, uint8_t key,
+static int sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd-&gt;tgt_protocol_private;
@@ -164,7 +166,7 @@
 	return key;
 }
 
-static void scsi_tgt_cmnd_done(struct stgt_cmnd *cmnd, int err)
+static void scsi_tgt_cmnd_done(struct tgt_cmnd *cmnd, int err)
 {
 	if (err &lt; 0) {
 		uint8_t key;
@@ -176,7 +178,7 @@
 		cmnd-&gt;result = SAM_STAT_GOOD;
 }
 
-void scsi_tgt_build_uspace_pdu(struct stgt_cmnd *cmnd, void *data)
+void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
 {
 	struct scsi_tgt_cmnd *scsi_tgt_cmnd = cmnd-&gt;tgt_protocol_private;
 

Copied: trunk/kernel/tgt_sysfs.c (from rev 67, trunk/kernel/stgt_sysfs.c)
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_sysfs.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,238 @@
+/*
+ * Target framework core sysfs files
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+#include &lt;tgt_target.h&gt;
+#include &lt;tgt_device.h&gt;
+
+/*
+ * Target files
+ */
+#define tgt_target_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
+	return snprintf (buf, 20, format_string, target-&gt;field);	\
+}
+
+#define tgt_target_rd_attr(field, format_string)		\
+	tgt_target_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_target_rd_attr(queued_cmnds, &quot;%u\n&quot;);
+
+static struct class_device_attribute *tgt_target_attrs[] = {
+	&amp;class_device_attr_queued_cmnds,
+	NULL
+};
+
+static void tgt_target_class_release(struct class_device *cdev)
+{
+	struct tgt_target *target = cdev_to_tgt_target(cdev);
+	kfree(target-&gt;tt_data);
+	kfree(target);
+}
+
+static struct class tgt_target_class = {
+	.name = &quot;tgt_target&quot;,
+	.release = tgt_target_class_release,
+};
+
+static struct class_device_attribute *class_attr_overridden(
+				struct class_device_attribute **attrs,
+				struct class_device_attribute *attr)
+{
+	int i;
+
+	if (!attrs)
+		return NULL;
+
+	for (i = 0; attrs[i]; i++)
+		if (!strcmp(attrs[i]-&gt;attr.name, attr-&gt;attr.name))
+			return attrs[i];
+	return NULL;
+}
+
+static int class_attr_add(struct class_device *classdev,
+			  struct class_device_attribute *attr)
+{
+	struct class_device_attribute *base_attr;
+
+	/*
+	 * Spare the caller from having to copy things it's not interested in.
+	*/
+	base_attr = class_attr_overridden(tgt_target_attrs, attr);
+	if (base_attr) {
+		/* extend permissions */
+		attr-&gt;attr.mode |= base_attr-&gt;attr.mode;
+
+		/* override null show/store with default */
+		if (!attr-&gt;show)
+			attr-&gt;show = base_attr-&gt;show;
+		if (!attr-&gt;store)
+			attr-&gt;store = base_attr-&gt;store;
+	}
+
+	return class_device_create_file(classdev, attr);
+}
+
+int tgt_sysfs_register_target(struct tgt_target *target)
+{
+	struct class_device *cdev = &amp;target-&gt;cdev;
+	int err, i;
+
+	cdev-&gt;class = &amp;tgt_target_class;
+	snprintf(cdev-&gt;class_id, BUS_ID_SIZE, &quot;target%d&quot;, target-&gt;tid);
+
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	if (target-&gt;tt-&gt;target_attrs) {
+		for (i = 0; target-&gt;tt-&gt;target_attrs[i]; i++) {
+			err = class_attr_add(&amp;target-&gt;cdev,
+					     target-&gt;tt-&gt;target_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; tgt_target_attrs[i]; i++) {
+		if (!class_attr_overridden(target-&gt;tt-&gt;target_attrs,
+					   tgt_target_attrs[i])) {
+			err = class_device_create_file(&amp;target-&gt;cdev,
+						       tgt_target_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_unregister(cdev);
+	return err;
+}
+
+void tgt_sysfs_unregister_target(struct tgt_target *target)
+{
+	class_device_unregister(&amp;target-&gt;cdev);
+}
+
+/*
+ * Device files
+ */
+#define tgt_device_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct tgt_device *device = cdev_to_tgt_device(cdev);		\
+	return sprintf(buf, format_string, device-&gt;field);	\
+}
+
+#define tgt_device_rd_attr(field, format_string)		\
+	tgt_device_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+tgt_device_rd_attr(path, &quot;%s\n&quot;);
+tgt_device_rd_attr(size, &quot;%llu\n&quot;);
+
+static struct class_device_attribute *tgt_device_attrs[] = {
+	&amp;class_device_attr_path,
+	&amp;class_device_attr_size,
+	NULL,
+};
+
+
+static void tgt_device_class_release(struct class_device *cdev)
+{
+	struct tgt_device *device = cdev_to_tgt_device(cdev);
+	struct tgt_target *target = device-&gt;target;
+
+	class_device_put(&amp;target-&gt;cdev);
+	kfree(device-&gt;dt_data);
+	kfree(device-&gt;path);
+	kfree(device);
+}
+
+static struct class tgt_device_class = {
+	.name = &quot;tgt_device&quot;,
+	.release = tgt_device_class_release,
+};
+
+int tgt_sysfs_register_device(struct tgt_device *device)
+{
+	struct tgt_target *target = device-&gt;target;
+	struct class_device *cdev = &amp;device-&gt;cdev;
+	int err, i;
+
+	cdev-&gt;class = &amp;tgt_device_class;
+	snprintf(cdev-&gt;class_id, BUS_ID_SIZE, &quot;device%d:%llu&quot;,
+		 target-&gt;tid, device-&gt;dev_id);
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	/*
+	 * get handle to target so our parent is never released before
+	 * us
+	 */
+	if (!class_device_get(&amp;target-&gt;cdev))
+		return -EINVAL;
+
+	if (device-&gt;dt-&gt;device_attrs) {
+		for (i = 0; device-&gt;dt-&gt;device_attrs[i]; i++) {
+			err = class_attr_add(&amp;device-&gt;cdev,
+					     device-&gt;dt-&gt;device_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; tgt_device_attrs[i]; i++) {
+		if (!class_attr_overridden(device-&gt;dt-&gt;device_attrs,
+					   tgt_device_attrs[i])) {
+			err = class_device_create_file(&amp;device-&gt;cdev,
+						       tgt_device_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_put(&amp;target-&gt;cdev);
+	class_device_unregister(cdev);
+	return err;
+
+}
+
+void tgt_sysfs_unregister_device(struct tgt_device *device)
+{
+	class_device_unregister(&amp;device-&gt;cdev);
+}
+
+int tgt_sysfs_init(void)
+{
+	int err;
+
+	err = class_register(&amp;tgt_target_class);
+	if (err)
+		return err;
+
+	err = class_register(&amp;tgt_device_class);
+	if (err)
+		class_unregister(&amp;tgt_target_class);
+	return err;
+}
+
+void tgt_sysfs_exit(void)
+{
+	class_unregister(&amp;tgt_target_class);
+	class_unregister(&amp;tgt_device_class);
+}

Copied: trunk/kernel/tgt_target.h (from rev 67, trunk/kernel/stgt_target.h)
===================================================================
--- trunk/kernel/stgt_target.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_target.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,69 @@
+/*
+ * Target Framework Target definitions
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+#ifndef __TGT_TARGET_H
+#define __TGT_TARGET_H
+
+#include &lt;linux/device.h&gt;
+#include &lt;linux/list.h&gt;
+
+struct tgt_protocol;
+struct tgt_target;
+
+struct tgt_target_template {
+	const char *name;
+	struct module *module;
+	unsigned priv_data_size;
+
+	int (* target_create) (struct tgt_target *);
+	void (* target_destroy) (struct tgt_target *);
+
+	/*
+	 * name of protocol to use
+	 */
+	const char *protocol;
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **target_attrs;
+};
+
+struct tgt_target {
+	int tid;
+	struct tgt_target_template *tt;
+	void *tt_data;
+	struct tgt_protocol *proto;
+
+	struct class_device cdev;
+
+	int queued_cmnds;
+
+	/* Protects session_list, work_list, device_list */
+	spinlock_t lock;
+
+	struct list_head tlist;
+
+	struct list_head device_list;
+	struct list_head session_list;
+
+	struct work_struct work;
+	struct list_head work_list;
+	struct workqueue_struct *twq;
+};
+
+#define cdev_to_tgt_target(cdev) \
+	container_of(cdev, struct tgt_target, cdev)
+
+extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmnds);
+extern int tgt_target_destroy(struct tgt_target *target);
+extern int tgt_sysfs_register_target(struct tgt_target *target);
+extern void tgt_sysfs_unregister_target(struct tgt_target *target);
+extern int tgt_target_template_register(struct tgt_target_template *tt);
+extern void tgt_target_template_unregister(struct tgt_target_template *tt);
+
+#endif

Copied: trunk/kernel/tgt_vsd.c (from rev 67, trunk/kernel/stgt_vsd.c)
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/kernel/tgt_vsd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,149 @@
+/*
+ * Target virtual device functions
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/blkdev.h&gt;
+#include &lt;linux/namei.h&gt;
+#include &lt;linux/uio.h&gt;
+#include &lt;linux/fs.h&gt;
+#include &lt;linux/writeback.h&gt;
+
+#include &lt;tgt.h&gt;
+#include &lt;tgt_device.h&gt;
+
+struct tgt_vsd_dev {
+	struct file *filp;
+};
+
+static void tgt_vsd_destroy(struct tgt_device *device)
+{
+	struct tgt_vsd_dev *vsddev = device-&gt;dt_data;
+	filp_close(vsddev-&gt;filp, NULL);
+}
+
+static int open_file(struct tgt_vsd_dev *vsddev, const char *path)
+{
+	struct file *filp;
+	mm_segment_t oldfs;
+	int err = 0;
+
+	oldfs = get_fs();
+	set_fs(get_ds());
+	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
+	set_fs(oldfs);
+
+	if (IS_ERR(filp)) {
+		err = PTR_ERR(filp);
+		printk(&quot;Can't open %s %d\n&quot;, path, err);
+	} else
+		vsddev-&gt;filp = filp;
+
+	return err;
+}
+
+static int tgt_vsd_create(struct tgt_device *device)
+{
+	struct tgt_vsd_dev *vsddev = device-&gt;dt_data;
+	struct inode *inode;
+	int err = 0;
+
+	err = open_file(vsddev, device-&gt;path);
+	if (err)
+		return err;
+
+	inode = vsddev-&gt;filp-&gt;f_dentry-&gt;d_inode;
+	if (S_ISREG(inode-&gt;i_mode))
+		;
+	else if (S_ISBLK(inode-&gt;i_mode))
+		inode = inode-&gt;i_bdev-&gt;bd_inode;
+	else {
+		err = -EINVAL;
+		goto out;
+	}
+
+	device-&gt;size = inode-&gt;i_size;
+	printk(&quot;%s %llu\n&quot;, device-&gt;path, inode-&gt;i_size &gt;&gt; 9);
+
+	return 0;
+out:
+	filp_close(vsddev-&gt;filp, NULL);
+	return err;
+}
+
+static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
+{
+	struct iovec* iov;
+	int i;
+
+	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
+	if (!iov)
+		return NULL;
+
+	for (i = 0; i &lt; sg_count; i++) {
+		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
+		iov[i].iov_len = sg[i].length;
+	}
+
+	return iov;
+}
+
+static int tgt_vsd_queue(struct tgt_device *device, struct tgt_cmnd *cmnd)
+{
+	struct tgt_vsd_dev *vsddev = device-&gt;dt_data;
+	ssize_t size;
+	struct iovec *iov;
+	loff_t pos = cmnd-&gt;offset;
+	int err = 0;
+
+	if (cmnd-&gt;bufflen + pos &gt; device-&gt;size)
+		return -EOVERFLOW;
+
+	iov = sg_to_iovec(cmnd-&gt;sg, cmnd-&gt;sg_count);
+	if (!iov)
+		return -ENOMEM;
+
+	if (cmnd-&gt;rw == READ)
+		size = generic_file_readv(vsddev-&gt;filp, iov, cmnd-&gt;sg_count, &amp;pos);
+	else
+		size = generic_file_writev(vsddev-&gt;filp, iov, cmnd-&gt;sg_count, &amp;pos);
+
+	kfree(iov);
+
+/* not yet used
+	if (sync)
+		err = sync_page_range(inode, inode-&gt;i_mapping, pos,
+				      (size_t) cmnd-&gt;bufflen);
+*/
+	if ((size != cmnd-&gt;bufflen) || err)
+		return -EIO;
+	else
+		return 0;
+}
+
+static struct tgt_device_template tgt_vsd = {
+	.name = &quot;tgt_vsd&quot;,
+	.module = THIS_MODULE,
+	.create = tgt_vsd_create,
+	.destroy = tgt_vsd_destroy,
+	.queue_cmnd = tgt_vsd_queue,
+};
+
+static int __init tgt_vsd_init(void)
+{
+	tgt_vsd.priv_data_size = sizeof(struct tgt_vsd_dev);
+	return tgt_device_template_register(&amp;tgt_vsd);
+}
+
+static void __exit tgt_vsd_exit(void)
+{
+	tgt_device_template_unregister(&amp;tgt_vsd);
+}
+
+module_init(tgt_vsd_init);
+module_exit(tgt_vsd_exit);
+MODULE_LICENSE(&quot;GPL&quot;);

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/Makefile	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,9 +1,9 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_STGT=20
-PROGRAMS = stgtd
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_TGT=20
+PROGRAMS = tgtd
 
 all: $(PROGRAMS)
 
-stgtd: stgtd.o scsi.o netlink.o ipc.o log.o
+tgtd: tgtd.o scsi.o netlink.o ipc.o log.o
 	$(CC) $^ -o $@ $(LIBS)
 
 clean:

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/ipc.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -3,7 +3,6 @@
  *
  * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
  * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- *
  * This code is licenced under the GPL.
  */
 
@@ -19,8 +18,8 @@
 #include &lt;sys/socket.h&gt;
 #include &lt;linux/netlink.h&gt;
 
-#include &lt;stgt_if.h&gt;
-#include &quot;stgtd.h&quot;
+#include &lt;tgt_if.h&gt;
+#include &quot;tgtd.h&quot;
 
 void ipc_event_handle(int accept_fd)
 {
@@ -28,7 +27,7 @@
 	struct ucred cred;
 	int fd, err, res;
 	socklen_t len;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	char nlm_ev[8192], *data;
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 	struct iovec iov;
@@ -87,7 +86,7 @@
 
 send:
 	nlh-&gt;nlmsg_len = NLMSG_SPACE(sizeof(*ev));
-	nlh-&gt;nlmsg_type = STGT_KEVENT_RESPONSE;
+	nlh-&gt;nlmsg_type = TGT_KEVENT_RESPONSE;
 	nlh-&gt;nlmsg_flags = 0;
 	nlh-&gt;nlmsg_pid = 0;
 	ev = NLMSG_DATA(nlh);
@@ -111,8 +110,8 @@
 
 	memset(&amp;addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &amp;addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
+	memcpy((char *) &amp;addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
 
 	if ((err = bind(fd, (struct sockaddr *) &amp;addr, sizeof(addr))) &lt; 0)
 		return err;

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/netlink.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -22,8 +22,8 @@
 #include &lt;asm/types.h&gt;
 #include &lt;linux/netlink.h&gt;
 
-#include &lt;stgt_if.h&gt;
-#include &quot;stgtd.h&quot;
+#include &lt;tgt_if.h&gt;
+#include &quot;tgtd.h&quot;
 
 #define	NL_BUFSIZE	8192
 
@@ -88,7 +88,7 @@
 {
 	int err;
 	struct iovec iov;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
 
 	iov.iov_base = data;
@@ -100,7 +100,7 @@
 
 	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
 
-	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
+	ev = (struct tgt_event *) NLMSG_DATA(nlm_ev);
 	*res = ev-&gt;k.event_res.err;
 
 	return err;
@@ -110,7 +110,7 @@
 {
 	int result, len;
 	struct iovec iov[2];
-	struct stgt_event *ev = (struct stgt_event *) reqbuf;
+	struct tgt_event *ev = (struct tgt_event *) reqbuf;
 	uint64_t cid = ev-&gt;k.cmnd_req.cid;
 	uint8_t *scb;
 
@@ -135,13 +135,13 @@
 	iov[1].iov_base = resbuf;
 	iov[1].iov_len = len;
 
-	return nl_write(fd, STGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
+	return nl_write(fd, TGT_UEVENT_CMND_RES, iov, len ? 2 : 1);
 }
 
 void nl_event_handle(int fd)
 {
 	struct nlmsghdr *nlh;
-	struct stgt_event *ev;
+	struct tgt_event *ev;
 	int err;
 
 peek_again:
@@ -156,7 +156,7 @@
 	}
 
 	nlh = (struct nlmsghdr *) recvbuf;
-	ev = (struct stgt_event *) NLMSG_DATA(nlh);
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
 	dprintf(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, nlh-&gt;nlmsg_len);
 
@@ -172,7 +172,7 @@
 	}
 
 	switch (nlh-&gt;nlmsg_type) {
-	case STGT_KEVENT_CMND_REQ:
+	case TGT_KEVENT_CMND_REQ:
 		cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	default:
@@ -186,9 +186,9 @@
 static void nl_start(int fd)
 {
 	int err, res;
-	struct stgt_event ev;
+	struct tgt_event ev;
 
-	err = nl_cmnd_call(fd, STGT_UEVENT_START, (char *) &amp;ev, sizeof(ev), &amp;res);
+	err = nl_cmnd_call(fd, TGT_UEVENT_START, (char *) &amp;ev, sizeof(ev), &amp;res);
 	if (err &lt; 0 || res &lt; 0) {
 		eprintf(&quot;%d %d\n&quot;, err, res);
 		exit(-1);
@@ -204,7 +204,7 @@
 		return -ENOMEM;
 	recvbuf = sendbuf + NL_BUFSIZE;
 
-	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_STGT);
+	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
 	if (fd &lt; 0) {
 		eprintf(&quot;%d\n&quot;, fd);
 		return fd;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/scsi.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -24,7 +24,7 @@
 #include &lt;sys/stat.h&gt;
 #include &lt;fcntl.h&gt;
 
-#include &quot;stgtd.h&quot;
+#include &quot;tgtd.h&quot;
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -65,7 +65,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[128];
 
-	sprintf(path, &quot;/sys/class/stgt_device/device%d:%&quot; PRIu64 &quot;/size&quot;,
+	sprintf(path, &quot;/sys/class/tgt_device/device%d:%&quot; PRIu64 &quot;/size&quot;,
 		tid, lun);
 
 	fd = open(path, O_RDONLY);
@@ -319,9 +319,9 @@
 	char buf[128];
 	int result = SAM_STAT_GOOD;
 
-	dir = opendir(&quot;/sys/class/stgt_device&quot;);
+	dir = opendir(&quot;/sys/class/tgt_device&quot;);
 	if (!dir) {
-		perror(&quot;can't open /sys/class/stgt_device\n&quot;);
+		perror(&quot;can't open /sys/class/tgt_device\n&quot;);
 		exit(0);
 	}
 
@@ -401,7 +401,7 @@
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	sprintf(path, &quot;/sys/class/stgt_device/device%d:%&quot; PRIu64 &quot;/path&quot;, tid, lun);
+	sprintf(path, &quot;/sys/class/tgt_device/device%d:%&quot; PRIu64 &quot;/path&quot;, tid, lun);
 
 	fd = open(path, O_RDONLY);
 	if (fd &lt; 0) {

Deleted: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/stgtd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,184 +0,0 @@
-/*
- * Core target framework user-space daemon
- *
- * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;getopt.h&gt;
-#include &lt;inttypes.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdint.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;asm/types.h&gt;
-#include &lt;sys/poll.h&gt;
-#include &lt;sys/signal.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;stgt_if.h&gt;
-#include &quot;stgtd.h&quot;
-
-int nl_fd, ipc_fd;
-
-enum {
-	POLL_NL,
-	POLL_IPC,
-	POLL_MAX,
-};
-
-static struct option const long_options[] =
-{
-	{&quot;foreground&quot;, no_argument, 0, 'f'},
-	{&quot;debug&quot;, required_argument, 0, 'd'},
-	{&quot;version&quot;, no_argument, 0, 'v'},
-	{&quot;help&quot;, no_argument, 0, 'h'},
-	{0, 0, 0, 0},
-};
-
-static char program_name[] = &quot;stgtd&quot;;
-
-static void usage(int status)
-{
-	if (status != 0)
-		fprintf(stderr, &quot;Try `%s --help' for more information.\n&quot;, program_name);
-	else {
-		printf(&quot;Usage: %s [OPTION]\n&quot;, program_name);
-		printf(&quot;\
-SCSI target daemon.\n\
-  -f, --foreground        make the program run in the foreground\n\
-  -d, --debug debuglevel  print debugging information\n\
-  -h, --help              display this help and exit\n\
-&quot;);
-	}
-	exit(1);
-}
-
-static void signal_catch(int signo) {
-}
-
-static void init(int daemon, int debug)
-{
-	int fd;
-	char path[64];
-	struct sigaction sa_old;
-	struct sigaction sa_new;
-
-	/* do not allow ctrl-c for now... */
-	sa_new.sa_handler = signal_catch;
-	sigemptyset(&amp;sa_new.sa_mask);
-	sa_new.sa_flags = 0;
-	sigaction(SIGINT, &amp;sa_new, &amp;sa_old );
-	sigaction(SIGPIPE, &amp;sa_new, &amp;sa_old );
-	sigaction(SIGTERM, &amp;sa_new, &amp;sa_old );
-
-	/* Should we use RT stuff? */
-	nice(-20);
-
-	/* Avoid oom-killer */
-	sprintf(path, &quot;/proc/%d/oom_adj&quot;, getpid());
-	fd = open(path, O_WRONLY);
-	if (fd &lt; 0) {
-		fprintf(stderr, &quot;can not adjust oom-killer's pardon %s\n&quot;, path);
-		return;
-	}
-	write(fd, &quot;-17\n&quot;, 4);
-	close(fd);
-
-	if (log_init(&quot;tgtd&quot;, DEFAULT_AREA_SIZE, daemon, debug) &lt; 0) {
-		fprintf(stderr, &quot;can not start the logger daemon\n&quot;);
-		exit(-1);
-	}
-}
-
-static void event_loop(struct pollfd *poll_array)
-{
-	int err;
-
-	while (1) {
-		if ((err = poll(poll_array, POLL_MAX, -1)) &lt; 0) {
-			if (errno != EINTR) {
-				eprintf(&quot;%d %d\n&quot;, err, errno);
-				exit(1);
-			}
-			continue;
-		}
-
-		if (poll_array[POLL_NL].revents)
-			nl_event_handle(nl_fd);
-
-		if (poll_array[POLL_IPC].revents)
-			ipc_event_handle(ipc_fd);
-
-	}
-}
-
-int main(int argc, char **argv)
-{
-	int ch, longindex;
-	int is_daemon = 1, is_debug = 1;
-	pid_t pid;
-	struct pollfd poll_array[POLL_MAX + 1];
-
-	while ((ch = getopt_long(argc, argv, &quot;fd:vh&quot;, long_options, &amp;longindex)) &gt;= 0) {
-		switch (ch) {
-		case 'f':
-			is_daemon = 0;
-			break;
-		case 'd':
-			is_debug = atoi(optarg);
-			break;
-		case 'v':
-			exit(0);
-			break;
-		case 'h':
-			usage(0);
-			break;
-		default:
-			usage(1);
-			break;
-		}
-	}
-
-	init(is_daemon, is_debug);
-
-	if (is_daemon) {
-		pid = fork();
-		if (pid &lt; 0)
-			exit(-1);
-		else if (pid)
-			exit(0);
-
-		chdir(&quot;/&quot;);
-
-		close(0);
-		open(&quot;/dev/null&quot;, O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
-
-	memset(poll_array, 0, sizeof(poll_array));
-
-	nl_fd = nl_open();
-	if (nl_fd &lt; 0)
-		exit(nl_fd);
-
-	ipc_fd = ipc_open();
-	if (ipc_fd &lt; 0)
-		exit(ipc_fd);
-
-	poll_array[POLL_NL].fd = nl_fd;
-	poll_array[POLL_NL].events = POLLIN;
-	poll_array[POLL_IPC].fd = ipc_fd;
-	poll_array[POLL_IPC].events = POLLIN;
-
-	event_loop(poll_array);
-
-	return 0;
-}

Deleted: trunk/usr/stgtd.h
===================================================================
--- trunk/usr/stgtd.h	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/stgtd.h	2005-09-12 00:20:00 UTC (rev 68)
@@ -1,28 +0,0 @@
-#ifndef __SCSI_TARGET_DAEMON_H
-#define __SCSI_TARGET_DAEMON_H
-
-#include &quot;log.h&quot;
-
-#define eprintf(fmt, args...)						\
-do {									\
-	log_error(&quot;%s/%d &quot; fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#define dprintf(fmt, args...)						\
-do {									\
-	log_debug(&quot;%s/%d &quot; fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-extern int nl_fd;
-
-extern int nl_open(void);
-extern void nl_event_handle(int fd);
-extern int nl_cmnd_call(int fd, int type, char *data, int size, int *res);
-
-extern int ipc_open(void);
-extern void ipc_event_handle(int fd);
-
-extern int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb,
-			     uint8_t *data, int *len);
-
-#endif

Copied: trunk/usr/tgtd.c (from rev 67, trunk/usr/stgtd.c)
===================================================================
--- trunk/usr/stgtd.c	2005-09-10 18:17:59 UTC (rev 67)
+++ trunk/usr/tgtd.c	2005-09-12 00:20:00 UTC (rev 68)
@@ -0,0 +1,184 @@
+/*
+ * Core target framework user-space daemon
+ *
+ * (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
+ * (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+ * This code is licenced under the GPL.
+ */
+
+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;getopt.h&gt;
+#include &lt;inttypes.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdint.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;asm/types.h&gt;
+#include &lt;sys/poll.h&gt;
+#include &lt;sys/signal.h&gt;
+#include &lt;sys/stat.h&gt;
+
+#include &lt;tgt_if.h&gt;
+#include &quot;tgtd.h&quot;
+
+int nl_fd, ipc_fd;
+
+enum {
+	POLL_NL,
+	POLL_IPC,
+	POLL_MAX,
+};
+
+static struct option const long_options[] =
+{
+	{&quot;foreground&quot;, no_argument, 0, 'f'},
+	{&quot;debug&quot;, required_argument, 0, 'd'},
+	{&quot;version&quot;, no_argument, 0, 'v'},
+	{&quot;help&quot;, no_argument, 0, 'h'},
+	{0, 0, 0, 0},
+};
+
+static char program_name[] = &quot;tgtd&quot;;
+
+static void usage(int status)
+{
+	if (status != 0)
+		fprintf(stderr, &quot;Try `%s --help' for more information.\n&quot;, program_name);
+	else {
+		printf(&quot;Usage: %s [OPTION]\n&quot;, program_name);
+		printf(&quot;\
+Target framework daemon.\n\
+  -f, --foreground        make the program run in the foreground\n\
+  -d, --debug debuglevel  print debugging information\n\
+  -h, --help              display this help and exit\n\
+&quot;);
+	}
+	exit(1);
+}
+
+static void signal_catch(int signo) {
+}
+
+static void init(int daemon, int debug)
+{
+	int fd;
+	char path[64];
+	struct sigaction sa_old;
+	struct sigaction sa_new;
+
+	/* do not allow ctrl-c for now... */
+	sa_new.sa_handler = signal_catch;
+	sigemptyset(&amp;sa_new.sa_mask);
+	sa_new.sa_flags = 0;
+	sigaction(SIGINT, &amp;sa_new, &amp;sa_old );
+	sigaction(SIGPIPE, &amp;sa_new, &amp;sa_old );
+	sigaction(SIGTERM, &amp;sa_new, &amp;sa_old );
+
+	/* Should we use RT stuff? */
+	nice(-20);
+
+	/* Avoid oom-killer */
+	sprintf(path, &quot;/proc/%d/oom_adj&quot;, getpid());
+	fd = open(path, O_WRONLY);
+	if (fd &lt; 0) {
+		fprintf(stderr, &quot;can not adjust oom-killer's pardon %s\n&quot;, path);
+		return;
+	}
+	write(fd, &quot;-17\n&quot;, 4);
+	close(fd);
+
+	if (log_init(program_name, DEFAULT_AREA_SIZE, daemon, debug) &lt; 0) {
+		fprintf(stderr, &quot;can not start the logger daemon\n&quot;);
+		exit(-1);
+	}
+}
+
+static void event_loop(struct pollfd *poll_array)
+{
+	int err;
+
+	while (1) {
+		if ((err = poll(poll_array, POLL_MAX, -1)) &lt; 0) {
+			if (errno != EINTR) {
+				eprintf(&quot;%d %d\n&quot;, err, errno);
+				exit(1);
+			}
+			continue;
+		}
+
+		if (poll_array[POLL_NL].revents)
+			nl_event_handle(nl_fd);
+
+		if (poll_array[POLL_IPC].revents)
+			ipc_event_handle(ipc_fd);
+
+	}
+}
+
+int main(int argc, char **argv)
+{
+	int ch, longindex;
+	int is_daemon = 1, is_debug = 1;
+	pid_t pid;
+	struct pollfd poll_array[POLL_MAX + 1];
+
+	while ((ch = getopt_long(argc, argv, &quot;fd:vh&quot;, long_options, &amp;longindex)) &gt;= 0) {
+		switch (ch) {
+		case 'f':
+			is_daemon = 0;
+			break;
+		case 'd':
+			is_debug = atoi(optarg);
+			break;
+		case 'v':
+			exit(0);
+			break;
+		case 'h':
+			usage(0);
+			break;
+		default:
+			usage(1);
+			break;
+		}
+	}
+
+	init(is_daemon, is_debug);
+
+	if (is_daemon) {
+		pid = fork();
+		if (pid &lt; 0)
+			exit(-1);
+		else if (pid)
+			exit(0);
+
+		chdir(&quot;/&quot;);
+
+		close(0);
+		open(&quot;/dev/null&quot;, O_RDWR);
+		dup2(0, 1);
+		dup2(0, 2);
+		setsid();
+	}
+
+	memset(poll_array, 0, sizeof(poll_array));
+
+	nl_fd = nl_open();
+	if (nl_fd &lt; 0)
+		exit(nl_fd);
+
+	ipc_fd = ipc_open();
+	if (ipc_fd &lt; 0)
+		exit(ipc_fd);
+
+	poll_array[POLL_NL].fd = nl_fd;
+	poll_array[POLL_NL].events = POLLIN;
+	poll_array[POLL_IPC].fd = ipc_fd;
+	poll_array[POLL_IPC].events = POLLIN;
+
+	event_loop(poll_array);
+
+	return 0;
+}

Copied: trunk/usr/tgtd.h (from rev 67, trunk/usr/stgtd.h)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000057.html">[Stgt-svn] r64 - trunk/iscsi/include
</A></li>
	<LI>Next message: <A HREF="000059.html">[Stgt-svn] r69 - trunk/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58">[ date ]</a>
              <a href="thread.html#58">[ thread ]</a>
              <a href="subject.html#58">[ subject ]</a>
              <a href="author.html#58">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
