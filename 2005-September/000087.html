<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r94 - in trunk: include iscsi/kernel iscsi/usr kernel usr
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r94%20-%20in%20trunk%3A%20include%20iscsi/kernel%20iscsi/usr%20kernel%20usr&In-Reply-To=%3C200509240030.j8O0UMSE017677%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000086.html">
   <LINK REL="Next"  HREF="000088.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r94 - in trunk: include iscsi/kernel iscsi/usr kernel usr</H1>
    <B>Mike Christie at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r94%20-%20in%20trunk%3A%20include%20iscsi/kernel%20iscsi/usr%20kernel%20usr&In-Reply-To=%3C200509240030.j8O0UMSE017677%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r94 - in trunk: include iscsi/kernel iscsi/usr kernel usr">mnc at berlios.de
       </A><BR>
    <I>Sat Sep 24 02:30:22 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000086.html">[Stgt-svn] r93 - trunk/kernel
</A></li>
        <LI>Next message: <A HREF="000088.html">[Stgt-svn] r95 - in trunk: iscsi/kernel kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87">[ date ]</a>
              <a href="thread.html#87">[ thread ]</a>
              <a href="subject.html#87">[ subject ]</a>
              <a href="author.html#87">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mnc
Date: 2005-09-24 02:30:13 +0200 (Sat, 24 Sep 2005)
New Revision: 94

Modified:
   trunk/include/tgt_if.h
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/usr/ctldev.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/kernel/tgt_vsd.c
   trunk/usr/ipc.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
rename cmnd to cmd to better match the block layer and scsi

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/include/tgt_if.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,11 +17,11 @@
 	TGT_UEVENT_TARGET_PASSTHRU,
 	TGT_UEVENT_DEVICE_CREATE,
 	TGT_UEVENT_DEVICE_DESTROY,
-	TGT_UEVENT_CMND_RES,
+	TGT_UEVENT_CMD_RES,
 
 	/* kernel -&gt; user */
 	TGT_KEVENT_RESPONSE,
-	TGT_KEVENT_CMND_REQ,
+	TGT_KEVENT_CMD_REQ,
 	TGT_KEVENT_TARGET_PASSTHRU,
 };
 
@@ -30,7 +30,7 @@
 	union {
 		struct {
 			char type[32];
-			int nr_cmnds;
+			int nr_cmds;
 		} c_target;
 		struct {
 			int tid;
@@ -54,7 +54,7 @@
 			uint64_t cid;
 			uint32_t len;
 			int result;
-		} cmnd_res;
+		} cmd_res;
 	} u;
 
 	/* kernel -&gt; user */
@@ -66,7 +66,7 @@
 			uint64_t cid;
 			int tid;
 			uint64_t dev_id;
-		} cmnd_req;
+		} cmd_req;
 		struct {
 			int tid;
 			uint32_t len;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/kernel/iscsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -263,7 +263,7 @@
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
-	struct scsi_tgt_cmnd *stc;
+	struct scsi_tgt_cmd *stc;
 	struct scatterlist *sg = &amp;req-&gt;sense_sg;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
@@ -275,7 +275,7 @@
 	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr-&gt;itt = cmnd_hdr(req)-&gt;itt;
 
-	stc = tgt_cmnd_to_scsi(req-&gt;tc);
+	stc = tgt_cmd_to_scsi(req-&gt;tc);
 	sense = (struct iscsi_sense_data *) stc-&gt;sense_buff;
 	memmove(sense-&gt;data, sense, stc-&gt;sense_len);
 	/*
@@ -295,7 +295,7 @@
 static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
 					   u8 sense_key, u8 asc, u8 ascq)
 {
-	struct scsi_tgt_cmnd *stc;
+	struct scsi_tgt_cmd *stc;
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
 	struct iscsi_sense_data *sense;
@@ -310,7 +310,7 @@
 	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr-&gt;itt = cmnd_hdr(req)-&gt;itt;
 
-	stc = tgt_cmnd_to_scsi(req-&gt;tc);
+	stc = tgt_cmd_to_scsi(req-&gt;tc);
 	sg-&gt;page = virt_to_page(stc-&gt;sense_buff);
 	sg-&gt;offset = offset_in_page(stc-&gt;sense_buff);
 	sg-&gt;length = stc-&gt;sense_len;
@@ -368,9 +368,10 @@
 	list_del(&amp;cmnd-&gt;conn_list);
 	spin_unlock(&amp;conn-&gt;list_lock);
 
-	if (cmnd-&gt;tc)
-		tgt_cmnd_destroy(cmnd-&gt;tc);
-
+	if (cmnd-&gt;tc) {
+		struct tgt_protocol *proto = cmnd-&gt;tc-&gt;session-&gt;target-&gt;proto;
+		proto-&gt;destroy_cmd(cmnd-&gt;tc);
+	}
 	kmem_cache_free(iscsi_cmnd_cache, cmnd);
 }
 
@@ -598,7 +599,7 @@
 	cmnd_skip_pdu(req);
 }
 
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmnd *tc,
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmd *tc,
 			 u32 offset, u32 size)
 {
 	int idx, i;
@@ -703,7 +704,7 @@
 	iscsi_cmnds_init_write(&amp;send);
 }
 
-static void scsi_cmnd_done(struct tgt_cmnd *tc)
+static void scsi_cmnd_done(struct tgt_cmd *tc)
 {
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc-&gt;private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
@@ -760,7 +761,7 @@
 		set_cmnd_waitio(cmnd);
 		cmnd-&gt;tc-&gt;private = cmnd;
 
-		proto-&gt;queue_cmnd(cmnd-&gt;tc, scsi_cmnd_done);
+		proto-&gt;queue_cmd(cmnd-&gt;tc, scsi_cmnd_done);
 	}
 }
 
@@ -859,10 +860,10 @@
 	else
 		data_dir = DMA_NONE;
 
-	req-&gt;tc = proto-&gt;create_cmnd(conn-&gt;session-&gt;ts, req_hdr-&gt;cdb,
-				     be32_to_cpu(req_hdr-&gt;data_length),
-				     data_dir, req_hdr-&gt;lun,
-				     sizeof(req_hdr-&gt;lun), NULL);
+	req-&gt;tc = proto-&gt;create_cmd(conn-&gt;session-&gt;ts, req_hdr-&gt;cdb,
+				    be32_to_cpu(req_hdr-&gt;data_length),
+				    data_dir, req_hdr-&gt;lun,
+				    sizeof(req_hdr-&gt;lun), NULL);
 	assert(req-&gt;tc);
 
 	switch (req_hdr-&gt;cdb[0]) {

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/kernel/iscsi.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -192,7 +192,7 @@
 	u32 ddigest;
 
 	struct iscsi_cmnd *req;
-	struct tgt_cmnd *tc;
+	struct tgt_cmd *tc;
 };
 
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/iscsi/usr/ctldev.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -441,7 +441,7 @@
 
 	ev = NLMSG_DATA(nlh);
 	sprintf(ev-&gt;u.c_target.type, &quot;%s&quot;, &quot;iet&quot;);
-	ev-&gt;u.c_target.nr_cmnds = DEFAULT_NR_QUEUED_CMNDS;
+	ev-&gt;u.c_target.nr_cmds = DEFAULT_NR_QUEUED_CMNDS;
 
 	err = ipc_cmnd_execute(nlh, nlh-&gt;nlmsg_len);
 	if (err &gt; 0) {

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -56,10 +56,10 @@
 static struct sock *nls;
 
 /* TODO: lock per session */
-static spinlock_t cmnd_hash_lock;
+static spinlock_t cmd_hash_lock;
 #define TGT_HASH_ORDER		8
-#define	cmnd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
-static struct list_head cmnd_hash[1 &lt;&lt; TGT_HASH_ORDER];
+#define	cmd_hashfn(key)	hash_long((key), TGT_HASH_ORDER)
+static struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
 
 struct target_type_internal {
 	struct list_head list;
@@ -154,7 +154,7 @@
 	return target;
 }
 
-struct tgt_target *tgt_target_create(char *target_type, int queued_cmnds)
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmds)
 {
 	char name[16];
 	static int target_id;
@@ -184,7 +184,7 @@
 	INIT_LIST_HEAD(&amp;target-&gt;device_list);
 	INIT_LIST_HEAD(&amp;target-&gt;work_list);
 
-	target-&gt;queued_cmnds = queued_cmnds;
+	target-&gt;queued_cmds = queued_cmds;
 
 	snprintf(name, sizeof(name), &quot;tgtd%d&quot;, target-&gt;tid);
 	target-&gt;twq = create_workqueue(name);
@@ -241,15 +241,15 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_destroy);
 
-static int session_init(struct tgt_session *session, int max_cmnds)
+static int session_init(struct tgt_session *session, int max_cmds)
 {
 	struct tgt_target *target = session-&gt;target;
 	struct tgt_protocol *proto = session-&gt;target-&gt;proto;
 	unsigned long flags;
 
-	session-&gt;cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
-					mempool_free_slab, proto-&gt;cmnd_cache);
-	if (!session-&gt;cmnd_pool)
+	session-&gt;cmd_pool = mempool_create(max_cmds, mempool_alloc_slab,
+					mempool_free_slab, proto-&gt;cmd_cache);
+	if (!session-&gt;cmd_pool)
 		goto out;
 
 	spin_lock_irqsave(&amp;target-&gt;lock, flags);
@@ -258,8 +258,8 @@
 
 	return 0;
 out:
-	if (session-&gt;cmnd_pool)
-		mempool_destroy(session-&gt;cmnd_pool);
+	if (session-&gt;cmd_pool)
+		mempool_destroy(session-&gt;cmd_pool);
 
 	return -ENOMEM;
 }
@@ -287,7 +287,7 @@
 
 struct tgt_session *
 tgt_session_create(struct tgt_target *target,
-		   int max_cmnds,
+		   int max_cmds,
 		   void (*done)(void *, struct tgt_session *),
 		   void *arg)
 {
@@ -301,7 +301,7 @@
 		return NULL;
 	}
 
-	dprintk(&quot;%p %d\n&quot;, target, max_cmnds);
+	dprintk(&quot;%p %d\n&quot;, target, max_cmds);
 
 	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
 	if (!session)
@@ -316,7 +316,7 @@
 			goto out;
 
 		async-&gt;session = session;
-		async-&gt;cmds = max_cmnds;
+		async-&gt;cmds = max_cmds;
 		async-&gt;done = done;
 		async-&gt;arg = arg;
 
@@ -325,7 +325,7 @@
 		return session;
 	}
 
-	if (session_init(session, max_cmnds) &lt; 0)
+	if (session_init(session, max_cmds) &lt; 0)
 		goto out;
 
 	return session;
@@ -338,7 +338,7 @@
 
 int tgt_session_destroy(struct tgt_session *session)
 {
-	mempool_destroy(session-&gt;cmnd_pool);
+	mempool_destroy(session-&gt;cmd_pool);
 	kfree(session);
 
 	return 0;
@@ -534,57 +534,57 @@
 	return 0;
 }
 
-struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session)
+struct tgt_cmd *tgt_cmd_create(struct tgt_session *session)
 {
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	unsigned long flags;
 
-	cmnd = mempool_alloc(session-&gt;cmnd_pool, GFP_ATOMIC);
-	if (!cmnd) {
-		eprintk(&quot;Could not allocate tgt_cmnd for %p\n&quot;, session);
+	cmd = mempool_alloc(session-&gt;cmd_pool, GFP_ATOMIC);
+	if (!cmd) {
+		eprintk(&quot;Could not allocate tgt_cmd for %p\n&quot;, session);
 		return NULL;
 	}
 
-	memset(cmnd, 0, sizeof(*cmnd));
-	cmnd-&gt;session = session;
-	cmnd-&gt;cid = (uint64_t) (unsigned long) cmnd;
-	INIT_LIST_HEAD(&amp;cmnd-&gt;clist);
-	INIT_LIST_HEAD(&amp;cmnd-&gt;hash_list);
+	memset(cmd, 0, sizeof(*cmd));
+	cmd-&gt;session = session;
+	cmd-&gt;cid = (uint64_t) (unsigned long) cmd;
+	INIT_LIST_HEAD(&amp;cmd-&gt;clist);
+	INIT_LIST_HEAD(&amp;cmd-&gt;hash_list);
 
-	dprintk(&quot;%p %llu\n&quot;, session, cmnd-&gt;cid);
+	dprintk(&quot;%p %llu\n&quot;, session, cmd-&gt;cid);
 
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
-	list_add_tail(&amp;cmnd-&gt;hash_list, &amp;cmnd_hash[cmnd_hashfn(cmnd-&gt;cid)]);
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+	spin_lock_irqsave(&amp;cmd_hash_lock, flags);
+	list_add_tail(&amp;cmd-&gt;hash_list, &amp;cmd_hash[cmd_hashfn(cmd-&gt;cid)]);
+	spin_unlock_irqrestore(&amp;cmd_hash_lock, flags);
 
-	return cmnd;
+	return cmd;
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_create);
+EXPORT_SYMBOL_GPL(tgt_cmd_create);
 
-static void tgt_free_buffer(struct tgt_cmnd *cmnd)
+static void tgt_free_buffer(struct tgt_cmd *cmd)
 {
 	int i;
 	
-	for (i = 0; i &lt; cmnd-&gt;sg_count; i++)
-		__free_page(cmnd-&gt;sg[i].page);
-	kfree(cmnd-&gt;sg);
+	for (i = 0; i &lt; cmd-&gt;sg_count; i++)
+		__free_page(cmd-&gt;sg[i].page);
+	kfree(cmd-&gt;sg);
 }
 
-void tgt_cmnd_destroy(struct tgt_cmnd *cmnd)
+void tgt_cmd_destroy(struct tgt_cmd *cmd)
 {
 	unsigned long flags;
 
-	dprintk(&quot;cid %llu\n&quot;, cmnd-&gt;cid);
+	dprintk(&quot;cid %llu\n&quot;, cmd-&gt;cid);
 
-	kfree(cmnd-&gt;sg);
+	kfree(cmd-&gt;sg);
 
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
-	list_del(&amp;cmnd-&gt;hash_list);
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+	spin_lock_irqsave(&amp;cmd_hash_lock, flags);
+	list_del(&amp;cmd-&gt;hash_list);
+	spin_unlock_irqrestore(&amp;cmd_hash_lock, flags);
 
-	mempool_free(cmnd, cmnd-&gt;session-&gt;cmnd_pool);
+	mempool_free(cmd, cmd-&gt;session-&gt;cmd_pool);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_destroy);
+EXPORT_SYMBOL_GPL(tgt_cmd_destroy);
 
 #define pgcnt(size, offset)	((((size) + ((offset) &amp; ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) &gt;&gt; PAGE_CACHE_SHIFT)
 
@@ -593,23 +593,23 @@
  * but to support passthrough commands we will need to obey the
  * something like's tgt_sd devices's queue's limits.
  */
-void __tgt_alloc_buffer(struct tgt_cmnd *cmnd)
+void __tgt_alloc_buffer(struct tgt_cmd *cmd)
 {
-	uint64_t offset = cmnd-&gt;offset;
-	uint32_t len = cmnd-&gt;bufflen;
+	uint64_t offset = cmd-&gt;offset;
+	uint32_t len = cmd-&gt;bufflen;
 	int i;
 
-	cmnd-&gt;sg_count = pgcnt(len, offset);
+	cmd-&gt;sg_count = pgcnt(len, offset);
 	offset &amp;= ~PAGE_CACHE_MASK;
 
-	dprintk(&quot;cid %llu pg_count %d offset %llu len %d\n&quot;, cmnd-&gt;cid,
-		cmnd-&gt;sg_count, cmnd-&gt;offset, cmnd-&gt;bufflen);
+	dprintk(&quot;cid %llu pg_count %d offset %llu len %d\n&quot;, cmd-&gt;cid,
+		cmd-&gt;sg_count, cmd-&gt;offset, cmd-&gt;bufflen);
 
-	cmnd-&gt;sg = kmalloc(cmnd-&gt;sg_count * sizeof(struct scatterlist),
+	cmd-&gt;sg = kmalloc(cmd-&gt;sg_count * sizeof(struct scatterlist),
 			   GFP_KERNEL | __GFP_NOFAIL);
 
-	for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
-		struct scatterlist *sg = &amp;cmnd-&gt;sg[i];
+	for (i = 0; i &lt; cmd-&gt;sg_count; i++) {
+		struct scatterlist *sg = &amp;cmd-&gt;sg[i];
 
 		sg-&gt;page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
 		sg-&gt;offset = offset;
@@ -622,37 +622,37 @@
 
 static void tgt_alloc_buffer(void *data)
 {
-	struct tgt_cmnd *cmnd = data;
+	struct tgt_cmd *cmd = data;
 
-	__tgt_alloc_buffer(cmnd);
+	__tgt_alloc_buffer(cmd);
 
-	if (cmnd-&gt;done) {
-		void (*done)(struct tgt_cmnd *) = cmnd-&gt;done;
-		cmnd-&gt;done = NULL;
-		done(cmnd);
+	if (cmd-&gt;done) {
+		void (*done)(struct tgt_cmd *) = cmd-&gt;done;
+		cmd-&gt;done = NULL;
+		done(cmd);
 	}
 }
 
-void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
 {
-	BUG_ON(!list_empty(&amp;cmnd-&gt;clist));
+	BUG_ON(!list_empty(&amp;cmd-&gt;clist));
 
 	if (done) {
-		struct tgt_session *session = cmnd-&gt;session;
+		struct tgt_session *session = cmd-&gt;session;
 
-		INIT_WORK(&amp;cmnd-&gt;work, tgt_alloc_buffer, cmnd);
-		cmnd-&gt;done = done;
-		queue_work(session-&gt;target-&gt;twq, &amp;cmnd-&gt;work);
+		INIT_WORK(&amp;cmd-&gt;work, tgt_alloc_buffer, cmd);
+		cmd-&gt;done = done;
+		queue_work(session-&gt;target-&gt;twq, &amp;cmd-&gt;work);
 		return;
 	}
 
-	tgt_alloc_buffer(cmnd);
+	tgt_alloc_buffer(cmd);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_alloc_buffer);
+EXPORT_SYMBOL_GPL(tgt_cmd_alloc_buffer);
 
-int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd)
+int tgt_uspace_cmd_send(struct tgt_cmd *cmd)
 {
-	struct tgt_protocol *proto = cmnd-&gt;session-&gt;target-&gt;proto;
+	struct tgt_protocol *proto = cmd-&gt;session-&gt;target-&gt;proto;
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
@@ -665,24 +665,24 @@
 		return -ENOMEM;
 
 	dprintk(&quot;%d %Zd %d\n&quot;, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMND_REQ,
+	nlh = __nlmsg_put(skb, tgt_pid, 0, TGT_KEVENT_CMD_REQ,
 			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 
 	pdu = (char *) ev-&gt;data;
-	ev-&gt;k.cmnd_req.tid = cmnd-&gt;session-&gt;target-&gt;tid;
-	ev-&gt;k.cmnd_req.dev_id = cmnd-&gt;dev_id;
-	ev-&gt;k.cmnd_req.cid = cmnd-&gt;cid;
+	ev-&gt;k.cmd_req.tid = cmd-&gt;session-&gt;target-&gt;tid;
+	ev-&gt;k.cmd_req.dev_id = cmd-&gt;dev_id;
+	ev-&gt;k.cmd_req.cid = cmd-&gt;cid;
 
-	proto-&gt;build_uspace_pdu(cmnd, pdu);
+	proto-&gt;build_uspace_pdu(cmd, pdu);
 
 	return netlink_unicast(nls, skb, tgt_pid, 0);
 }
-EXPORT_SYMBOL_GPL(tgt_uspace_cmnd_send);
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
 /*
- * TODO we should make cmnd-&gt;done a target callback instead. Maybe
+ * TODO we should make cmd-&gt;done a target callback instead. Maybe
  * target-&gt;tt-&gt;queuecommand. We need this becuase a target driver
  * may not have the resources to execute the command. We also need
  * a real queue, I guess, and some queue limits.
@@ -692,35 +692,35 @@
  * BE ABLE TO EXECUTE FROM A SOFTIRQ SINCE WE WILL EVENTUALLY GO ALL ASYNC
  *
  */
-static void tgt_notify_cmnd_ready(void *data)
+static void tgt_notify_cmd_ready(void *data)
 {
-	struct tgt_cmnd *cmnd = data;
-	void (*done)(struct tgt_cmnd *);
+	struct tgt_cmd *cmd = data;
+	void (*done)(struct tgt_cmd *);
 
-	done = cmnd-&gt;done;
-	cmnd-&gt;done = NULL;
-	done(cmnd);
+	done = cmd-&gt;done;
+	cmd-&gt;done = NULL;
+	done(cmd);
 }
 
-void tgt_cmnd_done(struct tgt_cmnd *cmnd)
+void tgt_cmd_done(struct tgt_cmd *cmd)
 {
-	struct tgt_session *session = cmnd-&gt;session;
+	struct tgt_session *session = cmd-&gt;session;
 
-	INIT_WORK(&amp;cmnd-&gt;work, tgt_notify_cmnd_ready, cmnd);
-	queue_work(session-&gt;target-&gt;twq, &amp;cmnd-&gt;work);
+	INIT_WORK(&amp;cmd-&gt;work, tgt_notify_cmd_ready, cmd);
+	queue_work(session-&gt;target-&gt;twq, &amp;cmd-&gt;work);
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_done);
+EXPORT_SYMBOL_GPL(tgt_cmd_done);
 
-static void uspace_cmnd_done(struct tgt_cmnd *cmnd, void *data,
+static void uspace_cmd_done(struct tgt_cmd *cmd, void *data,
 			     int result, uint32_t len)
 {
-	struct tgt_device *device = cmnd-&gt;device;
+	struct tgt_device *device = cmd-&gt;device;
 	char *p = data;
 	int i;
-	BUG_ON(!cmnd-&gt;done);
+	BUG_ON(!cmd-&gt;done);
 
 	dprintk(&quot;cid %llu result %d len %d bufflen %u\n&quot;,
-		cmnd-&gt;cid, result, len, cmnd-&gt;bufflen);
+		cmd-&gt;cid, result, len, cmd-&gt;bufflen);
 
 	if (len) {
 		/*
@@ -728,91 +728,91 @@
 		 * This will happen if we though we were going to do some
 		 * IO but we ended up just gettting some sense back
 		 */
-		if (len != cmnd-&gt;bufflen) {
-			tgt_free_buffer(cmnd);
+		if (len != cmd-&gt;bufflen) {
+			tgt_free_buffer(cmd);
 
-			cmnd-&gt;bufflen = len;
-			cmnd-&gt;offset = 0;
+			cmd-&gt;bufflen = len;
+			cmd-&gt;offset = 0;
 
-			__tgt_alloc_buffer(cmnd);
+			__tgt_alloc_buffer(cmd);
 		}
 
-		for (i = 0; i &lt; cmnd-&gt;sg_count; i++) {
+		for (i = 0; i &lt; cmd-&gt;sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
 
-			memcpy(page_address(cmnd-&gt;sg[i].page), p, copy);
+			memcpy(page_address(cmd-&gt;sg[i].page), p, copy);
 			p += copy;
 			len -= copy;
 		}
 	}
 
-	cmnd-&gt;result = result;
-	if (device-&gt;dt-&gt;complete_uspace_cmnd)
-		device-&gt;dt-&gt;complete_uspace_cmnd(cmnd);
-	tgt_cmnd_done(cmnd);
+	cmd-&gt;result = result;
+	if (device-&gt;dt-&gt;complete_uspace_cmd)
+		device-&gt;dt-&gt;complete_uspace_cmd(cmd);
+	tgt_cmd_done(cmd);
 }
 
 static void queuecommand(void *data)
 {
 	int err = 0;
-	struct tgt_cmnd *cmnd = data;
-	struct tgt_target *target = cmnd-&gt;session-&gt;target;
-	struct tgt_device *device = cmnd-&gt;device;
+	struct tgt_cmd *cmd = data;
+	struct tgt_target *target = cmd-&gt;session-&gt;target;
+	struct tgt_device *device = cmd-&gt;device;
 
-	dprintk(&quot;cid %llu\n&quot;, cmnd-&gt;cid);
+	dprintk(&quot;cid %llu\n&quot;, cmd-&gt;cid);
 
 	/* Should we do this earlier? */
 	if (!device)
-		cmnd-&gt;device = device = tgt_device_find(target, cmnd-&gt;dev_id);
+		cmd-&gt;device = device = tgt_device_find(target, cmd-&gt;dev_id);
 	if (device)
-		dprintk(&quot;found %llu\n&quot;, cmnd-&gt;dev_id);
+		dprintk(&quot;found %llu\n&quot;, cmd-&gt;dev_id);
 
-	err = device-&gt;dt-&gt;queue_cmnd(cmnd);
+	err = device-&gt;dt-&gt;queue_cmd(cmd);
 
 	switch (err) {
-	case TGT_CMND_FAILED:
-	case TGT_CMND_COMPLETED:
+	case TGT_CMD_FAILED:
+	case TGT_CMD_COMPLETED:
 		dprintk(&quot;command completed %d\n&quot;, err);
-		tgt_notify_cmnd_ready(cmnd);
+		tgt_notify_cmd_ready(cmd);
 	default:
-		dprintk(&quot;command %llu queued\n&quot;, cmnd-&gt;cid);
+		dprintk(&quot;command %llu queued\n&quot;, cmd-&gt;cid);
 	};
 }
 
-int tgt_cmnd_queue(struct tgt_cmnd *cmnd, void (*done)(struct tgt_cmnd *))
+int tgt_cmd_queue(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
 {
-	struct tgt_session *session = cmnd-&gt;session;
+	struct tgt_session *session = cmd-&gt;session;
 
-	BUG_ON(cmnd-&gt;done);
+	BUG_ON(cmd-&gt;done);
 	BUG_ON(!done);
 
-	cmnd-&gt;done = done;
-	INIT_WORK(&amp;cmnd-&gt;work, queuecommand, cmnd);
-	queue_work(session-&gt;target-&gt;twq, &amp;cmnd-&gt;work);
+	cmd-&gt;done = done;
+	INIT_WORK(&amp;cmd-&gt;work, queuecommand, cmd);
+	queue_work(session-&gt;target-&gt;twq, &amp;cmd-&gt;work);
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(tgt_cmnd_queue);
+EXPORT_SYMBOL_GPL(tgt_cmd_queue);
 
-static struct tgt_cmnd *find_cmnd_by_id(uint64_t cid)
+static struct tgt_cmd *find_cmd_by_id(uint64_t cid)
 {
 	struct list_head *head;
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	unsigned long flags;
 
-	head = &amp;cmnd_hash[cmnd_hashfn(cid)];
+	head = &amp;cmd_hash[cmd_hashfn(cid)];
 
-	spin_lock_irqsave(&amp;cmnd_hash_lock, flags);
+	spin_lock_irqsave(&amp;cmd_hash_lock, flags);
 
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd-&gt;cid == cid)
+	list_for_each_entry(cmd, head, hash_list) {
+		if (cmd-&gt;cid == cid)
 			goto found;
 	}
-	cmnd = NULL;
+	cmd = NULL;
 found:
-	spin_unlock_irqrestore(&amp;cmnd_hash_lock, flags);
+	spin_unlock_irqrestore(&amp;cmd_hash_lock, flags);
 
-	return cmnd;
+	return cmd;
 }
 
 int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
@@ -846,7 +846,7 @@
 {
 	int err = 0;
 	struct tgt_event *ev = NLMSG_DATA(nlh);
-	struct tgt_cmnd *cmnd;
+	struct tgt_cmd *cmd;
 	struct tgt_target *target;
 
 	dprintk(&quot;%d %d %d %d\n&quot;, daemon_pid, nlh-&gt;nlmsg_type,
@@ -864,7 +864,7 @@
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev-&gt;u.c_target.type,
-					   ev-&gt;u.c_target.nr_cmnds);
+					   ev-&gt;u.c_target.nr_cmds);
 		if (target)
 			err = target-&gt;tid;
 		else
@@ -900,14 +900,14 @@
 		err = tgt_device_destroy(ev-&gt;u.d_device.tid,
 					 ev-&gt;u.d_device.dev_id);
 		break;
-	case TGT_UEVENT_CMND_RES:
-		cmnd = find_cmnd_by_id(ev-&gt;u.cmnd_res.cid);
-		if (cmnd)
-			uspace_cmnd_done(cmnd, ev-&gt;data,
-					 ev-&gt;u.cmnd_res.result,
-					 ev-&gt;u.cmnd_res.len);
+	case TGT_UEVENT_CMD_RES:
+		cmd = find_cmd_by_id(ev-&gt;u.cmd_res.cid);
+		if (cmd)
+			uspace_cmd_done(cmd, ev-&gt;data,
+					 ev-&gt;u.cmd_res.result,
+					 ev-&gt;u.cmd_res.len);
 		else {
-			eprintk(&quot;cannot found %llu\n&quot;, ev-&gt;u.cmnd_res.cid);
+			eprintk(&quot;cannot found %llu\n&quot;, ev-&gt;u.cmd_res.cid);
 			err = -EEXIST;
 		}
 		break;
@@ -954,7 +954,7 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMND_RES &amp;&amp;
+		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMD_RES &amp;&amp;
 		    nlh-&gt;nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
 			ev-&gt;k.event_res.err = err;
 			send_event_res(NETLINK_CREDS(skb)-&gt;pid,
@@ -991,7 +991,7 @@
 	int i, err = -ENOMEM;
 
 	spin_lock_init(&amp;all_targets_lock);
-	spin_lock_init(&amp;cmnd_hash_lock);
+	spin_lock_init(&amp;cmd_hash_lock);
 	spin_lock_init(&amp;target_tmpl_lock);
 	spin_lock_init(&amp;device_tmpl_lock);
 
@@ -1005,8 +1005,8 @@
 	if (!nls)
 		goto out;
 
-	for (i = 0; i &lt; ARRAY_SIZE(cmnd_hash); i++)
-		INIT_LIST_HEAD(&amp;cmnd_hash[i]);
+	for (i = 0; i &lt; ARRAY_SIZE(cmd_hash); i++)
+		INIT_LIST_HEAD(&amp;cmd_hash[i]);
 
 	return 0;
 out:

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -19,10 +19,10 @@
 	struct tgt_target *target;
 	struct list_head slist;
 
-	mempool_t *cmnd_pool;
+	mempool_t *cmd_pool;
 };
 
-struct tgt_cmnd {
+struct tgt_cmd {
 	struct tgt_session *session;
 	struct tgt_device *device;
 	struct tgt_protocol *proto;
@@ -32,7 +32,7 @@
 	uint64_t cid;
 
 	struct work_struct work;
-	void (*done) (struct tgt_cmnd *);
+	void (*done) (struct tgt_cmd *);
 
 	struct list_head clist;
 	struct list_head hash_list;
@@ -57,20 +57,20 @@
 
 extern struct tgt_session *
 tgt_session_create(struct tgt_target *target,
-		   int max_cmnds,
+		   int max_cmds,
 		   void (*done)(void *, struct tgt_session *), void *arg);
 extern int tgt_session_destroy(struct tgt_session *session);
 
 extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
 			unsigned int gfp_flags);
-extern int tgt_uspace_cmnd_send(struct tgt_cmnd *cmnd);
-extern struct tgt_cmnd *tgt_cmnd_create(struct tgt_session *session);
-extern void tgt_cmnd_destroy(struct tgt_cmnd *cmnd);
-extern void tgt_cmnd_alloc_buffer(struct tgt_cmnd *cmnd,
-				  void (*done)(struct tgt_cmnd *));
-extern int tgt_cmnd_queue(struct tgt_cmnd *cmnd,
-			  void (*done)(struct tgt_cmnd *));
-extern void tgt_cmnd_done(struct tgt_cmnd *cmnd);
+extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
+extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session);
+extern void tgt_cmd_destroy(struct tgt_cmd *cmd);
+extern void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd,
+				  void (*done)(struct tgt_cmd *));
+extern int tgt_cmd_queue(struct tgt_cmd *cmd,
+			  void (*done)(struct tgt_cmd *));
+extern void tgt_cmd_done(struct tgt_cmd *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 #endif

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_device.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,17 +12,17 @@
 #include &lt;linux/list.h&gt;
 
 struct tgt_device;
-struct tgt_cmnd;
+struct tgt_cmd;
 
 enum {
-	TGT_CMND_COMPLETED,
-	TGT_CMND_FAILED,
+	TGT_CMD_COMPLETED,
+	TGT_CMD_FAILED,
 	/*
 	 * if the device has queued the command it is responsible for
 	 * for completing it
 	 */
-	TGT_CMND_USPACE_QUEUED,
-	TGT_CMND_KERN_QUEUED
+	TGT_CMD_USPACE_QUEUED,
+	TGT_CMD_KERN_QUEUED
 };
 
 struct tgt_device_template {
@@ -36,25 +36,25 @@
 	int (* create)(struct tgt_device *);
 	void (* destroy)(struct tgt_device *);
 	/*
-	 * queue or execute command. Return TGT_CMND*.
-	 * If returning TGT_CMND_COMPLETED or TGT_CMND_FAILED the result
+	 * queue or execute command. Return TGT_CMD*.
+	 * If returning TGT_CMD_COMPLETED or TGT_CMD_FAILED the result
 	 * field must be set.
 	 */
-	int (* queue_cmnd)(struct tgt_cmnd *cmnd);
+	int (* queue_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a userspace command
 	 */
-	void ( *complete_uspace_cmnd)(struct tgt_cmnd *cmnd);
+	void ( *complete_uspace_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a kernel command if your queue_command was async
 	 * and the device used one of the tgt threads to process the
 	 * command
 	 */
-	void (*complete_kern_cmnd)(struct tgt_cmnd *cmnd);
+	void (*complete_kern_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * setup buffer or device fields if needed
 	 */
-	void (* prep_cmnd)(struct tgt_cmnd *cmnd, uint32_t data_len);
+	void (* prep_cmd)(struct tgt_cmd *cmd, uint32_t data_len);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_protocol.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,7 +12,7 @@
 #include &lt;linux/dma-mapping.h&gt;
 
 struct module;
-struct tgt_cmnd;
+struct tgt_cmd;
 struct tgt_session;
 
 /*
@@ -24,7 +24,7 @@
 	const char *name;
 	struct module *module;
 
-	kmem_cache_t *cmnd_cache;
+	kmem_cache_t *cmd_cache;
 	int uspace_pdu_size;
 
 	/*
@@ -37,25 +37,25 @@
 	 * iet to open-iscsi's model so eventually the done() function
 	 * will be a requirement so we can have a common path.
 	 */
-	struct tgt_cmnd *(* create_cmnd)(struct tgt_session *session,
+	struct tgt_cmd *(* create_cmd)(struct tgt_session *session,
 					uint8_t *cmd, uint32_t data_len,
 					enum dma_data_direction data_dir,
 					uint8_t *dev_id_buff, int id_buff_size,
-					void (*done)(struct tgt_cmnd *));
+					void (*done)(struct tgt_cmd *));
 	/*
 	 * destroy a command. This will free the command and buffer
 	 */
-	void (* destroy_cmnd)(struct tgt_cmnd *cmd); 
+	void (* destroy_cmd)(struct tgt_cmd *cmd); 
 	/*
 	 * queue a command to be executed in a workqueue. A done() callback
 	 * must be passed in.
 	 */
-	int (* queue_cmnd)(struct tgt_cmnd *cmnd,
-			   void (*done)(struct tgt_cmnd *));
+	int (* queue_cmd)(struct tgt_cmd *cmd,
+			   void (*done)(struct tgt_cmd *));
 	/*
 	 * build userspace packet
 	 */
-	void (* build_uspace_pdu)(struct tgt_cmnd *cmnd, void *data);
+	void (* build_uspace_pdu)(struct tgt_cmd *cmd, void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_scsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,7 +17,7 @@
 #include &lt;tgt_device.h&gt;
 #include &lt;tgt_protocol.h&gt;
 
-static kmem_cache_t *scsi_tgt_cmnd_cache;
+static kmem_cache_t *scsi_tgt_cmd_cache;
 
 /*
  * we should be able to use scsi-ml's functions for this
@@ -46,100 +46,100 @@
  * we may have to add a wrapper becuase people are passing the lun in
  * differently
  */
-static struct tgt_cmnd *
-scsi_tgt_create_cmnd(struct tgt_session *session, uint8_t *scb,
+static struct tgt_cmd *
+scsi_tgt_create_cmd(struct tgt_session *session, uint8_t *scb,
 		     uint32_t data_len, enum dma_data_direction data_dir,
 		     uint8_t *lun, int lun_size,
-		     void (*done)(struct tgt_cmnd *))
+		     void (*done)(struct tgt_cmd *))
 {
 	struct tgt_device *device;
-	struct tgt_cmnd *cmnd;
-	struct scsi_tgt_cmnd *scmnd;
+	struct tgt_cmd *cmd;
+	struct scsi_tgt_cmd *scmd;
 
-	cmnd = tgt_cmnd_create(session);
-	if (!cmnd) {
+	cmd = tgt_cmd_create(session);
+	if (!cmd) {
 		printk(KERN_ERR &quot;Could not allocate command\n&quot;);
 		return NULL;
 	}
-	scmnd = tgt_cmnd_to_scsi(cmnd);
-	memcpy(scmnd-&gt;scb, scb, sizeof(scmnd-&gt;scb));
+	scmd = tgt_cmd_to_scsi(cmd);
+	memcpy(scmd-&gt;scb, scb, sizeof(scmd-&gt;scb));
 
 	/* translate target driver LUN to device id */
-	cmnd-&gt;dev_id = scsi_tgt_translate_lun(lun, lun_size);
-	device = tgt_device_find(session-&gt;target, cmnd-&gt;dev_id);
+	cmd-&gt;dev_id = scsi_tgt_translate_lun(lun, lun_size);
+	device = tgt_device_find(session-&gt;target, cmd-&gt;dev_id);
 	if (!device) {
 		printk(KERN_ERR &quot;Could not find device if %llu\n&quot;,
-		       cmnd-&gt;dev_id);
+		       cmd-&gt;dev_id);
 		return NULL;
 	}
-	cmnd-&gt;device = device;
+	cmd-&gt;device = device;
 
 	/* is this device specific */
-	cmnd-&gt;data_dir = data_dir;
+	cmd-&gt;data_dir = data_dir;
 	/*
 	 * set bufflen based on data_len for now, but let device specific
 	 * handler overide just in case
 	 */
-	cmnd-&gt;bufflen = data_len;
+	cmd-&gt;bufflen = data_len;
 	/* do scsi device specific setup */
-	device-&gt;dt-&gt;prep_cmnd(cmnd, data_len);
-	if (cmnd-&gt;bufflen)
-		tgt_cmnd_alloc_buffer(cmnd, done);
-	return cmnd;
+	device-&gt;dt-&gt;prep_cmd(cmd, data_len);
+	if (cmd-&gt;bufflen)
+		tgt_cmd_alloc_buffer(cmd, done);
+	return cmd;
 }
 
 /* kspace command failure */
-int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 			      uint8_t ascode, uint8_t ascodeq)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	int len = 8, alen = 6;
-	uint8_t *data = scmnd-&gt;sense_buff;
+	uint8_t *data = scmd-&gt;sense_buff;
 
-	memset(data, 0, sizeof(scmnd-&gt;sense_buff));
+	memset(data, 0, sizeof(scmd-&gt;sense_buff));
 
 	data[0] = 0x70 | 1U &lt;&lt; 7;
 	data[2] = key;
 	data[7] = alen;
 	data[12] = ascode;
 	data[13] = ascodeq;
-	cmnd-&gt;result = SAM_STAT_CHECK_CONDITION;
-	scmnd-&gt;sense_len = len + alen;
+	cmd-&gt;result = SAM_STAT_CHECK_CONDITION;
+	scmd-&gt;sense_len = len + alen;
 
 	return len + alen;
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_data_build);
 
 /* uspace command failure */
-int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd)
+int scsi_tgt_sense_copy(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *data = scmnd-&gt;sense_buff;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *data = scmd-&gt;sense_buff;
 	int len;
 
-	memset(data, 0, sizeof(scmnd-&gt;sense_buff));
-	len = min(cmnd-&gt;bufflen, sizeof(scmnd-&gt;sense_buff));
+	memset(data, 0, sizeof(scmd-&gt;sense_buff));
+	len = min(cmd-&gt;bufflen, sizeof(scmd-&gt;sense_buff));
 
 	/* userspace did everything for us */
-	memcpy(data, page_address(cmnd-&gt;sg[0].page), len);
-	scmnd-&gt;sense_len = len;
+	memcpy(data, page_address(cmd-&gt;sg[0].page), len);
+	scmd-&gt;sense_len = len;
 
 	return len;
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-void scsi_tgt_build_uspace_pdu(struct tgt_cmnd *cmnd, void *data)
+void scsi_tgt_build_uspace_pdu(struct tgt_cmd *cmd, void *data)
 {
-	struct scsi_tgt_cmnd *scmnd = (struct scsi_tgt_cmnd *)cmnd-&gt;proto_priv;
-	memcpy(data, scmnd-&gt;scb, sizeof(scmnd-&gt;scb));
+	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd-&gt;proto_priv;
+	memcpy(data, scmd-&gt;scb, sizeof(scmd-&gt;scb));
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = &quot;scsi&quot;,
 	.module = THIS_MODULE,
-	.create_cmnd = scsi_tgt_create_cmnd,
-	.destroy_cmnd = tgt_cmnd_destroy,
-	.queue_cmnd = tgt_cmnd_queue,
+	.create_cmd = scsi_tgt_create_cmd,
+	.destroy_cmd = tgt_cmd_destroy,
+	.queue_cmd = tgt_cmd_queue,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
@@ -148,23 +148,23 @@
 {
 	int err;
 
-	scsi_tgt_cmnd_cache = kmem_cache_create(&quot;scsi_tgt_cmnd&quot;,
-			sizeof(struct tgt_cmnd) + sizeof(struct scsi_tgt_cmnd),
+	scsi_tgt_cmd_cache = kmem_cache_create(&quot;scsi_tgt_cmd&quot;,
+			sizeof(struct tgt_cmd) + sizeof(struct scsi_tgt_cmd),
 			0, SLAB_HWCACHE_ALIGN | SLAB_NO_REAP, NULL, NULL);
-	if (!scsi_tgt_cmnd_cache)
+	if (!scsi_tgt_cmd_cache)
 		return -ENOMEM;
-	scsi_tgt_proto.cmnd_cache = scsi_tgt_cmnd_cache;
+	scsi_tgt_proto.cmd_cache = scsi_tgt_cmd_cache;
 
 	err = tgt_protocol_register(&amp;scsi_tgt_proto);
 	if (err)
-		kmem_cache_destroy(scsi_tgt_cmnd_cache);
+		kmem_cache_destroy(scsi_tgt_cmd_cache);
 
 	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
-	kmem_cache_destroy(scsi_tgt_cmnd_cache);
+	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	tgt_protocol_unregister(&amp;scsi_tgt_proto);
 }
 

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_scsi.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -12,19 +12,19 @@
 #include &lt;tgt.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
 
-struct scsi_tgt_cmnd {
+struct scsi_tgt_cmd {
 	uint8_t scb[MAX_COMMAND_SIZE];
 	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
 	int sense_len;
 	int tags;
 };
 
-static inline struct scsi_tgt_cmnd *tgt_cmnd_to_scsi(struct tgt_cmnd *cmnd)
+static inline struct scsi_tgt_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)
 {
-	return (struct scsi_tgt_cmnd *) cmnd-&gt;proto_priv;
+	return (struct scsi_tgt_cmd *) cmd-&gt;proto_priv;
 }
 
-extern int scsi_tgt_sense_copy(struct tgt_cmnd *cmnd);
-extern int scsi_tgt_sense_data_build(struct tgt_cmnd *cmnd, uint8_t key,
+extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
+extern int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 				     uint8_t ascode, uint8_t ascodeq);
 #endif

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_sd.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -43,10 +43,10 @@
 	return 0;
 }
 
-static void tgt_sd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
+static void tgt_sd_prep(struct tgt_cmd *cmd, uint32_t data_len)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *scb = scmnd-&gt;scb;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *scb = scmd-&gt;scb;
 	uint64_t off = 0;
 
 	/*
@@ -75,29 +75,29 @@
 	/*
 	 * we trust the data_len passed in for now
 	 */
-	cmnd-&gt;bufflen = data_len;
-	cmnd-&gt;offset = off;
+	cmd-&gt;bufflen = data_len;
+	cmd-&gt;offset = off;
 }
 
 static void tgt_sd_end_rq(struct request *rq)
 {
-	struct tgt_cmnd *cmnd = rq-&gt;end_io_data;
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
+	struct tgt_cmd *cmd = rq-&gt;end_io_data;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
 	if (rq-&gt;sense_len) {
-		memcpy(scmnd-&gt;sense_buff, rq-&gt;sense, SCSI_SENSE_BUFFERSIZE);
-		cmnd-&gt;result = SAM_STAT_CHECK_CONDITION;
+		memcpy(scmd-&gt;sense_buff, rq-&gt;sense, SCSI_SENSE_BUFFERSIZE);
+		cmd-&gt;result = SAM_STAT_CHECK_CONDITION;
 	} else if (rq-&gt;errors) {
 		/*
 		 * TODO check *_byte and just send error upwards
 		 */
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		cmnd-&gt;result = SAM_STAT_CHECK_CONDITION;
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		cmd-&gt;result = SAM_STAT_CHECK_CONDITION;
 	} else
-		cmnd-&gt;result = SAM_STAT_GOOD;
+		cmd-&gt;result = SAM_STAT_GOOD;
 
 
-	tgt_cmnd_done(cmnd);
+	tgt_cmd_done(cmd);
 	__blk_put_request(rq-&gt;q, rq);
 }
 
@@ -193,27 +193,27 @@
 /*
  * TODO part of this will move to a io_handler callout
  */
-static int tgt_sd_queue_rq(struct tgt_cmnd *cmnd)
+static int tgt_sd_queue_rq(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	struct file *file = cmnd-&gt;device-&gt;file;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct file *file = cmd-&gt;device-&gt;file;
 	request_queue_t *q = bdev_get_queue(file-&gt;f_dentry-&gt;d_inode-&gt;i_bdev);
 	struct request *rq;
-	int write = (cmnd-&gt;data_dir == DMA_TO_DEVICE);
+	int write = (cmd-&gt;data_dir == DMA_TO_DEVICE);
 
 	rq = blk_get_request(q, write, GFP_KERNEL | __GFP_NOFAIL);
 	if (!rq)
 		goto hw_error;
 
-	if (req_map_sg(q, rq, cmnd-&gt;sg, cmnd-&gt;sg_count,
+	if (req_map_sg(q, rq, cmd-&gt;sg, cmd-&gt;sg_count,
 			GFP_KERNEL | __GFP_NOFAIL))
 		goto free_request;
 
-	rq-&gt;cmd_len = COMMAND_SIZE(scmnd-&gt;scb[0]);
-	memcpy(rq-&gt;cmd, scmnd-&gt;scb, rq-&gt;cmd_len);
+	rq-&gt;cmd_len = COMMAND_SIZE(scmd-&gt;scb[0]);
+	memcpy(rq-&gt;cmd, scmd-&gt;scb, rq-&gt;cmd_len);
 	rq-&gt;sense_len = 0;
-	rq-&gt;sense = scmnd-&gt;sense_buff;
-	rq-&gt;end_io_data = cmnd;
+	rq-&gt;sense = scmd-&gt;sense_buff;
+	rq-&gt;end_io_data = cmd;
 	rq-&gt;timeout = 60 * HZ; /* TODO */
 	rq-&gt;flags |= REQ_BLOCK_PC;
 
@@ -223,32 +223,32 @@
  free_request:
 	blk_put_request(rq);
  hw_error:
-	scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
+	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
 	return -ENOMEM;
 }
 
-static int tgt_sd_queue(struct tgt_cmnd *cmnd)
+static int tgt_sd_queue(struct tgt_cmd *cmd)
 {
-	struct tgt_device *device = cmnd-&gt;device;
-	loff_t pos = cmnd-&gt;offset;
+	struct tgt_device *device = cmd-&gt;device;
+	loff_t pos = cmd-&gt;offset;
 
-	if (cmnd-&gt;bufflen + pos &gt; device-&gt;size) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (cmd-&gt;bufflen + pos &gt; device-&gt;size) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	}
 	/*
-	 * TODO this will become device-&gt;io_handler-&gt;queue_cmnd
+	 * TODO this will become device-&gt;io_handler-&gt;queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	return tgt_sd_queue_rq(cmnd) ? TGT_CMND_FAILED : TGT_CMND_KERN_QUEUED;
+	return tgt_sd_queue_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
 }
 
 static struct tgt_device_template tgt_sd = {
 	.name = &quot;tgt_sd&quot;,
 	.module = THIS_MODULE,
 	.create = tgt_sd_create,
-	.queue_cmnd = tgt_sd_queue,
-	.prep_cmnd = tgt_sd_prep,
+	.queue_cmd = tgt_sd_queue,
+	.prep_cmd = tgt_sd_prep,
 };
 
 static int __init tgt_sd_init(void)

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_sysfs.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -35,12 +35,12 @@
 	tgt_target_template_show_fn(field, format_string)		\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
-tgt_target_rd_attr(queued_cmnds, &quot;%u\n&quot;);
+tgt_target_rd_attr(queued_cmds, &quot;%u\n&quot;);
 tgt_target_template_rd_attr(name, &quot;%s\n&quot;);
 tgt_target_template_rd_attr(protocol, &quot;%s\n&quot;);
 
 static struct class_device_attribute *tgt_target_attrs[] = {
-	&amp;class_device_attr_queued_cmnds,
+	&amp;class_device_attr_queued_cmds,
 	&amp;class_device_attr_name,
 	&amp;class_device_attr_protocol,
 	NULL

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_target.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -41,7 +41,7 @@
 
 	struct class_device cdev;
 
-	int queued_cmnds;
+	int queued_cmds;
 
 	/* Protects session_list, work_list, device_list */
 	spinlock_t lock;
@@ -58,7 +58,7 @@
 #define cdev_to_tgt_target(cdev) \
 	container_of(cdev, struct tgt_target, cdev)
 
-extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmnds);
+extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds);
 extern int tgt_target_destroy(struct tgt_target *target);
 extern int tgt_sysfs_register_target(struct tgt_target *target);
 extern void tgt_sysfs_unregister_target(struct tgt_target *target);

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/kernel/tgt_vsd.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -40,10 +40,10 @@
 /*
  * is this device specific or common? Should it be moved to the protocol.
  */
-static void tgt_vsd_prep(struct tgt_cmnd *cmnd, uint32_t data_len)
+static void tgt_vsd_prep(struct tgt_cmd *cmd, uint32_t data_len)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	uint8_t *scb = scmnd-&gt;scb;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	uint8_t *scb = scmd-&gt;scb;
 	uint64_t off = 0;
 /*	uint32_t len = 0; */
 
@@ -79,15 +79,15 @@
 	/*
 	 * we trust the data_len passed in for now
 	 */
-	cmnd-&gt;bufflen = data_len;
-	cmnd-&gt;offset = off;
+	cmd-&gt;bufflen = data_len;
+	cmd-&gt;offset = off;
 }
 
-static void tgt_vsd_uspace_complete(struct tgt_cmnd *cmnd)
+static void tgt_vsd_uspace_complete(struct tgt_cmd *cmd)
 {
 	/* userspace did everything for us just copy the buffer */
-	if (cmnd-&gt;result != SAM_STAT_GOOD)
-		scsi_tgt_sense_copy(cmnd);
+	if (cmd-&gt;result != SAM_STAT_GOOD)
+		scsi_tgt_sense_copy(cmd);
 }
 
 /*
@@ -114,45 +114,45 @@
 /*
  * TODO this will move to a io_handler callout
  */
-static int vsd_queue_file_io(struct tgt_cmnd *cmnd, int op)
+static int vsd_queue_file_io(struct tgt_cmd *cmd, int op)
 {
-	struct file *file = cmnd-&gt;device-&gt;file;
+	struct file *file = cmd-&gt;device-&gt;file;
 	ssize_t size;
 	struct iovec *iov;
-	loff_t pos = cmnd-&gt;offset;
+	loff_t pos = cmd-&gt;offset;
 
-	iov = sg_to_iovec(cmnd-&gt;sg, cmnd-&gt;sg_count);
+	iov = sg_to_iovec(cmd-&gt;sg, cmd-&gt;sg_count);
 	if (!iov)
 		return -ENOMEM;
 
 	if (op == READ)
-		size = generic_file_readv(file, iov, cmnd-&gt;sg_count, &amp;pos);
+		size = generic_file_readv(file, iov, cmd-&gt;sg_count, &amp;pos);
 	else
-		size = generic_file_writev(file, iov, cmnd-&gt;sg_count, &amp;pos);
+		size = generic_file_writev(file, iov, cmd-&gt;sg_count, &amp;pos);
 
 	kfree(iov);
 
 /* not yet used
 	if (sync)
 		err = sync_page_range(inode, inode-&gt;i_mapping, pos,
-				      (size_t) cmnd-&gt;bufflen);
+				      (size_t) cmd-&gt;bufflen);
 */
 	return size;
 }
 
-static int tgt_vsd_queue(struct tgt_cmnd *cmnd)
+static int tgt_vsd_queue(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmnd *scmnd = tgt_cmnd_to_scsi(cmnd);
-	struct tgt_device *device = cmnd-&gt;device;
-	loff_t pos = cmnd-&gt;offset;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct tgt_device *device = cmd-&gt;device;
+	loff_t pos = cmd-&gt;offset;
 	int err = 0, rw;
 
-	if (cmnd-&gt;bufflen + pos &gt; device-&gt;size) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (cmd-&gt;bufflen + pos &gt; device-&gt;size) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	}
 
-	switch (scmnd-&gt;scb[0]) {
+	switch (scmd-&gt;scb[0]) {
 	case READ_6:
 	case READ_10:
 	case READ_16:
@@ -165,32 +165,32 @@
 		rw = WRITE;
 		break;
 	default:
-		err = tgt_uspace_cmnd_send(cmnd);
+		err = tgt_uspace_cmd_send(cmd);
 		/*
 		 * successfully queued
 		 */
 		if (err &gt;= 0)
-			return TGT_CMND_USPACE_QUEUED;
+			return TGT_CMD_USPACE_QUEUED;
 
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	};
 
 	/*
-	 * TODO this will become device-&gt;io_handler-&gt;queue_cmnd
+	 * TODO this will become device-&gt;io_handler-&gt;queue_cmd
 	 * when we seperate the io_handlers
 	 */
-	err = vsd_queue_file_io(cmnd, rw);
+	err = vsd_queue_file_io(cmd, rw);
 	/*
 	 * we should to a switch but I am not sure of all the err values
 	 * returned. If you find one add it
 	 */
-	if (err != cmnd-&gt;bufflen) {
-		scsi_tgt_sense_data_build(cmnd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMND_FAILED;
+	if (err != cmd-&gt;bufflen) {
+		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return TGT_CMD_FAILED;
 	} else {
-		cmnd-&gt;result = SAM_STAT_GOOD;
-		return TGT_CMND_COMPLETED;
+		cmd-&gt;result = SAM_STAT_GOOD;
+		return TGT_CMD_COMPLETED;
 	}
 }
 
@@ -198,9 +198,9 @@
 	.name = &quot;tgt_vsd&quot;,
 	.module = THIS_MODULE,
 	.create = tgt_vsd_create,
-	.queue_cmnd = tgt_vsd_queue,
-	.prep_cmnd = tgt_vsd_prep,
-	.complete_uspace_cmnd = tgt_vsd_uspace_complete,
+	.queue_cmd = tgt_vsd_queue,
+	.prep_cmd = tgt_vsd_prep,
+	.complete_uspace_cmd = tgt_vsd_uspace_complete,
 };
 
 static int __init tgt_vsd_init(void)

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/ipc.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -78,9 +78,9 @@
 		goto out;
 	data = NLMSG_DATA(nlh);
 
-	err = nl_cmnd_call(nl_fd, nlh-&gt;nlmsg_type, data,
-			   nlh-&gt;nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
-			   &amp;res);
+	err = nl_cmd_call(nl_fd, nlh-&gt;nlmsg_type, data,
+			  nlh-&gt;nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
+			  &amp;res);
 
 	dprintf(&quot;%s %d %d %d\n&quot;, __FUNCTION__, __LINE__, err, res);
 

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/netlink.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -74,7 +74,7 @@
 	return rc;
 }
 
-int nl_cmnd_call(int fd, int type, char *data, int size, int *res)
+int nl_cmd_call(int fd, int type, char *data, int size, int *res)
 {
 	int err;
 	struct tgt_event *ev;
@@ -92,12 +92,12 @@
 	return err;
 }
 
-static int cmnd_queue(int fd, char *reqbuf, char *resbuf)
+static int cmd_queue(int fd, char *reqbuf, char *resbuf)
 {
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t cid = ev_req-&gt;k.cmnd_req.cid;
+	uint64_t cid = ev_req-&gt;k.cmd_req.cid;
 	uint8_t *scb;
 
 	memset(resbuf, 0, NL_BUFSIZE);
@@ -105,22 +105,22 @@
 	dprintf(&quot;%&quot; PRIu64 &quot; %x\n&quot;, cid, scb[0]);
 
 	/*
-	 * TODO match tid to protocol and route cmnd to correct userspace
+	 * TODO match tid to protocol and route cmd to correct userspace
 	 * protocol module
 	 */
-	result = scsi_cmnd_process(ev_req-&gt;k.cmnd_req.tid,
-				   ev_req-&gt;k.cmnd_req.dev_id, scb,
+	result = scsi_cmd_process(ev_req-&gt;k.cmd_req.tid,
+				   ev_req-&gt;k.cmd_req.dev_id, scb,
 				   (uint8_t *) ev_res-&gt;data, &amp;len);
 
 	memset(ev_res, 0, sizeof(*ev_res));
-	ev_res-&gt;u.cmnd_res.cid = cid;
-	ev_res-&gt;u.cmnd_res.len = len;
-	ev_res-&gt;u.cmnd_res.result = result;
+	ev_res-&gt;u.cmd_res.cid = cid;
+	ev_res-&gt;u.cmd_res.len = len;
+	ev_res-&gt;u.cmd_res.result = result;
 
 
-	log_error(&quot;scsi_cmnd_process res %d len %d\n&quot;, result, len);
+	log_error(&quot;scsi_cmd_process res %d len %d\n&quot;, result, len);
 
-	return nl_write(fd, TGT_UEVENT_CMND_RES, resbuf,
+	return nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
 			NLMSG_SPACE(sizeof(*ev_res) + len));
 }
 
@@ -158,8 +158,8 @@
 	}
 
 	switch (nlh-&gt;nlmsg_type) {
-	case TGT_KEVENT_CMND_REQ:
-		cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
+	case TGT_KEVENT_CMD_REQ:
+		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	default:
 		/* kernel module bug */
@@ -174,7 +174,7 @@
 	int err, res;
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
 
-	err = nl_cmnd_call(fd, TGT_UEVENT_START, nlmsg, 
+	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg, 
 			   NLMSG_SPACE(sizeof(struct tgt_event)), &amp;res);
 	if (err &lt; 0 || res &lt; 0) {
 		eprintf(&quot;%d %d\n&quot;, err, res);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/scsi.c	2005-09-24 00:30:13 UTC (rev 94)
@@ -492,7 +492,7 @@
 	return SAM_STAT_GOOD;
 }
 
-int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_GOOD;
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-09-24 00:14:51 UTC (rev 93)
+++ trunk/usr/tgtd.h	2005-09-24 00:30:13 UTC (rev 94)
@@ -17,12 +17,12 @@
 
 extern int nl_open(void);
 extern void nl_event_handle(int fd);
-extern int nl_cmnd_call(int fd, int type, char *data, int size, int *res);
+extern int nl_cmd_call(int fd, int type, char *data, int size, int *res);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-extern int scsi_cmnd_process(int tid, uint64_t lun, uint8_t *scb,
-			     uint8_t *data, int *len);
+extern int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb,
+			    uint8_t *data, int *len);
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000086.html">[Stgt-svn] r93 - trunk/kernel
</A></li>
	<LI>Next message: <A HREF="000088.html">[Stgt-svn] r95 - in trunk: iscsi/kernel kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#87">[ date ]</a>
              <a href="thread.html#87">[ thread ]</a>
              <a href="subject.html#87">[ subject ]</a>
              <a href="author.html#87">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
