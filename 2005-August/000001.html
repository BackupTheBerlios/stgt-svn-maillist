<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r6 - trunk/iscsi/kernel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2005-August/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r6%20-%20trunk/iscsi/kernel&In-Reply-To=%3C200508170741.j7H7fqpt009084%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000000.html">
   <LINK REL="Next"  HREF="000002.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r6 - trunk/iscsi/kernel</H1>
    <B>Tomonori Fujita at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r6%20-%20trunk/iscsi/kernel&In-Reply-To=%3C200508170741.j7H7fqpt009084%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r6 - trunk/iscsi/kernel">tomo at berlios.de
       </A><BR>
    <I>Wed Aug 17 09:41:52 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000000.html">[Stgt-svn] r5 - trunk/usr
</A></li>
        <LI>Next message: <A HREF="000002.html">[Stgt-svn] r7 - trunk/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2005-08-17 09:41:44 +0200 (Wed, 17 Aug 2005)
New Revision: 6

Added:
   trunk/iscsi/kernel/iscsi_proto.h
Removed:
   trunk/iscsi/kernel/iscsi_hdr.h
Modified:
   trunk/iscsi/kernel/digest.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
Log:
Use open-iscsi iscsi_proto.h instead of Ardis iscsi_hdr.h (Thanks to Mike).

Modified: trunk/iscsi/kernel/digest.c
===================================================================
--- trunk/iscsi/kernel/digest.c	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/digest.c	2005-08-17 07:41:44 UTC (rev 6)
@@ -101,7 +101,7 @@
 		printk(&quot;\tcmnd: 0x%x, itt 0x%x, sn 0x%x\n&quot;,
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd-&gt;pdu.bhs.itt),
-		       be32_to_cpu(cmnd-&gt;pdu.bhs.sn));
+		       be32_to_cpu(cmnd-&gt;pdu.bhs.statsn));
 		cmnd-&gt;hdigest = ~cmnd-&gt;hdigest;
 		/* make things even worse by manipulating header fields */
 		cmnd-&gt;pdu.datasize += 8;
@@ -146,7 +146,7 @@
 		printk(&quot;\tcmnd 0x%x, itt 0x%x, sn 0x%x\n&quot;,
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd-&gt;pdu.bhs.itt),
-		       be32_to_cpu(cmnd-&gt;pdu.bhs.sn));
+		       be32_to_cpu(cmnd-&gt;pdu.bhs.statsn));
 		cmnd-&gt;ddigest = ~cmnd-&gt;ddigest;
 		num_errs++;
 		num_cmnds = 0;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi.c	2005-08-17 07:41:44 UTC (rev 6)
@@ -25,21 +25,21 @@
 
 static u32 cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr-&gt;flags &amp; ISCSI_CMD_WRITE)
+	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)
 		return be32_to_cpu(hdr-&gt;data_length);
 	return 0;
 }
 
 static u32 cmnd_read_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr-&gt;flags &amp; ISCSI_CMD_READ) {
-		if (!(hdr-&gt;flags &amp; ISCSI_CMD_WRITE))
+	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
+		if (!(hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE))
 			return be32_to_cpu(hdr-&gt;data_length);
-		if (hdr-&gt;flags &amp; ISCSI_CMD_READ) {
+		if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
 			struct iscsi_rlength_ahdr *ahdr =
 				(struct iscsi_rlength_ahdr *)cmnd-&gt;pdu.ahs;
 			if (ahdr &amp;&amp; ahdr-&gt;ahstype == ISCSI_AHSTYPE_RLENGTH)
@@ -162,8 +162,8 @@
 	struct iscsi_conn *conn = cmnd-&gt;conn;
 	struct iscsi_cmnd *data_cmnd;
 	struct scatterlist *sg = cmnd-&gt;stc-&gt;sg;
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
-	struct iscsi_data_in_hdr *rsp;
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
+	struct iscsi_data_rsp *rsp;
 	u32 pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
@@ -181,24 +181,25 @@
 	while (1) {
 		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size &lt;= pdusize);
 		data_cmnd-&gt;sg = sg;
-		rsp = (struct iscsi_data_in_hdr *)&amp;data_cmnd-&gt;pdu.bhs;
+		rsp = (struct iscsi_data_rsp *)&amp;data_cmnd-&gt;pdu.bhs;
 
 		rsp-&gt;opcode = ISCSI_OP_SCSI_DATA_IN;
 		rsp-&gt;itt = req-&gt;itt;
 		rsp-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-		rsp-&gt;buffer_offset = offset;
-		rsp-&gt;data_sn = cpu_to_be32(sn);
+		rsp-&gt;offset = offset;
+		rsp-&gt;datasn = cpu_to_be32(sn);
 
 		if (size &lt;= pdusize) {
 			data_cmnd-&gt;pdu.datasize = size;
-			rsp-&gt;flags = ISCSI_FLG_FINAL | ISCSI_FLG_STATUS;
+			rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL |
+				     ISCSI_FLAG_DATA_STATUS;
 
 			scsisize = cmnd-&gt;stc-&gt;bufflen;
 			if (scsisize &lt; expsize) {
-				rsp-&gt;flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+				rsp-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 				size = expsize - scsisize;
 			} else if (scsisize &gt; expsize) {
-				rsp-&gt;flags |= ISCSI_FLG_RESIDUAL_OVERFLOW;
+				rsp-&gt;flags |= ISCSI_FLAG_CMD_OVERFLOW;
 				size = scsisize - expsize;
 			} else
 				size = 0;
@@ -223,15 +224,15 @@
 static struct iscsi_cmnd *create_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd_rsp *rsp_hdr;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&amp;rsp-&gt;pdu.bhs;
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLG_FINAL;
-	rsp_hdr-&gt;response = ISCSI_RESPONSE_COMMAND_COMPLETED;
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr-&gt;cmd_status = SAM_STAT_GOOD;
 	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
 
@@ -241,13 +242,13 @@
 void send_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = create_scsi_rsp(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *) &amp;rsp-&gt;pdu.bhs;
+	rsp_hdr = (struct iscsi_cmd_rsp *) &amp;rsp-&gt;pdu.bhs;
 	if ((size = cmnd_read_size(req)) != 0) {
-		rsp_hdr-&gt;flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
 	}
 
@@ -322,16 +323,16 @@
 	kfree(cmnd-&gt;pdu.ahs);
 
 	if (!list_empty(&amp;cmnd-&gt;list)) {
-		struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+		struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 		eprintk(&quot;cmnd %p still on some list?, %x, %x, %x, %x, %x, %x, %x %lx %lx\n&quot;,
-			cmnd, req-&gt;opcode, req-&gt;scb[0], req-&gt;flags, req-&gt;itt,
+			cmnd, req-&gt;opcode, req-&gt;cdb[0], req-&gt;flags, req-&gt;itt,
 			be32_to_cpu(req-&gt;data_length),
-			req-&gt;cmd_sn, be32_to_cpu(cmnd-&gt;pdu.datasize), cmnd-&gt;state, conn-&gt;state);
+			req-&gt;cmdsn, be32_to_cpu(cmnd-&gt;pdu.datasize), cmnd-&gt;state, conn-&gt;state);
 
 		if (cmnd-&gt;req) {
-			struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd-&gt;req);
-			eprintk(&quot;%p %x %u\n&quot;, req, req-&gt;opcode, req-&gt;scb[0]);
+			struct iscsi_cmd *req = cmnd_hdr(cmnd-&gt;req);
+			eprintk(&quot;%p %x %u\n&quot;, req, req-&gt;opcode, req-&gt;cdb[0]);
 		}
 		dump_stack();
 		BUG();
@@ -359,7 +360,7 @@
 	assert(0);
 
 /* 	eprintk(&quot;%x %x %x %u\n&quot;, cmnd_itt(cmnd), cmnd_opcode(cmnd), */
-/* 		cmnd_hdr(cmnd)-&gt;scb[0], cmnd-&gt;pdu.datasize); */
+/* 		cmnd_hdr(cmnd)-&gt;cdb[0], cmnd-&gt;pdu.datasize); */
 
 /* 	if (!(size = cmnd-&gt;pdu.datasize)) */
 /* 		return; */
@@ -416,9 +417,10 @@
 	struct iscsi_session *sess = conn-&gt;session;
 
 	if (set_stat_sn)
-		cmnd-&gt;pdu.bhs.sn = cpu_to_be32(conn-&gt;stat_sn++);
-	cmnd-&gt;pdu.bhs.exp_sn = cpu_to_be32(sess-&gt;exp_cmd_sn);
-	cmnd-&gt;pdu.bhs.max_sn = cpu_to_be32(sess-&gt;exp_cmd_sn + sess-&gt;max_queued_cmnds);
+		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn++);
+	cmnd-&gt;pdu.bhs.exp_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn);
+	cmnd-&gt;pdu.bhs.max_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn +
+						sess-&gt;max_queued_cmnds);
 }
 
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
@@ -426,7 +428,7 @@
 	struct iscsi_conn *conn = cmnd-&gt;conn;
 	u32 exp_stat_sn;
 
-	cmnd-&gt;pdu.bhs.exp_sn = exp_stat_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.exp_sn);
+	cmnd-&gt;pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.exp_statsn);
 	dprintk(D_GENERIC, &quot;%x,%x\n&quot;, cmnd_opcode(cmnd), exp_stat_sn);
 	if ((int)(exp_stat_sn - conn-&gt;exp_stat_sn) &gt; 0 &amp;&amp;
 	    (int)(exp_stat_sn - conn-&gt;stat_sn) &lt;= 0) {
@@ -440,12 +442,12 @@
 	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
 	u32 cmd_sn;
 
-	cmnd-&gt;pdu.bhs.sn = cmd_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.sn);
+	cmnd-&gt;pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.statsn);
 	dprintk(D_GENERIC, &quot;%d(%d)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
 	if ((s32)(cmd_sn - session-&gt;exp_cmd_sn) &gt;= 0)
 		return 0;
 	eprintk(&quot;sequence error (%x,%x)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
-	return -ISCSI_REASON_PROTOCOL_ERROR;
+	return -ISCSI_PROTOCOL_ERROR;
 }
 
 static struct iscsi_cmnd *__cmnd_find_hash(struct iscsi_session *session, u32 itt, u32 ttt)
@@ -489,7 +491,7 @@
 
 	dprintk(D_GENERIC, &quot;%p:%x\n&quot;, cmnd, itt);
 	if (itt == ISCSI_RESERVED_TAG) {
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -502,7 +504,7 @@
 		list_add_tail(&amp;cmnd-&gt;hash_list, head);
 		set_cmnd_hashed(cmnd);
 	} else
-		err = -ISCSI_REASON_TASK_IN_PROGRESS;
+		err = -TASK_IN_PROGRESS;
 
 	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
 
@@ -540,28 +542,28 @@
 static void cmnd_skip_data(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = get_rsp_cmnd(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&amp;rsp-&gt;pdu.bhs;
-	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_RSP) {
+	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
+	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
 		eprintk(&quot;unexpected response command %u\n&quot;, cmnd_opcode(rsp));
 		return;
 	}
 
 	size = cmnd_write_size(req);
 	if (size) {
-		rsp_hdr-&gt;flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
 	}
 	size = cmnd_read_size(req);
 	if (size) {
-		if (cmnd_hdr(req)-&gt;flags &amp; ISCSI_CMD_WRITE) {
-			rsp_hdr-&gt;flags |= ISCSI_FLG_BIRESIDUAL_UNDERFLOW;
+		if (cmnd_hdr(req)-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
+			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
 			rsp_hdr-&gt;bi_residual_count = cpu_to_be32(size);
 		} else {
-			rsp_hdr-&gt;flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
 			rsp_hdr-&gt;residual_count = cpu_to_be32(size);
 		}
 	}
@@ -629,7 +631,7 @@
 static void send_r2t(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_r2t_hdr *rsp_hdr;
+	struct iscsi_r2t_rsp *rsp_hdr;
 	u32 length, offset, burst;
 	LIST_HEAD(send);
 
@@ -641,13 +643,13 @@
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
 		rsp-&gt;pdu.bhs.ttt = req-&gt;target_task_tag;
 
-		rsp_hdr = (struct iscsi_r2t_hdr *)&amp;rsp-&gt;pdu.bhs;
+		rsp_hdr = (struct iscsi_r2t_rsp *)&amp;rsp-&gt;pdu.bhs;
 		rsp_hdr-&gt;opcode = ISCSI_OP_R2T;
-		rsp_hdr-&gt;flags = ISCSI_FLG_FINAL;
+		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 		memcpy(rsp_hdr-&gt;lun, cmnd_hdr(req)-&gt;lun, 8);
 		rsp_hdr-&gt;itt = cmnd_hdr(req)-&gt;itt;
-		rsp_hdr-&gt;r2t_sn = cpu_to_be32(req-&gt;r2t_sn++);
-		rsp_hdr-&gt;buffer_offset = cpu_to_be32(offset);
+		rsp_hdr-&gt;r2tsn = cpu_to_be32(req-&gt;r2t_sn++);
+		rsp_hdr-&gt;data_offset = cpu_to_be32(offset);
 		if (length &gt; burst) {
 			rsp_hdr-&gt;data_length = cpu_to_be32(burst);
 			length -= burst;
@@ -659,8 +661,8 @@
 
 		dprintk(D_WRITE, &quot;%x %u %u %u %u\n&quot;, cmnd_itt(req),
 			be32_to_cpu(rsp_hdr-&gt;data_length),
-			be32_to_cpu(rsp_hdr-&gt;buffer_offset),
-			be32_to_cpu(rsp_hdr-&gt;r2t_sn), req-&gt;outstanding_r2t);
+			be32_to_cpu(rsp_hdr-&gt;data_offset),
+			be32_to_cpu(rsp_hdr-&gt;r2tsn), req-&gt;outstanding_r2t);
 
 		list_add_tail(&amp;rsp-&gt;list, &amp;send);
 
@@ -675,9 +677,9 @@
 static void scsi_cmnd_done(struct stgt_cmnd *stc)
 {
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) stc-&gt;private;
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
-	switch (req-&gt;scb[0]) {
+	switch (req-&gt;cdb[0]) {
 	case INQUIRY:
 	case REPORT_LUNS:
 	case READ_CAPACITY:
@@ -733,7 +735,7 @@
 		 * See 10.18.2 in the draft 20.
 		 */
 		eprintk(&quot;initiator bug %x\n&quot;, cmnd_itt(cmnd));
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -799,17 +801,17 @@
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
 
-	dprintk(D_GENERIC, &quot;scsi command: %02x\n&quot;, req_hdr-&gt;scb[0]);
+	dprintk(D_GENERIC, &quot;scsi command: %02x\n&quot;, req_hdr-&gt;cdb[0]);
 
-	eprintk(&quot;scsi command: %02x\n&quot;, req_hdr-&gt;scb[0]);
+	eprintk(&quot;scsi command: %02x\n&quot;, req_hdr-&gt;cdb[0]);
 
-	memcpy(req-&gt;stc-&gt;scb, req_hdr-&gt;scb, sizeof(req-&gt;stc-&gt;scb));
+	memcpy(req-&gt;stc-&gt;scb, req_hdr-&gt;cdb, sizeof(req-&gt;stc-&gt;scb));
 
-	switch (req_hdr-&gt;scb[0]) {
+	switch (req_hdr-&gt;cdb[0]) {
 	case SERVICE_ACTION_IN:
-		if ((req_hdr-&gt;scb[1] &amp; 0x1f) != 0x10)
+		if ((req_hdr-&gt;cdb[1] &amp; 0x1f) != 0x10)
 			goto error;
 
 	case INQUIRY:
@@ -827,9 +829,10 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	{
-		if (!(req_hdr-&gt;flags &amp; ISCSI_CMD_FINAL) || req-&gt;pdu.datasize) {
+		if (!(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ||
+		      req-&gt;pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;scb[0]);
+			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -839,9 +842,10 @@
 	case READ_10:
 	case READ_16:
 	{
-		if (!(req_hdr-&gt;flags &amp; ISCSI_CMD_FINAL) || req-&gt;pdu.datasize) {
+		if (!(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ||
+		      req-&gt;pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;scb[0]);
+			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -858,16 +862,18 @@
 		struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
 
 		req-&gt;r2t_length = be32_to_cpu(req_hdr-&gt;data_length) - req-&gt;pdu.datasize;
-		req-&gt;is_unsolicited_data = !(req_hdr-&gt;flags &amp; ISCSI_CMD_FINAL);
+		req-&gt;is_unsolicited_data = !(req_hdr-&gt;flags &amp;
+						ISCSI_FLAG_CMD_FINAL);
 		req-&gt;target_task_tag = get_next_ttt(conn-&gt;session);
 
 		if (!param-&gt;immediate_data &amp;&amp; req-&gt;pdu.datasize)
-			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;scb[0]);
+			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;cdb[0]);
 
-		if (param-&gt;initial_r2t &amp;&amp; !(req_hdr-&gt;flags &amp; ISCSI_CMD_FINAL))
-			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;scb[0]);
+		if (param-&gt;initial_r2t &amp;&amp;
+		    !(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
+			eprintk(&quot;%x %x\n&quot;, cmnd_itt(req), req_hdr-&gt;cdb[0]);
 
-		if (req_hdr-&gt;scb[0] == WRITE_VERIFY &amp;&amp; req_hdr-&gt;scb[1] &amp; 0x02)
+		if (req_hdr-&gt;cdb[0] == WRITE_VERIFY &amp;&amp; req_hdr-&gt;cdb[1] &amp; 0x02)
 			eprintk(&quot;Verification is ignored %x\n&quot;, cmnd_itt(req));
 
 		stgt_cmnd_alloc_buffer(req-&gt;stc, NULL);
@@ -880,7 +886,7 @@
 	}
 	error:
 	default:
-		eprintk(&quot;Unsupported %x\n&quot;, req_hdr-&gt;scb[0]);
+		eprintk(&quot;Unsupported %x\n&quot;, req_hdr-&gt;cdb[0]);
 		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
 		cmnd_skip_data(req);
 		break;
@@ -891,9 +897,9 @@
 
 static void data_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&amp;cmnd-&gt;pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *)&amp;cmnd-&gt;pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd = NULL;
-	u32 offset = be32_to_cpu(req-&gt;buffer_offset);
+	u32 offset = be32_to_cpu(req-&gt;offset);
 
 	update_stat_sn(cmnd);
 
@@ -920,7 +926,7 @@
 
 	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		/* unsolicited burst data */
-		if (scsi_cmnd-&gt;pdu.bhs.flags &amp; ISCSI_FLG_FINAL) {
+		if (scsi_cmnd-&gt;pdu.bhs.flags &amp; ISCSI_FLAG_CMD_FINAL) {
 			eprintk(&quot;unexpected data from %x %x\n&quot;,
 				cmnd_itt(cmnd), cmnd_ttt(cmnd));
 			goto skip_data;
@@ -942,7 +948,7 @@
 
 static void data_out_end(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *) &amp;cmnd-&gt;pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *) &amp;cmnd-&gt;pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd;
 	u32 offset;
 
@@ -953,7 +959,7 @@
 	if (conn-&gt;read_overflow) {
 		eprintk(&quot;%x %u\n&quot;, cmnd_itt(cmnd), conn-&gt;read_overflow);
 /* 		assert(scsi_cmnd-&gt;tio); */
-		offset = be32_to_cpu(req-&gt;buffer_offset);
+		offset = be32_to_cpu(req-&gt;offset);
 		offset += cmnd-&gt;pdu.datasize - conn-&gt;read_overflow;
 		if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;stc, offset, conn-&gt;read_overflow) &lt; 0)
 			assert(0);
@@ -961,17 +967,18 @@
 	}
 
 	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req-&gt;flags &amp; ISCSI_FLG_FINAL) {
+		if (req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) {
 			scsi_cmnd-&gt;is_unsolicited_data = 0;
 			if (!cmnd_pending(scsi_cmnd))
 				scsi_cmnd_exec(scsi_cmnd);
 		}
 	} else {
 		/* TODO : proper error handling */
-		if (!(req-&gt;flags &amp; ISCSI_FLG_FINAL) &amp;&amp; scsi_cmnd-&gt;r2t_length == 0)
+		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) &amp;&amp;
+		    scsi_cmnd-&gt;r2t_length == 0)
 			eprintk(&quot;initiator error %x\n&quot;, cmnd_itt(scsi_cmnd));
 
-		if (!(req-&gt;flags &amp; ISCSI_FLG_FINAL))
+		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
 			goto out;
 
 		scsi_cmnd-&gt;outstanding_r2t--;
@@ -1055,17 +1062,17 @@
 /* 	struct iscsi_conn *conn = req-&gt;conn; */
 /* 	struct iscsi_target *target = conn-&gt;session-&gt;target; */
 	struct iscsi_cmnd *rsp;
-	struct iscsi_task_mgt_hdr *req_hdr = (struct iscsi_task_mgt_hdr *)&amp;req-&gt;pdu.bhs;
-	struct iscsi_task_rsp_hdr *rsp_hdr;
-	int function = req_hdr-&gt;function &amp; ISCSI_FUNCTION_MASK;
+	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&amp;req-&gt;pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
+	int function = req_hdr-&gt;flags &amp; ISCSI_FLAG_TM_FUNC_MASK;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_task_rsp_hdr *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr = (struct iscsi_tm_rsp *)&amp;rsp-&gt;pdu.bhs;
 
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_TASK_MGT_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLG_FINAL;
+	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
-	rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_COMPLETE;
+	rsp_hdr-&gt;response = ISCSI_TMF_RSP_COMPLETE;
 
 	eprintk(&quot;%x %d %x\n&quot;, cmnd_itt(req), function, req_hdr-&gt;rtt);
 
@@ -1119,14 +1126,14 @@
 static void noop_out_exec(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_nop_in_hdr *rsp_hdr;
+	struct iscsi_nopin *rsp_hdr;
 
 	if (cmnd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-		rsp_hdr = (struct iscsi_nop_in_hdr *)&amp;rsp-&gt;pdu.bhs;
+		rsp_hdr = (struct iscsi_nopin *)&amp;rsp-&gt;pdu.bhs;
 		rsp_hdr-&gt;opcode = ISCSI_OP_NOOP_IN;
-		rsp_hdr-&gt;flags = ISCSI_FLG_FINAL;
+		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 		rsp_hdr-&gt;itt = req-&gt;pdu.bhs.itt;
 		rsp_hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
 
@@ -1149,15 +1156,15 @@
 
 static void logout_exec(struct iscsi_cmnd *req)
 {
-	struct iscsi_logout_req_hdr *req_hdr;
+	struct iscsi_logout *req_hdr;
 	struct iscsi_cmnd *rsp;
-	struct iscsi_logout_rsp_hdr *rsp_hdr;
+	struct iscsi_logout_rsp *rsp_hdr;
 
-	req_hdr = (struct iscsi_logout_req_hdr *)&amp;req-&gt;pdu.bhs;
+	req_hdr = (struct iscsi_logout *)&amp;req-&gt;pdu.bhs;
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_logout_rsp_hdr *)&amp;rsp-&gt;pdu.bhs;
+	rsp_hdr = (struct iscsi_logout_rsp *)&amp;rsp-&gt;pdu.bhs;
 	rsp_hdr-&gt;opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLG_FINAL;
+	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
 	set_cmnd_close(rsp);
 	iscsi_cmnd_init_write(rsp);
@@ -1165,7 +1172,8 @@
 
 static void iscsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
-	dprintk(D_GENERIC, &quot;%p,%x,%u\n&quot;, cmnd, cmnd_opcode(cmnd), cmnd-&gt;pdu.bhs.sn);
+	dprintk(D_GENERIC, &quot;%p,%x,%u\n&quot;, cmnd, cmnd_opcode(cmnd),
+		cmnd-&gt;pdu.bhs.statsn);
 
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_OUT:
@@ -1174,17 +1182,17 @@
 	case ISCSI_OP_SCSI_CMD:
 		scsi_cmnd_exec(cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		execute_task_management(cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		logout_exec(cmnd);
 		break;
 	case ISCSI_OP_SCSI_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
 		break;
 	default:
 		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmnd_opcode(cmnd));
@@ -1293,11 +1301,11 @@
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_TEXT_RSP:
@@ -1305,12 +1313,12 @@
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 	{
-		struct iscsi_data_in_hdr *rsp = (struct iscsi_data_in_hdr *)&amp;cmnd-&gt;pdu.bhs;
+		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&amp;cmnd-&gt;pdu.bhs;
 		u32 offset;
 
-		cmnd_set_sn(cmnd, (rsp-&gt;flags &amp; ISCSI_FLG_FINAL) ? 1 : 0);
-		offset = rsp-&gt;buffer_offset;
-		rsp-&gt;buffer_offset = cpu_to_be32(offset);
+		cmnd_set_sn(cmnd, (rsp-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
+		offset = rsp-&gt;offset;
+		rsp-&gt;offset = cpu_to_be32(offset);
 		assert(cmnd-&gt;sg);
 		__cmnd_send_pdu(conn, cmnd-&gt;sg, offset, cmnd-&gt;pdu.datasize);
 		break;
@@ -1320,9 +1328,9 @@
 		break;
 	case ISCSI_OP_R2T:
 		cmnd_set_sn(cmnd, 0);
-		cmnd-&gt;pdu.bhs.sn = cpu_to_be32(conn-&gt;stat_sn);
+		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn);
 		break;
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_REJECT:
@@ -1347,11 +1355,11 @@
 	dprintk(D_GENERIC, &quot;%p:%x\n&quot;, cmnd, cmnd_opcode(cmnd));
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_SCSI_RSP:
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 	case ISCSI_OP_TEXT_RSP:
 	case ISCSI_OP_R2T:
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 	case ISCSI_OP_REJECT:
 	case ISCSI_OP_SCSI_DATA_IN:
 	case ISCSI_OP_LOGOUT_RSP:
@@ -1385,14 +1393,15 @@
 	u32 cmd_sn;
 
 	dprintk(D_GENERIC, &quot;%p:%x %u,%u\n&quot;,
-		cmnd, cmnd_opcode(cmnd), cmnd-&gt;pdu.bhs.sn, session-&gt;exp_cmd_sn);
+		cmnd, cmnd_opcode(cmnd), cmnd-&gt;pdu.bhs.statsn,
+		session-&gt;exp_cmd_sn);
 
 	if (cmnd-&gt;pdu.bhs.opcode &amp; ISCSI_OP_IMMEDIATE) {
 		iscsi_cmnd_exec(cmnd);
 		return;
 	}
 
-	cmd_sn = cmnd-&gt;pdu.bhs.sn;
+	cmd_sn = cmnd-&gt;pdu.bhs.statsn;
 	if (cmd_sn == session-&gt;exp_cmd_sn) {
 		while (1) {
 			session-&gt;exp_cmd_sn = ++cmd_sn;
@@ -1401,10 +1410,10 @@
 			if (list_empty(&amp;session-&gt;pending_list))
 				break;
 			cmnd = list_entry(session-&gt;pending_list.next, struct iscsi_cmnd, list);
-			if (cmnd-&gt;pdu.bhs.sn != cmd_sn)
+			if (cmnd-&gt;pdu.bhs.statsn != cmd_sn)
 				break;
 /* 			eprintk(&quot;find out-of-order %x %u %u\n&quot;, */
-/* 				cmnd_itt(cmnd), cmd_sn, cmnd-&gt;pdu.bhs.sn); */
+/* 				cmnd_itt(cmnd), cmd_sn, cmnd-&gt;pdu.bhs.statsn); */
 			list_del_init(&amp;cmnd-&gt;list);
 			clear_cmnd_pending(cmnd);
 		}
@@ -1421,7 +1430,7 @@
 
 		list_for_each(entry, &amp;session-&gt;pending_list) {
 			struct iscsi_cmnd *tmp = list_entry(entry, struct iscsi_cmnd, list);
-			if (before(cmd_sn, tmp-&gt;pdu.bhs.sn))
+			if (before(cmd_sn, tmp-&gt;pdu.bhs.statsn))
 				break;
 		}
 
@@ -1467,21 +1476,21 @@
 		if (!(err = cmnd_insert_hash(cmnd)))
 			scsi_cmnd_start(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		err = cmnd_insert_hash(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_start(conn, cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		err = cmnd_insert_hash(cmnd);
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		err = -CMD_NOT_SUPPORTED;
 		break;
 	default:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+		err = -CMD_NOT_SUPPORTED;
 		break;
 	}
 
@@ -1500,15 +1509,15 @@
 	case ISCSI_OP_SCSI_REJECT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_LOGOUT:
 		iscsi_session_push_cmnd(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_end(conn, cmnd);
 		break;
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_SNACK:
 		break;
 	case ISCSI_OP_PDU_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -13,7 +13,7 @@
 #include &lt;linux/crypto.h&gt;
 #include &lt;net/sock.h&gt;
 
-#include &quot;iscsi_hdr.h&quot;
+#include &quot;iscsi_proto.h&quot;
 #include &quot;iet_u.h&quot;
 
 struct iscsi_sess_param {
@@ -261,34 +261,21 @@
 
 static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu-&gt;ahssize = pdu-&gt;bhs.length.ahslength * 4;
-	pdu-&gt;datasize = pdu-&gt;bhs.length.datalength;
-#elif defined(__LITTLE_ENDIAN)
-	pdu-&gt;ahssize = (pdu-&gt;bhs.length &amp; 0xff) * 4;
-	pdu-&gt;datasize = be32_to_cpu(pdu-&gt;bhs.length &amp; ~0xff);
-#else
-#error
-#endif
+	pdu-&gt;ahssize = pdu-&gt;bhs.hlength * 4;
+	pdu-&gt;datasize = ntoh24(pdu-&gt;bhs.dlength);
 }
 
 static inline void iscsi_cmnd_set_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu-&gt;bhs.length.ahslength = pdu-&gt;ahssize / 4;
-	pdu-&gt;bhs.length.datalength = pdu-&gt;datasize;
-#elif defined(__LITTLE_ENDIAN)
-	pdu-&gt;bhs.length = cpu_to_be32(pdu-&gt;datasize) | (pdu-&gt;ahssize / 4);
-#else
-#error
-#endif
+	pdu-&gt;bhs.hlength = pdu-&gt;ahssize / 4;
+	hton24(pdu-&gt;bhs.dlength, pdu-&gt;datasize);
 }
 
-#define cmnd_hdr(cmnd) ((struct iscsi_scsi_cmd_hdr *) (&amp;((cmnd)-&gt;pdu.bhs)))
+#define cmnd_hdr(cmnd) ((struct iscsi_cmd *) (&amp;((cmnd)-&gt;pdu.bhs)))
 #define cmnd_ttt(cmnd) cpu_to_be32((cmnd)-&gt;pdu.bhs.ttt)
 #define cmnd_itt(cmnd) cpu_to_be32((cmnd)-&gt;pdu.bhs.itt)
 #define cmnd_opcode(cmnd) ((cmnd)-&gt;pdu.bhs.opcode &amp; ISCSI_OPCODE_MASK)
-#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)-&gt;scb[0]
+#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)-&gt;cdb[0]
 
 #define	SECTOR_SIZE_BITS	9
 

Deleted: trunk/iscsi/kernel/iscsi_hdr.h
===================================================================
--- trunk/iscsi/kernel/iscsi_hdr.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi_hdr.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -1,507 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">roman at ardistech.com</A>&gt;
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef __ISCSI_HDR_H__
-#define __ISCSI_HDR_H__
-
-#include &lt;linux/types.h&gt;
-#include &lt;asm/byteorder.h&gt;
-
-#define ISCSI_VERSION			0
-
-#define __packed __attribute__ ((packed))
-
-struct iscsi_hdr {
-	u8  opcode;			/* 0 */
-	u8  flags;
-	u8  spec1[2];
-#if defined(__BIG_ENDIAN_BITFIELD)
-	struct {			/* 4 */
-		unsigned ahslength : 8;
-		unsigned datalength : 24;
-	} length;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	u32 length;			/* 4 */
-#endif
-	u16 lun[4];			/* 8 */
-	u32 itt;			/* 16 */
-	u32 ttt;			/* 20 */
-	u32 sn;				/* 24 */
-	u32 exp_sn;			/* 28 */
-	u32 max_sn;			/* 32 */
-	u32 spec3[3];			/* 36 */
-} __packed;				/* 48 */
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Client to Server Message Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TASK_MGT_MSG	0x02
-#define ISCSI_OP_LOGIN_CMD		0x03
-#define ISCSI_OP_TEXT_CMD		0x04
-#define ISCSI_OP_SCSI_DATA_OUT		0x05
-#define ISCSI_OP_LOGOUT_CMD		0x06
-#define ISCSI_OP_SNACK_CMD		0x10
-
-#define ISCSI_OP_VENDOR1_CMD		0x1c
-#define ISCSI_OP_VENDOR2_CMD		0x1d
-#define ISCSI_OP_VENDOR3_CMD		0x1e
-#define ISCSI_OP_VENDOR4_CMD		0x1f
-
-/* Server to Client Message Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_RSP		0x21
-#define ISCSI_OP_SCSI_TASK_MGT_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_IN		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T			0x31
-#define ISCSI_OP_ASYNC_MSG		0x32
-#define ISCSI_OP_REJECT			0x3f
-
-struct iscsi_ahs_hdr {
-	u16 ahslength;
-	u8 ahstype;
-} __packed;
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-union iscsi_sid {
-	struct {
-		u8 isid[6];		/* Initiator Session ID */
-		u16 tsih;		/* Target Session ID */
-	} id;
-	u64 id64;
-} __packed;
-
-struct iscsi_scsi_cmd_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 data_length;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u8  scb[16];
-} __packed;
-
-#define ISCSI_CMD_FINAL		0x80
-#define ISCSI_CMD_READ		0x40
-#define ISCSI_CMD_WRITE		0x20
-#define ISCSI_CMD_ATTR_MASK	0x07
-#define ISCSI_CMD_UNTAGGED	0x00
-#define ISCSI_CMD_SIMPLE	0x01
-#define ISCSI_CMD_ORDERED	0x02
-#define ISCSI_CMD_HEAD_OF_QUEUE	0x03
-#define ISCSI_CMD_ACA		0x04
-
-struct iscsi_cdb_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u8  cdb[0];
-} __packed;
-
-struct iscsi_rlength_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u32 read_length;
-} __packed;
-
-struct iscsi_scsi_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd1[2];
-	u32 itt;
-	u32 snack;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 exp_data_sn;
-	u32 bi_residual_count;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_RESIDUAL_UNDERFLOW		0x02
-#define ISCSI_FLG_RESIDUAL_OVERFLOW		0x04
-#define ISCSI_FLG_BIRESIDUAL_UNDERFLOW		0x08
-#define ISCSI_FLG_BIRESIDUAL_OVERFLOW		0x10
-
-#define ISCSI_RESPONSE_COMMAND_COMPLETED	0x00
-#define ISCSI_RESPONSE_TARGET_FAILURE		0x01
-
-struct iscsi_sense_data {
-	u16 length;
-	u8  data[0];
-} __packed;
-
-struct iscsi_task_mgt_hdr {
-	u8  opcode;
-	u8  function;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 rtt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 ref_cmd_sn;
-	u32 exp_data_sn;
-	u32 rsvd2[2];
-} __packed;
-
-#define ISCSI_FUNCTION_MASK			0x7f
-
-#define ISCSI_FUNCTION_ABORT_TASK		1
-#define ISCSI_FUNCTION_ABORT_TASK_SET		2
-#define ISCSI_FUNCTION_CLEAR_ACA		3
-#define ISCSI_FUNCTION_CLEAR_TASK_SET		4
-#define ISCSI_FUNCTION_LOGICAL_UNIT_RESET	5
-#define ISCSI_FUNCTION_TARGET_WARM_RESET	6
-#define ISCSI_FUNCTION_TARGET_COLD_RESET	7
-#define ISCSI_FUNCTION_TASK_REASSIGN		8
-
-struct iscsi_task_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4[3];
-} __packed;
-
-#define ISCSI_RESPONSE_FUNCTION_COMPLETE	0
-#define ISCSI_RESPONSE_UNKNOWN_TASK		1
-#define ISCSI_RESPONSE_UNKNOWN_LUN		2
-#define ISCSI_RESPONSE_TASK_ALLEGIANT		3
-#define ISCSI_RESPONSE_FAILOVER_UNSUPPORTED	4
-#define ISCSI_RESPONSE_FUNCTION_UNSUPPORTED	5
-#define ISCSI_RESPONSE_NO_AUTHORIZATION		6
-#define ISCSI_RESPONSE_FUNCTION_REJECTED	255
-
-struct iscsi_data_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd2;
-	u32 exp_stat_sn;
-	u32 rsvd3;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 rsvd4;
-} __packed;
-
-struct iscsi_data_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  rsvd1;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_STATUS		0x01
-
-struct iscsi_r2t_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 r2t_sn;
-	u32 buffer_offset;
-	u32 data_length;
-} __packed;
-
-struct iscsi_async_msg_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 ffffffff;
-	u32 rsvd2;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  async_event;
-	u8  async_vcode;
-	u16 param1;
-	u16 param2;
-	u16 param3;
-	u32 rsvd3;
-} __packed;
-
-#define ISCSI_ASYNC_SCSI		0
-#define ISCSI_ASYNC_LOGOUT		1
-#define ISCSI_ASYNC_DROP_CONNECTION	2
-#define ISCSI_ASYNC_DROP_SESSION	3
-#define ISCSI_ASYNC_PARAM_REQUEST	4
-#define ISCSI_ASYNC_VENDOR		255
-
-struct iscsi_text_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd3[4];
-} __packed;
-
-struct iscsi_text_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd3[3];
-} __packed;
-
-struct iscsi_login_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  min_version;		/* Min. version supported */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u16 cid;			/* Connection ID */
-	u16 rsvd1;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_login_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  active_version;		/* Active version */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u32 rsvd1;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  status_class;		/* see Login RSP ststus classes below */
-	u8  status_detail;		/* see Login RSP Status details below */
-	u8  rsvd2[10];
-} __packed;
-
-#define ISCSI_FLG_FINAL			0x80
-#define ISCSI_FLG_TRANSIT		0x80
-#define ISCSI_FLG_CSG_SECURITY		0x00
-#define ISCSI_FLG_CSG_LOGIN		0x04
-#define ISCSI_FLG_CSG_FULL_FEATURE	0x0c
-#define ISCSI_FLG_CSG_MASK		0x0c
-#define ISCSI_FLG_NSG_SECURITY		0x00
-#define ISCSI_FLG_NSG_LOGIN		0x01
-#define ISCSI_FLG_NSG_FULL_FEATURE	0x03
-#define ISCSI_FLG_NSG_MASK		0x03
-
-/* Login Status response classes */
-#define ISCSI_STATUS_SUCCESS		0x00
-#define ISCSI_STATUS_REDIRECT		0x01
-#define ISCSI_STATUS_INITIATOR_ERR	0x02
-#define ISCSI_STATUS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_STATUS_INIT_ERR		0x00
-#define ISCSI_STATUS_AUTH_FAILED	0x01
-#define ISCSI_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_STATUS_TGT_REMOVED	0x04
-#define ISCSI_STATUS_NO_VERSION		0x05
-#define ISCSI_STATUS_TOO_MANY_CONN	0x06
-#define ISCSI_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_STATUS_INV_SESSION_TYPE	0x09
-#define ISCSI_STATUS_SESSION_NOT_FOUND	0x0a
-#define ISCSI_STATUS_INV_REQ_TYPE	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_STATUS_TARGET_ERROR	0x00
-#define ISCSI_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_STATUS_NO_RESOURCES	0x02
-
-struct iscsi_logout_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u16 cid;
-	u16 rsvd3;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd4[4];
-} __packed;
-
-struct iscsi_logout_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4;
-	u16 time2wait;
-	u16 time2retain;
-	u32 rsvd5;
-} __packed;
-
-struct iscsi_snack_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd3;
-	u32 exp_stat_sn;
-	u32 rsvd4[2];
-	u32 beg_run;
-	u32 run_length;
-} __packed;
-
-struct iscsi_reject_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  reason;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 ffffffff;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 rsvd4[2];
-} __packed;
-
-#define ISCSI_REASON_NO_FULL_FEATURE_PHASE	0x01
-#define ISCSI_REASON_DATA_DIGEST_ERROR		0x02
-#define ISCSI_REASON_DATA_SNACK_REJECT		0x03
-#define ISCSI_REASON_PROTOCOL_ERROR		0x04
-#define ISCSI_REASON_UNSUPPORTED_COMMAND	0x05
-#define ISCSI_REASON_IMMEDIATE_COMMAND_REJECT	0x06
-#define ISCSI_REASON_TASK_IN_PROGRESS		0x07
-#define ISCSI_REASON_INVALID_SNACK		0x08
-#define ISCSI_REASON_NO_BOOKMARK		0x09
-#define ISCSI_REASON_BOOKMARK_REJECT		0x0a
-#define ISCSI_REASON_NEGOTIATION_RESET		0x0b
-#define ISCSI_REASON_WAITING_LOGOUT		0x0c
-
-
-struct iscsi_nop_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_nop_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd2[3];
-} __packed;
-
-#define ISCSI_RESERVED_TAG	(0xffffffffU)
-
-#endif	/* __ISCSI_HDR_H__ */

Added: trunk/iscsi/kernel/iscsi_proto.h
===================================================================
--- trunk/iscsi/kernel/iscsi_proto.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi_proto.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -0,0 +1,587 @@
+/*
+ * RFC 3720 (iSCSI) protocol data types
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_PROTO_H
+#define ISCSI_PROTO_H
+
+#define ISCSI_VERSION_STR	&quot;0.3&quot;
+#define ISCSI_DATE_STR		&quot;22-Apr-2005&quot;
+#define ISCSI_DRAFT20_VERSION	0x00
+
+/* default iSCSI listen port for incoming connections */
+#define ISCSI_LISTEN_PORT	3260
+
+/* Padding word length */
+#define PAD_WORD_LEN		4
+
+/*
+ * useful common(control and data pathes) macro
+ */
+#define ntoh24(p) (((p)[0] &lt;&lt; 16) | ((p)[1] &lt;&lt; 8) | ((p)[2]))
+#define hton24(p, v) { \
+        p[0] = (((v) &gt;&gt; 16) &amp; 0xFF); \
+        p[1] = (((v) &gt;&gt; 8) &amp; 0xFF); \
+        p[2] = ((v) &amp; 0xFF); \
+}
+#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
+
+/*
+ * iSCSI Template Message Header
+ */
+struct iscsi_hdr {
+	uint8_t		opcode;
+	uint8_t		flags;		/* Final bit */
+	uint8_t		rsvd2[2];
+	uint8_t		hlength;	/* AHSs total length */
+	uint8_t		dlength[3];	/* Data length */
+	uint8_t		lun[8];
+	__be32		itt;		/* Initiator Task Tag */
+	__be32		ttt;		/* Target Task Tag */
+	__be32		statsn;
+	__be32		exp_statsn;
+	__be32		max_statsn;
+	uint8_t		other[12];
+};
+
+/************************* RFC 3720 Begin *****************************/
+
+#define ISCSI_RESERVED_TAG		0xffffffff
+
+/* Opcode encoding bits */
+#define ISCSI_OP_RETRY			0x80
+#define ISCSI_OP_IMMEDIATE		0x40
+#define ISCSI_OPCODE_MASK		0x3F
+
+/* Initiator Opcode values */
+#define ISCSI_OP_NOOP_OUT		0x00
+#define ISCSI_OP_SCSI_CMD		0x01
+#define ISCSI_OP_SCSI_TMFUNC		0x02
+#define ISCSI_OP_LOGIN			0x03
+#define ISCSI_OP_TEXT			0x04
+#define ISCSI_OP_SCSI_DATA_OUT		0x05
+#define ISCSI_OP_LOGOUT			0x06
+#define ISCSI_OP_SNACK			0x10
+
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
+/* Target Opcode values */
+#define ISCSI_OP_NOOP_IN		0x20
+#define ISCSI_OP_SCSI_CMD_RSP		0x21
+#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
+#define ISCSI_OP_LOGIN_RSP		0x23
+#define ISCSI_OP_TEXT_RSP		0x24
+#define ISCSI_OP_SCSI_DATA_IN		0x25
+#define ISCSI_OP_LOGOUT_RSP		0x26
+#define ISCSI_OP_R2T			0x31
+#define ISCSI_OP_ASYNC_EVENT		0x32
+#define ISCSI_OP_REJECT			0x3f
+
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
+/* iSCSI PDU Header */
+struct iscsi_cmd {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16 rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32 itt;	/* Initiator Task Tag */
+	__be32 data_length;
+	__be32 cmdsn;
+	__be32 exp_statsn;
+	uint8_t cdb[16];	/* SCSI Command Block */
+	/* Additional Data (Command Dependent) */
+};
+
+/* Command PDU flags */
+#define ISCSI_FLAG_CMD_FINAL		0x80
+#define ISCSI_FLAG_CMD_READ		0x40
+#define ISCSI_FLAG_CMD_WRITE		0x20
+#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
+
+/* SCSI Command Attribute values */
+#define ISCSI_ATTR_UNTAGGED		0
+#define ISCSI_ATTR_SIMPLE		1
+#define ISCSI_ATTR_ORDERED		2
+#define ISCSI_ATTR_HEAD_OF_QUEUE	3
+#define ISCSI_ATTR_ACA			4
+
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
+/* SCSI Response Header */
+struct iscsi_cmd_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd1;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	exp_datasn;
+	__be32	bi_residual_count;
+	__be32	residual_count;
+	/* Response or Sense Data (optional) */
+};
+
+/* Command Response PDU flags */
+#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
+#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
+#define ISCSI_FLAG_CMD_OVERFLOW		0x04
+#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
+
+/* iSCSI Status values. Valid if Rsp Selector bit is not set */
+#define ISCSI_STATUS_CMD_COMPLETED	0
+#define ISCSI_STATUS_TARGET_FAILURE	1
+#define ISCSI_STATUS_SUBSYS_FAILURE	2
+
+/* Asynchronous Event Header */
+struct iscsi_async {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	uint8_t rsvd4[8];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t async_event;
+	uint8_t async_vcode;
+	__be16	param1;
+	__be16	param2;
+	__be16	param3;
+	uint8_t rsvd5[4];
+};
+
+/* iSCSI Event Codes */
+#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
+#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
+#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
+#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
+#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
+#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
+
+/* NOP-Out Message */
+struct iscsi_nopout {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* NOP-In Message */
+struct iscsi_nopin {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd4[12];
+};
+
+/* SCSI Task Management Message Header */
+struct iscsi_tm {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	__be32	refcmdsn;
+	__be32	exp_datasn;
+	uint8_t rsvd2[8];
+};
+
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
+
+/* Function values */
+#define ISCSI_TM_FUNC_ABORT_TASK		1
+#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
+#define ISCSI_TM_FUNC_CLEAR_ACA			3
+#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
+#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
+#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
+#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
+#define ISCSI_TM_FUNC_TASK_REASSIGN		8
+
+/* SCSI Task Management Response Header */
+struct iscsi_tm_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Response values below */
+	uint8_t qualifier;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd3[12];
+};
+
+/* Response values */
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
+
+/* Ready To Transfer Header */
+struct iscsi_r2t_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t	hlength;
+	uint8_t	dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	r2tsn;
+	__be32	data_offset;
+	__be32	data_length;
+};
+
+/* SCSI Data Hdr */
+struct iscsi_data {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	rsvd4;
+	__be32	exp_statsn;
+	__be32	rsvd5;
+	__be32	datasn;
+	__be32	offset;
+	__be32	rsvd6;
+	/* Payload */
+};
+
+/* SCSI Data Response Hdr */
+struct iscsi_data_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	__be32	offset;
+	__be32	residual_count;
+};
+
+/* Data Response PDU flags */
+#define ISCSI_FLAG_DATA_ACK		0x40
+#define ISCSI_FLAG_DATA_OVERFLOW	0x04
+#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
+#define ISCSI_FLAG_DATA_STATUS		0x01
+
+/* Text Header */
+struct iscsi_text {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+	/* Text - key=value pairs */
+};
+
+#define ISCSI_FLAG_TEXT_CONTINUE	0x40
+
+/* Text Response Header */
+struct iscsi_text_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd5[12];
+	/* Text Response - key:value pairs */
+};
+
+/* Login Header */
+struct iscsi_login {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t min_version;	/* Min. version supported */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	__be16	rsvd3;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+};
+
+/* Login PDU flags */
+#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
+#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
+#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
+#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
+
+#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
+	((flags &amp; ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) &gt;&gt; 2)
+#define ISCSI_LOGIN_NEXT_STAGE(flags) \
+	(flags &amp; ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
+
+/* Login Response Header */
+struct iscsi_login_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t active_version;	/* Active version */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd3;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t status_class;	/* see Login RSP ststus classes below */
+	uint8_t status_detail;	/* see Login RSP Status details below */
+	uint8_t rsvd4[10];
+};
+
+/* Login stage (phase) codes for CSG, NSG */
+#define ISCSI_INITIAL_LOGIN_STAGE		-1
+#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
+#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
+#define ISCSI_FULL_FEATURE_PHASE		3
+
+/* Login Status response classes */
+#define ISCSI_STATUS_CLS_SUCCESS		0x00
+#define ISCSI_STATUS_CLS_REDIRECT		0x01
+#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
+#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
+
+/* Login Status response detail codes */
+/* Class-0 (Success) */
+#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
+
+/* Class-1 (Redirection) */
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
+
+/* Class-2 (Initiator Error) */
+#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
+#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
+#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
+#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
+#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
+#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
+#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
+#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
+#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
+#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
+#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
+#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
+
+/* Class-3 (Target Error) */
+#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
+#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
+#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
+
+/* Logout Header */
+struct iscsi_logout {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	uint8_t rsvd3[2];
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* Logout PDU flags */
+#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
+
+/* logout reason_code values */
+
+#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
+#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
+#define ISCSI_LOGOUT_REASON_RECOVERY		2
+#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
+
+/* Logout Response Header */
+struct iscsi_logout_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Logout response values below */
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd4;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	rsvd5;
+	__be16	t2wait;
+	__be16	t2retain;
+	__be32	rsvd6;
+};
+
+/* logout response status values */
+
+#define ISCSI_LOGOUT_SUCCESS			0
+#define ISCSI_LOGOUT_CID_NOT_FOUND		1
+#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
+#define ISCSI_LOGOUT_CLEANUP_FAILED		3
+
+/* SNACK Header */
+struct iscsi_snack {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[14];
+	__be32	itt;
+	__be32	begrun;
+	__be32	runlength;
+	__be32	exp_statsn;
+	__be32	rsvd3;
+	__be32	exp_datasn;
+	uint8_t rsvd6[8];
+};
+
+/* SNACK PDU flags */
+#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
+
+/* Reject Message Header */
+struct iscsi_reject {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t reason;
+	uint8_t rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t rsvd4[16];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	uint8_t rsvd5[8];
+	/* Text - Rejected hdr */
+};
+
+/* Reason for Reject */
+#define CMD_BEFORE_LOGIN	1
+#define DATA_DIGEST_ERROR	2
+#define DATA_SNACK_REJECT	3
+#define ISCSI_PROTOCOL_ERROR	4
+#define CMD_NOT_SUPPORTED	5
+#define IMM_CMD_REJECT		6
+#define TASK_IN_PROGRESS	7
+#define INVALID_SNACK		8
+#define BOOKMARK_REJECTED	9
+#define BOOKMARK_NO_RESOURCES	10
+#define NEGOTIATION_RESET	11
+
+/* Max. number of Key=Value pairs in a text message */
+#define MAX_KEY_VALUE_PAIRS	8192
+
+/* maximum length for text keys/values */
+#define KEY_MAXLEN		64
+#define VALUE_MAXLEN		255
+#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
+
+#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
+
+/************************* RFC 3720 End *****************************/
+
+#endif /* ISCSI_PROTO_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000000.html">[Stgt-svn] r5 - trunk/usr
</A></li>
	<LI>Next message: <A HREF="000002.html">[Stgt-svn] r7 - trunk/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
