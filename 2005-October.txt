From tomo at berlios.de  Sat Oct  1 10:17:54 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 1 Oct 2005 10:17:54 +0200
Subject: [Stgt-svn] r110 - trunk/kernel
Message-ID: <200510010817.j918Hsfb018390@sheep.berlios.de>

Author: tomo
Date: 2005-10-01 10:17:53 +0200 (Sat, 01 Oct 2005)
New Revision: 110

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_target.h
Log:
Mike changed the tgt APIs to make it handle hardware targets better.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt.c	2005-10-01 08:17:53 UTC (rev 110)
@@ -501,6 +501,56 @@
 	return -EINVAL;
 }
 
+void tgt_transfer_response(void *data)
+{
+	struct tgt_cmd *cmd = data;
+	struct tgt_target *target = cmd->session->target;
+	int err;
+
+	cmd->done = tgt_cmd_destroy;
+	err = target->tt->transfer_response(cmd);
+	switch (err) {
+	case TGT_CMD_XMIT_FAILED:
+	case TGT_CMD_XMIT_REQUEUE:
+		/*
+		 * TODO add a real queue to avoid re-orders and starvation
+		 * for now just reschedule.
+		 */
+		INIT_WORK(&cmd->work, tgt_transfer_response, cmd);
+		queue_delayed_work(cmd->session->target->twq, &cmd->work,
+				   10 * HZ);
+		break;
+	};
+}
+EXPORT_SYMBOL_GPL(tgt_transfer_response);
+
+static void queuecommand(void *data)
+{
+	int err = 0;
+	struct tgt_cmd *cmd = data;
+	struct tgt_target *target = cmd->session->target;
+	struct tgt_device *device = cmd->device;
+
+	dprintk("cid %llu\n", cmd->cid);
+
+	/* Should we do this earlier? */
+	if (!device)
+		cmd->device = device = tgt_device_find(target, cmd->dev_id);
+	if (device)
+		dprintk("found %llu\n", cmd->dev_id);
+
+	err = device->dt->queue_cmd(cmd);
+
+	switch (err) {
+	case TGT_CMD_FAILED:
+	case TGT_CMD_COMPLETED:
+		dprintk("command completed %d\n", err);
+		tgt_transfer_response(cmd);
+	default:
+		dprintk("command %llu queued\n", cmd->cid);
+	};
+}
+
 static int tgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct tgt_device *device;
@@ -581,6 +631,34 @@
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_destroy);
 
+static int __tgt_cmd_queue(struct tgt_cmd *cmd)
+{
+	struct tgt_session *session = cmd->session;
+
+	/*
+	 * we may need to code so that other layers can override this
+	 * done function
+	 */
+	cmd->done = tgt_cmd_destroy;
+	INIT_WORK(&cmd->work, queuecommand, cmd);
+	queue_work(session->target->twq, &cmd->work);
+	return 0;
+}
+
+static void tgt_write_data_transfer_done(struct tgt_cmd *cmd)
+{
+	/*
+	 * TODO check for errors and add state checking. we may have
+	 * to internally queue for the target driver
+	 */
+
+	/*
+	 * we are normally called from a irq so since the tgt_vsd blocks
+	 * we must queue this cmd
+	 */
+	__tgt_cmd_queue(cmd);
+}
+
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
 /*
@@ -621,30 +699,42 @@
 
 	__tgt_alloc_buffer(cmd);
 
-	if (cmd->done) {
-		void (*done)(struct tgt_cmd *) = cmd->done;
-		cmd->done = NULL;
-		done(cmd);
-	}
+	/*
+	 * we probably will not be able to rely on the target
+	 * driver knowing the data_dir so this may have to move
+	 * the devices or protocol if it becomes command specific
+	 */
+	if (cmd->data_dir == DMA_TO_DEVICE) {
+		cmd->done = tgt_write_data_transfer_done;
+		/*
+		 * TODO handle errors and possibly requeue for the
+		 * target driver
+		 */
+		cmd->session->target->tt->transfer_write_data(cmd);
+	} else
+		queuecommand(cmd);
 }
 
-void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
+void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd)
 {
+	struct tgt_session *session = cmd->session;
 	BUG_ON(!list_empty(&cmd->clist));
 
-	if (done) {
-		struct tgt_session *session = cmd->session;
-
-		INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
-		cmd->done = done;
-		queue_work(session->target->twq, &cmd->work);
-		return;
-	}
-
-	tgt_alloc_buffer(cmd);
+	INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
+	queue_work(session->target->twq, &cmd->work);
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_alloc_buffer);
 
+int tgt_cmd_queue(struct tgt_cmd *cmd)
+{
+	if (cmd->bufflen)
+		tgt_cmd_alloc_buffer(cmd);
+	else
+		__tgt_cmd_queue(cmd);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_cmd_queue);
+
 int tgt_uspace_cmd_send(struct tgt_cmd *cmd)
 {
 	struct tgt_protocol *proto = cmd->session->target->proto;
@@ -676,43 +766,12 @@
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
-/*
- * TODO we should make cmd->done a target callback instead. Maybe
- * target->tt->queuecommand. We need this becuase a target driver
- * may not have the resources to execute the command. We also need
- * a real queue, I guess, and some queue limits.
- *
- * NOTE THIS WILL NOT EXECUTE FROM A THREAD FOR LONG. IT APPEARS
- * TO BE HORRIBLE FOR PERF AND ONLY NEEDED BECAUSE OF IET. THE LLD SHOULD
- * BE ABLE TO EXECUTE FROM A SOFTIRQ SINCE WE WILL EVENTUALLY GO ALL ASYNC
- *
- */
-static void tgt_notify_cmd_ready(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	void (*done)(struct tgt_cmd *);
-
-	done = cmd->done;
-	cmd->done = NULL;
-	done(cmd);
-}
-
-void tgt_cmd_done(struct tgt_cmd *cmd)
-{
-	struct tgt_session *session = cmd->session;
-
-	INIT_WORK(&cmd->work, tgt_notify_cmd_ready, cmd);
-	queue_work(session->target->twq, &cmd->work);
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_done);
-
 static void uspace_cmd_done(struct tgt_cmd *cmd, void *data,
 			     int result, uint32_t len)
 {
 	struct tgt_device *device = cmd->device;
 	char *p = data;
 	int i;
-	BUG_ON(!cmd->done);
 
 	dprintk("cid %llu result %d len %d bufflen %u\n",
 		cmd->cid, result, len, cmd->bufflen);
@@ -744,51 +803,9 @@
 	cmd->result = result;
 	if (device->dt->complete_uspace_cmd)
 		device->dt->complete_uspace_cmd(cmd);
-	tgt_cmd_done(cmd);
+	tgt_transfer_response(cmd);
 }
 
-static void queuecommand(void *data)
-{
-	int err = 0;
-	struct tgt_cmd *cmd = data;
-	struct tgt_target *target = cmd->session->target;
-	struct tgt_device *device = cmd->device;
-
-	dprintk("cid %llu\n", cmd->cid);
-
-	/* Should we do this earlier? */
-	if (!device)
-		cmd->device = device = tgt_device_find(target, cmd->dev_id);
-	if (device)
-		dprintk("found %llu\n", cmd->dev_id);
-
-	err = device->dt->queue_cmd(cmd);
-
-	switch (err) {
-	case TGT_CMD_FAILED:
-	case TGT_CMD_COMPLETED:
-		dprintk("command completed %d\n", err);
-		tgt_notify_cmd_ready(cmd);
-	default:
-		dprintk("command %llu queued\n", cmd->cid);
-	};
-}
-
-int tgt_cmd_queue(struct tgt_cmd *cmd, void (*done)(struct tgt_cmd *))
-{
-	struct tgt_session *session = cmd->session;
-
-	BUG_ON(cmd->done);
-	BUG_ON(!done);
-
-	cmd->done = done;
-	INIT_WORK(&cmd->work, queuecommand, cmd);
-	queue_work(session->target->twq, &cmd->work);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_queue);
-
 static struct tgt_cmd *find_cmd_by_id(uint64_t cid)
 {
 	struct list_head *head;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt.h	2005-10-01 08:17:53 UTC (rev 110)
@@ -22,6 +22,14 @@
 	mempool_t *cmd_pool;
 };
 
+enum {
+	TGT_CMD_CREATE,
+	TGT_CMD_RECV,
+	TGT_CMD_QUEUED,
+	TGT_CMD_XMIT,
+	TGT_CMD_DONE,
+};
+
 struct tgt_cmd {
 	struct tgt_session *session;
 	struct tgt_device *device;
@@ -66,11 +74,8 @@
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
 extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *priv);
 extern void tgt_cmd_destroy(struct tgt_cmd *cmd);
-extern void tgt_cmd_alloc_buffer(struct tgt_cmd *cmd,
-				  void (*done)(struct tgt_cmd *));
-extern int tgt_cmd_queue(struct tgt_cmd *cmd,
-			  void (*done)(struct tgt_cmd *));
-extern void tgt_cmd_done(struct tgt_cmd *cmd);
+extern int tgt_cmd_queue(struct tgt_cmd *cmd);
+extern void tgt_transfer_response(void *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 #endif

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt_protocol.h	2005-10-01 08:17:53 UTC (rev 110)
@@ -28,34 +28,21 @@
 	int uspace_pdu_size;
 
 	/*
-	 * create a command and allocate a buffer of size data_len for
+	 * Create a command and allocate a buffer of size data_len for
 	 * for transfer. The buffer will be allocated with GFP_KERNEL
-	 * so if you cannot sleep the caller must pass in a done() function.
-	 * The done function will be called from process context.
-	 *
-	 * TODO: This dual behavior is a little strange. We will convert
-	 * iet to open-iscsi's model so eventually the done() function
-	 * will be a requirement so we can have a common path.
+	 * and preprocesed by tgt/scsi_proto so the next time
+	 * the target driver is notified about the cmd is when
+	 * the transfer* is called.
 	 */
 	struct tgt_cmd *(* create_cmd)(struct tgt_session *session,
-					void *tgt_priv, uint8_t *cmd,
-					uint32_t data_len,
-					enum dma_data_direction data_dir,
-					uint8_t *dev_id_buff, int id_buff_size,
-					void (*done)(struct tgt_cmd *));
+				       void *tgt_priv, uint8_t *cmd,
+				       uint32_t data_len,
+				       enum dma_data_direction data_dir,
+				       uint8_t *dev_id_buff, int id_buff_size,
+				       int flags);
 	/*
-	 * destroy a command. This will free the command and buffer
+	 * Build userspace packet
 	 */
-	void (* destroy_cmd)(struct tgt_cmd *cmd); 
-	/*
-	 * queue a command to be executed in a workqueue. A done() callback
-	 * must be passed in.
-	 */
-	int (* queue_cmd)(struct tgt_cmd *cmd,
-			   void (*done)(struct tgt_cmd *));
-	/*
-	 * build userspace packet
-	 */
 	void (* build_uspace_pdu)(struct tgt_cmd *cmd, void *data);
 };
 

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt_scsi.c	2005-10-01 08:17:53 UTC (rev 110)
@@ -49,8 +49,7 @@
 static struct tgt_cmd *
 scsi_tgt_create_cmd(struct tgt_session *session, void *tgt_priv, uint8_t *scb,
 		    uint32_t data_len, enum dma_data_direction data_dir,
-		    uint8_t *lun, int lun_size,
-		    void (*done)(struct tgt_cmd *))
+		    uint8_t *lun, int lun_size, int tags)
 {
 	struct tgt_device *device;
 	struct tgt_cmd *cmd;
@@ -63,6 +62,7 @@
 	}
 	scmd = tgt_cmd_to_scsi(cmd);
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
+	scmd->tags = tags;
 
 	/* translate target driver LUN to device id */
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
@@ -83,8 +83,9 @@
 	cmd->bufflen = data_len;
 	/* do scsi device specific setup */
 	device->dt->prep_cmd(cmd, data_len);
-	if (cmd->bufflen)
-		tgt_cmd_alloc_buffer(cmd, done);
+
+	tgt_cmd_queue(cmd);
+
 	return cmd;
 }
 
@@ -138,8 +139,6 @@
 	.name = "scsi",
 	.module = THIS_MODULE,
 	.create_cmd = scsi_tgt_create_cmd,
-	.destroy_cmd = tgt_cmd_destroy,
-	.queue_cmd = tgt_cmd_queue,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt_sd.c	2005-10-01 08:17:53 UTC (rev 110)
@@ -96,8 +96,7 @@
 	} else
 		cmd->result = SAM_STAT_GOOD;
 
-
-	tgt_cmd_done(cmd);
+	tgt_transfer_response(cmd);
 	__blk_put_request(rq->q, rq);
 }
 

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-09-27 03:49:05 UTC (rev 109)
+++ trunk/kernel/tgt_target.h	2005-10-01 08:17:53 UTC (rev 110)
@@ -13,16 +13,51 @@
 
 struct tgt_protocol;
 struct tgt_target;
+struct tgt_cmd;
 
+enum {
+	TGT_CMD_XMIT_OK,
+	TGT_CMD_XMIT_FAILED,
+	TGT_CMD_XMIT_REQUEUE,
+};
+
 struct tgt_target_template {
 	const char *name;
 	struct module *module;
 	unsigned priv_data_size;
 
+	/*
+	 * Target creation/destroy callbacks useful when userspace
+	 * initiates these operations
+	 */
 	int (* target_create) (struct tgt_target *);
 	void (* target_destroy) (struct tgt_target *);
+	/*
+	 * Called when userspace sends the target a driver specific
+	 * message. To send a response the target driver should call
+	 * tgt_msg_send.
+	 */
 	int (* msg_recv) (struct tgt_target *, uint32_t, void *);
 	/*
+	 * Transfer command response and/or data. If the target driver
+	 * cannot queue the request and would like it requeued then it
+	 * should return an appropriate TGT_CMD_XMIT_*. When the
+	 * the transfer is complete and the target driver is finished with
+	 * the command the cmd->done() callback must be called. After the
+	 * the cmd->done callback has been called tgt_core owns the cmd and
+	 * may free it.
+	 *
+	 * TODO rename this
+	 */
+	int (* transfer_response) (struct tgt_cmd *);
+	/*
+	 * Transfer write data to the sg buffer.
+	 *
+	 * TODO rename
+	 */
+	int (* transfer_write_data) (struct tgt_cmd *);
+
+	/*
 	 * name of protocol to use
 	 */
 	const char *protocol;



From tomo at berlios.de  Sat Oct  1 10:18:35 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 1 Oct 2005 10:18:35 +0200
Subject: [Stgt-svn] r111 - trunk/iscsi/kernel
Message-ID: <200510010818.j918IZD5018510@sheep.berlios.de>

Author: tomo
Date: 2005-10-01 10:18:34 +0200 (Sat, 01 Oct 2005)
New Revision: 111

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
Log:
Changed the iSCSI software target for the new APIs.

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-10-01 08:17:53 UTC (rev 110)
+++ trunk/iscsi/kernel/iscsi.c	2005-10-01 08:18:34 UTC (rev 111)
@@ -73,6 +73,7 @@
 	cmnd->conn = conn;
 	spin_lock(&conn->list_lock);
 	atomic_inc(&conn->nr_cmnds);
+	init_completion(&cmnd->event);
 	if (req)
 		list_add_tail(&cmnd->conn_list, &conn->pdu_list);
 	spin_unlock(&conn->list_lock);
@@ -368,10 +369,8 @@
 	list_del(&cmnd->conn_list);
 	spin_unlock(&conn->list_lock);
 
-	if (cmnd->tc) {
-		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
-		proto->destroy_cmd(cmnd->tc);
-	}
+	if (cmnd->tc)
+		cmnd->tc->done(cmnd->tc);
 	kmem_cache_free(iscsi_cmnd_cache, cmnd);
 }
 
@@ -704,9 +703,10 @@
 	iscsi_cmnds_init_write(&send);
 }
 
-static void scsi_cmnd_done(struct tgt_cmd *tc)
+static void __scsi_cmnd_done(void *data)
 {
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+	struct tgt_cmd *tc = (struct tgt_cmd *) data;
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 	if (tc->result != SAM_STAT_GOOD) {
@@ -750,16 +750,70 @@
 	}
 }
 
+/* TODO : merge this with nthread. */
+static int scsi_cmnd_done(struct tgt_cmd *tc)
+{
+	int err;
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+
+	INIT_WORK(&cmnd->work, __scsi_cmnd_done, tc);
+	err = schedule_work(&cmnd->work);
+	BUG_ON(!err);
+
+	return TGT_CMD_XMIT_OK;
+}
+
+static void tgt_scsi_cmd_create(struct iscsi_cmnd *req)
+{
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_conn *conn = req->conn;
+	struct tgt_protocol *proto = conn->session->ts->target->proto;
+	enum dma_data_direction data_dir;
+
+	/*
+	 * handle bidi later
+	 */
+	if (req_hdr->flags & ISCSI_FLAG_CMD_WRITE)
+		data_dir = DMA_TO_DEVICE;
+	else if (req_hdr->flags & ISCSI_FLAG_CMD_READ)
+		data_dir = DMA_FROM_DEVICE;
+	else
+		data_dir = DMA_NONE;
+
+	req->tc = proto->create_cmd(conn->session->ts, req, req_hdr->cdb,
+				    be32_to_cpu(req_hdr->data_length),
+				    data_dir, req_hdr->lun,
+				    sizeof(req_hdr->lun),
+				    req->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK);
+	BUG_ON(!req->tc);
+
+	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {
+		switch (req_hdr->cdb[0]) {
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_16:
+		case WRITE_VERIFY:
+			break;
+		default:
+			eprintk("%x\n", req_hdr->cdb[0]);
+			break;
+		}
+	}
+}
+
 static void scsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
+	struct tgt_cmd *cmd = cmnd->tc;
+
 	if (cmnd->r2t_length) {
 		if (!cmnd->is_unsolicited_data)
 			send_r2t(cmnd);
 	} else {
-		struct tgt_protocol *proto = cmnd->tc->session->target->proto;
-
 		set_cmnd_waitio(cmnd);
-		proto->queue_cmd(cmnd->tc, scsi_cmnd_done);
+		if (cmnd->tc)
+			cmd->done(cmd);
+		else
+			tgt_scsi_cmd_create(cmnd);
 	}
 }
 
@@ -840,30 +894,10 @@
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
-	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
-	enum dma_data_direction data_dir;
 
 	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
 
-	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
-
-	/*
-	 * handle bidi later
-	 */
-	if (req_hdr->flags & ISCSI_FLAG_CMD_WRITE)
-		data_dir = DMA_TO_DEVICE;
-	else if (req_hdr->flags & ISCSI_FLAG_CMD_READ)
-		data_dir = DMA_FROM_DEVICE;
-	else
-		data_dir = DMA_NONE;
-
-	req->tc = proto->create_cmd(conn->session->ts, req, req_hdr->cdb,
-				    be32_to_cpu(req_hdr->data_length),
-				    data_dir, req_hdr->lun,
-				    sizeof(req_hdr->lun), NULL);
-	BUG_ON(!req->tc);
-
 	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
 		if ((req_hdr->cdb[1] & 0x1f) != 0x10)
@@ -883,16 +917,6 @@
 	case RELEASE:
 	case RESERVE_10:
 	case RELEASE_10:
-	{
-		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
-		      req->pdu.datasize) {
-			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
-			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
-			cmnd_skip_data(req);
-		}
-		break;
-	}
 	case READ_6:
 	case READ_10:
 	case READ_16:
@@ -904,7 +928,6 @@
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
-
 		break;
 	}
 	case WRITE_6:
@@ -914,6 +937,16 @@
 	{
 		struct iscsi_sess_param *param = &conn->session->param;
 
+		/*
+		 * We don't know this command arrives in order,
+		 * however we need to allocate buffer for immediate
+		 * and unsolicited data. tgt will not start to perform
+		 * this command until we call cmd->done so we don't
+		 * need to worry about the order of the command.
+		 */
+		tgt_scsi_cmd_create(req);
+		wait_for_completion(&req->event);
+
 		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
 		req->is_unsolicited_data = !(req_hdr->flags &
 						ISCSI_FLAG_CMD_FINAL);
@@ -1580,6 +1613,15 @@
 	}
 }
 
+static int buffer_ready(struct tgt_cmd *tc)
+{
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
+
+	complete(&cmnd->event);
+
+	return 0;
+}
+
 static struct tgt_target_template iet_tgt_target_template = {
 	.name = "iet",
 	.module = THIS_MODULE,
@@ -1587,6 +1629,8 @@
 	.target_create = target_add,
 	.target_destroy = target_del,
 	.msg_recv = iet_msg_recv,
+	.transfer_response = scsi_cmnd_done,
+	.transfer_write_data = buffer_ready,
 	.priv_data_size = sizeof(struct iscsi_target),
 };
 

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-10-01 08:17:53 UTC (rev 110)
+++ trunk/iscsi/kernel/iscsi.h	2005-10-01 08:18:34 UTC (rev 111)
@@ -180,6 +180,9 @@
 	u32 hdigest;
 	u32 ddigest;
 
+	struct work_struct work;
+	struct completion event;
+
 	struct iscsi_cmnd *req;
 	struct tgt_cmd *tc;
 };



From tomo at berlios.de  Sat Oct  1 10:41:49 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 1 Oct 2005 10:41:49 +0200
Subject: [Stgt-svn] r112 - in trunk: . usr
Message-ID: <200510010841.j918fn1m023322@sheep.berlios.de>

Author: tomo
Date: 2005-10-01 10:41:46 +0200 (Sat, 01 Oct 2005)
New Revision: 112

Added:
   trunk/istgt/
Removed:
   trunk/iscsi/
Modified:
   trunk/Makefile
   trunk/initd
   trunk/usr/tgtd.c
Log:
iscsi directory is renamed istgt.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-10-01 08:18:34 UTC (rev 111)
+++ trunk/Makefile	2005-10-01 08:41:46 UTC (rev 112)
@@ -7,7 +7,7 @@
 export KERNELSRC
 
 all:
-	make -C iscsi
+	make -C istgt
 
 	make -C usr
 	make -C kernel
@@ -15,4 +15,4 @@
 	make -C usr clean
 	make -C kernel clean
 
-	make -C iscsi clean
+	make -C istgt clean

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-10-01 08:18:34 UTC (rev 111)
+++ trunk/initd	2005-10-01 08:41:46 UTC (rev 112)
@@ -14,7 +14,7 @@
 #	insmod ${PWD}/kernel/tgt_sd.ko
 
 	modprobe -q crc32c
-	insmod ${PWD}/iscsi/kernel/iscsi_trgt.ko
+	insmod ${PWD}/istgt/kernel/iscsi_trgt.ko
 
 	${PWD}/usr/tgtd
 }

Copied: trunk/istgt (from rev 111, trunk/iscsi)

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-10-01 08:18:34 UTC (rev 111)
+++ trunk/usr/tgtd.c	2005-10-01 08:41:46 UTC (rev 112)
@@ -72,7 +72,7 @@
 	char path[PATH_MAX];
 
 	getcwd(path, sizeof(path));
-	strcat(path, "/iscsi/usr/istgt.so");
+	strcat(path, "/istgt/usr/istgt.so");
 
 	dl_handles[0] = dlopen(path, RTLD_LAZY);
 	if (!dl_handles[0]) {



From tomo at berlios.de  Sat Oct  1 10:56:03 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 1 Oct 2005 10:56:03 +0200
Subject: [Stgt-svn] r113 - trunk/istgt/usr
Message-ID: <200510010856.j918u3no024806@sheep.berlios.de>

Author: tomo
Date: 2005-10-01 10:56:02 +0200 (Sat, 01 Oct 2005)
New Revision: 113

Modified:
   trunk/istgt/usr/ctldev.c
Log:
Fix compile warnings for 64-bit archs.

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-10-01 08:41:46 UTC (rev 112)
+++ trunk/istgt/usr/ctldev.c	2005-10-01 08:56:02 UTC (rev 113)
@@ -199,7 +199,7 @@
 
 	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 	if (err)
-		fprintf(stderr, "%d %d %u %llu %d %u\n",
+		fprintf(stderr, "%d %d %u %" PRIx64 "%d %u\n",
 			err, errno, tid, sid, type, partial);
 	free(nlh);
 	return err;
@@ -637,7 +637,7 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %llu %llu %s\n", nlh->nlmsg_len,
+	eprintf("%d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
 		req->set, req->op, req->tid, req->sid, req->lun, params);
 
 	if (req->set & SET_USER)



From tomo at berlios.de  Sat Oct  1 11:02:09 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 1 Oct 2005 11:02:09 +0200
Subject: [Stgt-svn] r114 - trunk/kernel
Message-ID: <200510010902.j91929hP026331@sheep.berlios.de>

Author: tomo
Date: 2005-10-01 11:02:09 +0200 (Sat, 01 Oct 2005)
New Revision: 114

Modified:
   trunk/kernel/tgt_scsi.c
Log:
Trivial cleanups.

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-10-01 08:56:02 UTC (rev 113)
+++ trunk/kernel/tgt_scsi.c	2005-10-01 09:02:09 UTC (rev 114)
@@ -5,7 +5,6 @@
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
-#include <linux/fs.h>
 #include <linux/module.h>
 #include <linux/mm.h>
 #include <linux/highmem.h>
@@ -119,7 +118,7 @@
 	int len;
 
 	memset(data, 0, sizeof(scmd->sense_buff));
-	len = min(cmd->bufflen, sizeof(scmd->sense_buff));
+	len = min_t(int, cmd->bufflen, sizeof(scmd->sense_buff));
 
 	/* userspace did everything for us */
 	memcpy(data, page_address(cmd->sg[0].page), len);



From tomo at berlios.de  Sun Oct  2 01:01:36 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 2 Oct 2005 01:01:36 +0200
Subject: [Stgt-svn] r115 - in trunk: . istgt/include istgt/kernel istgt/usr usr
Message-ID: <200510012301.j91N1aqF028361@sheep.berlios.de>

Author: tomo
Date: 2005-10-02 01:01:32 +0200 (Sun, 02 Oct 2005)
New Revision: 115

Modified:
   trunk/initd
   trunk/istgt/include/iet_u.h
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/usr/ctldev.c
   trunk/usr/scsi.c
   trunk/usr/tgtd.c
Log:
Trivial cleanup.

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/initd	2005-10-01 23:01:32 UTC (rev 115)
@@ -5,6 +5,7 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 MEM_SIZE=1048576
+export LD_LIBRARY_PATH=${PWD}/istgt/usr:${LD_LIBRARY_PATH}
 
 start_server()
 {

Modified: trunk/istgt/include/iet_u.h
===================================================================
--- trunk/istgt/include/iet_u.h	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/istgt/include/iet_u.h	2005-10-01 23:01:32 UTC (rev 115)
@@ -1,11 +1,11 @@
 #ifndef _IET_U_H
 #define _IET_U_H
 
-#define IET_VERSION_STRING	"0.4.12"
+#define VERSION_STRING	"0.4.12"
+#define	THIS_NAME		"istgt"
 
 /* The maximum length of 223 bytes in the RFC. */
 #define ISCSI_NAME_LEN	256
-#define ISCSI_ARGS_LEN	2048
 
 #define VENDOR_ID_LEN	8
 #define SCSI_ID_LEN	24

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/istgt/kernel/iscsi.c	2005-10-01 23:01:32 UTC (rev 115)
@@ -1340,10 +1340,7 @@
 			iscsi_cmnd_remove(rsp);
 		}
 		list_del_init(&cmnd->list);
-	} else
-		if (cmnd_queued(cmnd))
-			;
-/* 			iscsi_scsi_dequeuecmnd(cmnd); */
+	}
 
 	if (cmnd_hashed(cmnd))
 		cmnd_remove_hash(cmnd);
@@ -1622,8 +1619,8 @@
 	return 0;
 }
 
-static struct tgt_target_template iet_tgt_target_template = {
-	.name = "iet",
+static struct tgt_target_template istgt_template = {
+	.name = THIS_NAME,
 	.module = THIS_MODULE,
 	.protocol = "scsi",
 	.target_create = target_add,
@@ -1639,21 +1636,22 @@
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
 
-	tgt_target_template_unregister(&iet_tgt_target_template);
+	tgt_target_template_unregister(&istgt_template);
 }
 
 static int iscsi_init(void)
 {
 	int err = -ENOMEM;
 
-	printk("iSCSI Enterprise Target Software - version %s\n", IET_VERSION_STRING);
+	printk("iSCSI Target Software for Linux Target Framework %s\n",
+	       VERSION_STRING);
 
 	iscsi_cmnd_cache = kmem_cache_create("iscsi_cmnd", sizeof(struct iscsi_cmnd),
 					     0, 0, NULL, NULL);
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-	err = tgt_target_template_register(&iet_tgt_target_template);
+	err = tgt_target_template_register(&istgt_template);
 	if (err < 0)
 		goto err;
 

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/istgt/kernel/iscsi.h	2005-10-01 23:01:32 UTC (rev 115)
@@ -255,7 +255,6 @@
 
 enum cmnd_flags {
 	CMND_hashed,
-	CMND_queued,
 	CMND_final,
 	CMND_waitio,
 	CMND_close,
@@ -266,9 +265,6 @@
 #define set_cmnd_hashed(cmnd)	set_bit(CMND_hashed, &(cmnd)->flags)
 #define cmnd_hashed(cmnd)	test_bit(CMND_hashed, &(cmnd)->flags)
 
-#define set_cmnd_queued(cmnd)	set_bit(CMND_queued, &(cmnd)->flags)
-#define cmnd_queued(cmnd)	test_bit(CMND_queued, &(cmnd)->flags)
-
 #define set_cmnd_final(cmnd)	set_bit(CMND_final, &(cmnd)->flags)
 #define cmnd_final(cmnd)	test_bit(CMND_final, &(cmnd)->flags)
 

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/istgt/usr/ctldev.c	2005-10-01 23:01:32 UTC (rev 115)
@@ -356,7 +356,7 @@
 		   NLMSG_SPACE(sizeof(*ev)), 0);
 
 	ev = NLMSG_DATA(nlh);
-	sprintf(ev->u.c_target.type, "%s", "iet");
+	sprintf(ev->u.c_target.type, "%s", THIS_NAME);
 	ev->u.c_target.nr_cmds = DEFAULT_NR_QUEUED_CMNDS;
 
 	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
@@ -608,7 +608,7 @@
 		if (err < 0)
 			continue;
 		eprintf("%s\n", buf);
-		if (!strncmp(buf, "iet", 3)) {
+		if (!strncmp(buf, THIS_NAME, strlen(THIS_NAME))) {
 			int tid;
 
 			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/usr/scsi.c	2005-10-01 23:01:32 UTC (rev 115)
@@ -426,11 +426,6 @@
 	fd = 0;
 	sscanf(buf, "%d\n", &fd);
 
-	/*
-	 * this will work when we merge the daemons (fd's are associated
-	 * with procssess so this will fail when ietd opens the fd and
-	 * this thread syncs it).
-	 */
 	err = fsync(fd);
 	if (err) {
 		log_error("scsi sync_cache fsync of fd %d failed err %d",

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-10-01 09:02:09 UTC (rev 114)
+++ trunk/usr/tgtd.c	2005-10-01 23:01:32 UTC (rev 115)
@@ -71,8 +71,7 @@
 {
 	char path[PATH_MAX];
 
-	getcwd(path, sizeof(path));
-	strcat(path, "/istgt/usr/istgt.so");
+	strcat(path, "istgt.so");
 
 	dl_handles[0] = dlopen(path, RTLD_LAZY);
 	if (!dl_handles[0]) {



From tomo at berlios.de  Tue Oct  4 07:08:15 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 4 Oct 2005 07:08:15 +0200
Subject: [Stgt-svn] r116 - in trunk: istgt/kernel kernel
Message-ID: <200510040508.j9458F7u022653@sheep.berlios.de>

Author: tomo
Date: 2005-10-04 07:08:03 +0200 (Tue, 04 Oct 2005)
New Revision: 116

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sysfs.c
Log:
Add task attributes support. queuecommand -> proto->queue_cmd ->
device->dt->queue_cmd. proto->queue_cmd does protocol specific task
attributes. struct tgt_device has protocol specific data. Can we call
task attributes support generic for all protocols? If so, we should
move some of data structures into struct tgt_device.


Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/istgt/kernel/iscsi.c	2005-10-04 05:08:03 UTC (rev 116)
@@ -8,6 +8,7 @@
 #include <linux/hash.h>
 #include <net/tcp.h>
 #include <scsi/scsi.h>
+#include <scsi/scsi_tcq.h>
 #include <linux/mempool.h>
 
 #include <tgt.h>
@@ -769,6 +770,7 @@
 	struct iscsi_conn *conn = req->conn;
 	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	enum dma_data_direction data_dir;
+	int tags = MSG_SIMPLE_TAG;;
 
 	/*
 	 * handle bidi later
@@ -780,11 +782,26 @@
 	else
 		data_dir = DMA_NONE;
 
+	switch (req->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		tags = MSG_SIMPLE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+		tags = MSG_ORDERED_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		tags = MSG_HEAD_TAG;
+		break;
+	case ISCSI_ATTR_ACA:
+		break;
+	}
+
 	req->tc = proto->create_cmd(conn->session->ts, req, req_hdr->cdb,
 				    be32_to_cpu(req_hdr->data_length),
 				    data_dir, req_hdr->lun,
 				    sizeof(req_hdr->lun),
-				    req->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK);
+				    tags);
 	BUG_ON(!req->tc);
 
 	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/kernel/tgt.c	2005-10-04 05:08:03 UTC (rev 116)
@@ -474,10 +474,18 @@
 	if (!device->dt_data)
 		goto put_template;
 
+	device->pt_data =
+		kzalloc(target->proto->priv_dev_data_size, GFP_KERNEL);
+	if (!device->pt_data)
+		goto free_priv_dt_data;
+
 	if (device->dt->create)
 		if (device->dt->create(device))
-			goto free_priv_dt_data;
+			goto free_priv_pt_data;
 
+	if (target->proto->attach_device)
+		target->proto->attach_device(device->pt_data);
+
 	if (tgt_sysfs_register_device(device))
 		goto dt_destroy;
 
@@ -490,6 +498,8 @@
 dt_destroy:
 	if (device->dt->destroy)
 		device->dt->destroy(device);
+free_priv_pt_data:
+	kfree(device->pt_data);
 free_priv_dt_data:
 	kfree(device->dt_data);
 put_template:
@@ -501,12 +511,45 @@
 	return -EINVAL;
 }
 
+static int tgt_device_destroy(int tid, uint64_t dev_id)
+{
+	struct tgt_device *device;
+	struct tgt_target *target;
+	unsigned long flags;
+
+	target = target_find(tid);
+	if (!target)
+		return -ENOENT;
+
+	spin_lock_irqsave(&target->lock, flags);
+	device = tgt_device_find_nolock(target, dev_id);
+	spin_unlock_irqrestore(&target->lock, flags);
+	if (!device)
+		return -EINVAL;
+
+	list_del(&device->dlist);
+	if (device->dt->destroy)
+		device->dt->destroy(device);
+
+	if (target->proto->detach_device)
+		target->proto->detach_device(device->pt_data);
+
+	fput(device->file);
+	device_template_put(device->dt);
+	tgt_sysfs_unregister_device(device);
+
+	return 0;
+}
+
 void tgt_transfer_response(void *data)
 {
 	struct tgt_cmd *cmd = data;
 	struct tgt_target *target = cmd->session->target;
 	int err;
 
+	if (target->proto->dequeue_cmd)
+		target->proto->dequeue_cmd(cmd);
+
 	cmd->done = tgt_cmd_destroy;
 	err = target->tt->transfer_response(cmd);
 	switch (err) {
@@ -539,7 +582,7 @@
 	if (device)
 		dprintk("found %llu\n", cmd->dev_id);
 
-	err = device->dt->queue_cmd(cmd);
+	err = target->proto->queue_cmd(cmd);
 
 	switch (err) {
 	case TGT_CMD_FAILED:
@@ -551,33 +594,6 @@
 	};
 }
 
-static int tgt_device_destroy(int tid, uint64_t dev_id)
-{
-	struct tgt_device *device;
-	struct tgt_target *target;
-	unsigned long flags;
-
-	target = target_find(tid);
-	if (!target)
-		return -ENOENT;
-
-	spin_lock_irqsave(&target->lock, flags);
-	device = tgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&target->lock, flags);
-	if (!device)
-		return -EINVAL;
-
-	list_del(&device->dlist);
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-
-	fput(device->file);
-	device_template_put(device->dt);
-	tgt_sysfs_unregister_device(device);
-
-	return 0;
-}
-
 struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *tgt_priv)
 {
 	struct tgt_cmd *cmd;

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/kernel/tgt_device.h	2005-10-04 05:08:03 UTC (rev 116)
@@ -44,13 +44,13 @@
 	/*
 	 * complete a userspace command
 	 */
-	void ( *complete_uspace_cmd)(struct tgt_cmd *cmd);
+	void (* complete_uspace_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * complete a kernel command if your queue_command was async
 	 * and the device used one of the tgt threads to process the
 	 * command
 	 */
-	void (*complete_kern_cmd)(struct tgt_cmd *cmd);
+	void (* complete_kern_cmd)(struct tgt_cmd *cmd);
 	/*
 	 * setup buffer or device fields if needed
 	 */
@@ -65,6 +65,7 @@
 struct tgt_device {
 	struct tgt_device_template *dt;
 	void *dt_data;
+	void *pt_data;
 
 	struct class_device cdev;
 

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/kernel/tgt_protocol.h	2005-10-04 05:08:03 UTC (rev 116)
@@ -25,7 +25,8 @@
 	struct module *module;
 
 	kmem_cache_t *cmd_cache;
-	int uspace_pdu_size;
+	unsigned uspace_pdu_size;
+	unsigned priv_dev_data_size;
 
 	/*
 	 * Create a command and allocate a buffer of size data_len for
@@ -40,10 +41,19 @@
 				       enum dma_data_direction data_dir,
 				       uint8_t *dev_id_buff, int id_buff_size,
 				       int flags);
+
+	int (* queue_cmd) (struct tgt_cmd *cmd);
+	void (* dequeue_cmd) (struct tgt_cmd *cmd);
 	/*
 	 * Build userspace packet
 	 */
 	void (* build_uspace_pdu)(struct tgt_cmd *cmd, void *data);
+
+	/*
+	 * Initialize protocol specific data per device
+	 */
+	void (* attach_device)(void *data);
+	void (* detach_device)(void *data);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/kernel/tgt_scsi.c	2005-10-04 05:08:03 UTC (rev 116)
@@ -9,13 +9,30 @@
 #include <linux/mm.h>
 #include <linux/highmem.h>
 #include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_tcq.h>
 
 #include <tgt.h>
 #include <tgt_scsi.h>
 #include <tgt_device.h>
 #include <tgt_protocol.h>
+#include <tgt_target.h>
 
+enum scsi_tgt_device_state_bit {
+	STDEV_ORDERED,
+	STDEV_HEAD,
+};
+
+/*
+ * The ordering stuff can be generic for all protocols. If so, should
+ * these be moved into struct tgt_device?
+ */
+struct scsi_tgt_device {
+	spinlock_t lock;
+	struct list_head pending_cmds;
+	unsigned long state;
+	unsigned active_cmds;
+};
+
 static kmem_cache_t *scsi_tgt_cmd_cache;
 
 /*
@@ -128,27 +145,185 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-void scsi_tgt_build_uspace_pdu(struct tgt_cmd *cmd, void *data)
+#define	device_blocked(x)	((x)->state & (1 << STDEV_ORDERED | 1 << STDEV_HEAD))
+
+static int scsi_tgt_task_state(struct tgt_cmd *cmd, int queue, int *more)
 {
+	struct tgt_device *device = cmd->device;
+	struct scsi_tgt_device *stdev = device->pt_data;
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	int enabled = 0;
+
+	*more = 0;
+	switch (scmd->tags) {
+	case MSG_SIMPLE_TAG:
+		if (!device_blocked(stdev) &&
+		    queue ? list_empty(&stdev->pending_cmds) : 1) {
+			enabled = 1;
+			*more = 1;
+		}
+
+		break;
+	case MSG_ORDERED_TAG:
+		if (!device_blocked(stdev) &&
+		    !stdev->active_cmds &&
+		    queue ? list_empty(&stdev->pending_cmds) : 1) {
+			enabled = 1;
+			stdev->state |= 1 << STDEV_ORDERED;
+		}
+		break;
+	case MSG_HEAD_TAG:
+		BUG_ON(!queue);
+		stdev->state |= 1 << STDEV_HEAD;
+		enabled = 1;
+		break;
+	default:
+		printk("unknown scsi tag %x\n", scmd->tags);
+		enabled = 1;
+		*more = 1;
+		break;
+	}
+
+	return enabled;
+}
+
+static void device_queue_cmd(void *data)
+{
+	struct tgt_cmd *cmd = data;
+	cmd->device->dt->queue_cmd(cmd);
+}
+
+static void scsi_tgt_dequeue_pending_cmd(struct tgt_device *device)
+{
+	struct scsi_tgt_device *stdev = device->pt_data;
+	struct tgt_cmd *cmd, *tmp;
+	struct scsi_tgt_cmd *scmd;
+	int enabled, more;
+
+	list_for_each_entry_safe(cmd, tmp, &stdev->pending_cmds, clist) {
+		scmd = tgt_cmd_to_scsi(cmd);
+
+		enabled = scsi_tgt_task_state(cmd, 0, &more);
+		BUG_ON(!enabled && more);
+
+		if (enabled) {
+			list_del(&cmd->clist);
+			stdev->active_cmds++;
+			INIT_WORK(&cmd->work, device_queue_cmd, cmd);
+			queue_work(cmd->session->target->twq, &cmd->work);
+		}
+
+		if (!more)
+			break;
+	}
+}
+
+static void scsi_tgt_dequeue_cmd(struct tgt_cmd *cmd)
+{
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct tgt_device *device = cmd->device;
+	struct scsi_tgt_device *stdev = device->pt_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&stdev->lock, flags);
+
+	stdev->active_cmds--;
+
+	switch (scmd->tags) {
+	case MSG_SIMPLE_TAG:
+		break;
+	case MSG_ORDERED_TAG:
+		stdev->state &= ~(1 << STDEV_ORDERED);
+		break;
+	case MSG_HEAD_TAG:
+		stdev->state &= ~(1 << STDEV_HEAD);
+		break;
+	default:
+		break;
+	}
+
+	if (!list_empty(&stdev->pending_cmds))
+		scsi_tgt_dequeue_pending_cmd(device);
+
+	spin_unlock_irqrestore(&stdev->lock, flags);
+}
+
+static int scsi_tgt_queue_cmd(struct tgt_cmd *cmd)
+{
+	struct tgt_device *device = cmd->device;
+	struct scsi_tgt_device *stdev = device->pt_data;
+	unsigned long flags;
+	int err, enabled, more;
+
+	/* FIXME: we need some tricks here. */
+	BUG_ON(!device);
+
+	spin_lock_irqsave(&stdev->lock, flags);
+
+	/* Do we need our own list_head? */
+	BUG_ON(!list_empty(&cmd->clist));
+
+	enabled = scsi_tgt_task_state(cmd, 1, &more);
+	if (enabled)
+		stdev->active_cmds++;
+	else
+		list_add_tail(&cmd->clist, &stdev->pending_cmds);
+
+	spin_unlock_irqrestore(&stdev->lock, flags);
+
+	if (enabled)
+		err = device->dt->queue_cmd(cmd);
+	else
+		err = TGT_CMD_KERN_QUEUED;
+
+	return err;
+}
+
+static void scsi_tgt_build_uspace_pdu(struct tgt_cmd *cmd, void *data)
+{
 	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
 	memcpy(data, scmd->scb, sizeof(scmd->scb));
 }
 
+static void scsi_tgt_attach_device(void *data)
+{
+	struct scsi_tgt_device *stdev = data;
+
+	spin_lock_init(&stdev->lock);
+	INIT_LIST_HEAD(&stdev->pending_cmds);
+	stdev->active_cmds = 0;
+}
+
+static void scsi_tgt_detach_device(void *data)
+{
+	struct scsi_tgt_device *stdev = data;
+
+	/* TODO */
+	BUG_ON(!list_empty(&stdev->pending_cmds));
+}
+
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
 	.create_cmd = scsi_tgt_create_cmd,
 	.build_uspace_pdu = scsi_tgt_build_uspace_pdu,
+	.queue_cmd = scsi_tgt_queue_cmd,
+	.dequeue_cmd = scsi_tgt_dequeue_cmd,
+	.attach_device = scsi_tgt_attach_device,
+	.detach_device = scsi_tgt_detach_device,
+	.priv_dev_data_size = sizeof(struct scsi_tgt_device),
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 
 static int __init scsi_tgt_init(void)
 {
 	int err;
+	size_t size = sizeof(struct tgt_cmd) + sizeof(struct scsi_tgt_cmd);
 
 	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-			sizeof(struct tgt_cmd) + sizeof(struct scsi_tgt_cmd),
-			0, SLAB_HWCACHE_ALIGN | SLAB_NO_REAP, NULL, NULL);
+					       size, 0,
+					       SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+					       NULL, NULL);
 	if (!scsi_tgt_cmd_cache)
 		return -ENOMEM;
 	scsi_tgt_proto.cmd_cache = scsi_tgt_cmd_cache;

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-10-01 23:01:32 UTC (rev 115)
+++ trunk/kernel/tgt_sysfs.c	2005-10-04 05:08:03 UTC (rev 116)
@@ -163,7 +163,6 @@
 	NULL,
 };
 
-
 static void tgt_device_class_release(struct class_device *cdev)
 {
 	struct tgt_device *device = cdev_to_tgt_device(cdev);
@@ -171,6 +170,7 @@
 
 	class_device_put(&target->cdev);
 	kfree(device->dt_data);
+	kfree(device->pt_data);
 	kfree(device);
 }
 



From tomo at berlios.de  Wed Oct  5 04:23:01 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 5 Oct 2005 04:23:01 +0200
Subject: [Stgt-svn] r117 - trunk/istgt/kernel
Message-ID: <200510050223.j952N15p009686@sheep.berlios.de>

Author: tomo
Date: 2005-10-05 04:22:59 +0200 (Wed, 05 Oct 2005)
New Revision: 117

Modified:
   trunk/istgt/kernel/digest.c
Log:
Restore iSCSI digest feature.

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-10-04 05:08:03 UTC (rev 116)
+++ trunk/istgt/kernel/digest.c	2005-10-05 02:22:59 UTC (rev 117)
@@ -7,6 +7,7 @@
 #include <asm/types.h>
 #include <asm/scatterlist.h>
 
+#include <tgt.h>
 #include "iscsi.h"
 #include "digest.h"
 #include "iscsi_dbg.h"
@@ -72,87 +73,6 @@
 		crypto_free_tfm(conn->rx_digest_tfm);
 }
 
-/**
- * debug handling of header digest errors:
- * simulates a digest error after n PDUs / every n-th PDU of type
- * HDIGEST_ERR_CORRUPT_PDU_TYPE.
- */
-static inline void __dbg_simulate_header_digest_error(struct iscsi_cmnd *cmnd)
-{
-#define HDIGEST_ERR_AFTER_N_CMNDS 1000
-#define HDIGEST_ERR_ONLY_ONCE     1
-#define HDIGEST_ERR_CORRUPT_PDU_TYPE ISCSI_OP_SCSI_CMD
-#define HDIGEST_ERR_CORRUPT_PDU_WITH_DATA_ONLY 0
-
-	static int num_cmnds = 0;
-	static int num_errs = 0;
-
-	if (cmnd_opcode(cmnd) == HDIGEST_ERR_CORRUPT_PDU_TYPE) {
-		if (HDIGEST_ERR_CORRUPT_PDU_WITH_DATA_ONLY) {
-			if (cmnd->pdu.datasize)
-				num_cmnds++;
-		} else
-			num_cmnds++;
-	}
-
-	if ((num_cmnds == HDIGEST_ERR_AFTER_N_CMNDS)
-	    && (!(HDIGEST_ERR_ONLY_ONCE && num_errs))) {
-		printk("*** Faking header digest error ***\n");
-		printk("\tcmnd: 0x%x, itt 0x%x, sn 0x%x\n",
-		       cmnd_opcode(cmnd),
-		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.statsn));
-		cmnd->hdigest = ~cmnd->hdigest;
-		/* make things even worse by manipulating header fields */
-		cmnd->pdu.datasize += 8;
-		num_errs++;
-		num_cmnds = 0;
-	}
-	return;
-}
-
-/**
- * debug handling of data digest errors:
- * simulates a digest error after n PDUs / every n-th PDU of type
- * DDIGEST_ERR_CORRUPT_PDU_TYPE.
- */
-static inline void __dbg_simulate_data_digest_error(struct iscsi_cmnd *cmnd)
-{
-#define DDIGEST_ERR_AFTER_N_CMNDS 50
-#define DDIGEST_ERR_ONLY_ONCE     1
-#define DDIGEST_ERR_CORRUPT_PDU_TYPE   ISCSI_OP_SCSI_DATA_OUT
-#define DDIGEST_ERR_CORRUPT_UNSOL_DATA_ONLY 0
-
-	static int num_cmnds = 0;
-	static int num_errs = 0;
-
-	if ((cmnd->pdu.datasize)
-	    && (cmnd_opcode(cmnd) == DDIGEST_ERR_CORRUPT_PDU_TYPE)) {
-		switch (cmnd_opcode(cmnd)) {
-		case ISCSI_OP_SCSI_DATA_OUT:
-			if ((DDIGEST_ERR_CORRUPT_UNSOL_DATA_ONLY)
-			    && (cmnd->pdu.bhs.ttt != ISCSI_RESERVED_TAG))
-				break;
-		default:
-			num_cmnds++;
-		}
-	}
-
-	if ((num_cmnds == DDIGEST_ERR_AFTER_N_CMNDS)
-	    && (!(DDIGEST_ERR_ONLY_ONCE && num_errs))
-	    && (cmnd->pdu.datasize)
-	    && (!cmnd->conn->read_overflow)) {
-		printk("*** Faking data digest error: ***");
-		printk("\tcmnd 0x%x, itt 0x%x, sn 0x%x\n",
-		       cmnd_opcode(cmnd),
-		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.statsn));
-		cmnd->ddigest = ~cmnd->ddigest;
-		num_errs++;
-		num_cmnds = 0;
-	}
-}
-
 /* Copied from linux-iscsi initiator and slightly adjusted */
 #define SETSG(sg, p, l) do {					\
 	(sg).page = virt_to_page((p));				\
@@ -193,75 +113,74 @@
 	digest_header(cmnd->conn->tx_digest_tfm, &cmnd->pdu, (u8 *) &cmnd->hdigest);
 }
 
-/* static void digest_data(struct crypto_tfm *tfm, struct iscsi_cmnd *cmnd, */
-/* 			struct tio *tio, u32 offset, u8 *crc) */
-/* { */
-/* 	struct scatterlist sg[ISCSI_CONN_IOV_MAX]; */
-/* 	u32 size, length; */
-/* 	int i, idx, count; */
+static void digest_data(struct crypto_tfm *tfm, struct iscsi_cmnd *cmnd,
+			struct scatterlist *sgv, u32 offset, u8 *crc)
+{
+	struct scatterlist sg[ISCSI_CONN_IOV_MAX];
+	u32 size, length;
+	int i, idx, count;
 
-/* 	size = cmnd->pdu.datasize; */
-/* 	size = (size + 3) & ~3; */
+	size = cmnd->pdu.datasize;
+	size = (size + 3) & ~3;
 
-/* 	offset += tio->offset; */
-/* 	idx = offset >> PAGE_CACHE_SHIFT; */
-/* 	offset &= ~PAGE_CACHE_MASK; */
-/* 	count = get_pgcnt(size, offset); */
+	offset += sgv->offset;
+	idx = offset >> PAGE_CACHE_SHIFT;
+	offset &= ~PAGE_CACHE_MASK;
+	count = get_pgcnt(size, offset);
+	BUG_ON(count > ISCSI_CONN_IOV_MAX);
 /* 	assert(idx + count <= tio->pg_cnt); */
 
-/* 	assert(count < ISCSI_CONN_IOV_MAX); */
+	crypto_digest_init(tfm);
 
-/* 	crypto_digest_init(tfm); */
+	for (i = 0; size; i++) {
+		if (offset + size > PAGE_CACHE_SIZE)
+			length = PAGE_CACHE_SIZE - offset;
+		else
+			length = size;
 
-/* 	for (i = 0; size; i++) { */
-/* 		if (offset + size > PAGE_CACHE_SIZE) */
-/* 			length = PAGE_CACHE_SIZE - offset; */
-/* 		else */
-/* 			length = size; */
+		sg[i].page = sgv[idx + i].page;
+		sg[i].offset = offset;
+		sg[i].length = length;
+		size -= length;
+		offset = 0;
+	}
 
-/* 		sg[i].page = tio->pvec[idx + i]; */
-/* 		sg[i].offset = offset; */
-/* 		sg[i].length = length; */
-/* 		size -= length; */
-/* 		offset = 0; */
-/* 	} */
+	crypto_digest_update(tfm, sg, count);
+	crypto_digest_final(tfm, crc);
+}
 
-/* 	crypto_digest_update(tfm, sg, count); */
-/* 	crypto_digest_final(tfm, crc); */
-/* } */
-
 int digest_rx_data(struct iscsi_cmnd *cmnd)
 {
-/* 	struct tio *tio; */
-/* 	u32 offset, crc; */
+	struct scatterlist *sg;
+	u32 offset, crc;
 
-/* 	if (cmnd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) { */
-/* 		struct iscsi_cmnd *scsi_cmnd = cmnd->req; */
-/* 		struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs; */
+	if (cmnd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
+		struct iscsi_cmnd *scsi_cmnd = cmnd->req;
+		struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 
-/* 		tio = scsi_cmnd->tio; */
-/* 		offset = be32_to_cpu(req->buffer_offset); */
-/* 	} else { */
-/* 		tio = cmnd->tio; */
-/* 		offset = 0; */
-/* 	} */
+		sg = scsi_cmnd->tc->sg;
+		offset = be32_to_cpu(req->offset);
+	} else {
+		sg = cmnd->tc->sg;
+		offset = 0;
+	}
 
-/* /\* 	digest_data(cmnd->conn->rx_digest_tfm, cmnd, tio, offset, (u8 *) &crc); *\/ */
+	BUG_ON(!sg);
+	digest_data(cmnd->conn->rx_digest_tfm, cmnd, sg, offset, (u8 *) &crc);
 
-/* 	if (!cmnd->conn->read_overflow && (cmnd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) { */
-/* 		if (crc != cmnd->ddigest) */
-/* 			return -EIO; */
-/* 	} */
+	if (!cmnd->conn->read_overflow && (cmnd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) {
+		if (crc != cmnd->ddigest)
+			return -EIO;
+	}
 
 	return 0;
 }
 
 void digest_tx_data(struct iscsi_cmnd *cmnd)
 {
-/* 	struct tio *tio = cmnd->tio; */
-/* 	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs; */
+	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 
-/* 	assert(tio); */
-/* 	digest_data(cmnd->conn->tx_digest_tfm, cmnd, tio, */
-/* 		    be32_to_cpu(req->buffer_offset), (u8 *) &cmnd->ddigest); */
+	BUG_ON(!cmnd->sg);
+	digest_data(cmnd->conn->tx_digest_tfm, cmnd, cmnd->sg,
+		    be32_to_cpu(req->offset), (u8 *) &cmnd->ddigest);
 }



From tomo at berlios.de  Wed Oct  5 07:28:19 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 5 Oct 2005 07:28:19 +0200
Subject: [Stgt-svn] r118 - trunk/istgt/kernel
Message-ID: <200510050528.j955SJFx019410@sheep.berlios.de>

Author: tomo
Date: 2005-10-05 07:28:03 +0200 (Wed, 05 Oct 2005)
New Revision: 118

Modified:
   trunk/istgt/kernel/digest.c
Log:
Clean up iSCSI digest feature.

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-10-05 02:22:59 UTC (rev 117)
+++ trunk/istgt/kernel/digest.c	2005-10-05 05:28:03 UTC (rev 118)
@@ -4,8 +4,10 @@
  * This code is licensed under the GPL.
  */
 
+#include <linux/mm.h>
 #include <asm/types.h>
 #include <asm/scatterlist.h>
+#include <linux/scatterlist.h>
 
 #include <tgt.h>
 #include "iscsi.h"
@@ -20,14 +22,6 @@
 	}
 }
 
-/**
- * initialize support for digest calculation.
- *
- * digest_init -
- * @conn: ptr to connection to make use of digests
- *
- * @return: 0 on success, < 0 on error
- */
 int digest_init(struct iscsi_conn *conn)
 {
 	int err = 0;
@@ -59,12 +53,6 @@
 	return err;
 }
 
-/**
- * free resources used for digest calculation.
- *
- * digest_cleanup -
- * @conn: ptr to connection that made use of digests
- */
 void digest_cleanup(struct iscsi_conn *conn)
 {
 	if (conn->tx_digest_tfm)
@@ -73,22 +61,15 @@
 		crypto_free_tfm(conn->rx_digest_tfm);
 }
 
-/* Copied from linux-iscsi initiator and slightly adjusted */
-#define SETSG(sg, p, l) do {					\
-	(sg).page = virt_to_page((p));				\
-	(sg).offset = ((unsigned long)(p) & ~PAGE_CACHE_MASK);	\
-	(sg).length = (l);					\
-} while (0)
-
 static void digest_header(struct crypto_tfm *tfm, struct iscsi_pdu *pdu, u8 *crc)
 {
 	struct scatterlist sg[2];
 	int i = 0;
 
-	SETSG(sg[i], &pdu->bhs, sizeof(struct iscsi_hdr));
+	sg_init_one(&sg[i], (u8 *) &pdu->bhs, sizeof(struct iscsi_hdr));
 	i++;
 	if (pdu->ahssize) {
-		SETSG(sg[i], pdu->ahs, pdu->ahssize);
+		sg_init_one(&sg[i], pdu->ahs, pdu->ahssize);
 		i++;
 	}
 



From tomo at berlios.de  Wed Oct  5 12:37:33 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 5 Oct 2005 12:37:33 +0200
Subject: [Stgt-svn] r119 - in trunk/istgt: include kernel usr
Message-ID: <200510051037.j95AbXeM022925@sheep.berlios.de>

Author: tomo
Date: 2005-10-05 12:37:31 +0200 (Wed, 05 Oct 2005)
New Revision: 119

Added:
   trunk/istgt/include/istgt_u.h
Removed:
   trunk/istgt/include/iet_u.h
   trunk/istgt/kernel/iscsi_dbg.h
Modified:
   trunk/istgt/kernel/config.c
   trunk/istgt/kernel/conn.c
   trunk/istgt/kernel/digest.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
   trunk/istgt/kernel/param.c
   trunk/istgt/kernel/session.c
   trunk/istgt/kernel/target.c
   trunk/istgt/usr/iscsid.h
Log:
Clean up iSCSI target header files.

Deleted: trunk/istgt/include/iet_u.h
===================================================================
--- trunk/istgt/include/iet_u.h	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/include/iet_u.h	2005-10-05 10:37:31 UTC (rev 119)
@@ -1,123 +0,0 @@
-#ifndef _IET_U_H
-#define _IET_U_H
-
-#define VERSION_STRING	"0.4.12"
-#define	THIS_NAME		"istgt"
-
-/* The maximum length of 223 bytes in the RFC. */
-#define ISCSI_NAME_LEN	256
-
-#define VENDOR_ID_LEN	8
-#define SCSI_ID_LEN	24
-
-struct session_info {
-	u32 tid;
-
-	u64 sid;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-};
-
-#define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
-#define DIGEST_NONE		(1 << 0)
-#define DIGEST_CRC32C           (1 << 1)
-
-struct conn_info {
-	u32 tid;
-	u64 sid;
-
-	u32 cid;
-	u32 stat_sn;
-	u32 exp_stat_sn;
-	int header_digest;
-	int data_digest;
-	int fd;
-};
-
-enum {
-	key_initial_r2t,
-	key_immediate_data,
-	key_max_connections,
-	key_max_recv_data_length,
-	key_max_xmit_data_length,
-	key_max_burst_length,
-	key_first_burst_length,
-	key_default_wait_time,
-	key_default_retain_time,
-	key_max_outstanding_r2t,
-	key_data_pdu_inorder,
-	key_data_sequence_inorder,
-	key_error_recovery_level,
-	key_header_digest,
-	key_data_digest,
-	key_ofmarker,
-	key_ifmarker,
-	key_ofmarkint,
-	key_ifmarkint,
-	session_key_last,
-};
-
-enum {
-	key_queued_cmnds,
-	target_key_last,
-};
-
-enum {
-	key_session,
-	key_target,
-};
-
-struct iscsi_param_info {
-	u32 tid;
-	u64 sid;
-
-	u32 param_type;
-	u32 partial;
-
-	u32 session_param[session_key_last];
-	u32 target_param[target_key_last];
-};
-
-enum iet_event_state {
-	E_CONN_CLOSE,
-};
-
-/*
- * msg types
- */
-enum {
-	IET_ADD_SESSION,
-	IET_DEL_SESSION,
-	IET_ADD_CONN,
-	IET_DEL_CONN,
-	IET_ISCSI_PARAM_SET,
-	IET_ISCSI_PARAM_GET,
-};
-
-struct iet_msg {
-	uint32_t msg_type;
-	uint32_t result;
-
-	/* user-> kernel */
-	union {
-		struct session_info sess_info;
-		struct conn_info conn_info;
-		struct iscsi_param_info param_info;
-	} u;
-
-	/* kernel -> user */
-	union {
-		struct {
-			u32 tid;
-			u64 sid;
-			u32 cid;
-			u32 state;
-		} conn_state_change;
-	} k;
-} __attribute__ ((aligned (sizeof(uint64_t))));
-
-#define	DEFAULT_NR_QUEUED_CMNDS	32
-#define	MIN_NR_QUEUED_CMNDS	1
-#define	MAX_NR_QUEUED_CMNDS	256
-
-#endif

Copied: trunk/istgt/include/istgt_u.h (from rev 117, trunk/istgt/include/iet_u.h)
===================================================================
--- trunk/istgt/include/iet_u.h	2005-10-05 02:22:59 UTC (rev 117)
+++ trunk/istgt/include/istgt_u.h	2005-10-05 10:37:31 UTC (rev 119)
@@ -0,0 +1,123 @@
+#ifndef _ISTGT_U_H
+#define _ISTGT_U_H
+
+#define VERSION_STRING	"0.4.12"
+#define	THIS_NAME		"istgt"
+
+/* The maximum length of 223 bytes in the RFC. */
+#define ISCSI_NAME_LEN	256
+
+#define VENDOR_ID_LEN	8
+#define SCSI_ID_LEN	24
+
+struct session_info {
+	u32 tid;
+
+	u64 sid;
+	u32 exp_cmd_sn;
+	u32 max_cmd_sn;
+};
+
+#define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
+#define DIGEST_NONE		(1 << 0)
+#define DIGEST_CRC32C           (1 << 1)
+
+struct conn_info {
+	u32 tid;
+	u64 sid;
+
+	u32 cid;
+	u32 stat_sn;
+	u32 exp_stat_sn;
+	int header_digest;
+	int data_digest;
+	int fd;
+};
+
+enum {
+	key_initial_r2t,
+	key_immediate_data,
+	key_max_connections,
+	key_max_recv_data_length,
+	key_max_xmit_data_length,
+	key_max_burst_length,
+	key_first_burst_length,
+	key_default_wait_time,
+	key_default_retain_time,
+	key_max_outstanding_r2t,
+	key_data_pdu_inorder,
+	key_data_sequence_inorder,
+	key_error_recovery_level,
+	key_header_digest,
+	key_data_digest,
+	key_ofmarker,
+	key_ifmarker,
+	key_ofmarkint,
+	key_ifmarkint,
+	session_key_last,
+};
+
+enum {
+	key_queued_cmnds,
+	target_key_last,
+};
+
+enum {
+	key_session,
+	key_target,
+};
+
+struct iscsi_param_info {
+	u32 tid;
+	u64 sid;
+
+	u32 param_type;
+	u32 partial;
+
+	u32 session_param[session_key_last];
+	u32 target_param[target_key_last];
+};
+
+enum iet_event_state {
+	E_CONN_CLOSE,
+};
+
+/*
+ * msg types
+ */
+enum {
+	IET_ADD_SESSION,
+	IET_DEL_SESSION,
+	IET_ADD_CONN,
+	IET_DEL_CONN,
+	IET_ISCSI_PARAM_SET,
+	IET_ISCSI_PARAM_GET,
+};
+
+struct iet_msg {
+	uint32_t msg_type;
+	uint32_t result;
+
+	/* user-> kernel */
+	union {
+		struct session_info sess_info;
+		struct conn_info conn_info;
+		struct iscsi_param_info param_info;
+	} u;
+
+	/* kernel -> user */
+	union {
+		struct {
+			u32 tid;
+			u64 sid;
+			u32 cid;
+			u32 state;
+		} conn_state_change;
+	} k;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+#define	DEFAULT_NR_QUEUED_CMNDS	32
+#define	MIN_NR_QUEUED_CMNDS	1
+#define	MAX_NR_QUEUED_CMNDS	256
+
+#endif

Modified: trunk/istgt/kernel/config.c
===================================================================
--- trunk/istgt/kernel/config.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/config.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -4,13 +4,10 @@
  * This code is licenced under the GPL.
  */
 
+#include <iscsi.h>
 #include <tgt.h>
 #include <tgt_target.h>
 
-#include "iet_u.h"
-#include "iscsi.h"
-#include "iscsi_dbg.h"
-
 static int add_conn(struct iscsi_target *target, struct conn_info *info)
 {
 	struct iscsi_session *session;

Modified: trunk/istgt/kernel/conn.c
===================================================================
--- trunk/istgt/kernel/conn.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/conn.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -8,9 +8,8 @@
 #include <linux/ip.h>
 #include <net/tcp.h>
 
-#include "iscsi.h"
-#include "iscsi_dbg.h"
-#include "digest.h"
+#include <iscsi.h>
+#include <digest.h>
 
 static struct iscsi_conn *conn_lookup(struct iscsi_session *session, u16 cid)
 {

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/digest.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -9,10 +9,9 @@
 #include <asm/scatterlist.h>
 #include <linux/scatterlist.h>
 
+#include <iscsi.h>
+#include <digest.h>
 #include <tgt.h>
-#include "iscsi.h"
-#include "digest.h"
-#include "iscsi_dbg.h"
 
 void digest_alg_available(unsigned int *val)
 {

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/iscsi.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -11,14 +11,12 @@
 #include <scsi/scsi_tcq.h>
 #include <linux/mempool.h>
 
+#include <iscsi.h>
 #include <tgt.h>
 #include <tgt_target.h>
 #include <tgt_scsi.h>
 #include <tgt_protocol.h>
 
-#include <iscsi.h>
-#include <iscsi_dbg.h>
-
 unsigned long debug_enable_flags;
 
 static kmem_cache_t *iscsi_cmnd_cache;
@@ -1440,7 +1438,6 @@
 	iop->iov_len = 0;
 	// move this?
 	conn->write_size = (conn->write_size + 3) & -4;
-	iscsi_dump_pdu(&cmnd->pdu);
 }
 
 void cmnd_tx_end(struct iscsi_cmnd *cmnd)
@@ -1558,8 +1555,6 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	int err = 0;
 
-	iscsi_dump_pdu(&cmnd->pdu);
-
 	if (check_segment_length(cmnd) < 0)
 		return;
 

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/iscsi.h	2005-10-05 10:37:31 UTC (rev 119)
@@ -13,8 +13,8 @@
 #include <net/sock.h>
 #include <asm/scatterlist.h>
 
-#include "iscsi_proto.h"
-#include "iet_u.h"
+#include <iscsi_proto.h>
+#include <istgt_u.h>
 
 struct iscsi_sess_param {
 	int initial_r2t;
@@ -284,4 +284,51 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
+
+#define D_SETUP		(1UL << 0)
+#define D_EXIT		(1UL << 1)
+#define D_GENERIC	(1UL << 2)
+#define D_READ		(1UL << 3)
+#define D_WRITE 	(1UL << 4)
+#define D_IOD		(1UL << 5)
+#define D_THREAD	(1UL << 6)
+#define D_TASK_MGT	(1UL << 7)
+#define D_IOMODE	(1UL << 8)
+
+#define D_DATA		(D_READ | D_WRITE)
+
+extern unsigned long debug_enable_flags;
+
+#define dprintk(debug, fmt, args...)					\
+do {									\
+	if ((debug) & debug_enable_flags) {				\
+		printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+	}								\
+} while (0)
+
+#define eprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#define show_param(param)\
+{\
+	eprintk("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",\
+		(param)->initial_r2t,\
+		(param)->immediate_data,\
+		(param)->max_connections,\
+		(param)->max_recv_data_length,\
+		(param)->max_xmit_data_length,\
+		(param)->max_burst_length,\
+		(param)->first_burst_length,\
+		(param)->default_wait_time,\
+		(param)->default_retain_time,\
+		(param)->max_outstanding_r2t,\
+		(param)->data_pdu_inorder,\
+		(param)->data_sequence_inorder,\
+		(param)->error_recovery_level,\
+		(param)->header_digest,\
+		(param)->data_digest);\
+}
+
 #endif	/* __ISCSI_H__ */

Deleted: trunk/istgt/kernel/iscsi_dbg.h
===================================================================
--- trunk/istgt/kernel/iscsi_dbg.h	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/iscsi_dbg.h	2005-10-05 10:37:31 UTC (rev 119)
@@ -1,116 +0,0 @@
-#ifndef ISCSI_DBG_H
-#define ISCSI_DBG_H
-
-#define D_SETUP		(1UL << 0)
-#define D_EXIT		(1UL << 1)
-#define D_GENERIC	(1UL << 2)
-#define D_READ		(1UL << 3)
-#define D_WRITE 	(1UL << 4)
-#define D_IOD		(1UL << 5)
-#define D_THREAD	(1UL << 6)
-#define D_TASK_MGT	(1UL << 7)
-#define D_IOMODE	(1UL << 8)
-
-#define D_DATA		(D_READ | D_WRITE)
-
-extern unsigned long debug_enable_flags;
-
-#define dprintk(debug, fmt, args...)					\
-do {									\
-	if ((debug) & debug_enable_flags) {				\
-		printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-	}								\
-} while (0)
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#ifdef D_IOV
-static inline void iscsi_dump_iov(struct msghdr *msg)
-{
-	int i;
-	printk("%p, %d\n", msg->msg_iov, msg->msg_iovlen);
-	for (i = 0; i < min_t(size_t, msg->msg_iovlen, ISCSI_CONN_IOV_MAX); i++)
-		printk("%d: %p,%d\n", i, msg->msg_iov[i].iov_base, msg->msg_iov[i].iov_len);
-}
-#else
-#define iscsi_dump_iov(x) do {} while (0)
-#endif
-
-#ifdef D_DUMP_PDU
-static void iscsi_dump_char(int ch)
-{
-	static unsigned char text[16];
-	static int i = 0;
-
-	if (ch < 0) {
-		while ((i % 16) != 0) {
-			printk("   ");
-			text[i] = ' ';
-			i++;
-			if ((i % 16) == 0)
-				printk(" | %.16s |\n", text);
-			else if ((i % 4) == 0)
-				printk(" |");
-		}
-		i = 0;
-		return;
-	}
-
-	text[i] = (ch < 0x20 || (ch >= 0x80 && ch <= 0xa0)) ? ' ' : ch;
-	printk(" %02x", ch);
-	i++;
-	if ((i % 16) == 0) {
-		printk(" | %.16s |\n", text);
-		i = 0;
-	} else if ((i % 4) == 0)
-		printk(" |");
-}
-
-static inline void iscsi_dump_pdu(struct iscsi_pdu *pdu)
-{
-	unsigned char *buf;
-	int i;
-
-	buf = (void *)&pdu->bhs;
-	printk("BHS: (%p,%d)\n", buf, sizeof(pdu->bhs));
-	for (i = 0; i < sizeof(pdu->bhs); i++)
-		iscsi_dump_char(*buf++);
-	iscsi_dump_char(-1);
-
-	buf = (void *)pdu->ahs;
-	printk("AHS: (%p,%d)\n", buf, pdu->ahssize);
-	for (i = 0; i < pdu->ahssize; i++)
-		iscsi_dump_char(*buf++);
-	iscsi_dump_char(-1);
-
-	printk("Data: (%d)\n", pdu->datasize);
-}
-
-#else
-#define iscsi_dump_pdu(x) do {} while (0)
-#endif
-
-#define show_param(param)\
-{\
-	eprintk("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",\
-		(param)->initial_r2t,\
-		(param)->immediate_data,\
-		(param)->max_connections,\
-		(param)->max_recv_data_length,\
-		(param)->max_xmit_data_length,\
-		(param)->max_burst_length,\
-		(param)->first_burst_length,\
-		(param)->default_wait_time,\
-		(param)->default_retain_time,\
-		(param)->max_outstanding_r2t,\
-		(param)->data_pdu_inorder,\
-		(param)->data_sequence_inorder,\
-		(param)->error_recovery_level,\
-		(param)->header_digest,\
-		(param)->data_digest);\
-}
-
-#endif

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/nthread.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -10,9 +10,8 @@
 #include <asm/ioctls.h>
 #include <asm/scatterlist.h>
 
-#include "iscsi.h"
-#include "iscsi_dbg.h"
-#include "digest.h"
+#include <iscsi.h>
+#include <digest.h>
 
 DECLARE_WAIT_QUEUE_HEAD(iscsi_ctl_wait);
 

Modified: trunk/istgt/kernel/param.c
===================================================================
--- trunk/istgt/kernel/param.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/param.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -4,9 +4,8 @@
  * This code is licenced under the GPL.
  */
 
-#include "iscsi.h"
-#include "iscsi_dbg.h"
-#include "digest.h"
+#include <iscsi.h>
+#include <digest.h>
 
 #define	CHECK_PARAM(info, iparam, word, min, max)			\
 do {									\

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/session.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -7,7 +7,6 @@
 #include <linux/mempool.h>
 
 #include <iscsi.h>
-#include <iscsi_dbg.h>
 #include <tgt.h>
 
 struct iscsi_session *session_lookup(struct iscsi_target *target, u64 sid)

Modified: trunk/istgt/kernel/target.c
===================================================================
--- trunk/istgt/kernel/target.c	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/kernel/target.c	2005-10-05 10:37:31 UTC (rev 119)
@@ -8,7 +8,6 @@
 
 #include <iscsi.h>
 #include <digest.h>
-#include <iscsi_dbg.h>
 #include <tgt.h>
 #include <tgt_device.h>
 #include <tgt_target.h>

Modified: trunk/istgt/usr/iscsid.h
===================================================================
--- trunk/istgt/usr/iscsid.h	2005-10-05 05:28:03 UTC (rev 118)
+++ trunk/istgt/usr/iscsid.h	2005-10-05 10:37:31 UTC (rev 119)
@@ -11,7 +11,7 @@
 #include <sys/types.h>
 
 #include "types.h"
-#include "iet_u.h"
+#include "istgt_u.h"
 #include "param.h"
 #include "misc.h"
 #include "log.h"



From tomo at berlios.de  Wed Oct 26 10:44:07 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 26 Oct 2005 10:44:07 +0200
Subject: [Stgt-svn] r120 - trunk/kernel
Message-ID: <200510260844.j9Q8i76O026037@sheep.berlios.de>

Author: tomo
Date: 2005-10-26 10:44:03 +0200 (Wed, 26 Oct 2005)
New Revision: 120

Modified:
   trunk/kernel/tgt.c
Log:
tgt_target_create doesn't need initialized tgtd_pid.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-05 10:37:31 UTC (rev 119)
+++ trunk/kernel/tgt.c	2005-10-26 08:44:03 UTC (rev 120)
@@ -157,11 +157,6 @@
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
-	if (!tgtd_pid) {
-		eprintk("%s\n", "Run the user-space daemon first!");
-		return NULL;
-	}
-
 	target = kzalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;



From tomo at berlios.de  Thu Oct 27 10:32:59 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 27 Oct 2005 10:32:59 +0200
Subject: [Stgt-svn] r121 - in trunk: kernel usr
Message-ID: <200510270832.j9R8Wxs0009476@sheep.berlios.de>

Author: tomo
Date: 2005-10-27 10:32:56 +0200 (Thu, 27 Oct 2005)
New Revision: 121

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/usr/netlink.c
Log:
Clean up send_event_res() and tgt_msg_send().


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-26 08:44:03 UTC (rev 120)
+++ trunk/kernel/tgt.c	2005-10-27 08:32:56 UTC (rev 121)
@@ -838,31 +838,40 @@
 	return cmd;
 }
 
-int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
-		 unsigned int gfp_flags)
+static int send_event_res(uint16_t type, struct tgt_event *p,
+			  void *data, int dlen, gfp_t flags)
 {
 	struct tgt_event *ev;
-	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
-	int len;
+	struct sk_buff *skb;
+	uint32_t len;
 
-	len = NLMSG_SPACE(sizeof(*ev) + data_len);
-	skb = alloc_skb(len, gfp_flags);
+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
+	skb = alloc_skb(len, flags);
 	if (!skb)
 		return -ENOMEM;
 
-	dprintk("%d %Zd %d\n", len, sizeof(*ev), data_len);
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_TARGET_PASSTHRU,
-			 len - sizeof(*nlh), 0);
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, type, len - sizeof(*nlh), 0);
+
 	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
+	memcpy(ev, p, sizeof(*ev));
+	if (dlen)
+		memcpy(ev->data, data, dlen);
 
-	memcpy(ev->data, data, data_len);
-	ev->k.tgt_passthru.tid = target->tid;
-	ev->k.tgt_passthru.len = data_len;
-
 	return netlink_unicast(nls, skb, tgtd_pid, 0);
 }
+
+int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.tgt_passthru.tid = target->tid;
+	ev.k.tgt_passthru.len = dlen;
+
+	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
+			      &ev, data, dlen, flags);
+}
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -937,31 +946,16 @@
 	return err;
 }
 
-static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
-{
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len = NLMSG_SPACE(size);
-
-	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
-	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
-	memcpy(NLMSG_DATA(nlh), data, size);
-
-	return netlink_unicast(nls, skb, pid, 0);
-}
-
 static int event_recv_skb(struct sk_buff *skb)
 {
 	int err;
 	uint32_t rlen;
 	struct nlmsghdr	*nlh;
-	struct tgt_event *ev;
 
 	while (skb->len >= NLMSG_SPACE(0)) {
 		nlh = (struct nlmsghdr *) skb->data;
 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
 			return 0;
-		ev = NLMSG_DATA(nlh);
 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
 		if (rlen > skb->len)
 			rlen = skb->len;
@@ -974,10 +968,12 @@
 		 */
 		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
 		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
-			ev->k.event_res.err = err;
-			send_event_res(NETLINK_CREDS(skb)->pid,
-				       TGT_KEVENT_RESPONSE,
-				       ev, sizeof(*ev));
+			struct tgt_event ev;
+
+			memset(&ev, 0, sizeof(ev));
+			ev.k.event_res.err = err;
+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+				       GFP_KERNEL | __GFP_NOFAIL);
 		}
 		skb_pull(skb, rlen);
 	}

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-10-26 08:44:03 UTC (rev 120)
+++ trunk/kernel/tgt.h	2005-10-27 08:32:56 UTC (rev 121)
@@ -69,8 +69,8 @@
 		   void (*done)(void *, struct tgt_session *), void *arg);
 extern int tgt_session_destroy(struct tgt_session *session);
 
-extern int tgt_msg_send(struct tgt_target *target, void *data, int data_len,
-			unsigned int gfp_flags);
+extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
+			gfp_t flags);
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd);
 extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *priv);
 extern void tgt_cmd_destroy(struct tgt_cmd *cmd);

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-10-26 08:44:03 UTC (rev 120)
+++ trunk/usr/netlink.c	2005-10-27 08:32:56 UTC (rev 121)
@@ -124,8 +124,8 @@
 	 * protocol module
 	 */
 	result = scsi_cmd_process(ev_req->k.cmd_req.tid,
-				   ev_req->k.cmd_req.dev_id, scb,
-				   (uint8_t *) ev_res->data, &len);
+				  ev_req->k.cmd_req.dev_id, scb,
+				  (uint8_t *) ev_res->data, &len);
 
 	memset(ev_res, 0, sizeof(*ev_res));
 	ev_res->u.cmd_res.cid = cid;



From tomo at berlios.de  Thu Oct 27 14:47:18 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 27 Oct 2005 14:47:18 +0200
Subject: [Stgt-svn] r122 - in trunk: . kernel usr
Message-ID: <200510271247.j9RClIJi008079@sheep.berlios.de>

Author: tomo
Date: 2005-10-27 14:47:15 +0200 (Thu, 27 Oct 2005)
New Revision: 122

Added:
   trunk/usr/dl.c
   trunk/usr/dl.h
Modified:
   trunk/initd
   trunk/kernel/tgt.c
   trunk/usr/Makefile
   trunk/usr/ipc.c
   trunk/usr/log.h
   trunk/usr/netlink.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Fix target dynamic library code. At the boot time tgtd asks the kernel
module what target drivers are available. That is, it is dynamically
changeable only at the boot time. some target driver libraries like
istgt.so need to keep the state information, so it is difficult to
implement the code that can load dynamic libraries at any time.

Asynchronous event handling always get information from /sys
directory. Maybe we need more efficient schemes (like adding target
driver id).


Modified: trunk/initd
===================================================================
--- trunk/initd	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/initd	2005-10-27 12:47:15 UTC (rev 122)
@@ -22,7 +22,7 @@
 	
 stop_server()
 {
-	${PWD}/usr/tgtadm --op delete
+	${PWD}/usr/tgtadm --driver istgt --op delete
 	killall -9 tgtd
 
 	rmmod iscsi_trgt

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/kernel/tgt.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -874,6 +874,44 @@
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
+static void tgt_start(void)
+{
+	struct tgt_event ev;
+	struct target_type_internal *ti;
+	unsigned long flags;
+	int n, err, done, rest = PAGE_SIZE;
+	char *p;
+
+	p = kzalloc(rest, GFP_KERNEL);
+	if (!p)
+		rest = 0;
+
+	n = done = 0;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+	list_for_each_entry(ti, &target_tmpl_list, list) {
+		dprintk("%s %s\n", ti->tt->name, ti->proto->name);
+		if (strlen(ti->tt->name) + strlen(ti->proto->name) + 2 > rest)
+			break;
+		err = snprintf(p + done, rest, "%s:%s,",
+			       ti->tt->name, ti->proto->name);
+		if (err < 0)
+			break;
+		rest -= err;
+		done += err;
+		n++;
+	}
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	memset(&ev, 0, sizeof(ev));
+	send_event_res(TGT_KEVENT_RESPONSE, &ev, p, done,
+		       GFP_KERNEL | __GFP_NOFAIL);
+
+	kfree(p);
+
+	eprintk("start %d target drivers\n", n);
+}
+
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;
@@ -887,7 +925,7 @@
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
 		tgtd_pid  = NETLINK_CREDS(skb)->pid;
-		dprintk("start %d\n", tgtd_pid);
+		tgt_start();
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
@@ -966,7 +1004,8 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
+		if (nlh->nlmsg_type != TGT_UEVENT_START &&
+		    nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
 		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
 			struct tgt_event ev;
 

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/Makefile	2005-10-27 12:47:15 UTC (rev 122)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o scsi.o netlink.o ipc.o log.o
+tgtd: tgtd.o scsi.o netlink.o ipc.o dl.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Added: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/dl.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -0,0 +1,140 @@
+/*
+ * Dynamic library
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This code is licenced under the GPL.
+ */
+
+/* TODO : better handling of dynamic library. */
+
+#include <string.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+
+#include "log.h"
+#include "dl.h"
+
+#define	MAX_DL_HANDLES	32
+
+struct driver_info {
+	char *name;
+	void *dl;
+	void *pdl;
+};
+
+static struct driver_info dinfo[MAX_DL_HANDLES];
+
+static int driver_find_by_name(char *name)
+{
+	int i;
+
+	for (i = 0; i < MAX_DL_HANDLES; i++)
+		if (!strncmp(dinfo[i].name, name, strlen(dinfo[i].name)))
+			return i;
+
+	return -ENOENT;
+}
+
+int dl_init(char *p)
+{
+	int i;
+	char path[PATH_MAX], *driver, *proto;
+
+	for (i = 0; (driver = strsep(&p, ",")); i++) {
+		proto = strchr(driver, ':');
+		if (!proto)
+			continue;
+
+		*proto++ = '\0';
+		dprintf("%s %s\n", driver, proto);
+
+		memset(path, 0, sizeof(path));
+		strcpy(path, driver);
+		strcat(path, ".so");
+
+		dinfo[i].name = strdup(driver);
+		dinfo[i].dl = dlopen(path, RTLD_LAZY);
+		if (!dinfo[i].dl)
+			fprintf(stderr, "%s\n", dlerror());
+	}
+
+	return i;
+}
+
+void dl_config_load(void)
+{
+	void (* fn)(void);
+	int i;
+
+	for (i = 0; i < MAX_DL_HANDLES; i++) {
+		if (!dinfo[i].dl)
+			continue;
+
+		fn = dlsym(dinfo[i].dl, "initial_config_load");
+		if (!fn)
+			eprintf("%s\n", dlerror());
+		else
+			fn();
+	}
+}
+
+void *dl_poll_init_fn(int idx)
+{
+	if (dinfo[idx].dl)
+		return dlsym(dinfo[idx].dl, "poll_init");
+	return NULL;
+}
+
+void *dl_poll_fn(int idx)
+{
+	if (dinfo[idx].dl)
+		return dlsym(dinfo[idx].dl, "poll_event");
+	return NULL;
+}
+
+void *dl_ipc_fn(char *name)
+{
+	int idx = driver_find_by_name(name);
+	if (idx < 0)
+		eprintf("%d %s\n", idx, name);
+
+	if (idx >= 0 && dinfo[idx].dl)
+		return dlsym(dinfo[idx].dl, "ipc_mgmt");
+	return NULL;
+}
+
+void *dl_event_fn(int tid)
+{
+	char path[PATH_MAX], name[PATH_MAX];
+	int idx, fd, err;
+
+	memset(path, 0, sizeof(path));
+
+	sprintf(path, "/sys/class/tgt_target/target%d/name", tid);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return NULL;
+
+	err = read(fd, name, sizeof(name));
+	close(fd);
+	if (err < 0)
+		return NULL;
+
+	idx = driver_find_by_name(name);
+	if (idx < 0)
+		eprintf("%d %s %d\n", idx, name, tid);
+
+	if (idx >= 0 && dinfo[idx].dl)
+		return dlsym(dinfo[idx].dl, "async_event");
+
+	return NULL;
+}

Added: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/dl.h	2005-10-27 12:47:15 UTC (rev 122)
@@ -0,0 +1,13 @@
+#ifndef __DL_H
+#define __DL_H
+
+extern int dl_init(char *data);
+extern void dl_config_load(void);
+extern struct pollfd * dl_poll_init(int *nr);
+
+extern void *dl_poll_init_fn(int idx);
+extern void *dl_poll_fn(int idx);
+extern void *dl_ipc_fn(char *driver);
+extern void *dl_event_fn(int tid);
+
+#endif

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/ipc.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -9,7 +9,6 @@
 #include <errno.h>
 #include <stdio.h>
 #include <unistd.h>
-#include <dlfcn.h>
 #include <errno.h>
 #include <inttypes.h>
 #include <sys/socket.h>
@@ -21,6 +20,7 @@
 
 #include "tgtd.h"
 #include "tgtadm.h"
+#include "dl.h"
 
 static int ipc_accept(int afd)
 {
@@ -58,6 +58,7 @@
 	struct iovec iov;
 	struct msghdr msg;
 	struct tgtadm_res *res;
+	struct tgtadm_req *req;
 	int (*fn) (char *, char *);
 
 	fd = ipc_accept(accept_fd);
@@ -96,11 +97,13 @@
 	if (err < 0)
 		goto fail;
 
-	eprintf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, nlh->nlmsg_len);
+	req = NLMSG_DATA(nlh);
 
-	fn = dlsym(dl_handles[0], "ipc_mgmt");
+	dprintf("%s %d %d\n", req->driver, err, nlh->nlmsg_len);
+
+	fn = dl_ipc_fn(req->driver);
 	if (!fn) {
-		eprintf("%s\n", dlerror());
+		eprintf("Cannot handle event %s\n", req->driver);
 		err = -EINVAL;
 		goto fail;
 	}

Modified: trunk/usr/log.h
===================================================================
--- trunk/usr/log.h	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/log.h	2005-10-27 12:47:15 UTC (rev 122)
@@ -73,12 +73,12 @@
 
 #define eprintf(fmt, args...)						\
 do {									\
-	log_error("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
+	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
 } while (0)
 
 #define dprintf(fmt, args...)						\
 do {									\
-	log_debug("%s/%d " fmt, __FUNCTION__, __LINE__, args);	\
+	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
 } while (0)
 
 #endif	/* LOG_H */

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/netlink.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -21,10 +21,10 @@
 #include <sys/socket.h>
 #include <asm/types.h>
 #include <linux/netlink.h>
-#include <dlfcn.h>
 
 #include <tgt_if.h>
 #include "tgtd.h"
+#include "dl.h"
 
 #define	NL_BUFSIZE	8192
 
@@ -158,9 +158,12 @@
 		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
 		break;
 	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dlsym(dl_handles[0], "async_event");
+		fn = dl_event_fn(ev->k.tgt_passthru.tid);
 		if (fn)
 			fn(NLMSG_DATA(recvbuf));
+		else
+			eprintf("Cannot handle async event %d\n",
+				ev->k.tgt_passthru.tid);
 		break;
 	default:
 		/* kernel module bug */
@@ -189,7 +192,7 @@
 	return err;
 }
 
-static void nl_start(int fd)
+static int nl_start(int fd)
 {
 	int err;
 	struct tgt_event *ev;
@@ -207,9 +210,11 @@
 		eprintf("%d %d\n", err, ev->k.event_res.err);
 		exit(-1);
 	}
+
+	return dl_init((char *) ev->data);
 }
 
-int nl_open(void)
+int nl_open(int *nr)
 {
 	int fd, err;
 
@@ -240,7 +245,7 @@
 	dest_addr.nl_pid = 0; /* kernel */
 	dest_addr.nl_groups = 0; /* unicast */
 
-	nl_start(fd);
+	*nr = nl_start(fd);
 
 	return fd;
 

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/tgtadm.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -34,6 +34,7 @@
 
 static struct option const long_options[] =
 {
+	{"driver", required_argument, NULL, 'n'},
 	{"op", required_argument, NULL, 'o'},
 	{"tid", required_argument, NULL, 't'},
 	{"sid", required_argument, NULL, 's'},
@@ -204,18 +205,21 @@
 	int tid = -1;
 	uint32_t cid = 0, set = 0;
 	uint64_t sid = 0, lun = 0;
-	char *params = NULL;
+	char *params = NULL, *driver = NULL;
 	struct tgtadm_req *req;
 	char sbuf[8192], rbuf[8912];
 
-	while ((ch = getopt_long(argc, argv, "o:t:s:c:l:p:uvh",
+	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvh",
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
+		case 'n':
+			driver = optarg;
+			break;
 		case 'o':
 			op = str_to_op(optarg);
 			break;
 		case 't':
-			tid = strtoul(optarg, NULL, 10);
+			tid = strtol(optarg, NULL, 10);
 			set |= SET_TARGET;
 			break;
 		case 's':
@@ -253,6 +257,11 @@
 		goto out;
 	}
 
+	if (!driver) {
+		fprintf(stderr, "You must specify the driver name\n");
+		goto out;
+	}
+
 	if (optind < argc) {
 		fprintf(stderr, "unrecognized: ");
 		while (optind < argc)
@@ -265,6 +274,7 @@
 	memset(rbuf, 0, sizeof(rbuf));
 
 	req = (struct tgtadm_req *) sbuf;
+	strncpy(req->driver, driver, sizeof(req->driver));
 	req->op = op;
 	req->set = set;
 	req->tid = tid;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/tgtadm.h	2005-10-27 12:47:15 UTC (rev 122)
@@ -9,6 +9,8 @@
 #define	SET_DEVICE	(1 << 3)
 #define	SET_USER	(1 << 4)
 
+#define	TGT_DNAME_LEN	64
+
 enum tgtadm_op {
 	OP_NEW,
 	OP_DELETE,
@@ -17,6 +19,7 @@
 };
 
 struct tgtadm_req {
+	char driver[TGT_DNAME_LEN];
 	int op;
 	uint32_t set;
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/tgtd.c	2005-10-27 12:47:15 UTC (rev 122)
@@ -16,7 +16,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
-#include <dlfcn.h>
 #include <asm/types.h>
 #include <sys/poll.h>
 #include <sys/signal.h>
@@ -25,14 +24,12 @@
 
 #include <tgt_if.h>
 #include "tgtd.h"
+#include "dl.h"
 
+#define	POLLS_PER_DRV	64
+
 int nl_fd, ipc_fd;
 
-#define	MAX_DL_HANDLES	32
-void *dl_handles[MAX_DL_HANDLES];
-
-#define	POLLS_PER_DL	64
-
 enum {
 	POLL_NL,
 	POLL_IPC,
@@ -65,49 +62,6 @@
 	exit(1);
 }
 
-/* TODO : proper handling of libraries.*/
-
-static int dl_init(void)
-{
-	char path[PATH_MAX];
-
-	strcat(path, "istgt.so");
-
-	dl_handles[0] = dlopen(path, RTLD_LAZY);
-	if (!dl_handles[0]) {
-		fprintf(stderr, "%s\n", dlerror());
-		exit(-1);
-	}
-
-	return 1;
-}
-
-static void dl_config_load(int nr)
-{
-	void (* fn)(void);
-
-	fn = dlsym(dl_handles[0], "initial_config_load");
-	if (!fn) {
-		eprintf("fail to dlsym %s\n", dlerror());
-		exit(-1);
-	}
-
-	fn();
-}
-
-static void dl_poll_init(int nr, struct pollfd *poll_array)
-{
-	void (* fn)(struct pollfd *, int);
-
-	fn = dlsym(dl_handles[0], "poll_init");
-	if (!fn) {
-		eprintf("fail to dlsym %s\n", dlerror());
-		exit(-1);
-	}
-
-	fn(poll_array, POLLS_PER_DL);
-}
-
 static void signal_catch(int signo) {
 }
 
@@ -147,7 +101,7 @@
 
 static void event_loop(int nr_dls, struct pollfd *poll_array)
 {
-	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DL;
+	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
 
 	while (1) {
@@ -165,28 +119,47 @@
 		if (poll_array[POLL_IPC].revents)
 			ipc_event_handle(ipc_fd);
 
-		for (i = 0; i < nr_dls && dl_handles[i]; i++) {
-			fn = dlsym(dl_handles[i], "poll_event");
-			if (!fn) {
-				eprintf("%s\n", dlerror());
-				continue;
-			}
-			fn(poll_array + ((i + 1) * POLLS_PER_DL), POLLS_PER_DL);
+		for (i = 0; i < nr_dls; i++) {
+			fn = dl_poll_fn(i);
+			if (fn)
+				fn(poll_array + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
 	}
 }
 
+static struct pollfd * poll_init(int nr)
+{
+	struct pollfd *array;
+	void (* fn)(struct pollfd *, int);
+	int i;
+
+	array = calloc((nr + 1) * POLLS_PER_DRV,
+		       sizeof(struct pollfd));
+	if (!array)
+		exit(-ENOMEM);
+
+	array[POLL_NL].fd = nl_fd;
+	array[POLL_NL].events = POLLIN;
+	array[POLL_IPC].fd = ipc_fd;
+	array[POLL_IPC].events = POLLIN;
+
+	for (i = 0; i < nr; i++) {
+		fn = dl_poll_init_fn(i);
+		if (fn)
+			fn(array + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
+	}
+
+	return array;
+}
+
 int main(int argc, char **argv)
 {
 	int ch, longindex;
-	int nr_dls, is_daemon = 1, is_debug = 1;
+	int is_daemon = 1, is_debug = 1;
+	int nr;
 	pid_t pid;
 	struct pollfd *poll_array;
 
-	nr_dls = dl_init();
-	if (nr_dls < 0)
-		nr_dls = 0;
-
 	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':
@@ -225,11 +198,7 @@
 		setsid();
 	}
 
-	poll_array = calloc((nr_dls + 1) * POLLS_PER_DL, sizeof(struct pollfd));
-	if (!poll_array)
-		exit(-ENOMEM);
-
-	nl_fd = nl_open();
+	nl_fd = nl_open(&nr);
 	if (nl_fd < 0)
 		exit(nl_fd);
 
@@ -237,16 +206,11 @@
 	if (ipc_fd < 0)
 		exit(ipc_fd);
 
-	poll_array[POLL_NL].fd = nl_fd;
-	poll_array[POLL_NL].events = POLLIN;
-	poll_array[POLL_IPC].fd = ipc_fd;
-	poll_array[POLL_IPC].events = POLLIN;
+	poll_array = poll_init(nr);
 
-	dl_poll_init(nr_dls, poll_array + POLLS_PER_DL);
+	dl_config_load();
 
-	dl_config_load(nr_dls);
+	event_loop(nr, poll_array);
 
-	event_loop(nr_dls, poll_array);
-
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-10-27 08:32:56 UTC (rev 121)
+++ trunk/usr/tgtd.h	2005-10-27 12:47:15 UTC (rev 122)
@@ -1,12 +1,11 @@
-#ifndef __SCSI_TARGET_DAEMON_H
-#define __SCSI_TARGET_DAEMON_H
+#ifndef __TARGET_DAEMON_H
+#define __TARGET_DAEMON_H
 
 #include "log.h"
 
 extern int nl_fd;
-extern void *dl_handles[];
 
-extern int nl_open(void);
+extern int nl_open(int *nr_drivers);
 extern void nl_event_handle(int fd);
 extern int nl_cmd_call(int fd, int type, char *data, int size, char *rbuf);
 



From tomo at berlios.de  Thu Oct 27 16:39:58 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 27 Oct 2005 16:39:58 +0200
Subject: [Stgt-svn] r123 - in trunk: . kernel usr
Message-ID: <200510271439.j9REdwqG014990@sheep.berlios.de>

Author: tomo
Date: 2005-10-27 16:39:57 +0200 (Thu, 27 Oct 2005)
New Revision: 123

Modified:
   trunk/initd
   trunk/kernel/tgt.c
   trunk/usr/Makefile
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
Use dynamic library for user-space protocols.


Modified: trunk/initd
===================================================================
--- trunk/initd	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/initd	2005-10-27 14:39:57 UTC (rev 123)
@@ -5,7 +5,7 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 MEM_SIZE=1048576
-export LD_LIBRARY_PATH=${PWD}/istgt/usr:${LD_LIBRARY_PATH}
+export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${LD_LIBRARY_PATH}
 
 start_server()
 {

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/kernel/tgt.c	2005-10-27 14:39:57 UTC (rev 123)
@@ -238,7 +238,7 @@
 	unsigned long flags;
 
 	session->cmd_pool = mempool_create(max_cmds, mempool_alloc_slab,
-					mempool_free_slab, proto->cmd_cache);
+					   mempool_free_slab, proto->cmd_cache);
 	if (!session->cmd_pool)
 		goto out;
 

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/Makefile	2005-10-27 14:39:57 UTC (rev 123)
@@ -1,12 +1,16 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_TGT=20
-PROGRAMS = tgtd tgtadm
+PROGRAMS = tgtd tgtadm scsi.so
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o scsi.o netlink.o ipc.o dl.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o
 	$(CC) -rdynamic -ldl $^ -o $@
+
+scsi.so: scsi.o
+	$(CC) -shared -o $@ $^
+
 clean:
 	rm -f *.o $(PROGRAMS)

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/dl.c	2005-10-27 14:39:57 UTC (rev 123)
@@ -37,13 +37,39 @@
 {
 	int i;
 
-	for (i = 0; i < MAX_DL_HANDLES; i++)
-		if (!strncmp(dinfo[i].name, name, strlen(dinfo[i].name)))
+	for (i = 0; i < MAX_DL_HANDLES; i++) {
+		if (dinfo[i].dl &&
+		    !strncmp(dinfo[i].name, name, strlen(dinfo[i].name)))
 			return i;
+	}
 
 	return -ENOENT;
 }
 
+static int tid_to_did(int tid)
+{
+	char path[PATH_MAX], name[PATH_MAX];
+	int idx, fd, err;
+
+	memset(path, 0, sizeof(path));
+
+	sprintf(path, "/sys/class/tgt_target/target%d/name", tid);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return fd;
+
+	err = read(fd, name, sizeof(name));
+	close(fd);
+	if (err < 0)
+		return err;
+
+	idx = driver_find_by_name(name);
+	if (idx < 0)
+		eprintf("%d %s\n", idx, name);
+
+	return idx;
+}
+
 int dl_init(char *p)
 {
 	int i;
@@ -60,11 +86,19 @@
 		memset(path, 0, sizeof(path));
 		strcpy(path, driver);
 		strcat(path, ".so");
-
 		dinfo[i].name = strdup(driver);
 		dinfo[i].dl = dlopen(path, RTLD_LAZY);
-		if (!dinfo[i].dl)
-			fprintf(stderr, "%s\n", dlerror());
+		if (!dinfo[i].dl) {
+			fprintf(stderr, "%s %s\n", path, dlerror());
+			continue;
+		}
+
+		memset(path, 0, sizeof(path));
+		strcpy(path, proto);
+		strcat(path, ".so");
+		dinfo[i].pdl = dlopen(path, RTLD_LAZY);
+		if (!dinfo[i].pdl)
+			fprintf(stderr, "%s %s\n", path, dlerror());
 	}
 
 	return i;
@@ -104,36 +138,39 @@
 void *dl_ipc_fn(char *name)
 {
 	int idx = driver_find_by_name(name);
-	if (idx < 0)
+
+	if (idx < 0) {
 		eprintf("%d %s\n", idx, name);
+		return NULL;
+	}
 
-	if (idx >= 0 && dinfo[idx].dl)
+	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "ipc_mgmt");
+
 	return NULL;
 }
 
-void *dl_event_fn(int tid)
+void *dl_proto_cmd_process(int tid)
 {
-	char path[PATH_MAX], name[PATH_MAX];
-	int idx, fd, err;
+	int idx = tid_to_did(tid);
 
-	memset(path, 0, sizeof(path));
-
-	sprintf(path, "/sys/class/tgt_target/target%d/name", tid);
-	fd = open(path, O_RDONLY);
-	if (fd < 0)
+	if (idx < 0)
 		return NULL;
 
-	err = read(fd, name, sizeof(name));
-	close(fd);
-	if (err < 0)
-		return NULL;
+	if (dinfo[idx].pdl)
+		return dlsym(dinfo[idx].pdl, "cmd_process");
 
-	idx = driver_find_by_name(name);
+	return NULL;
+}
+
+void *dl_event_fn(int tid)
+{
+	int idx = tid_to_did(tid);
+
 	if (idx < 0)
-		eprintf("%d %s %d\n", idx, name, tid);
+		return NULL;
 
-	if (idx >= 0 && dinfo[idx].dl)
+	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "async_event");
 
 	return NULL;

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/dl.h	2005-10-27 14:39:57 UTC (rev 123)
@@ -9,5 +9,6 @@
 extern void *dl_poll_fn(int idx);
 extern void *dl_ipc_fn(char *driver);
 extern void *dl_event_fn(int tid);
+extern void *dl_proto_cmd_process(int tid);
 
 #endif

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/netlink.c	2005-10-27 14:39:57 UTC (rev 123)
@@ -114,18 +114,22 @@
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
 	uint64_t cid = ev_req->k.cmd_req.cid;
 	uint8_t *scb;
+	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
 	scb = (uint8_t *) ev_req->data;
 	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
 
-	/*
-	 * TODO match tid to protocol and route cmd to correct userspace
-	 * protocol module
-	 */
-	result = scsi_cmd_process(ev_req->k.cmd_req.tid,
-				  ev_req->k.cmd_req.dev_id, scb,
-				  (uint8_t *) ev_res->data, &len);
+	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid);
+	if (fn)
+		result = fn(ev_req->k.cmd_req.tid,
+			    ev_req->k.cmd_req.dev_id, scb,
+			    (uint8_t *) ev_res->data, &len);
+	else {
+		result = -EINVAL;
+		eprintf("Cannot process cmd %d %llu %llu\n",
+			ev_req->k.cmd_req.tid, ev_req->k.cmd_req.dev_id, cid);
+	}
 
 	memset(ev_res, 0, sizeof(*ev_res));
 	ev_res->u.cmd_res.cid = cid;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/scsi.c	2005-10-27 14:39:57 UTC (rev 123)
@@ -226,11 +226,14 @@
 
 static int inquiry(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
+	uint64_t size;
 	int result = SAM_STAT_CHECK_CONDITION;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
+	device_info(tid, lun, &size);
+
 	if (!(scb[1] & 0x3)) {
 		data[2] = 4;
 		data[3] = 0x42;
@@ -283,7 +286,7 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (lun != ~0ULL)
+			if (errno == ENOENT)
 				sprintf(data + 8, "deadbeaf%d:%" PRIu64, tid, lun);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
@@ -295,7 +298,7 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (lun == ~0ULL)
+	if (errno == ENOENT)
 		data[0] = TYPE_NO_LUN;
 
 	return SAM_STAT_GOOD;
@@ -487,13 +490,15 @@
 	return SAM_STAT_GOOD;
 }
 
-int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
-	int result = SAM_STAT_GOOD;
+	int err, result = SAM_STAT_GOOD;
+	uint64_t size;
 
 	dprintf("%x\n", scb[0]);
 
-	if (lun == ~0ULL)
+	err = device_info(tid, lun, &size);
+	if (errno == ENOENT)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-10-27 12:47:15 UTC (rev 122)
+++ trunk/usr/tgtd.h	2005-10-27 14:39:57 UTC (rev 123)
@@ -12,6 +12,4 @@
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
-extern int scsi_cmd_process(int tid, uint64_t lun, uint8_t *scb,
-			    uint8_t *data, int *len);
 #endif



From tomo at berlios.de  Thu Oct 27 16:53:53 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 27 Oct 2005 16:53:53 +0200
Subject: [Stgt-svn] r124 - trunk/usr
Message-ID: <200510271453.j9RErrwL015978@sheep.berlios.de>

Author: tomo
Date: 2005-10-27 16:53:51 +0200 (Thu, 27 Oct 2005)
New Revision: 124

Modified:
   trunk/usr/Makefile
   trunk/usr/netlink.c
Log:
Fix the previous commit.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-10-27 14:39:57 UTC (rev 123)
+++ trunk/usr/Makefile	2005-10-27 14:53:51 UTC (rev 124)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_TGT=20
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I../include -DNETLINK_TGT=20
 PROGRAMS = tgtd tgtadm scsi.so
 
 all: $(PROGRAMS)

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-10-27 14:39:57 UTC (rev 123)
+++ trunk/usr/netlink.c	2005-10-27 14:53:51 UTC (rev 124)
@@ -127,7 +127,7 @@
 			    (uint8_t *) ev_res->data, &len);
 	else {
 		result = -EINVAL;
-		eprintf("Cannot process cmd %d %llu %llu\n",
+		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
 			ev_req->k.cmd_req.tid, ev_req->k.cmd_req.dev_id, cid);
 	}
 



From tomo at berlios.de  Fri Oct 28 03:52:15 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 03:52:15 +0200
Subject: [Stgt-svn] r125 - trunk/kernel
Message-ID: <200510280152.j9S1qFBg032685@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 03:52:12 +0200 (Fri, 28 Oct 2005)
New Revision: 125

Added:
   trunk/kernel/tgt_types.h
Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sysfs.c
Log:
Fix compile warning for some 64-bit architectures (ppc64, sparc64, etc).


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-27 14:53:51 UTC (rev 124)
+++ trunk/kernel/tgt.c	2005-10-28 01:52:12 UTC (rev 125)
@@ -438,7 +438,7 @@
 	struct tgt_device *device;
 	unsigned long flags;
 
-	dprintk("tid %d dev_id %llu type %s fd %d\n",
+	dprintk("tid %d dev_id %" PRIu64 " type %s fd %d\n",
 		tid, dev_id, device_type, fd);
 
 	target = target_find(tid);
@@ -569,13 +569,13 @@
 	struct tgt_target *target = cmd->session->target;
 	struct tgt_device *device = cmd->device;
 
-	dprintk("cid %llu\n", cmd->cid);
+	dprintk("cid %" PRIx64 "\n", cmd->cid);
 
 	/* Should we do this earlier? */
 	if (!device)
 		cmd->device = device = tgt_device_find(target, cmd->dev_id);
 	if (device)
-		dprintk("found %llu\n", cmd->dev_id);
+		dprintk("found %" PRIu64 "\n", cmd->dev_id);
 
 	err = target->proto->queue_cmd(cmd);
 
@@ -585,7 +585,7 @@
 		dprintk("command completed %d\n", err);
 		tgt_transfer_response(cmd);
 	default:
-		dprintk("command %llu queued\n", cmd->cid);
+		dprintk("command %" PRIx64 " queued\n", cmd->cid);
 	};
 }
 
@@ -607,7 +607,7 @@
 	INIT_LIST_HEAD(&cmd->clist);
 	INIT_LIST_HEAD(&cmd->hash_list);
 
-	dprintk("%p %llu\n", session, cmd->cid);
+	dprintk("%p %" PRIx64 "\n", session, cmd->cid);
 
 	spin_lock_irqsave(&cmd_hash_lock, flags);
 	list_add_tail(&cmd->hash_list, &cmd_hash[cmd_hashfn(cmd->cid)]);
@@ -630,7 +630,7 @@
 {
 	unsigned long flags;
 
-	dprintk("cid %llu\n", cmd->cid);
+	dprintk("cid %" PRIx64 "\n", cmd->cid);
 
 	tgt_free_buffer(cmd);
 
@@ -686,8 +686,8 @@
 	cmd->sg_count = pgcnt(len, offset);
 	offset &= ~PAGE_CACHE_MASK;
 
-	dprintk("cid %llu pg_count %d offset %llu len %d\n", cmd->cid,
-		cmd->sg_count, cmd->offset, cmd->bufflen);
+	dprintk("cid %" PRIx64 " pg_count %d offset %" PRIu64 " len %d\n",
+		cmd->cid, cmd->sg_count, cmd->offset, cmd->bufflen);
 
 	cmd->sg = kmalloc(cmd->sg_count * sizeof(struct scatterlist),
 			   GFP_KERNEL | __GFP_NOFAIL);
@@ -784,7 +784,7 @@
 	char *p = data;
 	int i;
 
-	dprintk("cid %llu result %d len %d bufflen %u\n",
+	dprintk("cid %" PRIx64 " result %d len %d bufflen %u\n",
 		cmd->cid, result, len, cmd->bufflen);
 
 	if (len) {
@@ -972,7 +972,8 @@
 					 ev->u.cmd_res.result,
 					 ev->u.cmd_res.len);
 		else {
-			eprintk("cannot found %llu\n", ev->u.cmd_res.cid);
+			eprintk("cannot found %" PRIx64 "\n",
+				ev->u.cmd_res.cid);
 			err = -EEXIST;
 		}
 		break;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-10-27 14:53:51 UTC (rev 124)
+++ trunk/kernel/tgt.h	2005-10-28 01:52:12 UTC (rev 125)
@@ -12,6 +12,8 @@
 #include <linux/mempool.h>
 #include <linux/dma-mapping.h>
 
+#include <tgt_types.h>
+
 struct tgt_device;
 struct tgt_protocol;
 

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-10-27 14:53:51 UTC (rev 124)
+++ trunk/kernel/tgt_scsi.c	2005-10-28 01:52:12 UTC (rev 125)
@@ -84,7 +84,7 @@
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	device = tgt_device_find(session->target, cmd->dev_id);
 	if (!device) {
-		printk(KERN_ERR "Could not find device if %llu\n",
+		printk(KERN_ERR "Could not find device if %" PRIu64 "\n",
 		       cmd->dev_id);
 		return NULL;
 	}

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-10-27 14:53:51 UTC (rev 124)
+++ trunk/kernel/tgt_sysfs.c	2005-10-28 01:52:12 UTC (rev 125)
@@ -5,6 +5,7 @@
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
+#include <tgt_types.h>
 #include <tgt_target.h>
 #include <tgt_device.h>
 
@@ -155,7 +156,7 @@
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
 tgt_device_rd_attr(fd, "%d\n");
-tgt_device_rd_attr(size, "%llu\n");
+tgt_device_rd_attr(size, "%" PRIu64 "\n");
 
 static struct class_device_attribute *tgt_device_attrs[] = {
 	&class_device_attr_fd,
@@ -186,7 +187,7 @@
 	int err, i;
 
 	cdev->class = &tgt_device_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%llu",
+	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%" PRIu64,
 		 target->tid, device->dev_id);
 	err = class_device_register(cdev);
 	if (err)

Added: trunk/kernel/tgt_types.h
===================================================================
--- trunk/kernel/tgt_types.h	2005-10-27 14:53:51 UTC (rev 124)
+++ trunk/kernel/tgt_types.h	2005-10-28 01:52:12 UTC (rev 125)
@@ -0,0 +1,18 @@
+#ifndef __TGT_TYPES_H
+#define __TGT_TYPES_H
+
+#include <linux/types.h>
+
+/* taken from inttypes.h */
+
+#if BITS_PER_LONG == 64
+#  define __PRI64_PREFIX	"l"
+# else
+#  define __PRI64_PREFIX	"ll"
+# endif
+
+# define PRId64		__PRI64_PREFIX "d"
+# define PRIu64		__PRI64_PREFIX "u"
+# define PRIx64		__PRI64_PREFIX "x"
+
+#endif



From tomo at berlios.de  Fri Oct 28 04:09:55 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 04:09:55 +0200
Subject: [Stgt-svn] r126 - in trunk: istgt/kernel kernel
Message-ID: <200510280209.j9S29tvV002316@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 04:09:53 +0200 (Fri, 28 Oct 2005)
New Revision: 126

Modified:
   trunk/istgt/kernel/conn.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
   trunk/istgt/kernel/session.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt_types.h
Log:
Move eprintk and dprintk to tgt_types.h (more appropriate header file name ?).


Modified: trunk/istgt/kernel/conn.c
===================================================================
--- trunk/istgt/kernel/conn.c	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/istgt/kernel/conn.c	2005-10-28 02:09:53 UTC (rev 126)
@@ -51,7 +51,7 @@
 	struct iscsi_session *session = conn->session;
 	struct iscsi_target *target = session->target;
 
-	dprintk(D_GENERIC, "%llu\n", (unsigned long long) session->sid);
+	dprintk("%llu\n", (unsigned long long) session->sid);
 
 	conn->sock = SOCKET_I(conn->file->f_dentry->d_inode);
 	conn->sock->sk->sk_user_data = conn;
@@ -73,7 +73,7 @@
 
 int conn_free(struct iscsi_conn *conn)
 {
-	dprintk(D_GENERIC, "%p %#Lx %u\n", conn->session,
+	dprintk("%p %#Lx %u\n", conn->session,
 		(unsigned long long) conn->session->sid, conn->cid);
 
 	BUG_ON(atomic_read(&conn->nr_cmnds));
@@ -101,8 +101,7 @@
 {
 	struct iscsi_conn *conn;
 
-	dprintk(D_SETUP, "%#Lx:%u\n",
-		(unsigned long long) session->sid, info->cid);
+	dprintk("%#Lx:%u\n", (unsigned long long) session->sid, info->cid);
 
 	conn = conn_lookup(session, info->cid);
 	if (conn)

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/istgt/kernel/iscsi.c	2005-10-28 02:09:53 UTC (rev 126)
@@ -12,10 +12,6 @@
 #include <linux/mempool.h>
 
 #include <iscsi.h>
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_scsi.h>
-#include <tgt_protocol.h>
 
 unsigned long debug_enable_flags;
 
@@ -83,7 +79,7 @@
 		BUG_ON(!conn->session->ts);
 	}
 
-	dprintk(D_GENERIC, "%p:%p\n", conn, cmnd);
+	dprintk("%p:%p\n", conn, cmnd);
 
 	return cmnd;
 }
@@ -124,7 +120,7 @@
 	list_for_each_safe(pos, next, send) {
 		cmnd = list_entry(pos, struct iscsi_cmnd, list);
 
-		dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
+		dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
 
 		list_del_init(&cmnd->list);
 		BUG_ON(conn != cmnd->conn);
@@ -165,7 +161,7 @@
 	u32 pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
-	dprintk(D_GENERIC, "%p\n", cmnd);
+	dprintk("%p\n", cmnd);
 	pdusize = conn->session->param.max_xmit_data_length;
 	expsize = cmnd_read_size(cmnd);
 	BUG_ON(!cmnd->tc);
@@ -343,7 +339,7 @@
 
 	if (!cmnd)
 		return;
-	dprintk(D_GENERIC, "%p\n", cmnd);
+	dprintk("%p\n", cmnd);
 	conn = cmnd->conn;
 	kfree(cmnd->pdu.ahs);
 
@@ -453,7 +449,7 @@
 	u32 exp_stat_sn;
 
 	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
-	dprintk(D_GENERIC, "%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
+	dprintk("%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
 	if ((int)(exp_stat_sn - conn->exp_stat_sn) > 0 &&
 	    (int)(exp_stat_sn - conn->stat_sn) <= 0) {
 		// free pdu resources
@@ -467,7 +463,7 @@
 	u32 cmd_sn;
 
 	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
-	dprintk(D_GENERIC, "%d(%d)\n", cmd_sn, session->exp_cmd_sn);
+	dprintk("%d(%d)\n", cmd_sn, session->exp_cmd_sn);
 	if ((s32)(cmd_sn - session->exp_cmd_sn) >= 0)
 		return 0;
 	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
@@ -513,7 +509,7 @@
 	int err = 0;
 	u32 itt = cmnd->pdu.bhs.itt;
 
-	dprintk(D_GENERIC, "%p:%x\n", cmnd, itt);
+	dprintk("%p:%x\n", cmnd, itt);
 	if (itt == ISCSI_RESERVED_TAG) {
 		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
@@ -604,7 +600,7 @@
 	char *addr;
 	struct scatterlist *sg;
 
-	dprintk(D_GENERIC, "%u,%u\n", offset, size);
+	dprintk("%u,%u\n", offset, size);
 
 	BUG_ON(!tc);
 	BUG_ON(!tc->sg);
@@ -687,7 +683,7 @@
 			length = 0;
 		}
 
-		dprintk(D_WRITE, "%x %u %u %u %u\n", cmnd_itt(req),
+		dprintk("%x %u %u %u %u\n", cmnd_itt(req),
 			be32_to_cpu(rsp_hdr->data_length),
 			be32_to_cpu(rsp_hdr->data_offset),
 			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
@@ -911,7 +907,7 @@
 {
 	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
 
-	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
+	dprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
 	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
@@ -1032,7 +1028,7 @@
 		}
 	}
 
-	dprintk(D_WRITE, "%u %p %p %u %u\n", req->ttt, cmnd, scsi_cmnd,
+	dprintk("%u %p %p %u %u\n", req->ttt, cmnd, scsi_cmnd,
 		offset, cmnd->pdu.datasize);
 
 	if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, cmnd->pdu.datasize) < 0)
@@ -1271,7 +1267,7 @@
 
 static void iscsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
-	dprintk(D_GENERIC, "%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
+	dprintk("%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
 		cmnd->pdu.bhs.statsn);
 
 	switch (cmnd_opcode(cmnd)) {
@@ -1377,7 +1373,7 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iovec *iop;
 
-	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
+	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
 	BUG_ON(!cmnd);
 	iscsi_cmnd_set_length(&cmnd->pdu);
 
@@ -1444,7 +1440,7 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
-	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
+	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
 	case ISCSI_OP_SCSI_CMD_RSP:
@@ -1484,7 +1480,7 @@
 	struct list_head *entry;
 	u32 cmd_sn;
 
-	dprintk(D_GENERIC, "%p:%x %u,%u\n",
+	dprintk("%p:%x %u,%u\n",
 		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn,
 		session->exp_cmd_sn);
 
@@ -1594,7 +1590,7 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 
-	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
+	dprintk("%p:%x\n", cmnd, cmnd_opcode(cmnd));
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_SCSI_REJECT:
 	case ISCSI_OP_NOOP_OUT:

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/istgt/kernel/iscsi.h	2005-10-28 02:09:53 UTC (rev 126)
@@ -16,6 +16,11 @@
 #include <iscsi_proto.h>
 #include <istgt_u.h>
 
+#include <tgt.h>
+#include <tgt_target.h>
+#include <tgt_scsi.h>
+#include <tgt_protocol.h>
+
 struct iscsi_sess_param {
 	int initial_r2t;
 	int immediate_data;
@@ -284,33 +289,6 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-
-#define D_SETUP		(1UL << 0)
-#define D_EXIT		(1UL << 1)
-#define D_GENERIC	(1UL << 2)
-#define D_READ		(1UL << 3)
-#define D_WRITE 	(1UL << 4)
-#define D_IOD		(1UL << 5)
-#define D_THREAD	(1UL << 6)
-#define D_TASK_MGT	(1UL << 7)
-#define D_IOMODE	(1UL << 8)
-
-#define D_DATA		(D_READ | D_WRITE)
-
-extern unsigned long debug_enable_flags;
-
-#define dprintk(debug, fmt, args...)					\
-do {									\
-	if ((debug) & debug_enable_flags) {				\
-		printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-	}								\
-} while (0)
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
 #define show_param(param)\
 {\
 	eprintk("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n",\

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/istgt/kernel/nthread.c	2005-10-28 02:09:53 UTC (rev 126)
@@ -134,7 +134,7 @@
 	}
 
 out:
-	dprintk(D_IOD, "%d\n", res);
+	dprintk("%d\n", res);
 
 	return res;
 }
@@ -315,7 +315,7 @@
 		set_fs(KERNEL_DS);
 		res = vfs_writev(file, (struct iovec __user *) iop, count, &off);
 		set_fs(oldfs);
-		dprintk(D_DATA, "%#Lx:%u: %d(%ld)\n",
+		dprintk("%#Lx:%u: %d(%ld)\n",
 			(unsigned long long) conn->session->sid, conn->cid,
 			res, (long) iop->iov_len);
 		if (unlikely(res <= 0)) {
@@ -359,7 +359,7 @@
 		sendsize = PAGE_CACHE_SIZE - offset;
 		if (size <= sendsize) {
 			res = sendpage(sock, sg[idx].page, offset, size, flags);
-			dprintk(D_DATA, "%s %#Lx:%u: %d(%lu,%u,%u)\n",
+			dprintk("%s %#Lx:%u: %d(%lu,%u,%u)\n",
 				sock->ops->sendpage ? "sendpage" : "writepage",
 				(unsigned long long ) conn->session->sid, conn->cid,
 				res, sg[idx].page->index, offset, size);
@@ -380,7 +380,7 @@
 		}
 
 		res = sendpage(sock, sg[idx].page, offset, sendsize, flags | MSG_MORE);
-		dprintk(D_DATA, "%s %#Lx:%u: %d(%lu,%u,%u)\n",
+		dprintk("%s %#Lx:%u: %d(%lu,%u,%u)\n",
 			sock->ops->sendpage ? "sendpage" : "writepage",
 			(unsigned long long ) conn->session->sid, conn->cid,
 			res, sg[idx].page->index, offset, sendsize);

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/istgt/kernel/session.c	2005-10-28 02:09:53 UTC (rev 126)
@@ -25,7 +25,7 @@
 	struct iscsi_session *session;
 	int i;
 
-	dprintk(D_SETUP, "%p %u %#Lx\n", target, target->tid,
+	dprintk("%p %u %#Lx\n", target, target->tid,
 		(unsigned long long) info->sid);
 
 	session = session_lookup(target, info->sid);
@@ -69,7 +69,7 @@
 	if (!session)
 		return -ENOENT;
 
-	dprintk(D_SETUP, "%#Lx\n", (unsigned long long) session->sid);
+	dprintk("%#Lx\n", (unsigned long long) session->sid);
 
 	if (!list_empty(&session->conn_list)) {
 		eprintk("%llu still have connections\n",

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/kernel/tgt.c	2005-10-28 02:09:53 UTC (rev 126)
@@ -24,19 +24,6 @@
 #include <tgt_if.h>
 #include <tgt_protocol.h>
 
-#define DEBUG_TGT
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#ifdef DEBUG_TGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
-#endif
-
 MODULE_LICENSE("GPL");
 
 static spinlock_t all_targets_lock;

Modified: trunk/kernel/tgt_types.h
===================================================================
--- trunk/kernel/tgt_types.h	2005-10-28 01:52:12 UTC (rev 125)
+++ trunk/kernel/tgt_types.h	2005-10-28 02:09:53 UTC (rev 126)
@@ -15,4 +15,18 @@
 # define PRIu64		__PRI64_PREFIX "u"
 # define PRIx64		__PRI64_PREFIX "x"
 
+
+#define DEBUG_TGT
+
+#define eprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#ifdef DEBUG_TGT
+#define dprintk eprintk
+#else
+#define dprintk(fmt, args...)
 #endif
+
+#endif



From tomo at berlios.de  Fri Oct 28 04:12:59 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 04:12:59 +0200
Subject: [Stgt-svn] r127 - trunk/kernel
Message-ID: <200510280212.j9S2CxoD003011@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 04:12:58 +0200 (Fri, 28 Oct 2005)
New Revision: 127

Modified:
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_vsd.c
Log:
Kill u32 and u64.


Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-10-28 02:09:53 UTC (rev 126)
+++ trunk/kernel/tgt_sd.c	2005-10-28 02:12:58 UTC (rev 127)
@@ -60,11 +60,11 @@
 	case READ_10:
 	case WRITE_10:
 	case WRITE_VERIFY:
-		off = be32_to_cpu(*(u32 *) &scb[2]);
+		off = be32_to_cpu(*(uint32_t *) &scb[2]);
 		break;
 	case READ_16:
 	case WRITE_16:
-		off = be64_to_cpu(*(u64 *)&scb[2]);
+		off = be64_to_cpu(*(uint64_t *) &scb[2]);
 		break;
 	default:
 		break;

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-10-28 02:09:53 UTC (rev 126)
+++ trunk/kernel/tgt_vsd.c	2005-10-28 02:12:58 UTC (rev 127)
@@ -45,7 +45,6 @@
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	uint8_t *scb = scmd->scb;
 	uint64_t off = 0;
-/*	uint32_t len = 0; */
 
 	/*
 	 * set bufflen and offset
@@ -54,27 +53,21 @@
 	case READ_6:
 	case WRITE_6:
 		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-/*		len = scb[4];
-		if (!len)
-			len = 256;*/
 		break;
 	case READ_10:
 	case WRITE_10:
 	case WRITE_VERIFY:
-		off = be32_to_cpu(*(u32 *) &scb[2]);
-/*		len = (scb[7] << 8) + scb[8]; */
+		off = be32_to_cpu(*(uint32_t *) &scb[2]);
 		break;
 	case READ_16:
 	case WRITE_16:
-		off = be64_to_cpu(*(u64 *)&scb[2]);
-/*		len = be32_to_cpu(*(u32 *)&scb[10]); */
+		off = be64_to_cpu(*(uint64_t *) &scb[2]);
 		break;
 	default:
 		break;
 	}
 
 	off <<= 9;
-/*	len <<= 9; */
 
 	/*
 	 * we trust the data_len passed in for now



From tomo at berlios.de  Fri Oct 28 12:20:13 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 12:20:13 +0200
Subject: [Stgt-svn] r128 - in trunk: istgt/include istgt/kernel istgt/usr kernel
Message-ID: <200510281020.j9SAKDRB007442@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 12:20:10 +0200 (Fri, 28 Oct 2005)
New Revision: 128

Removed:
   trunk/istgt/usr/config.h
Modified:
   trunk/istgt/include/istgt_u.h
   trunk/istgt/kernel/config.c
   trunk/istgt/kernel/conn.c
   trunk/istgt/kernel/digest.c
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/nthread.c
   trunk/istgt/kernel/param.c
   trunk/istgt/kernel/session.c
   trunk/istgt/usr/chap.c
   trunk/istgt/usr/conn.c
   trunk/istgt/usr/ctldev.c
   trunk/istgt/usr/iscsid.c
   trunk/istgt/usr/iscsid.h
   trunk/istgt/usr/istgt.c
   trunk/istgt/usr/session.c
   trunk/istgt/usr/target.c
   trunk/istgt/usr/types.h
   trunk/kernel/tgt_types.h
Log:
Kill all u8, u16, u32, and u64.


Modified: trunk/istgt/include/istgt_u.h
===================================================================
--- trunk/istgt/include/istgt_u.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/include/istgt_u.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -11,11 +11,11 @@
 #define SCSI_ID_LEN	24
 
 struct session_info {
-	u32 tid;
+	int tid;
 
-	u64 sid;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
+	uint64_t sid;
+	uint32_t exp_cmd_sn;
+	uint32_t max_cmd_sn;
 };
 
 #define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
@@ -23,12 +23,12 @@
 #define DIGEST_CRC32C           (1 << 1)
 
 struct conn_info {
-	u32 tid;
-	u64 sid;
+	int tid;
+	uint64_t sid;
 
-	u32 cid;
-	u32 stat_sn;
-	u32 exp_stat_sn;
+	uint32_t cid;
+	uint32_t stat_sn;
+	uint32_t exp_stat_sn;
 	int header_digest;
 	int data_digest;
 	int fd;
@@ -68,14 +68,14 @@
 };
 
 struct iscsi_param_info {
-	u32 tid;
-	u64 sid;
+	int tid;
+	uint64_t sid;
 
-	u32 param_type;
-	u32 partial;
+	uint32_t param_type;
+	uint32_t partial;
 
-	u32 session_param[session_key_last];
-	u32 target_param[target_key_last];
+	uint32_t session_param[session_key_last];
+	uint32_t target_param[target_key_last];
 };
 
 enum iet_event_state {
@@ -108,10 +108,10 @@
 	/* kernel -> user */
 	union {
 		struct {
-			u32 tid;
-			u64 sid;
-			u32 cid;
-			u32 state;
+			int tid;
+			uint64_t sid;
+			uint32_t cid;
+			uint32_t state;
 		} conn_state_change;
 	} k;
 } __attribute__ ((aligned (sizeof(uint64_t))));

Modified: trunk/istgt/kernel/config.c
===================================================================
--- trunk/istgt/kernel/config.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/config.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -79,7 +79,8 @@
 	return err;
 }
 
-int event_send(struct tgt_target *tgt, u32 tid, u64 sid, u32 cid, u32 state)
+int event_send(struct tgt_target *tgt, int tid, uint64_t sid, uint32_t cid,
+	       uint32_t state)
 {
 	struct iet_msg msg;
 

Modified: trunk/istgt/kernel/conn.c
===================================================================
--- trunk/istgt/kernel/conn.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/conn.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -11,7 +11,8 @@
 #include <iscsi.h>
 #include <digest.h>
 
-static struct iscsi_conn *conn_lookup(struct iscsi_session *session, u16 cid)
+static struct iscsi_conn *conn_lookup(struct iscsi_session *session,
+				      uint16_t cid)
 {
 	struct iscsi_conn *conn;
 

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/digest.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -60,12 +60,13 @@
 		crypto_free_tfm(conn->rx_digest_tfm);
 }
 
-static void digest_header(struct crypto_tfm *tfm, struct iscsi_pdu *pdu, u8 *crc)
+static void digest_header(struct crypto_tfm *tfm, struct iscsi_pdu *pdu,
+			  uint8_t *crc)
 {
 	struct scatterlist sg[2];
 	int i = 0;
 
-	sg_init_one(&sg[i], (u8 *) &pdu->bhs, sizeof(struct iscsi_hdr));
+	sg_init_one(&sg[i], (uint8_t *) &pdu->bhs, sizeof(struct iscsi_hdr));
 	i++;
 	if (pdu->ahssize) {
 		sg_init_one(&sg[i], pdu->ahs, pdu->ahssize);
@@ -79,9 +80,9 @@
 
 int digest_rx_header(struct iscsi_cmnd *cmnd)
 {
-	u32 crc;
+	uint32_t crc;
 
-	digest_header(cmnd->conn->rx_digest_tfm, &cmnd->pdu, (u8 *) &crc);
+	digest_header(cmnd->conn->rx_digest_tfm, &cmnd->pdu, (uint8_t *) &crc);
 	if (crc != cmnd->hdigest)
 		return -EIO;
 
@@ -90,14 +91,15 @@
 
 void digest_tx_header(struct iscsi_cmnd *cmnd)
 {
-	digest_header(cmnd->conn->tx_digest_tfm, &cmnd->pdu, (u8 *) &cmnd->hdigest);
+	digest_header(cmnd->conn->tx_digest_tfm, &cmnd->pdu,
+		      (uint8_t *) &cmnd->hdigest);
 }
 
 static void digest_data(struct crypto_tfm *tfm, struct iscsi_cmnd *cmnd,
-			struct scatterlist *sgv, u32 offset, u8 *crc)
+			struct scatterlist *sgv, uint32_t offset, uint8_t *crc)
 {
 	struct scatterlist sg[ISCSI_CONN_IOV_MAX];
-	u32 size, length;
+	uint32_t size, length;
 	int i, idx, count;
 
 	size = cmnd->pdu.datasize;
@@ -132,7 +134,7 @@
 int digest_rx_data(struct iscsi_cmnd *cmnd)
 {
 	struct scatterlist *sg;
-	u32 offset, crc;
+	uint32_t offset, crc;
 
 	if (cmnd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
 		struct iscsi_cmnd *scsi_cmnd = cmnd->req;
@@ -146,7 +148,8 @@
 	}
 
 	BUG_ON(!sg);
-	digest_data(cmnd->conn->rx_digest_tfm, cmnd, sg, offset, (u8 *) &crc);
+	digest_data(cmnd->conn->rx_digest_tfm, cmnd, sg, offset,
+		    (uint8_t *) &crc);
 
 	if (!cmnd->conn->read_overflow && (cmnd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) {
 		if (crc != cmnd->ddigest)
@@ -162,5 +165,5 @@
 
 	BUG_ON(!cmnd->sg);
 	digest_data(cmnd->conn->tx_digest_tfm, cmnd, cmnd->sg,
-		    be32_to_cpu(req->offset), (u8 *) &cmnd->ddigest);
+		    be32_to_cpu(req->offset), (uint8_t *) &cmnd->ddigest);
 }

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/iscsi.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -18,7 +18,7 @@
 static kmem_cache_t *iscsi_cmnd_cache;
 static char dummy_data[1024];
 
-static u32 cmnd_write_size(struct iscsi_cmnd *cmnd)
+static uint32_t cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
 	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
@@ -27,7 +27,7 @@
 	return 0;
 }
 
-static u32 cmnd_read_size(struct iscsi_cmnd *cmnd)
+static uint32_t cmnd_read_size(struct iscsi_cmnd *cmnd)
 {
 	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
@@ -158,7 +158,7 @@
 	struct scatterlist *sg = cmnd->tc->sg;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
-	u32 pdusize, expsize, scsisize, size, offset, sn;
+	uint32_t pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
 	dprintk("%p\n", cmnd);
@@ -237,7 +237,7 @@
 {
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
-	u32 size;
+	uint32_t size;
 
 	rsp = create_scsi_rsp(req);
 	rsp_hdr = (struct iscsi_cmd_rsp *) &rsp->pdu.bhs;
@@ -250,8 +250,8 @@
 }
 
 struct iscsi_sense_data {
-	u16 length;
-	u8  data[0];
+	uint16_t length;
+	uint8_t  data[0];
 } __packed;
 
 static struct iscsi_cmnd *do_create_sense_rsp(struct iscsi_cmnd *req)
@@ -289,7 +289,7 @@
 }
 
 static struct iscsi_cmnd *create_sense_rsp(struct iscsi_cmnd *req,
-					   u8 sense_key, u8 asc, u8 ascq)
+					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
 {
 	struct scsi_tgt_cmd *stc;
 	struct iscsi_cmnd *rsp;
@@ -446,12 +446,12 @@
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
 {
 	struct iscsi_conn *conn = cmnd->conn;
-	u32 exp_stat_sn;
+	uint32_t exp_stat_sn;
 
 	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
 	dprintk("%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
-	if ((int)(exp_stat_sn - conn->exp_stat_sn) > 0 &&
-	    (int)(exp_stat_sn - conn->stat_sn) <= 0) {
+	if ((int32_t) (exp_stat_sn - conn->exp_stat_sn) > 0 &&
+	    (int32_t) (exp_stat_sn - conn->stat_sn) <= 0) {
 		// free pdu resources
 		cmnd->conn->exp_stat_sn = exp_stat_sn;
 	}
@@ -460,17 +460,18 @@
 static int check_cmd_sn(struct iscsi_cmnd *cmnd)
 {
 	struct iscsi_session *session = cmnd->conn->session;
-	u32 cmd_sn;
+	uint32_t cmd_sn;
 
 	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
 	dprintk("%d(%d)\n", cmd_sn, session->exp_cmd_sn);
-	if ((s32)(cmd_sn - session->exp_cmd_sn) >= 0)
+	if ((int32_t) (cmd_sn - session->exp_cmd_sn) >= 0)
 		return 0;
 	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
 	return -ISCSI_PROTOCOL_ERROR;
 }
 
-static struct iscsi_cmnd *__cmnd_find_hash(struct iscsi_session *session, u32 itt, u32 ttt)
+static struct iscsi_cmnd *__cmnd_find_hash(struct iscsi_session *session,
+					   uint32_t itt, uint32_t ttt)
 {
 	struct list_head *head;
 	struct iscsi_cmnd *cmnd;
@@ -488,7 +489,8 @@
 	return NULL;
 }
 
-static struct iscsi_cmnd *cmnd_find_hash(struct iscsi_session *session, u32 itt, u32 ttt)
+static struct iscsi_cmnd *cmnd_find_hash(struct iscsi_session *session,
+					 uint32_t itt, uint32_t ttt)
 {
 	struct iscsi_cmnd *cmnd;
 
@@ -507,7 +509,7 @@
 	struct iscsi_cmnd *tmp;
 	struct list_head *head;
 	int err = 0;
-	u32 itt = cmnd->pdu.bhs.itt;
+	uint32_t itt = cmnd->pdu.bhs.itt;
 
 	dprintk("%p:%x\n", cmnd, itt);
 	if (itt == ISCSI_RESERVED_TAG) {
@@ -563,7 +565,7 @@
 {
 	struct iscsi_cmnd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
-	u32 size;
+	uint32_t size;
 
 	rsp = get_rsp_cmnd(req);
 	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
@@ -594,7 +596,7 @@
 }
 
 static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmd *tc,
-			 u32 offset, u32 size)
+			 uint32_t offset, uint32_t size)
 {
 	int idx, i;
 	char *addr;
@@ -656,7 +658,7 @@
 {
 	struct iscsi_cmnd *rsp;
 	struct iscsi_r2t_rsp *rsp_hdr;
-	u32 length, offset, burst;
+	uint32_t length, offset, burst;
 	LIST_HEAD(send);
 
 	length = req->r2t_length;
@@ -830,7 +832,7 @@
 
 static int noop_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	u32 size, tmp;
+	uint32_t size, tmp;
 	int i = 0, err = 0;
 
 	if (cmnd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
@@ -877,7 +879,7 @@
 		} else {
 			for (i = 0; i < ISCSI_CONN_IOV_MAX; i++) {
 				conn->read_iov[i].iov_base = dummy_data;
-				tmp = min_t(u32, size, sizeof(dummy_data));
+				tmp = min_t(uint32_t, size, sizeof(dummy_data));
 				conn->read_iov[i].iov_len = tmp;
 				conn->read_size += tmp;
 				size -= tmp;
@@ -892,9 +894,9 @@
 	return err;
 }
 
-static u32 get_next_ttt(struct iscsi_session *session)
+static uint32_t get_next_ttt(struct iscsi_session *session)
 {
-	u32 ttt;
+	uint32_t ttt;
 
 	if (session->next_ttt == ISCSI_RESERVED_TAG)
 		session->next_ttt++;
@@ -994,7 +996,7 @@
 {
 	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd = NULL;
-	u32 offset = be32_to_cpu(req->offset);
+	uint32_t offset = be32_to_cpu(req->offset);
 
 	update_stat_sn(cmnd);
 
@@ -1045,7 +1047,7 @@
 {
 	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd;
-	u32 offset;
+	uint32_t offset;
 
 	BUG_ON(!cmnd);
 	scsi_cmnd = cmnd->req;
@@ -1296,7 +1298,7 @@
 }
 
 static void __cmnd_send_pdu(struct iscsi_conn *conn, struct scatterlist *sg,
-			    u32 offset, u32 size)
+			    uint32_t offset, uint32_t size)
 {
 /* 	dprintk(D_GENERIC, "%p %u,%u\n", tio, offset, size); */
 	offset += sg->offset;
@@ -1311,7 +1313,7 @@
 
 static void cmnd_send_pdu(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	u32 size;
+	uint32_t size;
 
 	if (!cmnd->pdu.datasize)
 		return;
@@ -1403,7 +1405,7 @@
 	case ISCSI_OP_SCSI_DATA_IN:
 	{
 		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&cmnd->pdu.bhs;
-		u32 offset;
+		uint32_t offset;
 
 		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
 		offset = rsp->offset;
@@ -1478,7 +1480,7 @@
 {
 	struct iscsi_session *session = cmnd->conn->session;
 	struct list_head *entry;
-	u32 cmd_sn;
+	uint32_t cmd_sn;
 
 	dprintk("%p:%x %u,%u\n",
 		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn,

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/iscsi.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -85,13 +85,13 @@
 	struct list_head list;
 	struct iscsi_target *target;
 
-	u64 sid;
+	uint64_t sid;
 
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
+	uint32_t exp_cmd_sn;
+	uint32_t max_cmd_sn;
 
 	struct iscsi_sess_param param;
-	u32 max_queued_cmnds;
+	uint32_t max_queued_cmnds;
 
 	struct list_head conn_list;
 	struct list_head pending_list;
@@ -99,7 +99,7 @@
 	spinlock_t cmnd_hash_lock;
 	struct list_head cmnd_hash[1 << IET_HASH_ORDER];
 
-	u32 next_ttt;
+	uint32_t next_ttt;
 
 	struct tgt_session *ts;
 };
@@ -115,11 +115,11 @@
 	struct list_head list;			/* list entry in session list */
 	struct iscsi_session *session;		/* owning session */
 
-	u16 cid;
+	uint16_t cid;
 	unsigned long state;
 
-	u32 stat_sn;
-	u32 exp_stat_sn;
+	uint32_t stat_sn;
+	uint32_t exp_stat_sn;
 
 	int hdigest_type;
 	int ddigest_type;
@@ -137,8 +137,8 @@
 	struct iscsi_cmnd *read_cmnd;
 	struct msghdr read_msg;
 	struct iovec read_iov[ISCSI_CONN_IOV_MAX];
-	u32 read_size;
-	u32 read_overflow;
+	uint32_t read_size;
+	uint32_t read_overflow;
 	int read_state;
 
 	struct iscsi_cmnd *write_cmnd;
@@ -147,8 +147,8 @@
 
 	struct scatterlist *write_tcmnd;
 
-	u32 write_size;
-	u32 write_offset;
+	uint32_t write_size;
+	uint32_t write_offset;
 	int write_state;
 
 	struct crypto_tfm *rx_digest_tfm;
@@ -176,14 +176,14 @@
 
 	struct scatterlist *sg, sense_sg;
 
-	u32 r2t_sn;
-	u32 r2t_length;
-	u32 is_unsolicited_data;
-	u32 target_task_tag;
-	u32 outstanding_r2t;
+	uint32_t r2t_sn;
+	uint32_t r2t_length;
+	uint32_t is_unsolicited_data;
+	uint32_t target_task_tag;
+	uint32_t outstanding_r2t;
 
-	u32 hdigest;
-	u32 ddigest;
+	uint32_t hdigest;
+	uint32_t ddigest;
 
 	struct work_struct work;
 	struct completion event;
@@ -226,12 +226,13 @@
 
 /* config.c */
 extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
-extern int event_send(struct tgt_target *tgt, u32 tid, u64 sid, u32 cid, u32 state);
+extern int event_send(struct tgt_target *tgt, int tid, uint64_t sid,
+		      uint32_t cid, uint32_t state);
 
 /* session.c */
-extern struct iscsi_session *session_lookup(struct iscsi_target *, u64);
+extern struct iscsi_session *session_lookup(struct iscsi_target *, uint64_t);
 extern int session_add(struct iscsi_target *, struct session_info *);
-extern int session_del(struct iscsi_target *, u64);
+extern int session_del(struct iscsi_target *, uint64_t);
 
 /* params.c */
 extern int iscsi_param_set(struct iscsi_target *, struct iscsi_param_info *, int);

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/nthread.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -227,7 +227,7 @@
 		if (res <= 0 || conn->read_state != RX_INIT_HDIGEST)
 			break;
 	case RX_INIT_HDIGEST:
-		iscsi_conn_init_read(conn, &cmnd->hdigest, sizeof(u32));
+		iscsi_conn_init_read(conn, &cmnd->hdigest, sizeof(uint32_t));
 		conn->read_state = RX_HDIGEST;
 	case RX_HDIGEST:
 		res = do_recv(conn, RX_CHECK_HDIGEST);
@@ -247,7 +247,7 @@
 		if (res <= 0 || conn->read_state != RX_INIT_DDIGEST)
 			break;
 	case RX_INIT_DDIGEST:
-		iscsi_conn_init_read(conn, &cmnd->ddigest, sizeof(u32));
+		iscsi_conn_init_read(conn, &cmnd->ddigest, sizeof(uint32_t));
 		conn->read_state = RX_DDIGEST;
 	case RX_DDIGEST:
 		res = do_recv(conn, RX_CHECK_DDIGEST);
@@ -434,7 +434,7 @@
 	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
 	struct kvec iov;
 
-	iov.iov_base = (char *) (&cmnd->ddigest) + (sizeof(u32) - rest);
+	iov.iov_base = (char *) (&cmnd->ddigest) + (sizeof(uint32_t) - rest);
 	iov.iov_len = rest;
 
 	res = kernel_sendmsg(cmnd->conn->sock, &msg, &iov, 1, rest);
@@ -462,8 +462,8 @@
 	for (iop = conn->write_iop; iop->iov_len; iop++)
 		;
 	iop->iov_base = &(cmnd->hdigest);
-	iop->iov_len = sizeof(u32);
-	conn->write_size += sizeof(u32);
+	iop->iov_len = sizeof(uint32_t);
+	conn->write_size += sizeof(uint32_t);
 	iop++;
 	iop->iov_len = 0;
 
@@ -516,7 +516,7 @@
 	case TX_INIT_DDIGEST:
 		digest_tx_data(cmnd);
 		BUG_ON(cmnd->conn->write_size);
-		cmnd->conn->write_size += sizeof(u32);
+		cmnd->conn->write_size += sizeof(uint32_t);
 		conn->write_state = TX_DDIGEST;
 	case TX_DDIGEST:
 		res = tx_ddigest(cmnd, TX_END);

Modified: trunk/istgt/kernel/param.c
===================================================================
--- trunk/istgt/kernel/param.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/param.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -36,13 +36,13 @@
 
 static void sess_param_check(struct iscsi_param_info *info)
 {
-	u32 *iparam = info->session_param;
+	uint32_t *iparam = info->session_param;
 
 	CHECK_PARAM(info, iparam, max_connections, 1, 65535);
 	CHECK_PARAM(info, iparam, max_recv_data_length, 512,
-		    (u32) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
+		    (uint32_t) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
 	CHECK_PARAM(info, iparam, max_xmit_data_length, 512,
-		    (u32) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
+		    (uint32_t) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
 	CHECK_PARAM(info, iparam, error_recovery_level, 0, 0);
 	CHECK_PARAM(info, iparam, data_pdu_inorder, 1, 1);
 	CHECK_PARAM(info, iparam, data_sequence_inorder, 1, 1);
@@ -56,7 +56,7 @@
 
 static void sess_param_set(struct iscsi_sess_param *param, struct iscsi_param_info *info)
 {
-	u32 *iparam = info->session_param;
+	uint32_t *iparam = info->session_param;
 
 	SET_PARAM(param, info, iparam, initial_r2t);
 	SET_PARAM(param, info, iparam, immediate_data);
@@ -81,7 +81,7 @@
 
 static void sess_param_get(struct iscsi_sess_param *param, struct iscsi_param_info *info)
 {
-	u32 *iparam = info->session_param;
+	uint32_t *iparam = info->session_param;
 
 	GET_PARAM(param, info, iparam, initial_r2t);
 	GET_PARAM(param, info, iparam, immediate_data);
@@ -106,7 +106,7 @@
 
 static void trgt_param_check(struct iscsi_param_info *info)
 {
-	u32 *iparam = info->target_param;
+	uint32_t *iparam = info->target_param;
 
 	CHECK_PARAM(info, iparam, queued_cmnds, MIN_NR_QUEUED_CMNDS, MAX_NR_QUEUED_CMNDS);
 }
@@ -114,14 +114,14 @@
 static void trgt_param_set(struct iscsi_target *target, struct iscsi_param_info *info)
 {
 	struct iscsi_trgt_param *param = &target->trgt_param;
-	u32 *iparam = info->target_param;
+	uint32_t *iparam = info->target_param;
 
 	SET_PARAM(param, info, iparam, queued_cmnds);
 }
 
 static void trgt_param_get(struct iscsi_trgt_param *param, struct iscsi_param_info *info)
 {
-	u32 *iparam = info->target_param;
+	uint32_t *iparam = info->target_param;
 
 	GET_PARAM(param, info, iparam, queued_cmnds);
 }

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/kernel/session.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -9,7 +9,7 @@
 #include <iscsi.h>
 #include <tgt.h>
 
-struct iscsi_session *session_lookup(struct iscsi_target *target, u64 sid)
+struct iscsi_session *session_lookup(struct iscsi_target *target, uint64_t sid)
 {
 	struct iscsi_session *session;
 
@@ -25,8 +25,7 @@
 	struct iscsi_session *session;
 	int i;
 
-	dprintk("%p %u %#Lx\n", target, target->tid,
-		(unsigned long long) info->sid);
+	dprintk("%p %u %" PRIx64 "\n", target, target->tid, info->sid);
 
 	session = session_lookup(target, info->sid);
 	if (session)
@@ -60,7 +59,7 @@
 	return 0;
 }
 
-int session_del(struct iscsi_target *target, u64 sid)
+int session_del(struct iscsi_target *target, uint64_t sid)
 {
 	int i;
 	struct iscsi_session *session;
@@ -69,11 +68,10 @@
 	if (!session)
 		return -ENOENT;
 
-	dprintk("%#Lx\n", (unsigned long long) session->sid);
+	dprintk("%" PRIx64 "\n", session->sid);
 
 	if (!list_empty(&session->conn_list)) {
-		eprintk("%llu still have connections\n",
-			(unsigned long long) session->sid);
+		eprintk("%" PRIx64 " still have connections\n", session->sid);
 		return -EBUSY;
 	}
 

Modified: trunk/istgt/usr/chap.c
===================================================================
--- trunk/istgt/usr/chap.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/chap.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -57,7 +57,7 @@
 	return 0;
 }
 
-static void decode_hex_string(char *hex_string, u8 *intnum, int intlen)
+static void decode_hex_string(char *hex_string, uint8_t *intnum, int intlen)
 {
 	char *ptr;
 	int j;
@@ -77,7 +77,7 @@
 
 
 /* Base64 decoding, taken from UNH-iSCSI "Base64codeToNumber()" */
-static u8 decode_base64_digit(char base64)
+static uint8_t decode_base64_digit(char base64)
 {
 	switch (base64) {
 	case '=':
@@ -99,12 +99,12 @@
 }
 
 /* Base64 decoding, taken from UNH-iSCSI "Base64StringToInteger()" */
-static void decode_base64_string(char *string, u8 *intnum, int int_len)
+static void decode_base64_string(char *string, uint8_t *intnum, int int_len)
 {
 	int len;
 	int count;
 	int intptr;
-	u8 num[4];
+	uint8_t num[4];
 	int octets;
 
 	if ((string == NULL) || (intnum == NULL))
@@ -153,7 +153,7 @@
 	}
 }
 
-static inline void encode_hex_string(u8 *intnum, long length, char *string)
+static inline void encode_hex_string(uint8_t *intnum, long length, char *string)
 {
 	int i;
 	char *strptr;
@@ -164,7 +164,7 @@
 }
 
 /* Base64 encoding, taken from UNH iSCSI "IntegerToBase64String()" */
-static void encode_base64_string(u8 *intnum, long length, char *string)
+static void encode_base64_string(uint8_t *intnum, long length, char *string)
 {
 	int count, octets, strptr, delta;
 	static const char base64code[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G',
@@ -229,7 +229,7 @@
 	return encoding_fmt;
 }
 
-static int chap_alloc_decode_buffer(char *encoded, u8 **decode_buf, int encoding_fmt)
+static int chap_alloc_decode_buffer(char *encoded, uint8_t **decode_buf, int encoding_fmt)
 {
 	int i;
 	int decode_len = 0;
@@ -260,7 +260,7 @@
 	return decode_len;
 }
 
-static int chap_decode_string(char *encoded, u8 *decode_buf, int buf_len, int encoding_fmt)
+static int chap_decode_string(char *encoded, uint8_t *decode_buf, int buf_len, int encoding_fmt)
 {
 	if (encoding_fmt == HEX_FORMAT) {
 		if ((strlen(encoded) - 2) > (2 * buf_len)) {
@@ -286,7 +286,7 @@
 	return 0;
 }
 
-static inline void chap_encode_string(u8 *intnum, int buf_len, char *encode_buf, int encoding_fmt)
+static inline void chap_encode_string(uint8_t *intnum, int buf_len, char *encode_buf, int encoding_fmt)
 {
 	encode_buf[0] = '0';
 	if (encoding_fmt == HEX_FORMAT) {
@@ -298,7 +298,7 @@
 	}
 }
 
-static inline void chap_calc_digest_md5(char chap_id, char *secret, int secret_len, u8 *challenge, int challenge_len, u8 *digest)
+static inline void chap_calc_digest_md5(char chap_id, char *secret, int secret_len, uint8_t *challenge, int challenge_len, uint8_t *digest)
 {
 	MD5_CTX ctx;
 
@@ -309,7 +309,7 @@
 	MD5_Final(digest, &ctx);
 }
 
-static inline void chap_calc_digest_sha1(char chap_id, char *secret, int secret_len, u8 *challenge, int challenge_len, u8 *digest)
+static inline void chap_calc_digest_sha1(char chap_id, char *secret, int secret_len, uint8_t *challenge, int challenge_len, uint8_t *digest)
 {
 	SHA_CTX ctx;
 
@@ -376,7 +376,7 @@
 static int chap_initiator_auth_check_response(struct connection *conn)
 {
 	char *value;
-	u8 *his_digest = NULL, *our_digest = NULL;
+	uint8_t *his_digest = NULL, *our_digest = NULL;
 	int digest_len = 0, retval = 0, encoding_format;
 	char pass[ISCSI_NAME_LEN];
 
@@ -476,7 +476,7 @@
 static int chap_target_auth_create_response(struct connection *conn)
 {
 	char chap_id, *value, *response = NULL;
-	u8 *challenge = NULL, *digest = NULL;
+	uint8_t *challenge = NULL, *digest = NULL;
 	int encoding_format, response_len;
 	int challenge_len = 0, digest_len = 0, retval = 0;
 	char pass[ISCSI_NAME_LEN], name[ISCSI_NAME_LEN];

Deleted: trunk/istgt/usr/config.h
===================================================================
--- trunk/istgt/usr/config.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/config.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -1,21 +0,0 @@
-#ifndef CONFIG_H
-#define CONFIG_H
-
-struct config_operations {
-	int (*init) (char *);
-/* 	int (*target_add) (u32 *, char *); */
-/* 	int (*target_stop) (u32); */
-/* 	int (*target_del) (u32); */
-/* 	int (*lunit_add) (u32, u32, char *); */
-/* 	int (*lunit_stop) (u32, u32); */
-/* 	int (*lunit_del) (u32, u32); */
-/* 	int (*param_set) (u32, u64, int, u32, struct iscsi_param *); */
-	int (*account_add) (u32, int, char *, char *);
-	int (*account_del) (u32, int, char *);
-	int (*account_query) (u32, int, char *, char *);
-	int (*initiator_access) (u32, int);
-};
-
-extern struct config_operations *cops;
-
-#endif

Modified: trunk/istgt/usr/conn.c
===================================================================
--- trunk/istgt/usr/conn.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/conn.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -52,7 +52,7 @@
 	free(conn);
 }
 
-struct connection *conn_find(struct session *session, u32 cid)
+struct connection *conn_find(struct session *session, uint32_t cid)
 {
 	struct connection *conn;
 

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/ctldev.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -81,8 +81,8 @@
 	}
 }
 
-static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
-		       int len, int flags)
+static void nlmsg_init(struct nlmsghdr *nlh, uint32_t pid, uint32_t seq,
+		       uint16_t type, uint32_t len, uint16_t flags)
 {
 	nlh->nlmsg_pid = pid;
 	nlh->nlmsg_len = len;
@@ -94,7 +94,7 @@
 /*
  * this will have to be redone and made generic when we move it
  */
-static struct nlmsghdr *get_iet_msg(u32 tid, struct iet_msg **msg)
+static struct nlmsghdr *get_iet_msg(int tid, struct iet_msg **msg)
 {
 	int len;
 	struct nlmsghdr *nlh;
@@ -115,7 +115,7 @@
 }
 
 
-static int iscsi_conn_destroy(u32 tid, u64 sid, u32 cid)
+static int iscsi_conn_destroy(int tid, uint64_t sid, uint32_t cid)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -137,7 +137,7 @@
 	return err;
 }
 
-static int iscsi_param_get(u32 tid, u64 sid, struct iscsi_param *param)
+static int iscsi_param_get(int tid, uint64_t sid, struct iscsi_param *param)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -172,7 +172,8 @@
 	return err;
 }
 
-static int iscsi_param_set(u32 tid, u64 sid, int type, u32 partial, struct iscsi_param *param)
+static int iscsi_param_set(int tid, uint64_t sid, int type, uint32_t partial,
+			   struct iscsi_param *param)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -205,7 +206,8 @@
 	return err;
 }
 
-static int iscsi_param_partial_set(u32 tid, u64 sid, int type, int key, u32 val)
+static int iscsi_param_partial_set(int tid, uint64_t sid, int type, int key,
+				   uint32_t val)
 {
 	struct iscsi_param *param;
 	struct iscsi_param s_param[session_key_last];
@@ -230,7 +232,7 @@
 
 	while ((p = strsep(&params, ",")) != NULL) {
 		int idx;
-		u32 val;
+		uint32_t val;
 		if (!*p)
 			continue;
 		if (!(q = strchr(p, '=')))
@@ -272,7 +274,8 @@
 	return 0;
 }
 
-static int iscsi_session_create(u32 tid, u64 sid, u32 exp_cmd_sn, u32 max_cmd_sn, char *name)
+static int iscsi_session_create(int tid, uint64_t sid,
+				uint32_t exp_cmd_sn, uint32_t max_cmd_sn)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -295,7 +298,7 @@
 	return err;
 }
 
-static int iscsi_session_destroy(u32 tid, u64 sid)
+static int iscsi_session_destroy(int tid, uint64_t sid)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -316,8 +319,9 @@
 	return err;
 }
 
-static int iscsi_conn_create(u32 tid, u64 sid, u32 cid, u32 stat_sn, u32 exp_stat_sn,
-			     int fd, u32 hdigest, u32 ddigest)
+static int iscsi_conn_create(int tid, uint64_t sid, uint32_t cid,
+			     uint32_t stat_sn, uint32_t exp_stat_sn,
+			     int fd, uint32_t hdigest, uint32_t ddigest)
 {
 	struct iet_msg *msg;
 	struct nlmsghdr *nlh;
@@ -344,7 +348,7 @@
 	return err;
 }
 
-static int iscsi_target_create(int *tid, char *name)
+static int iscsi_target_create(int *tid)
 {
 	int err;
 	char nlm_ev[8912];
@@ -368,7 +372,7 @@
 	return err;
 }
 
-static int iscsi_target_destroy(u32 tid)
+static int iscsi_target_destroy(int tid)
 {
 	int err;
 	char nlm_ev[8912];
@@ -387,7 +391,7 @@
 	return err;
 }
 
-static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
+static int iscsi_lunit_create(int tid, uint64_t lun, char *args)
 {
 	int err, fd;
 	char *p, *q, *type = NULL, *path = NULL;
@@ -455,7 +459,7 @@
 	return err;
 }
 
-static int iscsi_lunit_destroy(u32 tid, u32 lun)
+static int iscsi_lunit_destroy(int tid, uint64_t lun)
 {
 	int err, fd;
 	char nlm_ev[8912];
@@ -463,7 +467,7 @@
 	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	fprintf(stderr, "%s %d %d %u\n", __FUNCTION__, __LINE__, tid, lun);
+	dprintf("%d %" PRIu64 "\n",tid, lun);
 
 	memset(nlm_ev, 0, sizeof(nlm_ev));
 	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_DEVICE_DESTROY,
@@ -473,7 +477,8 @@
 	ev->u.d_device.tid = tid;
 	ev->u.d_device.dev_id = lun;
 
-	sprintf(path, "/sys/class/tgt_device/device%d:%d/fd", tid, lun);
+	sprintf(path, "/sys/class/tgt_device/device%d:%" PRIu64 "/fd",
+		tid, lun);
 	fd = open(path, O_RDONLY);
 	if (fd < 0) {
 		perror("iscsi_lunit_destroy could not open fd file");
@@ -689,8 +694,8 @@
 	FILE *config;
 	char buf[BUFSIZE];
 	char *p, *q;
-	int idx;
-	u32 tid, val;
+	int idx, tid;
+	uint32_t val;
 
 	eprintf("%s\n", "load config");
 
@@ -715,8 +720,8 @@
 		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
 			/* target->max_sessions = strtol(q, &q, 0); */
 		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
-			u32 lun = strtol(q, &q, 10);
-			eprintf("creaing lun %d %u %s\n", tid, lun, p);
+			uint64_t lun = strtoull(q, &q, 10);
+			eprintf("creaing lun %d %" PRIu64 " %s\n", tid, lun, p);
 			iscsi_lunit_create(tid, lun, q);
 		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
 			val = strtol(q, &q, 0);

Modified: trunk/istgt/usr/iscsid.c
===================================================================
--- trunk/istgt/usr/iscsid.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/iscsid.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -113,7 +113,7 @@
 	text_key_add(conn, key, "Reject");
 }
 
-static int account_empty(u32 tid, int dir)
+static int account_empty(int tid, int dir)
 {
 	char pass[ISCSI_NAME_LEN];
 

Modified: trunk/istgt/usr/iscsid.h
===================================================================
--- trunk/istgt/usr/iscsid.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/iscsid.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -57,23 +57,23 @@
 	struct qelem clist;
 	struct session *session;
 
-	u32 tid;
+	int tid;
 	struct iscsi_param session_param[session_key_last];
 
 	char *initiator;
 	uint8_t isid[6];
 	uint16_t tsih;
-	u16 cid;
-	u16 pad;
+	uint16_t cid;
+	uint16_t pad;
 	int session_type;
 	int auth_method;
 
-	u32 stat_sn;
-	u32 exp_stat_sn;
+	uint32_t stat_sn;
+	uint32_t exp_stat_sn;
 
-	u32 cmd_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
+	uint32_t cmd_sn;
+	uint32_t exp_cmd_sn;
+	uint32_t max_cmd_sn;
 
 	struct PDU req;
 	void *req_buffer;
@@ -136,7 +136,7 @@
 
 	struct qelem sessions_list;
 
-	u32 tid;
+	int tid;
 	char name[ISCSI_NAME_LEN];
 	char *alias;
 
@@ -150,7 +150,7 @@
 /* conn.c */
 extern struct connection *conn_alloc(void);
 extern void conn_free(struct connection *conn);
-extern struct connection * conn_find(struct session *session, u32 cid);
+extern struct connection * conn_find(struct session *session, uint32_t cid);
 extern void conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
@@ -166,30 +166,33 @@
 extern void text_key_add(struct connection *conn, char *key, char *value);
 
 /* session.c */
-extern struct session *session_find_name(u32 tid, const char *iname, uint8_t *isid);
-extern struct session *session_find_id(u32 tid, u64 sid);
+extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
+extern struct session *session_find_id(int tid, uint64_t sid);
 extern void session_create(struct connection *conn);
 extern void session_remove(struct session *session);
 
 /* target.c */
 extern int target_add(int *tid, char *name);
 extern int target_del(int tid);
-extern int target_find_by_name(const char *name, u32 *tid);
-struct target * target_find_by_id(u32);
+extern int target_find_by_name(const char *name, int *tid);
+struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 
 /* ctldev.c */
 struct iscsi_kernel_interface {
-	int (*lunit_create) (u32 tid, u32 lun, char *args);
-	int (*lunit_destroy) (u32 tid, u32 lun);
-	int (*param_get) (u32, u64, struct iscsi_param *);
-	int (*param_set) (u32, u64, int, u32, struct iscsi_param *);
-	int (*target_create) (int *, char *);
-	int (*target_destroy) (u32);
-	int (*session_create) (u32, u64, u32, u32, char *);
-	int (*session_destroy) (u32, u64);
-	int (*conn_create) (u32, u64, u32, u32, u32, int, u32, u32);
-	int (*conn_destroy) (u32 tid, u64 sid, u32 cid);
+	int (*lunit_create) (int tid, uint64_t lun, char *args);
+	int (*lunit_destroy) (int tid, uint64_t lun);
+	int (*param_get) (int tid, uint64_t sid, struct iscsi_param *);
+	int (*param_set) (int tid, uint64_t sid, int type, uint32_t flags,
+			  struct iscsi_param *);
+	int (*target_create) (int *tid);
+	int (*target_destroy) (int tid);
+	int (*session_create) (int tid, uint64_t sid, uint32_t exp,
+			       uint32_t max);
+	int (*session_destroy) (int tid, uint64_t sid);
+	int (*conn_create) (int tid, uint64_t sid, uint32_t cid, uint32_t sn,
+			    uint32_t exp_sn, int fd, uint32_t hd, uint32_t dd);
+	int (*conn_destroy) (int tid, uint64_t sid, uint32_t cid);
 };
 
 extern struct iscsi_kernel_interface *ki;

Modified: trunk/istgt/usr/istgt.c
===================================================================
--- trunk/istgt/usr/istgt.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/istgt.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -272,7 +272,7 @@
 					o = conn->rwsize & 3;
 					if (o) {
 						for (o = 4 - o; o; o--)
-							*((u8 *)conn->buffer + conn->rwsize++) = 0;
+							*((uint8_t *)conn->buffer + conn->rwsize++) = 0;
 					}
 					goto write_again;
 				}

Modified: trunk/istgt/usr/session.c
===================================================================
--- trunk/istgt/usr/session.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/session.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -16,7 +16,7 @@
 
 #include "iscsid.h"
 
-static struct session *session_alloc(u32 tid)
+static struct session *session_alloc(int tid)
 {
 	struct session *session;
 	struct target *target = target_find_by_id(tid);
@@ -36,7 +36,7 @@
 	return session;
 }
 
-struct session *session_find_name(u32 tid, const char *iname, uint8_t *isid)
+struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
 	struct target *target;
@@ -55,7 +55,7 @@
 	return NULL;
 }
 
-struct session *session_find_id(u32 tid, u64 sid)
+struct session *session_find_id(int tid, uint64_t sid)
 {
 	struct session *session;
 	struct target *target;
@@ -99,7 +99,7 @@
 	log_debug("session_create: %#" PRIx64, sid);
 
 	ki->session_create(conn->tid, sid, conn->exp_cmd_sn,
-			   conn->max_cmd_sn, session->initiator);
+			   conn->max_cmd_sn);
 	ki->param_set(conn->tid, sid, key_session, 0, conn->session_param);
 }
 

Modified: trunk/istgt/usr/target.c
===================================================================
--- trunk/istgt/usr/target.c	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/target.c	2005-10-28 10:20:10 UTC (rev 128)
@@ -32,7 +32,7 @@
 	}
 }
 
-int target_find_by_name(const char *name, u32 *tid)
+int target_find_by_name(const char *name, int *tid)
 {
 	struct target *target;
 
@@ -46,7 +46,7 @@
 	return -ENOENT;
 }
 
-struct target* target_find_by_id(u32 tid)
+struct target* target_find_by_id(int tid)
 {
 	struct target *target;
 
@@ -58,7 +58,7 @@
 	return NULL;
 }
 
-static void all_accounts_del(u32 tid, int dir)
+static void all_accounts_del(int tid, int dir)
 {
 /* 	char name[ISCSI_NAME_LEN], pass[ISCSI_NAME_LEN]; */
 
@@ -111,7 +111,7 @@
 	memset(target, 0, sizeof(*target));
 	memcpy(target->name, name, sizeof(target->name) - 1);
 
-	if ((err = ki->target_create(tid, name)) < 0) {
+	if ((err = ki->target_create(tid)) < 0) {
 		log_warning("can't create a target %d %u\n", err, *tid);
 		goto out;
 	}

Modified: trunk/istgt/usr/types.h
===================================================================
--- trunk/istgt/usr/types.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/istgt/usr/types.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -27,11 +27,6 @@
 #error "unknown endianess!"
 #endif
 
-typedef u_int8_t u8;
-typedef u_int16_t u16;
-typedef u_int32_t u32;
-typedef u_int64_t u64;
-
 typedef uint16_t __be16;
 typedef uint32_t __be32;
 

Modified: trunk/kernel/tgt_types.h
===================================================================
--- trunk/kernel/tgt_types.h	2005-10-28 02:12:58 UTC (rev 127)
+++ trunk/kernel/tgt_types.h	2005-10-28 10:20:10 UTC (rev 128)
@@ -3,9 +3,9 @@
 
 #include <linux/types.h>
 
-/* taken from inttypes.h */
+/* Is there a smart way? */
 
-#if BITS_PER_LONG == 64
+#if defined(CONFIG_ALPAH) || defined(CONFIG_IA64) || defined(CONFIG_PPC64) || (defined(CONFIG_S390) && defined(__x390x__)) || defined(CONFIG_SPARC64)
 #  define __PRI64_PREFIX	"l"
 # else
 #  define __PRI64_PREFIX	"ll"



From tomo at berlios.de  Fri Oct 28 12:41:23 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 12:41:23 +0200
Subject: [Stgt-svn] r129 - trunk/istgt/usr
Message-ID: <200510281041.j9SAfN3r022128@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 12:41:20 +0200 (Fri, 28 Oct 2005)
New Revision: 129

Modified:
   trunk/istgt/usr/ctldev.c
   trunk/istgt/usr/target.c
Log:
Trivial cleanup.


Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2005-10-28 10:20:10 UTC (rev 128)
+++ trunk/istgt/usr/ctldev.c	2005-10-28 10:41:20 UTC (rev 129)
@@ -200,7 +200,7 @@
 
 	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
 	if (err)
-		fprintf(stderr, "%d %d %u %" PRIx64 "%d %u\n",
+		eprintf("%d %d %u %" PRIx64 "%d %u\n",
 			err, errno, tid, sid, type, partial);
 	free(nlh);
 	return err;
@@ -399,7 +399,7 @@
 	struct tgt_event *ev;
 	struct nlmsghdr *nlh;
 
-	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
+	dprintf("%s\n", args);
 
 	if (isspace(*args))
 		args++;
@@ -423,16 +423,15 @@
 	if (!type)
 		type = dtype;
 	if (!path) {
-		fprintf(stderr, "%s %d NULL path\n", __FUNCTION__, __LINE__);
+		eprintf("%d %" PRIu64 "\n", tid, lun);
 		return -EINVAL;
 	}
 
-	fprintf(stderr, "%s %d %s %s %Zd %Zd\n",
-		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
+	dprintf("%s %s %Zd\n", type, path, strlen(path));
 
 	fd = open(path, O_RDWR | O_LARGEFILE);
 	if (fd < 0) {
-		log_error("Could not open %s errno %d\n", path, errno);
+		eprintf("Could not open %s errno %d\n", path, errno);
 		return errno;
 	}
 

Modified: trunk/istgt/usr/target.c
===================================================================
--- trunk/istgt/usr/target.c	2005-10-28 10:20:10 UTC (rev 128)
+++ trunk/istgt/usr/target.c	2005-10-28 10:41:20 UTC (rev 129)
@@ -58,16 +58,6 @@
 	return NULL;
 }
 
-static void all_accounts_del(int tid, int dir)
-{
-/* 	char name[ISCSI_NAME_LEN], pass[ISCSI_NAME_LEN]; */
-
-/* 	for (memset(name, 0, sizeof(name)); */
-/* 	     cops->account_query(tid, dir, name, pass) != -ENOENT;) { */
-/* 		cops->account_del(tid, dir, name); */
-/* 	} */
-}
-
 int target_del(int tid)
 {
 	int err;
@@ -89,9 +79,6 @@
 		exit(-1);
 	}
 
-	all_accounts_del(tid, AUTH_DIR_INCOMING);
-	all_accounts_del(tid, AUTH_DIR_OUTGOING);
-
 	free(target);
 
 	return 0;



From tomo at berlios.de  Fri Oct 28 16:16:35 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 16:16:35 +0200
Subject: [Stgt-svn] r130 - trunk/kernel
Message-ID: <200510281416.j9SEGZad019802@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 16:16:33 +0200 (Fri, 28 Oct 2005)
New Revision: 130

Modified:
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_vsd.c
Log:
Support INQUIRY commands with invalid lun. We assume that we always
have a lun 0 (that is, a lun 0 device is used as a device server). We
need to fix this later on.


Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-10-28 10:41:20 UTC (rev 129)
+++ trunk/kernel/tgt_scsi.c	2005-10-28 14:16:33 UTC (rev 130)
@@ -40,7 +40,7 @@
  */
 static uint64_t scsi_tgt_translate_lun(uint8_t *p, int size)
 {
-	uint64_t lun = ~0U;
+	uint64_t lun = ~0ULL;
 
 	switch (*p >> 6) {
 	case 0:
@@ -84,9 +84,19 @@
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	device = tgt_device_find(session->target, cmd->dev_id);
 	if (!device) {
-		printk(KERN_ERR "Could not find device if %" PRIu64 "\n",
-		       cmd->dev_id);
-		return NULL;
+		switch (scmd->scb[0]) {
+		case INQUIRY:
+		case REPORT_LUNS:
+			/* we assume that we have lun 0. */
+			device = tgt_device_find(session->target, 0);
+			break;
+		}
+
+		if (!device) {
+			eprintk("Could not find device %x %" PRIu64 "\n",
+				scmd->scb[0], cmd->dev_id);
+			return NULL;
+		}
 	}
 	cmd->device = device;
 
@@ -255,7 +265,6 @@
 	unsigned long flags;
 	int err, enabled, more;
 
-	/* FIXME: we need some tricks here. */
 	BUG_ON(!device);
 
 	spin_lock_irqsave(&stdev->lock, flags);

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-10-28 10:41:20 UTC (rev 129)
+++ trunk/kernel/tgt_vsd.c	2005-10-28 14:16:33 UTC (rev 130)
@@ -32,7 +32,7 @@
 		return -EINVAL;
 
 	device->size = inode->i_size;
-	printk("%d %llu\n", device->fd, inode->i_size >> 9);
+	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
 
 	return 0;
 }
@@ -110,7 +110,7 @@
 static int vsd_queue_file_io(struct tgt_cmd *cmd, int op)
 {
 	struct file *file = cmd->device->file;
-	ssize_t size;
+	ssize_t ret;
 	struct iovec *iov;
 	loff_t pos = cmd->offset;
 
@@ -119,32 +119,28 @@
 		return -ENOMEM;
 
 	if (op == READ)
-		size = generic_file_readv(file, iov, cmd->sg_count, &pos);
+		ret = generic_file_readv(file, iov, cmd->sg_count, &pos);
 	else
-		size = generic_file_writev(file, iov, cmd->sg_count, &pos);
+		ret = generic_file_writev(file, iov, cmd->sg_count, &pos);
 
 	kfree(iov);
 
-/* not yet used
-	if (sync)
-		err = sync_page_range(inode, inode->i_mapping, pos,
-				      (size_t) cmd->bufflen);
-*/
-	return size;
+	if (ret < 0 || ret != cmd->bufflen) {
+		eprintk("I/O error %d %Zd %u %lld %" PRIu64 "\n",
+			op, ret, cmd->bufflen, pos, cmd->device->size);
+		return -EINVAL;
+	}
+
+	/* sync_page_range(inode, inode->i_mapping, pos, (size_t) cmd->bufflen); */
+
+	return 0;
 }
 
 static int tgt_vsd_queue(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	struct tgt_device *device = cmd->device;
-	loff_t pos = cmd->offset;
-	int err = 0, rw;
+	int err, rw;
 
-	if (cmd->bufflen + pos > device->size) {
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMD_FAILED;
-	}
-
 	switch (scmd->scb[0]) {
 	case READ_6:
 	case READ_10:
@@ -165,8 +161,7 @@
 		if (err >= 0)
 			return TGT_CMD_USPACE_QUEUED;
 
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMD_FAILED;
+		goto failed;
 	};
 
 	/*
@@ -174,17 +169,18 @@
 	 * when we seperate the io_handlers
 	 */
 	err = vsd_queue_file_io(cmd, rw);
+	if (!err) {
+		cmd->result = SAM_STAT_GOOD;
+		return TGT_CMD_COMPLETED;
+	}
+
 	/*
 	 * we should to a switch but I am not sure of all the err values
 	 * returned. If you find one add it
 	 */
-	if (err != cmd->bufflen) {
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMD_FAILED;
-	} else {
-		cmd->result = SAM_STAT_GOOD;
-		return TGT_CMD_COMPLETED;
-	}
+failed:
+	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+	return TGT_CMD_FAILED;
 }
 
 static struct tgt_device_template tgt_vsd = {



From tomo at berlios.de  Fri Oct 28 16:41:07 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 16:41:07 +0200
Subject: [Stgt-svn] r131 - in trunk: istgt/kernel kernel
Message-ID: <200510281441.j9SEf7tN022057@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 16:41:07 +0200 (Fri, 28 Oct 2005)
New Revision: 131

Modified:
   trunk/istgt/kernel/config.c
   trunk/istgt/kernel/digest.c
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/kernel/session.c
   trunk/istgt/kernel/target.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_types.h
Log:
Disable to debug istgt code.


Modified: trunk/istgt/kernel/config.c
===================================================================
--- trunk/istgt/kernel/config.c	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/istgt/kernel/config.c	2005-10-28 14:41:07 UTC (rev 131)
@@ -5,8 +5,6 @@
  */
 
 #include <iscsi.h>
-#include <tgt.h>
-#include <tgt_target.h>
 
 static int add_conn(struct iscsi_target *target, struct conn_info *info)
 {

Modified: trunk/istgt/kernel/digest.c
===================================================================
--- trunk/istgt/kernel/digest.c	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/istgt/kernel/digest.c	2005-10-28 14:41:07 UTC (rev 131)
@@ -11,7 +11,6 @@
 
 #include <iscsi.h>
 #include <digest.h>
-#include <tgt.h>
 
 void digest_alg_available(unsigned int *val)
 {

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/istgt/kernel/iscsi.h	2005-10-28 14:41:07 UTC (rev 131)
@@ -310,4 +310,14 @@
 		(param)->data_digest);\
 }
 
+#undef dprintk
+
+#undef DEBUG_ISTGT
+
+#ifdef DEBUG_ISTGT
+#define dprintk eprintk
+#else
+#define dprintk(fmt, args...)
+#endif
+
 #endif	/* __ISCSI_H__ */

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/istgt/kernel/session.c	2005-10-28 14:41:07 UTC (rev 131)
@@ -7,7 +7,6 @@
 #include <linux/mempool.h>
 
 #include <iscsi.h>
-#include <tgt.h>
 
 struct iscsi_session *session_lookup(struct iscsi_target *target, uint64_t sid)
 {

Modified: trunk/istgt/kernel/target.c
===================================================================
--- trunk/istgt/kernel/target.c	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/istgt/kernel/target.c	2005-10-28 14:41:07 UTC (rev 131)
@@ -8,9 +8,6 @@
 
 #include <iscsi.h>
 #include <digest.h>
-#include <tgt.h>
-#include <tgt_device.h>
-#include <tgt_target.h>
 
 static DECLARE_MUTEX(target_list_sem);
 

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/kernel/tgt.h	2005-10-28 14:41:07 UTC (rev 131)
@@ -80,4 +80,19 @@
 extern void tgt_transfer_response(void *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
+
+
+#define DEBUG_TGT
+
+#define eprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+#ifdef DEBUG_TGT
+#define dprintk eprintk
+#else
+#define dprintk(fmt, args...)
 #endif
+
+#endif

Modified: trunk/kernel/tgt_types.h
===================================================================
--- trunk/kernel/tgt_types.h	2005-10-28 14:16:33 UTC (rev 130)
+++ trunk/kernel/tgt_types.h	2005-10-28 14:41:07 UTC (rev 131)
@@ -15,18 +15,4 @@
 # define PRIu64		__PRI64_PREFIX "u"
 # define PRIx64		__PRI64_PREFIX "x"
 
-
-#define DEBUG_TGT
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-#ifdef DEBUG_TGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
 #endif
-
-#endif



From tomo at berlios.de  Fri Oct 28 16:49:17 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 16:49:17 +0200
Subject: [Stgt-svn] r132 - trunk/istgt/kernel
Message-ID: <200510281449.j9SEnHNx022979@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 16:49:16 +0200 (Fri, 28 Oct 2005)
New Revision: 132

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/nthread.c
Log:
Fix compile warnings.


Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-10-28 14:41:07 UTC (rev 131)
+++ trunk/istgt/kernel/iscsi.c	2005-10-28 14:49:16 UTC (rev 132)
@@ -703,7 +703,7 @@
 static void __scsi_cmnd_done(void *data)
 {
 	struct tgt_cmd *tc = (struct tgt_cmd *) data;
-	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;;
+	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) tc->private;
 	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 	if (tc->result != SAM_STAT_GOOD) {

Modified: trunk/istgt/kernel/nthread.c
===================================================================
--- trunk/istgt/kernel/nthread.c	2005-10-28 14:41:07 UTC (rev 131)
+++ trunk/istgt/kernel/nthread.c	2005-10-28 14:49:16 UTC (rev 132)
@@ -604,7 +604,8 @@
 		BUG_ON(1);
 	}
 
-	eprintk("%d %llu %u\n", session->target->tid, session->sid, conn->cid);
+	eprintk("%d %" PRIu64 " %u\n",
+		session->target->tid, session->sid, conn->cid);
 
 	event_send(session->target->tt, session->target->tid,
 		   session->sid, conn->cid, E_CONN_CLOSE);



From tomo at berlios.de  Fri Oct 28 17:17:10 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 17:17:10 +0200
Subject: [Stgt-svn] r133 - in trunk: . ibmvstgt ibmvstgt/kernel
Message-ID: <200510281517.j9SFHA1A025265@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 17:17:09 +0200 (Fri, 28 Oct 2005)
New Revision: 133

Added:
   trunk/ibmvstgt/
   trunk/ibmvstgt/Makefile
   trunk/ibmvstgt/kernel/
   trunk/ibmvstgt/kernel/Makefile
   trunk/ibmvstgt/kernel/ibmvstgt.c
Modified:
   trunk/Makefile
Log:
Add ibmvstgt driver (IBM virtual SCSI target). The user-space code is
not finished. So this driver does not work yet.


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2005-10-28 14:49:16 UTC (rev 132)
+++ trunk/Makefile	2005-10-28 15:17:09 UTC (rev 133)
@@ -7,6 +7,9 @@
 export KERNELSRC
 
 all:
+ifeq ($(ARCH), ppc64)
+	make -C ibmvstgt
+endif
 	make -C istgt
 
 	make -C usr
@@ -15,4 +18,7 @@
 	make -C usr clean
 	make -C kernel clean
 
+ifeq ($(ARCH), ppc64)
+	make -C ibmvstgt clean
+endif
 	make -C istgt clean

Added: trunk/ibmvstgt/Makefile
===================================================================
--- trunk/ibmvstgt/Makefile	2005-10-28 14:49:16 UTC (rev 132)
+++ trunk/ibmvstgt/Makefile	2005-10-28 15:17:09 UTC (rev 133)
@@ -0,0 +1,22 @@
+#
+# Makefile for the Linux kernel device drivers.
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (not a .c file).
+#
+# Note 2! The CFLAGS definitions are now in the main makefile.
+
+SUBDIRS := $(shell pwd)
+
+all: mods
+
+mods:
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
+
+libs:
+	$(MAKE) -C usr
+
+clean:
+#	$(MAKE) -C usr clean
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Added: trunk/ibmvstgt/kernel/Makefile
===================================================================
--- trunk/ibmvstgt/kernel/Makefile	2005-10-28 14:49:16 UTC (rev 132)
+++ trunk/ibmvstgt/kernel/Makefile	2005-10-28 15:17:09 UTC (rev 133)
@@ -0,0 +1,20 @@
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -I$(obj)/../../kernel \
+		-I$(KERNELSRC)/drivers/scsi/ibmvscsi/
+
+ifneq ($(KERNELRELEASE),)
+obj-m		+= ibmvstgt.o
+
+else
+
+ifeq ($(KERNELSRC),)
+	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
+endif
+
+PWD := $(shell pwd)
+
+default:
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) clean
+endif

Added: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-10-28 14:49:16 UTC (rev 132)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-10-28 15:17:09 UTC (rev 133)
@@ -0,0 +1,1254 @@
+/*
+ * IBM eServer i/pSeries Virtual SCSI Target Driver
+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
+ *
+ * Rewritten for Linux target framework by FUJITA Tomonori <tomof at acm.org>
+ *
+ * This code is licenced under the GPL2.
+ */
+
+#include <linux/module.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tcq.h>
+#include <linux/mempool.h>
+
+#include <asm/hvcall.h>
+#include <asm/vio.h>
+#include <asm/iommu.h>
+#include <asm/prom.h>
+
+#include <tgt.h>
+#include <tgt_target.h>
+#include <tgt_scsi.h>
+#include <tgt_protocol.h>
+
+#include "viosrp.h"
+
+#define DEFAULT_TIMEOUT		30*HZ
+#define	INITIAL_SRP_LIMIT	16
+#define	DEFAULT_MAX_SECTORS	512
+
+#define	TGT_NAME	"ibmvstgt"
+
+#define	vio_iu(iue)\
+	((union viosrp_iu *) ((char *) (iue) + sizeof(struct iu_entry)))
+
+#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
+#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
+#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
+
+/*
+ * Hypervisor calls.
+ */
+#define h_copy_rdma(l, sa, sb, da, db) \
+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
+#define h_send_crq(ua, l, h) \
+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
+#define h_reg_crq(ua, tok, sz)\
+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
+#define h_free_crq(ua) \
+			plpar_hcall_norets(H_FREE_CRQ, ua);
+
+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
+MODULE_AUTHOR("Dave Boutcher");
+MODULE_LICENSE("GPL");
+
+
+/*
+ * an RPA command/response transport queue.  This is our structure
+ * that points to the actual queue (not architected by firmware)
+ */
+struct crq_queue {
+	struct viosrp_crq *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+	spinlock_t lock;
+};
+
+/* all driver data associated with a host adapter */
+struct server_adapter {
+	struct device *dev;
+	struct vio_dev *dma_dev;
+
+	struct crq_queue crq_queue;
+	struct work_struct crq_work;
+	mempool_t *iu_pool;
+
+	spinlock_t lock; /* cmd_queue and next_rsp_delta */
+	struct list_head cmd_queue;
+	int next_rsp_delta;
+
+	unsigned long liobn;
+	unsigned long riobn;
+
+	int max_sectors;
+
+	struct tgt_target *tt;
+	struct tgt_session *ts;
+};
+
+enum iue_flags {
+	V_DIOVER,
+	V_WRITE,
+	V_LINKED,
+	V_ABORTED,
+	V_FLYING,
+	V_DONE,
+};
+
+/*
+ * This structure tracks our fundamental unit of work.  Whenever
+ * an SRP Information Unit (IU) arrives, we track all the good stuff
+ * here
+ */
+struct iu_entry {
+	struct server_adapter *adapter;
+
+	struct list_head ilist;
+	dma_addr_t iu_token;
+
+	struct {
+		dma_addr_t remote_token;
+		char *sense;
+		unsigned long flags;
+		int data_out_residual_count;
+		int data_in_residual_count;
+		int timeout;
+	} req;
+
+	struct tgt_cmd *tc;
+};
+
+
+static kmem_cache_t *iu_cache;
+
+/*
+ * These are fixed for the system and come from the Open Firmware device tree.
+ * We just store them here to save getting them every time.
+ */
+static char system_id[64] = "";
+static char partition_name[97] = "UNKNOWN";
+static unsigned int partition_number = -1;
+
+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
+{
+	long rc, rc1;
+	union {
+		struct viosrp_crq cooked;
+		uint64_t raw[2];
+	} crq;
+
+	/* First copy the SRP */
+	rc = h_copy_rdma(length, iue->adapter->liobn, iue->iu_token,
+			 iue->adapter->riobn, iue->req.remote_token);
+
+	if (rc)
+		eprintk("Error %ld transferring data\n", rc);
+
+	crq.cooked.valid = 0x80;
+	crq.cooked.format = format;
+	crq.cooked.reserved = 0x00;
+	crq.cooked.timeout = 0x00;
+	crq.cooked.IU_length = length;
+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.generic.tag;
+
+	if (rc == 0)
+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
+	else
+		crq.cooked.status = 0x00;
+
+	rc1 = h_send_crq(iue->adapter->dma_dev->unit_address,
+			 crq.raw[0], crq.raw[1]);
+
+	if (rc1) {
+		eprintk("%ld sending response\n", rc1);
+		return rc1;
+	}
+
+	return rc;
+}
+
+static int send_rsp(struct iu_entry *iue, unsigned char status,
+		    unsigned char asc)
+{
+	union viosrp_iu *iu = vio_iu(iue);
+	uint8_t *sense = iu->srp.rsp.sense_and_response_data;
+	uint64_t tag = iu->srp.generic.tag;
+	unsigned long flags;
+
+	/* If the linked bit is on and status is good */
+	if (test_bit(V_LINKED, &iue->req.flags) && (status == NO_SENSE))
+		status = 0x10;
+
+	memset(iu, 0, sizeof(struct srp_rsp));
+	iu->srp.rsp.type = SRP_RSP_TYPE;
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+	iu->srp.rsp.request_limit_delta = 1 + iue->adapter->next_rsp_delta;
+	iue->adapter->next_rsp_delta = 0;
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+	iu->srp.rsp.tag = tag;
+
+	iu->srp.rsp.diover = test_bit(V_DIOVER, &iue->req.flags) ? 1 : 0;
+
+	iu->srp.rsp.data_in_residual_count = iue->req.data_in_residual_count;
+	iu->srp.rsp.data_out_residual_count = iue->req.data_out_residual_count;
+
+	iu->srp.rsp.rspvalid = 0;
+
+	iu->srp.rsp.response_data_list_length = 0;
+
+	if (status && !iue->req.sense) {
+		iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
+		iu->srp.rsp.snsvalid = 1;
+		iu->srp.rsp.sense_data_list_length = 18;
+
+		/* Valid bit and 'current errors' */
+		sense[0] = (0x1 << 7 | 0x70);
+
+		/* Sense key */
+		sense[2] = status;
+
+		/* Additional sense length */
+		sense[7] = 0xa;	/* 10 bytes */
+
+		/* Additional sense code */
+		sense[12] = asc;
+	} else {
+		if (iue->req.sense) {
+			iu->srp.rsp.snsvalid = 1;
+			iu->srp.rsp.sense_data_list_length =
+							SCSI_SENSE_BUFFERSIZE;
+			memcpy(sense, iue->req.sense, SCSI_SENSE_BUFFERSIZE);
+		}
+		iu->srp.rsp.status = status;
+	}
+
+	send_iu(iue, sizeof(iu->srp.rsp), VIOSRP_SRP_FORMAT);
+
+	return 0;
+}
+
+static int data_out_desc_size(struct srp_cmd *cmd)
+{
+	int size = 0;
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		break;
+	case SRP_DIRECT_BUFFER:
+		size = sizeof(struct memory_descriptor);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		size = sizeof(struct indirect_descriptor) +
+			sizeof(struct memory_descriptor) * (cmd->data_out_count - 1);
+		break;
+	default:
+		eprintk("client error. Invalid data_out_format %d\n",
+			cmd->data_out_format);
+		break;
+	}
+	return size;
+}
+
+static int vscsis_data_length(struct srp_cmd *cmd, int out)
+{
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int format, len = 0, offset = cmd->additional_cdb_len * 4;
+
+	if (out)
+		format = cmd->data_out_format;
+	else {
+		format = cmd->data_in_format;
+		offset += data_out_desc_size(cmd);
+	}
+
+	switch (format) {
+	case SRP_NO_BUFFER:
+		break;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)
+			(cmd->additional_data + offset);
+		len = md->length;
+		break;
+	case SRP_INDIRECT_BUFFER:
+		id = (struct indirect_descriptor *)
+			(cmd->additional_data + offset);
+		len = id->total_length;
+		break;
+	default:
+		eprintk("invalid data format %d\n", format);
+		break;
+	}
+	return len;
+}
+
+static uint8_t getcontrolbyte(uint8_t *cdb)
+{
+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
+}
+
+static inline uint8_t getlink(struct iu_entry *iue)
+{
+	return (getcontrolbyte(vio_iu(iue)->srp.cmd.cdb) & 0x01);
+}
+
+static int process_cmd(struct iu_entry *iue)
+{
+	struct tgt_target *tt = iue->adapter->tt;
+	struct tgt_protocol *proto;
+	union viosrp_iu *iu = vio_iu(iue);
+	enum dma_data_direction data_dir;
+	int tags, len;
+	uint8_t lun[8];
+
+	dprintk("%p %p %p\n", tt, iue->adapter, iue);
+	proto = tt->proto;
+	BUG_ON(!proto);
+
+	if (getlink(iue))
+		__set_bit(V_LINKED, &iue->req.flags);
+
+	switch (iu->srp.cmd.task_attribute) {
+	case SRP_SIMPLE_TASK:
+		tags = MSG_SIMPLE_TAG;
+		break;
+	case SRP_ORDERED_TASK:
+		tags = MSG_ORDERED_TAG;
+		break;
+	case SRP_HEAD_TASK:
+		tags = MSG_HEAD_TAG;
+		break;
+	default:
+		eprintk("Task attribute %d not supported, assuming barrier\n",
+			iu->srp.cmd.task_attribute);
+		tags = MSG_ORDERED_TAG;
+	}
+
+	switch (iu->srp.cmd.cdb[0]) {
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_VERIFY:
+	case WRITE_12:
+	case WRITE_VERIFY_12:
+		__set_bit(V_WRITE, &iue->req.flags);
+	}
+
+	memset(lun, 0, sizeof(lun));
+	/* FIXME */
+	lun[1] = GETLUN(iu->srp.cmd.lun);
+	if (GETBUS(iu->srp.cmd.lun) || GETTARGET(iu->srp.cmd.lun))
+		lun[0] = 3 << 6;
+
+	if (iu->srp.cmd.data_out_format) {
+		data_dir = DMA_TO_DEVICE;
+		len = vscsis_data_length(&iu->srp.cmd, 1);
+	} else {
+		data_dir = DMA_FROM_DEVICE;
+		len = vscsis_data_length(&iu->srp.cmd, 0);
+	}
+
+	dprintk("%p %x %lx %d %d %x %d\n",
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, lun[1], tags);
+
+	BUG_ON(!iue->adapter->ts);
+	BUG_ON(!proto->create_cmd);
+	iue->tc = proto->create_cmd(iue->adapter->ts, iue, iu->srp.cmd.cdb,
+				    len, data_dir, lun, sizeof(lun), tags);
+	BUG_ON(!iue->tc);
+	dprintk("%p\n", iue->tc);
+
+	return 0;
+}
+
+static void handle_cmd_queue(struct server_adapter *adapter)
+{
+	struct iu_entry *iue;
+	unsigned long flags;
+
+retry:
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	list_for_each_entry(iue, &adapter->cmd_queue, ilist) {
+		if (!test_and_set_bit(V_FLYING, &iue->req.flags)) {
+			spin_unlock_irqrestore(&adapter->lock, flags);
+			process_cmd(iue);
+			goto retry;
+		}
+	}
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+}
+
+#define SEND	0
+#define RECV	1
+
+static int direct_data(struct tgt_cmd *tc, struct memory_descriptor *md, int op)
+{
+	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct server_adapter *adapter = iue->adapter;
+	struct scatterlist *sg = tc->sg;
+	unsigned int rest, len;
+	int i, done, nsg;
+	long err;
+	dma_addr_t token;
+
+	dprintk("%p %u %u %d\n", iue, tc->bufflen, md->length, tc->sg_count);
+
+	nsg = dma_map_sg(adapter->dev, sg, tc->sg_count, DMA_BIDIRECTIONAL);
+	if (!nsg) {
+		eprintk("fail to map %p %d\n", iue, tc->sg_count);
+		return 0;
+	}
+
+	rest = min(tc->bufflen, md->length);
+
+	for (i = 0, done = 0; i < nsg && rest; i++) {
+		token = sg_dma_address(sg + i);
+		len = min(sg_dma_len(sg + i), rest);
+
+		if (op == SEND)
+			err = h_copy_rdma(len, adapter->liobn,
+					  token,
+					  adapter->riobn,
+					  md->virtual_address + done);
+		else
+			err = h_copy_rdma(len, adapter->riobn,
+					  md->virtual_address + done,
+					  adapter->liobn,
+					  token);
+
+		if (err != H_Success) {
+			eprintk("rdma error %d %d %ld\n", op, i, err);
+			break;
+		}
+
+		rest -= len;
+		done += len;
+	}
+
+	dma_unmap_sg(adapter->dev, sg, nsg, DMA_BIDIRECTIONAL);
+
+	return done;
+}
+
+static int indirect_data(struct tgt_cmd *tc, struct indirect_descriptor *id,
+			 int op)
+{
+	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct server_adapter *adapter = iue->adapter;
+	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
+	struct memory_descriptor *mds;
+	struct scatterlist *sg = tc->sg;
+	dma_addr_t token, itoken = 0;
+	long err;
+	unsigned int rest, done = 0;
+	int i, nmd, nsg, sidx, soff;
+
+	nmd = id->head.length / sizeof(struct memory_descriptor);
+
+	dprintk("%p %u %u %lu %d %d %d\n",
+		iue, tc->bufflen, id->total_length, tc->offset, nmd,
+		cmd->data_in_count, cmd->data_out_count);
+
+	if ((op == SEND && nmd == cmd->data_in_count) ||
+	    (op == RECV && nmd == cmd->data_out_count)) {
+		mds = &id->list[0];
+		goto rdma;
+	}
+
+	mds = dma_alloc_coherent(adapter->dev, id->head.length,
+				 &itoken, GFP_KERNEL);
+	if (!mds) {
+		eprintk("Can't get dma memory %d\n", id->head.length);
+		return 0;
+	}
+
+	err = h_copy_rdma(id->head.length, adapter->riobn,
+			  id->head.virtual_address, adapter->liobn, itoken);
+	if (err != H_Success) {
+		eprintk("Error copying indirect table %ld\n", err);
+		goto free_mem;
+	}
+
+rdma:
+	nsg = dma_map_sg(adapter->dev, sg, tc->sg_count, DMA_BIDIRECTIONAL);
+	if (!nsg) {
+		eprintk("fail to map %p %d\n", iue, tc->sg_count);
+		goto free_mem;
+	}
+
+	sidx = soff = 0;
+	token = sg_dma_address(sg + sidx);
+	rest = min(tc->bufflen, id->total_length);
+	for (i = 0; i < nmd && rest; i++) {
+		unsigned int mdone, mlen;
+
+		mlen = min(rest, mds[i].length);
+		for (mdone = 0; mlen;) {
+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
+
+			if (op == SEND)
+				err = h_copy_rdma(slen,
+						  adapter->liobn,
+						  token + soff,
+						  adapter->riobn,
+						  mds[i].virtual_address + mdone);
+			else
+				err = h_copy_rdma(slen,
+						  adapter->riobn,
+						  mds[i].virtual_address + mdone,
+						  adapter->liobn,
+						  token + soff);
+
+			if (err != H_Success) {
+				eprintk("rdma error %d %d\n", op, slen);
+				goto unmap_sg;
+			}
+
+			mlen -= slen;
+			mdone += slen;
+			soff += slen;
+			done += slen;
+
+			if (soff == sg_dma_len(sg + sidx)) {
+				sidx++;
+				soff = 0;
+				token = sg_dma_address(sg + sidx);
+
+				if (sidx > nsg) {
+					eprintk("out of sg %p %d %d %d\n",
+						iue, sidx, nsg, tc->sg_count);
+					goto unmap_sg;
+				}
+			}
+		};
+
+		rest -= mlen;
+	}
+
+unmap_sg:
+	dma_unmap_sg(adapter->dev, sg, nsg, DMA_BIDIRECTIONAL);
+
+free_mem:
+	if (itoken)
+		dma_free_coherent(adapter->dev, id->head.length, mds, itoken);
+
+	return done;
+}
+
+static int handle_cmd_data(struct tgt_cmd *tc, int op)
+{
+	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset, err = 0;
+	uint8_t format;
+
+	offset = cmd->additional_cdb_len * 4;
+	if (op == SEND)
+		offset += data_out_desc_size(cmd);
+
+	format = (op == SEND) ? cmd->data_in_format : cmd->data_out_format;
+
+	switch (format) {
+	case SRP_NO_BUFFER:
+		break;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)
+			(cmd->additional_data + offset);
+		err = direct_data(tc, md, op);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		id = (struct indirect_descriptor *)
+			(cmd->additional_data + offset);
+		err = indirect_data(tc, id, op);
+		break;
+	default:
+		eprintk("Unknown format %d %d\n", op, format);
+		break;
+	}
+
+	return err;
+}
+
+static int recv_cmd_data(struct tgt_cmd *tc)
+{
+	dprintk("%p\n", tc);
+
+	handle_cmd_data(tc, RECV);
+	tc->done(tc);
+
+	return 0;
+}
+
+static struct iu_entry *get_iu(struct server_adapter *adapter)
+{
+	struct iu_entry *iue;
+
+	iue = mempool_alloc(adapter->iu_pool, GFP_ATOMIC);
+	if (!iue)
+		return NULL;
+
+	memset(&iue->req, 0, sizeof(iue->req));
+	iue->adapter = adapter;
+	INIT_LIST_HEAD(&iue->ilist);
+	iue->tc = NULL;
+
+	iue->iu_token = dma_map_single(adapter->dev, vio_iu(iue),
+				       sizeof(union viosrp_iu),
+				       DMA_BIDIRECTIONAL);
+	if (dma_mapping_error(iue->iu_token)) {
+		mempool_free(iue, adapter->iu_pool);
+		iue = NULL;
+	}
+
+	return iue;
+}
+
+static void put_iu(struct iu_entry *iue)
+{
+	struct server_adapter *adapter = iue->adapter;
+
+	dprintk("%p %p\n", adapter, iue);
+
+	if (iue->tc)
+		iue->tc->done(iue->tc);
+
+	dma_unmap_single(adapter->dev, iue->iu_token,
+			 sizeof(union viosrp_iu), DMA_BIDIRECTIONAL);
+
+	mempool_free(iue, adapter->iu_pool);
+}
+
+static int ibmvstgt_cmd_done(struct tgt_cmd *tc)
+{
+	int sent = 0;
+	unsigned long flags;
+	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct server_adapter *adapter = iue->adapter;
+
+	dprintk("%p %p %p %x\n", tc, iue, adapter, vio_iu(iue)->srp.cmd.cdb[0]);
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	list_del(&iue->ilist);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	if (tc->result != SAM_STAT_GOOD) {
+		eprintk("operation failed %p %d %x\n",
+			iue, tc->result, vio_iu(iue)->srp.cmd.cdb[0]);
+		send_rsp(iue, HARDWARE_ERROR, 0x00);
+		goto out;
+	}
+
+	/* FIXME */
+	switch (vio_iu(iue)->srp.cmd.cdb[0]) {
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_12:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	case WRITE_VERIFY_12:
+	case START_STOP:
+	case TEST_UNIT_READY:
+	case SYNCHRONIZE_CACHE:
+	case VERIFY:
+	case VERIFY_16:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+		send_rsp(iue, NO_SENSE, 0x00);
+		goto out;
+	default:
+		break;
+	}
+
+	sent = handle_cmd_data(tc, SEND);
+	if (sent != tc->bufflen) {
+		eprintk("sending data on response %p (tried %u, sent %d\n",
+			iue, tc->bufflen, sent);
+		send_rsp(iue, ABORTED_COMMAND, 0x00);
+	} else
+		send_rsp(iue, NO_SENSE, 0x00);
+
+out:
+	put_iu(iue);
+
+	return TGT_CMD_XMIT_OK;
+}
+
+int send_adapter_info(struct iu_entry *iue,
+		      dma_addr_t remote_buffer, uint16_t length)
+{
+	struct server_adapter *adapter = iue->adapter;
+	dma_addr_t data_token;
+	struct mad_adapter_info_data *info;
+	int err;
+
+	info = dma_alloc_coherent(adapter->dev, sizeof(*info),
+				  &data_token, GFP_KERNEL);
+
+	if (!info) {
+		eprintk("bad dma_alloc_coherent %p\n", adapter);
+		return 1;
+	}
+
+	/* Get remote info */
+	err = h_copy_rdma(sizeof(*info), adapter->riobn, remote_buffer,
+			  adapter->liobn, data_token);
+	if (err == H_Success) {
+		eprintk("Client connect: %s (%d)\n",
+			info->partition_name, info->partition_number);
+	}
+
+	memset(info, 0, sizeof(*info));
+
+	strcpy(info->srp_version, "16.a");
+	strncpy(info->partition_name, partition_name,
+		sizeof(info->partition_name));
+	info->partition_number = partition_number;
+	info->mad_version = 1;
+	info->os_type = 2;
+	info->port_max_txu[0] = adapter->max_sectors << 9;
+
+	/* Send our info to remote */
+	err = h_copy_rdma(sizeof(*info), adapter->liobn, data_token,
+			  adapter->riobn, remote_buffer);
+
+	dma_free_coherent(adapter->dev, sizeof(*info), info,
+			  data_token);
+
+	if (err != H_Success) {
+		eprintk("Error sending adapter info %d\n", err);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void process_login(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = vio_iu(iue);
+	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
+
+	uint64_t tag = iu->srp.generic.tag;
+
+	/* TODO handle case that requested size is wrong and
+	 * buffer format is wrong
+	 */
+	memset(iu, 0, sizeof(struct srp_login_rsp));
+	rsp->type = SRP_LOGIN_RSP_TYPE;
+	rsp->request_limit_delta = INITIAL_SRP_LIMIT;
+	rsp->tag = tag;
+	rsp->max_initiator_to_target_iulen = sizeof(union srp_iu);
+	rsp->max_target_to_initiator_iulen = sizeof(union srp_iu);
+	/* direct and indirect */
+	rsp->supported_buffer_formats = 0x0006;
+	rsp->multi_channel_result = 0x00;
+
+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
+}
+
+static inline void queue_cmd(struct iu_entry *iue)
+{
+	struct server_adapter *adapter = iue->adapter;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	list_add_tail(&iue->ilist, &iue->adapter->cmd_queue);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+	handle_cmd_queue(adapter);
+}
+
+/* TODO */
+static void process_device_reset(struct iu_entry *iue)
+{
+	send_rsp(iue, NO_SENSE, 0x00);
+}
+
+static void process_abort(struct iu_entry *iue)
+{
+	unsigned char status = ABORTED_COMMAND;
+
+	send_rsp(iue, status, 0x14);
+}
+
+static void process_tsk_mgmt(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = vio_iu(iue);
+	uint8_t flags = iu->srp.tsk_mgmt.task_mgmt_flags;
+
+	eprintk("Not supported yet %p %x\n", iue, flags);
+
+	if (flags == 0x01)
+		process_abort(iue);
+	else if (flags == 0x08)
+		process_device_reset(iue);
+	else
+		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
+}
+
+static int process_mad_iu(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = vio_iu(iue);
+	struct viosrp_adapter_info *info;
+	struct viosrp_host_config *conf;
+
+	dprintk("%p %d\n", iue, iu->mad.empty_iu.common.type);
+
+	switch (iu->mad.empty_iu.common.type) {
+	case VIOSRP_EMPTY_IU_TYPE:
+		eprintk("%s\n", "Unsupported EMPTY MAD IU");
+		break;
+	case VIOSRP_ERROR_LOG_TYPE:
+		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
+		iu->mad.error_log.common.status = 1;
+		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
+		break;
+	case VIOSRP_ADAPTER_INFO_TYPE:
+		info = &iu->mad.adapter_info;
+
+		info->common.status = send_adapter_info(iue, info->buffer,
+							info->common.length);
+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
+		break;
+	case VIOSRP_HOST_CONFIG_TYPE:
+		conf = &iu->mad.host_config;
+
+		conf->common.status = 1;
+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
+		break;
+	default:
+		eprintk("Unknown type %d\n", iu->srp.generic.type);
+	}
+
+	return 1;
+}
+
+static int process_srp_iu(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = vio_iu(iue);
+	int done = 1;
+
+	dprintk("%p %d\n", iue, iu->srp.generic.type);
+
+	switch (iu->srp.generic.type) {
+	case SRP_LOGIN_REQ_TYPE:
+		process_login(iue);
+		break;
+	case SRP_TSK_MGMT_TYPE:
+		process_tsk_mgmt(iue);
+		break;
+	case SRP_CMD_TYPE:
+		queue_cmd(iue);
+		done = 0;
+		break;
+	case SRP_LOGIN_RSP_TYPE:
+	case SRP_I_LOGOUT_TYPE:
+	case SRP_T_LOGOUT_TYPE:
+	case SRP_RSP_TYPE:
+	case SRP_CRED_REQ_TYPE:
+	case SRP_CRED_RSP_TYPE:
+	case SRP_AER_REQ_TYPE:
+	case SRP_AER_RSP_TYPE:
+		eprintk("Unsupported type %d\n", iu->srp.generic.type);
+		break;
+	default:
+		eprintk("Unknown type %d\n", iu->srp.generic.type);
+	}
+
+	return done;
+}
+
+static void process_iu(struct viosrp_crq *crq, struct server_adapter *adapter)
+{
+	struct iu_entry *iue;
+	long err, done;
+
+	iue = get_iu(adapter);
+	if (!iue) {
+		eprintk("Error getting IU from pool, %p\n", adapter);
+		return;
+	}
+
+	dprintk("%p %p\n", adapter, iue);
+
+	iue->req.remote_token = crq->IU_data_ptr;
+	iue->req.timeout= crq->timeout ? crq->timeout * HZ : DEFAULT_TIMEOUT;
+
+	err = h_copy_rdma(crq->IU_length, iue->adapter->riobn,
+			  iue->req.remote_token, adapter->liobn, iue->iu_token);
+
+	if (err != H_Success)
+		eprintk("%ld transferring data error %p\n", err, iue);
+
+	if (crq->format == VIOSRP_MAD_FORMAT)
+		done = process_mad_iu(iue);
+	else
+		done = process_srp_iu(iue);
+
+	if (done)
+		put_iu(iue);
+}
+
+static irqreturn_t ibmvstgt_interrupt(int irq, void *dev_instance,
+				      struct pt_regs *regs)
+{
+	struct server_adapter *adapter = (struct server_adapter *)dev_instance;
+
+	vio_disable_interrupts(adapter->dma_dev);
+	kblockd_schedule_work(&adapter->crq_work);
+
+	return IRQ_HANDLED;
+}
+
+static int crq_queue_create(struct crq_queue *queue,
+			    struct server_adapter *adapter)
+{
+	int err;
+
+	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
+	if (!queue->msgs)
+		goto malloc_failed;
+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
+
+	queue->msg_token = dma_map_single(adapter->dev, queue->msgs,
+					  queue->size * sizeof(*queue->msgs),
+					  DMA_BIDIRECTIONAL);
+
+	if (dma_mapping_error(queue->msg_token))
+		goto map_failed;
+
+	err = h_reg_crq(adapter->dma_dev->unit_address, queue->msg_token,
+			PAGE_SIZE);
+
+	/* If the adapter was left active for some reason (like kexec)
+	 * try freeing and re-registering
+	 */
+	if (err == H_Resource) {
+	    do {
+		err = h_free_crq(adapter->dma_dev->unit_address);
+	    } while (err == H_Busy || H_isLongBusy(err));
+
+	    err = h_reg_crq(adapter->dma_dev->unit_address, queue->msg_token,
+			    PAGE_SIZE);
+	}
+
+	if (err != H_Success && err != 2) {
+		eprintk("Error 0x%x opening virtual adapter\n", err);
+		goto reg_crq_failed;
+	}
+
+	err = request_irq(adapter->dma_dev->irq, &ibmvstgt_interrupt,
+			  SA_INTERRUPT, "ibmvstgt", adapter);
+	if (err)
+		goto req_irq_failed;
+
+	vio_enable_interrupts(adapter->dma_dev);
+
+	h_send_crq(adapter->dma_dev->unit_address, 0xC001000000000000, 0);
+
+	queue->cur = 0;
+	spin_lock_init(&queue->lock);
+
+	return 0;
+
+req_irq_failed:
+	do {
+		err = h_free_crq(adapter->dma_dev->unit_address);
+	} while (err == H_Busy || H_isLongBusy(err));
+
+reg_crq_failed:
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+map_failed:
+	free_page((unsigned long) queue->msgs);
+
+malloc_failed:
+	return -ENOMEM;
+}
+
+static void crq_queue_destroy(struct server_adapter *adapter)
+{
+	struct crq_queue *queue = &adapter->crq_queue;
+	int err;
+
+	free_irq(adapter->dma_dev->irq, adapter);
+	do {
+		err = h_free_crq(adapter->dma_dev->unit_address);
+	} while (err == H_Busy || H_isLongBusy(err));
+
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+
+	free_page((unsigned long) queue->msgs);
+}
+
+static void process_crq(struct viosrp_crq *crq,
+			struct server_adapter *adapter)
+{
+	dprintk("%x %x\n", crq->valid, crq->format);
+
+	switch (crq->valid) {
+	case 0xC0:
+		/* initialization */
+		switch (crq->format) {
+		case 0x01:
+			h_send_crq(adapter->dma_dev->unit_address,
+				   0xC002000000000000, 0);
+			break;
+		case 0x02:
+			break;
+		default:
+			eprintk("Unknown format %u\n", crq->format);
+		}
+		break;
+	case 0xFF:
+		/* transport event */
+		break;
+	case 0x80:
+		/* real payload */
+		switch (crq->format) {
+		case VIOSRP_SRP_FORMAT:
+		case VIOSRP_MAD_FORMAT:
+			process_iu(crq, adapter);
+			break;
+		case VIOSRP_OS400_FORMAT:
+		case VIOSRP_AIX_FORMAT:
+		case VIOSRP_LINUX_FORMAT:
+		case VIOSRP_INLINE_FORMAT:
+			eprintk("Unsupported format %u\n", crq->format);
+			break;
+		default:
+			eprintk("Unknown format %u\n", crq->format);
+		}
+		break;
+	default:
+		eprintk("unknown message type 0x%02x!?\n", crq->valid);
+	}
+}
+
+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
+{
+	struct viosrp_crq *crq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	crq = &queue->msgs[queue->cur];
+	if (crq->valid & 0x80) {
+		if (++queue->cur == queue->size)
+			queue->cur = 0;
+	} else
+		crq = NULL;
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return crq;
+}
+
+static void handle_crq(void *data)
+{
+	struct server_adapter *adapter = (struct server_adapter *) data;
+	struct viosrp_crq *crq;
+	int done = 0;
+
+	while (!done) {
+		while ((crq = next_crq(&adapter->crq_queue)) != NULL) {
+			process_crq(crq, adapter);
+			crq->valid = 0x00;
+		}
+
+		vio_enable_interrupts(adapter->dma_dev);
+
+		crq = next_crq(&adapter->crq_queue);
+		if (crq) {
+			vio_disable_interrupts(adapter->dma_dev);
+			process_crq(crq, adapter);
+			crq->valid = 0x00;
+		} else
+			done = 1;
+	}
+
+	handle_cmd_queue(adapter);
+}
+
+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
+{
+	struct tgt_target *tt;
+	struct server_adapter *adapter;
+	unsigned int *dma, dma_size;
+	int err = -ENOMEM;
+
+	dprintk("%s %s %x %u\n", dev->name, dev->type,
+		dev->unit_address, dev->irq);
+
+	tt = tgt_target_create(TGT_NAME, INITIAL_SRP_LIMIT);
+	if (!tt)
+		return err;
+
+	adapter = tt->tt_data;
+
+	dprintk("%p %p\n", tt, adapter);
+
+	adapter->tt = tt;
+	adapter->dma_dev = dev;
+	adapter->dev = &dev->dev;
+	adapter->dev->driver_data = adapter;
+	adapter->next_rsp_delta = 0;
+	adapter->max_sectors = DEFAULT_MAX_SECTORS;
+	spin_lock_init(&adapter->lock);
+
+	dma = (unsigned int *)
+		vio_get_attribute(dev, "ibm,my-dma-window", &dma_size);
+	if (!dma || dma_size != 40) {
+		eprintk("Couldn't get window property %d\n", dma_size);
+		err = -EIO;
+		goto free_tt;
+	}
+
+	adapter->liobn = dma[0];
+	adapter->riobn = dma[5];
+
+	INIT_WORK(&adapter->crq_work, handle_crq, adapter);
+	INIT_LIST_HEAD(&adapter->cmd_queue);
+
+	adapter->ts = tgt_session_create(tt, INITIAL_SRP_LIMIT,
+					 NULL, NULL);
+	if (!adapter->ts)
+		goto free_tt;
+
+	adapter->iu_pool = mempool_create(INITIAL_SRP_LIMIT,
+					  mempool_alloc_slab,
+					  mempool_free_slab, iu_cache);
+	if (!adapter->iu_pool)
+		goto free_ts;
+
+	err = crq_queue_create(&adapter->crq_queue, adapter);
+	if (err)
+		goto free_pool;
+
+	return 0;
+
+free_pool:
+	mempool_destroy(adapter->iu_pool);
+free_ts:
+	tgt_session_destroy(adapter->ts);
+free_tt:
+	tgt_target_destroy(tt);
+
+	return err;
+}
+
+static int ibmvstgt_remove(struct vio_dev *dev)
+{
+	struct server_adapter *adapter =
+		(struct server_adapter *) dev->dev.driver_data;
+	struct tgt_target *tt = adapter->tt;
+
+	crq_queue_destroy(adapter);
+	mempool_destroy(adapter->iu_pool);
+	tgt_session_destroy(adapter->ts);
+
+	tgt_target_destroy(tt);
+
+	return 0;
+}
+
+static struct tgt_target_template ibmvstgt_template = {
+	.name = TGT_NAME,
+	.module = THIS_MODULE,
+	.protocol = "scsi",
+	.transfer_response = ibmvstgt_cmd_done,
+	.transfer_write_data = recv_cmd_data,
+	.priv_data_size = sizeof(struct server_adapter),
+};
+
+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
+	{"v-scsi-host", "IBM,v-scsi-host"},
+	{"",""}
+};
+
+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
+
+static struct vio_driver ibmvstgt_driver = {
+	.name = "ibmvscsi",
+	.id_table = ibmvstgt_device_table,
+	.probe = ibmvstgt_probe,
+	.remove = ibmvstgt_remove,
+};
+
+static int get_system_info(void)
+{
+	struct device_node *rootdn;
+	char *id, *model, *name;
+	unsigned int *num;
+
+	rootdn = find_path_device("/");
+	if (!rootdn)
+		return -ENOENT;
+
+	model = get_property(rootdn, "model", NULL);
+	id = get_property(rootdn, "system-id", NULL);
+	if (model && id)
+		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
+
+	name = get_property(rootdn, "ibm,partition-name", NULL);
+	if (name)
+		strncpy(partition_name, name, sizeof(partition_name));
+
+	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
+	if (num)
+		partition_number = *num;
+
+	return 0;
+}
+
+static int ibmvstgt_init(void)
+{
+	int err;
+	size_t size = sizeof(struct iu_entry) + sizeof(union viosrp_iu);
+
+	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
+
+	iu_cache = kmem_cache_create("ibmvstgt_iu",
+				     size, 0,
+				     SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
+				     NULL, NULL);
+	if (!iu_cache)
+		return -ENOMEM;
+
+	err = tgt_target_template_register(&ibmvstgt_template);
+	if (err < 0)
+		goto iu_cache;
+
+	err = get_system_info();
+	if (err < 0)
+		goto unregister_template;
+
+	err = vio_register_driver(&ibmvstgt_driver);
+	if (err)
+		goto unregister_template;
+
+	return 0;
+
+unregister_template:
+	tgt_target_template_unregister(&ibmvstgt_template);
+iu_cache:
+	kmem_cache_destroy(iu_cache);
+
+	return err;
+}
+
+static void ibmvstgt_exit(void)
+{
+	printk("Unregister IBM virtual SCSI driver\n");
+
+	vio_unregister_driver(&ibmvstgt_driver);
+	tgt_target_template_unregister(&ibmvstgt_template);
+	kmem_cache_destroy(iu_cache);
+}
+
+module_init(ibmvstgt_init);
+module_exit(ibmvstgt_exit);



From tomo at berlios.de  Fri Oct 28 17:36:19 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 17:36:19 +0200
Subject: [Stgt-svn] r134 - trunk/ibmvstgt
Message-ID: <200510281536.j9SFaJLH030424@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 17:36:18 +0200 (Fri, 28 Oct 2005)
New Revision: 134

Added:
   trunk/ibmvstgt/README
Log:
Add ibmvstgt's README file (taken from the original code).


Added: trunk/ibmvstgt/README
===================================================================
--- trunk/ibmvstgt/README	2005-10-28 15:17:09 UTC (rev 133)
+++ trunk/ibmvstgt/README	2005-10-28 15:36:18 UTC (rev 134)
@@ -0,0 +1,37 @@
+This driver is a SCSI target that interoperates according to the PAPR
+(POWER Architecture Platform Requirements) document.  Currently it is
+specific to POWER logical partitioning, however in the future it would
+be nice to extend this to other virtualized environments.
+
+The architecture defines virtual adapters, whose configuration is
+reported in the Open Firmware device tree.  There area number of power
+hypervisor calls (such as h_reg_crq, to register the inter-OS queue)
+that support the virtual adapters.
+
+Messages are sent between partitions on a "Command/Response Queue"
+(CRQ), which is just a buffer of 16 byte entries in the receiver's
+Senders cannot access the buffer directly, but send messages by making
+a hypervisor call and passing in the 16 bytes.  The hypervisor puts
+the message in the next 16 byte space in round-robbin fashion, turns
+on the high order bit of the message (the valid bit), and generates an
+interrupt to the receiver (if interrupts are turned on.)  The receiver
+just turns off the valid bit when they have copied out the message.
+
+The VSCSI client builds a SCSI Remote Protocol (SRP) Information Unit
+(IU) (as defined in the T10 standard available at www.t10.org), gets a
+DMA address for the message, and sends it to the target as the payload
+of a CRQ message.  The target DMAs the SRP IU and processes it,
+including doing any additional data transfers.  When it is done, it
+DMAs the SRP response back to the same address as the request came
+from and sends a CRQ message back to inform the client that the
+request has completed.
+
+This target interoperates not only with the Linux client (ibmvscsi.c)
+but also with AIX and OS/400 clients.  Thus, while the implementation
+can be changed, the underlying behaviour (protocol) is fixed.
+
+Configuration of the target is done via sysfs.  The target driver maps
+either block devices (e.g. IDE CD drive, loopback file, etc) to SCSI
+LUNs, in which case it emulates the SCSI protocol and issues kernel
+block device calls, or maps real SCSI devices, in which case the SCSI
+commands are just passed on to the real SCSI device.



From tomo at berlios.de  Fri Oct 28 17:40:12 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 17:40:12 +0200
Subject: [Stgt-svn] r135 - in trunk: ibmvstgt istgt
Message-ID: <200510281540.j9SFeCwR000148@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 17:40:12 +0200 (Fri, 28 Oct 2005)
New Revision: 135

Modified:
   trunk/ibmvstgt/Makefile
   trunk/istgt/Makefile
Log:
Clean up Makefiles.


Modified: trunk/ibmvstgt/Makefile
===================================================================
--- trunk/ibmvstgt/Makefile	2005-10-28 15:36:18 UTC (rev 134)
+++ trunk/ibmvstgt/Makefile	2005-10-28 15:40:12 UTC (rev 135)
@@ -1,14 +1,9 @@
-#
-# Makefile for the Linux kernel device drivers.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile.
-
 SUBDIRS := $(shell pwd)
 
+ifeq ($(KERNELSRC),)
+	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
+endif
+
 all: mods
 
 mods:

Modified: trunk/istgt/Makefile
===================================================================
--- trunk/istgt/Makefile	2005-10-28 15:36:18 UTC (rev 134)
+++ trunk/istgt/Makefile	2005-10-28 15:40:12 UTC (rev 135)
@@ -1,47 +1,17 @@
-#
-# Makefile for the Linux kernel device drivers.
-#
-# Note! Dependencies are done automagically by 'make dep', which also
-# removes any old dependencies. DON'T put your own dependencies here
-# unless it's something special (not a .c file).
-#
-# Note 2! The CFLAGS definitions are now in the main makefile.
-
-#export KERNELSRC := /usr/src/linux
-
 SUBDIRS := $(shell pwd)
 
 ifeq ($(KERNELSRC),)
 	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
 endif
 
-all: progs mods
+all: libs mods
 
 mods:
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
 
-progs:
+libs:
 	$(MAKE) -C usr
 
-install: kernel/iscsi_trgt.ko usr/ietd usr/ietadm
-	@install -vD usr/ietd $(DISTDIR)/usr/sbin/ietd
-	@install -vD usr/ietadm $(DISTDIR)/usr/sbin/ietadm
-	if [ -f /etc/debian_version ]; then \
-		install -vD -m 755 etc/initd/initd.debian $(DISTDIR)/etc/init.d/iscsi-target; \
-	elif [ -f /etc/redhat-release ]; then \
-		install -vD -m 755 etc/initd/initd.redhat $(DISTDIR)/etc/init.d/iscsi-target; \
-	elif [ -f /etc/gentoo-release ]; then \
-		install -vD -m 755 etc/initd/initd.gentoo $(DISTDIR)/etc/init.d/iscsi-target; \
-	elif [ -f /etc/slackware-version ]; then \
-		install -vD -m 755 etc/initd/initd $(DISTDIR)/etc/rc.d/iscsi-target; \
-	else \
-		install -vD -m 755 etc/initd/initd $(DISTDIR)/etc/init.d/iscsi-target; \
-	fi
-	@eval `sed -n 's/#define UTS_RELEASE /KERNELRELEASE=/p' $(KERNELSRC)/include/linux/version.h`; \
-	install -vD kernel/iscsi_trgt.ko \
-	$(DISTDIR)$(INSTALL_MOD_PATH)/lib/modules/$$KERNELRELEASE/kernel/iscsi/iscsi_trgt.ko
-	-depmod -aq
-
 clean:
 	$(MAKE) -C usr clean
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean



From tomo at berlios.de  Fri Oct 28 17:50:57 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 28 Oct 2005 17:50:57 +0200
Subject: [Stgt-svn] r136 - in trunk: . istgt/kernel
Message-ID: <200510281550.j9SFov9W005771@sheep.berlios.de>

Author: tomo
Date: 2005-10-28 17:50:57 +0200 (Fri, 28 Oct 2005)
New Revision: 136

Modified:
   trunk/initd
   trunk/istgt/kernel/Makefile
Log:
Change istgt module name.

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-10-28 15:40:12 UTC (rev 135)
+++ trunk/initd	2005-10-28 15:50:57 UTC (rev 136)
@@ -15,7 +15,7 @@
 #	insmod ${PWD}/kernel/tgt_sd.ko
 
 	modprobe -q crc32c
-	insmod ${PWD}/istgt/kernel/iscsi_trgt.ko
+	insmod ${PWD}/istgt/kernel/istgt.ko
 
 	${PWD}/usr/tgtd
 }
@@ -25,7 +25,7 @@
 	${PWD}/usr/tgtadm --driver istgt --op delete
 	killall -9 tgtd
 
-	rmmod iscsi_trgt
+	rmmod istgt
 
 #	rmmod tgt_sd
 	rmmod tgt_vsd

Modified: trunk/istgt/kernel/Makefile
===================================================================
--- trunk/istgt/kernel/Makefile	2005-10-28 15:40:12 UTC (rev 135)
+++ trunk/istgt/kernel/Makefile	2005-10-28 15:50:57 UTC (rev 136)
@@ -10,8 +10,8 @@
 EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -I$(obj)/../../kernel
 
 ifneq ($(KERNELRELEASE),)
-obj-m		+= iscsi_trgt.o
-iscsi_trgt-objs	:= iscsi.o nthread.o config.o digest.o\
+obj-m		+= istgt.o
+istgt-objs	:= iscsi.o nthread.o config.o digest.o\
 			conn.o session.o target.o param.o
 else
 



From tomo at berlios.de  Sat Oct 29 11:15:43 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 29 Oct 2005 11:15:43 +0200
Subject: [Stgt-svn] r137 - trunk/kernel
Message-ID: <200510290915.j9T9Fh79012009@sheep.berlios.de>

Author: tomo
Date: 2005-10-29 11:15:41 +0200 (Sat, 29 Oct 2005)
New Revision: 137

Modified:
   trunk/kernel/tgt.h
Log:
Improve dprintk and eprintk macro slightly.


Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-10-28 15:50:57 UTC (rev 136)
+++ trunk/kernel/tgt.h	2005-10-29 09:15:41 UTC (rev 137)
@@ -86,7 +86,7 @@
 
 #define eprintk(fmt, args...)					\
 do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
 #ifdef DEBUG_TGT



From tomo at berlios.de  Sat Oct 29 11:18:16 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 29 Oct 2005 11:18:16 +0200
Subject: [Stgt-svn] r138 - in trunk: . ibmvstgt
Message-ID: <200510290918.j9T9IGU5012294@sheep.berlios.de>

Author: tomo
Date: 2005-10-29 11:18:13 +0200 (Sat, 29 Oct 2005)
New Revision: 138

Added:
   trunk/doc/
   trunk/ibmvstgt/README.ibmvstgt
Removed:
   trunk/ibmvstgt/README
Log:
Rename ibmvstgt README.

Deleted: trunk/ibmvstgt/README
===================================================================
--- trunk/ibmvstgt/README	2005-10-29 09:15:41 UTC (rev 137)
+++ trunk/ibmvstgt/README	2005-10-29 09:18:13 UTC (rev 138)
@@ -1,37 +0,0 @@
-This driver is a SCSI target that interoperates according to the PAPR
-(POWER Architecture Platform Requirements) document.  Currently it is
-specific to POWER logical partitioning, however in the future it would
-be nice to extend this to other virtualized environments.
-
-The architecture defines virtual adapters, whose configuration is
-reported in the Open Firmware device tree.  There area number of power
-hypervisor calls (such as h_reg_crq, to register the inter-OS queue)
-that support the virtual adapters.
-
-Messages are sent between partitions on a "Command/Response Queue"
-(CRQ), which is just a buffer of 16 byte entries in the receiver's
-Senders cannot access the buffer directly, but send messages by making
-a hypervisor call and passing in the 16 bytes.  The hypervisor puts
-the message in the next 16 byte space in round-robbin fashion, turns
-on the high order bit of the message (the valid bit), and generates an
-interrupt to the receiver (if interrupts are turned on.)  The receiver
-just turns off the valid bit when they have copied out the message.
-
-The VSCSI client builds a SCSI Remote Protocol (SRP) Information Unit
-(IU) (as defined in the T10 standard available at www.t10.org), gets a
-DMA address for the message, and sends it to the target as the payload
-of a CRQ message.  The target DMAs the SRP IU and processes it,
-including doing any additional data transfers.  When it is done, it
-DMAs the SRP response back to the same address as the request came
-from and sends a CRQ message back to inform the client that the
-request has completed.
-
-This target interoperates not only with the Linux client (ibmvscsi.c)
-but also with AIX and OS/400 clients.  Thus, while the implementation
-can be changed, the underlying behaviour (protocol) is fixed.
-
-Configuration of the target is done via sysfs.  The target driver maps
-either block devices (e.g. IDE CD drive, loopback file, etc) to SCSI
-LUNs, in which case it emulates the SCSI protocol and issues kernel
-block device calls, or maps real SCSI devices, in which case the SCSI
-commands are just passed on to the real SCSI device.

Copied: trunk/ibmvstgt/README.ibmvstgt (from rev 137, trunk/ibmvstgt/README)



From tomo at berlios.de  Sat Oct 29 11:18:49 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 29 Oct 2005 11:18:49 +0200
Subject: [Stgt-svn] r139 - in trunk: doc ibmvstgt
Message-ID: <200510290918.j9T9IndK012401@sheep.berlios.de>

Author: tomo
Date: 2005-10-29 11:18:48 +0200 (Sat, 29 Oct 2005)
New Revision: 139

Added:
   trunk/doc/README.ibmvstgt
Removed:
   trunk/ibmvstgt/README.ibmvstgt
Log:
Move ibmvstgt README to doc directory.

Copied: trunk/doc/README.ibmvstgt (from rev 138, trunk/ibmvstgt/README.ibmvstgt)

Deleted: trunk/ibmvstgt/README.ibmvstgt
===================================================================
--- trunk/ibmvstgt/README.ibmvstgt	2005-10-29 09:18:13 UTC (rev 138)
+++ trunk/ibmvstgt/README.ibmvstgt	2005-10-29 09:18:48 UTC (rev 139)
@@ -1,37 +0,0 @@
-This driver is a SCSI target that interoperates according to the PAPR
-(POWER Architecture Platform Requirements) document.  Currently it is
-specific to POWER logical partitioning, however in the future it would
-be nice to extend this to other virtualized environments.
-
-The architecture defines virtual adapters, whose configuration is
-reported in the Open Firmware device tree.  There area number of power
-hypervisor calls (such as h_reg_crq, to register the inter-OS queue)
-that support the virtual adapters.
-
-Messages are sent between partitions on a "Command/Response Queue"
-(CRQ), which is just a buffer of 16 byte entries in the receiver's
-Senders cannot access the buffer directly, but send messages by making
-a hypervisor call and passing in the 16 bytes.  The hypervisor puts
-the message in the next 16 byte space in round-robbin fashion, turns
-on the high order bit of the message (the valid bit), and generates an
-interrupt to the receiver (if interrupts are turned on.)  The receiver
-just turns off the valid bit when they have copied out the message.
-
-The VSCSI client builds a SCSI Remote Protocol (SRP) Information Unit
-(IU) (as defined in the T10 standard available at www.t10.org), gets a
-DMA address for the message, and sends it to the target as the payload
-of a CRQ message.  The target DMAs the SRP IU and processes it,
-including doing any additional data transfers.  When it is done, it
-DMAs the SRP response back to the same address as the request came
-from and sends a CRQ message back to inform the client that the
-request has completed.
-
-This target interoperates not only with the Linux client (ibmvscsi.c)
-but also with AIX and OS/400 clients.  Thus, while the implementation
-can be changed, the underlying behaviour (protocol) is fixed.
-
-Configuration of the target is done via sysfs.  The target driver maps
-either block devices (e.g. IDE CD drive, loopback file, etc) to SCSI
-LUNs, in which case it emulates the SCSI protocol and issues kernel
-block device calls, or maps real SCSI devices, in which case the SCSI
-commands are just passed on to the real SCSI device.



