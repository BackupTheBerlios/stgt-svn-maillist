From tomo at mail.berlios.de  Sat Mar  3 07:58:41 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 07:58:41 +0100
Subject: [Stgt-svn] r790 - trunk/usr
Message-ID: <200703030658.l236wf4Y005315@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 07:58:40 +0100 (Sat, 03 Mar 2007)
New Revision: 790

Modified:
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
define device_command_operations and sbp_ops.


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-02-28 01:20:49 UTC (rev 789)
+++ trunk/usr/scsi.c	2007-03-03 06:58:40 UTC (rev 790)
@@ -44,135 +44,218 @@
 	return len + 8;
 }
 
-static int insert_disconnect_pg(uint8_t *ptr)
+#define        TGT_INVALID_DEV_ID      ~0ULL
+
+static uint64_t __scsi_get_devid(uint8_t *p)
 {
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	uint64_t lun = TGT_INVALID_DEV_ID;
 
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
+	switch (*p >> 6) {
+	case 0:
+		lun = p[1];
+		break;
+	case 1:
+		lun = (0x3f & p[0]) << 8 | p[1];
+		break;
+	case 2:
+	case 3:
+	default:
+		break;
+	}
+
+	return lun;
 }
 
-static int insert_caching_pg(uint8_t *ptr)
+uint64_t scsi_get_devid(int lid, uint8_t *p)
 {
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
+	typeof(__scsi_get_devid) *fn;
+	fn = tgt_drivers[lid]->scsi_get_lun ? : __scsi_get_devid;
+	return fn(p);
 }
 
-static int insert_ctrl_m_pg(uint8_t *ptr)
+static int sbc_test_unit(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
+	int ret = SAM_STAT_GOOD;
+	uint8_t *data;
 
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
+	/* how should we test a backing-storage file? */
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		data = valloc(pagesize);
+		cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x24, 0);
+		cmd->uaddr = (unsigned long)data;
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+	return ret;
 }
 
-static int insert_iec_m_pg(uint8_t *ptr)
+static int sbc_request_sense(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
+	uint8_t *data;
 
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
+	data = valloc(pagesize);
+	if (!data)
+		return SAM_STAT_CHECK_CONDITION;
+
+	cmd->len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
+	cmd->uaddr = (unsigned long)data;
+	return SAM_STAT_GOOD;
 }
 
-static int insert_format_m_pg(uint8_t *ptr)
+static int __report_luns(struct list_head *dev_list, uint8_t *lun_buf,
+			 uint8_t *scb, uint8_t *p, int *len)
 {
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
+	struct tgt_device *dev;
+	uint64_t lun, *data = (uint64_t *) p;
+	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
+	int result = SAM_STAT_GOOD;
+
+	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
+	if (alen < 16) {
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
+					0x24, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	alen &= ~(8 - 1);
+	oalen = alen;
+
+	alen -= 8;
+	rbuflen -= 8; /* FIXME */
+	idx = 1;
+	nr_luns = 0;
+
+	overflow = 0;
+	list_for_each_entry(dev, dev_list, device_siblings) {
+		nr_luns++;
+
+		if (overflow)
+			continue;
+
+		lun = dev->lun;
+		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);
+		data[idx++] = __cpu_to_be64(lun << 32);
+		if (!(alen -= 8))
+			overflow = 1;
+		if (!(rbuflen -= 8)) {
+			fprintf(stderr, "FIXME: too many luns\n");
+			exit(-1);
+		}
+	}
+
+	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
+	*len = min(oalen, nr_luns * 8 + 8);
+
+	return result;
 }
 
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
+static int spc_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
+	struct target *target = cmd->c_target;
+	struct list_head *dev_list = &target->device_list;
+	uint8_t *data;
 
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long)data;
+
+	typeof(__report_luns) *fn;
+	fn = tgt_drivers[target->lid]->scsi_report_luns ? : __report_luns;
+	return fn(dev_list, cmd->lun, cmd->scb, data, &cmd->len);
 }
 
-static int mode_sense(struct tgt_device *dev, uint8_t *scb, uint8_t *data, int *len)
+static uint64_t sbc_rw_offset(uint8_t *scb)
 {
-	int result = SAM_STAT_GOOD;
-	uint8_t pcode = scb[2] & 0x3f;
-	uint64_t size;
+	uint64_t off;
 
-	*len = 4;
-	size = dev->size >> BLK_SHIFT;
-
-	if ((scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		*len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
-			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
-
-	switch (pcode) {
-	case 0x0:
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
 		break;
-	case 0x2:
-		*len += insert_disconnect_pg(data + *len);
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
 		break;
-	case 0x3:
-		*len += insert_format_m_pg(data + *len);
+	case READ_16:
+	case WRITE_16:
+		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
 		break;
-	case 0x4:
-		*len += insert_geo_m_pg(data + *len, size);
+	default:
+		off = 0;
 		break;
-	case 0x8:
-		*len += insert_caching_pg(data + *len);
+	}
+
+	return off << BLK_SHIFT;
+}
+
+static int sbc_rw(int host_no, struct scsi_cmd *cmd, void *key)
+{
+	int ret;
+	unsigned long uaddr;
+	uint8_t *data;
+	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no)) {
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+			goto sense;
+		}
+	} else {
+		ret = SAM_STAT_CHECK_CONDITION;
+		goto sense;
+	}
+
+	switch (cmd->scb[0]) {
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		cmd->rw = WRITE;
 		break;
-	case 0xa:
-		*len += insert_ctrl_m_pg(data + *len);
+	default:
 		break;
-	case 0x1c:
-		*len += insert_iec_m_pg(data + *len);
-		break;
-	case 0x3f:
-		*len += insert_disconnect_pg(data + *len);
-		*len += insert_format_m_pg(data + *len);
-		*len += insert_geo_m_pg(data + *len, size);
-		*len += insert_caching_pg(data + *len);
-		*len += insert_ctrl_m_pg(data + *len);
-		*len += insert_iec_m_pg(data + *len);
-		break;
-	default:
-		result = SAM_STAT_CHECK_CONDITION;
-		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
 	}
 
-	data[0] = *len - 1;
+	cmd->offset = sbc_rw_offset(cmd->scb);
+	uaddr = cmd->uaddr;
+	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
+		     cmd->offset, &cmd->async, key);
+	if (ret == SAM_STAT_GOOD) {
+		cmd->mmapped = 1;
+		cmd->uaddr = uaddr;
+		return SAM_STAT_GOOD;
+	}
 
-	return result;
+sense:
+	cmd->rw = READ;
+	cmd->offset = 0;
+	data = valloc(pagesize);
+	if (data) {
+		cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
+		cmd->uaddr = (unsigned long) data;
+	}
+	return ret;
 }
 
 #define VENDOR_ID	"IET"
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int __inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
-		     uint8_t *scb, uint8_t *data, int *len)
+static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	int result = SAM_STAT_CHECK_CONDITION;
+	int len, ret = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
 
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long) data;
+
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
@@ -196,15 +279,15 @@
 		data[61] = 0x60;
 		data[62] = 0x03;
 		data[63] = 0x00;
-		*len = 64;
-		result = SAM_STAT_GOOD;
+		len = 64;
+		ret = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
 		/* We do not support it now. */
 		data[1] = 0x1;
 		data[5] = 0;
-		*len = 6;
-		result = SAM_STAT_GOOD;
+		len = 6;
+		ret = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
 		if (scb[2] == 0x0) {
@@ -213,23 +296,23 @@
 			data[4] = 0x0;
 			data[5] = 0x80;
 			data[6] = 0x83;
-			*len = 7;
-			result = SAM_STAT_GOOD;
+			len = 7;
+			ret = SAM_STAT_GOOD;
 		} else if (scb[2] == 0x80) {
 			int tmp = SCSI_SN_LEN;
 
 			data[1] = 0x80;
 			data[3] = SCSI_SN_LEN;
 			memset(data + 4, 0x20, 4);
-			*len = 4 + SCSI_SN_LEN;
-			result = SAM_STAT_GOOD;
+			len = 4 + SCSI_SN_LEN;
+			ret = SAM_STAT_GOOD;
 
-			if (dev && strlen(dev->scsi_sn)) {
+			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
 				uint8_t *p;
 				char *q;
 
 				p = data + 4 + tmp - 1;
-				q = dev->scsi_sn + SCSI_SN_LEN - 1;
+				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
 
 				for (; tmp > 0; tmp--, q)
 					*(p--) = *q;
@@ -242,124 +325,142 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (dev)
-				strncpy((char *) data + 8, dev->scsi_id,
+			if (cmd->dev)
+				strncpy((char *) data + 8, cmd->dev->scsi_id,
 				        SCSI_ID_LEN);
-			*len = tmp + 8;
-			result = SAM_STAT_GOOD;
+			len = tmp + 8;
+			ret = SAM_STAT_GOOD;
 		}
 	}
 
-	if (result != SAM_STAT_GOOD)
+	if (ret != SAM_STAT_GOOD)
 		goto err;
 
-	*len = min_t(int, *len, scb[4]);
+	len = min_t(int, len, scb[4]);
 
-	if (!dev)
+	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
+	cmd->len = len;
+
 	return SAM_STAT_GOOD;
 
 err:
-	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-				0x24, 0);
+	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int inquiry(int lid, struct tgt_device *dev, int host_no,
-		   uint8_t *lun_buf, uint8_t *scb, uint8_t *data, int *len)
+static int sbc_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	typeof(__inquiry) *fn;
+	int ret, lid = cmd->c_target->lid;
 
-	fn = tgt_drivers[lid]->scsi_inquiry ? : __inquiry;
-	return fn(dev, host_no, lun_buf, scb, data, len);
+	if (tgt_drivers[lid]->scsi_inquiry) {
+		uint8_t *data;
+
+		data = valloc(pagesize);
+		memset(data, 0, pagesize);
+		cmd->uaddr = (unsigned long)data;
+		ret = tgt_drivers[lid]->scsi_inquiry(cmd->dev, host_no, cmd->lun,
+						     cmd->scb, data, &cmd->len);
+	} else
+		ret = __sbc_inquiry(host_no, cmd, key);
+
+	return ret;
 }
 
-static int __report_luns(struct list_head *dev_list, uint8_t *lun_buf,
-			 uint8_t *scb, uint8_t *p, int *len)
+static int sbc_reserve(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	struct tgt_device *dev;
-	uint64_t lun, *data = (uint64_t *) p;
-	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	int result = SAM_STAT_GOOD;
+	int ret;
+	uint8_t *data;
 
-	memset(data, 0, rbuflen);
-
-	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
-	if (alen < 16) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
-		return SAM_STAT_CHECK_CONDITION;
+	if (cmd->dev) {
+		ret = device_reserve(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+		else
+			ret = SAM_STAT_GOOD;
+	} else {
+		data = valloc(pagesize);
+		if (data) {
+			cmd->uaddr = (unsigned long)data;
+			cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
+		}
+		ret = SAM_STAT_CHECK_CONDITION;
 	}
+	return ret;
+}
 
-	alen &= ~(8 - 1);
-	oalen = alen;
+static int sbc_release(int host_no, struct scsi_cmd *cmd, void *key)
+{
+	int ret = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data;
 
-	alen -= 8;
-	rbuflen -= 8; /* FIXME */
-	idx = 1;
-	nr_luns = 0;
-
-	overflow = 0;
-	list_for_each_entry(dev, dev_list, device_siblings) {
-		nr_luns++;
-
-		if (overflow)
-			continue;
-
-		lun = dev->lun;
-		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);
-		data[idx++] = __cpu_to_be64(lun << 32);
-		if (!(alen -= 8))
-			overflow = 1;
-		if (!(rbuflen -= 8)) {
-			fprintf(stderr, "FIXME: too many luns\n");
-			exit(-1);
+	if (cmd->dev) {
+		ret = device_release(cmd->cmd_nexus_id, cmd->dev->lun, host_no, 0);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+		else
+			ret = SAM_STAT_GOOD;
+	} else {
+		data = valloc(pagesize);
+		if (data) {
+			cmd->uaddr = (unsigned long) data;
+			cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
 		}
 	}
-
-	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
-
-	return result;
+	return ret;
 }
 
-static int report_luns(int lid, struct list_head *dev_list, uint8_t *lun_buf,
-		       uint8_t *scb, uint8_t *p, int *len)
+static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	typeof(__report_luns) *fn;
-	fn = tgt_drivers[lid]->scsi_report_luns ? : __report_luns;
-	return fn(dev_list, lun_buf, scb, p, len);
-}
-
-static int read_capacity(struct tgt_device *dev, uint8_t *scb, uint8_t *p, int *len)
-{
-	uint32_t *data = (uint32_t *) p;
+	uint32_t *data;
 	uint64_t size;
+	uint8_t *scb = cmd->scb;
 
+	data = valloc(pagesize);
+	cmd->uaddr = (unsigned long) data;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		cmd->len = sense_data_build((uint8_t *)data, 0x70,
+					    ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
+		cmd->len = sense_data_build((uint8_t *)data, 0x70,
+					    ILLEGAL_REQUEST, 0x24, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	size = dev->size >> BLK_SHIFT;
+	size = cmd->dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
-	*len = 8;
+	cmd->len = 8;
 
 	return SAM_STAT_GOOD;
 }
 
-static int sync_cache(struct tgt_device *dev, uint8_t *data, int *len)
+static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	int err;
+	int ret, len;
+	uint8_t *data, ascode;
 
-	err = fsync(dev->fd);
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		ascode = 0x25;
+		goto sense;
+	}
 
-	switch (err) {
+	ret = fsync(cmd->dev->fd);
+
+	switch (ret) {
 	case EROFS:
 	case EINVAL:
 	case EBADF:
@@ -368,262 +469,329 @@
 		 * is this the right sense code?
 		 * what should I put for the asc/ascq?
 		 */
-		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
-		return SAM_STAT_CHECK_CONDITION;
+		ascode = 0;
+		goto sense;
 	default:
-		*len = 0;
+		len = 0;
 		return SAM_STAT_GOOD;
 	}
+
+sense:
+	data = valloc(pagesize);
+	cmd->uaddr = (unsigned long) data;
+	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, ascode, 0);
+
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-/*
- * TODO: We always assume autosense.
- */
-static int request_sense(uint8_t *data, int* len)
+static int insert_disconnect_pg(uint8_t *ptr)
 {
-	*len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
+	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
+                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 
-	return SAM_STAT_GOOD;
+	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
+	return sizeof(disconnect_pg);
 }
 
-static int sevice_action(struct tgt_device *dev, uint8_t *scb, uint8_t *p, int *len)
+static int insert_caching_pg(uint8_t *ptr)
 {
-	uint32_t *data = (uint32_t *) p;
-	uint64_t *data64, size;
+	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
+				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
+				      0x00, 0x00, 0x00, 0x00};
 
-	size = dev->size >> BLK_SHIFT;
-
-	data64 = (uint64_t *) data;
-	data64[0] = __cpu_to_be64(size - 1);
-	data[2] = __cpu_to_be32(1UL << BLK_SHIFT);
-
-	*len = 12;
-
-	return SAM_STAT_GOOD;
+	memcpy(ptr, caching_pg, sizeof(caching_pg));
+	return sizeof(caching_pg);
 }
 
-static uint64_t scsi_cmd_data_offset(uint8_t *scb)
+static int insert_ctrl_m_pg(uint8_t *ptr)
 {
-	uint64_t off;
+	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x02, 0x4b};
 
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		off = 0;
-		break;
-	}
-
-	return off << BLK_SHIFT;
+	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
+	return sizeof(ctrl_m_pg);
 }
 
-static int scsi_cmd_rw(uint8_t *scb, uint8_t *rw)
+static int insert_iec_m_pg(uint8_t *ptr)
 {
-	int is_alloc = 0;
+	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00};
 
-	switch (scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		*rw = READ;
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		*rw = WRITE;
-		break;
-	default:
-		is_alloc = 1;
-	}
-	return is_alloc;
+	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
+	return sizeof(iec_m_pg);
 }
 
-#define        TGT_INVALID_DEV_ID      ~0ULL
-
-static uint64_t __scsi_get_devid(uint8_t *p)
+static int insert_format_m_pg(uint8_t *ptr)
 {
-	uint64_t lun = TGT_INVALID_DEV_ID;
-
-	switch (*p >> 6) {
-	case 0:
-		lun = p[1];
-		break;
-	case 1:
-		lun = (0x3f & p[0]) << 8 | p[1];
-		break;
-	case 2:
-	case 3:
-	default:
-		break;
-	}
-
-	return lun;
+	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
+				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
+	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
+	return sizeof(format_m_pg);
 }
 
-uint64_t scsi_get_devid(int lid, uint8_t *p)
+static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
 {
-	typeof(__scsi_get_devid) *fn;
-	fn = tgt_drivers[lid]->scsi_get_lun ? : __scsi_get_devid;
-	return fn(p);
+	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
+	uint32_t ncyl, *p;
+
+	/* assume 0xff heads, 15krpm. */
+	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
+	ncyl = sec >> 14; /* 256 * 64 */
+	p = (uint32_t *)(ptr + 1);
+	*p = *p | __cpu_to_be32(ncyl);
+	return sizeof(geo_m_pg);
 }
 
-int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd, void *key)
 {
-	struct target *target = cmd->c_target;
-	int result = SAM_STAT_GOOD;
-	int lid = target->lid;
-	uint8_t *rw = &cmd->rw;
+	int ret = SAM_STAT_GOOD, len;
+	uint8_t pcode = cmd->scb[2] & 0x3f;
+	uint64_t size;
 	uint8_t *data = NULL;
-	uint8_t *scb = cmd->scb;
-	uint32_t datalen = cmd->len;
-	int *try_map = &cmd->mmapped;
-	uint64_t *offset = &cmd->offset;
-	uint8_t *lun_buf = cmd->lun;
-	int *len = &cmd->len;
-	int *async = &cmd->async;
-	uint64_t nid = cmd->cmd_nexus_id;
-	unsigned long uaddr = cmd->uaddr;
-	struct tgt_device *dev = cmd->dev;
-	struct list_head *dev_list = &target->device_list;
-	bkio_submit_t *submit = target->bdt->bd_cmd_submit;
 
-	dprintf("%x %u\n", scb[0], datalen);
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long) data;
 
-	*async = *offset = 0;
-	if (scsi_cmd_rw(scb, rw)) {
-		data = valloc(pagesize);
-		memset(data, 0, pagesize);
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		cmd->len = sense_data_build((uint8_t *)data, 0x70,
+					    ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	if (!dev) {
-		switch (scb[0]) {
-		case REQUEST_SENSE:
-		case INQUIRY:
-		case REPORT_LUNS:
-			break;
-		default:
-			*offset = 0;
-			if (!data) {
-				data = valloc(pagesize);
-				memset(data, 0, pagesize);
-			}
-			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-						0x25, 0);
-			result = SAM_STAT_CHECK_CONDITION;
-			goto out;
-		}
-	} else {
-		int reserved;
+	len = 4;
+	size = cmd->dev->size >> BLK_SHIFT;
 
-		reserved = device_reserved(nid, dev->lun, host_no);
-		if (reserved) {
-			switch (scb[0]) {
-			case INQUIRY:
-			case RELEASE:
-			case RELEASE_10:
-			case REPORT_LUNS:
-			case REQUEST_SENSE:
-				/* these commands are always allowed. */
-				break;
-			default:
-			*offset = 0;
-			if (data) {
-				free(data);
-				data = NULL;
-			}
-
-			*len = 0;
-			result = SAM_STAT_RESERVATION_CONFLICT;
-			goto out;
-			}
-		}
+	if ((cmd->scb[1] & 0x8))
+		data[3] = 0;
+	else {
+		data[3] = 8;
+		len += 8;
+		*(uint32_t *)(data + 4) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
 	}
 
-	switch (scb[0]) {
-	case INQUIRY:
-		result = inquiry(lid, dev, host_no, lun_buf, scb, data, len);
+	switch (pcode) {
+	case 0x0:
 		break;
-	case REPORT_LUNS:
-		*len = datalen;
-		result = report_luns(lid, dev_list, lun_buf, scb, data, len);
+	case 0x2:
+		len += insert_disconnect_pg(data + len);
 		break;
-	case READ_CAPACITY:
-		result = read_capacity(dev, scb, data, len);
+	case 0x3:
+		len += insert_format_m_pg(data + len);
 		break;
-	case MODE_SENSE:
-		result = mode_sense(dev, scb, data, len);
+	case 0x4:
+		len += insert_geo_m_pg(data + len, size);
 		break;
-	case REQUEST_SENSE:
-		result = request_sense(data, len);
+	case 0x8:
+		len += insert_caching_pg(data + len);
 		break;
-	case SERVICE_ACTION_IN:
-		result = sevice_action(dev, scb, data, len);
+	case 0xa:
+		len += insert_ctrl_m_pg(data + len);
 		break;
-	case SYNCHRONIZE_CACHE:
-		result = sync_cache(dev, data, len);
+	case 0x1c:
+		len += insert_iec_m_pg(data + len);
 		break;
-	case START_STOP:
-	case TEST_UNIT_READY:
-	case VERIFY:
-		*len = 0;
+	case 0x3f:
+		len += insert_disconnect_pg(data + len);
+		len += insert_format_m_pg(data + len);
+		len += insert_geo_m_pg(data + len, size);
+		len += insert_caching_pg(data + len);
+		len += insert_ctrl_m_pg(data + len);
+		len += insert_iec_m_pg(data + len);
 		break;
-	case READ_6:
-	case READ_10:
-	case READ_16:
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		*offset = scsi_cmd_data_offset(scb);
-		result = submit(dev, scb, *rw, datalen, &uaddr, *offset, async, key);
-		if (result == SAM_STAT_GOOD) {
-			*len = datalen;
-			*try_map = 1;
-			cmd->uaddr = uaddr;
-		} else {
-			*rw = READ;
-			*offset = 0;
-			if (!data)
-				data = valloc(pagesize);
-			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-						0x25, 0);
-		}
-		break;
-	case RESERVE:
-	case RESERVE_10:
-		result = device_reserve(nid, dev->lun, nid);
-		if (result)
-			result = SAM_STAT_RESERVATION_CONFLICT;
-		*len = 0;
-		break;
-	case RELEASE:
-	case RELEASE_10:
-		result = device_release(nid, dev->lun, host_no, 0);
-		if (result)
-			result = SAM_STAT_RESERVATION_CONFLICT;
-		*len = 0;
-		break;
 	default:
-		eprintf("unknown command %x %u\n", scb[0], datalen);
-		*len = 0;
-		break;
+		ret = SAM_STAT_CHECK_CONDITION;
+		len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,0x24, 0);
 	}
 
-out:
-	if (data)
+	data[0] = len - 1;
+	cmd->len = len;
+	return ret;
+}
+
+static int spc_start_stop(int host_no, struct scsi_cmd *cmd, void *key)
+{
+	cmd->len = 0;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		uint8_t *data;
+
+		data = valloc(pagesize);
+		memset(data, 0, pagesize);
 		cmd->uaddr = (unsigned long) data;
 
-	return result;
+		cmd->len = sense_data_build((uint8_t *)data, 0x70,
+					    ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	return SAM_STAT_GOOD;
 }
+
+static int spc_illegal_op(int host_no, struct scsi_cmd *cmd, void *key)
+{
+	uint8_t *data;
+
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long) data;
+	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,0x24, 0);
+
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+struct device_command_operations sbc_ops[] = {
+	{sbc_test_unit,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_request_sense,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0x10 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_inquiry,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_reserve,},
+	{sbc_release,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_mode_sense,},
+	{spc_start_stop,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0x20 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_read_capacity,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{sbc_test_unit},
+
+	/* 0x30 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_sync_cache,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	[0x40 ... 0x7f] = {spc_illegal_op,},
+
+	/* 0x80 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{sbc_test_unit},
+
+	/* 0x90 */
+	{spc_illegal_op,},
+	{sbc_sync_cache,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0xA0 */
+	{spc_report_luns,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{sbc_test_unit,},
+
+	[0xb0 ... 0xff] = {spc_illegal_op},
+};
+
+int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
+{
+	unsigned char op = cmd->scb[0];
+
+	return sbc_ops[op].cmd_perform(host_no, cmd, key);
+}

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-02-28 01:20:49 UTC (rev 789)
+++ trunk/usr/tgtd.h	2007-03-03 06:58:40 UTC (rev 790)
@@ -101,6 +101,10 @@
 struct backedio_template sg_bdt;
 #endif
 
+struct device_command_operations {
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd, void *key);
+};
+
 extern int kspace_send_tsk_mgmt_res(uint64_t nid, uint64_t mid, int result);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 



From tomo at mail.berlios.de  Sat Mar  3 08:55:34 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 08:55:34 +0100
Subject: [Stgt-svn] r791 - in trunk/usr: . ibmvio
Message-ID: <200703030755.l237tYlW007467@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 08:55:34 +0100 (Sat, 03 Mar 2007)
New Revision: 791

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/scsi.c
Log:
This enables a lld to modify device_command_operations


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-03 06:58:40 UTC (rev 790)
+++ trunk/usr/driver.h	2007-03-03 07:55:34 UTC (rev 791)
@@ -12,11 +12,11 @@
 
 	int (*show) (int, int, uint64_t, uint32_t, uint64_t, char *, int);
 
+	/* the following three should be killed shortly */
 	uint64_t (*scsi_get_lun)(uint8_t *);
-	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,
-				uint8_t *, int *);
-	int (*scsi_inquiry)(struct tgt_device *, int, uint8_t *, uint8_t *,
-			    uint8_t *, int *);
+	int (*scsi_report_luns)(int host_no, struct scsi_cmd *cmd, void *key);
+	int (*scsi_inquiry)(int host_no, struct scsi_cmd *cmd, void *key);
+
 	int (*cmd_end_notify)(uint64_t nid, int result, struct scsi_cmd *);
 	int (*mgmt_end_notify)(uint64_t nid, uint64_t mid, int result);
 

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-03 06:58:40 UTC (rev 790)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-03 07:55:34 UTC (rev 791)
@@ -41,6 +41,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "target.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -124,18 +125,23 @@
 	return sizeof(*id);
 }
 
-int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
-		 uint8_t *scb, uint8_t *data, int *len)
+int scsi_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	int result = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data, *scb = cmd->scb;
+	int *len = &cmd->len;
 
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long) data;
+
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
-		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
+		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) cmd->lun), data);
 		result = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
@@ -168,8 +174,8 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (dev)
-				strncpy(data + 8, dev->scsi_id, SCSI_ID_LEN);
+			if (cmd->dev)
+				strncpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
 		}
@@ -180,7 +186,7 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (!dev)
+	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
 	return SAM_STAT_GOOD;
@@ -200,19 +206,23 @@
 	return ((uint64_t) result) << 48;
 }
 
-int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
-		     uint8_t *scb, uint8_t *p, int *len)
+int scsi_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	struct tgt_device *dev;
-	uint64_t lun, *data = (uint64_t *) p;
+	struct list_head *dev_list = &cmd->c_target->device_list;
+	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	int result = SAM_STAT_GOOD;
+	int *len = &cmd->len;
+	uint8_t *lun_buf = cmd->lun;
 
-	memset(data, 0, rbuflen);
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long)data;
 
-	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
+	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
+		*len = sense_data_build((void *)data, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2007-03-03 06:58:40 UTC (rev 790)
+++ trunk/usr/ibmvio/ibmvio.h	2007-03-03 07:55:34 UTC (rev 791)
@@ -1,7 +1,5 @@
-extern int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
-			uint8_t *scb, uint8_t *data, int *len);
-extern int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
-			    uint8_t *scb, uint8_t *p, int *len);
+extern int scsi_inquiry(int host_no, struct scsi_cmd *cmd, void *key);
+extern int scsi_report_luns(int host_no, struct scsi_cmd *cmd, void *key);
 
 extern uint64_t scsi_lun_to_int(uint8_t *p);
 

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-03 06:58:40 UTC (rev 790)
+++ trunk/usr/scsi.c	2007-03-03 07:55:34 UTC (rev 791)
@@ -105,17 +105,22 @@
 	return SAM_STAT_GOOD;
 }
 
-static int __report_luns(struct list_head *dev_list, uint8_t *lun_buf,
-			 uint8_t *scb, uint8_t *p, int *len)
+static int __spc_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	struct tgt_device *dev;
-	uint64_t lun, *data = (uint64_t *) p;
+	struct list_head *dev_list = &cmd->c_target->device_list;
+	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
 	int result = SAM_STAT_GOOD;
+	int *len = &cmd->len;
 
-	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
+	data = valloc(pagesize);
+	memset(data, 0, pagesize);
+	cmd->uaddr = (unsigned long)data;
+
+	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
+		*len = sense_data_build((void *)data, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
@@ -155,16 +160,15 @@
 static int spc_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	struct target *target = cmd->c_target;
-	struct list_head *dev_list = &target->device_list;
-	uint8_t *data;
+	int ret, lid = target->lid;
 
-	data = valloc(pagesize);
-	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long)data;
+	/* temp hack */
+	if (tgt_drivers[lid]->scsi_report_luns)
+		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd, key);
+	else
+		ret = __spc_report_luns(host_no, cmd, key);
 
-	typeof(__report_luns) *fn;
-	fn = tgt_drivers[target->lid]->scsi_report_luns ? : __report_luns;
-	return fn(dev_list, cmd->lun, cmd->scb, data, &cmd->len);
+	return ret;
 }
 
 static uint64_t sbc_rw_offset(uint8_t *scb)
@@ -354,17 +358,10 @@
 {
 	int ret, lid = cmd->c_target->lid;
 
-	if (tgt_drivers[lid]->scsi_inquiry) {
-		uint8_t *data;
-
-		data = valloc(pagesize);
-		memset(data, 0, pagesize);
-		cmd->uaddr = (unsigned long)data;
-		ret = tgt_drivers[lid]->scsi_inquiry(cmd->dev, host_no, cmd->lun,
-						     cmd->scb, data, &cmd->len);
-	} else
+	if (tgt_drivers[lid]->scsi_inquiry)
+		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd, key);
+	else
 		ret = __sbc_inquiry(host_no, cmd, key);
-
 	return ret;
 }
 



From tomo at mail.berlios.de  Sat Mar  3 11:36:11 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 11:36:11 +0100
Subject: [Stgt-svn] r792 - in trunk/usr: . ibmvio iscsi
Message-ID: <200703031036.l23AaBrZ015886@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 11:36:10 +0100 (Sat, 03 Mar 2007)
New Revision: 792

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
clean up sense code


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/driver.h	2007-03-03 10:36:10 UTC (rev 792)
@@ -14,8 +14,8 @@
 
 	/* the following three should be killed shortly */
 	uint64_t (*scsi_get_lun)(uint8_t *);
-	int (*scsi_report_luns)(int host_no, struct scsi_cmd *cmd, void *key);
-	int (*scsi_inquiry)(int host_no, struct scsi_cmd *cmd, void *key);
+	int (*scsi_report_luns)(int host_no, struct scsi_cmd *cmd);
+	int (*scsi_inquiry)(int host_no, struct scsi_cmd *cmd);
 
 	int (*cmd_end_notify)(uint64_t nid, int result, struct scsi_cmd *);
 	int (*mgmt_end_notify)(uint64_t nid, uint64_t mid, int result);

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-03 10:36:10 UTC (rev 792)
@@ -125,19 +125,24 @@
 	return sizeof(*id);
 }
 
-int scsi_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
+int scsi_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int result = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
 	int *len = &cmd->len;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto sense;
+
 	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto err;
-
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
@@ -181,19 +186,22 @@
 		}
 	}
 
-	if (result != SAM_STAT_GOOD)
-		goto err;
+	if (result != SAM_STAT_GOOD) {
+		free(data);
+		goto sense;
+	}
 
 	*len = min_t(int, *len, scb[4]);
+	cmd->uaddr = (unsigned long)data;
 
 	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
 	return SAM_STAT_GOOD;
 
-err:
-	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-				0x24, 0);
+sense:
+	*len = 0;
+	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -206,27 +214,29 @@
 	return ((uint64_t) result) << 48;
 }
 
-int scsi_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
+int scsi_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev;
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	int result = SAM_STAT_GOOD;
 	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
+	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
+	if (alen < 16)
+		goto sense;
+
 	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
 	memset(data, 0, pagesize);
 	cmd->uaddr = (unsigned long)data;
 
-	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
-	if (alen < 16) {
-		*len = sense_data_build((void *)data, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-
 	alen &= ~(8 - 1);
 	oalen = alen;
 
@@ -256,8 +266,11 @@
 done:
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
-
-	return result;
+	return SAM_STAT_GOOD;
+sense:
+	*len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/ibmvio/ibmvio.h	2007-03-03 10:36:10 UTC (rev 792)
@@ -1,5 +1,5 @@
-extern int scsi_inquiry(int host_no, struct scsi_cmd *cmd, void *key);
-extern int scsi_report_luns(int host_no, struct scsi_cmd *cmd, void *key);
+extern int scsi_inquiry(int host_no, struct scsi_cmd *cmd);
+extern int scsi_report_luns(int host_no, struct scsi_cmd *cmd);
 
 extern uint64_t scsi_lun_to_int(uint8_t *p);
 

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/iscsi/iscsid.c	2007-03-03 10:36:10 UTC (rev 792)
@@ -766,7 +766,7 @@
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 	struct iscsi_sense_data *sense;
-	uint16_t sense_len = task->len;
+	unsigned char sense_len;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -775,18 +775,15 @@
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = SAM_STAT_CHECK_CONDITION;
 
-	sense = (void *) (unsigned long) task->addr;
+	sense = (struct iscsi_sense_data *)task->scmd->sense_buffer;
+	sense_len = task->scmd->sense_len;
 
-	/* FIXME: we assume that sense_buffer is large enough
-	 * (sense_len + 2 bytes). It's true now, but... */
-
 	memmove(sense->data, sense, sense_len);
 	sense->length = cpu_to_be16(sense_len);
 
 	conn->rsp.datasize = sense_len + sizeof(*sense);
 	hton24(rsp->dlength, sense_len + sizeof(*sense));
-	conn->rsp.data = (void *) (unsigned long) task->addr;
-	task->offset += sense_len + sizeof(*sense);
+	conn->rsp.data = sense;
 
 	return 0;
 }
@@ -945,6 +942,7 @@
 	task->result = result;
 	task->len = cmd->len;
 	task->rw = cmd->rw;
+	task->scmd = cmd;
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
 	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/iscsi/iscsid.h	2007-03-03 10:36:10 UTC (rev 792)
@@ -112,6 +112,12 @@
 	int exp_r2tsn;
 
 	void *c_buffer;
+
+	/*
+	 * temp hack.
+	 * TODO: move most of iscsi_task to scsi_cmd
+	 */
+	struct scsi_cmd *scmd;
 };
 
 struct iscsi_connection {

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/scsi.c	2007-03-03 10:36:10 UTC (rev 792)
@@ -30,18 +30,17 @@
 
 #define BLK_SHIFT	9
 
-int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
-		     uint8_t ascode, uint8_t ascodeq)
+void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	int len = 6;
+	int len = 0xa;
 
-	data[0] = res_code | 1U << 7;
-	data[2] = key;
-	data[7] = len;
-	data[12] = ascode;
-	data[13] = ascodeq;
+	cmd->sense_buffer[0] = 0x70;
+	cmd->sense_buffer[2] = key;
+	cmd->sense_buffer[7] = len;
+	cmd->sense_buffer[12] = asc;
+	cmd->sense_buffer[13] = asq;
 
-	return len + 8;
+	cmd->sense_len = len + 8;
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
@@ -73,58 +72,52 @@
 	return fn(p);
 }
 
-static int sbc_test_unit(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_test_unit(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_GOOD;
-	uint8_t *data;
 
 	/* how should we test a backing-storage file? */
 
 	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
 			ret = SAM_STAT_RESERVATION_CONFLICT;
 	} else {
-		data = valloc(pagesize);
-		cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x24, 0);
-		cmd->uaddr = (unsigned long)data;
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
 		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
 }
 
-static int sbc_request_sense(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
-	uint8_t *data;
-
-	data = valloc(pagesize);
-	if (!data)
-		return SAM_STAT_CHECK_CONDITION;
-
-	cmd->len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
-	cmd->uaddr = (unsigned long)data;
+	cmd->len = 0;
+	sense_data_build(cmd, NO_SENSE, 0, 0);
 	return SAM_STAT_GOOD;
 }
 
-static int __spc_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
+static int __spc_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev;
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	int result = SAM_STAT_GOOD;
 	int *len = &cmd->len;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
+	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
+	if (alen < 16)
+		goto sense;
+
 	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long)data;
 
-	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
-	if (alen < 16) {
-		*len = sense_data_build((void *)data, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-
 	alen &= ~(8 - 1);
 	oalen = alen;
 
@@ -151,22 +144,26 @@
 		}
 	}
 
+	cmd->uaddr = (unsigned long)data;
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
-
-	return result;
+	return SAM_STAT_GOOD;
+sense:
+	*len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int spc_report_luns(int host_no, struct scsi_cmd *cmd, void *key)
+static int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct target *target = cmd->c_target;
 	int ret, lid = target->lid;
 
 	/* temp hack */
 	if (tgt_drivers[lid]->scsi_report_luns)
-		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd, key);
+		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd);
 	else
-		ret = __spc_report_luns(host_no, cmd, key);
+		ret = __spc_report_luns(host_no, cmd);
 
 	return ret;
 }
@@ -197,18 +194,17 @@
 	return off << BLK_SHIFT;
 }
 
-static int sbc_rw(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
 	unsigned long uaddr;
-	uint8_t *data;
 	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
 	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no)) {
-			ret = SAM_STAT_RESERVATION_CONFLICT;
-			goto sense;
-		}
+		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			return SAM_STAT_RESERVATION_CONFLICT;
 	} else {
 		ret = SAM_STAT_CHECK_CONDITION;
 		goto sense;
@@ -228,41 +224,45 @@
 	cmd->offset = sbc_rw_offset(cmd->scb);
 	uaddr = cmd->uaddr;
 	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-		     cmd->offset, &cmd->async, key);
+		     cmd->offset, &cmd->async, (void *)cmd);
 	if (ret == SAM_STAT_GOOD) {
 		cmd->mmapped = 1;
 		cmd->uaddr = uaddr;
 		return SAM_STAT_GOOD;
+	} else {
+		key = HARDWARE_ERROR;
+		asc = 0;
 	}
-
 sense:
 	cmd->rw = READ;
 	cmd->offset = 0;
-	data = valloc(pagesize);
-	if (data) {
-		cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
-		cmd->uaddr = (unsigned long) data;
-	}
-	return ret;
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
 #define VENDOR_ID	"IET"
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
+static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto sense;
+
 	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto err;
-
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
@@ -338,37 +338,35 @@
 	}
 
 	if (ret != SAM_STAT_GOOD)
-		goto err;
+		goto sense;
 
-	len = min_t(int, len, scb[4]);
+	cmd->len = min_t(int, len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
 
 	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
-	cmd->len = len;
-
 	return SAM_STAT_GOOD;
-
-err:
-	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x24, 0);
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int sbc_inquiry(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, lid = cmd->c_target->lid;
 
 	if (tgt_drivers[lid]->scsi_inquiry)
-		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd, key);
+		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd);
 	else
-		ret = __sbc_inquiry(host_no, cmd, key);
+		ret = __sbc_inquiry(host_no, cmd);
 	return ret;
 }
 
-static int sbc_reserve(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_reserve(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	uint8_t *data;
 
 	if (cmd->dev) {
 		ret = device_reserve(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
@@ -377,20 +375,16 @@
 		else
 			ret = SAM_STAT_GOOD;
 	} else {
-		data = valloc(pagesize);
-		if (data) {
-			cmd->uaddr = (unsigned long)data;
-			cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
-		}
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
 		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
 }
 
-static int sbc_release(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_release(int host_no, struct scsi_cmd *cmd)
 {
-	int ret = SAM_STAT_CHECK_CONDITION;
-	uint8_t *data;
+	int ret;
 
 	if (cmd->dev) {
 		ret = device_release(cmd->cmd_nexus_id, cmd->dev->lun, host_no, 0);
@@ -399,39 +393,39 @@
 		else
 			ret = SAM_STAT_GOOD;
 	} else {
-		data = valloc(pagesize);
-		if (data) {
-			cmd->uaddr = (unsigned long) data;
-			cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0x25, 0);
-		}
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
 }
 
-static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 {
 	uint32_t *data;
 	uint64_t size;
 	uint8_t *scb = cmd->scb;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
-	data = valloc(pagesize);
-	cmd->uaddr = (unsigned long) data;
-
 	if (cmd->dev) {
 		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
 			return SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		cmd->len = sense_data_build((uint8_t *)data, 0x70,
-					    ILLEGAL_REQUEST, 0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
+	} else
+		goto sense;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		cmd->len = sense_data_build((uint8_t *)data, 0x70,
-					    ILLEGAL_REQUEST, 0x24, 0);
-		return SAM_STAT_CHECK_CONDITION;
+		asc = 0x24;
+		goto sense;
 	}
 
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	cmd->uaddr = (unsigned long) data;
+
 	size = cmd->dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
@@ -440,18 +434,22 @@
 	cmd->len = 8;
 
 	return SAM_STAT_GOOD;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, len;
-	uint8_t *data, ascode;
+	uint8_t key = ILLEGAL_REQUEST, asc;
 
 	if (cmd->dev) {
 		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
 			return SAM_STAT_RESERVATION_CONFLICT;
 	} else {
-		ascode = 0x25;
+		asc = 0x25;
 		goto sense;
 	}
 
@@ -466,7 +464,8 @@
 		 * is this the right sense code?
 		 * what should I put for the asc/ascq?
 		 */
-		ascode = 0;
+		key = HARDWARE_ERROR;
+		asc = 0;
 		goto sense;
 	default:
 		len = 0;
@@ -474,10 +473,8 @@
 	}
 
 sense:
-	data = valloc(pagesize);
-	cmd->uaddr = (unsigned long) data;
-	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, ascode, 0);
-
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -542,25 +539,27 @@
 	return sizeof(geo_m_pg);
 }
 
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd, void *key)
+static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_GOOD, len;
 	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
 	uint8_t *data = NULL;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
-	data = valloc(pagesize);
-	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
-
 	if (cmd->dev) {
 		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
 			return SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		cmd->len = sense_data_build((uint8_t *)data, 0x70,
-					    ILLEGAL_REQUEST, 0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
+	} else
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
 	}
+	memset(data, 0, pagesize);
 
 	len = 4;
 	size = cmd->dev->size >> BLK_SHIFT;
@@ -605,16 +604,21 @@
 		len += insert_iec_m_pg(data + len);
 		break;
 	default:
-		ret = SAM_STAT_CHECK_CONDITION;
-		len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,0x24, 0);
+		asc = 0x24;
+		goto sense;
 	}
 
 	data[0] = len - 1;
 	cmd->len = len;
+	cmd->uaddr = (unsigned long) data;
 	return ret;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int spc_start_stop(int host_no, struct scsi_cmd *cmd, void *key)
+static int spc_start_stop(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
 
@@ -622,29 +626,16 @@
 		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
 			return SAM_STAT_RESERVATION_CONFLICT;
 	} else {
-		uint8_t *data;
-
-		data = valloc(pagesize);
-		memset(data, 0, pagesize);
-		cmd->uaddr = (unsigned long) data;
-
-		cmd->len = sense_data_build((uint8_t *)data, 0x70,
-					    ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
-
 	return SAM_STAT_GOOD;
 }
 
-static int spc_illegal_op(int host_no, struct scsi_cmd *cmd, void *key)
+static int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
-	uint8_t *data;
-
-	data = valloc(pagesize);
-	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
-	cmd->len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,0x24, 0);
-
+	cmd->len = 0;
+	sense_data_build(cmd, ILLEGAL_REQUEST,0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -790,5 +781,5 @@
 {
 	unsigned char op = cmd->scb[0];
 
-	return sbc_ops[op].cmd_perform(host_no, cmd, key);
+	return sbc_ops[op].cmd_perform(host_no, cmd);
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/tgtd.h	2007-03-03 10:36:10 UTC (rev 792)
@@ -84,8 +84,9 @@
 	int async;
 	struct mgmt_req *mreq;
 
-#define SCSI_SENSE_BUFFERSIZE	96
+#define SCSI_SENSE_BUFFERSIZE	252
 	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE];
+	int sense_len;
 };
 
 #ifdef USE_KERNEL
@@ -102,7 +103,7 @@
 #endif
 
 struct device_command_operations {
-	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd, void *key);
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
 };
 
 extern int kspace_send_tsk_mgmt_res(uint64_t nid, uint64_t mid, int result);
@@ -141,8 +142,8 @@
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key);
-extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
-			    uint8_t ascode, uint8_t ascodeq);
+extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
+			     uint8_t asq);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2007-03-03 07:55:34 UTC (rev 791)
+++ trunk/usr/tgtif.c	2007-03-03 10:36:10 UTC (rev 792)
@@ -112,8 +112,10 @@
 	ev.hdr.type = TGT_UEVENT_CMD_RSP;
 	ev.p.cmd_rsp.host_no = it_nexus_to_host_no(nid);
 	ev.p.cmd_rsp.len = cmd->len;
+	ev.p.cmd_rsp.uaddr = cmd->uaddr;
+	ev.p.cmd_rsp.sense_len = cmd->sense_len;
+	ev.p.cmd_rsp.sense_uaddr = (unsigned long) cmd->sense_buffer;
 	ev.p.cmd_rsp.result = result;
-	ev.p.cmd_rsp.uaddr = cmd->uaddr;
 	ev.p.cmd_rsp.rw = cmd->rw;
 	ev.p.cmd_rsp.tag = cmd->tag;
 



From tomo at mail.berlios.de  Sat Mar  3 11:47:55 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 11:47:55 +0100
Subject: [Stgt-svn] r793 - trunk/usr
Message-ID: <200703031047.l23Altfd016438@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 11:47:55 +0100 (Sat, 03 Mar 2007)
New Revision: 793

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/scsi.c
Log:
handle AIO error


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2007-03-03 10:36:10 UTC (rev 792)
+++ trunk/usr/bd_aio.c	2007-03-03 10:47:55 UTC (rev 793)
@@ -183,12 +183,10 @@
 {
 	struct bd_aio_info *info;
 	struct iocb iocb, *io;
-	int err;
+	int ret;
 
 	info = (struct bd_aio_info *) ((char *)dev + sizeof(*dev));
 
-	*async = 1;
-
 	io = &iocb;
 	memset(io, 0, sizeof(*io));
 
@@ -201,9 +199,13 @@
 		io_prep_pwrite(io, dev->fd, (void *) *uaddr, datalen, offset);
 
 	io->data = key;
-	err = io_submit(info->ctx, 1, &io);
+	ret = io_submit(info->ctx, 1, &io);
 
-	return 0;
+	if (ret == 1) {
+		*async = 1;
+		return 0;
+	} else
+		return 1;
 }
 
 static int bd_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-03 10:36:10 UTC (rev 792)
+++ trunk/usr/scsi.c	2007-03-03 10:47:55 UTC (rev 793)
@@ -225,13 +225,13 @@
 	uaddr = cmd->uaddr;
 	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
 		     cmd->offset, &cmd->async, (void *)cmd);
-	if (ret == SAM_STAT_GOOD) {
+	if (ret) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+	} else {
 		cmd->mmapped = 1;
 		cmd->uaddr = uaddr;
 		return SAM_STAT_GOOD;
-	} else {
-		key = HARDWARE_ERROR;
-		asc = 0;
 	}
 sense:
 	cmd->rw = READ;



From tomo at mail.berlios.de  Sat Mar  3 12:29:28 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 12:29:28 +0100
Subject: [Stgt-svn] r794 - trunk/usr
Message-ID: <200703031129.l23BTSf2018752@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 12:29:27 +0100 (Sat, 03 Mar 2007)
New Revision: 794

Added:
   trunk/usr/sbc.c
   trunk/usr/spc.c
   trunk/usr/spc.h
Modified:
   trunk/usr/Makefile
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/target.h
Log:
add device type support


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/Makefile	2007-03-03 11:29:27 UTC (rev 794)
@@ -45,7 +45,7 @@
 CFLAGS += -Wall -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o
+TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o scsi.o log.o driver.o util.o work.o
 
 all: $(PROGRAMS)
 

Added: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/sbc.c	2007-03-03 11:29:27 UTC (rev 794)
@@ -0,0 +1,642 @@
+/*
+ * SCSI block command processing
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "scsi.h"
+#include "spc.h"
+
+#define BLK_SHIFT	9
+
+static int sbc_test_unit(int host_no, struct scsi_cmd *cmd)
+{
+	int ret = SAM_STAT_GOOD;
+
+	/* how should we test a backing-storage file? */
+
+	if (cmd->dev) {
+		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+	return ret;
+}
+
+static int sbc_request_sense(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+	sense_data_build(cmd, NO_SENSE, 0, 0);
+	return SAM_STAT_GOOD;
+}
+
+static uint64_t sbc_rw_offset(uint8_t *scb)
+{
+	uint64_t off;
+
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
+		break;
+	default:
+		off = 0;
+		break;
+	}
+
+	return off << BLK_SHIFT;
+}
+
+static int sbc_rw(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+	unsigned long uaddr;
+	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+
+	if (cmd->dev) {
+		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		ret = SAM_STAT_CHECK_CONDITION;
+		goto sense;
+	}
+
+	switch (cmd->scb[0]) {
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		cmd->rw = WRITE;
+		break;
+	default:
+		break;
+	}
+
+	cmd->offset = sbc_rw_offset(cmd->scb);
+	uaddr = cmd->uaddr;
+	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
+		     cmd->offset, &cmd->async, (void *)cmd);
+	if (ret) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+	} else {
+		cmd->mmapped = 1;
+		cmd->uaddr = uaddr;
+		return SAM_STAT_GOOD;
+	}
+sense:
+	cmd->rw = READ;
+	cmd->offset = 0;
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+#define VENDOR_ID	"IET"
+#define PRODUCT_ID	"VIRTUAL-DISK"
+#define PRODUCT_REV	"0"
+
+static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd)
+{
+	int len, ret = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (!(scb[1] & 0x3)) {
+		data[2] = 4;
+		data[3] = 0x42;
+		data[4] = 59;
+		data[7] = 0x02;
+		memset(data + 8, 0x20, 28);
+		memcpy(data + 8,
+		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
+		memcpy(data + 16,
+		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
+		memcpy(data + 32,
+		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
+		data[58] = 0x03;
+		data[59] = 0x20;
+		data[60] = 0x09;
+		data[61] = 0x60;
+		data[62] = 0x03;
+		data[63] = 0x00;
+		len = 64;
+		ret = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x2) {
+		/* CmdDt bit is set */
+		/* We do not support it now. */
+		data[1] = 0x1;
+		data[5] = 0;
+		len = 6;
+		ret = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x1) {
+		/* EVPD bit set */
+		if (scb[2] == 0x0) {
+			data[1] = 0x0;
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			len = 7;
+			ret = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			int tmp = SCSI_SN_LEN;
+
+			data[1] = 0x80;
+			data[3] = SCSI_SN_LEN;
+			memset(data + 4, 0x20, 4);
+			len = 4 + SCSI_SN_LEN;
+			ret = SAM_STAT_GOOD;
+
+			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+				uint8_t *p;
+				char *q;
+
+				p = data + 4 + tmp - 1;
+				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
+
+				for (; tmp > 0; tmp--, q)
+					*(p--) = *q;
+			}
+		} else if (scb[2] == 0x83) {
+			int tmp = SCSI_ID_LEN;
+
+			data[1] = 0x83;
+			data[3] = tmp + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = tmp;
+			if (cmd->dev)
+				strncpy((char *) data + 8, cmd->dev->scsi_id,
+				        SCSI_ID_LEN);
+			len = tmp + 8;
+			ret = SAM_STAT_GOOD;
+		}
+	}
+
+	if (ret != SAM_STAT_GOOD)
+		goto sense;
+
+	cmd->len = min_t(int, len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
+
+	if (!cmd->dev)
+		data[0] = TYPE_NO_LUN;
+
+	return SAM_STAT_GOOD;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int sbc_inquiry(int host_no, struct scsi_cmd *cmd)
+{
+	int ret, lid = cmd->c_target->lid;
+
+	if (tgt_drivers[lid]->scsi_inquiry)
+		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd);
+	else
+		ret = __sbc_inquiry(host_no, cmd);
+	return ret;
+}
+
+static int sbc_reserve(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	if (cmd->dev) {
+		ret = device_reserve(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+		else
+			ret = SAM_STAT_GOOD;
+	} else {
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+	return ret;
+}
+
+static int sbc_release(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	if (cmd->dev) {
+		ret = device_release(cmd->cmd_nexus_id, cmd->dev->lun, host_no, 0);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+		else
+			ret = SAM_STAT_GOOD;
+	} else {
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+	return ret;
+}
+
+static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
+{
+	uint32_t *data;
+	uint64_t size;
+	uint8_t *scb = cmd->scb;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else
+		goto sense;
+
+	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
+		asc = 0x24;
+		goto sense;
+	}
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	cmd->uaddr = (unsigned long) data;
+
+	size = cmd->dev->size >> BLK_SHIFT;
+
+	data[0] = (size >> 32) ?
+		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
+	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
+	cmd->len = 8;
+
+	return SAM_STAT_GOOD;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
+{
+	int ret, len;
+	uint8_t key = ILLEGAL_REQUEST, asc;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		asc = 0x25;
+		goto sense;
+	}
+
+	ret = fsync(cmd->dev->fd);
+
+	switch (ret) {
+	case EROFS:
+	case EINVAL:
+	case EBADF:
+	case EIO:
+		/*
+		 * is this the right sense code?
+		 * what should I put for the asc/ascq?
+		 */
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	default:
+		len = 0;
+		return SAM_STAT_GOOD;
+	}
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int insert_disconnect_pg(uint8_t *ptr)
+{
+	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
+                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
+	return sizeof(disconnect_pg);
+}
+
+static int insert_caching_pg(uint8_t *ptr)
+{
+	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
+				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
+				      0x00, 0x00, 0x00, 0x00};
+
+	memcpy(ptr, caching_pg, sizeof(caching_pg));
+	return sizeof(caching_pg);
+}
+
+static int insert_ctrl_m_pg(uint8_t *ptr)
+{
+	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x02, 0x4b};
+
+	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
+	return sizeof(ctrl_m_pg);
+}
+
+static int insert_iec_m_pg(uint8_t *ptr)
+{
+	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00};
+
+	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
+	return sizeof(iec_m_pg);
+}
+
+static int insert_format_m_pg(uint8_t *ptr)
+{
+	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
+				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
+	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
+	return sizeof(format_m_pg);
+}
+
+static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
+{
+	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
+	uint32_t ncyl, *p;
+
+	/* assume 0xff heads, 15krpm. */
+	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
+	ncyl = sec >> 14; /* 256 * 64 */
+	p = (uint32_t *)(ptr + 1);
+	*p = *p | __cpu_to_be32(ncyl);
+	return sizeof(geo_m_pg);
+}
+
+static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	int ret = SAM_STAT_GOOD, len;
+	uint8_t pcode = cmd->scb[2] & 0x3f;
+	uint64_t size;
+	uint8_t *data = NULL;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	len = 4;
+	size = cmd->dev->size >> BLK_SHIFT;
+
+	if ((cmd->scb[1] & 0x8))
+		data[3] = 0;
+	else {
+		data[3] = 8;
+		len += 8;
+		*(uint32_t *)(data + 4) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
+	}
+
+	switch (pcode) {
+	case 0x0:
+		break;
+	case 0x2:
+		len += insert_disconnect_pg(data + len);
+		break;
+	case 0x3:
+		len += insert_format_m_pg(data + len);
+		break;
+	case 0x4:
+		len += insert_geo_m_pg(data + len, size);
+		break;
+	case 0x8:
+		len += insert_caching_pg(data + len);
+		break;
+	case 0xa:
+		len += insert_ctrl_m_pg(data + len);
+		break;
+	case 0x1c:
+		len += insert_iec_m_pg(data + len);
+		break;
+	case 0x3f:
+		len += insert_disconnect_pg(data + len);
+		len += insert_format_m_pg(data + len);
+		len += insert_geo_m_pg(data + len, size);
+		len += insert_caching_pg(data + len);
+		len += insert_ctrl_m_pg(data + len);
+		len += insert_iec_m_pg(data + len);
+		break;
+	default:
+		asc = 0x24;
+		goto sense;
+	}
+
+	data[0] = len - 1;
+	cmd->len = len;
+	cmd->uaddr = (unsigned long) data;
+	return ret;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+struct device_command_operations sbc_ops[] = {
+	{sbc_test_unit,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_request_sense,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0x10 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_inquiry,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_reserve,},
+	{sbc_release,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_mode_sense,},
+	{spc_start_stop,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0x20 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_read_capacity,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{sbc_test_unit},
+
+	/* 0x30 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_sync_cache,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	[0x40 ... 0x7f] = {spc_illegal_op,},
+
+	/* 0x80 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw},
+	{sbc_test_unit},
+
+	/* 0x90 */
+	{spc_illegal_op,},
+	{sbc_sync_cache,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0xA0 */
+	{spc_report_luns,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{sbc_rw,},
+	{sbc_test_unit,},
+
+	[0xb0 ... 0xff] = {spc_illegal_op},
+};

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/scsi.c	2007-03-03 11:29:27 UTC (rev 794)
@@ -1,15 +1,24 @@
 /*
- * SCSI command processing
+ * SCSI lib functions
  *
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
- * SCSI target emulation code is based on Ardis's iSCSI implementation.
- *   http://www.ardistech.com/iscsi/
- *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
- *   licensed under the terms of the GNU GPL v2.0,
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
@@ -27,9 +36,8 @@
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
+#include "spc.h"
 
-#define BLK_SHIFT	9
-
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
 	int len = 0xa;
@@ -72,714 +80,8 @@
 	return fn(p);
 }
 
-static int sbc_test_unit(int host_no, struct scsi_cmd *cmd)
-{
-	int ret = SAM_STAT_GOOD;
-
-	/* how should we test a backing-storage file? */
-
-	if (cmd->dev) {
-		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
-		if (ret)
-			ret = SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
-		ret = SAM_STAT_CHECK_CONDITION;
-	}
-	return ret;
-}
-
-static int sbc_request_sense(int host_no, struct scsi_cmd *cmd)
-{
-	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
-	return SAM_STAT_GOOD;
-}
-
-static int __spc_report_luns(int host_no, struct scsi_cmd *cmd)
-{
-	struct tgt_device *dev;
-	struct list_head *dev_list = &cmd->c_target->device_list;
-	uint64_t lun, *data;
-	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	int *len = &cmd->len;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
-
-	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
-	if (alen < 16)
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	alen &= ~(8 - 1);
-	oalen = alen;
-
-	alen -= 8;
-	rbuflen -= 8; /* FIXME */
-	idx = 1;
-	nr_luns = 0;
-
-	overflow = 0;
-	list_for_each_entry(dev, dev_list, device_siblings) {
-		nr_luns++;
-
-		if (overflow)
-			continue;
-
-		lun = dev->lun;
-		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);
-		data[idx++] = __cpu_to_be64(lun << 32);
-		if (!(alen -= 8))
-			overflow = 1;
-		if (!(rbuflen -= 8)) {
-			fprintf(stderr, "FIXME: too many luns\n");
-			exit(-1);
-		}
-	}
-
-	cmd->uaddr = (unsigned long)data;
-	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
-	return SAM_STAT_GOOD;
-sense:
-	*len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int spc_report_luns(int host_no, struct scsi_cmd *cmd)
-{
-	struct target *target = cmd->c_target;
-	int ret, lid = target->lid;
-
-	/* temp hack */
-	if (tgt_drivers[lid]->scsi_report_luns)
-		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd);
-	else
-		ret = __spc_report_luns(host_no, cmd);
-
-	return ret;
-}
-
-static uint64_t sbc_rw_offset(uint8_t *scb)
-{
-	uint64_t off;
-
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		off = 0;
-		break;
-	}
-
-	return off << BLK_SHIFT;
-}
-
-static int sbc_rw(int host_no, struct scsi_cmd *cmd)
-{
-	int ret;
-	unsigned long uaddr;
-	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-	if (cmd->dev) {
-		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
-		if (ret)
-			return SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		ret = SAM_STAT_CHECK_CONDITION;
-		goto sense;
-	}
-
-	switch (cmd->scb[0]) {
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		cmd->rw = WRITE;
-		break;
-	default:
-		break;
-	}
-
-	cmd->offset = sbc_rw_offset(cmd->scb);
-	uaddr = cmd->uaddr;
-	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-		     cmd->offset, &cmd->async, (void *)cmd);
-	if (ret) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-	} else {
-		cmd->mmapped = 1;
-		cmd->uaddr = uaddr;
-		return SAM_STAT_GOOD;
-	}
-sense:
-	cmd->rw = READ;
-	cmd->offset = 0;
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-#define VENDOR_ID	"IET"
-#define PRODUCT_ID	"VIRTUAL-DISK"
-#define PRODUCT_REV	"0"
-
-static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	uint8_t *data;
-	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
-
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		data[2] = 4;
-		data[3] = 0x42;
-		data[4] = 59;
-		data[7] = 0x02;
-		memset(data + 8, 0x20, 28);
-		memcpy(data + 8,
-		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
-		memcpy(data + 16,
-		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
-		memcpy(data + 32,
-		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
-		data[58] = 0x03;
-		data[59] = 0x20;
-		data[60] = 0x09;
-		data[61] = 0x60;
-		data[62] = 0x03;
-		data[63] = 0x00;
-		len = 64;
-		ret = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x2) {
-		/* CmdDt bit is set */
-		/* We do not support it now. */
-		data[1] = 0x1;
-		data[5] = 0;
-		len = 6;
-		ret = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x1) {
-		/* EVPD bit set */
-		if (scb[2] == 0x0) {
-			data[1] = 0x0;
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			int tmp = SCSI_SN_LEN;
-
-			data[1] = 0x80;
-			data[3] = SCSI_SN_LEN;
-			memset(data + 4, 0x20, 4);
-			len = 4 + SCSI_SN_LEN;
-			ret = SAM_STAT_GOOD;
-
-			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
-				uint8_t *p;
-				char *q;
-
-				p = data + 4 + tmp - 1;
-				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
-				for (; tmp > 0; tmp--, q)
-					*(p--) = *q;
-			}
-		} else if (scb[2] == 0x83) {
-			int tmp = SCSI_ID_LEN;
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			if (cmd->dev)
-				strncpy((char *) data + 8, cmd->dev->scsi_id,
-				        SCSI_ID_LEN);
-			len = tmp + 8;
-			ret = SAM_STAT_GOOD;
-		}
-	}
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
-	if (!cmd->dev)
-		data[0] = TYPE_NO_LUN;
-
-	return SAM_STAT_GOOD;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int sbc_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	int ret, lid = cmd->c_target->lid;
-
-	if (tgt_drivers[lid]->scsi_inquiry)
-		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd);
-	else
-		ret = __sbc_inquiry(host_no, cmd);
-	return ret;
-}
-
-static int sbc_reserve(int host_no, struct scsi_cmd *cmd)
-{
-	int ret;
-
-	if (cmd->dev) {
-		ret = device_reserve(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
-		if (ret)
-			ret = SAM_STAT_RESERVATION_CONFLICT;
-		else
-			ret = SAM_STAT_GOOD;
-	} else {
-		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
-		ret = SAM_STAT_CHECK_CONDITION;
-	}
-	return ret;
-}
-
-static int sbc_release(int host_no, struct scsi_cmd *cmd)
-{
-	int ret;
-
-	if (cmd->dev) {
-		ret = device_release(cmd->cmd_nexus_id, cmd->dev->lun, host_no, 0);
-		if (ret)
-			ret = SAM_STAT_RESERVATION_CONFLICT;
-		else
-			ret = SAM_STAT_GOOD;
-	} else {
-		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
-		ret = SAM_STAT_CHECK_CONDITION;
-	}
-	return ret;
-}
-
-static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
-{
-	uint32_t *data;
-	uint64_t size;
-	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
-			return SAM_STAT_RESERVATION_CONFLICT;
-	} else
-		goto sense;
-
-	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		asc = 0x24;
-		goto sense;
-	}
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	cmd->uaddr = (unsigned long) data;
-
-	size = cmd->dev->size >> BLK_SHIFT;
-
-	data[0] = (size >> 32) ?
-		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
-	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
-	cmd->len = 8;
-
-	return SAM_STAT_GOOD;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
-{
-	int ret, len;
-	uint8_t key = ILLEGAL_REQUEST, asc;
-
-	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
-			return SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		asc = 0x25;
-		goto sense;
-	}
-
-	ret = fsync(cmd->dev->fd);
-
-	switch (ret) {
-	case EROFS:
-	case EINVAL:
-	case EBADF:
-	case EIO:
-		/*
-		 * is this the right sense code?
-		 * what should I put for the asc/ascq?
-		 */
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	default:
-		len = 0;
-		return SAM_STAT_GOOD;
-	}
-
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int insert_disconnect_pg(uint8_t *ptr)
-{
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
-}
-
-static int insert_caching_pg(uint8_t *ptr)
-{
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
-}
-
-static int insert_ctrl_m_pg(uint8_t *ptr)
-{
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
-
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
-}
-
-static int insert_iec_m_pg(uint8_t *ptr)
-{
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
-}
-
-static int insert_format_m_pg(uint8_t *ptr)
-{
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
-}
-
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
-{
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
-
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
-}
-
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
-{
-	int ret = SAM_STAT_GOOD, len;
-	uint8_t pcode = cmd->scb[2] & 0x3f;
-	uint64_t size;
-	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
-			return SAM_STAT_RESERVATION_CONFLICT;
-	} else
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	len = 4;
-	size = cmd->dev->size >> BLK_SHIFT;
-
-	if ((cmd->scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
-			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
-
-	switch (pcode) {
-	case 0x0:
-		break;
-	case 0x2:
-		len += insert_disconnect_pg(data + len);
-		break;
-	case 0x3:
-		len += insert_format_m_pg(data + len);
-		break;
-	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
-		break;
-	case 0x8:
-		len += insert_caching_pg(data + len);
-		break;
-	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
-		break;
-	case 0x1c:
-		len += insert_iec_m_pg(data + len);
-		break;
-	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
-		break;
-	default:
-		asc = 0x24;
-		goto sense;
-	}
-
-	data[0] = len - 1;
-	cmd->len = len;
-	cmd->uaddr = (unsigned long) data;
-	return ret;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int spc_start_stop(int host_no, struct scsi_cmd *cmd)
-{
-	cmd->len = 0;
-
-	if (cmd->dev) {
-		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
-			return SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-	return SAM_STAT_GOOD;
-}
-
-static int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
-{
-	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST,0x24, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-struct device_command_operations sbc_ops[] = {
-	{sbc_test_unit,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_request_sense,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	/* 0x10 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_inquiry,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_reserve,},
-	{sbc_release,},
-
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_mode_sense,},
-	{spc_start_stop,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	/* 0x20 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_read_capacity,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{sbc_rw},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{sbc_test_unit},
-
-	/* 0x30 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_sync_cache,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	[0x40 ... 0x7f] = {spc_illegal_op,},
-
-	/* 0x80 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{sbc_test_unit},
-
-	/* 0x90 */
-	{spc_illegal_op,},
-	{sbc_sync_cache,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	/* 0xA0 */
-	{spc_report_luns,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{sbc_test_unit,},
-
-	[0xb0 ... 0xff] = {spc_illegal_op},
-};
-
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	unsigned char op = cmd->scb[0];
-
-	return sbc_ops[op].cmd_perform(host_no, cmd);
+	return cmd->c_target->dev_cmd_ops[op].cmd_perform(host_no, cmd);
 }

Added: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/spc.c	2007-03-03 11:29:27 UTC (rev 794)
@@ -0,0 +1,125 @@
+/*
+ * SCSI primary command processing
+ *
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "scsi.h"
+#include "spc.h"
+
+static int __spc_report_luns(int host_no, struct scsi_cmd *cmd)
+{
+	struct tgt_device *dev;
+	struct list_head *dev_list = &cmd->c_target->device_list;
+	uint64_t lun, *data;
+	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
+	int *len = &cmd->len;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+
+	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
+	if (alen < 16)
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	alen &= ~(8 - 1);
+	oalen = alen;
+
+	alen -= 8;
+	rbuflen -= 8; /* FIXME */
+	idx = 1;
+	nr_luns = 0;
+
+	overflow = 0;
+	list_for_each_entry(dev, dev_list, device_siblings) {
+		nr_luns++;
+
+		if (overflow)
+			continue;
+
+		lun = dev->lun;
+		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);
+		data[idx++] = __cpu_to_be64(lun << 32);
+		if (!(alen -= 8))
+			overflow = 1;
+		if (!(rbuflen -= 8)) {
+			fprintf(stderr, "FIXME: too many luns\n");
+			exit(-1);
+		}
+	}
+
+	cmd->uaddr = (unsigned long)data;
+	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
+	*len = min(oalen, nr_luns * 8 + 8);
+	return SAM_STAT_GOOD;
+sense:
+	*len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+int spc_report_luns(int host_no, struct scsi_cmd *cmd)
+{
+	struct target *target = cmd->c_target;
+	int ret, lid = target->lid;
+
+	/* temp hack */
+	if (tgt_drivers[lid]->scsi_report_luns)
+		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd);
+	else
+		ret = __spc_report_luns(host_no, cmd);
+
+	return ret;
+}
+
+int spc_start_stop(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+
+	if (cmd->dev) {
+		if (device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no))
+			return SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	return SAM_STAT_GOOD;
+}
+
+int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+	sense_data_build(cmd, ILLEGAL_REQUEST,0x24, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}

Added: trunk/usr/spc.h
===================================================================
--- trunk/usr/spc.h	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/spc.h	2007-03-03 11:29:27 UTC (rev 794)
@@ -0,0 +1,9 @@
+#ifndef __SPC_H
+#define __SPC_H
+
+extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
+extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
+extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
+
+#endif
+

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/target.c	2007-03-03 11:29:27 UTC (rev 794)
@@ -36,6 +36,8 @@
 #include "scsi.h"
 #include "tgtadm.h"
 
+extern struct device_command_operations sbc_ops[];
+
 static LIST_HEAD(target_list);
 
 static struct target *target_lookup(int tid)
@@ -1219,6 +1221,15 @@
 	if (!target)
 		return TGTADM_NOMEM;
 
+	switch (t_type) {
+	case TARGET_SBC:
+		target->dev_cmd_ops = sbc_ops;
+		break;
+	default:
+		free(target);
+		return TGTADM_INVALID_REQUEST;
+	}
+
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-03 10:47:55 UTC (rev 793)
+++ trunk/usr/target.h	2007-03-03 11:29:27 UTC (rev 794)
@@ -57,6 +57,8 @@
 	struct list_head acl_list;
 
 	struct tgt_account account;
+
+	struct device_command_operations *dev_cmd_ops;
 };
 
 struct it_nexus {



From tomo at mail.berlios.de  Sat Mar  3 14:29:55 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 14:29:55 +0100
Subject: [Stgt-svn] r795 - trunk/usr
Message-ID: <200703031329.l23DTtD2006294@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 14:29:54 +0100 (Sat, 03 Mar 2007)
New Revision: 795

Added:
   trunk/usr/spt.c
Removed:
   trunk/usr/bd_sg.c
Modified:
   trunk/usr/Makefile
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
change pass through from backing storage type to target type


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/Makefile	2007-03-03 13:29:54 UTC (rev 795)
@@ -21,7 +21,7 @@
 endif
 
 ifneq ($(RAW),)
-TGTD_OBJS += bd_sg.o
+TGTD_OBJS += spt.o
 CFLAGS += -DUSE_RAW
 endif
 

Deleted: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/bd_sg.c	2007-03-03 13:29:54 UTC (rev 795)
@@ -1,219 +0,0 @@
-/*
- * rawio routine
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/epoll.h>
-#include <limits.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-#include <linux/types.h>
-#include <scsi/sg.h>
-#include <linux/bsg.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-#include "target.h"
-
-static void sg_handler(int fd, int events, void *data)
-{
-	int i, err;
-	struct sg_io_v4 hdrs[64];
-	struct tgt_device *dev = data;
-
-	err = read(dev->fd, hdrs, sizeof(hdrs));
-	if (err < 0)
-		return;
-
-	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
-		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
-		if (hdrs[i].din_resid)
-			cmd->len = hdrs[i].din_resid;
-		target_cmd_io_done(cmd, 0);
-	}
-}
-
-static int bd_sg_open(struct tgt_device *dev,
-		      char *path, int *fd, uint64_t *size)
-{
-	int err, maj, min;
-	char *sd, buf[256];
-	struct stat64 st;
-	struct timeval t;
-	struct sg_io_v4 hdr, *h;
-	int nr_queue_cmd;
-
-	/* we assume something like /dev/sda */
-	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
-
-	*fd = backed_file_open(path, 0, size);
-	if (*fd < 0)
-		return *fd;
-
-	err = fstat64(*fd, &st);
-	if (err < 0) {
-		eprintf("can't get stat %d, %m\n", *fd);
-		goto close_fd;
-	}
-
-	if(!S_ISBLK(st.st_mode)) {
-		eprintf("only scsi devices are supported %s\n", path);
-		err = -EINVAL;
-		goto close_fd;
-	}
-
-	close(*fd);
-
-	sd = strrchr(path, '/');
-	if (!sd) {
-		eprintf("invalid path %s\n", path);
-		return -EINVAL;
-	}
-
-	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
-	*fd = open(buf, O_RDONLY);
-	if (*fd < 0) {
-		eprintf("can't open %s, %m\n", buf);
-		return -errno;
-	}
-
-	err = read(*fd, buf, sizeof(buf));
-	if (err < 0) {
-		eprintf("can't open %s, %m\n", buf);
-		goto close_fd;
-	}
-
-	err = sscanf(buf, "%u:%u", &maj, &min);
-	if (err < 0) {
-		eprintf("can't get bsg major/minor number %s, %m\n", buf);
-		goto close_fd;
-	}
-
-	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
-	close(*fd);
-
-	err = gettimeofday(&t, NULL);
-	if (err) {
-		eprintf("can't get temporary name for bsg device, %m\n");
-		return -errno;
-	}
-
-	memset(buf, 0, sizeof(buf));
-	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
-	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
-		    maj << 8 | min);
-	if (err < 0) {
-		eprintf("can't create the bsg device %s, %m\n", buf);
-		return -errno;
-	}
-
-	*fd = open(buf, O_RDWR | O_NONBLOCK);
-
-	dprintf("%d %s\n", *fd, buf);
-	unlink(buf);
-
-	if (*fd < 0) {
-		eprintf("can't open the bsg device %s, %m\n", buf);
-		return -errno;
-	}
-
-	/* workaround */
-	nr_queue_cmd = 128;
-	err = ioctl(*fd, SG_SET_COMMAND_Q, &nr_queue_cmd);
-	if (err) {
-		eprintf("can't set the queue depth %d, %m\n", nr_queue_cmd);
-		goto close_fd;
-	}
-
-	err = tgt_event_add(*fd, EPOLLIN, sg_handler, dev);
-	if (err) {
-		free(dev);
-		goto close_fd;
-	}
-
-	return 0;
-close_fd:
-	close(*fd);
-	return err;
-}
-
-static void bd_sg_close(struct tgt_device *dev)
-{
-	tgt_event_del(dev->fd);
-	close(dev->fd);
-}
-
-static int bd_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	return 0;
-}
-
-static int bd_sg_cmd_submit(struct tgt_device *dev, uint8_t *scb,
-			    int rw, uint32_t datalen, unsigned long *uaddr,
-			    uint64_t offset, int *async, void *key)
-{
-	int err;
-	struct sg_io_v4 hdr;
-
-	/* TODO sense */
-
-	dprintf("%x %d %u %lx\n", scb[0], rw, datalen, *uaddr);
-	memset(&hdr, 0, sizeof(hdr));
-	hdr.guard = 'Q';
-	hdr.request_len = 16;
-	hdr.request = (unsigned long) scb;
-
-	if (rw) {
-		hdr.dout_xfer_len = datalen;
-		hdr.dout_xferp = *uaddr;
-	} else {
-		hdr.din_xfer_len = datalen;
-		hdr.din_xferp = *uaddr;
-	}
-
-/* 	hdr.max_response_len = sizeof(sense); */
-/* 	hdr.response = (unsigned long) sense; */
-
-	hdr.usr_ptr = (unsigned long) key;
-
-	*async = 1;
-
-	err = write(dev->fd, &hdr, sizeof(hdr));
-	if (err != sizeof(hdr))
-		eprintf("%d %m\n", err);
-	else
-		err = 0;
-	return err;
-}
-
-struct backedio_template sg_bdt = {
-	.bd_open		= bd_sg_open,
-	.bd_close		= bd_sg_close,
-	.bd_cmd_submit		= bd_sg_cmd_submit,
-	.bd_cmd_done		= bd_sg_cmd_done,
-};

Copied: trunk/usr/spt.c (from rev 794, trunk/usr/bd_sg.c)
===================================================================
--- trunk/usr/bd_sg.c	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/spt.c	2007-03-03 13:29:54 UTC (rev 795)
@@ -0,0 +1,254 @@
+/*
+ * SCSI pass through
+ *
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <linux/types.h>
+#include <scsi/sg.h>
+#include <linux/bsg.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "scsi.h"
+#include "spc.h"
+
+static void sg_handler(int fd, int events, void *data)
+{
+	int i, err;
+	struct sg_io_v4 hdrs[64];
+	struct tgt_device *dev = data;
+
+	err = read(dev->fd, hdrs, sizeof(hdrs));
+	if (err < 0)
+		return;
+
+	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
+		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
+		if (hdrs[i].din_resid)
+			cmd->len = hdrs[i].din_resid;
+		target_cmd_io_done(cmd, 0);
+	}
+}
+
+static int bd_sg_open(struct tgt_device *dev,
+		      char *path, int *fd, uint64_t *size)
+{
+	int err, maj, min;
+	char *sd, buf[256];
+	struct stat64 st;
+	struct timeval t;
+	struct sg_io_v4 hdr, *h;
+	int nr_queue_cmd;
+
+	/* we assume something like /dev/sda */
+	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
+
+	*fd = backed_file_open(path, 0, size);
+	if (*fd < 0)
+		return *fd;
+
+	err = fstat64(*fd, &st);
+	if (err < 0) {
+		eprintf("can't get stat %d, %m\n", *fd);
+		goto close_fd;
+	}
+
+	if(!S_ISBLK(st.st_mode)) {
+		eprintf("only scsi devices are supported %s\n", path);
+		err = -EINVAL;
+		goto close_fd;
+	}
+
+	close(*fd);
+
+	sd = strrchr(path, '/');
+	if (!sd) {
+		eprintf("invalid path %s\n", path);
+		return -EINVAL;
+	}
+
+	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
+	*fd = open(buf, O_RDONLY);
+	if (*fd < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		return -errno;
+	}
+
+	err = read(*fd, buf, sizeof(buf));
+	if (err < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	err = sscanf(buf, "%u:%u", &maj, &min);
+	if (err < 0) {
+		eprintf("can't get bsg major/minor number %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
+	close(*fd);
+
+	err = gettimeofday(&t, NULL);
+	if (err) {
+		eprintf("can't get temporary name for bsg device, %m\n");
+		return -errno;
+	}
+
+	memset(buf, 0, sizeof(buf));
+	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
+	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
+		    maj << 8 | min);
+	if (err < 0) {
+		eprintf("can't create the bsg device %s, %m\n", buf);
+		return -errno;
+	}
+
+	*fd = open(buf, O_RDWR | O_NONBLOCK);
+
+	dprintf("%d %s\n", *fd, buf);
+	unlink(buf);
+
+	if (*fd < 0) {
+		eprintf("can't open the bsg device %s, %m\n", buf);
+		return -errno;
+	}
+
+	/* workaround */
+	nr_queue_cmd = 128;
+	err = ioctl(*fd, SG_SET_COMMAND_Q, &nr_queue_cmd);
+	if (err) {
+		eprintf("can't set the queue depth %d, %m\n", nr_queue_cmd);
+		goto close_fd;
+	}
+
+	err = tgt_event_add(*fd, EPOLLIN, sg_handler, dev);
+	if (err) {
+		free(dev);
+		goto close_fd;
+	}
+
+	return 0;
+close_fd:
+	close(*fd);
+	return err;
+}
+
+static void bd_sg_close(struct tgt_device *dev)
+{
+	tgt_event_del(dev->fd);
+	close(dev->fd);
+}
+
+static int bd_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	return 0;
+}
+
+static int sg_cmd_submit(struct scsi_cmd *cmd)
+{
+	int ret;
+	struct sg_io_v4 hdr;
+
+	/* TODO sense */
+
+	dprintf("%x %d %u %" PRIx64"\n", cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr);
+	memset(&hdr, 0, sizeof(hdr));
+	hdr.guard = 'Q';
+	hdr.request_len = 16;
+	hdr.request = (unsigned long) cmd->scb;
+
+	if (cmd->rw) {
+		hdr.dout_xfer_len = cmd->len;
+		hdr.dout_xferp = cmd->uaddr;
+	} else {
+		hdr.din_xfer_len = cmd->len;
+		hdr.din_xferp = cmd->uaddr;
+	}
+
+	hdr.max_response_len = sizeof(cmd->sense_buffer);
+	hdr.response = (unsigned long) cmd->sense_buffer;
+
+	hdr.usr_ptr = (unsigned long) cmd;
+
+	ret = write(cmd->dev->fd, &hdr, sizeof(hdr));
+	if (ret == sizeof(hdr)) {
+		cmd->async = 1;
+		return 0;
+	} else {
+		eprintf("%d %m\n", ret);
+		return -1;
+	}
+}
+
+struct backedio_template sg_bdt = {
+	.bd_open		= bd_sg_open,
+	.bd_close		= bd_sg_close,
+	.bd_cmd_done		= bd_sg_cmd_done,
+};
+
+static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+	ret = sg_cmd_submit(cmd);
+	if (ret) {
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	} else
+		return SAM_STAT_GOOD;
+}
+
+struct device_command_operations spt_ops[] = {
+	[0x40 ... 0x7f] = {spt_cmd_perform,},
+
+	{spc_report_luns,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+	{spt_cmd_perform,},
+
+	[0xb0 ... 0xff] = {spt_cmd_perform},
+};

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/target.c	2007-03-03 13:29:54 UTC (rev 795)
@@ -36,7 +36,7 @@
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_command_operations sbc_ops[];
+extern struct device_command_operations sbc_ops[], spt_ops[];
 
 static LIST_HEAD(target_list);
 
@@ -431,25 +431,6 @@
 
 	cmd->dev = device_lookup(target, dev_id);
 
-	/* FIXME */
-	if (target->target_iotype == SCSI_TARGET_RAWIO) {
-		dprintf("%u %s\n", scb[0], cmd->dev ? "do sg" : "fake");
-
-		/* we can't pass through REPORT_LUNS. */
-		if (cmd->dev && scb[0] != REPORT_LUNS) {
-			uint64_t offset = 0;
-			int async = 0;
-
-			target->bdt->bd_cmd_submit(cmd->dev, cmd->scb, rw,
-						   data_len, &uaddr, offset,
-						   &async, (void *) cmd);
-			cmd->len = data_len;
-			cmd->uaddr = uaddr;
-			goto out;
-		} else
-			enabled = 1;
-	}
-
 	if (cmd->dev)
 		q = &cmd->dev->cmd_queue;
 	else
@@ -477,7 +458,7 @@
 
 		list_add_tail(&cmd->qlist, &q->queue);
 	}
-out:
+
 	return 0;
 }
 
@@ -1225,6 +1206,9 @@
 	case TARGET_SBC:
 		target->dev_cmd_ops = sbc_ops;
 		break;
+	case TARGET_SPT:
+		target->dev_cmd_ops = spt_ops;
+		break;
 	default:
 		free(target);
 		return TGTADM_INVALID_REQUEST;
@@ -1251,7 +1235,7 @@
 	INIT_LIST_HEAD(&target->device_list);
 
 	/* FIXME */
-	if (bs_type == LU_BS_RAW) {
+	if (t_type == TARGET_SPT) {
 		target->target_iotype = SCSI_TARGET_RAWIO;
 		target->bdt = &sg_bdt;
 	} else {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/tgtadm.c	2007-03-03 13:29:54 UTC (rev 795)
@@ -315,6 +315,8 @@
 	} else if (!strcmp(str, "osd")) {
 		eprintf("osd isn't supported yet\n");
 		exit(EINVAL);
+	} else if (!strcmp(str, "pt")) {
+		return TARGET_SPT;
 	} else {
 		eprintf("unknown target type: %s\n", str);
 		exit(EINVAL);

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2007-03-03 11:29:27 UTC (rev 794)
+++ trunk/usr/tgtadm.h	2007-03-03 13:29:54 UTC (rev 795)
@@ -54,6 +54,7 @@
 	TARGET_SSC, /* tape */
 	TARGET_MMC, /* cdrom */
 	TARGET_OSD, /* object storage device */
+	TARGET_SPT, /* pass through */
 };
 
 /* backing store type */



From tomo at mail.berlios.de  Sat Mar  3 14:37:07 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 14:37:07 +0100
Subject: [Stgt-svn] r796 - trunk/usr
Message-ID: <200703031337.l23Db70K006788@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 14:37:06 +0100 (Sat, 03 Mar 2007)
New Revision: 796

Added:
   trunk/usr/spt_sgv4.c
Modified:
   trunk/usr/Makefile
   trunk/usr/spt.c
Log:
Preparation to add sgv3 pass through support


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-03 13:29:54 UTC (rev 795)
+++ trunk/usr/Makefile	2007-03-03 13:37:06 UTC (rev 796)
@@ -21,7 +21,7 @@
 endif
 
 ifneq ($(RAW),)
-TGTD_OBJS += spt.o
+TGTD_OBJS += spt.o spt_sgv4.o
 CFLAGS += -DUSE_RAW
 endif
 

Modified: trunk/usr/spt.c
===================================================================
--- trunk/usr/spt.c	2007-03-03 13:29:54 UTC (rev 795)
+++ trunk/usr/spt.c	2007-03-03 13:37:06 UTC (rev 796)
@@ -42,185 +42,30 @@
 #include "scsi.h"
 #include "spc.h"
 
-static void sg_handler(int fd, int events, void *data)
-{
-	int i, err;
-	struct sg_io_v4 hdrs[64];
-	struct tgt_device *dev = data;
+extern int spt_sg_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
+extern int spt_sg_perform(struct scsi_cmd *cmd);
 
-	err = read(dev->fd, hdrs, sizeof(hdrs));
-	if (err < 0)
-		return;
-
-	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
-		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
-		if (hdrs[i].din_resid)
-			cmd->len = hdrs[i].din_resid;
-		target_cmd_io_done(cmd, 0);
-	}
-}
-
-static int bd_sg_open(struct tgt_device *dev,
-		      char *path, int *fd, uint64_t *size)
+static void spt_sg_close(struct tgt_device *dev)
 {
-	int err, maj, min;
-	char *sd, buf[256];
-	struct stat64 st;
-	struct timeval t;
-	struct sg_io_v4 hdr, *h;
-	int nr_queue_cmd;
-
-	/* we assume something like /dev/sda */
-	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
-
-	*fd = backed_file_open(path, 0, size);
-	if (*fd < 0)
-		return *fd;
-
-	err = fstat64(*fd, &st);
-	if (err < 0) {
-		eprintf("can't get stat %d, %m\n", *fd);
-		goto close_fd;
-	}
-
-	if(!S_ISBLK(st.st_mode)) {
-		eprintf("only scsi devices are supported %s\n", path);
-		err = -EINVAL;
-		goto close_fd;
-	}
-
-	close(*fd);
-
-	sd = strrchr(path, '/');
-	if (!sd) {
-		eprintf("invalid path %s\n", path);
-		return -EINVAL;
-	}
-
-	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
-	*fd = open(buf, O_RDONLY);
-	if (*fd < 0) {
-		eprintf("can't open %s, %m\n", buf);
-		return -errno;
-	}
-
-	err = read(*fd, buf, sizeof(buf));
-	if (err < 0) {
-		eprintf("can't open %s, %m\n", buf);
-		goto close_fd;
-	}
-
-	err = sscanf(buf, "%u:%u", &maj, &min);
-	if (err < 0) {
-		eprintf("can't get bsg major/minor number %s, %m\n", buf);
-		goto close_fd;
-	}
-
-	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
-	close(*fd);
-
-	err = gettimeofday(&t, NULL);
-	if (err) {
-		eprintf("can't get temporary name for bsg device, %m\n");
-		return -errno;
-	}
-
-	memset(buf, 0, sizeof(buf));
-	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
-	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
-		    maj << 8 | min);
-	if (err < 0) {
-		eprintf("can't create the bsg device %s, %m\n", buf);
-		return -errno;
-	}
-
-	*fd = open(buf, O_RDWR | O_NONBLOCK);
-
-	dprintf("%d %s\n", *fd, buf);
-	unlink(buf);
-
-	if (*fd < 0) {
-		eprintf("can't open the bsg device %s, %m\n", buf);
-		return -errno;
-	}
-
-	/* workaround */
-	nr_queue_cmd = 128;
-	err = ioctl(*fd, SG_SET_COMMAND_Q, &nr_queue_cmd);
-	if (err) {
-		eprintf("can't set the queue depth %d, %m\n", nr_queue_cmd);
-		goto close_fd;
-	}
-
-	err = tgt_event_add(*fd, EPOLLIN, sg_handler, dev);
-	if (err) {
-		free(dev);
-		goto close_fd;
-	}
-
-	return 0;
-close_fd:
-	close(*fd);
-	return err;
-}
-
-static void bd_sg_close(struct tgt_device *dev)
-{
 	tgt_event_del(dev->fd);
 	close(dev->fd);
 }
 
-static int bd_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+static int spt_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	return 0;
 }
 
-static int sg_cmd_submit(struct scsi_cmd *cmd)
-{
-	int ret;
-	struct sg_io_v4 hdr;
-
-	/* TODO sense */
-
-	dprintf("%x %d %u %" PRIx64"\n", cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr);
-	memset(&hdr, 0, sizeof(hdr));
-	hdr.guard = 'Q';
-	hdr.request_len = 16;
-	hdr.request = (unsigned long) cmd->scb;
-
-	if (cmd->rw) {
-		hdr.dout_xfer_len = cmd->len;
-		hdr.dout_xferp = cmd->uaddr;
-	} else {
-		hdr.din_xfer_len = cmd->len;
-		hdr.din_xferp = cmd->uaddr;
-	}
-
-	hdr.max_response_len = sizeof(cmd->sense_buffer);
-	hdr.response = (unsigned long) cmd->sense_buffer;
-
-	hdr.usr_ptr = (unsigned long) cmd;
-
-	ret = write(cmd->dev->fd, &hdr, sizeof(hdr));
-	if (ret == sizeof(hdr)) {
-		cmd->async = 1;
-		return 0;
-	} else {
-		eprintf("%d %m\n", ret);
-		return -1;
-	}
-}
-
 struct backedio_template sg_bdt = {
-	.bd_open		= bd_sg_open,
-	.bd_close		= bd_sg_close,
-	.bd_cmd_done		= bd_sg_cmd_done,
+	.bd_open		= spt_sg_open,
+	.bd_close		= spt_sg_close,
+	.bd_cmd_done		= spt_sg_cmd_done,
 };
 
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	ret = sg_cmd_submit(cmd);
+	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
 		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);

Added: trunk/usr/spt_sgv4.c
===================================================================
--- trunk/usr/spt_sgv4.c	2007-03-03 13:29:54 UTC (rev 795)
+++ trunk/usr/spt_sgv4.c	2007-03-03 13:37:06 UTC (rev 796)
@@ -0,0 +1,204 @@
+/*
+ * SCSI pass through sg4v functions
+ *
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <linux/types.h>
+#include <scsi/sg.h>
+#include <linux/bsg.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "scsi.h"
+
+/*
+ *
+ */
+
+static void sgv4_handler(int fd, int events, void *data)
+{
+	int i, err;
+	struct sg_io_v4 hdrs[64];
+	struct tgt_device *dev = data;
+
+	err = read(dev->fd, hdrs, sizeof(hdrs));
+	if (err < 0)
+		return;
+
+	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
+		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
+		if (hdrs[i].din_resid)
+			cmd->len = hdrs[i].din_resid;
+		target_cmd_io_done(cmd, 0);
+	}
+}
+
+int spt_sg_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+{
+	int err, maj, min;
+	char *sd, buf[256];
+	struct stat64 st;
+	struct timeval t;
+	struct sg_io_v4 hdr, *h;
+	int nr_queue_cmd;
+
+	/* we assume something like /dev/sda */
+	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
+
+	*fd = backed_file_open(path, 0, size);
+	if (*fd < 0)
+		return *fd;
+
+	err = fstat64(*fd, &st);
+	if (err < 0) {
+		eprintf("can't get stat %d, %m\n", *fd);
+		goto close_fd;
+	}
+
+	if(!S_ISBLK(st.st_mode)) {
+		eprintf("only scsi devices are supported %s\n", path);
+		err = -EINVAL;
+		goto close_fd;
+	}
+
+	close(*fd);
+
+	sd = strrchr(path, '/');
+	if (!sd) {
+		eprintf("invalid path %s\n", path);
+		return -EINVAL;
+	}
+
+	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
+	*fd = open(buf, O_RDONLY);
+	if (*fd < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		return -errno;
+	}
+
+	err = read(*fd, buf, sizeof(buf));
+	if (err < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	err = sscanf(buf, "%u:%u", &maj, &min);
+	if (err < 0) {
+		eprintf("can't get bsg major/minor number %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
+	close(*fd);
+
+	err = gettimeofday(&t, NULL);
+	if (err) {
+		eprintf("can't get temporary name for bsg device, %m\n");
+		return -errno;
+	}
+
+	memset(buf, 0, sizeof(buf));
+	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
+	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
+		    maj << 8 | min);
+	if (err < 0) {
+		eprintf("can't create the bsg device %s, %m\n", buf);
+		return -errno;
+	}
+
+	*fd = open(buf, O_RDWR | O_NONBLOCK);
+
+	dprintf("%d %s\n", *fd, buf);
+	unlink(buf);
+
+	if (*fd < 0) {
+		eprintf("can't open the bsg device %s, %m\n", buf);
+		return -errno;
+	}
+
+	/* workaround */
+	nr_queue_cmd = 128;
+	err = ioctl(*fd, SG_SET_COMMAND_Q, &nr_queue_cmd);
+	if (err) {
+		eprintf("can't set the queue depth %d, %m\n", nr_queue_cmd);
+		goto close_fd;
+	}
+
+	err = tgt_event_add(*fd, EPOLLIN, sgv4_handler, dev);
+	if (err) {
+		free(dev);
+		goto close_fd;
+	}
+
+	return 0;
+close_fd:
+	close(*fd);
+	return err;
+}
+
+int spt_sg_perform(struct scsi_cmd *cmd)
+{
+	int ret;
+	struct sg_io_v4 hdr;
+
+	/* TODO sense */
+
+	dprintf("%x %d %u %" PRIx64"\n", cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr);
+	memset(&hdr, 0, sizeof(hdr));
+	hdr.guard = 'Q';
+	hdr.request_len = 16;
+	hdr.request = (unsigned long) cmd->scb;
+
+	if (cmd->rw) {
+		hdr.dout_xfer_len = cmd->len;
+		hdr.dout_xferp = cmd->uaddr;
+	} else {
+		hdr.din_xfer_len = cmd->len;
+		hdr.din_xferp = cmd->uaddr;
+	}
+
+	hdr.max_response_len = sizeof(cmd->sense_buffer);
+	hdr.response = (unsigned long) cmd->sense_buffer;
+
+	hdr.usr_ptr = (unsigned long) cmd;
+
+	ret = write(cmd->dev->fd, &hdr, sizeof(hdr));
+	if (ret == sizeof(hdr)) {
+		cmd->async = 1;
+		return 0;
+	} else {
+		eprintf("%d %m\n", ret);
+		return -1;
+	}
+}



From tomo at mail.berlios.de  Sat Mar  3 14:41:56 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 3 Mar 2007 14:41:56 +0100
Subject: [Stgt-svn] r797 - trunk/usr
Message-ID: <200703031341.l23Dfu32007082@sheep.berlios.de>

Author: tomo
Date: 2007-03-03 14:41:55 +0100 (Sat, 03 Mar 2007)
New Revision: 797

Modified:
   trunk/usr/spt_sgv4.c
Log:
Add sense support sgv4


Modified: trunk/usr/spt_sgv4.c
===================================================================
--- trunk/usr/spt_sgv4.c	2007-03-03 13:37:06 UTC (rev 796)
+++ trunk/usr/spt_sgv4.c	2007-03-03 13:41:55 UTC (rev 797)
@@ -43,9 +43,8 @@
 #include "scsi.h"
 
 /*
- *
+ * until sgv4 is merged into mainline, we support sgv3 too.
  */
-
 static void sgv4_handler(int fd, int events, void *data)
 {
 	int i, err;
@@ -58,9 +57,17 @@
 
 	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
 		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
-		if (hdrs[i].din_resid)
-			cmd->len = hdrs[i].din_resid;
-		target_cmd_io_done(cmd, 0);
+
+		dprintf("%p %u %u %u %u\n", cmd,
+			hdrs[i].response_len, hdrs[i].device_status,
+			hdrs[i].transport_status, hdrs[i].transport_status);
+
+		if (hdrs[i].device_status) {
+			cmd->sense_len = hdrs[i].response_len;
+			cmd->len = 0;
+		}
+
+		target_cmd_io_done(cmd, hdrs[i].device_status);
 	}
 }
 
@@ -172,8 +179,6 @@
 	int ret;
 	struct sg_io_v4 hdr;
 
-	/* TODO sense */
-
 	dprintf("%x %d %u %" PRIx64"\n", cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr);
 	memset(&hdr, 0, sizeof(hdr));
 	hdr.guard = 'Q';



From tomo at mail.berlios.de  Sun Mar  4 05:34:39 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 05:34:39 +0100
Subject: [Stgt-svn] r798 - in trunk/usr: . iscsi
Message-ID: <200703040434.l244YdKI024071@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 05:34:38 +0100 (Sun, 04 Mar 2007)
New Revision: 798

Added:
   trunk/usr/spt_sgv3.c
Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/iscsid.c
   trunk/usr/spt.c
   trunk/usr/spt_sgv4.c
   trunk/usr/target.c
Log:
Add sgv3 pass through support. I can see disk drives, but it can't work fully yet.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/Makefile	2007-03-04 04:34:38 UTC (rev 798)
@@ -21,7 +21,8 @@
 endif
 
 ifneq ($(RAW),)
-TGTD_OBJS += spt.o spt_sgv4.o
+#TGTD_OBJS += spt.o spt_sgv4.o
+TGTD_OBJS += spt.o spt_sgv3.o
 CFLAGS += -DUSE_RAW
 endif
 
@@ -42,7 +43,7 @@
 endif
 
 INCLUDES += -I.
-CFLAGS += -Wall -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
+CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
 TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o scsi.o log.o driver.o util.o work.o

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/iscsi/iscsid.c	2007-03-04 04:34:38 UTC (rev 798)
@@ -743,6 +743,8 @@
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 
+	dprintf("%p %x\n", task, task->scmd->scb[0]);
+
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
 	rsp->itt = task->tag;

Modified: trunk/usr/spt.c
===================================================================
--- trunk/usr/spt.c	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/spt.c	2007-03-04 04:34:38 UTC (rev 798)
@@ -33,7 +33,6 @@
 #include <sys/time.h>
 #include <linux/types.h>
 #include <scsi/sg.h>
-#include <linux/bsg.h>
 
 #include "list.h"
 #include "util.h"
@@ -62,9 +61,16 @@
 	.bd_cmd_done		= spt_sg_cmd_done,
 };
 
+extern struct device_command_operations sbc_ops[];
+
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
+
+	/* FIXME */
+	if (!cmd->dev)
+		return sbc_ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+
 	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
@@ -75,8 +81,9 @@
 }
 
 struct device_command_operations spt_ops[] = {
-	[0x40 ... 0x7f] = {spt_cmd_perform,},
+	[0x00 ... 0x9f] = {spt_cmd_perform,},
 
+	/* 0xA0 */
 	{spc_report_luns,},
 	{spt_cmd_perform,},
 	{spt_cmd_perform,},

Added: trunk/usr/spt_sgv3.c
===================================================================
--- trunk/usr/spt_sgv3.c	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/spt_sgv3.c	2007-03-04 04:34:38 UTC (rev 798)
@@ -0,0 +1,131 @@
+/*
+ * SCSI pass through sg3v functions
+ *
+ * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <linux/types.h>
+#include <scsi/sg.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "scsi.h"
+
+/*
+ * until sgv4 is merged into mainline, we support sgv3 too.
+ */
+static void sgv3_handler(int fd, int events, void *data)
+{
+	int i, err;
+	struct sg_io_hdr hdrs[64];
+	struct tgt_device *dev = data;
+
+	err = read(dev->fd, hdrs, sizeof(struct sg_io_hdr));
+	if (err <= 0)
+		return;
+
+	for (i = 0; i < 1; i++) {
+		struct scsi_cmd *cmd = (void *) (unsigned long) hdrs[i].usr_ptr;
+
+		dprintf("%p %u %u %u %u %u\n", cmd,
+			hdrs[i].status, hdrs[i].host_status, hdrs[i].driver_status,
+			cmd->len, hdrs[i].resid);
+
+		if (hdrs[i].status) {
+			cmd->sense_len = hdrs[i].sb_len_wr;
+			cmd->len = 0;
+		} else
+			cmd->len += hdrs[i].resid;
+
+		target_cmd_io_done(cmd, hdrs[i].status);
+	}
+}
+
+int spt_sg_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+{
+	int err;
+	int nr_queue_cmd;
+
+	*size = 0;
+	*fd = open(path, O_RDWR | O_NONBLOCK);
+	if (*fd < 0)
+		return *fd;
+
+	/* workaround */
+	nr_queue_cmd = 128;
+	err = ioctl(*fd, SG_SET_COMMAND_Q, &nr_queue_cmd);
+	if (err) {
+		eprintf("can't set the queue depth %d, %m\n", nr_queue_cmd);
+		goto close_fd;
+	}
+
+	err = tgt_event_add(*fd, EPOLLIN, sgv3_handler, dev);
+	if (err) {
+		free(dev);
+		goto close_fd;
+	}
+
+	return 0;
+close_fd:
+	close(*fd);
+	return err;
+}
+
+int spt_sg_perform(struct scsi_cmd *cmd)
+{
+	int ret;
+	struct sg_io_hdr hdr;
+
+	dprintf("%x %d %u %" PRIx64"\n", cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr);
+	memset(&hdr, 0, sizeof(hdr));
+	hdr.interface_id = 'S';
+	hdr.cmd_len = 16;
+	hdr.cmdp = cmd->scb;
+	hdr.dxfer_direction = cmd->rw ? SG_DXFER_TO_DEV : SG_DXFER_FROM_DEV;
+	hdr.dxfer_len = cmd->len;
+	hdr.dxferp = (void *)(unsigned long)cmd->uaddr;
+	hdr.mx_sb_len = sizeof(cmd->sense_buffer);
+	hdr.sbp = cmd->sense_buffer;
+	hdr.flags = SG_FLAG_DIRECT_IO;
+
+	hdr.usr_ptr = (void *)(unsigned long)cmd;
+
+	ret = write(cmd->dev->fd, &hdr, sizeof(hdr));
+	if (ret == sizeof(hdr)) {
+		cmd->async = 1;
+		return 0;
+	} else {
+		eprintf("%d %m\n", ret);
+		return -1;
+	}
+}

Modified: trunk/usr/spt_sgv4.c
===================================================================
--- trunk/usr/spt_sgv4.c	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/spt_sgv4.c	2007-03-04 04:34:38 UTC (rev 798)
@@ -65,6 +65,9 @@
 		if (hdrs[i].device_status) {
 			cmd->sense_len = hdrs[i].response_len;
 			cmd->len = 0;
+		} else {
+			if (hdrs[i].din_resid)
+				cmd->len = hdrs[i].din_resid;
 		}
 
 		target_cmd_io_done(cmd, hdrs[i].device_status);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-03 13:41:55 UTC (rev 797)
+++ trunk/usr/target.c	2007-03-04 04:34:38 UTC (rev 798)
@@ -421,13 +421,14 @@
 	cmd->tag = tag;
 	cmd->uaddr = uaddr;
 	cmd->len = data_len;
+	cmd->rw = rw;
 	memcpy(cmd->scb, scb, sizeof(cmd->scb));
 	memcpy(cmd->lun, lun, sizeof(cmd->lun));
 
 	cmd_hlist_insert(target, cmd);
 
 	dev_id = scsi_get_devid(target->lid, lun);
-	dprintf("%x %" PRIx64 "\n", scb[0], dev_id);
+	dprintf("%p %x %" PRIx64 "\n", cmd, scb[0], dev_id);
 
 	cmd->dev = device_lookup(target, dev_id);
 
@@ -436,8 +437,8 @@
 	else
 		q = &target->cmd_queue;
 
-	if (!enabled)
-		enabled = cmd_enabled(q, cmd);
+	enabled = cmd_enabled(q, cmd);
+	dprintf("%p %x %" PRIx64 " %d\n", cmd, scb[0], dev_id, enabled);
 
 	if (enabled) {
 		result = scsi_cmd_perform(nexus->host_no, cmd, (void *)cmd);



From tomo at mail.berlios.de  Sun Mar  4 08:39:49 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 08:39:49 +0100
Subject: [Stgt-svn] r799 - trunk/usr
Message-ID: <200703040739.l247dnPs007534@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 08:39:48 +0100 (Sun, 04 Mar 2007)
New Revision: 799

Added:
   trunk/usr/mmc.c
Modified:
   trunk/usr/Makefile
   trunk/usr/driver.h
   trunk/usr/sbc.c
   trunk/usr/scsi.c
   trunk/usr/spc.c
   trunk/usr/spc.h
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.h
Log:
add mmc code.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/Makefile	2007-03-04 07:39:48 UTC (rev 799)
@@ -21,9 +21,9 @@
 endif
 
 ifneq ($(RAW),)
-#TGTD_OBJS += spt.o spt_sgv4.o
-TGTD_OBJS += spt.o spt_sgv3.o
-CFLAGS += -DUSE_RAW
+TGTD_OBJS += spt_sgv4.o
+else
+TGTD_OBJS += spt_sgv3.o
 endif
 
 ifneq ($(IBMVIO),)
@@ -46,7 +46,8 @@
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o scsi.o log.o driver.o util.o work.o
+TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o spt.o scsi.o log.o \
+	driver.o util.o work.o
 
 all: $(PROGRAMS)
 

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/driver.h	2007-03-04 07:39:48 UTC (rev 799)
@@ -1,4 +1,4 @@
-extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt, xen_bdt;
+extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt, xen_bdt, sg_bdt;
 
 struct tgt_driver {
 	const char *name;

Added: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/mmc.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -0,0 +1,312 @@
+/*
+ * SCSI multimedia command processing
+ *
+ * (C) 2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * based on Ardis's iSCSI implementation.
+ *
+ * (C) 2005-2007 Ming Zhang <blackmagic02881 at gmail.com>
+ * This code is licenced under the GPL.
+ */
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "scsi.h"
+#include "spc.h"
+
+#define MMC_BLK_SHIFT 11
+
+#define PRODUCT_ID	"Virtual CD/DVD ROM"
+#define PRODUCT_REV	"0"
+
+static int mmc_inquiry(int host_no, struct scsi_cmd *cmd)
+{
+	int len, ret = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (!(scb[1] & 0x3)) {
+		data[0] = TYPE_ROM;
+		data[1] = 0x80;
+		data[2] = 0x03;
+		data[3] = 0x02;
+		data[4] = 0x1f;
+		data[7] = 0x02;
+		memcpy(data + 8, VENDOR_ID,
+		       min_t(size_t, strlen(VENDOR_ID), 8));
+		memcpy(data + 16, PRODUCT_ID,
+			min_t(size_t, strlen(PRODUCT_ID), 16));
+		memcpy(data + 32, PRODUCT_REV,
+			min_t(size_t, strlen(PRODUCT_REV), 4));
+		len = data[4] + 5;
+		ret = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x2) {
+		/* CmdDt bit is set */
+		/* We do not support it now. */
+	} else if (scb[1] & 0x1) {
+		if (scb[2] == 0x0) {
+			data[0] = TYPE_ROM;
+			data[1] = 0x0;
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			len = 7;
+			ret = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			int tmp = SCSI_SN_LEN;
+
+			data[1] = 0x80;
+			data[3] = SCSI_SN_LEN;
+			memset(data + 4, 0x20, 4);
+			len = SCSI_SN_LEN + 4;
+			ret = SAM_STAT_GOOD;
+
+			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+				uint8_t *p;
+				char *q;
+
+				p = data + 4 + tmp - 1;
+				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
+
+				for (; tmp > 0; tmp--, q)
+					*(p--) = *q;
+			}
+		} else if (scb[2] == 0x83) {
+			int tmp = SCSI_ID_LEN;
+
+			data[1] = 0x83;
+			data[3] = tmp + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = tmp;
+			if (cmd->dev)
+				strncpy((char *) data + 8, cmd->dev->scsi_id,
+				        SCSI_ID_LEN);
+			len = tmp + 8;
+			ret = SAM_STAT_GOOD;
+		}
+	}
+
+	if (ret != SAM_STAT_GOOD)
+		goto sense;
+
+	cmd->len = min_t(int, len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
+
+	if (!cmd->dev)
+		data[0] = TYPE_NO_LUN;
+
+	return SAM_STAT_GOOD;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int mmc_rw(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+	unsigned long uaddr;
+	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
+
+	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
+	uaddr = cmd->uaddr;
+	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
+		     cmd->offset, &cmd->async, (void *)cmd);
+	if (ret) {
+		cmd->offset = 0;
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	} else {
+		cmd->mmapped = 1;
+		cmd->uaddr = uaddr;
+		return SAM_STAT_GOOD;
+	}
+	return 0;
+}
+
+static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *data;
+
+	data = valloc(pagesize);
+	if (!data) {
+		cmd->len = 0;
+		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	memset(data, pagesize, 0);
+	cmd->uaddr = (unsigned long) data;
+
+	/* forged for single session data cd only. all iso file fall into this */
+	if (cmd->scb[1] & 0x2) {
+		data[1] = 0x12;
+		data[2] = 0x01;
+		data[3] = 0x01;
+		data[5] = 0x14;
+		data[6] = 0x01;
+		data[13] = 0x14;
+		data[14] = 0xaa;
+	} else {
+		data[1] = 0x0a;
+		data[2] = 0x01;
+		data[3] = 0x01;
+		data[5] = 0x14;
+		data[6] = 0x01;
+	}
+
+	cmd->len = data[1] + 2;
+
+	return SAM_STAT_GOOD;
+}
+
+static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
+{
+	uint64_t size;
+	uint8_t *data;
+
+	data = valloc(pagesize);
+	if (!data) {
+		cmd->len = 0;
+		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	memset(data, pagesize, 0);
+	cmd->uaddr = (unsigned long) data;
+
+	size = cmd->dev->size >> MMC_BLK_SHIFT;
+
+	data[0] = (size >> 32) ?
+		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
+	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
+	cmd->len = 8;
+
+	return SAM_STAT_GOOD;
+}
+
+struct device_command_operations mmc_ops[] = {
+	{spc_test_unit,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_request_sense,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	/* 0x10 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{mmc_inquiry,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_start_stop,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_start_stop,}, /* allow medium removal */
+	{spc_illegal_op,},
+
+	/* 0x20 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{mmc_read_capacity,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{mmc_rw},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_test_unit},
+
+	[0x30 ... 0x3f] = {spc_illegal_op,},
+
+	/* 0x40 */
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{mmc_read_toc,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	[0x50 ... 0x9f] = {spc_illegal_op,},
+
+	/* 0xA0 */
+	{spc_report_luns,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+	{spc_illegal_op,},
+
+	[0xb0 ... 0xff] = {spc_illegal_op},
+};

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/sbc.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -9,7 +9,6 @@
  *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
  *   licensed under the terms of the GNU GPL v2.0,
  */
-
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -28,57 +27,6 @@
 
 #define BLK_SHIFT	9
 
-static int sbc_test_unit(int host_no, struct scsi_cmd *cmd)
-{
-	int ret = SAM_STAT_GOOD;
-
-	/* how should we test a backing-storage file? */
-
-	if (cmd->dev) {
-		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
-		if (ret)
-			ret = SAM_STAT_RESERVATION_CONFLICT;
-	} else {
-		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
-		ret = SAM_STAT_CHECK_CONDITION;
-	}
-	return ret;
-}
-
-static int sbc_request_sense(int host_no, struct scsi_cmd *cmd)
-{
-	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
-	return SAM_STAT_GOOD;
-}
-
-static uint64_t sbc_rw_offset(uint8_t *scb)
-{
-	uint64_t off;
-
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		off = 0;
-		break;
-	}
-
-	return off << BLK_SHIFT;
-}
-
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
@@ -106,7 +54,7 @@
 		break;
 	}
 
-	cmd->offset = sbc_rw_offset(cmd->scb);
+	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
 	uaddr = cmd->uaddr;
 	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
 		     cmd->offset, &cmd->async, (void *)cmd);
@@ -126,7 +74,6 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-#define VENDOR_ID	"IET"
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
@@ -504,10 +451,10 @@
 }
 
 struct device_command_operations sbc_ops[] = {
-	{sbc_test_unit,},
+	{spc_test_unit,},
 	{spc_illegal_op,},
 	{spc_illegal_op,},
-	{sbc_request_sense,},
+	{spc_request_sense,},
 	{spc_illegal_op,},
 	{spc_illegal_op,},
 	{spc_illegal_op,},
@@ -558,7 +505,7 @@
 	{spc_illegal_op,},
 	{spc_illegal_op,},
 	{sbc_rw},
-	{sbc_test_unit},
+	{spc_test_unit},
 
 	/* 0x30 */
 	{spc_illegal_op,},
@@ -598,7 +545,7 @@
 	{spc_illegal_op,},
 	{spc_illegal_op,},
 	{sbc_rw},
-	{sbc_test_unit},
+	{spc_test_unit},
 
 	/* 0x90 */
 	{spc_illegal_op,},
@@ -636,7 +583,7 @@
 	{spc_illegal_op,},
 	{spc_illegal_op,},
 	{sbc_rw,},
-	{sbc_test_unit,},
+	{spc_test_unit,},
 
 	[0xb0 ... 0xff] = {spc_illegal_op},
 };

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/scsi.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -80,6 +80,32 @@
 	return fn(p);
 }
 
+uint64_t scsi_rw_offset(uint8_t *scb)
+{
+	uint64_t off;
+
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
+		break;
+	default:
+		off = 0;
+		break;
+	}
+
+	return off;
+}
+
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	unsigned char op = cmd->scb[0];

Modified: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/spc.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -117,9 +117,34 @@
 	return SAM_STAT_GOOD;
 }
 
+int spc_test_unit(int host_no, struct scsi_cmd *cmd)
+{
+	int ret = SAM_STAT_GOOD;
+
+	/* how should we test a backing-storage file? */
+
+	if (cmd->dev) {
+		ret = device_reserved(cmd->cmd_nexus_id, cmd->dev->lun, host_no);
+		if (ret)
+			ret = SAM_STAT_RESERVATION_CONFLICT;
+	} else {
+		cmd->len = 0;
+		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+	return ret;
+}
+
+int spc_request_sense(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+	sense_data_build(cmd, NO_SENSE, 0, 0);
+	return SAM_STAT_GOOD;
+}
+
 int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST,0x24, 0);
+	sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }

Modified: trunk/usr/spc.h
===================================================================
--- trunk/usr/spc.h	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/spc.h	2007-03-04 07:39:48 UTC (rev 799)
@@ -3,7 +3,8 @@
 
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
+extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
+extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 
 #endif
-

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/target.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -36,7 +36,7 @@
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_command_operations sbc_ops[], spt_ops[];
+extern struct device_command_operations sbc_ops[], mmc_ops[], spt_ops[];
 
 static LIST_HEAD(target_list);
 
@@ -1207,6 +1207,9 @@
 	case TARGET_SBC:
 		target->dev_cmd_ops = sbc_ops;
 		break;
+	case TARGET_MMC:
+		target->dev_cmd_ops = mmc_ops;
+		break;
 	case TARGET_SPT:
 		target->dev_cmd_ops = spt_ops;
 		break;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/tgtadm.c	2007-03-04 07:39:48 UTC (rev 799)
@@ -310,8 +310,7 @@
 		eprintf("type emulation isn't supported yet\n");
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd")) {
-		eprintf("cdrom emulation isn't supported yet\n");
-		exit(EINVAL);
+		return TARGET_MMC;
 	} else if (!strcmp(str, "osd")) {
 		eprintf("osd isn't supported yet\n");
 		exit(EINVAL);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-04 04:34:38 UTC (rev 798)
+++ trunk/usr/tgtd.h	2007-03-04 07:39:48 UTC (rev 799)
@@ -6,6 +6,8 @@
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
 
+#define VENDOR_ID	"IET"
+
 #define TID_SHIFT 32
 #define NID_MASK ((1ULL << TID_SHIFT) - 1)
 #define NID64(tid, nid) ((uint64_t) tid << TID_SHIFT | nid)
@@ -98,10 +100,6 @@
 }
 #endif
 
-#ifndef USE_RAW
-struct backedio_template sg_bdt;
-#endif
-
 struct device_command_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
 };
@@ -144,6 +142,7 @@
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key);
 extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
 			     uint8_t asq);
+extern uint64_t scsi_rw_offset(uint8_t *scb);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);



From tomo at mail.berlios.de  Sun Mar  4 10:23:06 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:23:06 +0100
Subject: [Stgt-svn] r800 - trunk/usr
Message-ID: <200703040923.l249N6VO011100@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:23:06 +0100 (Sun, 04 Mar 2007)
New Revision: 800

Modified:
   trunk/usr/tgtd.c
Log:
Disable realtime priority because it leads to lots of dirty pages. We
don't have asynchronous fsync. So it's not nice.


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2007-03-04 07:39:48 UTC (rev 799)
+++ trunk/usr/tgtd.c	2007-03-04 09:23:06 UTC (rev 800)
@@ -83,14 +83,6 @@
 static void signal_catch(int signo) {
 }
 
-static int set_realtime(void)
-{
-	struct sched_param sp;
-
-	sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
-	return sched_setscheduler(0, SCHED_FIFO, &sp);
-}
-
 static int oom_adjust(void)
 {
 	int fd, err;
@@ -286,10 +278,6 @@
 	if (err)
 		exit(1);
 
-	err = set_realtime();
-	if (err)
-		eprintf("can't set SCHED_FIFO, %m\n");
-
 	err = log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug);
 	if (err)
 		exit(1);



From tomo at mail.berlios.de  Sun Mar  4 10:25:53 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:25:53 +0100
Subject: [Stgt-svn] r801 - trunk/usr
Message-ID: <200703040925.l249PrjX011259@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:25:53 +0100 (Sun, 04 Mar 2007)
New Revision: 801

Modified:
   trunk/usr/Makefile
Log:
Rename RAW to SGV4


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-04 09:23:06 UTC (rev 800)
+++ trunk/usr/Makefile	2007-03-04 09:25:53 UTC (rev 801)
@@ -20,7 +20,7 @@
 LIBS += -laio
 endif
 
-ifneq ($(RAW),)
+ifneq ($(SGV4),)
 TGTD_OBJS += spt_sgv4.o
 else
 TGTD_OBJS += spt_sgv3.o



From tomo at mail.berlios.de  Sun Mar  4 10:26:39 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:26:39 +0100
Subject: [Stgt-svn] r802 - trunk/usr
Message-ID: <200703040926.l249QdfI011319@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:26:39 +0100 (Sun, 04 Mar 2007)
New Revision: 802

Modified:
   trunk/usr/Makefile
Log:
Fix Makefile typo


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-04 09:25:53 UTC (rev 801)
+++ trunk/usr/Makefile	2007-03-04 09:26:39 UTC (rev 802)
@@ -59,7 +59,7 @@
 
 ifneq ($(XEN),)
 install: $(PROGRAMS)
-	install -m0755 $(PROGRAMS) $(DESTDIR)/usr/sbin
+	install -m 0755 $(PROGRAMS) $(DESTDIR)/usr/sbin
 endif
 
 clean:



From tomo at mail.berlios.de  Sun Mar  4 10:35:46 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:35:46 +0100
Subject: [Stgt-svn] r803 - trunk/usr
Message-ID: <200703040935.l249ZkRk011814@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:35:45 +0100 (Sun, 04 Mar 2007)
New Revision: 803

Modified:
   trunk/usr/scsi.h
   trunk/usr/target.h
Log:
Remove unused defines


Modified: trunk/usr/scsi.h
===================================================================
--- trunk/usr/scsi.h	2007-03-04 09:26:39 UTC (rev 802)
+++ trunk/usr/scsi.h	2007-03-04 09:35:45 UTC (rev 803)
@@ -133,11 +133,6 @@
 #define	MSG_HEAD_TAG	0x21
 #define	MSG_ORDERED_TAG	0x22
 
-#define	MAX_NR_TARGET		1024
-#define	MAX_NR_HOST		1024
-#define	DEFAULT_NR_DEVICE	64
-#define	MAX_NR_DEVICE		(1 << 20)
-
 #define ABORT_TASK          0x0d
 #define ABORT_TASK_SET      0x06
 #define CLEAR_ACA           0x16

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-04 09:26:39 UTC (rev 802)
+++ trunk/usr/target.h	2007-03-04 09:35:45 UTC (rev 803)
@@ -10,8 +10,6 @@
 #define	MSG_HEAD_TAG	0x21
 #define	MSG_ORDERED_TAG	0x22
 
-#define	MAX_NR_HOST		1024
-
 #define	HASH_ORDER	4
 #define	hashfn(val)	hash_long((unsigned long) (val), HASH_ORDER)
 



From tomo at mail.berlios.de  Sun Mar  4 10:38:58 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:38:58 +0100
Subject: [Stgt-svn] r804 - trunk/usr
Message-ID: <200703040938.l249cwhc012009@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:38:58 +0100 (Sun, 04 Mar 2007)
New Revision: 804

Modified:
   trunk/usr/target.h
Log:
Remove unused defines again.


Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-04 09:35:45 UTC (rev 803)
+++ trunk/usr/target.h	2007-03-04 09:38:58 UTC (rev 804)
@@ -5,11 +5,6 @@
 #define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
 #include <linux/hash.h>
 
-/* better if we can include the followings in kernel header files. */
-#define	MSG_SIMPLE_TAG	0x20
-#define	MSG_HEAD_TAG	0x21
-#define	MSG_ORDERED_TAG	0x22
-
 #define	HASH_ORDER	4
 #define	hashfn(val)	hash_long((unsigned long) (val), HASH_ORDER)
 



From tomo at mail.berlios.de  Sun Mar  4 10:51:55 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 10:51:55 +0100
Subject: [Stgt-svn] r805 - trunk/usr
Message-ID: <200703040951.l249ptVo012945@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 10:51:55 +0100 (Sun, 04 Mar 2007)
New Revision: 805

Modified:
   trunk/usr/scsi.h
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Remove tgtadm_target_type


Modified: trunk/usr/scsi.h
===================================================================
--- trunk/usr/scsi.h	2007-03-04 09:38:58 UTC (rev 804)
+++ trunk/usr/scsi.h	2007-03-04 09:51:55 UTC (rev 805)
@@ -127,8 +127,11 @@
 #define TYPE_RAID           0x0c
 #define TYPE_ENCLOSURE      0x0d
 #define TYPE_RBC	    0x0e
+#define TYPE_OSD	    0x11
 #define TYPE_NO_LUN         0x7f
 
+#define TYPE_SPT	    0xff
+
 #define	MSG_SIMPLE_TAG	0x20
 #define	MSG_HEAD_TAG	0x21
 #define	MSG_ORDERED_TAG	0x22

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 09:38:58 UTC (rev 804)
+++ trunk/usr/target.c	2007-03-04 09:51:55 UTC (rev 805)
@@ -1204,13 +1204,13 @@
 		return TGTADM_NOMEM;
 
 	switch (t_type) {
-	case TARGET_SBC:
+	case TYPE_DISK:
 		target->dev_cmd_ops = sbc_ops;
 		break;
-	case TARGET_MMC:
+	case TYPE_ROM:
 		target->dev_cmd_ops = mmc_ops;
 		break;
-	case TARGET_SPT:
+	case TYPE_SPT:
 		target->dev_cmd_ops = spt_ops;
 		break;
 	default:
@@ -1239,7 +1239,7 @@
 	INIT_LIST_HEAD(&target->device_list);
 
 	/* FIXME */
-	if (t_type == TARGET_SPT) {
+	if (t_type == TYPE_SPT) {
 		target->target_iotype = SCSI_TARGET_RAWIO;
 		target->bdt = &sg_bdt;
 	} else {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-04 09:38:58 UTC (rev 804)
+++ trunk/usr/tgtadm.c	2007-03-04 09:51:55 UTC (rev 805)
@@ -36,6 +36,7 @@
 #include <sys/types.h>
 #include <sys/un.h>
 
+#include "scsi.h"
 #include "util.h"
 #include "list.h"
 #include "tgtadm.h"
@@ -305,18 +306,18 @@
 static int target_type(char *str)
 {
 	if (!strcmp(str, "disk"))
-		return TARGET_SBC;
+		return TYPE_DISK;
 	else if (!strcmp(str, "tape")) {
 		eprintf("type emulation isn't supported yet\n");
 		exit(EINVAL);
-	} else if (!strcmp(str, "cd")) {
-		return TARGET_MMC;
-	} else if (!strcmp(str, "osd")) {
+	} else if (!strcmp(str, "cd"))
+		return TYPE_ROM;
+	else if (!strcmp(str, "osd")) {
 		eprintf("osd isn't supported yet\n");
 		exit(EINVAL);
-	} else if (!strcmp(str, "pt")) {
-		return TARGET_SPT;
-	} else {
+	} else if (!strcmp(str, "pt"))
+		return TYPE_SPT;
+	else {
 		eprintf("unknown target type: %s\n", str);
 		exit(EINVAL);
 	}
@@ -373,7 +374,7 @@
 
 	op = tid = mode = -1;
 	total = cid = hostno = sid = lun = 0;
-	t_type = TARGET_SBC;
+	t_type = TYPE_DISK;
 	bs_type = LU_BS_FILE;
 	ac_dir = ACCOUNT_TYPE_INCOMING;
 	rest = BUFSIZE;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2007-03-04 09:38:58 UTC (rev 804)
+++ trunk/usr/tgtadm.h	2007-03-04 09:51:55 UTC (rev 805)
@@ -49,14 +49,6 @@
 	MODE_ACCOUNT,
 };
 
-enum tgtadm_target_type {
-	TARGET_SBC, /* disk */
-	TARGET_SSC, /* tape */
-	TARGET_MMC, /* cdrom */
-	TARGET_OSD, /* object storage device */
-	TARGET_SPT, /* pass through */
-};
-
 /* backing store type */
 enum tgtadm_lu_bs_type {
 	LU_BS_FILE,



From tomo at mail.berlios.de  Sun Mar  4 11:19:47 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 11:19:47 +0100
Subject: [Stgt-svn] r806 - trunk/usr
Message-ID: <200703041019.l24AJl9q014761@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 11:19:46 +0100 (Sun, 04 Mar 2007)
New Revision: 806

Modified:
   trunk/usr/mmc.c
   trunk/usr/sbc.c
   trunk/usr/scsi.c
   trunk/usr/spt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
print target type via show option.


Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/mmc.c	2007-03-04 10:19:46 UTC (rev 806)
@@ -209,104 +209,107 @@
 	return SAM_STAT_GOOD;
 }
 
-struct device_command_operations mmc_ops[] = {
-	{spc_test_unit,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_request_sense,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+struct device_type_template mmc_template = {
+	.name	= "cdrom/dvd",
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	/* 0x10 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{mmc_inquiry,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_start_stop,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_start_stop,}, /* allow medium removal */
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_start_stop,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_start_stop,}, /* allow medium removal */
+		{spc_illegal_op,},
 
-	/* 0x20 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{mmc_read_capacity,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x20 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_read_capacity,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{mmc_rw},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_test_unit},
+		{mmc_rw},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit},
 
-	[0x30 ... 0x3f] = {spc_illegal_op,},
+		[0x30 ... 0x3f] = {spc_illegal_op,},
 
-	/* 0x40 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{mmc_read_toc,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x40 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_read_toc,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	[0x50 ... 0x9f] = {spc_illegal_op,},
+		[0x50 ... 0x9f] = {spc_illegal_op,},
 
-	/* 0xA0 */
-	{spc_report_luns,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	[0xb0 ... 0xff] = {spc_illegal_op},
+		[0xb0 ... 0xff] = {spc_illegal_op},
+	}
 };

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/sbc.c	2007-03-04 10:19:46 UTC (rev 806)
@@ -450,140 +450,143 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-struct device_command_operations sbc_ops[] = {
-	{spc_test_unit,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_request_sense,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+struct device_type_template sbc_template = {
+	.name	= "disk",
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	/* 0x10 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_inquiry,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_reserve,},
-	{sbc_release,},
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_reserve,},
+		{sbc_release,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_mode_sense,},
-	{spc_start_stop,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_mode_sense,},
+		{spc_start_stop,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	/* 0x20 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_read_capacity,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x20 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_read_capacity,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{sbc_rw},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{spc_test_unit},
+		{sbc_rw},
+		{spc_illegal_op,},
+		{sbc_rw},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_rw},
+		{spc_test_unit},
 
-	/* 0x30 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_sync_cache,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x30 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_sync_cache,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	[0x40 ... 0x7f] = {spc_illegal_op,},
+		[0x40 ... 0x7f] = {spc_illegal_op,},
 
-	/* 0x80 */
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x80 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw},
-	{spc_test_unit},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_rw},
+		{spc_test_unit},
 
-	/* 0x90 */
-	{spc_illegal_op,},
-	{sbc_sync_cache,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0x90 */
+		{spc_illegal_op,},
+		{sbc_sync_cache,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	/* 0xA0 */
-	{spc_report_luns,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{spc_illegal_op,},
-	{sbc_rw,},
-	{spc_test_unit,},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{sbc_rw,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{sbc_rw,},
+		{spc_test_unit,},
 
-	[0xb0 ... 0xff] = {spc_illegal_op},
+		[0xb0 ... 0xff] = {spc_illegal_op},
+	}
 };

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/scsi.c	2007-03-04 10:19:46 UTC (rev 806)
@@ -109,5 +109,5 @@
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_cmd_ops[op].cmd_perform(host_no, cmd);
+	return cmd->c_target->dev_type_template->ops[op].cmd_perform(host_no, cmd);
 }

Modified: trunk/usr/spt.c
===================================================================
--- trunk/usr/spt.c	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/spt.c	2007-03-04 10:19:46 UTC (rev 806)
@@ -61,7 +61,7 @@
 	.bd_cmd_done		= spt_sg_cmd_done,
 };
 
-extern struct device_command_operations sbc_ops[];
+extern struct device_type_template sbc_template;
 
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
@@ -69,7 +69,7 @@
 
 	/* FIXME */
 	if (!cmd->dev)
-		return sbc_ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+		return sbc_template.ops[cmd->scb[0]].cmd_perform(host_no, cmd);
 
 	ret = spt_sg_perform(cmd);
 	if (ret) {
@@ -80,27 +80,30 @@
 		return SAM_STAT_GOOD;
 }
 
-struct device_command_operations spt_ops[] = {
-	[0x00 ... 0x9f] = {spt_cmd_perform,},
+struct device_type_template spt_template = {
+	.name	= "passthrough",
+	.ops	= {
+		[0x00 ... 0x9f] = {spt_cmd_perform,},
 
-	/* 0xA0 */
-	{spc_report_luns,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
 
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
-	{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
+		{spt_cmd_perform,},
 
-	[0xb0 ... 0xff] = {spt_cmd_perform},
+		[0xb0 ... 0xff] = {spt_cmd_perform},
+	}
 };

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/target.c	2007-03-04 10:19:46 UTC (rev 806)
@@ -36,7 +36,7 @@
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_command_operations sbc_ops[], mmc_ops[], spt_ops[];
+extern struct device_type_template sbc_template, mmc_template, spt_template;
 
 static LIST_HEAD(target_list);
 
@@ -1097,11 +1097,13 @@
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
 			 TAB1 "System information:\n"
-			 TAB2 "Driver: %s\n"
-			 TAB2 "Status: %s\n",
+			 TAB2 "driver : %s\n"
+			 TAB2 "type   : %s\n"
+			 TAB2 "status : %s\n",
 			 target->tid,
 			 target->name,
 			 tgt_drivers[target->lid]->name,
+			 target->dev_type_template->name,
 			 target_state_name(target->target_state));
 
 		shprintf(total, buf, rest, TAB1 "I_T nexus information:\n");
@@ -1205,13 +1207,13 @@
 
 	switch (t_type) {
 	case TYPE_DISK:
-		target->dev_cmd_ops = sbc_ops;
+		target->dev_type_template = &sbc_template;
 		break;
 	case TYPE_ROM:
-		target->dev_cmd_ops = mmc_ops;
+		target->dev_type_template = &mmc_template;
 		break;
 	case TYPE_SPT:
-		target->dev_cmd_ops = spt_ops;
+		target->dev_type_template = &spt_template;
 		break;
 	default:
 		free(target);

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/target.h	2007-03-04 10:19:46 UTC (rev 806)
@@ -51,7 +51,7 @@
 
 	struct tgt_account account;
 
-	struct device_command_operations *dev_cmd_ops;
+	struct device_type_template *dev_type_template;
 };
 
 struct it_nexus {

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-04 09:51:55 UTC (rev 805)
+++ trunk/usr/tgtd.h	2007-03-04 10:19:46 UTC (rev 806)
@@ -100,10 +100,15 @@
 }
 #endif
 
-struct device_command_operations {
+struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
 };
 
+struct device_type_template {
+	char *name;
+	struct device_type_operations ops[256];
+};
+
 extern int kspace_send_tsk_mgmt_res(uint64_t nid, uint64_t mid, int result);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 



From tomo at mail.berlios.de  Sun Mar  4 11:32:28 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 11:32:28 +0100
Subject: [Stgt-svn] r807 - trunk/usr
Message-ID: <200703041032.l24AWSXe015456@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 11:32:27 +0100 (Sun, 04 Mar 2007)
New Revision: 807

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Remove backing store type.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2007-03-04 10:19:46 UTC (rev 806)
+++ trunk/usr/mgmt.c	2007-03-04 10:32:27 UTC (rev 807)
@@ -78,7 +78,7 @@
 	switch (req->op) {
 	case OP_NEW:
 		err = tgt_target_create(lld_no, req->tid, mtask->buf,
-					req->target_type, req->bs_type);
+					req->target_type);
 		if (!err && tgt_drivers[lld_no]->target_create)
 			tgt_drivers[lld_no]->target_create(req->tid, mtask->buf);
 		break;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 10:19:46 UTC (rev 806)
+++ trunk/usr/target.c	2007-03-04 10:32:27 UTC (rev 807)
@@ -997,28 +997,6 @@
 	return 0;
 }
 
-static struct {
-	enum scsi_target_iotype value;
-	char *name;
-} target_iotype[] = {
-	{SCSI_TARGET_FILEIO, "file"},
-	{SCSI_TARGET_RAWIO, "raw"},
-};
-
-static char *target_iotype_name(enum scsi_target_state state)
-{
-	int i;
-	char *name = NULL;
-
-	for (i = 0; i < ARRAY_SIZE(target_iotype); i++) {
-		if (target_iotype[i].value == state) {
-			name = target_iotype[i].name;
-			break;
-		}
-	}
-	return name;
-}
-
 enum scsi_target_state tgt_get_target_state(int tid)
 {
 	struct target *target;
@@ -1097,9 +1075,9 @@
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
 			 TAB1 "System information:\n"
-			 TAB2 "driver : %s\n"
-			 TAB2 "type   : %s\n"
-			 TAB2 "status : %s\n",
+			 TAB2 "Type: %s\n"
+			 TAB2 "Driver: %s\n"
+			 TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
 			 tgt_drivers[target->lid]->name,
@@ -1122,14 +1100,12 @@
 				 TAB3 "SCSI ID: %s\n"
 				 TAB3 "SCSI SN: %s\n"
 				 TAB3 "Size: %s\n"
-				 TAB3 "Backing store: %s\n"
-				 TAB3 "Backing store type: %s\n",
+				 TAB3 "Backing store: %s\n",
 				 device->lun,
 				 device->scsi_id,
 				 device->scsi_sn,
 				 print_disksize(device->size),
-				 device->path,
-				 target_iotype_name(target->target_iotype));
+				 device->path);
 
 		if (!strcmp(tgt_drivers[target->lid]->name, "iscsi")) {
 			int i, aid;
@@ -1171,7 +1147,7 @@
 
 #define DEFAULT_NR_ACCOUNT 16
 
-int tgt_target_create(int lld, int tid, char *args, int t_type, int bs_type)
+int tgt_target_create(int lld, int tid, char *args, int t_type)
 {
 	int i;
 	struct target *target, *pos;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-04 10:19:46 UTC (rev 806)
+++ trunk/usr/tgtadm.c	2007-03-04 10:32:27 UTC (rev 807)
@@ -106,7 +106,6 @@
 
 	{"bus", required_argument, NULL, 'B'},
 	{"target-type", required_argument, NULL, 'Y'},
-	{"backing-store-type", required_argument, NULL, 'S'},
 	{"outgoing", no_argument, NULL, 'O'},
 	{NULL, 0, NULL, 0},
 };
@@ -291,18 +290,6 @@
 	return host;
 }
 
-static int backing_store_type(char *str)
-{
-	if (!strcmp(str, "file"))
-		return LU_BS_FILE;
-	else if (!strcmp(str, "raw"))
-		return LU_BS_RAW;
-	else {
-		eprintf("unknown backing store type: %s\n", str);
-		exit(EINVAL);
-	}
-}
-
 static int target_type(char *str)
 {
 	if (!strcmp(str, "disk"))
@@ -364,7 +351,7 @@
 int main(int argc, char **argv)
 {
 	int ch, longindex;
-	int op, total, tid, rest, mode, t_type, bs_type, ac_dir;
+	int op, total, tid, rest, mode, t_type, ac_dir;
 	uint32_t cid, hostno;
 	uint64_t sid, lun;
 	char *name, *value, *path, *targetname, *params, *address;
@@ -375,7 +362,6 @@
 	op = tid = mode = -1;
 	total = cid = hostno = sid = lun = 0;
 	t_type = TYPE_DISK;
-	bs_type = LU_BS_FILE;
 	ac_dir = ACCOUNT_TYPE_INCOMING;
 	rest = BUFSIZE;
 	name = value = path = targetname = address = NULL;
@@ -436,9 +422,6 @@
 		case 'Y':
 			t_type = target_type(optarg);
 			break;
-		case 'S':
-			bs_type = backing_store_type(optarg);
-			break;
 		case 'O':
 			ac_dir = ACCOUNT_TYPE_OUTGOING;
 			break;
@@ -565,7 +548,6 @@
 	req->mode = mode;
 	req->host_no = hostno;
 	req->target_type = t_type;
-	req->bs_type = bs_type;
 	req->ac_dir = ac_dir;
 
 	params = buf + sizeof(*req);

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2007-03-04 10:19:46 UTC (rev 806)
+++ trunk/usr/tgtadm.h	2007-03-04 10:32:27 UTC (rev 807)
@@ -49,12 +49,6 @@
 	MODE_ACCOUNT,
 };
 
-/* backing store type */
-enum tgtadm_lu_bs_type {
-	LU_BS_FILE,
-	LU_BS_RAW, /* pass through */
-};
-
 enum tgtadm_account_dir {
 	ACCOUNT_TYPE_INCOMING,
 	ACCOUNT_TYPE_OUTGOING,
@@ -71,7 +65,6 @@
 	uint32_t cid;
 	uint32_t host_no;
 	uint32_t target_type;
-	uint32_t bs_type;
 	uint32_t ac_dir;
 	uint32_t pack;
 };

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-04 10:19:46 UTC (rev 806)
+++ trunk/usr/tgtd.h	2007-03-04 10:32:27 UTC (rev 807)
@@ -120,7 +120,7 @@
 extern int device_release(uint64_t nid, uint64_t lun, uint64_t reserve_id, int force);
 extern int device_reserved(uint64_t nid, uint64_t lun, uint64_t reserve_id);
 
-extern int tgt_target_create(int lld, int tid, char *args, int t_type, int bs_type);
+extern int tgt_target_create(int lld, int tid, char *args, int t_type);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);
 extern char *tgt_targetname(int tid);



From tomo at mail.berlios.de  Sun Mar  4 11:34:21 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 4 Mar 2007 11:34:21 +0100
Subject: [Stgt-svn] r808 - trunk/usr
Message-ID: <200703041034.l24AYLUx015520@sheep.berlios.de>

Author: tomo
Date: 2007-03-04 11:34:21 +0100 (Sun, 04 Mar 2007)
New Revision: 808

Modified:
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
Remove backing store type again.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 10:32:27 UTC (rev 807)
+++ trunk/usr/target.c	2007-03-04 10:34:21 UTC (rev 808)
@@ -1217,13 +1217,10 @@
 	INIT_LIST_HEAD(&target->device_list);
 
 	/* FIXME */
-	if (t_type == TYPE_SPT) {
-		target->target_iotype = SCSI_TARGET_RAWIO;
+	if (t_type == TYPE_SPT)
 		target->bdt = &sg_bdt;
-	} else {
-		target->target_iotype = SCSI_TARGET_FILEIO;
+	else
 		target->bdt = tgt_drivers[lld]->default_bdt;
-	}
 
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-04 10:32:27 UTC (rev 807)
+++ trunk/usr/target.h	2007-03-04 10:34:21 UTC (rev 808)
@@ -32,7 +32,6 @@
 	int tid;
 	int lid;
 
-	enum scsi_target_iotype target_iotype;
 	enum scsi_target_state target_state;
 
 	struct list_head target_siblings;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-04 10:32:27 UTC (rev 807)
+++ trunk/usr/tgtd.h	2007-03-04 10:34:21 UTC (rev 808)
@@ -18,11 +18,6 @@
 #define TAB3 TAB1 TAB1 TAB1
 #define TAB4 TAB2 TAB2
 
-enum scsi_target_iotype {
-	SCSI_TARGET_FILEIO = 1,
-	SCSI_TARGET_RAWIO,
-};
-
 enum scsi_target_state {
 	SCSI_TARGET_SUSPENDED = 1,
 	SCSI_TARGET_RUNNING,



From tomo at mail.berlios.de  Mon Mar  5 01:41:34 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 5 Mar 2007 01:41:34 +0100
Subject: [Stgt-svn] r809 - trunk/usr
Message-ID: <200703050041.l250fYKm028090@sheep.berlios.de>

Author: tomo
Date: 2007-03-05 01:41:32 +0100 (Mon, 05 Mar 2007)
New Revision: 809

Added:
   trunk/usr/osd.c
   trunk/usr/osd.h
Modified:
   trunk/usr/Makefile
   trunk/usr/mmc.c
   trunk/usr/scsi.h
   trunk/usr/target.c
   trunk/usr/tgtadm.c
Log:
Add command parser for OSD commands.

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/Makefile	2007-03-05 00:41:32 UTC (rev 809)
@@ -46,7 +46,7 @@
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o spt.o scsi.o log.o \
+TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scsi.o log.o \
 	driver.o util.o work.o
 
 all: $(PROGRAMS)

Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/mmc.c	2007-03-05 00:41:32 UTC (rev 809)
@@ -58,7 +58,7 @@
 		memcpy(data + 8, VENDOR_ID,
 		       min_t(size_t, strlen(VENDOR_ID), 8));
 		memcpy(data + 16, PRODUCT_ID,
-			min_t(size_t, strlen(PRODUCT_ID), 16));
+		       min_t(size_t, strlen(PRODUCT_ID), 16));
 		memcpy(data + 32, PRODUCT_REV,
 			min_t(size_t, strlen(PRODUCT_REV), 4));
 		len = data[4] + 5;

Added: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/osd.c	2007-03-05 00:41:32 UTC (rev 809)
@@ -0,0 +1,229 @@
+/*
+ * SCSI object storage device command processing
+ *
+ * Copyright (C) 2006 Pete Wyckoff <pw at osc.edu>
+ *
+ * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "scsi.h"
+#include "spc.h"
+#include "osd.h"
+
+#define PRODUCT_ID	"OSD"
+#define PRODUCT_REV	"0"
+
+static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *data, *scb = cmd->scb;
+	int len, ret = SAM_STAT_CHECK_CONDITION;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+
+	/* EVPD means need a page code */
+	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	data[0] = TYPE_OSD;
+	if (!cmd->dev)
+		data[0] = TYPE_NO_LUN;
+
+	if ((scb[1] & 0x1) == 0) {
+		data[2] = 5;  /* modern version */
+		data[3] = 0x02;  /* modern response format */
+		data[7] = 0x02;  /* support command queueing */
+		memset(data + 8, 0x20, 28);
+		memcpy(data + 8,
+		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
+		memcpy(data + 16,
+		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
+		memcpy(data + 32,
+		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
+		len = 36;
+		if (cmd->dev) {
+			data[58] = 0x03;
+			data[59] = 0x40;  /* osd */
+			data[60] = 0x09;
+			data[61] = 0x60;  /* iscsi */
+			data[62] = 0x03;
+			data[63] = 0x00;  /* spc3 */
+			len = 64;
+		}
+		data[4] = len - 5;  /* additional length */
+		ret = SAM_STAT_GOOD;
+	} else {
+		if (!cmd->dev)
+			goto sense;
+
+		data[1] = scb[2];
+		if (scb[2] == 0x0) {
+			/* supported VPD pages */
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			len = 7;
+			ret = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			/* unit serial number "    " */
+			data[3] = 4;
+			memset(data + 4, 0x20, 4);
+			len = 8;
+			ret = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x83) {
+			/* device identification */
+			data[3] = SCSI_ID_LEN + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = SCSI_ID_LEN;
+			if (cmd->dev)
+				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
+			len = SCSI_ID_LEN + 8;
+			ret = SAM_STAT_GOOD;
+		}
+	}
+
+	if (ret != SAM_STAT_GOOD)
+		goto sense;
+
+	cmd->len = min_t(int, len, scb[4]);
+
+	return SAM_STAT_GOOD;
+sense:
+	sense_data_build(cmd, key, asc, 0);
+	cmd->len = 0;
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
+{
+	int ret = SAM_STAT_GOOD;
+	uint16_t action;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned long uaddr;
+	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
+
+	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
+	if (cmd->scb[7] != 200 - 8) {
+		eprintf("request size %d wrong, should be 200\n",
+			cmd->scb[7] + 8);
+		goto sense;
+	}
+
+	action = (cmd->scb[8] << 8) | cmd->scb[9];
+
+	switch (action) {
+	case OSD_APPEND:
+	case OSD_CREATE:
+	case OSD_CREATE_AND_WRITE:
+	case OSD_CREATE_COLLECTION:
+	case OSD_CREATE_PARTITION:
+	case OSD_FLUSH:
+	case OSD_FLUSH_COLLECTION:
+	case OSD_FLUSH_OSD:
+	case OSD_FLUSH_PARTITION:
+	case OSD_FORMAT_OSD:
+	case OSD_GET_ATTRIBUTES:
+	case OSD_GET_MEMBER_ATTRIBUTES:
+	case OSD_LIST:
+	case OSD_LIST_COLLECTION:
+	case OSD_PERFORM_SCSI_COMMAND:
+	case OSD_PERFORM_TASK_MGMT_FUNC:
+	case OSD_QUERY:
+	case OSD_READ:
+	case OSD_REMOVE:
+	case OSD_REMOVE_COLLECTION:
+	case OSD_REMOVE_MEMBER_OBJECTS:
+	case OSD_REMOVE_PARTITION:
+	case OSD_SET_ATTRIBUTES:
+	case OSD_SET_KEY:
+	case OSD_SET_MASTER_KEY:
+	case OSD_SET_MEMBER_ATTRIBUTES:
+	case OSD_WRITE:
+		ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
+			     cmd->offset, &cmd->async, (void *)cmd);
+		if (ret)
+			goto sense;
+		break;
+	default:
+		eprintf("unknown service action 0x%04x\n", action);
+		goto sense;
+	}
+
+	return SAM_STAT_GOOD;
+sense:
+	sense_data_build(cmd, key, asc, 0);
+	cmd->len = 0;
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+struct device_type_template osd_template = {
+	.name	= "osd",
+	.ops	= {
+		[0x00 ... 0x0f] = {spc_illegal_op},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{osd_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x6f] = {spc_illegal_op},
+
+		/* 0x70 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{osd_varlen_cdb,},
+
+		[0x80 ... 0xff] = {spc_illegal_op},
+	}
+};

Added: trunk/usr/osd.h
===================================================================
--- trunk/usr/osd.h	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/osd.h	2007-03-05 00:41:32 UTC (rev 809)
@@ -0,0 +1,33 @@
+#ifndef __OSD_H
+#define __OSD_H
+
+/* varlen cdb service actions for OSD-2 (before SNIA changes 17 jan 07) */
+#define OSD_APPEND			0x8807
+#define OSD_CREATE			0x8802
+#define OSD_CREATE_AND_WRITE		0x8812
+#define OSD_CREATE_COLLECTION		0x8815
+#define OSD_CREATE_PARTITION		0x880b
+#define OSD_FLUSH			0x8808
+#define OSD_FLUSH_COLLECTION		0x881a
+#define OSD_FLUSH_OSD			0x881c
+#define OSD_FLUSH_PARTITION		0x881b
+#define OSD_FORMAT_OSD			0x8801
+#define OSD_GET_ATTRIBUTES		0x880e
+#define OSD_GET_MEMBER_ATTRIBUTES	0x8822
+#define OSD_LIST			0x8803
+#define OSD_LIST_COLLECTION		0x8817
+#define OSD_PERFORM_SCSI_COMMAND	0x8f7e
+#define OSD_PERFORM_TASK_MGMT_FUNC	0x8f7f
+#define OSD_QUERY			0x8820
+#define OSD_READ			0x8805
+#define OSD_REMOVE			0x880a
+#define OSD_REMOVE_COLLECTION		0x8816
+#define OSD_REMOVE_MEMBER_OBJECTS	0x8821
+#define OSD_REMOVE_PARTITION		0x880c
+#define OSD_SET_ATTRIBUTES		0x880f
+#define OSD_SET_KEY			0x8818
+#define OSD_SET_MASTER_KEY		0x8819
+#define OSD_SET_MEMBER_ATTRIBUTES	0x8823
+#define OSD_WRITE			0x8806
+
+#endif

Modified: trunk/usr/scsi.h
===================================================================
--- trunk/usr/scsi.h	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/scsi.h	2007-03-05 00:41:32 UTC (rev 809)
@@ -69,6 +69,7 @@
 #define MODE_SENSE_10         0x5a
 #define PERSISTENT_RESERVE_IN 0x5e
 #define PERSISTENT_RESERVE_OUT 0x5f
+#define VARLEN_CDB            0x7f
 #define REPORT_LUNS           0xa0
 #define MOVE_MEDIUM           0xa5
 #define EXCHANGE_MEDIUM       0xa6

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/target.c	2007-03-05 00:41:32 UTC (rev 809)
@@ -36,7 +36,8 @@
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_type_template sbc_template, mmc_template, spt_template;
+extern struct device_type_template sbc_template, mmc_template, osd_template,
+	spt_template;
 
 static LIST_HEAD(target_list);
 
@@ -1188,6 +1189,9 @@
 	case TYPE_ROM:
 		target->dev_type_template = &mmc_template;
 		break;
+	case TYPE_OSD:
+		target->dev_type_template = &osd_template;
+		break;
 	case TYPE_SPT:
 		target->dev_type_template = &spt_template;
 		break;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-04 10:34:21 UTC (rev 808)
+++ trunk/usr/tgtadm.c	2007-03-05 00:41:32 UTC (rev 809)
@@ -299,10 +299,9 @@
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
-	else if (!strcmp(str, "osd")) {
-		eprintf("osd isn't supported yet\n");
-		exit(EINVAL);
-	} else if (!strcmp(str, "pt"))
+	else if (!strcmp(str, "osd"))
+		return TYPE_OSD;
+	else if (!strcmp(str, "pt"))
 		return TYPE_SPT;
 	else {
 		eprintf("unknown target type: %s\n", str);



From tomo at mail.berlios.de  Mon Mar  5 01:43:25 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 5 Mar 2007 01:43:25 +0100
Subject: [Stgt-svn] r810 - trunk/usr
Message-ID: <200703050043.l250hPLP028188@sheep.berlios.de>

Author: tomo
Date: 2007-03-05 01:43:25 +0100 (Mon, 05 Mar 2007)
New Revision: 810

Modified:
   trunk/usr/target.c
Log:
Fix show option typo.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-05 00:41:32 UTC (rev 809)
+++ trunk/usr/target.c	2007-03-05 00:43:25 UTC (rev 810)
@@ -1081,8 +1081,8 @@
 			 TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
+			 target->dev_type_template->name,
 			 tgt_drivers[target->lid]->name,
-			 target->dev_type_template->name,
 			 target_state_name(target->target_state));
 
 		shprintf(total, buf, rest, TAB1 "I_T nexus information:\n");



From tomo at mail.berlios.de  Mon Mar  5 08:50:01 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 5 Mar 2007 08:50:01 +0100
Subject: [Stgt-svn] r811 - trunk/usr
Message-ID: <200703050750.l257o12t011438@sheep.berlios.de>

Author: tomo
Date: 2007-03-05 08:50:01 +0100 (Mon, 05 Mar 2007)
New Revision: 811

Modified:
   trunk/usr/Makefile
Log:
Remove unused junk in Makefile


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-05 00:43:25 UTC (rev 810)
+++ trunk/usr/Makefile	2007-03-05 07:50:01 UTC (rev 811)
@@ -30,7 +30,6 @@
 CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
 TGTD_OBJS += bd_mmap.o tgtif.o
-BD_MMAP=1
 endif
 
 ifneq ($(ISCSI),)
@@ -39,7 +38,6 @@
 	chap.o transport.o iscsi_tcp.o)
 TGTD_OBJS += bd_aio.o
 LIBS += -lcrypto -lpthread
-BD_AIO=1
 endif
 
 INCLUDES += -I.



From tomo at mail.berlios.de  Tue Mar  6 23:55:58 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 6 Mar 2007 23:55:58 +0100
Subject: [Stgt-svn] r812 - trunk
Message-ID: <200703062255.l26MtwrI020340@sheep.berlios.de>

Author: tomo
Date: 2007-03-06 23:55:57 +0100 (Tue, 06 Mar 2007)
New Revision: 812

Modified:
   trunk/README
Log:
Update README about kernel requirement for iSCSI.


Modified: trunk/README
===================================================================
--- trunk/README	2007-03-05 07:50:01 UTC (rev 811)
+++ trunk/README	2007-03-06 22:55:57 UTC (rev 812)
@@ -19,10 +19,15 @@
 
 Preparation
 -------------
+
 Get kernel version 2.6.20, rebuild the kernel, and reboot with the new
 kernel. Note you need to enable SCSI_TGT, SCSI_SRP, and SCSI_IBMVSCSIS
-kernel options in order to use the IBM VIO target driver,
+kernel options in order to use the IBM VIO target driver.
 
+Note that if you are interested in only the iSCSI target driver, you
+don't need 2.6.20.  It works with any recent kernel versions (the
+oldest version that I confirmed is 2.6.18).
+
 Now you are ready to build target drivers. If you like to use the
 iSCSI target driver:
 



From tomo at mail.berlios.de  Fri Mar  9 16:10:57 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 9 Mar 2007 16:10:57 +0100
Subject: [Stgt-svn] r813 - trunk/usr
Message-ID: <200703091510.l29FAvQ6020141@sheep.berlios.de>

Author: tomo
Date: 2007-03-09 16:10:57 +0100 (Fri, 09 Mar 2007)
New Revision: 813

Modified:
   trunk/usr/mgmt.c
Log:
From: Robert Jennings <rcj at linux.vnet.ibm.com>

Fix tgtadm segmentation fault on target update operation

In a case where the target driver doesn't have a target_update()
method defined tgtadm will segfault because rsp.err has a negative
value.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2007-03-06 22:55:57 UTC (rev 812)
+++ trunk/usr/mgmt.c	2007-03-09 15:10:57 UTC (rev 813)
@@ -115,7 +115,7 @@
 	case OP_UPDATE:
 	{
 		char *p;
-		err = -EINVAL;
+		err = TGTADM_UNSUPPORTED_OPERATION;
 
 		p = strchr(mtask->buf, '=');
 		if (!p)



From tomo at mail.berlios.de  Fri Mar  9 16:29:09 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 9 Mar 2007 16:29:09 +0100
Subject: [Stgt-svn] r814 - in trunk/usr: . xen
Message-ID: <200703091529.l29FT9Ll021014@sheep.berlios.de>

Author: tomo
Date: 2007-03-09 16:29:08 +0100 (Fri, 09 Mar 2007)
New Revision: 814

Modified:
   trunk/usr/spt_sgv4.c
   trunk/usr/tgtif.c
   trunk/usr/util.c
   trunk/usr/xen/xenbus.c
Log:
Use makedev in sys/sysmacros.h (thanks to FUKAYAMA Atsushi).


Modified: trunk/usr/spt_sgv4.c
===================================================================
--- trunk/usr/spt_sgv4.c	2007-03-09 15:10:57 UTC (rev 813)
+++ trunk/usr/spt_sgv4.c	2007-03-09 15:29:08 UTC (rev 814)
@@ -35,6 +35,7 @@
 #include <linux/types.h>
 #include <scsi/sg.h>
 #include <linux/bsg.h>
+#include <sys/sysmacros.h>
 
 #include "list.h"
 #include "util.h"
@@ -141,7 +142,7 @@
 	memset(buf, 0, sizeof(buf));
 	snprintf(buf, sizeof(buf), "/tmp/%lx%lx", t.tv_sec, t.tv_usec);
 	err = mknod(buf, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
-		    maj << 8 | min);
+		    makedev(maj, min));
 	if (err < 0) {
 		eprintf("can't create the bsg device %s, %m\n", buf);
 		return -errno;

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2007-03-09 15:10:57 UTC (rev 813)
+++ trunk/usr/tgtif.c	2007-03-09 15:29:08 UTC (rev 814)
@@ -32,6 +32,7 @@
 #include <sys/epoll.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 
 #define aligned_u64 unsigned long long __attribute__((aligned(8)))
 #include <scsi/scsi_tgt_if.h>
@@ -184,7 +185,7 @@
 		goto out;
 
 	unlink(path);
-	err = mknod(path, (S_IFCHR | 0600), (major << 8) | minor);
+	err = mknod(path, (S_IFCHR | 0600), makedev(major, minor));
 	if (err)
 		goto out;
 

Modified: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2007-03-09 15:10:57 UTC (rev 813)
+++ trunk/usr/util.c	2007-03-09 15:29:08 UTC (rev 814)
@@ -8,6 +8,7 @@
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <linux/fs.h>
+#include <sys/sysmacros.h>
 
 #include "log.h"
 
@@ -44,7 +45,7 @@
 	}
 
 	unlink(devpath);
-	err = mknod(devpath, (S_IFCHR | 0600), (major << 8) | minor);
+	err = mknod(devpath, (S_IFCHR | 0600), makedev(major, minor));
 	if (err) {
 		eprintf("cannot create %s, %m\n", devpath);
 		return -errno;

Modified: trunk/usr/xen/xenbus.c
===================================================================
--- trunk/usr/xen/xenbus.c	2007-03-09 15:10:57 UTC (rev 813)
+++ trunk/usr/xen/xenbus.c	2007-03-09 15:29:08 UTC (rev 814)
@@ -51,6 +51,7 @@
 #include <poll.h>
 #include <time.h>
 #include <sys/time.h>
+#include <sys/sysmacros.h>
 
 /* FIXME */
 #define SRP_RING_PAGES 1
@@ -238,7 +239,7 @@
 	snprintf(devname, sizeof(devname), "/dev/%s%d", name, minor);
 
 	unlink(devname);
-	if (mknod(devname, (S_IFCHR | 0600), (devn << 8) | minor)) {
+	if (mknod(devname, (S_IFCHR | 0600), makedev(devn, minor))) {
 		eprintf("cannot create %s %s\n", devname, strerror(errno));
 		return -1;
 	}



From tomo at mail.berlios.de  Sat Mar 10 08:16:22 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 08:16:22 +0100
Subject: [Stgt-svn] r815 - in trunk/usr: . iscsi
Message-ID: <200703100716.l2A7GMpw006784@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 08:16:20 +0100 (Sat, 10 Mar 2007)
New Revision: 815

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/mmc.c
   trunk/usr/osd.c
   trunk/usr/sbc.c
   trunk/usr/spc.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
- llds allocate scb.
- pass scsi_cmd struct to bd_cmd_submit (btw, should be renamed).
- fix mmc capacity bug.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/bd_aio.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -77,6 +77,7 @@
 
 	ret = io_getevents(info->ctx, 1, MAX_AIO_REQS, info->events, NULL);
 	nr = ret;
+	dprintf("%d", ret);
 	if (nr > 0) {
 	rewrite:
 		ret = write(info->done_fd[1], &nr, sizeof(nr));
@@ -177,35 +178,37 @@
 	close(dev->fd);
 }
 
-static int bd_aio_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
-			     uint32_t datalen, unsigned long *uaddr,
-			     uint64_t offset, int *async, void *key)
+static int bd_aio_cmd_submit(struct scsi_cmd *cmd)
 {
-	struct bd_aio_info *info;
+	struct tgt_device *dev = cmd->dev;
+	struct bd_aio_info *info = (struct bd_aio_info *)((char *)dev + sizeof(*dev));
 	struct iocb iocb, *io;
 	int ret;
 
-	info = (struct bd_aio_info *) ((char *)dev + sizeof(*dev));
-
 	io = &iocb;
 	memset(io, 0, sizeof(*io));
 
-	dprintf("%d %d %u %lx %" PRIx64 " %p %p\n", dev->fd, rw, datalen,
-		*uaddr, offset, io, key);
+	dprintf("%d %d %u %"  PRIx64 " %" PRIx64 " %p\n", dev->fd, cmd->rw, cmd->len,
+		cmd->uaddr, cmd->offset, cmd);
 
-	if (rw == READ)
-		io_prep_pread(io, dev->fd, (void *) *uaddr, datalen, offset);
+	if (cmd->rw == READ)
+		io_prep_pread(io, dev->fd, (void *)(unsigned long)cmd->uaddr,
+			      cmd->len,	cmd->offset);
 	else
-		io_prep_pwrite(io, dev->fd, (void *) *uaddr, datalen, offset);
+		io_prep_pwrite(io, dev->fd, (void *)(unsigned long)cmd->uaddr,
+			       cmd->len, cmd->offset);
 
-	io->data = key;
+	io->data = cmd;
 	ret = io_submit(info->ctx, 1, &io);
 
 	if (ret == 1) {
-		*async = 1;
+		cmd->async = 1;
 		return 0;
-	} else
+	} else {
+		dprintf("%d %d %u %"  PRIx64 " %" PRIx64 " %p\n", dev->fd, cmd->rw, cmd->len,
+			cmd->uaddr, cmd->offset, cmd);
 		return 1;
+	}
 }
 
 static int bd_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/bd_mmap.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -46,29 +46,28 @@
 
 #define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
 
-static int bd_mmap_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
-			      uint32_t datalen, unsigned long *uaddr,
-			      uint64_t offset, int *async, void *key)
+static int bd_mmap_cmd_submit(struct scsi_cmd *cmd)
 {
-	int fd = dev->fd;
+	int fd = cmd->dev->fd;
 	void *p;
 	int err = 0;
 
-	if (*uaddr)
-		*uaddr = *uaddr + offset;
+	if (cmd->uaddr)
+		cmd->uaddr += cmd->offset;
 	else {
-		p = mmap64(NULL, pgcnt(datalen, offset) << pageshift,
+		p = mmap64(NULL, pgcnt(cmd->len, cmd->offset) << pageshift,
 			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   offset & ~((1ULL << pageshift) - 1));
+			   cmd->offset & ~((1ULL << pageshift) - 1));
 
-		*uaddr = (unsigned long) p + (offset & (pagesize - 1));
+		cmd->uaddr = (unsigned long) p + (cmd->offset & (pagesize - 1));
 		if (p == MAP_FAILED) {
 			err = -EINVAL;
-			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+			eprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr,
+				cmd->len, cmd->offset);
 		}
 	}
 
-	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+	dprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr, cmd->len, cmd->offset);
 
 	return err;
 }

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/iscsi/iscsid.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -743,7 +743,7 @@
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 
-	dprintf("%p %x\n", task, task->scmd->scb[0]);
+	dprintf("%p %x\n", task, task->scmd.scb[0]);
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -777,8 +777,8 @@
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = SAM_STAT_CHECK_CONDITION;
 
-	sense = (struct iscsi_sense_data *)task->scmd->sense_buffer;
-	sense_len = task->scmd->sense_len;
+	sense = (struct iscsi_sense_data *)task->scmd.sense_buffer;
+	sense_len = task->scmd.sense_len;
 
 	memmove(sense->data, sense, sense_len);
 	sense->length = cpu_to_be16(sense_len);
@@ -895,11 +895,15 @@
 	conn_put(conn);
 }
 
+static inline struct iscsi_task *ITASK(struct scsi_cmd *scmd)
+{
+	return container_of(scmd, struct iscsi_task, scmd);
+}
+
 static void iscsi_free_cmd_task(struct iscsi_task *task)
 {
-	struct iscsi_connection *conn = task->conn;
+	target_cmd_done(&task->scmd);
 
-	target_cmd_done(conn->session->iscsi_nexus_id, task->tag);
 	list_del(&task->c_hlist);
 	if (task->c_buffer) {
 		if ((unsigned long) task->c_buffer != task->addr)
@@ -908,27 +912,10 @@
 	iscsi_free_task(task);
 }
 
-int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *cmd)
+int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 {
-	struct iscsi_session *session;
-	struct iscsi_task *task;
+	struct iscsi_task *task = ITASK(scmd);
 
-	dprintf("%" PRIu64 " %d %d %d %" PRIx64 " %" PRIx64 "\n", nid,
-		cmd->len, result, cmd->rw, cmd->uaddr, cmd->tag);
-	session = session_lookup(nid);
-	if (!session)
-		return -EINVAL;
-
-	list_for_each_entry(task, &session->cmd_list, c_hlist) {
-		if (task->tag == cmd->tag)
-			goto found;
-	}
-	eprintf("Cannot find a task %" PRIx64 "\n", cmd->tag);
-	return -EINVAL;
-
-found:
-	dprintf("found a task %" PRIx64 "\n", cmd->tag);
-
 	/*
 	 * Since the connection is closed we just free the task.
 	 * We could delay the closing of the conn in some cases and send
@@ -940,11 +927,10 @@
 		return 0;
 	}
 
-	task->addr = cmd->uaddr;
+	task->addr = scmd->uaddr;
 	task->result = result;
-	task->len = cmd->len;
-	task->rw = cmd->rw;
-	task->scmd = cmd;
+	task->len = scmd->len;
+	task->rw = scmd->rw;
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
 	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
@@ -972,11 +958,32 @@
 	return attr;
 }
 
-static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
+static int iscsi_target_cmd_queue(struct iscsi_task *task)
 {
+	struct scsi_cmd *scmd = &task->scmd;
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	unsigned long uaddr = (unsigned long) task->c_buffer;
+
+	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
+	/* tmp hack */
+	scmd->scb = req->cdb;
+	scmd->scb_len = sizeof(req->cdb);
+
+	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
+	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
+	scmd->len = ntohl(req->data_length);
+	scmd->attribute = cmd_attr(task);
+	scmd->tag = req->itt;
+	scmd->uaddr = uaddr;
+
+	return target_cmd_queue(scmd);
+}
+
+static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
+{
+	struct iscsi_connection *conn = task->conn;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	int err = 0;
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
@@ -986,18 +993,9 @@
 			else
 				list_add_tail(&task->c_list, &task->conn->tx_clist);
 		} else
-			err = target_cmd_queue(conn->session->iscsi_nexus_id,
-					       req->cdb,
-					       req->flags & ISCSI_FLAG_CMD_WRITE,
-					       uaddr, req->lun,
-					       ntohl(req->data_length),
-					       cmd_attr(task), req->itt);
+			err = iscsi_target_cmd_queue(task);
 	} else
-		err = target_cmd_queue(conn->session->iscsi_nexus_id,
-				       req->cdb,
-				       req->flags & ISCSI_FLAG_CMD_WRITE,
-				       uaddr, req->lun, ntohl(req->data_length),
-				       cmd_attr(task), req->itt);
+		err = iscsi_target_cmd_queue(task);
 
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
 

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/iscsi/iscsid.h	2007-03-10 07:16:20 UTC (rev 815)
@@ -15,6 +15,7 @@
 #include "list.h"
 #include "param.h"
 #include "log.h"
+#include "tgtd.h"
 
 #include <scsi/iscsi_if.h>
 #include <scsi/iscsi_proto.h>
@@ -113,11 +114,7 @@
 
 	void *c_buffer;
 
-	/*
-	 * temp hack.
-	 * TODO: move most of iscsi_task to scsi_cmd
-	 */
-	struct scsi_cmd *scmd;
+	struct scsi_cmd scmd;
 };
 
 struct iscsi_connection {

Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/mmc.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -130,13 +130,9 @@
 static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned long uaddr;
-	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	uaddr = cmd->uaddr;
-	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-		     cmd->offset, &cmd->async, (void *)cmd);
+	ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
@@ -144,7 +140,6 @@
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
 		cmd->mmapped = 1;
-		cmd->uaddr = uaddr;
 		return SAM_STAT_GOOD;
 	}
 	return 0;
@@ -188,7 +183,7 @@
 static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 {
 	uint64_t size;
-	uint8_t *data;
+	uint32_t *data;
 
 	data = valloc(pagesize);
 	if (!data) {

Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/osd.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -122,8 +122,6 @@
 	int ret = SAM_STAT_GOOD;
 	uint16_t action;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-	unsigned long uaddr;
-	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
 
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
@@ -162,8 +160,7 @@
 	case OSD_SET_MASTER_KEY:
 	case OSD_SET_MEMBER_ATTRIBUTES:
 	case OSD_WRITE:
-		ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-			     cmd->offset, &cmd->async, (void *)cmd);
+		ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
 		if (ret)
 			goto sense;
 		break;

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/sbc.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -30,8 +30,6 @@
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned long uaddr;
-	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
 	if (cmd->dev) {
@@ -55,15 +53,12 @@
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	uaddr = cmd->uaddr;
-	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-		     cmd->offset, &cmd->async, (void *)cmd);
+	ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;
 	} else {
 		cmd->mmapped = 1;
-		cmd->uaddr = uaddr;
 		return SAM_STAT_GOOD;
 	}
 sense:

Modified: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/spc.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -38,7 +38,6 @@
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	int *len = &cmd->len;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
@@ -81,10 +80,10 @@
 
 	cmd->uaddr = (unsigned long)data;
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
+	cmd->len = min(oalen, nr_luns * 8 + 8);
 	return SAM_STAT_GOOD;
 sense:
-	*len = 0;
+	cmd->len = 0;
 	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/target.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -391,18 +391,15 @@
 	}
 }
 
-int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
-		     unsigned long uaddr,
-		     uint8_t *lun, uint32_t data_len,
-		     int attribute, uint64_t tag)
+int target_cmd_queue(struct scsi_cmd *cmd)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
 	struct it_nexus *nexus;
-	struct scsi_cmd *cmd;
 	int result, enabled = 0;
-	uint64_t dev_id;
+	uint64_t dev_id, nid;
 
+	nid = cmd->cmd_nexus_id;
 	nexus = it_nexus_lookup(nid);
 	if (!nexus) {
 		eprintf("invalid nid %u %u\n", (int)NID2TID(nid),
@@ -410,26 +407,12 @@
 		return -ENOENT;
 	}
 
-	target = nexus->nexus_target;
-	/* TODO: preallocate cmd */
-	cmd = zalloc(sizeof(*cmd));
-	if (!cmd)
-		return -ENOMEM;
+	cmd->c_target = target = nexus->nexus_target;
 
-	cmd->cmd_nexus_id = nid;
-	cmd->c_target = target;
-	cmd->attribute = attribute;
-	cmd->tag = tag;
-	cmd->uaddr = uaddr;
-	cmd->len = data_len;
-	cmd->rw = rw;
-	memcpy(cmd->scb, scb, sizeof(cmd->scb));
-	memcpy(cmd->lun, lun, sizeof(cmd->lun));
-
 	cmd_hlist_insert(target, cmd);
 
-	dev_id = scsi_get_devid(target->lid, lun);
-	dprintf("%p %x %" PRIx64 "\n", cmd, scb[0], dev_id);
+	dev_id = scsi_get_devid(target->lid, cmd->lun);
+	dprintf("%p %x %" PRIx64 "\n", cmd, cmd->scb[0], dev_id);
 
 	cmd->dev = device_lookup(target, dev_id);
 
@@ -439,7 +422,7 @@
 		q = &target->cmd_queue;
 
 	enabled = cmd_enabled(q, cmd);
-	dprintf("%p %x %" PRIx64 " %d\n", cmd, scb[0], dev_id, enabled);
+	dprintf("%p %x %" PRIx64 " %d\n", cmd, cmd->scb[0], dev_id, enabled);
 
 	if (enabled) {
 		result = scsi_cmd_perform(nexus->host_no, cmd, (void *)cmd);
@@ -447,7 +430,8 @@
 		cmd_post_perform(q, cmd);
 
 		dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
-			tag, scb[0], cmd->uaddr, cmd->offset, cmd->len, result, cmd->async);
+			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
+			result, cmd->async);
 
 		set_cmd_processed(cmd);
 		if (!cmd->async)
@@ -455,7 +439,7 @@
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
-			tag, scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
+			cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
 			q->active_cmd);
 
 		list_add_tail(&cmd->qlist, &q->queue);
@@ -464,11 +448,8 @@
 	return 0;
 }
 
-void target_cmd_io_done(void *key, int result)
+void target_cmd_io_done(struct scsi_cmd *cmd, int result)
 {
-	struct scsi_cmd *cmd = (struct scsi_cmd *) key;
-
-	/* TODO: sense in case of error. */
 	tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->cmd_nexus_id,
 							result, cmd);
 	return;
@@ -538,30 +519,32 @@
 		break;
 	}
 
-	free(cmd);
-
 	post_cmd_done(q);
 }
 
-void target_cmd_done(uint64_t nid, uint64_t tag)
+struct scsi_cmd *target_cmd_lookup(uint64_t nid, uint64_t tag)
 {
 	struct target *target;
 	struct scsi_cmd *cmd;
-	struct mgmt_req *mreq;
 
 	target = target_lookup(NID2TID(nid));
 	if (!target) {
 		eprintf("invalid nid %u %u\n", (int)NID2TID(nid),
 			(uint32_t)(nid & NID_MASK));
-		return;
+		return NULL;
 	}
 
 	cmd = cmd_lookup(target, tag);
-	if (!cmd) {
+	if (!cmd)
 		eprintf("Cannot find cmd %d %" PRIx64 "\n", (int)NID2TID(nid), tag);
-		return;
-	}
 
+	return cmd;
+}
+
+void target_cmd_done(struct scsi_cmd *cmd)
+{
+	struct mgmt_req *mreq;
+
 	mreq = cmd->mreq;
 	if (mreq && !--mreq->busy) {
 		int err = mreq->function == ABORT_TASK ? -EEXIST : 0;
@@ -570,7 +553,7 @@
 		free(mreq);
 	}
 
-	__cmd_done(target, cmd);
+	__cmd_done(cmd->c_target, cmd);
 }
 
 static int abort_cmd(struct target* target, struct mgmt_req *mreq,

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/tgtd.h	2007-03-10 07:16:20 UTC (rev 815)
@@ -46,18 +46,6 @@
 	uint64_t reserve_id;
 };
 
-typedef int (bkio_submit_t) (struct tgt_device *dev, uint8_t *scb,
-			     int rw, uint32_t datalen, unsigned long *uaddr,
-			     uint64_t offset, int *async, void *key);
-
-struct backedio_template {
-	int bd_datasize;
-	int (*bd_open)(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
-	void (*bd_close)(struct tgt_device *dev);
-	bkio_submit_t *bd_cmd_submit;
-	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
-};
-
 struct scsi_cmd {
 	struct target *c_target;
 	/* linked target->cmd_hash_list */
@@ -73,7 +61,8 @@
 	uint64_t cmd_nexus_id;
 	uint32_t data_len;
 	uint64_t offset;
-	uint8_t scb[16];
+	uint8_t *scb;
+	int scb_len;
 	uint8_t lun[8];
 	int attribute;
 	uint64_t tag;
@@ -86,6 +75,14 @@
 	int sense_len;
 };
 
+struct backedio_template {
+	int bd_datasize;
+	int (*bd_open)(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
+	void (*bd_close)(struct tgt_device *dev);
+	int (*bd_cmd_submit)(struct scsi_cmd *cmd);
+	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+};
+
 #ifdef USE_KERNEL
 extern int kreq_init(void);
 #else
@@ -125,19 +122,14 @@
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
 extern void tgt_event_del(int fd);
 extern int tgt_event_modify(int fd, int events);
-
-extern int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
-			    unsigned long uaddr,
-			    uint8_t *lun, uint32_t data_len,
-			    int attribute, uint64_t tag);
-extern void target_cmd_done(uint64_t nid, uint64_t tag);
+extern int target_cmd_queue(struct scsi_cmd *cmd);
+extern void target_cmd_done(struct scsi_cmd *cmd);
+struct scsi_cmd *target_cmd_lookup(uint64_t nid, uint64_t tag);
 extern void target_mgmt_request(uint64_t nid, uint64_t req_id, int function,
 				uint8_t *lun, uint64_t tag);
 
-extern void target_cmd_io_done(void *key, int result);
+extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
-struct scsi_cmd;
-
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key);
 extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2007-03-09 15:29:08 UTC (rev 814)
+++ trunk/usr/tgtif.c	2007-03-10 07:16:20 UTC (rev 815)
@@ -123,9 +123,39 @@
 	return kreq_send(&ev);
 }
 
+static int kern_queue_cmd(struct tgt_event *ev)
+{
+	struct scsi_cmd *cmd;
+	int scb_len = 16;
+
+	/* TODO: define scsi_kcmd and move mmap stuff */
+
+	cmd = zalloc(sizeof(*cmd) + scb_len);
+	if (!cmd)
+		return ENOMEM;
+
+	cmd->cmd_nexus_id = host_no_to_it_nexus(ev->p.cmd_req.host_no);
+	cmd->scb = (char *)cmd + sizeof(*cmd);
+	memcpy(cmd->scb, ev->p.cmd_req.scb, scb_len);
+	cmd->scb_len = scb_len;
+	memcpy(cmd->lun, ev->p.cmd_req.lun, sizeof(cmd->lun));
+
+	cmd->len = ev->p.cmd_req.data_len;
+	cmd->attribute = ev->p.cmd_req.attribute;
+	cmd->tag = ev->p.cmd_req.tag;
+/* 	cmd->uaddr = ev->k.cmd_req.uaddr; */
+	cmd->uaddr = 0;
+
+	return target_cmd_queue(cmd);
+}
+
 static void kern_event_handler(int fd, int events, void *data)
 {
+	int ret;
+	uint64_t nid;
 	struct tgt_event *ev;
+	/* temp hack */
+	struct scsi_cmd *cmd;
 
 retry:
 	ev = head_ring_hdr(&kuring);
@@ -136,15 +166,18 @@
 
 	switch (ev->hdr.type) {
 	case TGT_KEVENT_CMD_REQ:
-		target_cmd_queue(host_no_to_it_nexus(ev->p.cmd_req.host_no),
-				 ev->p.cmd_req.scb,
-				 0, 0,
-/* 				 ev->k.cmd_req.uaddr, */
-				 ev->p.cmd_req.lun, ev->p.cmd_req.data_len,
-				 ev->p.cmd_req.attribute, ev->p.cmd_req.tag);
+		ret = kern_queue_cmd(ev);
+		if (ret)
+			eprintf("can't queue this command %d\n", ret);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(host_no_to_it_nexus(ev->p.cmd_done.host_no),
+		nid = host_no_to_it_nexus(ev->p.cmd_done.host_no);
+		cmd = target_cmd_lookup(nid, ev->p.cmd_done.tag);
+		if (cmd) {
+			target_cmd_done(cmd);
+			free(cmd);
+		} else
+			eprintf("unknow command %" PRIu64 " %" PRIu64 "\n", nid,
 				ev->p.cmd_done.tag);
 		break;
 	case TGT_KEVENT_TSK_MGMT_REQ:



From tomo at mail.berlios.de  Sat Mar 10 09:58:42 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 09:58:42 +0100
Subject: [Stgt-svn] r816 - in trunk/usr: . iscsi
Message-ID: <200703100858.l2A8wgke011754@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 09:58:41 +0100 (Sat, 10 Mar 2007)
New Revision: 816

Modified:
   trunk/usr/iscsi/session.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
rename TAB* difines because they conflict with ppc defines.


Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2007-03-10 07:16:20 UTC (rev 815)
+++ trunk/usr/iscsi/session.c	2007-03-10 08:58:41 UTC (rev 816)
@@ -103,9 +103,9 @@
 	memset(addr, 0, sizeof(addr));
 	conn->tp->ep_show(conn->fd, addr, sizeof(addr));
 
-	snprintf(session->info, 1024, TAB3 "Initiator: %s\n"
-		 TAB3 "Connection: %u\n"
-		 TAB4 "%s\n", session->initiator, conn->cid, addr);
+	snprintf(session->info, 1024, _TAB3 "Initiator: %s\n"
+		 _TAB3 "Connection: %u\n"
+		 _TAB4 "%s\n", session->initiator, conn->cid, addr);
 
 	err = it_nexus_create(target->tid, session->info, &nexus_id);
 	if (err) {

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-10 07:16:20 UTC (rev 815)
+++ trunk/usr/target.c	2007-03-10 08:58:41 UTC (rev 816)
@@ -1058,33 +1058,33 @@
 	list_for_each_entry(target, &target_list, target_siblings) {
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
-			 TAB1 "System information:\n"
-			 TAB2 "Type: %s\n"
-			 TAB2 "Driver: %s\n"
-			 TAB2 "Status: %s\n",
+			 _TAB1 "System information:\n"
+			 _TAB2 "Type: %s\n"
+			 _TAB2 "Driver: %s\n"
+			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
 			 target->dev_type_template->name,
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
-		shprintf(total, buf, rest, TAB1 "I_T nexus information:\n");
+		shprintf(total, buf, rest, _TAB1 "I_T nexus information:\n");
 
 		list_for_each_entry(nexus, &target->it_nexus_list, nexus_siblings) {
-			shprintf(total, buf, rest, TAB2 "I_T nexus: %u\n",
+			shprintf(total, buf, rest, _TAB2 "I_T nexus: %u\n",
 				 nexus->nexus_id);
 			if (nexus->info)
 				shprintf(total, buf, rest, "%s", nexus->info);
 		}
 
-		shprintf(total, buf, rest, TAB1 "LUN information:\n");
+		shprintf(total, buf, rest, _TAB1 "LUN information:\n");
 		list_for_each_entry(device, &target->device_list, device_siblings)
 			shprintf(total, buf, rest,
-				 TAB2 "LUN: %" PRIu64 "\n"
-				 TAB3 "SCSI ID: %s\n"
-				 TAB3 "SCSI SN: %s\n"
-				 TAB3 "Size: %s\n"
-				 TAB3 "Backing store: %s\n",
+				 _TAB2 "LUN: %" PRIu64 "\n"
+				 _TAB3 "SCSI ID: %s\n"
+				 _TAB3 "SCSI SN: %s\n"
+				 _TAB3 "Size: %s\n"
+				 _TAB3 "Backing store: %s\n",
 				 device->lun,
 				 device->scsi_id,
 				 device->scsi_sn,
@@ -1094,24 +1094,24 @@
 		if (!strcmp(tgt_drivers[target->lid]->name, "iscsi")) {
 			int i, aid;
 
-			shprintf(total, buf, rest, TAB1
+			shprintf(total, buf, rest, _TAB1
 				 "Account information:\n");
 			for (i = 0; i < target->account.nr_inaccount; i++) {
 				aid = target->account.in_aids[i];
-				shprintf(total, buf, rest, TAB2 "%s\n",
+				shprintf(total, buf, rest, _TAB2 "%s\n",
 					 __account_lookup_id(aid)->user);
 			}
 			if (target->account.out_aid) {
 				aid = target->account.out_aid;
 				shprintf(total, buf, rest,
-					 TAB2 "%s (outgoing)\n",
+					 _TAB2 "%s (outgoing)\n",
 					 __account_lookup_id(aid)->user);
 			}
 		}
 
-		shprintf(total, buf, rest, TAB1 "ACL information:\n");
+		shprintf(total, buf, rest, _TAB1 "ACL information:\n");
 		list_for_each_entry(acl, &target->acl_list, aclent_list)
-			shprintf(total, buf, rest, TAB2 "%s\n", acl->address);
+			shprintf(total, buf, rest, _TAB2 "%s\n", acl->address);
 	}
 	return total;
 overflow:
@@ -1269,7 +1269,7 @@
 		shprintf(total, buf, rest, "Account list:\n");
 
 	list_for_each_entry(ac, &account_list, account_siblings)
-		shprintf(total, buf, rest, TAB1 "%s\n", ac->user);
+		shprintf(total, buf, rest, _TAB1 "%s\n", ac->user);
 
 	return total;
 overflow:

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-10 07:16:20 UTC (rev 815)
+++ trunk/usr/tgtd.h	2007-03-10 08:58:41 UTC (rev 816)
@@ -13,10 +13,10 @@
 #define NID64(tid, nid) ((uint64_t) tid << TID_SHIFT | nid)
 #define NID2TID(nid) (nid >> TID_SHIFT)
 
-#define TAB1 "    "
-#define TAB2 TAB1 TAB1
-#define TAB3 TAB1 TAB1 TAB1
-#define TAB4 TAB2 TAB2
+#define _TAB1 "    "
+#define _TAB2 _TAB1 _TAB1
+#define _TAB3 _TAB1 _TAB1 _TAB1
+#define _TAB4 _TAB2 _TAB2
 
 enum scsi_target_state {
 	SCSI_TARGET_SUSPENDED = 1,



From tomo at mail.berlios.de  Sat Mar 10 10:54:11 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 10:54:11 +0100
Subject: [Stgt-svn] r817 - trunk/usr
Message-ID: <200703100954.l2A9sB51014536@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 10:54:10 +0100 (Sat, 10 Mar 2007)
New Revision: 817

Modified:
   trunk/usr/spt_sgv4.c
Log:
Improve sgv4 error print


Modified: trunk/usr/spt_sgv4.c
===================================================================
--- trunk/usr/spt_sgv4.c	2007-03-10 08:58:41 UTC (rev 816)
+++ trunk/usr/spt_sgv4.c	2007-03-10 09:54:10 UTC (rev 817)
@@ -207,7 +207,8 @@
 		cmd->async = 1;
 		return 0;
 	} else {
-		eprintf("%d %m\n", ret);
+		eprintf("%x %d %u %" PRIx64" %d %m\n",
+			cmd->scb[0], cmd->rw, cmd->len, cmd->uaddr, ret);
 		return -1;
 	}
 }



From tomo at mail.berlios.de  Sat Mar 10 11:07:31 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 11:07:31 +0100
Subject: [Stgt-svn] r818 - trunk/usr
Message-ID: <200703101007.l2AA7VQD015298@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 11:07:30 +0100 (Sat, 10 Mar 2007)
New Revision: 818

Modified:
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Remove the key arg in scsi_cmd_perform.


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-10 09:54:10 UTC (rev 817)
+++ trunk/usr/scsi.c	2007-03-10 10:07:30 UTC (rev 818)
@@ -106,7 +106,7 @@
 	return off;
 }
 
-int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key)
+int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
 	return cmd->c_target->dev_type_template->ops[op].cmd_perform(host_no, cmd);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-10 09:54:10 UTC (rev 817)
+++ trunk/usr/target.c	2007-03-10 10:07:30 UTC (rev 818)
@@ -425,7 +425,7 @@
 	dprintf("%p %x %" PRIx64 " %d\n", cmd, cmd->scb[0], dev_id, enabled);
 
 	if (enabled) {
-		result = scsi_cmd_perform(nexus->host_no, cmd, (void *)cmd);
+		result = scsi_cmd_perform(nexus->host_no, cmd);
 
 		cmd_post_perform(q, cmd);
 
@@ -471,7 +471,7 @@
 
 			list_del(&cmd->qlist);
 			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
-			result = scsi_cmd_perform(nexus->host_no, cmd, (void *)cmd);
+			result = scsi_cmd_perform(nexus->host_no, cmd);
 			cmd_post_perform(q, cmd);
 			set_cmd_processed(cmd);
 			if (!cmd->async) {

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-10 09:54:10 UTC (rev 817)
+++ trunk/usr/tgtd.h	2007-03-10 10:07:30 UTC (rev 818)
@@ -131,7 +131,7 @@
 extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
-extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd, void *key);
+extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
 extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
 			     uint8_t asq);
 extern uint64_t scsi_rw_offset(uint8_t *scb);



From tomo at mail.berlios.de  Sat Mar 10 13:32:49 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 13:32:49 +0100
Subject: [Stgt-svn] r819 - in trunk: . doc
Message-ID: <200703101232.l2ACWne5003259@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 13:32:47 +0100 (Sat, 10 Mar 2007)
New Revision: 819

Modified:
   trunk/README
   trunk/doc/README.passthrough
   trunk/doc/TODO
Log:
Update documents.


Modified: trunk/README
===================================================================
--- trunk/README	2007-03-10 10:07:30 UTC (rev 818)
+++ trunk/README	2007-03-10 12:32:47 UTC (rev 819)
@@ -19,21 +19,14 @@
 
 Preparation
 -------------
-
-Get kernel version 2.6.20, rebuild the kernel, and reboot with the new
-kernel. Note you need to enable SCSI_TGT, SCSI_SRP, and SCSI_IBMVSCSIS
-kernel options in order to use the IBM VIO target driver.
-
-Note that if you are interested in only the iSCSI target driver, you
-don't need 2.6.20.  It works with any recent kernel versions (the
+The iSCSI target driver can works with any recent kernel versions (the
 oldest version that I confirmed is 2.6.18).
 
-Now you are ready to build target drivers. If you like to use the
-iSCSI target driver:
-
 host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1
 
-Or if you like to use the IBM VIO target driver:
+If you want IBM VIO target driver, get kernel version 2.6.20, rebuild
+the kernel, and reboot with the new kernel. Note you need to enable
+SCSI_TGT, SCSI_SRP, and SCSI_IBMVSCSIS kernel options.
 
 host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> IBMVIO=1
 

Modified: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2007-03-10 10:07:30 UTC (rev 818)
+++ trunk/doc/README.passthrough	2007-03-10 12:32:47 UTC (rev 819)
@@ -38,13 +38,10 @@
 Third, compile the code with RAW option enabled like the following
 example (for the case you use iSCSI the target driver):
 
-host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1 RAW=1
+host:~/tgt/usr$ make KERNELSRC=<kernel-src-directory> ISCSI=1 SGV4=1
 
 The following example is to export /dev/sdb via the iscsi driver:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --backing-store-type raw -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --target-type pt -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sdb
 host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
-
-If you want to export a cdrom drive, use /dev/sr0 instead of /dev/sdb
-in the above example.

Modified: trunk/doc/TODO
===================================================================
--- trunk/doc/TODO	2007-03-10 10:07:30 UTC (rev 818)
+++ trunk/doc/TODO	2007-03-10 12:32:47 UTC (rev 819)
@@ -57,4 +57,3 @@
 asynchrnously). This workaround will be removed when upstream kernels
 have a unified event notification interface (there are some candidates
 under development). It should improve the tgt AIO performance too.
-



From tomo at mail.berlios.de  Sat Mar 10 17:47:07 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 10 Mar 2007 17:47:07 +0100
Subject: [Stgt-svn] r820 - in trunk/usr: . ibmvio
Message-ID: <200703101647.l2AGl76w020484@sheep.berlios.de>

Author: tomo
Date: 2007-03-10 17:47:07 +0100 (Sat, 10 Mar 2007)
New Revision: 820

Modified:
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/mmc.c
   trunk/usr/osd.c
   trunk/usr/sbc.c
   trunk/usr/spc.c
   trunk/usr/spc.h
   trunk/usr/tgtd.h
Log:
Clean up inquiry code.


Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-10 16:47:07 UTC (rev 820)
@@ -42,6 +42,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "spc.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -68,12 +69,14 @@
 
 #define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
 
-static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
+static int ibmvstgt_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 {
 	struct inquiry_data *id = (struct inquiry_data *) data;
 	char system_id[256], path[256], buf[32];
 	int fd, err, partition_number;
 	unsigned int unit_address;
+	unsigned char device_type = cmd->c_target->dev_type_template->type;
+	uint64_t lun = *((uint64_t *) cmd->lun);
 
 	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
 	fd = open(path, O_RDONLY);
@@ -98,7 +101,7 @@
 	dprintf("%d %s %d %x %" PRIx64 "\n",
 		host_no, system_id, partition_number, unit_address, lun);
 
-	id->qual_type = TYPE_DISK;
+	id->qual_type = device_type;
 	id->rmb_reserve = 0x00;
 	id->version = 0x84;	/* ISO/IE		  */
 	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
@@ -127,9 +130,8 @@
 
 int scsi_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	int result = SAM_STAT_CHECK_CONDITION;
+	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
-	int *len = &cmd->len;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -146,61 +148,23 @@
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
-		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) cmd->lun), data);
-		result = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x2) {
-		/* CmdDt bit is set */
-		/* We do not support it now. */
-		data[1] = 0x1;
-		data[5] = 0;
-		*len = 6;
-		result = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x1) {
-		/* EVPD bit set */
-		if (scb[2] == 0x0) {
-			data[1] = 0x0;
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			*len = 7;
-			result = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			data[1] = 0x80;
-			data[3] = 4;
-			memset(data + 4, 0x20, 4);
-			*len = 8;
-			result = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x83) {
-			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
+		cmd->len = ibmvstgt_inquiry(host_no, cmd, data);
+		ret = SAM_STAT_GOOD;
+	} else
+		return spc_inquiry(host_no, cmd);
 
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			if (cmd->dev)
-				strncpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
-			*len = tmp + 8;
-			result = SAM_STAT_GOOD;
-		}
-	}
-
-	if (result != SAM_STAT_GOOD) {
-		free(data);
+	if (ret != SAM_STAT_GOOD)
 		goto sense;
-	}
 
-	*len = min_t(int, *len, scb[4]);
-	cmd->uaddr = (unsigned long)data;
+	cmd->len = min_t(int, cmd->len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
 
 	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
 	return SAM_STAT_GOOD;
-
 sense:
-	*len = 0;
+	cmd->len = 0;
 	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }

Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/mmc.c	2007-03-10 16:47:07 UTC (rev 820)
@@ -27,106 +27,6 @@
 
 #define MMC_BLK_SHIFT 11
 
-#define PRODUCT_ID	"Virtual CD/DVD ROM"
-#define PRODUCT_REV	"0"
-
-static int mmc_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	uint8_t *data;
-	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
-
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	if (!(scb[1] & 0x3)) {
-		data[0] = TYPE_ROM;
-		data[1] = 0x80;
-		data[2] = 0x03;
-		data[3] = 0x02;
-		data[4] = 0x1f;
-		data[7] = 0x02;
-		memcpy(data + 8, VENDOR_ID,
-		       min_t(size_t, strlen(VENDOR_ID), 8));
-		memcpy(data + 16, PRODUCT_ID,
-		       min_t(size_t, strlen(PRODUCT_ID), 16));
-		memcpy(data + 32, PRODUCT_REV,
-			min_t(size_t, strlen(PRODUCT_REV), 4));
-		len = data[4] + 5;
-		ret = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x2) {
-		/* CmdDt bit is set */
-		/* We do not support it now. */
-	} else if (scb[1] & 0x1) {
-		if (scb[2] == 0x0) {
-			data[0] = TYPE_ROM;
-			data[1] = 0x0;
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			int tmp = SCSI_SN_LEN;
-
-			data[1] = 0x80;
-			data[3] = SCSI_SN_LEN;
-			memset(data + 4, 0x20, 4);
-			len = SCSI_SN_LEN + 4;
-			ret = SAM_STAT_GOOD;
-
-			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
-				uint8_t *p;
-				char *q;
-
-				p = data + 4 + tmp - 1;
-				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
-				for (; tmp > 0; tmp--, q)
-					*(p--) = *q;
-			}
-		} else if (scb[2] == 0x83) {
-			int tmp = SCSI_ID_LEN;
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			if (cmd->dev)
-				strncpy((char *) data + 8, cmd->dev->scsi_id,
-				        SCSI_ID_LEN);
-			len = tmp + 8;
-			ret = SAM_STAT_GOOD;
-		}
-	}
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
-	if (!cmd->dev)
-		data[0] = TYPE_NO_LUN;
-
-	return SAM_STAT_GOOD;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
 static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
@@ -205,7 +105,9 @@
 }
 
 struct device_type_template mmc_template = {
+	.type	= TYPE_ROM,
 	.name	= "cdrom/dvd",
+	.pid	= "VIRTUAL-CDROM",
 	.ops	= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
@@ -228,7 +130,7 @@
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_inquiry,},
+		{spc_inquiry,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/osd.c	2007-03-10 16:47:07 UTC (rev 820)
@@ -177,6 +177,7 @@
 }
 
 struct device_type_template osd_template = {
+	.type	= TYPE_OSD,
 	.name	= "osd",
 	.ops	= {
 		[0x00 ... 0x0f] = {spc_illegal_op},

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/sbc.c	2007-03-10 16:47:07 UTC (rev 820)
@@ -69,117 +69,6 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-#define PRODUCT_ID	"VIRTUAL-DISK"
-#define PRODUCT_REV	"0"
-
-static int __sbc_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	uint8_t *data;
-	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
-
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		data[2] = 4;
-		data[3] = 0x42;
-		data[4] = 59;
-		data[7] = 0x02;
-		memset(data + 8, 0x20, 28);
-		memcpy(data + 8,
-		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
-		memcpy(data + 16,
-		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
-		memcpy(data + 32,
-		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
-		data[58] = 0x03;
-		data[59] = 0x20;
-		data[60] = 0x09;
-		data[61] = 0x60;
-		data[62] = 0x03;
-		data[63] = 0x00;
-		len = 64;
-		ret = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x2) {
-		/* CmdDt bit is set */
-		/* We do not support it now. */
-		data[1] = 0x1;
-		data[5] = 0;
-		len = 6;
-		ret = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x1) {
-		/* EVPD bit set */
-		if (scb[2] == 0x0) {
-			data[1] = 0x0;
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			int tmp = SCSI_SN_LEN;
-
-			data[1] = 0x80;
-			data[3] = SCSI_SN_LEN;
-			memset(data + 4, 0x20, 4);
-			len = 4 + SCSI_SN_LEN;
-			ret = SAM_STAT_GOOD;
-
-			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
-				uint8_t *p;
-				char *q;
-
-				p = data + 4 + tmp - 1;
-				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
-				for (; tmp > 0; tmp--, q)
-					*(p--) = *q;
-			}
-		} else if (scb[2] == 0x83) {
-			int tmp = SCSI_ID_LEN;
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			if (cmd->dev)
-				strncpy((char *) data + 8, cmd->dev->scsi_id,
-				        SCSI_ID_LEN);
-			len = tmp + 8;
-			ret = SAM_STAT_GOOD;
-		}
-	}
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
-	if (!cmd->dev)
-		data[0] = TYPE_NO_LUN;
-
-	return SAM_STAT_GOOD;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
 static int sbc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, lid = cmd->c_target->lid;
@@ -187,7 +76,7 @@
 	if (tgt_drivers[lid]->scsi_inquiry)
 		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd);
 	else
-		ret = __sbc_inquiry(host_no, cmd);
+		ret = spc_inquiry(host_no, cmd);
 	return ret;
 }
 
@@ -446,7 +335,9 @@
 }
 
 struct device_type_template sbc_template = {
+	.type	= TYPE_DISK,
 	.name	= "disk",
+	.pid	= "VIRTUAL-DISK",
 	.ops	= {
 		{spc_test_unit,},
 		{spc_illegal_op,},

Modified: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/spc.c	2007-03-10 16:47:07 UTC (rev 820)
@@ -32,6 +32,117 @@
 #include "scsi.h"
 #include "spc.h"
 
+#define PRODUCT_REV	"0"
+
+int spc_inquiry(int host_no, struct scsi_cmd *cmd)
+{
+	int len, ret = SAM_STAT_CHECK_CONDITION;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	unsigned char device_type = cmd->c_target->dev_type_template->type;
+	char *product_id = cmd->c_target->dev_type_template->pid;
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = 0;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (!(scb[1] & 0x3)) {
+		data[0] = device_type;
+		data[2] = 4;
+		data[3] = 0x42;
+		data[4] = 59;
+		data[7] = 0x02;
+		memset(data + 8, 0x20, 28);
+		strncpy(data + 8, VENDOR_ID, 8);
+		strncpy(data + 16, product_id, 16);
+		strncpy(data + 32, PRODUCT_REV, 4);
+		data[58] = 0x03;
+		data[59] = 0x20;
+		data[60] = 0x09;
+		data[61] = 0x60;
+		data[62] = 0x03;
+		data[63] = 0x00;
+		len = 64;
+		ret = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x2) {
+		/* CmdDt bit is set */
+		/* We do not support it now. */
+		data[1] = 0x1;
+		data[5] = 0;
+		len = 6;
+		ret = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x1) {
+		/* EVPD bit set */
+		if (scb[2] == 0x0) {
+			data[0] = device_type;
+			data[1] = 0x0;
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			len = 7;
+			ret = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			int tmp = SCSI_SN_LEN;
+
+			data[1] = 0x80;
+			data[3] = SCSI_SN_LEN;
+			memset(data + 4, 0x20, 4);
+			len = 4 + SCSI_SN_LEN;
+			ret = SAM_STAT_GOOD;
+
+			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+				uint8_t *p;
+				char *q;
+
+				p = data + 4 + tmp - 1;
+				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
+
+				for (; tmp > 0; tmp--, q)
+					*(p--) = *q;
+			}
+		} else if (scb[2] == 0x83) {
+			int tmp = SCSI_ID_LEN;
+
+			data[1] = 0x83;
+			data[3] = tmp + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = tmp;
+			if (cmd->dev)
+				strncpy((char *) data + 8, cmd->dev->scsi_id,
+				        SCSI_ID_LEN);
+			len = tmp + 8;
+			ret = SAM_STAT_GOOD;
+		}
+	}
+
+	if (ret != SAM_STAT_GOOD)
+		goto sense;
+
+	cmd->len = min_t(int, len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
+
+	if (!cmd->dev)
+		data[0] = TYPE_NO_LUN;
+
+	return SAM_STAT_GOOD;
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
 static int __spc_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev;

Modified: trunk/usr/spc.h
===================================================================
--- trunk/usr/spc.h	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/spc.h	2007-03-10 16:47:07 UTC (rev 820)
@@ -1,6 +1,7 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
 extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-10 12:32:47 UTC (rev 819)
+++ trunk/usr/tgtd.h	2007-03-10 16:47:07 UTC (rev 820)
@@ -97,7 +97,9 @@
 };
 
 struct device_type_template {
+	unsigned char type;
 	char *name;
+	char *pid;
 	struct device_type_operations ops[256];
 };
 



From tomo at mail.berlios.de  Sun Mar 11 02:13:02 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 11 Mar 2007 02:13:02 +0100
Subject: [Stgt-svn] r821 - in trunk/usr: . ibmvio iscsi
Message-ID: <200703110113.l2B1D2Q3012468@sheep.berlios.de>

Author: tomo
Date: 2007-03-11 02:13:01 +0100 (Sun, 11 Mar 2007)
New Revision: 821

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/sbc.c
   trunk/usr/scsi.c
   trunk/usr/spc.c
   trunk/usr/target.c
   trunk/usr/target.h
Log:
Kill scsi_report_luns and scsi_inquiry hack in tgt_driver struct.


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/driver.h	2007-03-11 01:13:01 UTC (rev 821)
@@ -6,16 +6,13 @@
 
 	int (*init) (int);
 
-	int (*target_create) (int, char *);
+	int (*target_create) (struct target *);
 	int (*target_destroy) (int);
 	int (*target_update) (int, char *);
 
 	int (*show) (int, int, uint64_t, uint32_t, uint64_t, char *, int);
 
-	/* the following three should be killed shortly */
 	uint64_t (*scsi_get_lun)(uint8_t *);
-	int (*scsi_report_luns)(int host_no, struct scsi_cmd *cmd);
-	int (*scsi_inquiry)(int host_no, struct scsi_cmd *cmd);
 
 	int (*cmd_end_notify)(uint64_t nid, int result, struct scsi_cmd *);
 	int (*mgmt_end_notify)(uint64_t nid, uint64_t mid, int result);

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -69,13 +69,13 @@
 
 #define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
 
-static int ibmvstgt_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
+static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 {
 	struct inquiry_data *id = (struct inquiry_data *) data;
 	char system_id[256], path[256], buf[32];
 	int fd, err, partition_number;
 	unsigned int unit_address;
-	unsigned char device_type = cmd->c_target->dev_type_template->type;
+	unsigned char device_type = cmd->c_target->dev_type_template.type;
 	uint64_t lun = *((uint64_t *) cmd->lun);
 
 	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
@@ -114,7 +114,11 @@
 	 * and their client won't  work unless we use VOPTA and
 	 * VDASD.
 	 */
-	memcpy(id->product, "VDASD blkdev    ", 16);
+	if (device_type)
+		memcpy(id->product, "VOPTA blkdev    ", 16);
+	else
+		memcpy(id->product, "VDASD blkdev    ", 16);
+
 	memcpy(id->revision, "0001", 4);
 	snprintf(id->unique,sizeof(id->unique),
 		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
@@ -128,7 +132,7 @@
 	return sizeof(*id);
 }
 
-int scsi_inquiry(int host_no, struct scsi_cmd *cmd)
+static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
@@ -148,7 +152,7 @@
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
-		cmd->len = ibmvstgt_inquiry(host_no, cmd, data);
+		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
 		ret = SAM_STAT_GOOD;
 	} else
 		return spc_inquiry(host_no, cmd);
@@ -178,7 +182,7 @@
 	return ((uint64_t) result) << 48;
 }
 
-int scsi_report_luns(int host_no, struct scsi_cmd *cmd)
+static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev;
 	struct list_head *dev_list = &cmd->c_target->device_list;
@@ -251,3 +255,16 @@
 	else
 		return GETTARGET(lun);
 }
+
+int ibmvio_target_create(struct target *target)
+{
+	unsigned char device_type = target->dev_type_template.type;
+	struct device_type_operations *ops = target->dev_type_template.ops;
+
+	if (device_type == TYPE_DISK || device_type == TYPE_ROM)
+		ops[INQUIRY].cmd_perform = ibmvio_inquiry;
+
+	ops[REPORT_LUNS].cmd_perform = ibmvio_report_luns;
+
+	return 0;
+}

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/ibmvio/ibmvio.h	2007-03-11 01:13:01 UTC (rev 821)
@@ -1,5 +1,4 @@
-extern int scsi_inquiry(int host_no, struct scsi_cmd *cmd);
-extern int scsi_report_luns(int host_no, struct scsi_cmd *cmd);
+extern int ibmvio_target_create(struct target *);
 
 extern uint64_t scsi_lun_to_int(uint8_t *p);
 
@@ -7,8 +6,7 @@
 	.name			= "ibmvio",
 	.use_kernel		= 1,
 	.scsi_get_lun		= scsi_lun_to_int,
-	.scsi_report_luns	= scsi_report_luns,
-	.scsi_inquiry		= scsi_inquiry,
+	.target_create		= ibmvio_target_create,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
 	.default_bdt		= &mmap_bdt,

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/iscsi/iscsi.h	2007-03-11 01:13:01 UTC (rev 821)
@@ -1,5 +1,5 @@
 extern int iscsi_init(int);
-extern int iscsi_target_create(int, char *);
+extern int iscsi_target_create(struct target *);
 extern int iscsi_target_destroy(int);
 extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
 			     uint64_t lun, char *buf, int rest);

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/iscsi/target.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -24,6 +24,7 @@
 #include "iscsid.h"
 #include "tgtadm.h"
 #include "tgtd.h"
+#include "target.h"
 
 static LIST_HEAD(targets_list);
 
@@ -240,8 +241,9 @@
 	return 0;
 }
 
-int iscsi_target_create(int tid, char *name)
+int iscsi_target_create(struct target *t)
 {
+	int tid = t->tid;
 	struct iscsi_target *target;
 	struct param default_tgt_session_param[] = {
 		{0, 8192},

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/mgmt.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -79,8 +79,6 @@
 	case OP_NEW:
 		err = tgt_target_create(lld_no, req->tid, mtask->buf,
 					req->target_type);
-		if (!err && tgt_drivers[lld_no]->target_create)
-			tgt_drivers[lld_no]->target_create(req->tid, mtask->buf);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/sbc.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -69,17 +69,6 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int sbc_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	int ret, lid = cmd->c_target->lid;
-
-	if (tgt_drivers[lid]->scsi_inquiry)
-		ret = tgt_drivers[lid]->scsi_inquiry(host_no, cmd);
-	else
-		ret = spc_inquiry(host_no, cmd);
-	return ret;
-}
-
 static int sbc_reserve(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
@@ -360,7 +349,7 @@
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_inquiry,},
+		{spc_inquiry,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/scsi.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -109,5 +109,5 @@
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_type_template->ops[op].cmd_perform(host_no, cmd);
+	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }

Modified: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/spc.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -39,8 +39,8 @@
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char device_type = cmd->c_target->dev_type_template->type;
-	char *product_id = cmd->c_target->dev_type_template->pid;
+	unsigned char device_type = cmd->c_target->dev_type_template.type;
+	char *product_id = cmd->c_target->dev_type_template.pid;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -143,7 +143,7 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int __spc_report_luns(int host_no, struct scsi_cmd *cmd)
+int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev;
 	struct list_head *dev_list = &cmd->c_target->device_list;
@@ -199,20 +199,6 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-int spc_report_luns(int host_no, struct scsi_cmd *cmd)
-{
-	struct target *target = cmd->c_target;
-	int ret, lid = target->lid;
-
-	/* temp hack */
-	if (tgt_drivers[lid]->scsi_report_luns)
-		ret = tgt_drivers[lid]->scsi_report_luns(host_no, cmd);
-	else
-		ret = __spc_report_luns(host_no, cmd);
-
-	return ret;
-}
-
 int spc_start_stop(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/target.c	2007-03-11 01:13:01 UTC (rev 821)
@@ -1064,7 +1064,7 @@
 			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
-			 target->dev_type_template->name,
+			 target->dev_type_template.name,
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
@@ -1167,16 +1167,16 @@
 
 	switch (t_type) {
 	case TYPE_DISK:
-		target->dev_type_template = &sbc_template;
+		target->dev_type_template = sbc_template;
 		break;
 	case TYPE_ROM:
-		target->dev_type_template = &mmc_template;
+		target->dev_type_template = mmc_template;
 		break;
 	case TYPE_OSD:
-		target->dev_type_template = &osd_template;
+		target->dev_type_template = osd_template;
 		break;
 	case TYPE_SPT:
-		target->dev_type_template = &spt_template;
+		target->dev_type_template = spt_template;
 		break;
 	default:
 		free(target);
@@ -1225,6 +1225,9 @@
 
 	dprintf("Succeed to create a new target %d\n", tid);
 
+	if (tgt_drivers[lld]->target_create)
+		tgt_drivers[lld]->target_create(target);
+
 	return 0;
 }
 

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-10 16:47:07 UTC (rev 820)
+++ trunk/usr/target.h	2007-03-11 01:13:01 UTC (rev 821)
@@ -50,7 +50,8 @@
 
 	struct tgt_account account;
 
-	struct device_type_template *dev_type_template;
+	/* we don't use a pointer because a lld could change this. */
+	struct device_type_template dev_type_template;
 };
 
 struct it_nexus {



From tomo at mail.berlios.de  Sun Mar 11 04:46:20 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 11 Mar 2007 04:46:20 +0100
Subject: [Stgt-svn] r822 - trunk/usr/iscsi
Message-ID: <200703110346.l2B3kKOv020260@sheep.berlios.de>

Author: tomo
Date: 2007-03-11 04:46:18 +0100 (Sun, 11 Mar 2007)
New Revision: 822

Added:
   trunk/usr/iscsi/iscsi_if.h
   trunk/usr/iscsi/iscsi_proto.h
Modified:
   trunk/usr/iscsi/iscsid.h
Log:
Add iscsi_proto.h and iscsi_if.h for struct iscsi_ecdb_ahdr. They will
be removed when upstream kernels have them.


Added: trunk/usr/iscsi/iscsi_if.h
===================================================================
--- trunk/usr/iscsi/iscsi_if.h	2007-03-11 01:13:01 UTC (rev 821)
+++ trunk/usr/iscsi/iscsi_if.h	2007-03-11 03:46:18 UTC (rev 822)
@@ -0,0 +1,333 @@
+/*
+ * iSCSI User/Kernel Shares (Defines, Constants, Protocol definitions, etc)
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_IF_H
+#define ISCSI_IF_H
+
+#define UEVENT_BASE			10
+#define KEVENT_BASE			100
+#define ISCSI_ERR_BASE			1000
+
+enum iscsi_uevent_e {
+	ISCSI_UEVENT_UNKNOWN		= 0,
+
+	/* down events */
+	ISCSI_UEVENT_CREATE_SESSION	= UEVENT_BASE + 1,
+	ISCSI_UEVENT_DESTROY_SESSION	= UEVENT_BASE + 2,
+	ISCSI_UEVENT_CREATE_CONN	= UEVENT_BASE + 3,
+	ISCSI_UEVENT_DESTROY_CONN	= UEVENT_BASE + 4,
+	ISCSI_UEVENT_BIND_CONN		= UEVENT_BASE + 5,
+	ISCSI_UEVENT_SET_PARAM		= UEVENT_BASE + 6,
+	ISCSI_UEVENT_START_CONN		= UEVENT_BASE + 7,
+	ISCSI_UEVENT_STOP_CONN		= UEVENT_BASE + 8,
+	ISCSI_UEVENT_SEND_PDU		= UEVENT_BASE + 9,
+	ISCSI_UEVENT_GET_STATS		= UEVENT_BASE + 10,
+	ISCSI_UEVENT_GET_PARAM		= UEVENT_BASE + 11,
+
+	ISCSI_UEVENT_TRANSPORT_EP_CONNECT	= UEVENT_BASE + 12,
+	ISCSI_UEVENT_TRANSPORT_EP_POLL		= UEVENT_BASE + 13,
+	ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT	= UEVENT_BASE + 14,
+
+	ISCSI_UEVENT_TGT_DSCVR		= UEVENT_BASE + 15,
+
+	/* up events */
+	ISCSI_KEVENT_RECV_PDU		= KEVENT_BASE + 1,
+	ISCSI_KEVENT_CONN_ERROR		= KEVENT_BASE + 2,
+	ISCSI_KEVENT_IF_ERROR		= KEVENT_BASE + 3,
+	ISCSI_KEVENT_DESTROY_SESSION	= KEVENT_BASE + 4,
+};
+
+enum iscsi_tgt_dscvr {
+	ISCSI_TGT_DSCVR_SEND_TARGETS	= 1,
+	ISCSI_TGT_DSCVR_ISNS		= 2,
+	ISCSI_TGT_DSCVR_SLP		= 3,
+};
+
+struct iscsi_uevent {
+	uint32_t type; /* k/u events type */
+	uint32_t iferror; /* carries interface or resource errors */
+	uint64_t transport_handle;
+
+	union {
+		/* messages u -> k */
+		struct msg_create_session {
+			uint32_t	initial_cmdsn;
+		} c_session;
+		struct msg_destroy_session {
+			uint32_t	sid;
+		} d_session;
+		struct msg_create_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn;
+		struct msg_bind_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	transport_eph;
+			uint32_t	is_leading;
+		} b_conn;
+		struct msg_destroy_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} d_conn;
+		struct msg_send_pdu {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	hdr_size;
+			uint32_t	data_size;
+		} send_pdu;
+		struct msg_set_param {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	param; /* enum iscsi_param */
+			uint32_t	len;
+		} set_param;
+		struct msg_start_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} start_conn;
+		struct msg_stop_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	conn_handle;
+			uint32_t	flag;
+		} stop_conn;
+		struct msg_get_stats {
+			uint32_t	sid;
+			uint32_t	cid;
+		} get_stats;
+		struct msg_transport_connect {
+			uint32_t	non_blocking;
+		} ep_connect;
+		struct msg_transport_poll {
+			uint64_t	ep_handle;
+			uint32_t	timeout_ms;
+		} ep_poll;
+		struct msg_transport_disconnect {
+			uint64_t	ep_handle;
+		} ep_disconnect;
+		struct msg_tgt_dscvr {
+			enum iscsi_tgt_dscvr	type;
+			uint32_t	host_no;
+			/*
+ 			 * enable = 1 to establish a new connection
+			 * with the server. enable = 0 to disconnect
+			 * from the server. Used primarily to switch
+			 * from one iSNS server to another.
+			 */
+			uint32_t	enable;
+		} tgt_dscvr;
+	} u;
+	union {
+		/* messages k -> u */
+		int			retcode;
+		struct msg_create_session_ret {
+			uint32_t	sid;
+			uint32_t	host_no;
+		} c_session_ret;
+		struct msg_create_conn_ret {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn_ret;
+		struct msg_recv_req {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	recv_handle;
+		} recv_req;
+		struct msg_conn_error {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	error; /* enum iscsi_err */
+		} connerror;
+		struct msg_session_destroyed {
+			uint32_t	host_no;
+			uint32_t	sid;
+		} d_session;
+		struct msg_transport_connect_ret {
+			uint64_t	handle;
+		} ep_connect_ret;
+	} r;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+/*
+ * Common error codes
+ */
+enum iscsi_err {
+	ISCSI_OK			= 0,
+
+	ISCSI_ERR_DATASN		= ISCSI_ERR_BASE + 1,
+	ISCSI_ERR_DATA_OFFSET		= ISCSI_ERR_BASE + 2,
+	ISCSI_ERR_MAX_CMDSN		= ISCSI_ERR_BASE + 3,
+	ISCSI_ERR_EXP_CMDSN		= ISCSI_ERR_BASE + 4,
+	ISCSI_ERR_BAD_OPCODE		= ISCSI_ERR_BASE + 5,
+	ISCSI_ERR_DATALEN		= ISCSI_ERR_BASE + 6,
+	ISCSI_ERR_AHSLEN		= ISCSI_ERR_BASE + 7,
+	ISCSI_ERR_PROTO			= ISCSI_ERR_BASE + 8,
+	ISCSI_ERR_LUN			= ISCSI_ERR_BASE + 9,
+	ISCSI_ERR_BAD_ITT		= ISCSI_ERR_BASE + 10,
+	ISCSI_ERR_CONN_FAILED		= ISCSI_ERR_BASE + 11,
+	ISCSI_ERR_R2TSN			= ISCSI_ERR_BASE + 12,
+	ISCSI_ERR_SESSION_FAILED	= ISCSI_ERR_BASE + 13,
+	ISCSI_ERR_HDR_DGST		= ISCSI_ERR_BASE + 14,
+	ISCSI_ERR_DATA_DGST		= ISCSI_ERR_BASE + 15,
+	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16,
+	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
+};
+
+/*
+ * iSCSI Parameters (RFC3720)
+ */
+enum iscsi_param {
+	/* passed in using netlink set param */
+	ISCSI_PARAM_MAX_RECV_DLENGTH,
+	ISCSI_PARAM_MAX_XMIT_DLENGTH,
+	ISCSI_PARAM_HDRDGST_EN,
+	ISCSI_PARAM_DATADGST_EN,
+	ISCSI_PARAM_INITIAL_R2T_EN,
+	ISCSI_PARAM_MAX_R2T,
+	ISCSI_PARAM_IMM_DATA_EN,
+	ISCSI_PARAM_FIRST_BURST,
+	ISCSI_PARAM_MAX_BURST,
+	ISCSI_PARAM_PDU_INORDER_EN,
+	ISCSI_PARAM_DATASEQ_INORDER_EN,
+	ISCSI_PARAM_ERL,
+	ISCSI_PARAM_IFMARKER_EN,
+	ISCSI_PARAM_OFMARKER_EN,
+	ISCSI_PARAM_EXP_STATSN,
+	ISCSI_PARAM_TARGET_NAME,
+	ISCSI_PARAM_TPGT,
+	ISCSI_PARAM_PERSISTENT_ADDRESS,
+	ISCSI_PARAM_PERSISTENT_PORT,
+	ISCSI_PARAM_SESS_RECOVERY_TMO,
+
+	/* pased in through bind conn using transport_fd */
+	ISCSI_PARAM_CONN_PORT,
+	ISCSI_PARAM_CONN_ADDRESS,
+
+	/* must always be last */
+	ISCSI_PARAM_MAX,
+};
+
+#define ISCSI_MAX_RECV_DLENGTH		(1 << ISCSI_PARAM_MAX_RECV_DLENGTH)
+#define ISCSI_MAX_XMIT_DLENGTH		(1 << ISCSI_PARAM_MAX_XMIT_DLENGTH)
+#define ISCSI_HDRDGST_EN		(1 << ISCSI_PARAM_HDRDGST_EN)
+#define ISCSI_DATADGST_EN		(1 << ISCSI_PARAM_DATADGST_EN)
+#define ISCSI_INITIAL_R2T_EN		(1 << ISCSI_PARAM_INITIAL_R2T_EN)
+#define ISCSI_MAX_R2T			(1 << ISCSI_PARAM_MAX_R2T)
+#define ISCSI_IMM_DATA_EN		(1 << ISCSI_PARAM_IMM_DATA_EN)
+#define ISCSI_FIRST_BURST		(1 << ISCSI_PARAM_FIRST_BURST)
+#define ISCSI_MAX_BURST			(1 << ISCSI_PARAM_MAX_BURST)
+#define ISCSI_PDU_INORDER_EN		(1 << ISCSI_PARAM_PDU_INORDER_EN)
+#define ISCSI_DATASEQ_INORDER_EN	(1 << ISCSI_PARAM_DATASEQ_INORDER_EN)
+#define ISCSI_ERL			(1 << ISCSI_PARAM_ERL)
+#define ISCSI_IFMARKER_EN		(1 << ISCSI_PARAM_IFMARKER_EN)
+#define ISCSI_OFMARKER_EN		(1 << ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_EXP_STATSN		(1 << ISCSI_PARAM_EXP_STATSN)
+#define ISCSI_TARGET_NAME		(1 << ISCSI_PARAM_TARGET_NAME)
+#define ISCSI_TPGT			(1 << ISCSI_PARAM_TPGT)
+#define ISCSI_PERSISTENT_ADDRESS	(1 << ISCSI_PARAM_PERSISTENT_ADDRESS)
+#define ISCSI_PERSISTENT_PORT		(1 << ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_SESS_RECOVERY_TMO		(1 << ISCSI_PARAM_SESS_RECOVERY_TMO)
+#define ISCSI_CONN_PORT			(1 << ISCSI_PARAM_CONN_PORT)
+#define ISCSI_CONN_ADDRESS		(1 << ISCSI_PARAM_CONN_ADDRESS)
+
+#define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
+#define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_hostdata - get LLD hostdata from scsi_host
+ * @_hostdata: pointer to scsi host's hostdata
+ **/
+#define iscsi_hostdata(_hostdata) ((void*)_hostdata + sizeof(unsigned long))
+
+/*
+ * These flags presents iSCSI Data-Path capabilities.
+ */
+#define CAP_RECOVERY_L0		0x1
+#define CAP_RECOVERY_L1		0x2
+#define CAP_RECOVERY_L2		0x4
+#define CAP_MULTI_R2T		0x8
+#define CAP_HDRDGST		0x10
+#define CAP_DATADGST		0x20
+#define CAP_MULTI_CONN		0x40
+#define CAP_TEXT_NEGO		0x80
+#define CAP_MARKERS		0x100
+
+/*
+ * These flags describes reason of stop_conn() call
+ */
+#define STOP_CONN_TERM		0x1
+#define STOP_CONN_SUSPEND	0x2
+#define STOP_CONN_RECOVER	0x3
+
+#define ISCSI_STATS_CUSTOM_MAX		32
+#define ISCSI_STATS_CUSTOM_DESC_MAX	64
+struct iscsi_stats_custom {
+	char desc[ISCSI_STATS_CUSTOM_DESC_MAX];
+	uint64_t value;
+};
+
+/*
+ * struct iscsi_stats - iSCSI Statistics (iSCSI MIB)
+ *
+ * Note: this structure contains counters collected on per-connection basis.
+ */
+struct iscsi_stats {
+	/* octets */
+	uint64_t txdata_octets;
+	uint64_t rxdata_octets;
+
+	/* xmit pdus */
+	uint32_t noptx_pdus;
+	uint32_t scsicmd_pdus;
+	uint32_t tmfcmd_pdus;
+	uint32_t login_pdus;
+	uint32_t text_pdus;
+	uint32_t dataout_pdus;
+	uint32_t logout_pdus;
+	uint32_t snack_pdus;
+
+	/* recv pdus */
+	uint32_t noprx_pdus;
+	uint32_t scsirsp_pdus;
+	uint32_t tmfrsp_pdus;
+	uint32_t textrsp_pdus;
+	uint32_t datain_pdus;
+	uint32_t logoutrsp_pdus;
+	uint32_t r2t_pdus;
+	uint32_t async_pdus;
+	uint32_t rjt_pdus;
+
+	/* errors */
+	uint32_t digest_err;
+	uint32_t timeout_err;
+
+	/*
+	 * iSCSI Custom Statistics support, i.e. Transport could
+	 * extend existing MIB statistics with its own specific statistics
+	 * up to ISCSI_STATS_CUSTOM_MAX
+	 */
+	uint32_t custom_length;
+	struct iscsi_stats_custom custom[0]
+		__attribute__ ((aligned (sizeof(uint64_t))));
+};
+
+#endif

Added: trunk/usr/iscsi/iscsi_proto.h
===================================================================
--- trunk/usr/iscsi/iscsi_proto.h	2007-03-11 01:13:01 UTC (rev 821)
+++ trunk/usr/iscsi/iscsi_proto.h	2007-03-11 03:46:18 UTC (rev 822)
@@ -0,0 +1,595 @@
+/*
+ * RFC 3720 (iSCSI) protocol data types
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_PROTO_H
+#define ISCSI_PROTO_H
+
+#define ISCSI_DRAFT20_VERSION	0x00
+
+/* default iSCSI listen port for incoming connections */
+#define ISCSI_LISTEN_PORT	3260
+
+/* Padding word length */
+#define PAD_WORD_LEN		4
+
+/*
+ * useful common(control and data pathes) macro
+ */
+#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
+#define hton24(p, v) { \
+        p[0] = (((v) >> 16) & 0xFF); \
+        p[1] = (((v) >> 8) & 0xFF); \
+        p[2] = ((v) & 0xFF); \
+}
+#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
+
+/*
+ * iSCSI Template Message Header
+ */
+struct iscsi_hdr {
+	uint8_t		opcode;
+	uint8_t		flags;		/* Final bit */
+	uint8_t		rsvd2[2];
+	uint8_t		hlength;	/* AHSs total length */
+	uint8_t		dlength[3];	/* Data length */
+	uint8_t		lun[8];
+	__be32		itt;		/* Initiator Task Tag */
+	__be32		ttt;		/* Target Task Tag */
+	__be32		statsn;
+	__be32		exp_statsn;
+	__be32		max_statsn;
+	uint8_t		other[12];
+};
+
+/************************* RFC 3720 Begin *****************************/
+
+#define ISCSI_RESERVED_TAG		0xffffffff
+
+/* Opcode encoding bits */
+#define ISCSI_OP_RETRY			0x80
+#define ISCSI_OP_IMMEDIATE		0x40
+#define ISCSI_OPCODE_MASK		0x3F
+
+/* Initiator Opcode values */
+#define ISCSI_OP_NOOP_OUT		0x00
+#define ISCSI_OP_SCSI_CMD		0x01
+#define ISCSI_OP_SCSI_TMFUNC		0x02
+#define ISCSI_OP_LOGIN			0x03
+#define ISCSI_OP_TEXT			0x04
+#define ISCSI_OP_SCSI_DATA_OUT		0x05
+#define ISCSI_OP_LOGOUT			0x06
+#define ISCSI_OP_SNACK			0x10
+
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
+/* Target Opcode values */
+#define ISCSI_OP_NOOP_IN		0x20
+#define ISCSI_OP_SCSI_CMD_RSP		0x21
+#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
+#define ISCSI_OP_LOGIN_RSP		0x23
+#define ISCSI_OP_TEXT_RSP		0x24
+#define ISCSI_OP_SCSI_DATA_IN		0x25
+#define ISCSI_OP_LOGOUT_RSP		0x26
+#define ISCSI_OP_R2T			0x31
+#define ISCSI_OP_ASYNC_EVENT		0x32
+#define ISCSI_OP_REJECT			0x3f
+
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
+/* iSCSI PDU Header */
+struct iscsi_cmd {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16 rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32 itt;	/* Initiator Task Tag */
+	__be32 data_length;
+	__be32 cmdsn;
+	__be32 exp_statsn;
+	uint8_t cdb[16];	/* SCSI Command Block */
+	/* Additional Data (Command Dependent) */
+};
+
+/* Command PDU flags */
+#define ISCSI_FLAG_CMD_FINAL		0x80
+#define ISCSI_FLAG_CMD_READ		0x40
+#define ISCSI_FLAG_CMD_WRITE		0x20
+#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
+
+/* SCSI Command Attribute values */
+#define ISCSI_ATTR_UNTAGGED		0
+#define ISCSI_ATTR_SIMPLE		1
+#define ISCSI_ATTR_ORDERED		2
+#define ISCSI_ATTR_HEAD_OF_QUEUE	3
+#define ISCSI_ATTR_ACA			4
+
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
+/* Extended CDB AHS */
+struct iscsi_ecdb_ahdr {
+	__be16 ahslength; /* CDB length - 15, including reserved byte */
+	uint8_t ahstype;
+	uint8_t reserved;
+	uint8_t ecdb[260 - 16]; /* 4-byte aligned extended CDB spillover */
+};
+
+/* SCSI Response Header */
+struct iscsi_cmd_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd1;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	exp_datasn;
+	__be32	bi_residual_count;
+	__be32	residual_count;
+	/* Response or Sense Data (optional) */
+};
+
+/* Command Response PDU flags */
+#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
+#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
+#define ISCSI_FLAG_CMD_OVERFLOW		0x04
+#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
+
+/* iSCSI Status values. Valid if Rsp Selector bit is not set */
+#define ISCSI_STATUS_CMD_COMPLETED	0
+#define ISCSI_STATUS_TARGET_FAILURE	1
+#define ISCSI_STATUS_SUBSYS_FAILURE	2
+
+/* Asynchronous Event Header */
+struct iscsi_async {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	uint8_t rsvd4[8];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t async_event;
+	uint8_t async_vcode;
+	__be16	param1;
+	__be16	param2;
+	__be16	param3;
+	uint8_t rsvd5[4];
+};
+
+/* iSCSI Event Codes */
+#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
+#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
+#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
+#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
+#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
+#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
+
+/* NOP-Out Message */
+struct iscsi_nopout {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* NOP-In Message */
+struct iscsi_nopin {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd4[12];
+};
+
+/* SCSI Task Management Message Header */
+struct iscsi_tm {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	__be32	refcmdsn;
+	__be32	exp_datasn;
+	uint8_t rsvd2[8];
+};
+
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
+
+/* Function values */
+#define ISCSI_TM_FUNC_ABORT_TASK		1
+#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
+#define ISCSI_TM_FUNC_CLEAR_ACA			3
+#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
+#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
+#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
+#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
+#define ISCSI_TM_FUNC_TASK_REASSIGN		8
+
+/* SCSI Task Management Response Header */
+struct iscsi_tm_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Response values below */
+	uint8_t qualifier;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd3[12];
+};
+
+/* Response values */
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
+
+/* Ready To Transfer Header */
+struct iscsi_r2t_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t	hlength;
+	uint8_t	dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	r2tsn;
+	__be32	data_offset;
+	__be32	data_length;
+};
+
+/* SCSI Data Hdr */
+struct iscsi_data {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	rsvd4;
+	__be32	exp_statsn;
+	__be32	rsvd5;
+	__be32	datasn;
+	__be32	offset;
+	__be32	rsvd6;
+	/* Payload */
+};
+
+/* SCSI Data Response Hdr */
+struct iscsi_data_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	__be32	offset;
+	__be32	residual_count;
+};
+
+/* Data Response PDU flags */
+#define ISCSI_FLAG_DATA_ACK		0x40
+#define ISCSI_FLAG_DATA_OVERFLOW	0x04
+#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
+#define ISCSI_FLAG_DATA_STATUS		0x01
+
+/* Text Header */
+struct iscsi_text {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+	/* Text - key=value pairs */
+};
+
+#define ISCSI_FLAG_TEXT_CONTINUE	0x40
+
+/* Text Response Header */
+struct iscsi_text_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd5[12];
+	/* Text Response - key:value pairs */
+};
+
+/* Login Header */
+struct iscsi_login {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t min_version;	/* Min. version supported */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	__be16	rsvd3;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+};
+
+/* Login PDU flags */
+#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
+#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
+#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
+#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
+
+#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
+	((flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) >> 2)
+#define ISCSI_LOGIN_NEXT_STAGE(flags) \
+	(flags & ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
+
+/* Login Response Header */
+struct iscsi_login_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t active_version;	/* Active version */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd3;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t status_class;	/* see Login RSP ststus classes below */
+	uint8_t status_detail;	/* see Login RSP Status details below */
+	uint8_t rsvd4[10];
+};
+
+/* Login stage (phase) codes for CSG, NSG */
+#define ISCSI_INITIAL_LOGIN_STAGE		-1
+#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
+#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
+#define ISCSI_FULL_FEATURE_PHASE		3
+
+/* Login Status response classes */
+#define ISCSI_STATUS_CLS_SUCCESS		0x00
+#define ISCSI_STATUS_CLS_REDIRECT		0x01
+#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
+#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
+
+/* Login Status response detail codes */
+/* Class-0 (Success) */
+#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
+
+/* Class-1 (Redirection) */
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
+
+/* Class-2 (Initiator Error) */
+#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
+#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
+#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
+#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
+#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
+#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
+#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
+#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
+#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
+#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
+#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
+#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
+
+/* Class-3 (Target Error) */
+#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
+#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
+#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
+
+/* Logout Header */
+struct iscsi_logout {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	uint8_t rsvd3[2];
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* Logout PDU flags */
+#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
+
+/* logout reason_code values */
+
+#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
+#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
+#define ISCSI_LOGOUT_REASON_RECOVERY		2
+#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
+
+/* Logout Response Header */
+struct iscsi_logout_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Logout response values below */
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd4;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	rsvd5;
+	__be16	t2wait;
+	__be16	t2retain;
+	__be32	rsvd6;
+};
+
+/* logout response status values */
+
+#define ISCSI_LOGOUT_SUCCESS			0
+#define ISCSI_LOGOUT_CID_NOT_FOUND		1
+#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
+#define ISCSI_LOGOUT_CLEANUP_FAILED		3
+
+/* SNACK Header */
+struct iscsi_snack {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[14];
+	__be32	itt;
+	__be32	begrun;
+	__be32	runlength;
+	__be32	exp_statsn;
+	__be32	rsvd3;
+	__be32	exp_datasn;
+	uint8_t rsvd6[8];
+};
+
+/* SNACK PDU flags */
+#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
+
+/* Reject Message Header */
+struct iscsi_reject {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t reason;
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32  ffffffff;
+	uint8_t rsvd4[4];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	uint8_t rsvd5[8];
+	/* Text - Rejected hdr */
+};
+
+/* Reason for Reject */
+#define ISCSI_REASON_CMD_BEFORE_LOGIN	1
+#define ISCSI_REASON_DATA_DIGEST_ERROR	2
+#define ISCSI_REASON_DATA_SNACK_REJECT	3
+#define ISCSI_REASON_PROTOCOL_ERROR	4
+#define ISCSI_REASON_CMD_NOT_SUPPORTED	5
+#define ISCSI_REASON_IMM_CMD_REJECT		6
+#define ISCSI_REASON_TASK_IN_PROGRESS	7
+#define ISCSI_REASON_INVALID_SNACK		8
+#define ISCSI_REASON_BOOKMARK_INVALID	9
+#define ISCSI_REASON_BOOKMARK_NO_RESOURCES	10
+#define ISCSI_REASON_NEGOTIATION_RESET	11
+
+/* Max. number of Key=Value pairs in a text message */
+#define MAX_KEY_VALUE_PAIRS	8192
+
+/* maximum length for text keys/values */
+#define KEY_MAXLEN		64
+#define VALUE_MAXLEN		255
+#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
+
+#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
+
+/************************* RFC 3720 End *****************************/
+
+#endif /* ISCSI_PROTO_H */

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-11 01:13:01 UTC (rev 821)
+++ trunk/usr/iscsi/iscsid.h	2007-03-11 03:46:18 UTC (rev 822)
@@ -17,8 +17,8 @@
 #include "log.h"
 #include "tgtd.h"
 
-#include <scsi/iscsi_if.h>
-#include <scsi/iscsi_proto.h>
+#include "iscsi_proto.h"
+#include "iscsi_if.h"
 
 #define cpu_to_be16(x)	__cpu_to_be16(x)
 #define cpu_to_be32(x)	__cpu_to_be32(x)



From tomo at mail.berlios.de  Sun Mar 11 06:36:50 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 11 Mar 2007 06:36:50 +0100
Subject: [Stgt-svn] r823 - trunk/usr
Message-ID: <200703110536.l2B5ao2B009129@sheep.berlios.de>

Author: tomo
Date: 2007-03-11 06:36:45 +0100 (Sun, 11 Mar 2007)
New Revision: 823

Modified:
   trunk/usr/spt.c
Log:
Remove sbc_template in spt. spt should works for any device types.


Modified: trunk/usr/spt.c
===================================================================
--- trunk/usr/spt.c	2007-03-11 03:46:18 UTC (rev 822)
+++ trunk/usr/spt.c	2007-03-11 05:36:45 UTC (rev 823)
@@ -61,15 +61,15 @@
 	.bd_cmd_done		= spt_sg_cmd_done,
 };
 
-extern struct device_type_template sbc_template;
-
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
+	struct device_type_operations *ops;
 
-	/* FIXME */
-	if (!cmd->dev)
-		return sbc_template.ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+	if (!cmd->dev) {
+		ops = cmd->c_target->dev_type_template.ops;
+		return ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+	}
 
 	ret = spt_sg_perform(cmd);
 	if (ret) {



From tomo at mail.berlios.de  Wed Mar 14 11:00:51 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 14 Mar 2007 11:00:51 +0100
Subject: [Stgt-svn] r824 - trunk/usr/iscsi
Message-ID: <200703141000.l2EA0pQA023337@sheep.berlios.de>

Author: tomo
Date: 2007-03-14 11:00:50 +0100 (Wed, 14 Mar 2007)
New Revision: 824

Modified:
   trunk/usr/iscsi/iscsi_tcp.c
Log:
Enable the keepalive option on iSCSI connections to avoid remaining
connections and sessions. We had better implement nop-in/out fully
later on.  --This line, and those below, will be ignored--

M    usr/iscsi/iscsi_tcp.c


Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2007-03-11 05:36:45 UTC (rev 823)
+++ trunk/usr/iscsi/iscsi_tcp.c	2007-03-14 10:00:50 UTC (rev 824)
@@ -40,6 +40,33 @@
 #define LISTEN_MAX		4
 #define INCOMING_MAX		32
 
+static int set_keepalive(int fd)
+{
+	int ret, opt;
+
+	opt = 1;
+	ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &opt, sizeof(opt));
+	if (ret)
+		return ret;
+
+	opt = 1800;
+	ret = setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &opt, sizeof(opt));
+	if (ret)
+		return ret;
+
+	opt = 6;
+	ret = setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &opt, sizeof(opt));
+	if (ret)
+		return ret;
+
+	opt = 300;
+	ret = setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &opt, sizeof(opt));
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
 static void accept_connection(int afd, int events, void *data)
 {
 	struct sockaddr_storage from;
@@ -56,6 +83,10 @@
 		return;
 	}
 
+	err = set_keepalive(fd);
+	if (err)
+		goto out;
+
 	conn = conn_alloc();
 	if (!conn)
 		goto out;



From tomo at mail.berlios.de  Wed Mar 14 11:06:48 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 14 Mar 2007 11:06:48 +0100
Subject: [Stgt-svn] r825 - trunk/usr
Message-ID: <200703141006.l2EA6mUb023662@sheep.berlios.de>

Author: tomo
Date: 2007-03-14 11:06:46 +0100 (Wed, 14 Mar 2007)
New Revision: 825

Modified:
   trunk/usr/util.h
Log:
Add roundup macro (stolen from Linux kernel)


Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2007-03-14 10:00:50 UTC (rev 824)
+++ trunk/usr/util.h	2007-03-14 10:06:46 UTC (rev 825)
@@ -3,6 +3,7 @@
 
 #include <byteswap.h>
 
+#define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 #define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
 



From tomo at mail.berlios.de  Thu Mar 15 03:05:47 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 03:05:47 +0100
Subject: [Stgt-svn] r826 - trunk/usr/iscsi
Message-ID: <200703150205.l2F25lSE030626@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 03:05:46 +0100 (Thu, 15 Mar 2007)
New Revision: 826

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Add extdata to iscsi_task struct.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-14 10:06:46 UTC (rev 825)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 02:05:46 UTC (rev 826)
@@ -865,12 +865,12 @@
 }
 
 static inline struct iscsi_task *
-iscsi_alloc_task(struct iscsi_connection *conn)
+iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 {
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = zalloc(sizeof(*task));
+	task = zalloc(sizeof(*task) + ext_len);
 	if (!task)
 		return NULL;
 
@@ -1205,25 +1205,16 @@
 	return 0;
 }
 
-static struct iscsi_task *__iscsi_task_rx_start(struct iscsi_connection *conn)
-{
-	struct iscsi_task *task;
-
-	task = iscsi_alloc_task(conn);
-	if (!task)
-		return NULL;
-	conn->rx_task = task;
-	return task;
-}
-
 static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
 	int len;
 
-	task = __iscsi_task_rx_start(conn);
-	if (!task)
+	task = iscsi_alloc_task(conn, 0);
+	if (task)
+		conn->rx_task = task;
+	else
 		return -ENOMEM;
 	task->tag = req->itt;
 
@@ -1283,8 +1274,10 @@
 
 	conn->exp_stat_sn = be32_to_cpu(req->exp_statsn);
 
-	task = __iscsi_task_rx_start(conn);
-	if (!task)
+	task = iscsi_alloc_task(conn, 0);
+	if (task)
+		conn->rx_task = task;
+	else
 		goto out;
 
 	len = ntoh24(req->dlength);
@@ -1335,6 +1328,7 @@
 static int iscsi_task_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
+	struct iscsi_task *task;
 	uint8_t op;
 	int err = 0;
 
@@ -1355,7 +1349,10 @@
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
-		if (!__iscsi_task_rx_start(conn))
+		task = iscsi_alloc_task(conn, 0);
+		if (task)
+			conn->rx_task = task;
+		else
 			err = -ENOMEM;
 		break;
 	case ISCSI_OP_TEXT:

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-14 10:06:46 UTC (rev 825)
+++ trunk/usr/iscsi/iscsid.h	2007-03-15 02:05:46 UTC (rev 826)
@@ -115,6 +115,8 @@
 	void *c_buffer;
 
 	struct scsi_cmd scmd;
+
+	unsigned long extdata[0];
 };
 
 struct iscsi_connection {



From tomo at mail.berlios.de  Thu Mar 15 05:05:13 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 05:05:13 +0100
Subject: [Stgt-svn] r827 - trunk/usr/iscsi
Message-ID: <200703150405.l2F45Dcm004809@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 05:05:12 +0100 (Thu, 15 Mar 2007)
New Revision: 827

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Kill iscsi_task::c_buffer to simplify the buffer management.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 02:05:46 UTC (rev 826)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 04:05:12 UTC (rev 827)
@@ -879,6 +879,9 @@
 	INIT_LIST_HEAD(&task->c_hlist);
 	INIT_LIST_HEAD(&task->c_list);
 
+	if (ext_len)
+		task->data = task->extdata;
+
 	conn_get(conn);
 	return task;
 }
@@ -887,10 +890,7 @@
 {
 	struct iscsi_connection *conn = task->conn;
 
-	if (task->c_buffer)
-		free(task->c_buffer);
 	free(task);
-
 	/* from alloc */
 	conn_put(conn);
 }
@@ -905,8 +905,8 @@
 	target_cmd_done(&task->scmd);
 
 	list_del(&task->c_hlist);
-	if (task->c_buffer) {
-		if ((unsigned long) task->c_buffer != task->addr)
+	if (task->data) {
+		if ((unsigned long) task->data != task->addr)
 			free((void *) (unsigned long) task->addr);
 	}
 	iscsi_free_task(task);
@@ -963,7 +963,7 @@
 	struct scsi_cmd *scmd = &task->scmd;
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	unsigned long uaddr = (unsigned long) task->c_buffer;
+	unsigned long uaddr = (unsigned long) task->data;
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
 	/* tmp hack */
@@ -1141,7 +1141,7 @@
 		task->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
-	conn->rx_buffer = (void *) (unsigned long) task->c_buffer;
+	conn->rx_buffer = task->data;
 	conn->rx_buffer += be32_to_cpu(req->offset);
 	conn->rx_size = ntoh24(req->dlength);
 
@@ -1209,32 +1209,22 @@
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
-	int len;
 
-	task = iscsi_alloc_task(conn, 0);
+	dprintf("%u %x %d %d %x\n", conn->session->tsih,
+		req->cdb[0], ntohl(req->data_length),
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
+
+	task = iscsi_alloc_task(conn, ntohl(req->data_length));
 	if (task)
 		conn->rx_task = task;
 	else
 		return -ENOMEM;
+
 	task->tag = req->itt;
 
-	dprintf("%u %x %d %d %x\n", conn->session->tsih,
-		req->cdb[0], ntohl(req->data_length),
-		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
-
-	len = ntohl(req->data_length);
-	if (len) {
-		task->c_buffer = valloc(len);
-		if (!task->c_buffer) {
-			iscsi_free_task(task);
-			return -ENOMEM;
-		}
-		dprintf("%p\n", task->c_buffer);
-	}
-
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		conn->rx_size = ntoh24(req->dlength);
-		conn->rx_buffer = task->c_buffer;
+		conn->rx_buffer = task->data;
 		task->r2t_count = ntohl(req->data_length) - conn->rx_size;
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
 		task->offset = conn->rx_size;
@@ -1274,23 +1264,17 @@
 
 	conn->exp_stat_sn = be32_to_cpu(req->exp_statsn);
 
-	task = iscsi_alloc_task(conn, 0);
+	len = ntoh24(req->dlength);
+	task = iscsi_alloc_task(conn, len);
 	if (task)
 		conn->rx_task = task;
 	else
 		goto out;
 
-	len = ntoh24(req->dlength);
 	if (len) {
 		conn->rx_size = len;
 		task->len = len;
-		task->c_buffer = malloc(len);
-		if (!task->c_buffer) {
-			iscsi_free_task(task);
-			goto out;
-		}
-
-		conn->rx_buffer = task->c_buffer;
+		conn->rx_buffer = task->data;
 	}
 out:
 	return err;
@@ -1436,7 +1420,7 @@
 		/* TODO: honor max_burst */
 		conn->rsp.datasize = task->len;
 		hton24(rsp->dlength, task->len);
-		conn->rsp.data = task->c_buffer;
+		conn->rsp.data = task->data;
 	}
 
 	return 0;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-15 02:05:46 UTC (rev 826)
+++ trunk/usr/iscsi/iscsid.h	2007-03-15 04:05:12 UTC (rev 827)
@@ -112,7 +112,7 @@
 	int unsol_count;
 	int exp_r2tsn;
 
-	void *c_buffer;
+	void *data;
 
 	struct scsi_cmd scmd;
 



From tomo at mail.berlios.de  Thu Mar 15 17:17:13 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 17:17:13 +0100
Subject: [Stgt-svn] r828 - trunk/usr/iscsi
Message-ID: <200703151617.l2FGHDF7012922@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 17:17:13 +0100 (Thu, 15 Mar 2007)
New Revision: 828

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
clean up iscsi_scsi_cmd_execute

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 04:05:12 UTC (rev 827)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 16:17:13 UTC (rev 828)
@@ -984,19 +984,17 @@
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
+	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
 	int err = 0;
 
-	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		if (task->r2t_count) {
-			if (task->unsol_count)
-				;
-			else
-				list_add_tail(&task->c_list, &task->conn->tx_clist);
-		} else
-			err = iscsi_target_cmd_queue(task);
-	} else
-		err = iscsi_target_cmd_queue(task);
+	if (rw && task->r2t_count) {
+		if (!task->unsol_count)
+			list_add_tail(&task->c_list, &task->conn->tx_clist);
+		goto no_queuing;
+	}
 
+	err = iscsi_target_cmd_queue(task);
+no_queuing:
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
 
 	return err;



From tomo at mail.berlios.de  Thu Mar 15 17:20:20 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 17:20:20 +0100
Subject: [Stgt-svn] r829 - trunk/usr/iscsi
Message-ID: <200703151620.l2FGKKR0013100@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 17:20:19 +0100 (Thu, 15 Mar 2007)
New Revision: 829

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
add AHS support to iscsi_scsi_cmd_rx_start()

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 16:17:13 UTC (rev 828)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 16:20:19 UTC (rev 829)
@@ -1207,12 +1207,20 @@
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
+	int ahs_len, imm_len, data_len, task_len;
 
-	dprintf("%u %x %d %d %x\n", conn->session->tsih,
-		req->cdb[0], ntohl(req->data_length),
+	ahs_len = roundup(req->hlength * 4, 4);
+	imm_len = roundup(ntoh24(req->dlength), 4);
+	data_len = ntohl(req->data_length);
+
+	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
+		req->cdb[0], ahs_len, imm_len, data_len,
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
-	task = iscsi_alloc_task(conn, ntohl(req->data_length));
+	task_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0
+		+ max(imm_len, data_len);
+
+	task = iscsi_alloc_task(conn, task_len);
 	if (task)
 		conn->rx_task = task;
 	else
@@ -1220,12 +1228,20 @@
 
 	task->tag = req->itt;
 
+	if (ahs_len || data_len) {
+		if (ahs_len) {
+			task->ahs = task->data + sizeof(req->cdb);
+			task->data = task->ahs + ahs_len;
+		}
+
+		conn->rx_size = ahs_len + imm_len;
+		conn->rx_buffer = task->data;
+	}
+
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		conn->rx_size = ntoh24(req->dlength);
-		conn->rx_buffer = task->data;
-		task->r2t_count = ntohl(req->data_length) - conn->rx_size;
+		task->r2t_count = data_len - imm_len;
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		task->offset = conn->rx_size;
+		task->offset = imm_len;
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
 			task->unsol_count, task->offset);

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-15 16:17:13 UTC (rev 828)
+++ trunk/usr/iscsi/iscsid.h	2007-03-15 16:20:19 UTC (rev 829)
@@ -112,6 +112,7 @@
 	int unsol_count;
 	int exp_r2tsn;
 
+	void *ahs;
 	void *data;
 
 	struct scsi_cmd scmd;



From tomo at mail.berlios.de  Thu Mar 15 17:23:13 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 17:23:13 +0100
Subject: [Stgt-svn] r830 - trunk/usr/iscsi
Message-ID: <200703151623.l2FGND1h013313@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 17:23:12 +0100 (Thu, 15 Mar 2007)
New Revision: 830

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
add AHS support to iscsi_target_cmd_queue()

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 16:20:19 UTC (rev 829)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 16:23:12 UTC (rev 830)
@@ -966,10 +966,32 @@
 	unsigned long uaddr = (unsigned long) task->data;
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
-	/* tmp hack */
-	scmd->scb = req->cdb;
-	scmd->scb_len = sizeof(req->cdb);
 
+	if (task->ahs) {
+		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
+		char *p = (void *)task->extdata;
+
+		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
+			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
+
+			if (extcdb_len + sizeof(req->cdb) > 260) {
+				eprintf("invalid extcdb len %d\n", extcdb_len);
+
+				return EINVAL;
+			}
+
+			memcpy(p, req->cdb, sizeof(req->cdb));
+			memmove(p + sizeof(req->cdb), ahs_extcdb->ecdb,
+				extcdb_len);
+
+			scmd->scb = p;
+			scmd->scb_len = sizeof(req->cdb) + extcdb_len;
+		}
+	} else {
+		scmd->scb = req->cdb;
+		scmd->scb_len = sizeof(req->cdb);
+	}
+
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
 	scmd->len = ntohl(req->data_length);



From tomo at mail.berlios.de  Thu Mar 15 17:26:10 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 17:26:10 +0100
Subject: [Stgt-svn] r831 - trunk/usr/iscsi
Message-ID: <200703151626.l2FGQAdk013535@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 17:26:10 +0100 (Thu, 15 Mar 2007)
New Revision: 831

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
add AHS support to iscsi_rx_handler()

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 16:23:12 UTC (rev 830)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 16:26:10 UTC (rev 831)
@@ -1597,32 +1597,25 @@
 
 		switch (conn->rx_iostate) {
 		case IOSTATE_READ_BHS:
-			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
 			conn->req.ahssize = conn->req.bhs.hlength * 4;
 			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-			conn->rx_size = (conn->req.ahssize + conn->req.datasize + 3) & -4;
 
-			if (conn->req.ahssize) {
-				eprintf("FIXME: we cannot handle ahs\n");
-				conn->state = STATE_CLOSE;
-				break;
-			}
-
 			if (conn->state == STATE_SCSI) {
 				res = iscsi_task_rx_start(conn);
 				if (res) {
 					conn->state = STATE_CLOSE;
 					break;
 				}
+			} else {
+				conn->rx_buffer = conn->req_buffer;
+				conn->req.ahs = conn->rx_buffer;
+				conn->rx_size = roundup(conn->req.ahssize, 4);
+				conn->req.data = conn->rx_buffer + conn->rx_size;
+				conn->rx_size += roundup(conn->req.datasize, 4);
 			}
 
 			if (conn->rx_size) {
-				if (conn->state != STATE_SCSI) {
-					conn->rx_buffer = conn->req_buffer;
-					conn->req.ahs = conn->rx_buffer;
-				}
-				conn->req.data =
-					conn->rx_buffer + conn->req.ahssize;
+				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
 				goto read_again;
 			}
 



From tomo at mail.berlios.de  Thu Mar 15 17:31:45 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 15 Mar 2007 17:31:45 +0100
Subject: [Stgt-svn] r832 - trunk/usr/iscsi
Message-ID: <200703151631.l2FGVjPl014003@sheep.berlios.de>

Author: tomo
Date: 2007-03-15 17:31:45 +0100 (Thu, 15 Mar 2007)
New Revision: 832

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
add Pete's Copyright.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-15 16:26:10 UTC (rev 831)
+++ trunk/usr/iscsi/iscsid.c	2007-03-15 16:31:45 UTC (rev 832)
@@ -3,6 +3,7 @@
  *
  * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007 Pete Wyckoff <pw at osc.edu>
  *
  * This code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/



From tomo at mail.berlios.de  Fri Mar 16 06:21:22 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 16 Mar 2007 06:21:22 +0100
Subject: [Stgt-svn] r833 - trunk/usr
Message-ID: <200703160521.l2G5LMq9017683@sheep.berlios.de>

Author: tomo
Date: 2007-03-16 06:21:21 +0100 (Fri, 16 Mar 2007)
New Revision: 833

Modified:
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
add descriptor format support to sense_data_build()


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2007-03-15 16:31:45 UTC (rev 832)
+++ trunk/usr/scsi.c	2007-03-16 05:21:21 UTC (rev 833)
@@ -40,15 +40,25 @@
 
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	int len = 0xa;
+	if (cmd->dev && cmd->dev->d_sense) {
+		/* descriptor format */
 
-	cmd->sense_buffer[0] = 0x70;
-	cmd->sense_buffer[2] = key;
-	cmd->sense_buffer[7] = len;
-	cmd->sense_buffer[12] = asc;
-	cmd->sense_buffer[13] = asq;
+		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
+		cmd->sense_buffer[1] = key;
+		cmd->sense_buffer[2] = asc;
+		cmd->sense_buffer[3] = asq;
+		cmd->sense_len = 8;
+	} else {
+		/* fixed format */
 
-	cmd->sense_len = len + 8;
+		int len = 0xa;
+		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[2] = key;
+		cmd->sense_buffer[7] = len;
+		cmd->sense_buffer[12] = asc;
+		cmd->sense_buffer[13] = asq;
+		cmd->sense_len = len + 8;
+	}
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-15 16:31:45 UTC (rev 832)
+++ trunk/usr/tgtd.h	2007-03-16 05:21:21 UTC (rev 833)
@@ -44,6 +44,9 @@
 	struct tgt_cmd_queue cmd_queue;
 
 	uint64_t reserve_id;
+
+	/* TODO: needs a structure for device parameters */
+	uint8_t d_sense;
 };
 
 struct scsi_cmd {



From tomo at mail.berlios.de  Fri Mar 16 06:38:36 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 16 Mar 2007 06:38:36 +0100
Subject: [Stgt-svn] r834 - trunk/usr
Message-ID: <200703160538.l2G5cadZ003235@sheep.berlios.de>

Author: tomo
Date: 2007-03-16 06:38:34 +0100 (Fri, 16 Mar 2007)
New Revision: 834

Modified:
   trunk/usr/osd.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
add device_type_template::device_init to set up a device type specific stuff


Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-16 05:21:21 UTC (rev 833)
+++ trunk/usr/osd.c	2007-03-16 05:38:34 UTC (rev 834)
@@ -176,10 +176,16 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+static void device_osd_init(struct tgt_device *dev)
+{
+	dev->d_sense = 1;
+}
+
 struct device_type_template osd_template = {
-	.type	= TYPE_OSD,
-	.name	= "osd",
-	.ops	= {
+	.type		= TYPE_OSD,
+	.name		= "osd",
+	.device_init	= device_osd_init,
+	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
 		/* 0x10 */

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-16 05:21:21 UTC (rev 833)
+++ trunk/usr/target.c	2007-03-16 05:38:34 UTC (rev 834)
@@ -242,6 +242,9 @@
 
 	tgt_cmd_queue_init(&device->cmd_queue);
 
+	if (target->dev_type_template.device_init)
+		target->dev_type_template.device_init(device);
+
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (device->lun < pos->lun)
 			break;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-16 05:21:21 UTC (rev 833)
+++ trunk/usr/tgtd.h	2007-03-16 05:38:34 UTC (rev 834)
@@ -45,7 +45,7 @@
 
 	uint64_t reserve_id;
 
-	/* TODO: needs a structure for device parameters */
+	/* TODO: needs a structure for lots of device parameters */
 	uint8_t d_sense;
 };
 
@@ -103,6 +103,9 @@
 	unsigned char type;
 	char *name;
 	char *pid;
+
+	void (*device_init)(struct tgt_device *dev);
+
 	struct device_type_operations ops[256];
 };
 



From tomo at mail.berlios.de  Fri Mar 16 06:55:17 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 16 Mar 2007 06:55:17 +0100
Subject: [Stgt-svn] r835 - trunk/usr/iscsi
Message-ID: <200703160555.l2G5tHKj026142@sheep.berlios.de>

Author: tomo
Date: 2007-03-16 06:55:16 +0100 (Fri, 16 Mar 2007)
New Revision: 835

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
iscsi ahs bugfixes

Set scb in case of exthdr but not AHS exthdr (like non-extended bidir).
Return -errno for consistency, even though nothing actually looks at it.
Repair precedence problem with ?:.
Read into ahs buffer when ahs exists.
Use unrounded immediate length value when considering how much more data
to fetch.

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-16 05:38:34 UTC (rev 834)
+++ trunk/usr/iscsi/iscsid.c	2007-03-16 05:55:16 UTC (rev 835)
@@ -968,17 +968,20 @@
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
 
+	scmd->scb = req->cdb;
+	scmd->scb_len = sizeof(req->cdb);
+
 	if (task->ahs) {
 		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
-		char *p = (void *)task->extdata;
 
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
+			char *p = (void *)task->extdata;
 
 			if (extcdb_len + sizeof(req->cdb) > 260) {
 				eprintf("invalid extcdb len %d\n", extcdb_len);
 
-				return EINVAL;
+				return -EINVAL;
 			}
 
 			memcpy(p, req->cdb, sizeof(req->cdb));
@@ -988,9 +991,6 @@
 			scmd->scb = p;
 			scmd->scb_len = sizeof(req->cdb) + extcdb_len;
 		}
-	} else {
-		scmd->scb = req->cdb;
-		scmd->scb_len = sizeof(req->cdb);
 	}
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
@@ -1240,8 +1240,8 @@
 		req->cdb[0], ahs_len, imm_len, data_len,
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
-	task_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0
-		+ max(imm_len, data_len);
+	task_len = max(imm_len, data_len) +
+		ahs_len ? sizeof(req->cdb) + ahs_len : 0;
 
 	task = iscsi_alloc_task(conn, task_len);
 	if (task)
@@ -1251,20 +1251,20 @@
 
 	task->tag = req->itt;
 
-	if (ahs_len || data_len) {
-		if (ahs_len) {
-			task->ahs = task->data + sizeof(req->cdb);
-			task->data = task->ahs + ahs_len;
-		}
+	if (ahs_len) {
+		task->ahs = task->data + sizeof(req->cdb);
+		task->data = task->ahs + ahs_len;
+		conn->rx_buffer = task->ahs;
+ 		conn->rx_size = ahs_len + imm_len;
+	} else if (data_len) {
+ 		conn->rx_buffer = task->data;
+		conn->rx_size = imm_len;
+ 	}
 
-		conn->rx_size = ahs_len + imm_len;
-		conn->rx_buffer = task->data;
-	}
-
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		task->r2t_count = data_len - imm_len;
+		task->offset = ntoh24(req->dlength);
+		task->r2t_count = data_len - task->offset;
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		task->offset = imm_len;
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
 			task->unsol_count, task->offset);



From tomo at mail.berlios.de  Sat Mar 17 01:41:53 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 01:41:53 +0100
Subject: [Stgt-svn] r836 - trunk/usr/iscsi
Message-ID: <200703170041.l2H0frBM001924@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 01:41:53 +0100 (Sat, 17 Mar 2007)
New Revision: 836

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
one more iscsi ahs bug fix

Try to fix the precedence bug again.  Binary + really does happen
before ternary ? : .

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-16 05:55:16 UTC (rev 835)
+++ trunk/usr/iscsi/iscsid.c	2007-03-17 00:41:53 UTC (rev 836)
@@ -1241,7 +1241,7 @@
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
 	task_len = max(imm_len, data_len) +
-		ahs_len ? sizeof(req->cdb) + ahs_len : 0;
+		(ahs_len ? sizeof(req->cdb) + ahs_len : 0);
 
 	task = iscsi_alloc_task(conn, task_len);
 	if (task)



From tomo at mail.berlios.de  Sat Mar 17 05:57:46 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 05:57:46 +0100
Subject: [Stgt-svn] r837 - trunk/usr
Message-ID: <200703170457.l2H4vkVB014416@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 05:57:45 +0100 (Sat, 17 Mar 2007)
New Revision: 837

Modified:
   trunk/usr/spc.c
Log:
Not updating Serial Number in SCSI Inquiry page	correctly

From: "Mark Harvey" <mark_harvey at symantec.com>

In page 0x80 of SCSI Inquiry, forgot to decrement the destination
pointer.


Modified: trunk/usr/spc.c
===================================================================
--- trunk/usr/spc.c	2007-03-17 00:41:53 UTC (rev 836)
+++ trunk/usr/spc.c	2007-03-17 04:57:45 UTC (rev 837)
@@ -109,7 +109,7 @@
 				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
 
 				for (; tmp > 0; tmp--, q)
-					*(p--) = *q;
+					*(p--) = *(q--);
 			}
 		} else if (scb[2] == 0x83) {
 			int tmp = SCSI_ID_LEN;



From tomo at mail.berlios.de  Sat Mar 17 06:00:40 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 06:00:40 +0100
Subject: [Stgt-svn] r838 - trunk/usr
Message-ID: <200703170500.l2H50e9r014592@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 06:00:39 +0100 (Sat, 17 Mar 2007)
New Revision: 838

Modified:
   trunk/usr/target.c
Log:
Fix tgt_device_update bugs. tgtadm and management code need to be rewritten.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-17 04:57:45 UTC (rev 837)
+++ trunk/usr/target.c	2007-03-17 05:00:39 UTC (rev 838)
@@ -342,9 +342,9 @@
 		return TGTADM_NO_LUN;
 	}
 
-	if (!strcmp(name, "scsi_id="))
+	if (!strncmp(name, "scsi_id=", 8))
 		memcpy(device->scsi_id, name + 8, sizeof(device->scsi_id) - 1);
-	else if (!strcmp(name, "scsi_sn="))
+	else if (!strncmp(name, "scsi_sn=", 8))
 		memcpy(device->scsi_sn, name + 8, sizeof(device->scsi_sn) - 1);
 	else
 		err = TGTADM_INVALID_REQUEST;



From tomo at mail.berlios.de  Sat Mar 17 13:16:56 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 13:16:56 +0100
Subject: [Stgt-svn] r839 - trunk/usr
Message-ID: <200703171216.l2HCGuEp008308@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 13:16:55 +0100 (Sat, 17 Mar 2007)
New Revision: 839

Removed:
   trunk/usr/osd.h
Modified:
   trunk/usr/osd.c
Log:
remove obsolete service action codes and let bd_submit do what it wants

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-17 05:00:39 UTC (rev 838)
+++ trunk/usr/osd.c	2007-03-17 12:16:55 UTC (rev 839)
@@ -1,8 +1,7 @@
 /*
  * SCSI object storage device command processing
  *
- * Copyright (C) 2006 Pete Wyckoff <pw at osc.edu>
- *
+ * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
  * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
  * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
  *
@@ -21,7 +20,6 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "osd.h"
 
 #define PRODUCT_ID	"OSD"
 #define PRODUCT_REV	"0"
@@ -119,61 +117,18 @@
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
-	int ret = SAM_STAT_GOOD;
-	uint16_t action;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
 		eprintf("request size %d wrong, should be 200\n",
 			cmd->scb[7] + 8);
-		goto sense;
+		sense_data_build(cmd, key, asc, 0);
+		cmd->len = 0;
+		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	action = (cmd->scb[8] << 8) | cmd->scb[9];
-
-	switch (action) {
-	case OSD_APPEND:
-	case OSD_CREATE:
-	case OSD_CREATE_AND_WRITE:
-	case OSD_CREATE_COLLECTION:
-	case OSD_CREATE_PARTITION:
-	case OSD_FLUSH:
-	case OSD_FLUSH_COLLECTION:
-	case OSD_FLUSH_OSD:
-	case OSD_FLUSH_PARTITION:
-	case OSD_FORMAT_OSD:
-	case OSD_GET_ATTRIBUTES:
-	case OSD_GET_MEMBER_ATTRIBUTES:
-	case OSD_LIST:
-	case OSD_LIST_COLLECTION:
-	case OSD_PERFORM_SCSI_COMMAND:
-	case OSD_PERFORM_TASK_MGMT_FUNC:
-	case OSD_QUERY:
-	case OSD_READ:
-	case OSD_REMOVE:
-	case OSD_REMOVE_COLLECTION:
-	case OSD_REMOVE_MEMBER_OBJECTS:
-	case OSD_REMOVE_PARTITION:
-	case OSD_SET_ATTRIBUTES:
-	case OSD_SET_KEY:
-	case OSD_SET_MASTER_KEY:
-	case OSD_SET_MEMBER_ATTRIBUTES:
-	case OSD_WRITE:
-		ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
-		if (ret)
-			goto sense;
-		break;
-	default:
-		eprintf("unknown service action 0x%04x\n", action);
-		goto sense;
-	}
-
-	return SAM_STAT_GOOD;
-sense:
-	sense_data_build(cmd, key, asc, 0);
-	cmd->len = 0;
-	return SAM_STAT_CHECK_CONDITION;
+	return cmd->c_target->bdt->bd_cmd_submit(cmd);
 }
 
 static void device_osd_init(struct tgt_device *dev)

Deleted: trunk/usr/osd.h
===================================================================
--- trunk/usr/osd.h	2007-03-17 05:00:39 UTC (rev 838)
+++ trunk/usr/osd.h	2007-03-17 12:16:55 UTC (rev 839)
@@ -1,33 +0,0 @@
-#ifndef __OSD_H
-#define __OSD_H
-
-/* varlen cdb service actions for OSD-2 (before SNIA changes 17 jan 07) */
-#define OSD_APPEND			0x8807
-#define OSD_CREATE			0x8802
-#define OSD_CREATE_AND_WRITE		0x8812
-#define OSD_CREATE_COLLECTION		0x8815
-#define OSD_CREATE_PARTITION		0x880b
-#define OSD_FLUSH			0x8808
-#define OSD_FLUSH_COLLECTION		0x881a
-#define OSD_FLUSH_OSD			0x881c
-#define OSD_FLUSH_PARTITION		0x881b
-#define OSD_FORMAT_OSD			0x8801
-#define OSD_GET_ATTRIBUTES		0x880e
-#define OSD_GET_MEMBER_ATTRIBUTES	0x8822
-#define OSD_LIST			0x8803
-#define OSD_LIST_COLLECTION		0x8817
-#define OSD_PERFORM_SCSI_COMMAND	0x8f7e
-#define OSD_PERFORM_TASK_MGMT_FUNC	0x8f7f
-#define OSD_QUERY			0x8820
-#define OSD_READ			0x8805
-#define OSD_REMOVE			0x880a
-#define OSD_REMOVE_COLLECTION		0x8816
-#define OSD_REMOVE_MEMBER_OBJECTS	0x8821
-#define OSD_REMOVE_PARTITION		0x880c
-#define OSD_SET_ATTRIBUTES		0x880f
-#define OSD_SET_KEY			0x8818
-#define OSD_SET_MASTER_KEY		0x8819
-#define OSD_SET_MEMBER_ATTRIBUTES	0x8823
-#define OSD_WRITE			0x8806
-
-#endif



From tomo at mail.berlios.de  Sat Mar 17 13:32:32 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 13:32:32 +0100
Subject: [Stgt-svn] r840 - trunk/usr
Message-ID: <200703171232.l2HCWWoq023721@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 13:32:32 +0100 (Sat, 17 Mar 2007)
New Revision: 840

Modified:
   trunk/usr/driver.h
Log:
no need to export sg_bdt twice


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-17 12:16:55 UTC (rev 839)
+++ trunk/usr/driver.h	2007-03-17 12:32:32 UTC (rev 840)
@@ -1,4 +1,4 @@
-extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt, xen_bdt, sg_bdt;
+extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt, xen_bdt;
 
 struct tgt_driver {
 	const char *name;



From tomo at mail.berlios.de  Sat Mar 17 15:16:09 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 17 Mar 2007 15:16:09 +0100
Subject: [Stgt-svn] r841 - trunk/usr/iscsi
Message-ID: <200703171416.l2HEG9NO029836@sheep.berlios.de>

Author: tomo
Date: 2007-03-17 15:16:09 +0100 (Sat, 17 Mar 2007)
New Revision: 841

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
iSCSI bidirectional support

Make iSCSI bidirectional transfers work.

Signed-off-by: Pete Wyckoff <pw at osc.edu>


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-17 12:32:32 UTC (rev 840)
+++ trunk/usr/iscsi/iscsid.c	2007-03-17 14:16:09 UTC (rev 841)
@@ -743,6 +743,7 @@
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+	uint32_t residual;
 
 	dprintf("%p %x\n", task, task->scmd.scb[0]);
 
@@ -756,6 +757,31 @@
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
+	/* we never have write under/over flow, no way to signal that
+	 * back from the target currently. */
+
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
+
 	return 0;
 }
 
@@ -770,6 +796,7 @@
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 	struct iscsi_sense_data *sense;
 	unsigned char sense_len;
+ 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -777,7 +804,33 @@
 	rsp->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
+	/* XXX: copied from above, consider merging these functions */
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
+
 	sense = (struct iscsi_sense_data *)task->scmd.sense_buffer;
 	sense_len = task->scmd.sense_len;
 
@@ -795,19 +848,17 @@
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	int residual, datalen, exp_datalen = ntohl(req->data_length);
+	int datalen, exp_datalen = task->read_len;
 	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+ 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
 	rsp->itt = task->tag;
 	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
 
 	rsp->offset = cpu_to_be32(task->offset);
-	rsp->datasn = cpu_to_be32(task->data_sn++);
-	rsp->cmd_status = task->result;
+	rsp->datasn = cpu_to_be32(task->exp_r2tsn++);
 
 	datalen = min(exp_datalen, task->len);
 	datalen -= task->offset;
@@ -815,21 +866,26 @@
 	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, task->len, max_burst, rsp->itt);
 
 	if (datalen <= max_burst) {
-		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-		if (task->len < exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - task->len;
-		} else if (task->len > exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = task->len - exp_datalen;
-		} else
-			residual = 0;
-		rsp->residual_count = cpu_to_be32(residual);
+		rsp->flags = ISCSI_FLAG_CMD_FINAL;
+
+		/* collapse status into final packet if successful */
+		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
+			if (task->len < exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				residual = exp_datalen - task->len;
+			} else if (task->len > exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				residual = task->len - exp_datalen;
+			} else
+				residual = 0;
+			rsp->cmd_status = task->result;
+			rsp->statsn = cpu_to_be32(conn->stat_sn++);
+			rsp->residual_count = cpu_to_be32(residual);
+		}
 	} else
 		datalen = max_burst;
 
-	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
-		rsp->statsn = cpu_to_be32(conn->stat_sn++);
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
@@ -933,6 +989,12 @@
 	task->len = scmd->len;
 	task->rw = scmd->rw;
 
+	if (task->len > task->read_len) {
+		dprintf("shrinking target len %d to initiator len %d\n",
+		        task->len, task->read_len);
+		task->len = task->read_len;
+	}
+
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
 	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
@@ -965,19 +1027,29 @@
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	unsigned long uaddr = (unsigned long) task->data;
+	uint32_t data_len;
+	uint8_t *ahs;
+	int ahslen;
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
 
 	scmd->scb = req->cdb;
 	scmd->scb_len = sizeof(req->cdb);
 
-	if (task->ahs) {
-		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
+	ahs = task->ahs;
+	ahslen = req->hlength * 4;
+	if (ahslen >= 4) {
+		struct iscsi_ecdb_ahdr *ahs_extcdb = (void *) ahs;
 
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
 			char *p = (void *)task->extdata;
 
+			if (4 + extcdb_len > ahslen) {
+				eprintf("AHS len %d too short for extcdb %d\n",
+					ahslen, extcdb_len);
+				return -EINVAL;
+			}
 			if (extcdb_len + sizeof(req->cdb) > 260) {
 				eprintf("invalid extcdb len %d\n", extcdb_len);
 
@@ -990,9 +1062,32 @@
 
 			scmd->scb = p;
 			scmd->scb_len = sizeof(req->cdb) + extcdb_len;
+
+			ahs += 4 + extcdb_len;
+			ahslen -= 4 + extcdb_len;
 		}
 	}
 
+	/* figure out incoming (write) and outgoing (read) sizes */
+	data_len = 0;
+	task->write_len = 0;
+	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
+		task->write_len = ntohl(req->data_length);
+		data_len = task->write_len;
+	}
+	task->read_len = 0;
+	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
+		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
+		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
+			task->read_len = ntohl(ahs_bidi->read_length);
+			dprintf("bidi read len %u\n", task->read_len);
+		}
+	}
+	if (task->dir == READ) {
+		task->read_len = ntohl(req->data_length);
+		data_len = task->read_len;
+	}
+
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
 	scmd->len = ntohl(req->data_length);
@@ -1016,6 +1111,7 @@
 		goto no_queuing;
 	}
 
+	task->offset = 0;  /* for use as transmit pointer for data-ins */
 	err = iscsi_target_cmd_queue(task);
 no_queuing:
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
@@ -1105,6 +1201,17 @@
 		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
+		/* convenient directionality for our internal use */
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+			if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
+				task->dir = BIDIRECTIONAL;
+			else
+				task->dir = READ;
+		} else if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+			task->dir = WRITE;
+		} else
+			task->dir = NONE;
+
 		err = iscsi_scsi_cmd_execute(task);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -1393,28 +1500,16 @@
 static int iscsi_scsi_cmd_tx_start(struct iscsi_task *task)
 {
 	int err = 0;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 
 	if (task->r2t_count)
 		err = iscsi_r2t_build(task);
-	else {
-		/* Needs to clean up this mess. */
+	else if (task->offset < task->len)
+		err = iscsi_data_rsp_build(task);
+	else if (task->result)
+		err = iscsi_sense_rsp_build(task);
+	else
+		err = iscsi_cmd_rsp_build(task);
 
-		if (req->flags & ISCSI_FLAG_CMD_WRITE)
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		else {
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else if (task->len)
-				err = iscsi_data_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		}
-	}
-
 	return err;
 }
 
@@ -1490,8 +1585,9 @@
 	case ISCSI_OP_R2T:
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
-			dprintf("more data %x\n", hdr->itt);
+		if (task->offset < task->len || task->result != 0
+		   || task->dir == BIDIRECTIONAL) {
+			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
 		}

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-17 12:32:32 UTC (rev 840)
+++ trunk/usr/iscsi/iscsid.h	2007-03-17 14:16:09 UTC (rev 841)
@@ -99,6 +99,9 @@
 	struct list_head c_list;
 
 	unsigned long flags;
+	enum { NONE, WRITE, READ, BIDIRECTIONAL } dir;
+	uint32_t write_len;  /* from command pdu, write and read lengths */
+	uint32_t read_len;
 
 	uint64_t addr;
 	int result;
@@ -106,7 +109,6 @@
 	int rw;
 
 	int offset;
-	int data_sn;
 
 	int r2t_count;
 	int unsol_count;



From tomo at mail.berlios.de  Sun Mar 18 02:02:24 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 02:02:24 +0100
Subject: [Stgt-svn] r842 - in trunk/usr: . ibmvio iscsi xen
Message-ID: <200703180102.l2I12OHY024055@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 02:02:22 +0100 (Sun, 18 Mar 2007)
New Revision: 842

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/bd_xen.c
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/mmc.c
   trunk/usr/osd.c
   trunk/usr/sbc.c
   trunk/usr/spt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
   trunk/usr/xen/xen.h
Log:
backendio_template is renamed backingstore_template mainly because
it's doing more than I/Os.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/bd_aio.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -47,7 +47,7 @@
 /* FIXME */
 #define MAX_AIO_REQS 2048
 
-struct bd_aio_info {
+struct bs_aio_info {
 	io_context_t ctx;
 
 	/* TODO: batch requests */
@@ -62,7 +62,7 @@
 
 static void *bs_aio_endio_thread(void *arg)
 {
-	struct bd_aio_info *info = arg;
+	struct bs_aio_info *info = arg;
 	int command, ret, nr;
 
 retry:
@@ -96,7 +96,7 @@
 
 static void bs_aio_handler(int fd, int events, void *data)
 {
-	struct bd_aio_info *info = data;
+	struct bs_aio_info *info = data;
 	int i, nr_events, ret;
 
 	ret = read(info->done_fd[0], &nr_events, sizeof(nr_events));
@@ -115,11 +115,11 @@
 }
 
 static int
-bd_aio_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+bs_aio_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
 {
 	int ret;
-	struct bd_aio_info *info =
-		(struct bd_aio_info *) ((char *)dev + sizeof(*dev));
+	struct bs_aio_info *info =
+		(struct bs_aio_info *) ((char *)dev + sizeof(*dev));
 
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
 	if (*fd < 0)
@@ -166,11 +166,11 @@
 	return -1;
 }
 
-static void bd_aio_close(struct tgt_device *dev)
+static void bs_aio_close(struct tgt_device *dev)
 {
-	struct bd_aio_info *info;
+	struct bs_aio_info *info;
 
-	info = (struct bd_aio_info *) ((char *)dev + sizeof(*dev));
+	info = (struct bs_aio_info *) ((char *)dev + sizeof(*dev));
 
 	pthread_cancel(info->aio_thread);
 	pthread_join(info->aio_thread, NULL);
@@ -178,10 +178,10 @@
 	close(dev->fd);
 }
 
-static int bd_aio_cmd_submit(struct scsi_cmd *cmd)
+static int bs_aio_cmd_submit(struct scsi_cmd *cmd)
 {
 	struct tgt_device *dev = cmd->dev;
-	struct bd_aio_info *info = (struct bd_aio_info *)((char *)dev + sizeof(*dev));
+	struct bs_aio_info *info = (struct bs_aio_info *)((char *)dev + sizeof(*dev));
 	struct iocb iocb, *io;
 	int ret;
 
@@ -211,15 +211,15 @@
 	}
 }
 
-static int bd_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+static int bs_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	return 0;
 }
 
-struct backedio_template aio_bdt = {
-	.bd_datasize		= sizeof(struct bd_aio_info),
-	.bd_open		= bd_aio_open,
-	.bd_close		= bd_aio_close,
-	.bd_cmd_submit		= bd_aio_cmd_submit,
-	.bd_cmd_done		= bd_aio_cmd_done,
+struct backingstore_template aio_bst = {
+	.bs_datasize		= sizeof(struct bs_aio_info),
+	.bs_open		= bs_aio_open,
+	.bs_close		= bs_aio_close,
+	.bs_cmd_submit		= bs_aio_cmd_submit,
+	.bs_cmd_done		= bs_aio_cmd_done,
 };

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/bd_mmap.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -32,21 +32,21 @@
 #include "util.h"
 #include "tgtd.h"
 
-static int bd_mmap_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+static int bs_mmap_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
 {
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
 
 	return *fd >= 0 ? 0 : *fd;
 }
 
-static void bd_mmap_close(struct tgt_device *dev)
+static void bs_mmap_close(struct tgt_device *dev)
 {
 	close(dev->fd);
 }
 
 #define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
 
-static int bd_mmap_cmd_submit(struct scsi_cmd *cmd)
+static int bs_mmap_cmd_submit(struct scsi_cmd *cmd)
 {
 	int fd = cmd->dev->fd;
 	void *p;
@@ -72,7 +72,7 @@
 	return err;
 }
 
-static int bd_mmap_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+static int bs_mmap_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 
@@ -90,9 +90,9 @@
 	return err;
 }
 
-struct backedio_template mmap_bdt = {
-	.bd_open		= bd_mmap_open,
-	.bd_close		= bd_mmap_close,
-	.bd_cmd_submit		= bd_mmap_cmd_submit,
-	.bd_cmd_done		= bd_mmap_cmd_done,
+struct backingstore_template mmap_bst = {
+	.bs_open		= bs_mmap_open,
+	.bs_close		= bs_mmap_close,
+	.bs_cmd_submit		= bs_mmap_cmd_submit,
+	.bs_cmd_done		= bs_mmap_cmd_done,
 };

Modified: trunk/usr/bd_xen.c
===================================================================
--- trunk/usr/bd_xen.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/bd_xen.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -37,14 +37,14 @@
 
 #define O_DIRECT 040000 /* who defines this?*/
 
-static int bd_xen_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
+static int bs_xen_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
 {
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE | O_DIRECT, size);
 
 	return *fd >= 0 ? 0 : *fd;
 }
 
-static void bd_xen_close(struct tgt_device *dev)
+static void bs_xen_close(struct tgt_device *dev)
 {
 	close(dev->fd);
 }
@@ -52,7 +52,7 @@
 /*
  * Replace this with AIO readv/writev after 2.6.20.
  */
-static int bd_xen_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
+static int bs_xen_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
 			     uint32_t datalen, unsigned long *uaddr,
 			     uint64_t offset, int *async, void *key)
 {
@@ -75,14 +75,14 @@
 	return 0;
 }
 
-static int bd_xen_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+static int bs_xen_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	return 0;
 }
 
-struct backedio_template xen_bdt = {
-	.bd_open		= bd_xen_open,
-	.bd_close		= bd_xen_close,
-	.bd_cmd_submit		= bd_xen_cmd_submit,
-	.bd_cmd_done		= bd_xen_cmd_done,
+struct backingstore_template xen_bst = {
+	.bs_open		= bs_xen_open,
+	.bs_close		= bs_xen_close,
+	.bs_cmd_submit		= bs_xen_cmd_submit,
+	.bs_cmd_done		= bs_xen_cmd_done,
 };

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/driver.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -1,4 +1,4 @@
-extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt, xen_bdt;
+extern struct backingstore_template mmap_bst, aio_bst, sg_bst, xen_bst;
 
 struct tgt_driver {
 	const char *name;
@@ -17,7 +17,7 @@
 	int (*cmd_end_notify)(uint64_t nid, int result, struct scsi_cmd *);
 	int (*mgmt_end_notify)(uint64_t nid, uint64_t mid, int result);
 
-	struct backedio_template *default_bdt;
+	struct backingstore_template *default_bst;
 };
 
 extern struct tgt_driver *tgt_drivers[];

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/ibmvio/ibmvio.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -9,5 +9,5 @@
 	.target_create		= ibmvio_target_create,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
-	.default_bdt		= &mmap_bdt,
+	.default_bst		= &mmap_bst,
 };

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/iscsi/iscsi.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -19,5 +19,5 @@
 	.show			= iscsi_target_show,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
-	.default_bdt		= &aio_bdt,
+	.default_bst		= &aio_bst,
 };

Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/mmc.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -32,7 +32,7 @@
 	int ret;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
+	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;

Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/osd.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -128,7 +128,7 @@
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	return cmd->c_target->bdt->bd_cmd_submit(cmd);
+	return cmd->c_target->bst->bs_cmd_submit(cmd);
 }
 
 static void device_osd_init(struct tgt_device *dev)

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/sbc.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -53,7 +53,7 @@
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
+	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;

Modified: trunk/usr/spt.c
===================================================================
--- trunk/usr/spt.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/spt.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -55,10 +55,10 @@
 	return 0;
 }
 
-struct backedio_template sg_bdt = {
-	.bd_open		= spt_sg_open,
-	.bd_close		= spt_sg_close,
-	.bd_cmd_done		= spt_sg_cmd_done,
+struct backingstore_template sg_bst = {
+	.bs_open		= spt_sg_open,
+	.bs_close		= spt_sg_close,
+	.bs_cmd_done		= spt_sg_cmd_done,
 };
 
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/target.c	2007-03-18 01:02:22 UTC (rev 842)
@@ -166,7 +166,7 @@
 	if (!path)
 		return TGTADM_NOMEM;
 
-	err = target->bdt->bd_open(device, path, &dev_fd, &size);
+	err = target->bst->bs_open(device, path, &dev_fd, &size);
 	if (err) {
 		free(path);
 		return TGTADM_INVALID_REQUEST;
@@ -225,7 +225,7 @@
 		return TGTADM_INVALID_REQUEST;
 	p++;
 
-	device = zalloc(sizeof(*device) + target->bdt->bd_datasize);
+	device = zalloc(sizeof(*device) + target->bst->bs_datasize);
 	if (!device)
 		return TGTADM_NOMEM;
 
@@ -274,7 +274,7 @@
 	free(device->path);
 	list_del(&device->device_siblings);
 
-	target->bdt->bd_close(device);
+	target->bst->bs_close(device);
 	free(device);
 	return 0;
 }
@@ -503,7 +503,7 @@
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = target->bdt->bd_cmd_done(do_munmap,
+	err = target->bst->bs_cmd_done(do_munmap,
 				       !cmd->mmapped,
 				       cmd->uaddr, cmd->len);
 
@@ -1208,9 +1208,9 @@
 
 	/* FIXME */
 	if (t_type == TYPE_SPT)
-		target->bdt = &sg_bdt;
+		target->bst = &sg_bst;
 	else
-		target->bdt = tgt_drivers[lld]->default_bdt;
+		target->bst = tgt_drivers[lld]->default_bst;
 
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/target.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -44,7 +44,7 @@
 
 	struct tgt_cmd_queue cmd_queue;
 
-	struct backedio_template *bdt;
+	struct backingstore_template *bst;
 
 	struct list_head acl_list;
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/tgtd.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -78,12 +78,12 @@
 	int sense_len;
 };
 
-struct backedio_template {
-	int bd_datasize;
-	int (*bd_open)(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
-	void (*bd_close)(struct tgt_device *dev);
-	int (*bd_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+struct backingstore_template {
+	int bs_datasize;
+	int (*bs_open)(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
+	void (*bs_close)(struct tgt_device *dev);
+	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
+	int (*bs_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 };
 
 #ifdef USE_KERNEL

Modified: trunk/usr/xen/xen.h
===================================================================
--- trunk/usr/xen/xen.h	2007-03-17 14:16:09 UTC (rev 841)
+++ trunk/usr/xen/xen.h	2007-03-18 01:02:22 UTC (rev 842)
@@ -9,7 +9,7 @@
 	.init			= xen_init,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
-	.default_bdt		= &xen_bdt,
+	.default_bst		= &xen_bst,
 };
 
 #endif



From tomo at mail.berlios.de  Sun Mar 18 02:22:27 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 02:22:27 +0100
Subject: [Stgt-svn] r843 - in trunk/usr: . ibmvio iscsi xen
Message-ID: <200703180122.l2I1MRc2026701@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 02:22:24 +0100 (Sun, 18 Mar 2007)
New Revision: 843

Removed:
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/xen/xen.h
Modified:
   trunk/usr/driver.c
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/xen/xen.c
Log:
Clean up driver.h stuff (though needs more cleanups)


Modified: trunk/usr/driver.c
===================================================================
--- trunk/usr/driver.c	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/driver.c	2007-03-18 01:22:24 UTC (rev 843)
@@ -6,18 +6,8 @@
 #include "tgtd.h"
 #include "driver.h"
 
-#ifdef IBMVIO
-#include "ibmvio/ibmvio.h"
-#endif
+extern struct tgt_driver ibmvio, iscsi, xen;
 
-#ifdef ISCSI
-#include "iscsi/iscsi.h"
-#endif
-
-#ifdef XEN
-#include "xen/xen.h"
-#endif
-
 struct tgt_driver *tgt_drivers[] = {
 #ifdef IBMVIO
 	&ibmvio,

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-18 01:22:24 UTC (rev 843)
@@ -42,6 +42,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "driver.h"
 #include "spc.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
@@ -243,7 +244,7 @@
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
 
-uint64_t scsi_lun_to_int(uint8_t *p)
+static uint64_t scsi_lun_to_int(uint8_t *p)
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
@@ -256,7 +257,7 @@
 		return GETTARGET(lun);
 }
 
-int ibmvio_target_create(struct target *target)
+static int ibmvio_target_create(struct target *target)
 {
 	unsigned char device_type = target->dev_type_template.type;
 	struct device_type_operations *ops = target->dev_type_template.ops;
@@ -268,3 +269,13 @@
 
 	return 0;
 }
+
+struct tgt_driver ibmvio = {
+	.name			= "ibmvio",
+	.use_kernel		= 1,
+	.scsi_get_lun		= scsi_lun_to_int,
+	.target_create		= ibmvio_target_create,
+	.cmd_end_notify		= kspace_send_cmd_res,
+	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
+	.default_bst		= &mmap_bst,
+};

Deleted: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/ibmvio/ibmvio.h	2007-03-18 01:22:24 UTC (rev 843)
@@ -1,13 +0,0 @@
-extern int ibmvio_target_create(struct target *);
-
-extern uint64_t scsi_lun_to_int(uint8_t *p);
-
-struct tgt_driver ibmvio = {
-	.name			= "ibmvio",
-	.use_kernel		= 1,
-	.scsi_get_lun		= scsi_lun_to_int,
-	.target_create		= ibmvio_target_create,
-	.cmd_end_notify		= kspace_send_cmd_res,
-	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
-	.default_bst		= &mmap_bst,
-};

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/iscsi/iscsi.h	2007-03-18 01:22:24 UTC (rev 843)
@@ -9,15 +9,3 @@
 extern int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *cmd);
 extern int iscsi_tm_done(uint64_t nid, uint64_t mid, int result);
 
-struct tgt_driver iscsi = {
-	.name			= "iscsi",
-	.use_kernel		= 0,
-	.init			= iscsi_init,
-	.target_create		= iscsi_target_create,
-	.target_destroy		= iscsi_target_destroy,
-	.target_update		= iscsi_target_update,
-	.show			= iscsi_target_show,
-	.cmd_end_notify		= iscsi_scsi_cmd_done,
-	.mgmt_end_notify	= iscsi_tm_done,
-	.default_bst		= &aio_bst,
-};

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/iscsi/iscsid.c	2007-03-18 01:22:24 UTC (rev 843)
@@ -23,6 +23,8 @@
 #include "iscsid.h"
 #include "tgtd.h"
 #include "util.h"
+#include "driver.h"
+#include "iscsi.h"
 
 #define MAX_QUEUE_CMD	32
 
@@ -1843,3 +1845,16 @@
 	if (conn->state == STATE_CLOSE)
 		conn_close(conn, fd);
 }
+
+struct tgt_driver iscsi = {
+	.name			= "iscsi",
+	.use_kernel		= 0,
+	.init			= iscsi_init,
+	.target_create		= iscsi_target_create,
+	.target_destroy		= iscsi_target_destroy,
+	.target_update		= iscsi_target_update,
+	.show			= iscsi_target_show,
+	.cmd_end_notify		= iscsi_scsi_cmd_done,
+	.mgmt_end_notify	= iscsi_tm_done,
+	.default_bst		= &aio_bst,
+};

Modified: trunk/usr/xen/xen.c
===================================================================
--- trunk/usr/xen/xen.c	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/xen/xen.c	2007-03-18 01:22:24 UTC (rev 843)
@@ -5,6 +5,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "driver.h"
 #include "xs_api.h"
 
 /* xenstore/xenbus: */
@@ -17,7 +18,7 @@
 	xs_fire_next_watch((struct xs_handle *) data);
 }
 
-int xen_init(int index)
+static int xen_init(int index)
 {
 	int err;
 	struct xs_handle *xsh;
@@ -41,3 +42,12 @@
 open_failed:
 	return -1;
 }
+
+struct tgt_driver xen = {
+	.name			= "xen",
+	.use_kernel		= 1,
+	.init			= xen_init,
+	.cmd_end_notify		= kspace_send_cmd_res,
+	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
+	.default_bst		= &xen_bst,
+};

Deleted: trunk/usr/xen/xen.h
===================================================================
--- trunk/usr/xen/xen.h	2007-03-18 01:02:22 UTC (rev 842)
+++ trunk/usr/xen/xen.h	2007-03-18 01:22:24 UTC (rev 843)
@@ -1,15 +0,0 @@
-#ifndef __TGTXEN_H__
-#define __TGTXEN_H__
-
-extern int xen_init(void);
-
-struct tgt_driver xen = {
-	.name			= "xen",
-	.use_kernel		= 1,
-	.init			= xen_init,
-	.cmd_end_notify		= kspace_send_cmd_res,
-	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
-	.default_bst		= &xen_bst,
-};
-
-#endif



From tomo at mail.berlios.de  Sun Mar 18 02:29:47 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 02:29:47 +0100
Subject: [Stgt-svn] r844 - trunk/usr/iscsi
Message-ID: <200703180129.l2I1TlW2027112@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 02:29:44 +0100 (Sun, 18 Mar 2007)
New Revision: 844

Removed:
   trunk/usr/iscsi/iscsi.h
Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
remove iscsi.h


Deleted: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2007-03-18 01:22:24 UTC (rev 843)
+++ trunk/usr/iscsi/iscsi.h	2007-03-18 01:29:44 UTC (rev 844)
@@ -1,11 +0,0 @@
-extern int iscsi_init(int);
-extern int iscsi_target_create(struct target *);
-extern int iscsi_target_destroy(int);
-extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
-			     uint64_t lun, char *buf, int rest);
-extern int iscsi_target_update(int, char *);
-extern int iscsi_mgmt_account(uint32_t op, int tid, uint32_t uid, char *param,
-			      char *buf, int len);
-extern int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *cmd);
-extern int iscsi_tm_done(uint64_t nid, uint64_t mid, int result);
-

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-18 01:22:24 UTC (rev 843)
+++ trunk/usr/iscsi/iscsid.c	2007-03-18 01:29:44 UTC (rev 844)
@@ -24,7 +24,6 @@
 #include "tgtd.h"
 #include "util.h"
 #include "driver.h"
-#include "iscsi.h"
 
 #define MAX_QUEUE_CMD	32
 
@@ -971,7 +970,7 @@
 	iscsi_free_task(task);
 }
 
-int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
+static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 {
 	struct iscsi_task *task = ITASK(scmd);
 
@@ -1121,7 +1120,7 @@
 	return err;
 }
 
-extern int iscsi_tm_done(uint64_t nid, uint64_t mid, int result)
+static int iscsi_tm_done(uint64_t nid, uint64_t mid, int result)
 {
 	struct iscsi_task *task = (struct iscsi_task *) (unsigned long) mid;
 

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2007-03-18 01:22:24 UTC (rev 843)
+++ trunk/usr/iscsi/iscsid.h	2007-03-18 01:29:44 UTC (rev 844)
@@ -273,10 +273,18 @@
 struct iscsi_target * target_find_by_id(int tid);
 extern void target_list_build(struct iscsi_connection *, char *, char *);
 extern int ip_acl(int tid, int fd);
+extern int iscsi_target_create(struct target *);
+extern int iscsi_target_destroy(int);
+extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
+			     uint64_t lun, char *buf, int rest);
+extern int iscsi_target_update(int, char *);
 
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 
+/* transport.c */
+extern int iscsi_init(int);
+
 #define buffer_check(buf, total, len, rest)	\
 ({						\
 	buf += len;				\



From tomo at mail.berlios.de  Sun Mar 18 02:35:08 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 02:35:08 +0100
Subject: [Stgt-svn] r845 - trunk/usr
Message-ID: <200703180135.l2I1Z8Ap027459@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 02:35:08 +0100 (Sun, 18 Mar 2007)
New Revision: 845

Added:
   trunk/usr/bs_aio.c
   trunk/usr/bs_mmap.c
   trunk/usr/bs_xen.c
Removed:
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/bd_xen.c
Modified:
   trunk/usr/Makefile
Log:
bd_* are renamed bs_*


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2007-03-18 01:29:44 UTC (rev 844)
+++ trunk/usr/Makefile	2007-03-18 01:35:08 UTC (rev 845)
@@ -14,7 +14,7 @@
 LIBS += -lxenctrl
 LIBS += -L$(XEN_XENSTORE) -lxenstore $(AIOLIBS)
 TGTD_OBJS += $(addprefix xen/, xen.o xs_api.o xenbus.o)
-TGTD_OBJS += tgtif.o bd_xen.o
+TGTD_OBJS += tgtif.o bs_xen.o
 else
 INCLUDES += -I../include -I$(KERNELSRC)/include
 LIBS += -laio
@@ -29,14 +29,14 @@
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
-TGTD_OBJS += bd_mmap.o tgtif.o
+TGTD_OBJS += bs_mmap.o tgtif.o
 endif
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
 	chap.o transport.o iscsi_tcp.o)
-TGTD_OBJS += bd_aio.o
+TGTD_OBJS += bs_aio.o
 LIBS += -lcrypto -lpthread
 endif
 

Deleted: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2007-03-18 01:29:44 UTC (rev 844)
+++ trunk/usr/bd_aio.c	2007-03-18 01:35:08 UTC (rev 845)
@@ -1,225 +0,0 @@
-/*
- * AIO file backed routine
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <libaio.h>
-#include <pthread.h>
-
-#include <linux/fs.h>
-#include <sys/epoll.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-
-/*
- * We need an interface to wait for both synchronous and asynchronous
- * descriptors (something like BSD's kqueue). But upstream kernels
- * don't provide it though some candidates are under development. So
- * we use a hacky trick with pthread (stolen from RedHat Xen blktap
- * code).
- */
-
-/* FIXME */
-#define MAX_AIO_REQS 2048
-
-struct bs_aio_info {
-	io_context_t ctx;
-
-	/* TODO: batch requests */
-/* 	struct iocb iocb[MAX_AIO_REQS]; */
-	struct io_event events[MAX_AIO_REQS];
-
-	pthread_t aio_thread;
-
-	int command_fd[2];
-	int done_fd[2];
-};
-
-static void *bs_aio_endio_thread(void *arg)
-{
-	struct bs_aio_info *info = arg;
-	int command, ret, nr;
-
-retry:
-	ret = read(info->command_fd[0], &command, sizeof(command));
-	if (ret < 0) {
-		eprintf("AIO pthread will be dead, %m\n");
-		if (errno == EAGAIN || errno == EINTR)
-			goto retry;
-
-		goto out;
-	}
-
-	ret = io_getevents(info->ctx, 1, MAX_AIO_REQS, info->events, NULL);
-	nr = ret;
-	dprintf("%d", ret);
-	if (nr > 0) {
-	rewrite:
-		ret = write(info->done_fd[1], &nr, sizeof(nr));
-		if (ret < 0) {
-			eprintf("can't notify tgtd, %m\n");
-		if (errno == EAGAIN || errno == EINTR)
-			goto rewrite;
-
-		goto out;
-		}
-	}
-	goto retry;
-out:
-	return NULL;
-}
-
-static void bs_aio_handler(int fd, int events, void *data)
-{
-	struct bs_aio_info *info = data;
-	int i, nr_events, ret;
-
-	ret = read(info->done_fd[0], &nr_events, sizeof(nr_events));
-	if (ret < 0) {
-		eprintf("wrong wakeup\n");
-		return;
-	}
-
-	/* FIXME: need to handle failure */
-	for (i = 0; i < nr_events; i++) {
-		struct io_event *ep = &info->events[i];
-		target_cmd_io_done(ep->data, 0);
-	}
-
-	write(info->command_fd[1], &nr_events, sizeof(nr_events));
-}
-
-static int
-bs_aio_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
-{
-	int ret;
-	struct bs_aio_info *info =
-		(struct bs_aio_info *) ((char *)dev + sizeof(*dev));
-
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
-	if (*fd < 0)
-		return *fd;
-
-	ret = io_queue_init(MAX_AIO_REQS, &info->ctx);
-	if (ret) {
-		eprintf("fail to create aio_queue, %m\n");
-		goto close_dev_fd;
-	}
-
-	ret = pipe(info->command_fd);
-	if (ret)
-		goto close_ctx;
-
-	ret = pipe(info->done_fd);
-	if (ret)
-		goto close_command_fd;
-
-	ret = tgt_event_add(info->done_fd[0], EPOLLIN, bs_aio_handler, info);
-	if (ret)
-		goto close_done_fd;
-
-	ret = pthread_create(&info->aio_thread, NULL, bs_aio_endio_thread,
-			     info);
-	if (ret)
-		goto event_del;
-
-	write(info->command_fd[1], &ret, sizeof(ret));
-
-	return 0;
-event_del:
-	tgt_event_del(info->done_fd[0]);
-close_done_fd:
-	close(info->done_fd[0]);
-	close(info->done_fd[1]);
-close_command_fd:
-	close(info->command_fd[0]);
-	close(info->command_fd[1]);
-close_ctx:
-	io_destroy(info->ctx);
-close_dev_fd:
-	close(*fd);
-	return -1;
-}
-
-static void bs_aio_close(struct tgt_device *dev)
-{
-	struct bs_aio_info *info;
-
-	info = (struct bs_aio_info *) ((char *)dev + sizeof(*dev));
-
-	pthread_cancel(info->aio_thread);
-	pthread_join(info->aio_thread, NULL);
-	io_destroy(info->ctx);
-	close(dev->fd);
-}
-
-static int bs_aio_cmd_submit(struct scsi_cmd *cmd)
-{
-	struct tgt_device *dev = cmd->dev;
-	struct bs_aio_info *info = (struct bs_aio_info *)((char *)dev + sizeof(*dev));
-	struct iocb iocb, *io;
-	int ret;
-
-	io = &iocb;
-	memset(io, 0, sizeof(*io));
-
-	dprintf("%d %d %u %"  PRIx64 " %" PRIx64 " %p\n", dev->fd, cmd->rw, cmd->len,
-		cmd->uaddr, cmd->offset, cmd);
-
-	if (cmd->rw == READ)
-		io_prep_pread(io, dev->fd, (void *)(unsigned long)cmd->uaddr,
-			      cmd->len,	cmd->offset);
-	else
-		io_prep_pwrite(io, dev->fd, (void *)(unsigned long)cmd->uaddr,
-			       cmd->len, cmd->offset);
-
-	io->data = cmd;
-	ret = io_submit(info->ctx, 1, &io);
-
-	if (ret == 1) {
-		cmd->async = 1;
-		return 0;
-	} else {
-		dprintf("%d %d %u %"  PRIx64 " %" PRIx64 " %p\n", dev->fd, cmd->rw, cmd->len,
-			cmd->uaddr, cmd->offset, cmd);
-		return 1;
-	}
-}
-
-static int bs_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	return 0;
-}
-
-struct backingstore_template aio_bst = {
-	.bs_datasize		= sizeof(struct bs_aio_info),
-	.bs_open		= bs_aio_open,
-	.bs_close		= bs_aio_close,
-	.bs_cmd_submit		= bs_aio_cmd_submit,
-	.bs_cmd_done		= bs_aio_cmd_done,
-};

Deleted: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2007-03-18 01:29:44 UTC (rev 844)
+++ trunk/usr/bd_mmap.c	2007-03-18 01:35:08 UTC (rev 845)
@@ -1,98 +0,0 @@
-/*
- * mmap file backed routine
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-
-static int bs_mmap_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
-{
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
-
-	return *fd >= 0 ? 0 : *fd;
-}
-
-static void bs_mmap_close(struct tgt_device *dev)
-{
-	close(dev->fd);
-}
-
-#define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
-
-static int bs_mmap_cmd_submit(struct scsi_cmd *cmd)
-{
-	int fd = cmd->dev->fd;
-	void *p;
-	int err = 0;
-
-	if (cmd->uaddr)
-		cmd->uaddr += cmd->offset;
-	else {
-		p = mmap64(NULL, pgcnt(cmd->len, cmd->offset) << pageshift,
-			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   cmd->offset & ~((1ULL << pageshift) - 1));
-
-		cmd->uaddr = (unsigned long) p + (cmd->offset & (pagesize - 1));
-		if (p == MAP_FAILED) {
-			err = -EINVAL;
-			eprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr,
-				cmd->len, cmd->offset);
-		}
-	}
-
-	dprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr, cmd->len, cmd->offset);
-
-	return err;
-}
-
-static int bs_mmap_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	int err = 0;
-
-	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
-
-	if (do_munmap) {
-		len = pgcnt(len, (uaddr & (pagesize - 1))) << pageshift;
-		uaddr &= ~(pagesize - 1);
-		err = munmap((void *) (unsigned long) uaddr, len);
-		if (err)
-			eprintf("%" PRIx64 " %d\n", uaddr, len);
-	} else if (do_free)
-		free((void *) (unsigned long) uaddr);
-
-	return err;
-}
-
-struct backingstore_template mmap_bst = {
-	.bs_open		= bs_mmap_open,
-	.bs_close		= bs_mmap_close,
-	.bs_cmd_submit		= bs_mmap_cmd_submit,
-	.bs_cmd_done		= bs_mmap_cmd_done,
-};

Deleted: trunk/usr/bd_xen.c
===================================================================
--- trunk/usr/bd_xen.c	2007-03-18 01:29:44 UTC (rev 844)
+++ trunk/usr/bd_xen.c	2007-03-18 01:35:08 UTC (rev 845)
@@ -1,88 +0,0 @@
-/*
- * Xen file backed routine
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <libaio.h>
-#include <linux/fs.h>
-#include <sys/epoll.h>
-#include <sys/uio.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-
-#define O_DIRECT 040000 /* who defines this?*/
-
-static int bs_xen_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
-{
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE | O_DIRECT, size);
-
-	return *fd >= 0 ? 0 : *fd;
-}
-
-static void bs_xen_close(struct tgt_device *dev)
-{
-	close(dev->fd);
-}
-
-/*
- * Replace this with AIO readv/writev after 2.6.20.
- */
-static int bs_xen_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
-			     uint32_t datalen, unsigned long *uaddr,
-			     uint64_t offset, int *async, void *key)
-{
-	struct iovec *iov = (struct iovec *) (void *) *uaddr;
-	int cnt;
-	long total;
-
-	cnt = total = 0;
-	do {
-		total += iov[cnt++].iov_len;
-	} while (total < datalen);
-
-	lseek64(dev->fd, offset, SEEK_SET);
-
-	if (rw == READ)
-		readv(dev->fd, iov, cnt);
-	else
-		writev(dev->fd, iov, cnt);
-
-	return 0;
-}
-
-static int bs_xen_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	return 0;
-}
-
-struct backingstore_template xen_bst = {
-	.bs_open		= bs_xen_open,
-	.bs_close		= bs_xen_close,
-	.bs_cmd_submit		= bs_xen_cmd_submit,
-	.bs_cmd_done		= bs_xen_cmd_done,
-};

Copied: trunk/usr/bs_aio.c (from rev 844, trunk/usr/bd_aio.c)

Copied: trunk/usr/bs_mmap.c (from rev 844, trunk/usr/bd_mmap.c)

Copied: trunk/usr/bs_xen.c (from rev 844, trunk/usr/bd_xen.c)



From tomo at mail.berlios.de  Sun Mar 18 05:10:25 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 05:10:25 +0100
Subject: [Stgt-svn] r846 - in trunk/usr: . ibmvio iscsi
Message-ID: <200703180410.l2I4APOF002141@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 05:10:23 +0100 (Sun, 18 Mar 2007)
New Revision: 846

Modified:
   trunk/usr/bs_aio.c
   trunk/usr/bs_mmap.c
   trunk/usr/bs_xen.c
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/param.c
   trunk/usr/iscsi/param.h
   trunk/usr/mgmt.c
   trunk/usr/mmc.c
   trunk/usr/sbc.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.c
   trunk/usr/tgtif.c
   trunk/usr/work.c
Log:
updated Copyright stuff


Modified: trunk/usr/bs_aio.c
===================================================================
--- trunk/usr/bs_aio.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/bs_aio.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * AIO file backed routine
  *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/bs_mmap.c
===================================================================
--- trunk/usr/bs_mmap.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/bs_mmap.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * mmap file backed routine
  *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/bs_xen.c
===================================================================
--- trunk/usr/bs_xen.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/bs_xen.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * Xen file backed routine
  *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/ibmvio/ibmvio.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,7 +1,7 @@
 /*
  * SCSI command processing specific to IBM Virtual SCSI target Driver
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
  *
  * Based on:
  *

Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/iscsi/iscsi_tcp.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * Software iSCSI target over TCP/IP Data-Path
  *
- * (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/iscsi/iscsid.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,9 +1,9 @@
 /*
  * Software iSCSI target protocol routines
  *
- * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
- * (C) 2007 Pete Wyckoff <pw at osc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2007 Pete Wyckoff <pw at osc.edu>
  *
  * This code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/

Modified: trunk/usr/iscsi/param.c
===================================================================
--- trunk/usr/iscsi/param.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/iscsi/param.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,5 +1,5 @@
 /*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
  *
  * This code is licenced under the GPL.
  */

Modified: trunk/usr/iscsi/param.h
===================================================================
--- trunk/usr/iscsi/param.h	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/iscsi/param.h	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,5 +1,5 @@
 /*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
  *
  * This code is licenced under the GPL.
  */

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/mgmt.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI target management functions
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/mmc.c
===================================================================
--- trunk/usr/mmc.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/mmc.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,10 +1,13 @@
 /*
  * SCSI multimedia command processing
  *
- * (C) 2007 FUJITA Tomonori <tomof at acm.org>
- * (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
  *
- * based on Ardis's iSCSI implementation.
+ * This code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
+ *   licensed under the terms of the GNU GPL v2.0,
  *
  * (C) 2005-2007 Ming Zhang <blackmagic02881 at gmail.com>
  * This code is licenced under the GPL.

Modified: trunk/usr/sbc.c
===================================================================
--- trunk/usr/sbc.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/sbc.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI block command processing
  *
- * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * SCSI target emulation code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/target.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI target daemon core functions
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/tgtadm.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI target daemon management interface
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/tgtd.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI target daemon
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/tgtif.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * SCSI kernel and user interface
  *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as

Modified: trunk/usr/work.c
===================================================================
--- trunk/usr/work.c	2007-03-18 01:35:08 UTC (rev 845)
+++ trunk/usr/work.c	2007-03-18 04:10:23 UTC (rev 846)
@@ -1,8 +1,8 @@
 /*
  * bogus scheduler
  *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as



From tomo at mail.berlios.de  Sun Mar 18 06:02:11 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 06:02:11 +0100
Subject: [Stgt-svn] r847 - trunk
Message-ID: <200703180502.l2I52B39003584@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 06:02:11 +0100 (Sun, 18 Mar 2007)
New Revision: 847

Modified:
   trunk/README
Log:
Add developer notes to README.


Modified: trunk/README
===================================================================
--- trunk/README	2007-03-18 04:10:23 UTC (rev 846)
+++ trunk/README	2007-03-18 05:02:11 UTC (rev 847)
@@ -35,3 +35,18 @@
 Now you can run tgt. Target drivers have their own ways for
 configuration. So find an appropriate documentation in the doc
 directory.
+
+
+Developer Notes
+-------------
+The central resource for tgt development is the mailing list
+(stgt-devel at lists.berlios.de).
+
+Before submitting patches, please read (in short, follow Linux kernel
+development rules):
+
+http://lxr.linux.no/source/Documentation/CodingStyle
+http://lxr.linux.no/source/Documentation/SubmittingPatches
+
+The commits to the subversion repository go to the stgt-svn mailing
+list (stgt-svn at lists.berlios.de).



From tomo at mail.berlios.de  Sun Mar 18 12:04:50 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 12:04:50 +0100
Subject: [Stgt-svn] r848 - trunk/usr
Message-ID: <200703181104.l2IB4oe4030678@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 12:04:48 +0100 (Sun, 18 Mar 2007)
New Revision: 848

Modified:
   trunk/usr/osd.c
Log:
Fix osd_inquiry

Can osd_inquiry be merged into spc_inquiry?


Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-18 05:02:11 UTC (rev 847)
+++ trunk/usr/osd.c	2007-03-18 11:04:48 UTC (rev 848)
@@ -107,6 +107,7 @@
 		goto sense;
 
 	cmd->len = min_t(int, len, scb[4]);
+	cmd->uaddr = (unsigned long) data;
 
 	return SAM_STAT_GOOD;
 sense:
@@ -128,6 +129,7 @@
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
+/* 	return SAM_STAT_GOOD; */
 	return cmd->c_target->bst->bs_cmd_submit(cmd);
 }
 



From tomo at mail.berlios.de  Sun Mar 18 12:09:13 2007
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 18 Mar 2007 12:09:13 +0100
Subject: [Stgt-svn] r849 - trunk/usr
Message-ID: <200703181109.l2IB9Dth031003@sheep.berlios.de>

Author: tomo
Date: 2007-03-18 12:09:13 +0100 (Sun, 18 Mar 2007)
New Revision: 849

Modified:
   trunk/usr/osd.c
Log:
add scp_report_luns to osd


Modified: trunk/usr/osd.c
===================================================================
--- trunk/usr/osd.c	2007-03-18 11:04:48 UTC (rev 848)
+++ trunk/usr/osd.c	2007-03-18 11:09:13 UTC (rev 849)
@@ -185,6 +185,27 @@
 		{spc_illegal_op,},
 		{osd_varlen_cdb,},
 
-		[0x80 ... 0xff] = {spc_illegal_op},
+		[0x80 ... 0x9f] = {spc_illegal_op},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };



