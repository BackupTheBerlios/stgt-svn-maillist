From tomo at berlios.de  Tue Aug 16 15:18:24 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 16 Aug 2005 15:18:24 +0200
Subject: [Stgt-svn] r5 - trunk/usr
Message-ID: <200508161318.j7GDIOTY023740@sheep.berlios.de>

Author: tomo
Date: 2005-08-16 15:18:24 +0200 (Tue, 16 Aug 2005)
New Revision: 5

Modified:
   trunk/usr/stgtd.c
Log:
Include inttypes.h for PRI* stuff.

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-16 00:33:51 UTC (rev 4)
+++ trunk/usr/stgtd.c	2005-08-16 13:18:24 UTC (rev 5)
@@ -8,6 +8,7 @@
  */
 
 #include <errno.h>
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -152,7 +153,7 @@
 	uint8_t *scb;
 
 	scb = recvbuf + sizeof(*ev);
-	eprintf("%llu %x\n", ev->u.msg_scsi_cmnd.cid, scb[0]);
+	eprintf("%" PRIu64 " %x\n", ev->u.msg_scsi_cmnd.cid, scb[0]);
 
 	if ((err = disk_execute_cmnd(scb, sendbuf)) < 0)
 		return err;



From tomo at berlios.de  Wed Aug 17 09:41:52 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 17 Aug 2005 09:41:52 +0200
Subject: [Stgt-svn] r6 - trunk/iscsi/kernel
Message-ID: <200508170741.j7H7fqpt009084@sheep.berlios.de>

Author: tomo
Date: 2005-08-17 09:41:44 +0200 (Wed, 17 Aug 2005)
New Revision: 6

Added:
   trunk/iscsi/kernel/iscsi_proto.h
Removed:
   trunk/iscsi/kernel/iscsi_hdr.h
Modified:
   trunk/iscsi/kernel/digest.c
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
Log:
Use open-iscsi iscsi_proto.h instead of Ardis iscsi_hdr.h (Thanks to Mike).

Modified: trunk/iscsi/kernel/digest.c
===================================================================
--- trunk/iscsi/kernel/digest.c	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/digest.c	2005-08-17 07:41:44 UTC (rev 6)
@@ -101,7 +101,7 @@
 		printk("\tcmnd: 0x%x, itt 0x%x, sn 0x%x\n",
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.sn));
+		       be32_to_cpu(cmnd->pdu.bhs.statsn));
 		cmnd->hdigest = ~cmnd->hdigest;
 		/* make things even worse by manipulating header fields */
 		cmnd->pdu.datasize += 8;
@@ -146,7 +146,7 @@
 		printk("\tcmnd 0x%x, itt 0x%x, sn 0x%x\n",
 		       cmnd_opcode(cmnd),
 		       be32_to_cpu(cmnd->pdu.bhs.itt),
-		       be32_to_cpu(cmnd->pdu.bhs.sn));
+		       be32_to_cpu(cmnd->pdu.bhs.statsn));
 		cmnd->ddigest = ~cmnd->ddigest;
 		num_errs++;
 		num_cmnds = 0;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi.c	2005-08-17 07:41:44 UTC (rev 6)
@@ -25,21 +25,21 @@
 
 static u32 cmnd_write_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr->flags & ISCSI_CMD_WRITE)
+	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
 		return be32_to_cpu(hdr->data_length);
 	return 0;
 }
 
 static u32 cmnd_read_size(struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_scsi_cmd_hdr *hdr = cmnd_hdr(cmnd);
+	struct iscsi_cmd *hdr = cmnd_hdr(cmnd);
 
-	if (hdr->flags & ISCSI_CMD_READ) {
-		if (!(hdr->flags & ISCSI_CMD_WRITE))
+	if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+		if (!(hdr->flags & ISCSI_FLAG_CMD_WRITE))
 			return be32_to_cpu(hdr->data_length);
-		if (hdr->flags & ISCSI_CMD_READ) {
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
 			struct iscsi_rlength_ahdr *ahdr =
 				(struct iscsi_rlength_ahdr *)cmnd->pdu.ahs;
 			if (ahdr && ahdr->ahstype == ISCSI_AHSTYPE_RLENGTH)
@@ -162,8 +162,8 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	struct iscsi_cmnd *data_cmnd;
 	struct scatterlist *sg = cmnd->stc->sg;
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
-	struct iscsi_data_in_hdr *rsp;
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
+	struct iscsi_data_rsp *rsp;
 	u32 pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
@@ -181,24 +181,25 @@
 	while (1) {
 		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
 		data_cmnd->sg = sg;
-		rsp = (struct iscsi_data_in_hdr *)&data_cmnd->pdu.bhs;
+		rsp = (struct iscsi_data_rsp *)&data_cmnd->pdu.bhs;
 
 		rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
 		rsp->itt = req->itt;
 		rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-		rsp->buffer_offset = offset;
-		rsp->data_sn = cpu_to_be32(sn);
+		rsp->offset = offset;
+		rsp->datasn = cpu_to_be32(sn);
 
 		if (size <= pdusize) {
 			data_cmnd->pdu.datasize = size;
-			rsp->flags = ISCSI_FLG_FINAL | ISCSI_FLG_STATUS;
+			rsp->flags = ISCSI_FLAG_CMD_FINAL |
+				     ISCSI_FLAG_DATA_STATUS;
 
 			scsisize = cmnd->stc->bufflen;
 			if (scsisize < expsize) {
-				rsp->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 				size = expsize - scsisize;
 			} else if (scsisize > expsize) {
-				rsp->flags |= ISCSI_FLG_RESIDUAL_OVERFLOW;
+				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
 				size = scsisize - expsize;
 			} else
 				size = 0;
@@ -223,15 +224,15 @@
 static struct iscsi_cmnd *create_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd_rsp *rsp_hdr;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
-	rsp_hdr->response = ISCSI_RESPONSE_COMMAND_COMPLETED;
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp_hdr->cmd_status = SAM_STAT_GOOD;
 	rsp_hdr->itt = req_hdr->itt;
 
@@ -241,13 +242,13 @@
 void send_scsi_rsp(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = create_scsi_rsp(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *) &rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_cmd_rsp *) &rsp->pdu.bhs;
 	if ((size = cmnd_read_size(req)) != 0) {
-		rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr->residual_count = cpu_to_be32(size);
 	}
 
@@ -322,16 +323,16 @@
 	kfree(cmnd->pdu.ahs);
 
 	if (!list_empty(&cmnd->list)) {
-		struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+		struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
 		eprintk("cmnd %p still on some list?, %x, %x, %x, %x, %x, %x, %x %lx %lx\n",
-			cmnd, req->opcode, req->scb[0], req->flags, req->itt,
+			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
 			be32_to_cpu(req->data_length),
-			req->cmd_sn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
+			req->cmdsn, be32_to_cpu(cmnd->pdu.datasize), cmnd->state, conn->state);
 
 		if (cmnd->req) {
-			struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd->req);
-			eprintk("%p %x %u\n", req, req->opcode, req->scb[0]);
+			struct iscsi_cmd *req = cmnd_hdr(cmnd->req);
+			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
 		}
 		dump_stack();
 		BUG();
@@ -359,7 +360,7 @@
 	assert(0);
 
 /* 	eprintk("%x %x %x %u\n", cmnd_itt(cmnd), cmnd_opcode(cmnd), */
-/* 		cmnd_hdr(cmnd)->scb[0], cmnd->pdu.datasize); */
+/* 		cmnd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
 
 /* 	if (!(size = cmnd->pdu.datasize)) */
 /* 		return; */
@@ -416,9 +417,10 @@
 	struct iscsi_session *sess = conn->session;
 
 	if (set_stat_sn)
-		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn++);
-	cmnd->pdu.bhs.exp_sn = cpu_to_be32(sess->exp_cmd_sn);
-	cmnd->pdu.bhs.max_sn = cpu_to_be32(sess->exp_cmd_sn + sess->max_queued_cmnds);
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn++);
+	cmnd->pdu.bhs.exp_statsn = cpu_to_be32(sess->exp_cmd_sn);
+	cmnd->pdu.bhs.max_statsn = cpu_to_be32(sess->exp_cmd_sn +
+						sess->max_queued_cmnds);
 }
 
 static void update_stat_sn(struct iscsi_cmnd *cmnd)
@@ -426,7 +428,7 @@
 	struct iscsi_conn *conn = cmnd->conn;
 	u32 exp_stat_sn;
 
-	cmnd->pdu.bhs.exp_sn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_sn);
+	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
 	dprintk(D_GENERIC, "%x,%x\n", cmnd_opcode(cmnd), exp_stat_sn);
 	if ((int)(exp_stat_sn - conn->exp_stat_sn) > 0 &&
 	    (int)(exp_stat_sn - conn->stat_sn) <= 0) {
@@ -440,12 +442,12 @@
 	struct iscsi_session *session = cmnd->conn->session;
 	u32 cmd_sn;
 
-	cmnd->pdu.bhs.sn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.sn);
+	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
 	dprintk(D_GENERIC, "%d(%d)\n", cmd_sn, session->exp_cmd_sn);
 	if ((s32)(cmd_sn - session->exp_cmd_sn) >= 0)
 		return 0;
 	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
-	return -ISCSI_REASON_PROTOCOL_ERROR;
+	return -ISCSI_PROTOCOL_ERROR;
 }
 
 static struct iscsi_cmnd *__cmnd_find_hash(struct iscsi_session *session, u32 itt, u32 ttt)
@@ -489,7 +491,7 @@
 
 	dprintk(D_GENERIC, "%p:%x\n", cmnd, itt);
 	if (itt == ISCSI_RESERVED_TAG) {
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -502,7 +504,7 @@
 		list_add_tail(&cmnd->hash_list, head);
 		set_cmnd_hashed(cmnd);
 	} else
-		err = -ISCSI_REASON_TASK_IN_PROGRESS;
+		err = -TASK_IN_PROGRESS;
 
 	spin_unlock(&session->cmnd_hash_lock);
 
@@ -540,28 +542,28 @@
 static void cmnd_skip_data(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_scsi_rsp_hdr *rsp_hdr;
+	struct iscsi_cmd_rsp *rsp_hdr;
 	u32 size;
 
 	rsp = get_rsp_cmnd(req);
-	rsp_hdr = (struct iscsi_scsi_rsp_hdr *)&rsp->pdu.bhs;
-	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_RSP) {
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	if (cmnd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
 		eprintk("unexpected response command %u\n", cmnd_opcode(rsp));
 		return;
 	}
 
 	size = cmnd_write_size(req);
 	if (size) {
-		rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
 		rsp_hdr->residual_count = cpu_to_be32(size);
 	}
 	size = cmnd_read_size(req);
 	if (size) {
-		if (cmnd_hdr(req)->flags & ISCSI_CMD_WRITE) {
-			rsp_hdr->flags |= ISCSI_FLG_BIRESIDUAL_UNDERFLOW;
+		if (cmnd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
 			rsp_hdr->bi_residual_count = cpu_to_be32(size);
 		} else {
-			rsp_hdr->flags |= ISCSI_FLG_RESIDUAL_UNDERFLOW;
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
 			rsp_hdr->residual_count = cpu_to_be32(size);
 		}
 	}
@@ -629,7 +631,7 @@
 static void send_r2t(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_r2t_hdr *rsp_hdr;
+	struct iscsi_r2t_rsp *rsp_hdr;
 	u32 length, offset, burst;
 	LIST_HEAD(send);
 
@@ -641,13 +643,13 @@
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
 		rsp->pdu.bhs.ttt = req->target_task_tag;
 
-		rsp_hdr = (struct iscsi_r2t_hdr *)&rsp->pdu.bhs;
+		rsp_hdr = (struct iscsi_r2t_rsp *)&rsp->pdu.bhs;
 		rsp_hdr->opcode = ISCSI_OP_R2T;
-		rsp_hdr->flags = ISCSI_FLG_FINAL;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 		memcpy(rsp_hdr->lun, cmnd_hdr(req)->lun, 8);
 		rsp_hdr->itt = cmnd_hdr(req)->itt;
-		rsp_hdr->r2t_sn = cpu_to_be32(req->r2t_sn++);
-		rsp_hdr->buffer_offset = cpu_to_be32(offset);
+		rsp_hdr->r2tsn = cpu_to_be32(req->r2t_sn++);
+		rsp_hdr->data_offset = cpu_to_be32(offset);
 		if (length > burst) {
 			rsp_hdr->data_length = cpu_to_be32(burst);
 			length -= burst;
@@ -659,8 +661,8 @@
 
 		dprintk(D_WRITE, "%x %u %u %u %u\n", cmnd_itt(req),
 			be32_to_cpu(rsp_hdr->data_length),
-			be32_to_cpu(rsp_hdr->buffer_offset),
-			be32_to_cpu(rsp_hdr->r2t_sn), req->outstanding_r2t);
+			be32_to_cpu(rsp_hdr->data_offset),
+			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
 
 		list_add_tail(&rsp->list, &send);
 
@@ -675,9 +677,9 @@
 static void scsi_cmnd_done(struct stgt_cmnd *stc)
 {
 	struct iscsi_cmnd *cmnd = (struct iscsi_cmnd *) stc->private;
-	struct iscsi_scsi_cmd_hdr *req = cmnd_hdr(cmnd);
+	struct iscsi_cmd *req = cmnd_hdr(cmnd);
 
-	switch (req->scb[0]) {
+	switch (req->cdb[0]) {
 	case INQUIRY:
 	case REPORT_LUNS:
 	case READ_CAPACITY:
@@ -733,7 +735,7 @@
 		 * See 10.18.2 in the draft 20.
 		 */
 		eprintk("initiator bug %x\n", cmnd_itt(cmnd));
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		err = -ISCSI_PROTOCOL_ERROR;
 		goto out;
 	}
 
@@ -799,17 +801,17 @@
 
 static void scsi_cmnd_start(struct iscsi_conn *conn, struct iscsi_cmnd *req)
 {
-	struct iscsi_scsi_cmd_hdr *req_hdr = cmnd_hdr(req);
+	struct iscsi_cmd *req_hdr = cmnd_hdr(req);
 
-	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->scb[0]);
+	dprintk(D_GENERIC, "scsi command: %02x\n", req_hdr->cdb[0]);
 
-	eprintk("scsi command: %02x\n", req_hdr->scb[0]);
+	eprintk("scsi command: %02x\n", req_hdr->cdb[0]);
 
-	memcpy(req->stc->scb, req_hdr->scb, sizeof(req->stc->scb));
+	memcpy(req->stc->scb, req_hdr->cdb, sizeof(req->stc->scb));
 
-	switch (req_hdr->scb[0]) {
+	switch (req_hdr->cdb[0]) {
 	case SERVICE_ACTION_IN:
-		if ((req_hdr->scb[1] & 0x1f) != 0x10)
+		if ((req_hdr->cdb[1] & 0x1f) != 0x10)
 			goto error;
 
 	case INQUIRY:
@@ -827,9 +829,10 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	{
-		if (!(req_hdr->flags & ISCSI_CMD_FINAL) || req->pdu.datasize) {
+		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
+		      req->pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -839,9 +842,10 @@
 	case READ_10:
 	case READ_16:
 	{
-		if (!(req_hdr->flags & ISCSI_CMD_FINAL) || req->pdu.datasize) {
+		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
+		      req->pdu.datasize) {
 			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
 			cmnd_skip_data(req);
 		}
@@ -858,16 +862,18 @@
 		struct iscsi_sess_param *param = &conn->session->param;
 
 		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
-		req->is_unsolicited_data = !(req_hdr->flags & ISCSI_CMD_FINAL);
+		req->is_unsolicited_data = !(req_hdr->flags &
+						ISCSI_FLAG_CMD_FINAL);
 		req->target_task_tag = get_next_ttt(conn->session);
 
 		if (!param->immediate_data && req->pdu.datasize)
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 
-		if (param->initial_r2t && !(req_hdr->flags & ISCSI_CMD_FINAL))
-			eprintk("%x %x\n", cmnd_itt(req), req_hdr->scb[0]);
+		if (param->initial_r2t &&
+		    !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL))
+			eprintk("%x %x\n", cmnd_itt(req), req_hdr->cdb[0]);
 
-		if (req_hdr->scb[0] == WRITE_VERIFY && req_hdr->scb[1] & 0x02)
+		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
 			eprintk("Verification is ignored %x\n", cmnd_itt(req));
 
 		stgt_cmnd_alloc_buffer(req->stc, NULL);
@@ -880,7 +886,7 @@
 	}
 	error:
 	default:
-		eprintk("Unsupported %x\n", req_hdr->scb[0]);
+		eprintk("Unsupported %x\n", req_hdr->cdb[0]);
 		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
 		cmnd_skip_data(req);
 		break;
@@ -891,9 +897,9 @@
 
 static void data_out_start(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *)&cmnd->pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd = NULL;
-	u32 offset = be32_to_cpu(req->buffer_offset);
+	u32 offset = be32_to_cpu(req->offset);
 
 	update_stat_sn(cmnd);
 
@@ -920,7 +926,7 @@
 
 	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		/* unsolicited burst data */
-		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLG_FINAL) {
+		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_FINAL) {
 			eprintk("unexpected data from %x %x\n",
 				cmnd_itt(cmnd), cmnd_ttt(cmnd));
 			goto skip_data;
@@ -942,7 +948,7 @@
 
 static void data_out_end(struct iscsi_conn *conn, struct iscsi_cmnd *cmnd)
 {
-	struct iscsi_data_out_hdr *req = (struct iscsi_data_out_hdr *) &cmnd->pdu.bhs;
+	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 	struct iscsi_cmnd *scsi_cmnd;
 	u32 offset;
 
@@ -953,7 +959,7 @@
 	if (conn->read_overflow) {
 		eprintk("%x %u\n", cmnd_itt(cmnd), conn->read_overflow);
 /* 		assert(scsi_cmnd->tio); */
-		offset = be32_to_cpu(req->buffer_offset);
+		offset = be32_to_cpu(req->offset);
 		offset += cmnd->pdu.datasize - conn->read_overflow;
 		if (cmnd_recv_pdu(conn, scsi_cmnd->stc, offset, conn->read_overflow) < 0)
 			assert(0);
@@ -961,17 +967,18 @@
 	}
 
 	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req->flags & ISCSI_FLG_FINAL) {
+		if (req->flags & ISCSI_FLAG_CMD_FINAL) {
 			scsi_cmnd->is_unsolicited_data = 0;
 			if (!cmnd_pending(scsi_cmnd))
 				scsi_cmnd_exec(scsi_cmnd);
 		}
 	} else {
 		/* TODO : proper error handling */
-		if (!(req->flags & ISCSI_FLG_FINAL) && scsi_cmnd->r2t_length == 0)
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL) &&
+		    scsi_cmnd->r2t_length == 0)
 			eprintk("initiator error %x\n", cmnd_itt(scsi_cmnd));
 
-		if (!(req->flags & ISCSI_FLG_FINAL))
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL))
 			goto out;
 
 		scsi_cmnd->outstanding_r2t--;
@@ -1055,17 +1062,17 @@
 /* 	struct iscsi_conn *conn = req->conn; */
 /* 	struct iscsi_target *target = conn->session->target; */
 	struct iscsi_cmnd *rsp;
-	struct iscsi_task_mgt_hdr *req_hdr = (struct iscsi_task_mgt_hdr *)&req->pdu.bhs;
-	struct iscsi_task_rsp_hdr *rsp_hdr;
-	int function = req_hdr->function & ISCSI_FUNCTION_MASK;
+	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
+	int function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_task_rsp_hdr *)&rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_tm_rsp *)&rsp->pdu.bhs;
 
-	rsp_hdr->opcode = ISCSI_OP_SCSI_TASK_MGT_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
-	rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_COMPLETE;
+	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE;
 
 	eprintk("%x %d %x\n", cmnd_itt(req), function, req_hdr->rtt);
 
@@ -1119,14 +1126,14 @@
 static void noop_out_exec(struct iscsi_cmnd *req)
 {
 	struct iscsi_cmnd *rsp;
-	struct iscsi_nop_in_hdr *rsp_hdr;
+	struct iscsi_nopin *rsp_hdr;
 
 	if (cmnd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
-		rsp_hdr = (struct iscsi_nop_in_hdr *)&rsp->pdu.bhs;
+		rsp_hdr = (struct iscsi_nopin *)&rsp->pdu.bhs;
 		rsp_hdr->opcode = ISCSI_OP_NOOP_IN;
-		rsp_hdr->flags = ISCSI_FLG_FINAL;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 		rsp_hdr->itt = req->pdu.bhs.itt;
 		rsp_hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
 
@@ -1149,15 +1156,15 @@
 
 static void logout_exec(struct iscsi_cmnd *req)
 {
-	struct iscsi_logout_req_hdr *req_hdr;
+	struct iscsi_logout *req_hdr;
 	struct iscsi_cmnd *rsp;
-	struct iscsi_logout_rsp_hdr *rsp_hdr;
+	struct iscsi_logout_rsp *rsp_hdr;
 
-	req_hdr = (struct iscsi_logout_req_hdr *)&req->pdu.bhs;
+	req_hdr = (struct iscsi_logout *)&req->pdu.bhs;
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_logout_rsp_hdr *)&rsp->pdu.bhs;
+	rsp_hdr = (struct iscsi_logout_rsp *)&rsp->pdu.bhs;
 	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp_hdr->flags = ISCSI_FLG_FINAL;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp_hdr->itt = req_hdr->itt;
 	set_cmnd_close(rsp);
 	iscsi_cmnd_init_write(rsp);
@@ -1165,7 +1172,8 @@
 
 static void iscsi_cmnd_exec(struct iscsi_cmnd *cmnd)
 {
-	dprintk(D_GENERIC, "%p,%x,%u\n", cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.sn);
+	dprintk(D_GENERIC, "%p,%x,%u\n", cmnd, cmnd_opcode(cmnd),
+		cmnd->pdu.bhs.statsn);
 
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_OUT:
@@ -1174,17 +1182,17 @@
 	case ISCSI_OP_SCSI_CMD:
 		scsi_cmnd_exec(cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		execute_task_management(cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		logout_exec(cmnd);
 		break;
 	case ISCSI_OP_SCSI_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
 		break;
 	default:
 		eprintk("unexpected cmnd op %x\n", cmnd_opcode(cmnd));
@@ -1293,11 +1301,11 @@
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
 		cmnd_set_sn(cmnd, 1);
 		cmnd_send_pdu(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_TEXT_RSP:
@@ -1305,12 +1313,12 @@
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 	{
-		struct iscsi_data_in_hdr *rsp = (struct iscsi_data_in_hdr *)&cmnd->pdu.bhs;
+		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&cmnd->pdu.bhs;
 		u32 offset;
 
-		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLG_FINAL) ? 1 : 0);
-		offset = rsp->buffer_offset;
-		rsp->buffer_offset = cpu_to_be32(offset);
+		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
+		offset = rsp->offset;
+		rsp->offset = cpu_to_be32(offset);
 		assert(cmnd->sg);
 		__cmnd_send_pdu(conn, cmnd->sg, offset, cmnd->pdu.datasize);
 		break;
@@ -1320,9 +1328,9 @@
 		break;
 	case ISCSI_OP_R2T:
 		cmnd_set_sn(cmnd, 0);
-		cmnd->pdu.bhs.sn = cpu_to_be32(conn->stat_sn);
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn);
 		break;
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 		cmnd_set_sn(cmnd, 1);
 		break;
 	case ISCSI_OP_REJECT:
@@ -1347,11 +1355,11 @@
 	dprintk(D_GENERIC, "%p:%x\n", cmnd, cmnd_opcode(cmnd));
 	switch (cmnd_opcode(cmnd)) {
 	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_SCSI_RSP:
-	case ISCSI_OP_SCSI_TASK_MGT_RSP:
+	case ISCSI_OP_SCSI_CMD_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
 	case ISCSI_OP_TEXT_RSP:
 	case ISCSI_OP_R2T:
-	case ISCSI_OP_ASYNC_MSG:
+	case ISCSI_OP_ASYNC_EVENT:
 	case ISCSI_OP_REJECT:
 	case ISCSI_OP_SCSI_DATA_IN:
 	case ISCSI_OP_LOGOUT_RSP:
@@ -1385,14 +1393,15 @@
 	u32 cmd_sn;
 
 	dprintk(D_GENERIC, "%p:%x %u,%u\n",
-		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.sn, session->exp_cmd_sn);
+		cmnd, cmnd_opcode(cmnd), cmnd->pdu.bhs.statsn,
+		session->exp_cmd_sn);
 
 	if (cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE) {
 		iscsi_cmnd_exec(cmnd);
 		return;
 	}
 
-	cmd_sn = cmnd->pdu.bhs.sn;
+	cmd_sn = cmnd->pdu.bhs.statsn;
 	if (cmd_sn == session->exp_cmd_sn) {
 		while (1) {
 			session->exp_cmd_sn = ++cmd_sn;
@@ -1401,10 +1410,10 @@
 			if (list_empty(&session->pending_list))
 				break;
 			cmnd = list_entry(session->pending_list.next, struct iscsi_cmnd, list);
-			if (cmnd->pdu.bhs.sn != cmd_sn)
+			if (cmnd->pdu.bhs.statsn != cmd_sn)
 				break;
 /* 			eprintk("find out-of-order %x %u %u\n", */
-/* 				cmnd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.sn); */
+/* 				cmnd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
 			list_del_init(&cmnd->list);
 			clear_cmnd_pending(cmnd);
 		}
@@ -1421,7 +1430,7 @@
 
 		list_for_each(entry, &session->pending_list) {
 			struct iscsi_cmnd *tmp = list_entry(entry, struct iscsi_cmnd, list);
-			if (before(cmd_sn, tmp->pdu.bhs.sn))
+			if (before(cmd_sn, tmp->pdu.bhs.statsn))
 				break;
 		}
 
@@ -1467,21 +1476,21 @@
 		if (!(err = cmnd_insert_hash(cmnd)))
 			scsi_cmnd_start(conn, cmnd);
 		break;
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
+	case ISCSI_OP_SCSI_TMFUNC:
 		err = cmnd_insert_hash(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_start(conn, cmnd);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		err = cmnd_insert_hash(cmnd);
 		break;
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_SNACK_CMD:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		err = -CMD_NOT_SUPPORTED;
 		break;
 	default:
-		err = -ISCSI_REASON_UNSUPPORTED_COMMAND;
+		err = -CMD_NOT_SUPPORTED;
 		break;
 	}
 
@@ -1500,15 +1509,15 @@
 	case ISCSI_OP_SCSI_REJECT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TASK_MGT_MSG:
-	case ISCSI_OP_TEXT_CMD:
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_LOGOUT:
 		iscsi_session_push_cmnd(cmnd);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		data_out_end(conn, cmnd);
 		break;
-	case ISCSI_OP_SNACK_CMD:
+	case ISCSI_OP_SNACK:
 		break;
 	case ISCSI_OP_PDU_REJECT:
 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -13,7 +13,7 @@
 #include <linux/crypto.h>
 #include <net/sock.h>
 
-#include "iscsi_hdr.h"
+#include "iscsi_proto.h"
 #include "iet_u.h"
 
 struct iscsi_sess_param {
@@ -261,34 +261,21 @@
 
 static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu->ahssize = pdu->bhs.length.ahslength * 4;
-	pdu->datasize = pdu->bhs.length.datalength;
-#elif defined(__LITTLE_ENDIAN)
-	pdu->ahssize = (pdu->bhs.length & 0xff) * 4;
-	pdu->datasize = be32_to_cpu(pdu->bhs.length & ~0xff);
-#else
-#error
-#endif
+	pdu->ahssize = pdu->bhs.hlength * 4;
+	pdu->datasize = ntoh24(pdu->bhs.dlength);
 }
 
 static inline void iscsi_cmnd_set_length(struct iscsi_pdu *pdu)
 {
-#if defined(__BIG_ENDIAN)
-	pdu->bhs.length.ahslength = pdu->ahssize / 4;
-	pdu->bhs.length.datalength = pdu->datasize;
-#elif defined(__LITTLE_ENDIAN)
-	pdu->bhs.length = cpu_to_be32(pdu->datasize) | (pdu->ahssize / 4);
-#else
-#error
-#endif
+	pdu->bhs.hlength = pdu->ahssize / 4;
+	hton24(pdu->bhs.dlength, pdu->datasize);
 }
 
-#define cmnd_hdr(cmnd) ((struct iscsi_scsi_cmd_hdr *) (&((cmnd)->pdu.bhs)))
+#define cmnd_hdr(cmnd) ((struct iscsi_cmd *) (&((cmnd)->pdu.bhs)))
 #define cmnd_ttt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.ttt)
 #define cmnd_itt(cmnd) cpu_to_be32((cmnd)->pdu.bhs.itt)
 #define cmnd_opcode(cmnd) ((cmnd)->pdu.bhs.opcode & ISCSI_OPCODE_MASK)
-#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)->scb[0]
+#define cmnd_scsicode(cmnd) cmnd_hdr(cmnd)->cdb[0]
 
 #define	SECTOR_SIZE_BITS	9
 

Deleted: trunk/iscsi/kernel/iscsi_hdr.h
===================================================================
--- trunk/iscsi/kernel/iscsi_hdr.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi_hdr.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -1,507 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef __ISCSI_HDR_H__
-#define __ISCSI_HDR_H__
-
-#include <linux/types.h>
-#include <asm/byteorder.h>
-
-#define ISCSI_VERSION			0
-
-#define __packed __attribute__ ((packed))
-
-struct iscsi_hdr {
-	u8  opcode;			/* 0 */
-	u8  flags;
-	u8  spec1[2];
-#if defined(__BIG_ENDIAN_BITFIELD)
-	struct {			/* 4 */
-		unsigned ahslength : 8;
-		unsigned datalength : 24;
-	} length;
-#elif defined(__LITTLE_ENDIAN_BITFIELD)
-	u32 length;			/* 4 */
-#endif
-	u16 lun[4];			/* 8 */
-	u32 itt;			/* 16 */
-	u32 ttt;			/* 20 */
-	u32 sn;				/* 24 */
-	u32 exp_sn;			/* 28 */
-	u32 max_sn;			/* 32 */
-	u32 spec3[3];			/* 36 */
-} __packed;				/* 48 */
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Client to Server Message Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TASK_MGT_MSG	0x02
-#define ISCSI_OP_LOGIN_CMD		0x03
-#define ISCSI_OP_TEXT_CMD		0x04
-#define ISCSI_OP_SCSI_DATA_OUT		0x05
-#define ISCSI_OP_LOGOUT_CMD		0x06
-#define ISCSI_OP_SNACK_CMD		0x10
-
-#define ISCSI_OP_VENDOR1_CMD		0x1c
-#define ISCSI_OP_VENDOR2_CMD		0x1d
-#define ISCSI_OP_VENDOR3_CMD		0x1e
-#define ISCSI_OP_VENDOR4_CMD		0x1f
-
-/* Server to Client Message Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_RSP		0x21
-#define ISCSI_OP_SCSI_TASK_MGT_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_IN		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T			0x31
-#define ISCSI_OP_ASYNC_MSG		0x32
-#define ISCSI_OP_REJECT			0x3f
-
-struct iscsi_ahs_hdr {
-	u16 ahslength;
-	u8 ahstype;
-} __packed;
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-union iscsi_sid {
-	struct {
-		u8 isid[6];		/* Initiator Session ID */
-		u16 tsih;		/* Target Session ID */
-	} id;
-	u64 id64;
-} __packed;
-
-struct iscsi_scsi_cmd_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 data_length;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u8  scb[16];
-} __packed;
-
-#define ISCSI_CMD_FINAL		0x80
-#define ISCSI_CMD_READ		0x40
-#define ISCSI_CMD_WRITE		0x20
-#define ISCSI_CMD_ATTR_MASK	0x07
-#define ISCSI_CMD_UNTAGGED	0x00
-#define ISCSI_CMD_SIMPLE	0x01
-#define ISCSI_CMD_ORDERED	0x02
-#define ISCSI_CMD_HEAD_OF_QUEUE	0x03
-#define ISCSI_CMD_ACA		0x04
-
-struct iscsi_cdb_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u8  cdb[0];
-} __packed;
-
-struct iscsi_rlength_ahdr {
-	u16 ahslength;
-	u8  ahstype;
-	u8  reserved;
-	u32 read_length;
-} __packed;
-
-struct iscsi_scsi_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd1[2];
-	u32 itt;
-	u32 snack;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 exp_data_sn;
-	u32 bi_residual_count;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_RESIDUAL_UNDERFLOW		0x02
-#define ISCSI_FLG_RESIDUAL_OVERFLOW		0x04
-#define ISCSI_FLG_BIRESIDUAL_UNDERFLOW		0x08
-#define ISCSI_FLG_BIRESIDUAL_OVERFLOW		0x10
-
-#define ISCSI_RESPONSE_COMMAND_COMPLETED	0x00
-#define ISCSI_RESPONSE_TARGET_FAILURE		0x01
-
-struct iscsi_sense_data {
-	u16 length;
-	u8  data[0];
-} __packed;
-
-struct iscsi_task_mgt_hdr {
-	u8  opcode;
-	u8  function;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 rtt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 ref_cmd_sn;
-	u32 exp_data_sn;
-	u32 rsvd2[2];
-} __packed;
-
-#define ISCSI_FUNCTION_MASK			0x7f
-
-#define ISCSI_FUNCTION_ABORT_TASK		1
-#define ISCSI_FUNCTION_ABORT_TASK_SET		2
-#define ISCSI_FUNCTION_CLEAR_ACA		3
-#define ISCSI_FUNCTION_CLEAR_TASK_SET		4
-#define ISCSI_FUNCTION_LOGICAL_UNIT_RESET	5
-#define ISCSI_FUNCTION_TARGET_WARM_RESET	6
-#define ISCSI_FUNCTION_TARGET_COLD_RESET	7
-#define ISCSI_FUNCTION_TASK_REASSIGN		8
-
-struct iscsi_task_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4[3];
-} __packed;
-
-#define ISCSI_RESPONSE_FUNCTION_COMPLETE	0
-#define ISCSI_RESPONSE_UNKNOWN_TASK		1
-#define ISCSI_RESPONSE_UNKNOWN_LUN		2
-#define ISCSI_RESPONSE_TASK_ALLEGIANT		3
-#define ISCSI_RESPONSE_FAILOVER_UNSUPPORTED	4
-#define ISCSI_RESPONSE_FUNCTION_UNSUPPORTED	5
-#define ISCSI_RESPONSE_NO_AUTHORIZATION		6
-#define ISCSI_RESPONSE_FUNCTION_REJECTED	255
-
-struct iscsi_data_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd2;
-	u32 exp_stat_sn;
-	u32 rsvd3;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 rsvd4;
-} __packed;
-
-struct iscsi_data_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  rsvd1;
-	u8  cmd_status;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 buffer_offset;
-	u32 residual_count;
-} __packed;
-
-#define ISCSI_FLG_STATUS		0x01
-
-struct iscsi_r2t_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 r2t_sn;
-	u32 buffer_offset;
-	u32 data_length;
-} __packed;
-
-struct iscsi_async_msg_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 ffffffff;
-	u32 rsvd2;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  async_event;
-	u8  async_vcode;
-	u16 param1;
-	u16 param2;
-	u16 param3;
-	u32 rsvd3;
-} __packed;
-
-#define ISCSI_ASYNC_SCSI		0
-#define ISCSI_ASYNC_LOGOUT		1
-#define ISCSI_ASYNC_DROP_CONNECTION	2
-#define ISCSI_ASYNC_DROP_SESSION	3
-#define ISCSI_ASYNC_PARAM_REQUEST	4
-#define ISCSI_ASYNC_VENDOR		255
-
-struct iscsi_text_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd3[4];
-} __packed;
-
-struct iscsi_text_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd3[3];
-} __packed;
-
-struct iscsi_login_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  min_version;		/* Min. version supported */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u16 cid;			/* Connection ID */
-	u16 rsvd1;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_login_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  active_version;		/* Active version */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u32 rsvd1;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  status_class;		/* see Login RSP ststus classes below */
-	u8  status_detail;		/* see Login RSP Status details below */
-	u8  rsvd2[10];
-} __packed;
-
-#define ISCSI_FLG_FINAL			0x80
-#define ISCSI_FLG_TRANSIT		0x80
-#define ISCSI_FLG_CSG_SECURITY		0x00
-#define ISCSI_FLG_CSG_LOGIN		0x04
-#define ISCSI_FLG_CSG_FULL_FEATURE	0x0c
-#define ISCSI_FLG_CSG_MASK		0x0c
-#define ISCSI_FLG_NSG_SECURITY		0x00
-#define ISCSI_FLG_NSG_LOGIN		0x01
-#define ISCSI_FLG_NSG_FULL_FEATURE	0x03
-#define ISCSI_FLG_NSG_MASK		0x03
-
-/* Login Status response classes */
-#define ISCSI_STATUS_SUCCESS		0x00
-#define ISCSI_STATUS_REDIRECT		0x01
-#define ISCSI_STATUS_INITIATOR_ERR	0x02
-#define ISCSI_STATUS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_STATUS_INIT_ERR		0x00
-#define ISCSI_STATUS_AUTH_FAILED	0x01
-#define ISCSI_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_STATUS_TGT_REMOVED	0x04
-#define ISCSI_STATUS_NO_VERSION		0x05
-#define ISCSI_STATUS_TOO_MANY_CONN	0x06
-#define ISCSI_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_STATUS_INV_SESSION_TYPE	0x09
-#define ISCSI_STATUS_SESSION_NOT_FOUND	0x0a
-#define ISCSI_STATUS_INV_REQ_TYPE	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_STATUS_TARGET_ERROR	0x00
-#define ISCSI_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_STATUS_NO_RESOURCES	0x02
-
-struct iscsi_logout_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u16 cid;
-	u16 rsvd3;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd4[4];
-} __packed;
-
-struct iscsi_logout_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4;
-	u16 time2wait;
-	u16 time2retain;
-	u32 rsvd5;
-} __packed;
-
-struct iscsi_snack_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 rsvd3;
-	u32 exp_stat_sn;
-	u32 rsvd4[2];
-	u32 beg_run;
-	u32 run_length;
-} __packed;
-
-struct iscsi_reject_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  reason;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 ffffffff;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 data_sn;
-	u32 rsvd4[2];
-} __packed;
-
-#define ISCSI_REASON_NO_FULL_FEATURE_PHASE	0x01
-#define ISCSI_REASON_DATA_DIGEST_ERROR		0x02
-#define ISCSI_REASON_DATA_SNACK_REJECT		0x03
-#define ISCSI_REASON_PROTOCOL_ERROR		0x04
-#define ISCSI_REASON_UNSUPPORTED_COMMAND	0x05
-#define ISCSI_REASON_IMMEDIATE_COMMAND_REJECT	0x06
-#define ISCSI_REASON_TASK_IN_PROGRESS		0x07
-#define ISCSI_REASON_INVALID_SNACK		0x08
-#define ISCSI_REASON_NO_BOOKMARK		0x09
-#define ISCSI_REASON_BOOKMARK_REJECT		0x0a
-#define ISCSI_REASON_NEGOTIATION_RESET		0x0b
-#define ISCSI_REASON_WAITING_LOGOUT		0x0c
-
-
-struct iscsi_nop_out_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_nop_in_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u16 lun[4];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd2[3];
-} __packed;
-
-#define ISCSI_RESERVED_TAG	(0xffffffffU)
-
-#endif	/* __ISCSI_HDR_H__ */

Added: trunk/iscsi/kernel/iscsi_proto.h
===================================================================
--- trunk/iscsi/kernel/iscsi_proto.h	2005-08-16 13:18:24 UTC (rev 5)
+++ trunk/iscsi/kernel/iscsi_proto.h	2005-08-17 07:41:44 UTC (rev 6)
@@ -0,0 +1,587 @@
+/*
+ * RFC 3720 (iSCSI) protocol data types
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_PROTO_H
+#define ISCSI_PROTO_H
+
+#define ISCSI_VERSION_STR	"0.3"
+#define ISCSI_DATE_STR		"22-Apr-2005"
+#define ISCSI_DRAFT20_VERSION	0x00
+
+/* default iSCSI listen port for incoming connections */
+#define ISCSI_LISTEN_PORT	3260
+
+/* Padding word length */
+#define PAD_WORD_LEN		4
+
+/*
+ * useful common(control and data pathes) macro
+ */
+#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
+#define hton24(p, v) { \
+        p[0] = (((v) >> 16) & 0xFF); \
+        p[1] = (((v) >> 8) & 0xFF); \
+        p[2] = ((v) & 0xFF); \
+}
+#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
+
+/*
+ * iSCSI Template Message Header
+ */
+struct iscsi_hdr {
+	uint8_t		opcode;
+	uint8_t		flags;		/* Final bit */
+	uint8_t		rsvd2[2];
+	uint8_t		hlength;	/* AHSs total length */
+	uint8_t		dlength[3];	/* Data length */
+	uint8_t		lun[8];
+	__be32		itt;		/* Initiator Task Tag */
+	__be32		ttt;		/* Target Task Tag */
+	__be32		statsn;
+	__be32		exp_statsn;
+	__be32		max_statsn;
+	uint8_t		other[12];
+};
+
+/************************* RFC 3720 Begin *****************************/
+
+#define ISCSI_RESERVED_TAG		0xffffffff
+
+/* Opcode encoding bits */
+#define ISCSI_OP_RETRY			0x80
+#define ISCSI_OP_IMMEDIATE		0x40
+#define ISCSI_OPCODE_MASK		0x3F
+
+/* Initiator Opcode values */
+#define ISCSI_OP_NOOP_OUT		0x00
+#define ISCSI_OP_SCSI_CMD		0x01
+#define ISCSI_OP_SCSI_TMFUNC		0x02
+#define ISCSI_OP_LOGIN			0x03
+#define ISCSI_OP_TEXT			0x04
+#define ISCSI_OP_SCSI_DATA_OUT		0x05
+#define ISCSI_OP_LOGOUT			0x06
+#define ISCSI_OP_SNACK			0x10
+
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
+/* Target Opcode values */
+#define ISCSI_OP_NOOP_IN		0x20
+#define ISCSI_OP_SCSI_CMD_RSP		0x21
+#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
+#define ISCSI_OP_LOGIN_RSP		0x23
+#define ISCSI_OP_TEXT_RSP		0x24
+#define ISCSI_OP_SCSI_DATA_IN		0x25
+#define ISCSI_OP_LOGOUT_RSP		0x26
+#define ISCSI_OP_R2T			0x31
+#define ISCSI_OP_ASYNC_EVENT		0x32
+#define ISCSI_OP_REJECT			0x3f
+
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
+/* iSCSI PDU Header */
+struct iscsi_cmd {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16 rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32 itt;	/* Initiator Task Tag */
+	__be32 data_length;
+	__be32 cmdsn;
+	__be32 exp_statsn;
+	uint8_t cdb[16];	/* SCSI Command Block */
+	/* Additional Data (Command Dependent) */
+};
+
+/* Command PDU flags */
+#define ISCSI_FLAG_CMD_FINAL		0x80
+#define ISCSI_FLAG_CMD_READ		0x40
+#define ISCSI_FLAG_CMD_WRITE		0x20
+#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
+
+/* SCSI Command Attribute values */
+#define ISCSI_ATTR_UNTAGGED		0
+#define ISCSI_ATTR_SIMPLE		1
+#define ISCSI_ATTR_ORDERED		2
+#define ISCSI_ATTR_HEAD_OF_QUEUE	3
+#define ISCSI_ATTR_ACA			4
+
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
+/* SCSI Response Header */
+struct iscsi_cmd_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd1;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	exp_datasn;
+	__be32	bi_residual_count;
+	__be32	residual_count;
+	/* Response or Sense Data (optional) */
+};
+
+/* Command Response PDU flags */
+#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
+#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
+#define ISCSI_FLAG_CMD_OVERFLOW		0x04
+#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
+
+/* iSCSI Status values. Valid if Rsp Selector bit is not set */
+#define ISCSI_STATUS_CMD_COMPLETED	0
+#define ISCSI_STATUS_TARGET_FAILURE	1
+#define ISCSI_STATUS_SUBSYS_FAILURE	2
+
+/* Asynchronous Event Header */
+struct iscsi_async {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	uint8_t rsvd4[8];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t async_event;
+	uint8_t async_vcode;
+	__be16	param1;
+	__be16	param2;
+	__be16	param3;
+	uint8_t rsvd5[4];
+};
+
+/* iSCSI Event Codes */
+#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
+#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
+#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
+#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
+#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
+#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
+
+/* NOP-Out Message */
+struct iscsi_nopout {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* NOP-In Message */
+struct iscsi_nopin {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd4[12];
+};
+
+/* SCSI Task Management Message Header */
+struct iscsi_tm {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	__be32	refcmdsn;
+	__be32	exp_datasn;
+	uint8_t rsvd2[8];
+};
+
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
+
+/* Function values */
+#define ISCSI_TM_FUNC_ABORT_TASK		1
+#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
+#define ISCSI_TM_FUNC_CLEAR_ACA			3
+#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
+#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
+#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
+#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
+#define ISCSI_TM_FUNC_TASK_REASSIGN		8
+
+/* SCSI Task Management Response Header */
+struct iscsi_tm_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Response values below */
+	uint8_t qualifier;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd3[12];
+};
+
+/* Response values */
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
+
+/* Ready To Transfer Header */
+struct iscsi_r2t_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t	hlength;
+	uint8_t	dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	r2tsn;
+	__be32	data_offset;
+	__be32	data_length;
+};
+
+/* SCSI Data Hdr */
+struct iscsi_data {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	rsvd4;
+	__be32	exp_statsn;
+	__be32	rsvd5;
+	__be32	datasn;
+	__be32	offset;
+	__be32	rsvd6;
+	/* Payload */
+};
+
+/* SCSI Data Response Hdr */
+struct iscsi_data_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	__be32	offset;
+	__be32	residual_count;
+};
+
+/* Data Response PDU flags */
+#define ISCSI_FLAG_DATA_ACK		0x40
+#define ISCSI_FLAG_DATA_OVERFLOW	0x04
+#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
+#define ISCSI_FLAG_DATA_STATUS		0x01
+
+/* Text Header */
+struct iscsi_text {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+	/* Text - key=value pairs */
+};
+
+#define ISCSI_FLAG_TEXT_CONTINUE	0x40
+
+/* Text Response Header */
+struct iscsi_text_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd5[12];
+	/* Text Response - key:value pairs */
+};
+
+/* Login Header */
+struct iscsi_login {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t min_version;	/* Min. version supported */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	__be16	rsvd3;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+};
+
+/* Login PDU flags */
+#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
+#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
+#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
+#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
+
+#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
+	((flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) >> 2)
+#define ISCSI_LOGIN_NEXT_STAGE(flags) \
+	(flags & ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
+
+/* Login Response Header */
+struct iscsi_login_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t active_version;	/* Active version */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd3;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t status_class;	/* see Login RSP ststus classes below */
+	uint8_t status_detail;	/* see Login RSP Status details below */
+	uint8_t rsvd4[10];
+};
+
+/* Login stage (phase) codes for CSG, NSG */
+#define ISCSI_INITIAL_LOGIN_STAGE		-1
+#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
+#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
+#define ISCSI_FULL_FEATURE_PHASE		3
+
+/* Login Status response classes */
+#define ISCSI_STATUS_CLS_SUCCESS		0x00
+#define ISCSI_STATUS_CLS_REDIRECT		0x01
+#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
+#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
+
+/* Login Status response detail codes */
+/* Class-0 (Success) */
+#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
+
+/* Class-1 (Redirection) */
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
+
+/* Class-2 (Initiator Error) */
+#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
+#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
+#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
+#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
+#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
+#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
+#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
+#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
+#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
+#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
+#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
+#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
+
+/* Class-3 (Target Error) */
+#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
+#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
+#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
+
+/* Logout Header */
+struct iscsi_logout {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	uint8_t rsvd3[2];
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* Logout PDU flags */
+#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
+
+/* logout reason_code values */
+
+#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
+#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
+#define ISCSI_LOGOUT_REASON_RECOVERY		2
+#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
+
+/* Logout Response Header */
+struct iscsi_logout_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Logout response values below */
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd4;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	rsvd5;
+	__be16	t2wait;
+	__be16	t2retain;
+	__be32	rsvd6;
+};
+
+/* logout response status values */
+
+#define ISCSI_LOGOUT_SUCCESS			0
+#define ISCSI_LOGOUT_CID_NOT_FOUND		1
+#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
+#define ISCSI_LOGOUT_CLEANUP_FAILED		3
+
+/* SNACK Header */
+struct iscsi_snack {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[14];
+	__be32	itt;
+	__be32	begrun;
+	__be32	runlength;
+	__be32	exp_statsn;
+	__be32	rsvd3;
+	__be32	exp_datasn;
+	uint8_t rsvd6[8];
+};
+
+/* SNACK PDU flags */
+#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
+
+/* Reject Message Header */
+struct iscsi_reject {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t reason;
+	uint8_t rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t rsvd4[16];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	uint8_t rsvd5[8];
+	/* Text - Rejected hdr */
+};
+
+/* Reason for Reject */
+#define CMD_BEFORE_LOGIN	1
+#define DATA_DIGEST_ERROR	2
+#define DATA_SNACK_REJECT	3
+#define ISCSI_PROTOCOL_ERROR	4
+#define CMD_NOT_SUPPORTED	5
+#define IMM_CMD_REJECT		6
+#define TASK_IN_PROGRESS	7
+#define INVALID_SNACK		8
+#define BOOKMARK_REJECTED	9
+#define BOOKMARK_NO_RESOURCES	10
+#define NEGOTIATION_RESET	11
+
+/* Max. number of Key=Value pairs in a text message */
+#define MAX_KEY_VALUE_PAIRS	8192
+
+/* maximum length for text keys/values */
+#define KEY_MAXLEN		64
+#define VALUE_MAXLEN		255
+#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
+
+#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
+
+/************************* RFC 3720 End *****************************/
+
+#endif /* ISCSI_PROTO_H */



From tomo at berlios.de  Thu Aug 18 20:07:21 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 18 Aug 2005 20:07:21 +0200
Subject: [Stgt-svn] r7 - trunk/kernel
Message-ID: <200508181807.j7II7LZo027998@sheep.berlios.de>

Author: tomo
Date: 2005-08-18 20:07:21 +0200 (Thu, 18 Aug 2005)
New Revision: 7

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
Log:
stgt_session_create() can be called in an atomic manner (that is, interrupt context is OK), however, not tested yet.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-17 07:41:44 UTC (rev 6)
+++ trunk/kernel/stgt.c	2005-08-18 18:07:21 UTC (rev 7)
@@ -46,6 +46,12 @@
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
+static void session_init_handler(void *data);
+static spinlock_t atomic_sessions_lock;
+static LIST_HEAD(atomic_sessions);
+static DECLARE_WORK(atomic_session_work, session_init_handler,
+		    &atomic_sessions);
+
 static int daemon_pid;
 static struct sock *nls;
 
@@ -57,6 +63,14 @@
 #define	cmnd_hashfn(key)	hash_long((key), STGT_HASH_ORDER)
 static struct list_head cmnd_hash[1 << STGT_HASH_ORDER];
 
+struct atomic_session_args {
+	struct stgt_session *session;
+	void (*done) (void *, struct stgt_session *);
+	int max_cmnds;
+	void *arg;
+	struct list_head list;
+};
+
 struct stgt_work {
 	void (*fn) (void *);
 	void *arg;
@@ -140,26 +154,11 @@
 }
 EXPORT_SYMBOL(stgt_target_destroy);
 
-struct stgt_session *stgt_session_create(struct stgt_target *target,
-					 void (*done)(void *), int max_cmnds)
+static int session_init(struct stgt_session *session, int max_cmnds)
 {
-	struct stgt_session *session;
+	struct stgt_target *target = session->target;
 	unsigned long flags;
 
-	if (!target) {
-		eprintk("%s\n", "Null target pointer!");
-		return NULL;
-	}
-
-	dprintk("%p %d\n", target, max_cmnds);
-	session = kmalloc(sizeof(*session), GFP_KERNEL);
-	if (!session)
-		return NULL;
-
-	memset(session, 0, sizeof(*session));
-	session->target = target;
-	INIT_LIST_HEAD(&session->slist);
-
 	session->cmnd_pool = mempool_create(max_cmnds, mempool_alloc_slab,
 					    mempool_free_slab, cmnd_slab);
 	if (!session->cmnd_pool)
@@ -174,8 +173,7 @@
 	list_add(&session->slist, &target->session_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	return session;
-
+	return 0;
 out:
 	if (session->cmnd_pool)
 		mempool_destroy(session->cmnd_pool);
@@ -183,8 +181,97 @@
 	if (session->work_pool)
 		mempool_destroy(session->work_pool);
 
+	return -ENOMEM;
+}
+
+static void session_init_handler(void *data)
+{
+	struct list_head *head = (struct list_head *) data;
+	struct atomic_session_args *ssa = NULL;
+	unsigned long flags;
+	int err;
+
+	spin_lock_irqsave(&atomic_sessions_lock, flags);
+	if (!list_empty(&atomic_sessions)) {
+		ssa = list_entry(head->next, struct atomic_session_args, list);
+		list_del(&ssa->list);
+	}
+	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
+
+	if (!ssa)
+		return;
+
+	err = session_init(ssa->session, ssa->max_cmnds);
+	if (err)
+		kfree(ssa->session);
+
+	ssa->done(ssa->arg, err ? NULL : ssa->session);
+
+	kfree(ssa);
+}
+
+static int session_atomic_init(struct stgt_session *session,
+			       int max_cmnds,
+			       void (*done) (void *, struct stgt_session *),
+			       int *arg)
+{
+	struct atomic_session_args *ssa;
+	unsigned long flags;
+
+	ssa = kmalloc(sizeof(*ssa), GFP_ATOMIC);
+	if (!ssa)
+		return -ENOMEM;
+
+	ssa->session = session;
+	ssa->max_cmnds = max_cmnds;
+	ssa->arg = arg;
+
+	spin_lock_irqsave(&atomic_sessions_lock, flags);
+	list_add(&ssa->list, &atomic_sessions);
+	spin_unlock_irqrestore(&atomic_sessions_lock, flags);
+
+	schedule_work(&atomic_session_work);
+
+	return 0;
+}
+
+struct stgt_session *
+stgt_session_create(struct stgt_target *target,
+		    int max_cmnds,
+		    void (*done)(void *, struct stgt_session *),
+		    void *arg)
+{
+	struct stgt_session *session;
+
+	if (!target) {
+		eprintk("%s\n", "Null target pointer!");
+		return NULL;
+	}
+
+	dprintk("%p %d\n", target, max_cmnds);
+
+	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
+	if (!session)
+		return NULL;
+
+	memset(session, 0, sizeof(*session));
+	session->target = target;
+	INIT_LIST_HEAD(&session->slist);
+
+	if (done) {
+		if (session_atomic_init(session, max_cmnds, done, arg) < 0)
+			goto out;
+
+		return session;
+	}
+
+	if (session_init(session, max_cmnds) < 0)
+		goto out;
+
+	return session;
+
+out:
 	kfree(session);
-
 	return NULL;
 }
 EXPORT_SYMBOL(stgt_session_create);
@@ -539,6 +626,7 @@
 	int i, err = -ENOMEM;
 
 	spin_lock_init(&all_targets_lock);
+	spin_lock_init(&atomic_sessions_lock);
 	spin_lock_init(&cmnd_hash_lock);
 
 	cmnd_slab = kmem_cache_create("stgt_cmnd", sizeof(struct stgt_cmnd), 0,

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-08-17 07:41:44 UTC (rev 6)
+++ trunk/kernel/stgt.h	2005-08-18 18:07:21 UTC (rev 7)
@@ -54,8 +54,10 @@
 extern struct stgt_target *stgt_target_create(void);
 extern int stgt_target_destroy(struct stgt_target *target);
 
-extern struct stgt_session *stgt_session_create(struct stgt_target *target,
-						void (*done)(void *), int nr);
+extern struct stgt_session *
+stgt_session_create(struct stgt_target *target,
+		    int max_cmnds,
+		    void (*done)(void *, struct stgt_session *), void *arg);
 extern int stgt_session_destroy(struct stgt_session *session);
 
 extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session);



From tomo at berlios.de  Thu Aug 18 20:10:22 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 18 Aug 2005 20:10:22 +0200
Subject: [Stgt-svn] r8 - trunk/iscsi/kernel
Message-ID: <200508181810.j7IIAMl1028353@sheep.berlios.de>

Author: tomo
Date: 2005-08-18 20:10:22 +0200 (Thu, 18 Aug 2005)
New Revision: 8

Modified:
   trunk/iscsi/kernel/session.c
Log:
Adjust iet_session_alloc() to the new interface of stgt_session_create().

Modified: trunk/iscsi/kernel/session.c
===================================================================
--- trunk/iscsi/kernel/session.c	2005-08-18 18:07:21 UTC (rev 7)
+++ trunk/iscsi/kernel/session.c	2005-08-18 18:10:22 UTC (rev 8)
@@ -59,7 +59,7 @@
 
 	list_add(&session->list, &target->session_list);
 
-	session->sts = stgt_session_create(target->stt, NULL, 64);
+	session->sts = stgt_session_create(target->stt, 64, NULL, NULL);
 
 	return 0;
 err:



From tomo at berlios.de  Thu Aug 18 20:12:22 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 18 Aug 2005 20:12:22 +0200
Subject: [Stgt-svn] r9 - trunk/kernel
Message-ID: <200508181812.j7IICM0t028469@sheep.berlios.de>

Author: tomo
Date: 2005-08-18 20:12:22 +0200 (Thu, 18 Aug 2005)
New Revision: 9

Modified:
   trunk/kernel/stgt.c
Log:
Add strict arg check to stgt_session_create().

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-18 18:10:22 UTC (rev 8)
+++ trunk/kernel/stgt.c	2005-08-18 18:12:22 UTC (rev 9)
@@ -248,6 +248,11 @@
 		return NULL;
 	}
 
+	if (done && !arg) {
+		eprintk("%s\n", "Need arg !");
+		return NULL;
+	}
+
 	dprintk("%p %d\n", target, max_cmnds);
 
 	session = kmalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);



From tomo at berlios.de  Thu Aug 18 20:18:56 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Thu, 18 Aug 2005 20:18:56 +0200
Subject: [Stgt-svn] r10 - trunk/kernel
Message-ID: <200508181818.j7IIIueP028665@sheep.berlios.de>

Author: tomo
Date: 2005-08-18 20:18:56 +0200 (Thu, 18 Aug 2005)
New Revision: 10

Modified:
   trunk/kernel/stgt.c
Log:
Small cleanups on stgt_work stuff.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-18 18:12:22 UTC (rev 9)
+++ trunk/kernel/stgt.c	2005-08-18 18:18:56 UTC (rev 10)
@@ -78,6 +78,23 @@
 	struct list_head list;
 };
 
+static struct stgt_work * stgt_init_work(struct stgt_session *session,
+					 void (*fn)(void *), void *arg)
+{
+	struct stgt_work *work;
+	mempool_t *pool = session->work_pool;
+
+	work = mempool_alloc(pool, GFP_ATOMIC);
+	if (!work)
+		return NULL;
+
+	work->fn = fn;
+	work->arg = arg;
+	work->pool = pool;
+
+	return work;
+}
+
 static void stgt_worker(void *data)
 {
 	struct stgt_target *target = (struct stgt_target *) data;
@@ -410,13 +427,10 @@
 	assert(list_empty(&cmnd->clist));
 
 	if (done) {
+		struct stgt_session *session = cmnd->session;
 		struct stgt_work *work;
-		struct stgt_session *session = cmnd->session;
 
-		work = mempool_alloc(session->work_pool, GFP_ATOMIC);
-		work->fn = alloc_buffer;
-		work->arg = cmnd;
-		work->pool = session->work_pool;
+		work = stgt_init_work(session, alloc_buffer, cmnd);
 		stgt_queue_work(session->target, work);
 		return;
 	};
@@ -514,11 +528,9 @@
 		return -EINVAL;
 	}
 
-	work = mempool_alloc(session->work_pool, GFP_ATOMIC);
-	work->fn = virtual_disk_handler;
-	work->arg = cmnd;
-	work->pool =session->work_pool;
-
+	work = stgt_init_work(session, virtual_disk_handler, cmnd);
+	if (!work)
+		return -ENOMEM;
 	stgt_queue_work(session->target, work);
 
 	return 0;



From tomo at berlios.de  Fri Aug 19 03:50:53 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 19 Aug 2005 03:50:53 +0200
Subject: [Stgt-svn] r11 - in trunk: include kernel usr
Message-ID: <200508190150.j7J1orZC026728@sheep.berlios.de>

Author: tomo
Date: 2005-08-19 03:50:52 +0200 (Fri, 19 Aug 2005)
New Revision: 11

Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/usr/stgtd.c
Log:
Cleanup of user-kernel events.

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-08-18 18:18:56 UTC (rev 10)
+++ trunk/include/stgt_if.h	2005-08-19 01:50:52 UTC (rev 11)
@@ -7,10 +7,12 @@
 #define __SCSI_TARGET_IF_H
 
 enum stgt_event_type {
-	STGT_KEVENT_START = 10,
-	STGT_UEVENT_SCSI_CMND_REQ,
+	/* user -> kernel */
+	STGT_UEVENT_START,
+	STGT_UEVENT_SCSI_CMND_RES,
 
-	STGT_KEVENT_SCSI_CMND_RES,
+	/* user <- kernel */
+	STGT_KEVENT_SCSI_CMND_REQ,
 };
 
 struct stgt_event {

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-18 18:18:56 UTC (rev 10)
+++ trunk/kernel/stgt.c	2005-08-19 01:50:52 UTC (rev 11)
@@ -452,7 +452,7 @@
 
 	dprintk("%d %Zd %Zd\n", len, sizeof(*ev), sizeof(cmnd->scb));
 	nlh = __nlmsg_put(skb, daemon_pid, 0,
-			  STGT_UEVENT_SCSI_CMND_REQ, len - sizeof(*nlh), 0);
+			  STGT_KEVENT_SCSI_CMND_REQ, len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 
@@ -569,10 +569,10 @@
 	dprintk("%d %d\n", daemon_pid, nlh->nlmsg_type);
 
 	switch (nlh->nlmsg_type) {
-	case STGT_KEVENT_START:
+	case STGT_UEVENT_START:
 		dprintk("start %d\n", daemon_pid);
 		break;
-	case STGT_KEVENT_SCSI_CMND_RES:
+	case STGT_UEVENT_SCSI_CMND_RES:
 		dprintk("start %llu\n", ev->u.msg_scsi_cmnd.cid);
 		cmnd = find_cmnd_by_id(ev->u.msg_scsi_cmnd.cid);
 		if (cmnd)

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-18 18:18:56 UTC (rev 10)
+++ trunk/usr/stgtd.c	2005-08-19 01:50:52 UTC (rev 11)
@@ -114,7 +114,7 @@
 	iov.iov_base = &ev;
 	iov.iov_len = sizeof(ev);
 
-	if ((res = nl_write(nl_fd, STGT_KEVENT_START, &iov, 1)) < 0) {
+	if ((res = nl_write(nl_fd, STGT_UEVENT_START, &iov, 1)) < 0) {
 		return res;
 	}
 
@@ -166,7 +166,7 @@
 	iov[1].iov_base = sendbuf;
 	iov[1].iov_len = err;
 
-	err = nl_write(fd, STGT_KEVENT_SCSI_CMND_RES, iov, err ? 2 : 1);
+	err = nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, err ? 2 : 1);
 
 	return 0;
 }
@@ -201,7 +201,7 @@
 	}
 
 	switch (nlh->nlmsg_type) {
-	case STGT_UEVENT_SCSI_CMND_REQ:
+	case STGT_KEVENT_SCSI_CMND_REQ:
 		memset(sendbuf, 0, sizeof(sendbuf));
 		execute_cmnd(fd, recvbuf, sendbuf);
 		break;



From tomo at berlios.de  Fri Aug 19 06:50:23 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 19 Aug 2005 06:50:23 +0200
Subject: [Stgt-svn] r12 - trunk/kernel
Message-ID: <200508190450.j7J4oN1C000954@sheep.berlios.de>

Author: tomo
Date: 2005-08-19 06:50:13 +0200 (Fri, 19 Aug 2005)
New Revision: 12

Modified:
   trunk/kernel/stgt.c
Log:
Fix uspace_cmnd_done() for zero-byte commands.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-19 01:50:52 UTC (rev 11)
+++ trunk/kernel/stgt.c	2005-08-19 04:50:13 UTC (rev 12)
@@ -412,7 +412,7 @@
 
 	set_offset_and_length(cmnd->scb, &offset, &len);
 
-	dprintk("%x %llu %u", cmnd->scb[0], offset, len);
+	dprintk("%x %llu %u\n", cmnd->scb[0], offset, len);
 	__alloc_buffer(cmnd, len, offset);
 
 	if (cmnd->done) {
@@ -479,9 +479,11 @@
 
 	dprintk("%x %u\n", cmnd->scb[0], datasize);
 
-	__alloc_buffer(cmnd, datasize, 0);
-	/* FIXEM: multiple pages */
-	memcpy(page_address(cmnd->sg[0].page), data, datasize);
+	if (datasize) {
+		__alloc_buffer(cmnd, datasize, 0);
+		/* FIXEM: multiple pages */
+		memcpy(page_address(cmnd->sg[0].page), data, datasize);
+	}
 
 	cmnd_done(cmnd);
 }



From tomo at berlios.de  Fri Aug 19 06:55:40 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 19 Aug 2005 06:55:40 +0200
Subject: [Stgt-svn] r13 - trunk/kernel
Message-ID: <200508190455.j7J4tecr004691@sheep.berlios.de>

Author: tomo
Date: 2005-08-19 06:54:53 +0200 (Fri, 19 Aug 2005)
New Revision: 13

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
Log:
Add initial logical unit code.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-19 04:50:13 UTC (rev 12)
+++ trunk/kernel/stgt.c	2005-08-19 04:54:53 UTC (rev 13)
@@ -146,7 +146,7 @@
 	spin_lock_init(&target->lock);
 
 	INIT_LIST_HEAD(&target->session_list);
-	INIT_LIST_HEAD(&target->lu_list);
+	INIT_LIST_HEAD(&target->device_list);
 	INIT_LIST_HEAD(&target->work_list);
 
 	INIT_WORK(&target->work, stgt_worker, target);
@@ -308,6 +308,61 @@
 }
 EXPORT_SYMBOL(stgt_session_destroy);
 
+struct stgt_device *
+stgt_device_create(struct stgt_target *target, char *path, uint32_t lun,
+		   unsigned long dflags)
+{
+	struct stgt_device *device;
+	unsigned long flags;
+
+	if (!target)
+		return NULL;
+
+	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device)
+		return NULL;
+
+	memset(device, 0, sizeof(*device));
+
+	device->lun = lun;
+	device->path = kmalloc(strlen(path) + 1, GFP_KERNEL);
+	if (!device->path)
+		goto out;
+	strcpy(device->path, path);
+	device->path[strlen(path)] = '\0';
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_add(&device->dlist, &target->device_list);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return device;
+out:
+	if (device)
+		kfree(device->path);
+	kfree(device);
+	return NULL;
+}
+EXPORT_SYMBOL(stgt_device_create);
+
+int stgt_device_destroy(struct stgt_device *device)
+{
+	struct stgt_target *target = device->target;
+	unsigned long flags;
+
+	if (!device)
+		return -EINVAL;
+
+	spin_lock_irqsave(&target->lock, flags);
+	list_del(&device->dlist);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	kfree(device->path);
+	kfree(device);
+
+	return 0;
+}
+EXPORT_SYMBOL(stgt_device_destroy);
+
 struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session)
 {
 	static uint64_t cid = 0;

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-08-19 04:50:13 UTC (rev 12)
+++ trunk/kernel/stgt.h	2005-08-19 04:54:53 UTC (rev 13)
@@ -9,11 +9,12 @@
 #include <scsi/scsi_cmnd.h>
 
 struct stgt_target {
-	spinlock_t lock; /* session_list, work_list */
+	/* Protects session_list, work_list, device_list */
+	spinlock_t lock;
 
 	struct list_head tlist;
 
-	struct list_head lu_list;
+	struct list_head device_list;
 	struct list_head session_list;
 
 	struct work_struct work;
@@ -51,6 +52,16 @@
 	void *private;
 };
 
+struct stgt_device {
+	char *path;
+	uint32_t lun;
+	uint32_t blk_shift;
+	uint64_t blk_count;
+
+	struct stgt_target *target;
+	struct list_head dlist;
+};
+
 extern struct stgt_target *stgt_target_create(void);
 extern int stgt_target_destroy(struct stgt_target *target);
 
@@ -62,10 +73,14 @@
 
 extern struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session);
 extern void stgt_cmnd_destroy(struct stgt_cmnd *cmnd);
-
 extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
 			   void (*done)(struct stgt_cmnd *));
 
+extern struct stgt_device*
+stgt_device_create(struct stgt_target *target, char *path, uint32_t lun,
+		   unsigned long dflags);
+extern int stgt_device_destroy(struct stgt_device *device);
+
 #endif



From tomo at berlios.de  Tue Aug 23 11:29:24 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 23 Aug 2005 11:29:24 +0200
Subject: [Stgt-svn] r14 - in trunk/iscsi: include kernel usr
Message-ID: <200508230929.j7N9TOAc006380@sheep.berlios.de>

Author: tomo
Date: 2005-08-23 11:29:23 +0200 (Tue, 23 Aug 2005)
New Revision: 14

Added:
   trunk/iscsi/include/iscsi_proto.h
Removed:
   trunk/iscsi/kernel/iscsi_proto.h
   trunk/iscsi/usr/iscsi_hdr.h
Modified:
   trunk/iscsi/usr/conn.c
   trunk/iscsi/usr/ietd.c
   trunk/iscsi/usr/iscsid.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/session.c
   trunk/iscsi/usr/types.h
Log:
Use open-iscsi iscsi_proto.h instead of Ardis iscsi_hdr.h in user space.

Copied: trunk/iscsi/include/iscsi_proto.h (from rev 13, trunk/iscsi/kernel/iscsi_proto.h)

Deleted: trunk/iscsi/kernel/iscsi_proto.h
===================================================================
--- trunk/iscsi/kernel/iscsi_proto.h	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/kernel/iscsi_proto.h	2005-08-23 09:29:23 UTC (rev 14)
@@ -1,587 +0,0 @@
-/*
- * RFC 3720 (iSCSI) protocol data types
- *
- * Copyright (C) 2005 Dmitry Yusupov
- * Copyright (C) 2005 Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#ifndef ISCSI_PROTO_H
-#define ISCSI_PROTO_H
-
-#define ISCSI_VERSION_STR	"0.3"
-#define ISCSI_DATE_STR		"22-Apr-2005"
-#define ISCSI_DRAFT20_VERSION	0x00
-
-/* default iSCSI listen port for incoming connections */
-#define ISCSI_LISTEN_PORT	3260
-
-/* Padding word length */
-#define PAD_WORD_LEN		4
-
-/*
- * useful common(control and data pathes) macro
- */
-#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
-#define hton24(p, v) { \
-        p[0] = (((v) >> 16) & 0xFF); \
-        p[1] = (((v) >> 8) & 0xFF); \
-        p[2] = ((v) & 0xFF); \
-}
-#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
-
-/*
- * iSCSI Template Message Header
- */
-struct iscsi_hdr {
-	uint8_t		opcode;
-	uint8_t		flags;		/* Final bit */
-	uint8_t		rsvd2[2];
-	uint8_t		hlength;	/* AHSs total length */
-	uint8_t		dlength[3];	/* Data length */
-	uint8_t		lun[8];
-	__be32		itt;		/* Initiator Task Tag */
-	__be32		ttt;		/* Target Task Tag */
-	__be32		statsn;
-	__be32		exp_statsn;
-	__be32		max_statsn;
-	uint8_t		other[12];
-};
-
-/************************* RFC 3720 Begin *****************************/
-
-#define ISCSI_RESERVED_TAG		0xffffffff
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Initiator Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TMFUNC		0x02
-#define ISCSI_OP_LOGIN			0x03
-#define ISCSI_OP_TEXT			0x04
-#define ISCSI_OP_SCSI_DATA_OUT		0x05
-#define ISCSI_OP_LOGOUT			0x06
-#define ISCSI_OP_SNACK			0x10
-
-#define ISCSI_OP_VENDOR1_CMD		0x1c
-#define ISCSI_OP_VENDOR2_CMD		0x1d
-#define ISCSI_OP_VENDOR3_CMD		0x1e
-#define ISCSI_OP_VENDOR4_CMD		0x1f
-
-/* Target Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_CMD_RSP		0x21
-#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_IN		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T			0x31
-#define ISCSI_OP_ASYNC_EVENT		0x32
-#define ISCSI_OP_REJECT			0x3f
-
-struct iscsi_ahs_hdr {
-	__be16 ahslength;
-	uint8_t ahstype;
-	uint8_t ahspec[5];
-};
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-/* iSCSI PDU Header */
-struct iscsi_cmd {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16 rsvd2;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32 itt;	/* Initiator Task Tag */
-	__be32 data_length;
-	__be32 cmdsn;
-	__be32 exp_statsn;
-	uint8_t cdb[16];	/* SCSI Command Block */
-	/* Additional Data (Command Dependent) */
-};
-
-/* Command PDU flags */
-#define ISCSI_FLAG_CMD_FINAL		0x80
-#define ISCSI_FLAG_CMD_READ		0x40
-#define ISCSI_FLAG_CMD_WRITE		0x20
-#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
-
-/* SCSI Command Attribute values */
-#define ISCSI_ATTR_UNTAGGED		0
-#define ISCSI_ATTR_SIMPLE		1
-#define ISCSI_ATTR_ORDERED		2
-#define ISCSI_ATTR_HEAD_OF_QUEUE	3
-#define ISCSI_ATTR_ACA			4
-
-struct iscsi_rlength_ahdr {
-	__be16 ahslength;
-	uint8_t ahstype;
-	uint8_t reserved;
-	__be32 read_length;
-};
-
-/* SCSI Response Header */
-struct iscsi_cmd_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;
-	uint8_t cmd_status;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd1;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	exp_datasn;
-	__be32	bi_residual_count;
-	__be32	residual_count;
-	/* Response or Sense Data (optional) */
-};
-
-/* Command Response PDU flags */
-#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
-#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
-#define ISCSI_FLAG_CMD_OVERFLOW		0x04
-#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
-
-/* iSCSI Status values. Valid if Rsp Selector bit is not set */
-#define ISCSI_STATUS_CMD_COMPLETED	0
-#define ISCSI_STATUS_TARGET_FAILURE	1
-#define ISCSI_STATUS_SUBSYS_FAILURE	2
-
-/* Asynchronous Event Header */
-struct iscsi_async {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	uint8_t rsvd4[8];
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t async_event;
-	uint8_t async_vcode;
-	__be16	param1;
-	__be16	param2;
-	__be16	param3;
-	uint8_t rsvd5[4];
-};
-
-/* iSCSI Event Codes */
-#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
-#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
-#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
-#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
-#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
-#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
-
-/* NOP-Out Message */
-struct iscsi_nopout {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16	rsvd2;
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd4[16];
-};
-
-/* NOP-In Message */
-struct iscsi_nopin {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16	rsvd2;
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd4[12];
-};
-
-/* SCSI Task Management Message Header */
-struct iscsi_tm {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd1[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rtt;	/* Reference Task Tag */
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	__be32	refcmdsn;
-	__be32	exp_datasn;
-	uint8_t rsvd2[8];
-};
-
-#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
-
-/* Function values */
-#define ISCSI_TM_FUNC_ABORT_TASK		1
-#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
-#define ISCSI_TM_FUNC_CLEAR_ACA			3
-#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
-#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
-#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
-#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
-#define ISCSI_TM_FUNC_TASK_REASSIGN		8
-
-/* SCSI Task Management Response Header */
-struct iscsi_tm_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;	/* see Response values below */
-	uint8_t qualifier;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd2[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rtt;	/* Reference Task Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd3[12];
-};
-
-/* Response values */
-#define ISCSI_TMF_RSP_COMPLETE		0x00
-#define ISCSI_TMF_RSP_NO_TASK		0x01
-#define ISCSI_TMF_RSP_NO_LUN		0x02
-#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
-#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
-#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
-#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
-#define ISCSI_TMF_RSP_REJECTED		0xff
-
-/* Ready To Transfer Header */
-struct iscsi_r2t_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t	hlength;
-	uint8_t	dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	r2tsn;
-	__be32	data_offset;
-	__be32	data_length;
-};
-
-/* SCSI Data Hdr */
-struct iscsi_data {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	rsvd4;
-	__be32	exp_statsn;
-	__be32	rsvd5;
-	__be32	datasn;
-	__be32	offset;
-	__be32	rsvd6;
-	/* Payload */
-};
-
-/* SCSI Data Response Hdr */
-struct iscsi_data_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2;
-	uint8_t cmd_status;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	datasn;
-	__be32	offset;
-	__be32	residual_count;
-};
-
-/* Data Response PDU flags */
-#define ISCSI_FLAG_DATA_ACK		0x40
-#define ISCSI_FLAG_DATA_OVERFLOW	0x04
-#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
-#define ISCSI_FLAG_DATA_STATUS		0x01
-
-/* Text Header */
-struct iscsi_text {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd4[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd5[16];
-	/* Text - key=value pairs */
-};
-
-#define ISCSI_FLAG_TEXT_CONTINUE	0x40
-
-/* Text Response Header */
-struct iscsi_text_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd4[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd5[12];
-	/* Text Response - key:value pairs */
-};
-
-/* Login Header */
-struct iscsi_login {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t max_version;	/* Max. version supported */
-	uint8_t min_version;	/* Min. version supported */
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t isid[6];	/* Initiator Session ID */
-	__be16	tsih;	/* Target Session Handle */
-	__be32	itt;	/* Initiator Task Tag */
-	__be16	cid;
-	__be16	rsvd3;
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd5[16];
-};
-
-/* Login PDU flags */
-#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
-#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
-#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
-#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
-
-#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
-	((flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) >> 2)
-#define ISCSI_LOGIN_NEXT_STAGE(flags) \
-	(flags & ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
-
-/* Login Response Header */
-struct iscsi_login_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t max_version;	/* Max. version supported */
-	uint8_t active_version;	/* Active version */
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t isid[6];	/* Initiator Session ID */
-	__be16	tsih;	/* Target Session Handle */
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd3;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t status_class;	/* see Login RSP ststus classes below */
-	uint8_t status_detail;	/* see Login RSP Status details below */
-	uint8_t rsvd4[10];
-};
-
-/* Login stage (phase) codes for CSG, NSG */
-#define ISCSI_INITIAL_LOGIN_STAGE		-1
-#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
-#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
-#define ISCSI_FULL_FEATURE_PHASE		3
-
-/* Login Status response classes */
-#define ISCSI_STATUS_CLS_SUCCESS		0x00
-#define ISCSI_STATUS_CLS_REDIRECT		0x01
-#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
-#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
-#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
-#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
-#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
-#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
-#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
-#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
-#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
-#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
-
-/* Logout Header */
-struct iscsi_logout {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd1[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd2[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be16	cid;
-	uint8_t rsvd3[2];
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd4[16];
-};
-
-/* Logout PDU flags */
-#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
-
-/* logout reason_code values */
-
-#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
-#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
-#define ISCSI_LOGOUT_REASON_RECOVERY		2
-#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
-
-/* Logout Response Header */
-struct iscsi_logout_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;	/* see Logout response values below */
-	uint8_t rsvd2;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd3[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd4;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	rsvd5;
-	__be16	t2wait;
-	__be16	t2retain;
-	__be32	rsvd6;
-};
-
-/* logout response status values */
-
-#define ISCSI_LOGOUT_SUCCESS			0
-#define ISCSI_LOGOUT_CID_NOT_FOUND		1
-#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
-#define ISCSI_LOGOUT_CLEANUP_FAILED		3
-
-/* SNACK Header */
-struct iscsi_snack {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[14];
-	__be32	itt;
-	__be32	begrun;
-	__be32	runlength;
-	__be32	exp_statsn;
-	__be32	rsvd3;
-	__be32	exp_datasn;
-	uint8_t rsvd6[8];
-};
-
-/* SNACK PDU flags */
-#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
-
-/* Reject Message Header */
-struct iscsi_reject {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t reason;
-	uint8_t rsvd2;
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t rsvd4[16];
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	datasn;
-	uint8_t rsvd5[8];
-	/* Text - Rejected hdr */
-};
-
-/* Reason for Reject */
-#define CMD_BEFORE_LOGIN	1
-#define DATA_DIGEST_ERROR	2
-#define DATA_SNACK_REJECT	3
-#define ISCSI_PROTOCOL_ERROR	4
-#define CMD_NOT_SUPPORTED	5
-#define IMM_CMD_REJECT		6
-#define TASK_IN_PROGRESS	7
-#define INVALID_SNACK		8
-#define BOOKMARK_REJECTED	9
-#define BOOKMARK_NO_RESOURCES	10
-#define NEGOTIATION_RESET	11
-
-/* Max. number of Key=Value pairs in a text message */
-#define MAX_KEY_VALUE_PAIRS	8192
-
-/* maximum length for text keys/values */
-#define KEY_MAXLEN		64
-#define VALUE_MAXLEN		255
-#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
-
-#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
-
-/************************* RFC 3720 End *****************************/
-
-#endif /* ISCSI_PROTO_H */

Modified: trunk/iscsi/usr/conn.c
===================================================================
--- trunk/iscsi/usr/conn.c	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/conn.c	2005-08-23 09:29:23 UTC (rev 14)
@@ -46,7 +46,7 @@
 	int err = -ENOENT, find = 0;
 
 	t_tid = conn->tid;
-	t_sid = conn->session->sid.id64;
+	t_sid = sid64(conn->session->isid, conn->session->tsih);
 	t_cid = conn->cid;
 
 	if ((f = fopen(PROC_SESSION, "r")) == NULL) {
@@ -104,12 +104,14 @@
 void conn_take_fd(struct connection *conn, int fd)
 {
 	int err;
+	uint64_t sid = sid64(conn->isid, conn->tsih);
+
 	log_debug(1, "conn_take_fd: %d %u %u %u %" PRIx64,
-		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, conn->sid.id64);
+		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;
 
-	err = ki->conn_create(conn->tid, conn->session->sid.id64, conn->cid,
+	err = ki->conn_create(conn->tid, sid, conn->cid,
 			      conn->stat_sn, conn->exp_stat_sn, fd,
 			      conn->session_param[key_header_digest].val,
 			      conn->session_param[key_data_digest].val);

Modified: trunk/iscsi/usr/ietd.c
===================================================================
--- trunk/iscsi/usr/ietd.c	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/ietd.c	2005-08-23 09:29:23 UTC (rev 14)
@@ -103,7 +103,7 @@
 	int i, sock, opt;
 
 	memset(servname, 0, sizeof(servname));
-	snprintf(servname, sizeof(servname), "%d", ISCSI_TARGET_DEFAULT_PORT);
+	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_socktype = SOCK_STREAM;
@@ -265,10 +265,10 @@
 				switch (conn->iostate) {
 				case IOSTATE_READ_BHS:
 					conn->iostate = IOSTATE_READ_AHS_DATA;
-					conn->req.ahssize = conn->req.bhs.ahslength * 4;
-					conn->req.datasize = ((conn->req.bhs.datalength[0] << 16) +
-							      (conn->req.bhs.datalength[1] << 8) +
-							      conn->req.bhs.datalength[2]);
+					conn->req.ahssize =
+						conn->req.bhs.hlength * 4;
+					conn->req.datasize =
+						ntoh24(conn->req.bhs.dlength);
 					conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
 					if (conn->rwsize) {
 						if (!conn->req_buffer)
@@ -466,7 +466,7 @@
 
 	if (use_isns) {
 		if (initialize_iet_isns(isns_ip,
-					ISCSI_TARGET_DEFAULT_PORT) < 0)
+					ISCSI_LISTEN_PORT) < 0)
 			use_isns = 0;
 	}
 

Deleted: trunk/iscsi/usr/iscsi_hdr.h
===================================================================
--- trunk/iscsi/usr/iscsi_hdr.h	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/iscsi_hdr.h	2005-08-23 09:29:23 UTC (rev 14)
@@ -1,213 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef ISCSI_HDR_H
-#define ISCSI_HDR_H
-
-#define ISCSI_VERSION			0
-
-#define __packed __attribute__ ((packed))
-
-struct iscsi_hdr {
-	u8  opcode;			/* 0 */
-	u8  flags;
-	u8  spec1[2];
-	u8  ahslength;			/* 4 */
-	u8  datalength[3];
-	u16 lun[4];			/* 8 */
-	u32 itt;			/* 16 */
-	u32 ttt;			/* 20 */
-	u32 sn;				/* 24 */
-	u32 exp_sn;			/* 28 */
-	u32 max_sn;			/* 32 */
-	u32 spec3[3];			/* 36 */
-} __packed;				/* 48 */
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Client to Server Message Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TASK_MGT_MSG	0x02
-#define ISCSI_OP_LOGIN_CMD		0x03
-#define ISCSI_OP_TEXT_CMD		0x04
-#define ISCSI_OP_SCSI_DATA		0x05
-#define ISCSI_OP_LOGOUT_CMD		0x06
-#define ISCSI_OP_SNACK_CMD		0x10
-
-/* Server to Client Message Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_RSP		0x21
-#define ISCSI_OP_SCSI_TASK_MGT_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_RSP		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T_RSP		0x31
-#define ISCSI_OP_ASYNC_EVENT		0x32
-#define ISCSI_OP_REJECT_MSG		0x3f
-
-struct iscsi_ahs_hdr {
-	u16 ahslength;
-	u8 ahstype;
-} __packed;
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-union iscsi_sid {
-	struct {
-		u8 isid[6];		/* Initiator Session ID */
-		u16 tsih;		/* Target Session ID */
-	} id;
-	u64 id64;
-} __packed;
-
-struct iscsi_text_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd3[4];
-} __packed;
-
-struct iscsi_text_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 ttt;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd3[3];
-} __packed;
-
-struct iscsi_login_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  min_version;		/* Min. version supported */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u16 cid;			/* Connection ID */
-	u16 rsvd1;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd2[4];
-} __packed;
-
-struct iscsi_login_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  max_version;		/* Max. version supported */
-	u8  active_version;		/* Active version */
-	u8  ahslength;
-	u8  datalength[3];
-	union iscsi_sid sid;
-	u32 itt;			/* Initiator Task Tag */
-	u32 rsvd1;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u8  status_class;		/* see Login RSP ststus classes below */
-	u8  status_detail;		/* see Login RSP Status details below */
-	u8  rsvd2[10];
-} __packed;
-
-#define ISCSI_FLG_FINAL			0x80
-#define ISCSI_FLG_TRANSIT		0x80
-#define ISCSI_FLG_CSG_SECURITY		0x00
-#define ISCSI_FLG_CSG_LOGIN		0x04
-#define ISCSI_FLG_CSG_FULL_FEATURE	0x0c
-#define ISCSI_FLG_CSG_MASK		0x0c
-#define ISCSI_FLG_NSG_SECURITY		0x00
-#define ISCSI_FLG_NSG_LOGIN		0x01
-#define ISCSI_FLG_NSG_FULL_FEATURE	0x03
-#define ISCSI_FLG_NSG_MASK		0x03
-
-/* Login Status response classes */
-#define ISCSI_STATUS_SUCCESS		0x00
-#define ISCSI_STATUS_REDIRECT		0x01
-#define ISCSI_STATUS_INITIATOR_ERR	0x02
-#define ISCSI_STATUS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_STATUS_INIT_ERR		0x00
-#define ISCSI_STATUS_AUTH_FAILED	0x01
-#define ISCSI_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_STATUS_TGT_REMOVED	0x04
-#define ISCSI_STATUS_NO_VERSION		0x05
-#define ISCSI_STATUS_TOO_MANY_CONN	0x06
-#define ISCSI_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_STATUS_INV_SESSION_TYPE	0x09
-#define ISCSI_STATUS_SESSION_NOT_FOUND	0x0a
-#define ISCSI_STATUS_INV_REQ_TYPE	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_STATUS_TARGET_ERROR	0x00
-#define ISCSI_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_STATUS_NO_RESOURCES	0x02
-
-struct iscsi_logout_req_hdr {
-	u8  opcode;
-	u8  flags;
-	u16 rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u16 cid;
-	u16 rsvd3;
-	u32 cmd_sn;
-	u32 exp_stat_sn;
-	u32 rsvd4[4];
-} __packed;
-
-struct iscsi_logout_rsp_hdr {
-	u8  opcode;
-	u8  flags;
-	u8  response;
-	u8  rsvd1;
-	u8  ahslength;
-	u8  datalength[3];
-	u32 rsvd2[2];
-	u32 itt;
-	u32 rsvd3;
-	u32 stat_sn;
-	u32 exp_cmd_sn;
-	u32 max_cmd_sn;
-	u32 rsvd4;
-	u16 time2wait;
-	u16 time2retain;
-	u32 rsvd5;
-} __packed;
-
-#endif	/* ISCSI_HDR_H */

Modified: trunk/iscsi/usr/iscsid.c
===================================================================
--- trunk/iscsi/usr/iscsid.c	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/iscsid.c	2005-08-23 09:29:23 UTC (rev 14)
@@ -123,7 +123,7 @@
 
 static void text_scan_security(struct connection *conn)
 {
-	struct iscsi_login_rsp_hdr *rsp = (struct iscsi_login_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	char *key, *value, *data, *nextValue;
 	int datasize;
 
@@ -160,8 +160,8 @@
 			text_key_add(conn, key, "NotUnderstood");
 	}
 	if (conn->auth_method == AUTH_UNKNOWN) {
-		rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-		rsp->status_detail = ISCSI_STATUS_AUTH_FAILED;
+		rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+		rsp->status_detail = ISCSI_LOGIN_STATUS_AUTH_FAILED;
 		conn->state = STATE_EXIT;
 	}
 }
@@ -169,22 +169,23 @@
 static void login_security_done(struct connection *conn)
 {
 	int err;
-	struct iscsi_login_req_hdr *req = (struct iscsi_login_req_hdr *)&conn->req.bhs;
-	struct iscsi_login_rsp_hdr *rsp = (struct iscsi_login_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
 	struct session *session;
 
 	if (!conn->tid)
 		return;
 
-	if ((session = session_find_name(conn->tid, conn->initiator, req->sid))) {
-		if (!req->sid.id.tsih) {
+	if ((session = session_find_name(conn->tid, conn->initiator, req->isid))) {
+		if (!req->tsih) {
+			uint64_t sid = sid64(session->isid, session->tsih);
 			/* do session reinstatement */
-			session_conns_close(conn->tid, session->sid.id64);
+			session_conns_close(conn->tid, sid);
 			session = NULL;
-		} else if (req->sid.id.tsih != session->sid.id.tsih) {
+		} else if (req->tsih != session->tsih) {
 			/* fail the login */
-			rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-			rsp->status_detail = ISCSI_STATUS_SESSION_NOT_FOUND;
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
 			return;
 		} else if ((err = conn_test(conn)) == -ENOENT) {
@@ -193,10 +194,10 @@
 		/* add a new connection to the session */
 		conn->session = session;
 	} else {
-		if (req->sid.id.tsih) {
+		if (req->tsih) {
 			/* fail the login */
-			rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-			rsp->status_detail = ISCSI_STATUS_SESSION_NOT_FOUND;
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_NO_SESSION;
 			conn->state = STATE_EXIT;
 			return;
 		}
@@ -208,7 +209,7 @@
 {
 	char *key, *value, *data;
 	int datasize, idx;
-	struct iscsi_login_rsp_hdr *rsp = (struct iscsi_login_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 
 	data = conn->req.data;
 	datasize = conn->req.datasize;
@@ -232,8 +233,10 @@
 					text_key_add_reject(conn, key);
 					continue;
 				} else {
-					rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-					rsp->status_detail = ISCSI_STATUS_INIT_ERR;
+					rsp->status_class =
+						ISCSI_STATUS_CLS_INITIATOR_ERR;
+					rsp->status_detail =
+						ISCSI_LOGIN_STATUS_INIT_ERR;
 					conn->state = STATE_EXIT;
 					goto out;
 				}
@@ -252,8 +255,10 @@
 				break;
 			case KEY_STATE_REQUEST:
 				if (val != conn->session_param[idx].val) {
-					rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-					rsp->status_detail = ISCSI_STATUS_INIT_ERR;
+					rsp->status_class =
+						ISCSI_STATUS_CLS_INITIATOR_ERR;
+					rsp->status_detail =
+						ISCSI_LOGIN_STATUS_INIT_ERR;
 					conn->state = STATE_EXIT;
 					log_warning("%s %u %u\n", key,
 					val, conn->session_param[idx].val);
@@ -302,23 +307,25 @@
 
 static void login_start(struct connection *conn)
 {
-	struct iscsi_login_req_hdr *req = (struct iscsi_login_req_hdr *)&conn->req.bhs;
-	struct iscsi_login_rsp_hdr *rsp = (struct iscsi_login_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	char *name, *alias, *session_type, *target_name;
 
 	conn->cid = be16_to_cpu(req->cid);
-	conn->sid.id64 = req->sid.id64;
-	if (!conn->sid.id64) {
-		rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-		rsp->status_detail = ISCSI_STATUS_MISSING_FIELDS;
+	memcpy(conn->isid, req->isid, sizeof(req->isid));
+	conn->tsih = req->tsih;
+
+	if (!sid64(conn->isid, conn->tsih)) {
+		rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+		rsp->status_detail = ISCSI_LOGIN_STATUS_MISSING_FIELDS;
 		conn->state = STATE_EXIT;
 		return;
 	}
 
 	name = text_key_find(conn, "InitiatorName");
 	if (!name) {
-		rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-		rsp->status_detail = ISCSI_STATUS_MISSING_FIELDS;
+		rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+		rsp->status_detail = ISCSI_LOGIN_STATUS_MISSING_FIELDS;
 		conn->state = STATE_EXIT;
 		return;
 	}
@@ -334,8 +341,8 @@
 		if (!strcmp(session_type, "Discovery"))
 			conn->session_type = SESSION_DISCOVERY;
 		else if (strcmp(session_type, "Normal")) {
-			rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-			rsp->status_detail = ISCSI_STATUS_INV_SESSION_TYPE;
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_NO_SESSION_TYPE;
 			conn->state = STATE_EXIT;
 			return;
 		}
@@ -343,16 +350,16 @@
 
 	if (conn->session_type == SESSION_NORMAL) {
 		if (!target_name) {
-			rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-			rsp->status_detail = ISCSI_STATUS_MISSING_FIELDS;
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_MISSING_FIELDS;
 			conn->state = STATE_EXIT;
 			return;
 		}
 
 		if (!(conn->tid = target_find_by_name(target_name)) ||
 		    cops->initiator_access(conn->tid, conn->fd) < 0) {
-			rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-			rsp->status_detail = ISCSI_STATUS_TGT_NOT_FOUND;
+			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
 			return;
 		}
@@ -367,8 +374,8 @@
 /* 		} */
 
 		ki->param_get(conn->tid, 0, conn->session_param);
-		conn->exp_cmd_sn = be32_to_cpu(req->cmd_sn);
-		log_debug(1, "exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmd_sn);
+		conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
+		log_debug(1, "exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmdsn);
 		conn->max_cmd_sn = conn->exp_cmd_sn;
 	}
 	text_key_add(conn, "TargetPortalGroupTag", "1");
@@ -380,11 +387,12 @@
 	case SESSION_NORMAL:
 		if (!conn->session)
 			session_create(conn);
-		conn->sid = conn->session->sid;
+		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
+		conn->tsih = conn->session->tsih;
 		break;
 	case SESSION_DISCOVERY:
 		/* set a dummy tsih value */
-		conn->sid.id.tsih = 1;
+		conn->tsih = 1;
 		break;
 	}
 }
@@ -410,33 +418,33 @@
 
 static void cmnd_exec_login(struct connection *conn)
 {
-	struct iscsi_login_req_hdr *req = (struct iscsi_login_req_hdr *)&conn->req.bhs;
-	struct iscsi_login_rsp_hdr *rsp = (struct iscsi_login_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	int stay = 0, nsg_disagree = 0;
 
 	memset(rsp, 0, BHS_SIZE);
-	if ((req->opcode & ISCSI_OPCODE_MASK) != ISCSI_OP_LOGIN_CMD ||
+	if ((req->opcode & ISCSI_OPCODE_MASK) != ISCSI_OP_LOGIN ||
 	    !(req->opcode & ISCSI_OP_IMMEDIATE)) {
 		//reject
 	}
 
 	rsp->opcode = ISCSI_OP_LOGIN_RSP;
-	rsp->max_version = ISCSI_VERSION;
-	rsp->active_version = ISCSI_VERSION;
+	rsp->max_version = ISCSI_DRAFT20_VERSION;
+	rsp->active_version = ISCSI_DRAFT20_VERSION;
 	rsp->itt = req->itt;
 
 	if (/*req->max_version < ISCSI_VERSION ||*/
-	    req->min_version > ISCSI_VERSION) {
-		rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-		rsp->status_detail = ISCSI_STATUS_NO_VERSION;
+	    req->min_version > ISCSI_DRAFT20_VERSION) {
+		rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+		rsp->status_detail = ISCSI_LOGIN_STATUS_NO_VERSION;
 		conn->state = STATE_EXIT;
 		return;
 	}
 
-	switch (req->flags & ISCSI_FLG_CSG_MASK) {
-	case ISCSI_FLG_CSG_SECURITY:
+	switch (ISCSI_LOGIN_CURRENT_STAGE(req->flags)) {
+	case ISCSI_SECURITY_NEGOTIATION_STAGE:
 		log_debug(1, "Login request (security negotiation): %d", conn->state);
-		rsp->flags = ISCSI_FLG_CSG_SECURITY;
+		rsp->flags = ISCSI_SECURITY_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
 		case STATE_FREE:
@@ -470,9 +478,9 @@
 		}
 
 		break;
-	case ISCSI_FLG_CSG_LOGIN:
+	case ISCSI_OP_PARMS_NEGOTIATION_STAGE:
 		log_debug(1, "Login request (operational negotiation): %d", conn->state);
-		rsp->flags = ISCSI_FLG_CSG_LOGIN;
+		rsp->flags = ISCSI_OP_PARMS_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
 		case STATE_FREE:
@@ -504,11 +512,12 @@
 
 	if (rsp->status_class)
 		return;
-	if (conn->state != STATE_SECURITY_AUTH && req->flags & ISCSI_FLG_TRANSIT) {
-		int nsg = req->flags & ISCSI_FLG_NSG_MASK;
+	if (conn->state != STATE_SECURITY_AUTH &&
+	    req->flags & ISCSI_FLAG_LOGIN_TRANSIT) {
+		int nsg = ISCSI_LOGIN_NEXT_STAGE(req->flags);
 
 		switch (nsg) {
-		case ISCSI_FLG_NSG_LOGIN:
+		case ISCSI_OP_PARMS_NEGOTIATION_STAGE:
 			switch (conn->state) {
 			case STATE_SECURITY:
 			case STATE_SECURITY_DONE:
@@ -519,13 +528,13 @@
 				goto init_err;
 			}
 			break;
-		case ISCSI_FLG_NSG_FULL_FEATURE:
+		case ISCSI_FULL_FEATURE_PHASE:
 			switch (conn->state) {
 			case STATE_SECURITY:
 			case STATE_SECURITY_DONE:
 				if ((nsg_disagree = text_check_param(conn))) {
 					conn->state = STATE_LOGIN;
-					nsg = ISCSI_FLG_NSG_LOGIN;
+					nsg = ISCSI_OP_PARMS_NEGOTIATION_STAGE;
 					break;
 				}
 				conn->state = STATE_SECURITY_FULL;
@@ -533,7 +542,7 @@
 				break;
 			case STATE_LOGIN:
 				if (stay)
-					nsg = ISCSI_FLG_NSG_LOGIN;
+					nsg = ISCSI_OP_PARMS_NEGOTIATION_STAGE;
 				else
 					conn->state = STATE_LOGIN_FULL;
 				break;
@@ -546,24 +555,25 @@
 		default:
 			goto init_err;
 		}
-		rsp->flags |= nsg | (stay ? 0 : ISCSI_FLG_TRANSIT);
+		rsp->flags |= nsg | (stay ? 0 : ISCSI_FLAG_LOGIN_TRANSIT);
 	}
 
-	rsp->sid = conn->sid;
-	rsp->stat_sn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmd_sn = cpu_to_be32(conn->exp_cmd_sn);
-	rsp->max_cmd_sn = cpu_to_be32(conn->max_cmd_sn);
+	memcpy(rsp->isid, conn->isid, sizeof(rsp->isid));
+	rsp->tsih = conn->tsih;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 	return;
 init_err:
 	rsp->flags = 0;
-	rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-	rsp->status_detail = ISCSI_STATUS_INIT_ERR;
+	rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+	rsp->status_detail = ISCSI_LOGIN_STATUS_INIT_ERR;
 	conn->state = STATE_EXIT;
 	return;
 auth_err:
 	rsp->flags = 0;
-	rsp->status_class = ISCSI_STATUS_INITIATOR_ERR;
-	rsp->status_detail = ISCSI_STATUS_AUTH_FAILED;
+	rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
+	rsp->status_detail = ISCSI_LOGIN_STATUS_AUTH_FAILED;
 	conn->state = STATE_EXIT;
 	return;
 }
@@ -604,7 +614,7 @@
 			if (ss.ss_family == AF_INET6)
 				 *p++ = ']';
 
-			sprintf(p, ":%d,1", ISCSI_TARGET_DEFAULT_PORT);
+			sprintf(p, ":%d,1", ISCSI_LISTEN_PORT);
 			target_list_build(conn, buf,
 					  strcmp(value, "All") ? value : NULL);
 		} else
@@ -614,8 +624,8 @@
 
 static void cmnd_exec_text(struct connection *conn)
 {
-	struct iscsi_text_req_hdr *req = (struct iscsi_text_req_hdr *)&conn->req.bhs;
-	struct iscsi_text_rsp_hdr *rsp = (struct iscsi_text_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_text *req = (struct iscsi_text *)&conn->req.bhs;
+	struct iscsi_text_rsp *rsp = (struct iscsi_text_rsp *)&conn->rsp.bhs;
 
 	memset(rsp, 0, BHS_SIZE);
 
@@ -626,37 +636,37 @@
 	rsp->itt = req->itt;
 	//rsp->ttt = rsp->ttt;
 	rsp->ttt = 0xffffffff;
-	conn->exp_cmd_sn = be32_to_cpu(req->cmd_sn);
+	conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
 	if (!(req->opcode & ISCSI_OP_IMMEDIATE))
 		conn->exp_cmd_sn++;
 
 	log_debug(1, "Text request: %d", conn->state);
 	text_scan_text(conn);
 
-	if (req->flags & ISCSI_FLG_FINAL)
-		rsp->flags = ISCSI_FLG_FINAL;
+	if (req->flags & ISCSI_FLAG_CMD_FINAL)
+		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
-	rsp->stat_sn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmd_sn = cpu_to_be32(conn->exp_cmd_sn);
-	rsp->max_cmd_sn = cpu_to_be32(conn->max_cmd_sn);
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 }
 
 static void cmnd_exec_logout(struct connection *conn)
 {
-	struct iscsi_logout_req_hdr *req = (struct iscsi_logout_req_hdr *)&conn->req.bhs;
-	struct iscsi_logout_rsp_hdr *rsp = (struct iscsi_logout_rsp_hdr *)&conn->rsp.bhs;
+	struct iscsi_logout *req = (struct iscsi_logout *)&conn->req.bhs;
+	struct iscsi_logout_rsp *rsp = (struct iscsi_logout_rsp *)&conn->rsp.bhs;
 
 	memset(rsp, 0, BHS_SIZE);
 	rsp->opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp->flags = ISCSI_FLG_FINAL;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp->itt = req->itt;
-	conn->exp_cmd_sn = be32_to_cpu(req->cmd_sn);
+	conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
 	if (!(req->opcode & ISCSI_OP_IMMEDIATE))
 		conn->exp_cmd_sn++;
 
-	rsp->stat_sn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmd_sn = cpu_to_be32(conn->exp_cmd_sn);
-	rsp->max_cmd_sn = cpu_to_be32(conn->max_cmd_sn);
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 }
 
 int cmnd_execute(struct connection *conn)
@@ -664,31 +674,27 @@
 	int res = 1;
 
 	switch (conn->req.bhs.opcode & ISCSI_OPCODE_MASK) {
-	case ISCSI_OP_LOGIN_CMD:
+	case ISCSI_OP_LOGIN:
 		//if conn->state == STATE_FULL -> reject
 		cmnd_exec_login(conn);
-		conn->rsp.bhs.ahslength = conn->rsp.ahssize / 4;
-		conn->rsp.bhs.datalength[0] = conn->rsp.datasize >> 16;
-		conn->rsp.bhs.datalength[1] = conn->rsp.datasize >> 8;
-		conn->rsp.bhs.datalength[2] = conn->rsp.datasize;
+		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
+		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
-	case ISCSI_OP_TEXT_CMD:
+	case ISCSI_OP_TEXT:
 		//if conn->state != STATE_FULL -> reject
+		printf("%s %d %u\n", __FUNCTION__, __LINE__, conn->req.datasize);
 		cmnd_exec_text(conn);
-		conn->rsp.bhs.ahslength = conn->rsp.ahssize / 4;
-		conn->rsp.bhs.datalength[0] = conn->rsp.datasize >> 16;
-		conn->rsp.bhs.datalength[1] = conn->rsp.datasize >> 8;
-		conn->rsp.bhs.datalength[2] = conn->rsp.datasize;
+		printf("%s %d %u\n", __FUNCTION__, __LINE__, conn->rsp.datasize);
+		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
+		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
-	case ISCSI_OP_LOGOUT_CMD:
+	case ISCSI_OP_LOGOUT:
 		//if conn->state != STATE_FULL -> reject
 		cmnd_exec_logout(conn);
-		conn->rsp.bhs.ahslength = conn->rsp.ahssize / 4;
-		conn->rsp.bhs.datalength[0] = conn->rsp.datasize >> 16;
-		conn->rsp.bhs.datalength[1] = conn->rsp.datasize >> 8;
-		conn->rsp.bhs.datalength[2] = conn->rsp.datasize;
+		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
+		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
 	default:

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/iscsid.h	2005-08-23 09:29:23 UTC (rev 14)
@@ -11,16 +11,22 @@
 #include <sys/types.h>
 
 #include "types.h"
-#include "iscsi_hdr.h"
 #include "iet_u.h"
 #include "param.h"
 #include "config.h"
 #include "misc.h"
+#include <iscsi_proto.h>
 
-#define ISCSI_TARGET_DEFAULT_PORT	3260
-
 #define PROC_SESSION	"/proc/net/iet/session"
 
+#define sid64(isid, tsih)					\
+({								\
+	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
+	(uint64_t) isid[2] << 16 | (uint64_t) isid[3] << 24 |	\
+	(uint64_t) isid[4] << 32 | (uint64_t) isid[5] << 40 |	\
+	(uint64_t) tsih << 48;					\
+})
+
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;
@@ -38,7 +44,8 @@
 
 	char *initiator;
 	struct target *target;
-	union iscsi_sid sid;
+	uint8_t isid[6];
+	uint16_t tsih;
 
 	int conn_cnt;
 };
@@ -54,7 +61,8 @@
 	struct iscsi_param session_param[session_key_last];
 
 	char *initiator;
-	union iscsi_sid sid;
+	uint8_t isid[6];
+	uint16_t tsih;
 	u16 cid;
 	u16 pad;
 	int session_type;
@@ -175,7 +183,7 @@
 extern void log_pdu(int level, struct PDU *pdu);
 
 /* session.c */
-extern struct session *session_find_name(u32 tid, const char *iname, union iscsi_sid sid);
+extern struct session *session_find_name(u32 tid, const char *iname, uint8_t *isid);
 extern struct session *session_find_id(u32 tid, u64 sid);
 extern void session_create(struct connection *conn);
 extern void session_remove(struct session *session);

Modified: trunk/iscsi/usr/session.c
===================================================================
--- trunk/iscsi/usr/session.c	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/session.c	2005-08-23 09:29:23 UTC (rev 14)
@@ -34,7 +34,7 @@
 	return session;
 }
 
-struct session *session_find_name(u32 tid, const char *iname, union iscsi_sid sid)
+struct session *session_find_name(u32 tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
 	struct target *target;
@@ -42,9 +42,10 @@
 	if (!(target = target_find_by_id(tid)))
 		return NULL;
 
-	log_debug(1, "session_find_name: %s %#" PRIx64, iname, sid.id64);
+	log_debug(1, "session_find_name: %s %x %x %x %x %x %x", iname,
+		  isid[0], isid[1], isid[2], isid[3], isid[4], isid[5]);
 	list_for_each_entry(session, &target->sessions_list, slist) {
-		if (!memcmp(sid.id.isid, session->sid.id.isid, 6) &&
+		if (!memcmp(isid, session->isid, sizeof(session->isid)) &&
 		    !strcmp(iname, session->initiator))
 			return session;
 	}
@@ -62,7 +63,7 @@
 
 	log_debug(1, "session_find_id: %#" PRIx64, sid);
 	list_for_each_entry(session, &target->sessions_list, slist) {
-		if (session->sid.id64 == sid)
+		if (sid64(session->isid, session->tsih) == sid)
 			return session;
 	}
 
@@ -120,42 +121,46 @@
 void session_create(struct connection *conn)
 {
 	struct session *session;
+	uint64_t sid;
 	static u16 tsih = 1;
 
 	if (!(session = session_alloc(conn->tid)))
 		return;
 
-	session->sid = conn->sid;
-	session->sid.id.tsih = tsih;
+	memcpy(session->isid, conn->isid, sizeof(session->isid));
+	session->tsih = tsih;
 
 	while (1) {
-		int err = session_test(conn->tid, session->sid.id64);
+		sid = sid64(session->isid, session->tsih);
+		int err = session_test(conn->tid, sid);
 
 		if (err == -ENOENT)
 			break;
 		else if (err < 0)
 			return;
-		session->sid.id.tsih++;
+		session->tsih++;
 	}
-	tsih = session->sid.id.tsih + 1;
+	tsih = session->tsih + 1;
 
 	conn->session = session;
 	conn->session->initiator = strdup(conn->initiator);
 
-	log_debug(1, "session_create: %#" PRIx64, session->sid.id64);
+	log_debug(1, "session_create: %#" PRIx64, sid);
 
-	ki->session_create(conn->tid, session->sid.id64, conn->exp_cmd_sn,
+	ki->session_create(conn->tid, sid, conn->exp_cmd_sn,
 			   conn->max_cmd_sn, session->initiator);
-	ki->param_set(conn->tid, session->sid.id64, key_session, 0, conn->session_param);
+	ki->param_set(conn->tid, sid, key_session, 0, conn->session_param);
 }
 
 void session_remove(struct session *session)
 {
-	log_debug(1, "session_remove: %#"  PRIx64, session->sid.id64);
+	uint64_t sid = sid64(session->isid, session->tsih);
 
-	if (!session->sid.id.tsih)
-		ki->session_destroy(session->target->tid, session->sid.id64);
+	log_debug(1, "session_remove: %#"  PRIx64, sid);
 
+	if (!session->tsih)
+		ki->session_destroy(session->target->tid, sid);
+
 	if (session->target) {
 		remque(&session->slist);
 /* 		session->target->nr_sessions--; */

Modified: trunk/iscsi/usr/types.h
===================================================================
--- trunk/iscsi/usr/types.h	2005-08-19 04:54:53 UTC (rev 13)
+++ trunk/iscsi/usr/types.h	2005-08-23 09:29:23 UTC (rev 14)
@@ -32,4 +32,7 @@
 typedef u_int32_t u32;
 typedef u_int64_t u64;
 
+typedef uint16_t __be16;
+typedef uint32_t __be32;
+
 #endif	/* TYPES_H */



From tomo at berlios.de  Tue Aug 23 11:32:45 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 23 Aug 2005 11:32:45 +0200
Subject: [Stgt-svn] r15 - trunk/iscsi/usr
Message-ID: <200508230932.j7N9Wjr5007128@sheep.berlios.de>

Author: tomo
Date: 2005-08-23 11:32:45 +0200 (Tue, 23 Aug 2005)
New Revision: 15

Modified:
   trunk/iscsi/usr/iscsid.c
Log:
Remove useless code that was commited by mistake.

Modified: trunk/iscsi/usr/iscsid.c
===================================================================
--- trunk/iscsi/usr/iscsid.c	2005-08-23 09:29:23 UTC (rev 14)
+++ trunk/iscsi/usr/iscsid.c	2005-08-23 09:32:45 UTC (rev 15)
@@ -683,9 +683,7 @@
 		break;
 	case ISCSI_OP_TEXT:
 		//if conn->state != STATE_FULL -> reject
-		printf("%s %d %u\n", __FUNCTION__, __LINE__, conn->req.datasize);
 		cmnd_exec_text(conn);
-		printf("%s %d %u\n", __FUNCTION__, __LINE__, conn->rsp.datasize);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);



From mnc at berlios.de  Tue Aug 23 19:11:26 2005
From: mnc at berlios.de (Mike Christie at BerliOS)
Date: Tue, 23 Aug 2005 19:11:26 +0200
Subject: [Stgt-svn] r16 - in trunk: iscsi/include iscsi/kernel kernel usr
Message-ID: <200508231711.j7NHBQaE008618@sheep.berlios.de>

Author: mnc
Date: 2005-08-23 19:11:24 +0200 (Tue, 23 Aug 2005)
New Revision: 16

Added:
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_sd.c
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_target.h
Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/kernel/Makefile
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/usr/Makefile
Log:
add stgt_device and stgt_target sysfs code (with stgt_sd example)

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/iscsi/include/iet_u.h	2005-08-23 17:11:24 UTC (rev 16)
@@ -112,7 +112,7 @@
 #define	MIN_NR_QUEUED_CMNDS	1
 #define	MAX_NR_QUEUED_CMNDS	256
 
-#define NETLINK_IET	11
+#define NETLINK_IET	21
 
 #define ADD_TARGET _IOW('i', 0, struct target_info)
 #define DEL_TARGET _IOW('i', 1, struct target_info)

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-23 17:11:24 UTC (rev 16)
@@ -56,6 +56,7 @@
 };
 
 struct iscsi_cmnd;
+struct stgt_target;
 
 enum iscsi_device_state {
 	IDEV_RUNNING,

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/iscsi/kernel/target.c	2005-08-23 17:11:24 UTC (rev 16)
@@ -10,6 +10,7 @@
 #include <digest.h>
 #include <iscsi_dbg.h>
 #include <stgt.h>
+#include <stgt_target.h>
 
 #define	MAX_NR_TARGETS	(1UL << 30)
 
@@ -111,6 +112,11 @@
 	nthread_stop(target);
 }
 
+static struct stgt_target_template iet_stgt_target_template = {
+	.name = "iet",
+	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
+};
+
 static int iscsi_target_create(struct target_info *info, u32 tid)
 {
 	int err = -EINVAL, len;
@@ -154,7 +160,7 @@
 		goto out;
 	}
 
-	target->stt = stgt_target_create();
+	target->stt = stgt_target_create(&iet_stgt_target_template);
 	assert(target->stt);
 
 	return 0;

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/Makefile	2005-08-23 17:11:24 UTC (rev 16)
@@ -2,10 +2,13 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_STGT=12
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_STGT=20
 
 ifneq ($(KERNELRELEASE),)
-obj-m		+= stgt.o
+obj-m		+= stgt_core.o
+stgt_core-objs	:= stgt_sysfs.o stgt.o
+
+obj-m		+= stgt_sd.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt.c	2005-08-23 17:11:24 UTC (rev 16)
@@ -2,6 +2,7 @@
  * SCSI Targets Framework
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
 
@@ -17,6 +18,8 @@
 #include <scsi/scsi.h>
 
 #include <stgt.h>
+#include <stgt_target.h>
+#include <stgt_device.h>
 #include <stgt_if.h>
 
 #define DEBUG_STGT
@@ -46,6 +49,9 @@
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
+static spinlock_t device_tmpl_lock;
+static LIST_HEAD(device_tmpl_list);
+
 static void session_init_handler(void *data);
 static spinlock_t atomic_sessions_lock;
 static LIST_HEAD(atomic_sessions);
@@ -127,7 +133,7 @@
 	schedule_work(&target->work);
 }
 
-struct stgt_target *stgt_target_create(void)
+struct stgt_target *stgt_target_create(struct stgt_target_template *stt)
 {
 	struct stgt_target *target;
 
@@ -150,7 +156,14 @@
 	INIT_LIST_HEAD(&target->work_list);
 
 	INIT_WORK(&target->work, stgt_worker, target);
+	target->stt = stt;
+	target->queued_cmnds = stt->queued_cmnds;
 
+	if (stgt_sysfs_register_target(target)) {
+		kfree(target);
+		return NULL;
+	}
+
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
@@ -165,7 +178,7 @@
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 
-	kfree(target);
+	stgt_sysfs_unregister_target(target);
 
 	return 0;
 }
@@ -308,10 +321,78 @@
 }
 EXPORT_SYMBOL(stgt_session_destroy);
 
-struct stgt_device *
-stgt_device_create(struct stgt_target *target, char *path, uint32_t lun,
-		   unsigned long dflags)
+struct device_type_internal {
+	struct stgt_device_template *sdt;
+	struct list_head list;
+};
+
+static struct stgt_device_template *device_template_get(const char *name)
 {
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &device_tmpl_list, list)
+		if (!strcmp(name, ti->sdt->name)) {
+			if (!try_module_get(ti->sdt->module))
+				ti = NULL;
+			spin_unlock_irqrestore(&device_tmpl_lock, flags);
+			return ti ? ti->sdt : NULL;
+		}
+
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void device_template_put(struct stgt_device_template *sdt)
+{
+	module_put(sdt->module);
+}
+
+int stgt_device_template_register(struct stgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&ti->list);
+	ti->sdt = sdt;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+	list_add_tail(&ti->list, &device_tmpl_list);
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stgt_device_template_register);
+
+void stgt_device_template_unregister(struct stgt_device_template *sdt)
+{
+	unsigned long flags;
+	struct device_type_internal *ti;
+
+	spin_lock_irqsave(&device_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &device_tmpl_list, list)
+		if (ti->sdt == sdt) {
+			list_del(&ti->list);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&device_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
+
+struct stgt_device *stgt_device_create(struct stgt_target *target,
+				       char *device_type, char *path,
+				       uint32_t lun, unsigned long dflags)
+{
 	struct stgt_device *device;
 	unsigned long flags;
 
@@ -325,20 +406,43 @@
 	memset(device, 0, sizeof(*device));
 
 	device->lun = lun;
-	device->path = kmalloc(strlen(path) + 1, GFP_KERNEL);
+	device->target = target;
+	device->path = kstrdup(path, GFP_KERNEL);
 	if (!device->path)
-		goto out;
-	strcpy(device->path, path);
-	device->path[strlen(path)] = '\0';
+		goto free_device;
 
+	device->sdt = device_template_get(device_type);
+	if (!device->sdt)
+		goto free_path;
+
+	device->sdt_data = kmalloc(sizeof(device->sdt->priv_data_size),
+				   GFP_KERNEL);
+	if (!device->sdt_data)
+		goto put_template;
+
+	if (device->sdt->create)
+		if (device->sdt->create(device))
+			goto free_priv_sdt_data;
+
+	if (stgt_sysfs_register_device(device))
+		goto sdt_destroy;
+
 	spin_lock_irqsave(&target->lock, flags);
 	list_add(&device->dlist, &target->device_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return device;
-out:
-	if (device)
-		kfree(device->path);
+
+sdt_destroy:
+	if (device->sdt->destroy)
+		device->sdt->destroy(device);
+free_priv_sdt_data:
+	kfree(device->sdt_data);
+put_template:
+	device_template_put(device->sdt);
+free_path:
+	kfree(device->path);
+free_device:
 	kfree(device);
 	return NULL;
 }
@@ -356,9 +460,12 @@
 	list_del(&device->dlist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	kfree(device->path);
-	kfree(device);
+	if (device->sdt->destroy)
+		device->sdt->destroy(device);
 
+	device_template_put(device->sdt);
+	stgt_sysfs_unregister_device(device);
+
 	return 0;
 }
 EXPORT_SYMBOL(stgt_device_destroy);
@@ -543,12 +650,19 @@
 	cmnd_done(cmnd);
 }
 
-static void virtual_disk_handler(void *data)
+static void queuecommand(void *data)
 {
 	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
 
 	dprintk("%x\n", cmnd->scb[0]);
 
+	/*
+	 * seperate vsd (virtual disk from sd (real sd))
+	 * call scsi_device_temaplte->prepcommand to see if they want it
+	 * and allow them to setup.
+	 *
+	 * Then call queuecommand
+	 */
 	switch (cmnd->scb[0]) {
 	case READ_6:
 	case READ_10:
@@ -585,7 +699,7 @@
 		return -EINVAL;
 	}
 
-	work = stgt_init_work(session, virtual_disk_handler, cmnd);
+	work = stgt_init_work(session, queuecommand, cmnd);
 	if (!work)
 		return -ENOMEM;
 	stgt_queue_work(session->target, work);
@@ -693,6 +807,8 @@
 
 	if (nls)
 		sock_release(nls->sk_socket);
+
+	stgt_sysfs_exit();
 }
 
 static int __init stgt_init(void)
@@ -702,7 +818,12 @@
 	spin_lock_init(&all_targets_lock);
 	spin_lock_init(&atomic_sessions_lock);
 	spin_lock_init(&cmnd_hash_lock);
+	spin_lock_init(&device_tmpl_lock);
 
+	err = stgt_sysfs_init();
+	if (err)
+		return err;
+
 	cmnd_slab = kmem_cache_create("stgt_cmnd", sizeof(struct stgt_cmnd), 0,
 				      SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
 				      NULL, NULL);

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt.h	2005-08-23 17:11:24 UTC (rev 16)
@@ -8,19 +8,6 @@
 
 #include <scsi/scsi_cmnd.h>
 
-struct stgt_target {
-	/* Protects session_list, work_list, device_list */
-	spinlock_t lock;
-
-	struct list_head tlist;
-
-	struct list_head device_list;
-	struct list_head session_list;
-
-	struct work_struct work;
-	struct list_head work_list;
-};
-
 struct stgt_session {
 	struct stgt_target *target;
 	struct list_head slist;
@@ -52,19 +39,6 @@
 	void *private;
 };
 
-struct stgt_device {
-	char *path;
-	uint32_t lun;
-	uint32_t blk_shift;
-	uint64_t blk_count;
-
-	struct stgt_target *target;
-	struct list_head dlist;
-};
-
-extern struct stgt_target *stgt_target_create(void);
-extern int stgt_target_destroy(struct stgt_target *target);
-
 extern struct stgt_session *
 stgt_session_create(struct stgt_target *target,
 		    int max_cmnds,
@@ -77,10 +51,6 @@
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
 			   void (*done)(struct stgt_cmnd *));
-
-extern struct stgt_device*
-stgt_device_create(struct stgt_target *target, char *path, uint32_t lun,
-		   unsigned long dflags);
-extern int stgt_device_destroy(struct stgt_device *device);
-
+extern int stgt_sysfs_init(void);
+extern void stgt_sysfs_exit(void);
 #endif

Added: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt_device.h	2005-08-23 17:11:24 UTC (rev 16)
@@ -0,0 +1,61 @@
+/*
+ * STGT device
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#ifndef __SCSI_STGT_DEVICE_H
+#define __SCSI_STGT_DEVICE_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+struct stgt_device;
+struct stgt_cmnd;
+
+struct stgt_device_template {
+	const char *name;
+	struct module *module;
+	unsigned priv_data_size;
+
+	int (* create)(struct stgt_device *);
+	void (* destroy)(struct stgt_device *);
+	int (* queuecommand)(struct stgt_device *device, struct stgt_cmnd *cmd);
+	int (* prepcommand)(struct stgt_device *device, struct stgt_cmnd *cmn);
+
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **device_attrs;
+};
+
+struct stgt_device {
+	struct stgt_device_template *sdt;
+	void *sdt_data;
+
+	struct class_device cdev;
+
+        char *path;
+        uint32_t lun;
+        uint32_t blk_shift;
+        uint64_t blk_count;
+
+        struct stgt_target *target;
+        struct list_head dlist;
+};
+
+#define cdev_to_stgt_device(cdev) \
+        container_of(cdev, struct stgt_device, cdev)
+
+extern struct stgt_device* stgt_device_create(struct stgt_target *target,
+					      char *device_type, char *path,
+					      uint32_t lun,
+					      unsigned long dflags);
+extern int stgt_device_destroy(struct stgt_device *device);
+extern int stgt_sysfs_register_device(struct stgt_device *device);
+extern void stgt_sysfs_unregister_device(struct stgt_device *device);
+extern int stgt_device_template_register(struct stgt_device_template *sdt);
+extern void stgt_device_template_unregister(struct stgt_device_template *sdt);
+
+#endif

Added: trunk/kernel/stgt_sd.c
===================================================================
--- trunk/kernel/stgt_sd.c	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt_sd.c	2005-08-23 17:11:24 UTC (rev 16)
@@ -0,0 +1,137 @@
+/*
+ * STGT passthrough device
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/namei.h>
+
+#include <stgt_device.h>
+
+struct stgt_sd_dev {
+	struct block_device *bdev;
+};
+
+/*
+ * Convert a device path to a dev_t.
+ * from dm-table.c
+ */
+static int lookup_device(const char *path, dev_t *dev)
+{
+	int r;
+	struct nameidata nd;
+	struct inode *inode;
+
+	r = path_lookup(path, LOOKUP_FOLLOW, &nd);
+	if (r)
+		return r;
+
+	inode = nd.dentry->d_inode;
+	if (!inode) {
+		r = -ENOENT;
+		goto out;
+	}
+
+	if (!S_ISBLK(inode->i_mode)) {
+		r = -ENOTBLK;
+		goto out;
+	}
+
+	*dev = inode->i_rdev;
+out:
+	path_release(&nd);
+	return r;
+}
+
+static int open_dev(struct stgt_sd_dev *sddev, dev_t devt)
+{
+        struct block_device *bdev;
+
+        bdev = open_by_devnum(devt, FMODE_WRITE | FMODE_READ);
+        if (IS_ERR(bdev))
+                return PTR_ERR(bdev);
+	sddev->bdev = bdev;
+        return 0;
+}
+
+/*
+ * Close a device that we've been using.
+ */
+static void close_dev(struct stgt_sd_dev *sddev)
+{
+	blkdev_put(sddev->bdev);
+}
+
+static int stgt_sd_create(struct stgt_device *device)
+{
+	struct stgt_sd_dev *sddev = device->sdt_data;
+	dev_t devt;
+	int err;
+
+	err = lookup_device(device->path, &devt);
+	if (err)
+		return err;
+
+	err = open_dev(sddev, devt);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static void stgt_sd_destroy(struct stgt_device *device)
+{
+	close_dev(device->sdt_data);
+}
+
+static int stgt_sd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
+{
+	/*
+	struct stgt_sd_dev *sddev = device->sdt_data;
+	struct request_queue *q = bdev_get_queue(sddev->bdev);
+	struct request *rq;
+
+	 * format struct request as BLOCK_PC command and do
+	 * elv_add_request or if James's no_wait helper is in
+	 * then use it
+	 *
+	 * Will need some stgt wrappers/helpers though
+	 */
+	return 0;
+}
+
+static int stgt_sd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
+{
+	/*
+	 * can we take owner ship? If so return 0 else return a enum
+	 * (TODO define this)
+	 */
+	return 0;
+}
+
+static struct stgt_device_template stgt_sd = {
+	.name = "stgt_sd",
+	.module = THIS_MODULE,
+	.create = stgt_sd_create,
+	.destroy = stgt_sd_destroy,
+	.queuecommand = stgt_sd_queue,
+	.prepcommand = stgt_sd_prep,
+};
+
+static int __init stgt_sd_init(void)
+{
+	stgt_sd.priv_data_size = sizeof(struct stgt_sd_dev);
+	return stgt_device_template_register(&stgt_sd);
+}
+
+static void __exit stgt_sd_exit(void)
+{
+	stgt_device_template_unregister(&stgt_sd);
+}
+
+module_init(stgt_sd_init);
+module_exit(stgt_sd_exit);
+MODULE_LICENSE("GPL");

Added: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt_sysfs.c	2005-08-23 17:11:24 UTC (rev 16)
@@ -0,0 +1,240 @@
+/*
+ * STGT core sysfs files
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#include <stgt_target.h>
+#include <stgt_device.h>
+
+/*
+ * Target files
+ */
+#define stgt_target_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct stgt_target *target = cdev_to_stgt_target(cdev);		\
+	return snprintf (buf, 20, format_string, target->field);	\
+}
+
+#define stgt_target_rd_attr(field, format_string)		\
+	stgt_target_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+stgt_target_rd_attr(queued_cmnds, "%u\n");
+
+static struct class_device_attribute *stgt_target_attrs[] = {
+	&class_device_attr_queued_cmnds,
+	NULL
+};
+
+static void stgt_target_class_release(struct class_device *cdev)
+{
+	struct stgt_target *target = cdev_to_stgt_target(cdev);
+	kfree(target);
+}
+
+static struct class stgt_target_class = {
+	.name = "stgt_target",
+	.release = stgt_target_class_release,
+};
+
+/*
+ * Tmp: used for unique class_id names. For software we could
+ * push the naming to userspace
+ */
+static int stgt_target_num = 0;
+
+static struct class_device_attribute *class_attr_overridden(
+				struct class_device_attribute **attrs,
+				struct class_device_attribute *attr)
+{
+	int i;
+
+	if (!attrs)
+		return NULL;
+
+	for (i = 0; attrs[i]; i++)
+		if (!strcmp(attrs[i]->attr.name, attr->attr.name))
+			return attrs[i];
+	return NULL;
+}
+
+static int class_attr_add(struct class_device *classdev,
+			  struct class_device_attribute *attr)
+{
+	struct class_device_attribute *base_attr;
+
+	/*
+	 * Spare the caller from having to copy things it's not interested in.
+	*/
+	base_attr = class_attr_overridden(stgt_target_attrs, attr);
+	if (base_attr) {
+		/* extend permissions */
+		attr->attr.mode |= base_attr->attr.mode;
+
+		/* override null show/store with default */
+		if (!attr->show)
+			attr->show = base_attr->show;
+		if (!attr->store)
+			attr->store = base_attr->store;
+	}
+
+	return class_device_create_file(classdev, attr);
+}
+
+int stgt_sysfs_register_target(struct stgt_target *target)
+{
+	struct class_device *cdev = &target->cdev;
+	int err, i;
+	
+	cdev->class = &stgt_target_class;
+	snprintf(cdev->class_id, BUS_ID_SIZE, "target%d", stgt_target_num);
+
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	if (target->stt->target_attrs) {
+		for (i = 0; target->stt->target_attrs[i]; i++) {
+			err = class_attr_add(&target->cdev,
+					     target->stt->target_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; stgt_target_attrs[i]; i++) {
+		if (!class_attr_overridden(target->stt->target_attrs,
+					   stgt_target_attrs[i])) {
+			err = class_device_create_file(&target->cdev,
+						       stgt_target_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_unregister(cdev);
+	return err;
+}
+
+void stgt_sysfs_unregister_target(struct stgt_target *target)
+{
+	class_device_unregister(&target->cdev);
+}
+
+/*
+ * Device files
+ */
+#define stgt_device_show_fn(field, format_string)			\
+static ssize_t								\
+show_##field (struct class_device *cdev, char *buf)			\
+{									\
+	struct stgt_device *device = cdev_to_stgt_device(cdev);		\
+	return sprintf (buf, format_string, device->field);	\
+}
+
+#define stgt_device_rd_attr(field, format_string)		\
+	stgt_device_show_fn(field, format_string)		\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
+
+stgt_device_rd_attr(path, "%s\n");
+
+static struct class_device_attribute *stgt_device_attrs[] = {
+	&class_device_attr_path,
+	NULL
+};
+
+
+static void stgt_device_class_release(struct class_device *cdev)
+{
+	struct stgt_device *device = cdev_to_stgt_device(cdev);
+	struct stgt_target *target = device->target;
+
+	class_device_put(&target->cdev);
+	kfree(device->sdt_data);
+	kfree(device->path);
+	kfree(device);
+}
+
+static struct class stgt_device_class = {
+	.name = "stgt_device",
+	.release = stgt_device_class_release,
+};
+
+int stgt_sysfs_register_device(struct stgt_device *device)
+{
+	struct stgt_target *target = device->target;
+	struct class_device *cdev = &device->cdev;
+	int err, i;
+
+	cdev->class = &stgt_device_class;
+	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d", device->lun);
+	err = class_device_register(cdev);
+	if (err)
+		return err;
+
+	/*
+	 * get handle to target so our parent is never released before
+	 * us
+	 */
+	if (!class_device_get(&target->cdev))
+		return -EINVAL;
+
+	if (device->sdt->device_attrs) {
+		for (i = 0; device->sdt->device_attrs[i]; i++) {
+			err = class_attr_add(&device->cdev,
+					     device->sdt->device_attrs[i]);
+                        if (err)
+                                goto cleanup;
+		}
+	}
+
+	for (i = 0; stgt_device_attrs[i]; i++) {
+		if (!class_attr_overridden(device->sdt->device_attrs,
+					   stgt_device_attrs[i])) {
+			err = class_device_create_file(&device->cdev,
+						       stgt_device_attrs[i]);
+			if (err)
+				goto cleanup;
+		}
+	}
+
+	return 0;
+
+cleanup:
+	class_device_put(&target->cdev);
+	class_device_unregister(cdev);
+	return err;
+
+}
+
+void stgt_sysfs_unregister_device(struct stgt_device *device)
+{
+	class_device_unregister(&device->cdev);
+}
+
+int stgt_sysfs_init(void)
+{
+	int err;
+
+	err = class_register(&stgt_target_class);
+	if (err)
+		return err;
+
+	err = class_register(&stgt_device_class);
+	if (err)
+		class_unregister(&stgt_target_class);
+	return err;
+}
+
+void stgt_sysfs_exit(void)
+{
+	class_unregister(&stgt_target_class);
+	class_unregister(&stgt_device_class);
+}

Added: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/kernel/stgt_target.h	2005-08-23 17:11:24 UTC (rev 16)
@@ -0,0 +1,50 @@
+/*
+ * STGT target definitions
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+#ifndef __SCSI_STGT_TARGET_H
+#define __SCSI_STGT_TARGET_H
+
+#include <linux/device.h>
+#include <linux/list.h>
+
+struct stgt_target_template {
+	const char *name;
+
+	int queued_cmnds;
+	/*
+	 * Pointer to the sysfs class properties for this host, NULL terminated.
+	 */
+	struct class_device_attribute **target_attrs;
+};
+
+struct stgt_target {
+	struct stgt_target_template *stt;
+	struct class_device cdev;
+
+	int queued_cmnds;
+
+	/* Protects session_list, work_list, device_list */
+	spinlock_t lock;
+
+	struct list_head tlist;
+
+	struct list_head device_list;
+	struct list_head session_list;
+
+	struct work_struct work;
+	struct list_head work_list;
+};
+
+#define cdev_to_stgt_target(cdev) \
+	container_of(cdev, struct stgt_target, cdev)
+
+extern struct stgt_target *stgt_target_create(struct stgt_target_template *stt);
+extern int stgt_target_destroy(struct stgt_target *target);
+extern int stgt_sysfs_register_target(struct stgt_target *target);
+extern void stgt_sysfs_unregister_target(struct stgt_target *target);
+
+#endif

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-08-23 09:32:45 UTC (rev 15)
+++ trunk/usr/Makefile	2005-08-23 17:11:24 UTC (rev 16)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_STGT=12
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -I../include -DNETLINK_STGT=20
 PROGRAMS = stgtd
 
 all: $(PROGRAMS)



From tomo at berlios.de  Tue Aug 23 20:03:05 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 23 Aug 2005 20:03:05 +0200
Subject: [Stgt-svn] r17 - trunk/iscsi/kernel
Message-ID: <200508231803.j7NI35gf022832@sheep.berlios.de>

Author: tomo
Date: 2005-08-23 20:03:04 +0200 (Tue, 23 Aug 2005)
New Revision: 17

Modified:
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
Log:
IET uses stgt_device_create().

Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-08-23 17:11:24 UTC (rev 16)
+++ trunk/iscsi/kernel/config.c	2005-08-23 18:03:04 UTC (rev 17)
@@ -170,8 +170,7 @@
 	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
 		return err;
 
-	return 0;
-/* 	return volume_add(target, &info); */
+	return volume_add(target, &info);
 }
 
 static int del_volume(struct iscsi_target *target, unsigned long ptr)
@@ -182,8 +181,7 @@
 	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
 		return err;
 
-	return 0;
-/* 	return iscsi_volume_del(target, &info); */
+	return volume_del(target, &info);
 }
 
 static int iscsi_param_config(struct iscsi_target *target, unsigned long ptr, int set)

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-23 17:11:24 UTC (rev 16)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-23 18:03:04 UTC (rev 17)
@@ -73,6 +73,7 @@
 	struct iscsi_trgt_param trgt_param;
 
 	struct list_head session_list;
+	struct list_head device_list;
 
 	struct network_thread_info nthread_info;
 
@@ -231,6 +232,8 @@
 struct iscsi_target *target_lookup_by_id(u32);
 extern int target_add(struct target_info *);
 extern int target_del(u32 id);
+extern int volume_del(struct iscsi_target *target, struct volume_info *info);
+extern int volume_add(struct iscsi_target *target, struct volume_info *info);
 
 /* config.c */
 extern int iet_procfs_init(void);

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-08-23 17:11:24 UTC (rev 16)
+++ trunk/iscsi/kernel/target.c	2005-08-23 18:03:04 UTC (rev 17)
@@ -11,6 +11,7 @@
 #include <iscsi_dbg.h>
 #include <stgt.h>
 #include <stgt_target.h>
+#include <stgt_device.h>
 
 #define	MAX_NR_TARGETS	(1UL << 30)
 
@@ -151,6 +152,7 @@
 	init_MUTEX(&target->target_sem);
 
 	INIT_LIST_HEAD(&target->session_list);
+	INIT_LIST_HEAD(&target->device_list);
 	list_add(&target->t_list, &target_list);
 
 	nthread_init(target);
@@ -277,3 +279,81 @@
 
 	return 0;
 }
+
+/*
+ * Temporary device code
+ */
+
+struct iscsi_device {
+	uint64_t lun;
+	struct list_head list;
+	struct stgt_device *sd;
+};
+
+struct iscsi_device *volume_lookup(struct iscsi_target *target, u32 lun)
+{
+	struct iscsi_device *device;
+	list_for_each_entry(device, &target->device_list, list) {
+		if (device->lun == lun)
+			return device;
+	}
+	return NULL;
+}
+
+int volume_add(struct iscsi_target *target, struct volume_info *info)
+{
+	char key_path[] = "Path=", key_type[] = "Type=";
+	char *p, *path = NULL, *type = NULL;
+	struct iscsi_device *device;
+	struct stgt_device *sd;
+	char *args = info->args;
+
+	while ((p = strsep(&args, ",")) != NULL) {
+		if (!*p) continue;
+
+		if (!strncmp(p, key_path, strlen(key_path)))
+			path = p + strlen(key_path);
+		else if (!strncmp(p, key_type, strlen(key_type)))
+			type = p + strlen(key_type);
+	}
+
+	if (volume_lookup(target, info->lun)) {
+		eprintk("%u\n", info->lun);
+		return -EEXIST;
+	}
+
+	if (!path)
+		return -EINVAL;
+
+	device = kmalloc(sizeof(*device), GFP_KERNEL);
+	if (!device)
+		return -ENOMEM;
+
+	eprintk("%u %s %s\n", info->lun, path, type);
+	sd = stgt_device_create(target->stt, type ? : "stgt_sd",
+				path, info->lun, 0);
+	if (!sd)
+		goto out;
+
+	device->sd = sd;
+	device->lun = info->lun;
+	list_add(&device->list, &target->device_list);
+	return 0;
+out:
+	kfree(device);
+	return -EINVAL;
+}
+
+int volume_del(struct iscsi_target *target, struct volume_info *info)
+{
+	struct iscsi_device *device;
+
+	device = volume_lookup(target, info->lun);
+	if (!device)
+		return -ENOENT;
+
+	stgt_device_destroy(device->sd);
+	list_del(&device->list);
+	kfree(device);
+	return 0;
+}



From tomo at berlios.de  Tue Aug 23 20:13:14 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 23 Aug 2005 20:13:14 +0200
Subject: [Stgt-svn] r18 - trunk/kernel
Message-ID: <200508231813.j7NIDEwv023418@sheep.berlios.de>

Author: tomo
Date: 2005-08-23 20:13:14 +0200 (Tue, 23 Aug 2005)
New Revision: 18

Added:
   trunk/kernel/stgt_vsd.c
Modified:
   trunk/kernel/Makefile
Log:
Add initial virtual device code.

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-08-23 18:03:04 UTC (rev 17)
+++ trunk/kernel/Makefile	2005-08-23 18:13:14 UTC (rev 18)
@@ -8,7 +8,7 @@
 obj-m		+= stgt_core.o
 stgt_core-objs	:= stgt_sysfs.o stgt.o
 
-obj-m		+= stgt_sd.o
+obj-m		+= stgt_sd.o stgt_vsd.o
 else
 
 ifeq ($(KERNELSRC),)

Added: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-08-23 18:03:04 UTC (rev 17)
+++ trunk/kernel/stgt_vsd.c	2005-08-23 18:13:14 UTC (rev 18)
@@ -0,0 +1,105 @@
+/*
+ * STGT virtual device
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/namei.h>
+
+#include <stgt_device.h>
+
+struct stgt_vsd_dev {
+	struct file *filp;
+};
+
+static void stgt_vsd_destroy(struct stgt_device *device)
+{
+	struct stgt_vsd_dev *vsddev = device->sdt_data;
+	filp_close(vsddev->filp, NULL);
+}
+
+static int open_file(struct stgt_vsd_dev *vsddev, const char *path)
+{
+	struct file *filp;
+	mm_segment_t oldfs;
+	int err = 0;
+
+	oldfs = get_fs();
+	set_fs(get_ds());
+	filp = filp_open(path, O_RDWR|O_LARGEFILE, 0);
+	set_fs(oldfs);
+
+	if (IS_ERR(filp)) {
+		err = PTR_ERR(filp);
+		printk("Can't open %s %d\n", path, err);
+	} else
+		vsddev->filp = filp;
+
+	return err;
+}
+
+static int stgt_vsd_create(struct stgt_device *device)
+{
+	struct stgt_vsd_dev *vsddev = device->sdt_data;
+	struct inode *inode;
+	int err = 0;
+
+	err = open_file(vsddev, device->path);
+	if (err)
+		return err;
+
+	inode = vsddev->filp->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
+	else {
+		err = -EINVAL;
+		goto out;
+	}
+
+	printk("%s %llu\n", device->path, inode->i_size >> 9);
+
+	return 0;
+out:
+	filp_close(vsddev->filp, NULL);
+	return err;
+}
+
+static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
+{
+	return 0;
+}
+
+static int stgt_vsd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
+{
+	return 0;
+}
+
+static struct stgt_device_template stgt_vsd = {
+	.name = "stgt_vsd",
+	.module = THIS_MODULE,
+	.create = stgt_vsd_create,
+	.destroy = stgt_vsd_destroy,
+	.queuecommand = stgt_vsd_queue,
+	.prepcommand = stgt_vsd_prep,
+};
+
+static int __init stgt_vsd_init(void)
+{
+	stgt_vsd.priv_data_size = sizeof(struct stgt_vsd_dev);
+	return stgt_device_template_register(&stgt_vsd);
+}
+
+static void __exit stgt_vsd_exit(void)
+{
+	stgt_device_template_unregister(&stgt_vsd);
+}
+
+module_init(stgt_vsd_init);
+module_exit(stgt_vsd_exit);
+MODULE_LICENSE("GPL");



From tomo at berlios.de  Fri Aug 26 07:35:35 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 26 Aug 2005 07:35:35 +0200
Subject: [Stgt-svn] r20 - in trunk: include iscsi/kernel kernel usr
Message-ID: <200508260535.j7Q5ZZhe000383@sheep.berlios.de>

Author: tomo
Date: 2005-08-26 07:35:30 +0200 (Fri, 26 Aug 2005)
New Revision: 20

Modified:
   trunk/include/stgt_if.h
   trunk/iscsi/kernel/iscsi.c
   trunk/kernel/stgt.c
   trunk/kernel/stgt.h
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_sd.c
   trunk/kernel/stgt_sysfs.c
   trunk/kernel/stgt_vsd.c
   trunk/usr/scsi.c
   trunk/usr/stgtd.c
Log:
Change stgt_cmnd_queue interface to initialize stgt_cmnd->lun
(Should stgt_cmnd_create do this?). stgtd builds real responses
by using sysfs info.


Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/include/stgt_if.h	2005-08-26 05:35:30 UTC (rev 20)
@@ -18,6 +18,8 @@
 struct stgt_event {
 	union {
 		struct {
+			uint64_t tid;
+			uint32_t lun;
 			uint64_t cid;
 			uint32_t size;
 		} msg_scsi_cmnd;

Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/iscsi/kernel/iscsi.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -720,7 +720,8 @@
 	} else {
 		set_cmnd_waitio(cmnd);
 		cmnd->stc->private = cmnd;
-		stgt_cmnd_queue(cmnd->stc, scsi_cmnd_done);
+		stgt_cmnd_queue(cmnd->stc, cmnd_hdr(cmnd)->lun,
+				sizeof(cmnd_hdr(cmnd)->lun), scsi_cmnd_done);
 	}
 }
 

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -621,6 +621,8 @@
 	memset(ev, 0, sizeof(*ev));
 
 	pdu = (char *) ev + sizeof(*ev);
+	ev->u.msg_scsi_cmnd.tid = cmnd->session->target->tid;
+	ev->u.msg_scsi_cmnd.lun = cmnd->lun;
 	ev->u.msg_scsi_cmnd.cid = cmnd->cid;
 
 	memcpy(pdu, cmnd->scb, sizeof(cmnd->scb));
@@ -687,8 +689,29 @@
 	}
 }
 
-int stgt_cmnd_queue(struct stgt_cmnd *cmnd, void (*done)(struct stgt_cmnd *))
+static uint32_t translate_lun(uint8_t *p, int size)
 {
+	uint32_t lun = ~0U;
+
+	switch (*p >> 6) {
+	case 0:
+		lun = p[1];
+		break;
+	case 1:
+		lun = (0x3f & p[0]) << 8 | p[1];
+		break;
+	case 2:
+	case 3:
+	default:
+		break;
+	}
+
+	return lun;
+}
+
+int stgt_cmnd_queue(struct stgt_cmnd *cmnd, uint8_t *lun, int lun_size,
+		    void (*done)(struct stgt_cmnd *))
+{
 	struct stgt_work *work;
 	struct stgt_session *session = cmnd->session;
 
@@ -704,6 +727,9 @@
 	work = stgt_init_work(session, queuecommand, cmnd);
 	if (!work)
 		return -ENOMEM;
+
+	cmnd->lun = translate_lun(lun, lun_size);
+
 	stgt_queue_work(session->target, work);
 
 	return 0;

Modified: trunk/kernel/stgt.h
===================================================================
--- trunk/kernel/stgt.h	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt.h	2005-08-26 05:35:30 UTC (rev 20)
@@ -50,6 +50,7 @@
 extern void stgt_cmnd_alloc_buffer(struct stgt_cmnd *cmnd,
 				  void (*done)(struct stgt_cmnd *));
 extern int stgt_cmnd_queue(struct stgt_cmnd *cmnd,
+			   uint8_t *lun, int lun_len,
 			   void (*done)(struct stgt_cmnd *));
 extern int stgt_sysfs_init(void);
 extern void stgt_sysfs_exit(void);

Modified: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt_device.h	2005-08-26 05:35:30 UTC (rev 20)
@@ -39,7 +39,7 @@
         char *path;
         uint32_t lun;
         uint32_t blk_shift;
-        uint64_t blk_count;
+        uint64_t size;
 
         struct stgt_target *target;
         struct list_head dlist;

Modified: trunk/kernel/stgt_sd.c
===================================================================
--- trunk/kernel/stgt_sd.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt_sd.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -79,6 +79,8 @@
 	if (err)
 		return err;
 
+	device->size = sddev->bdev->bd_block_size;
+
 	return 0;
 }
 

Modified: trunk/kernel/stgt_sysfs.c
===================================================================
--- trunk/kernel/stgt_sysfs.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt_sysfs.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -138,10 +138,12 @@
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
 stgt_device_rd_attr(path, "%s\n");
+stgt_device_rd_attr(size, "%llu\n");
 
 static struct class_device_attribute *stgt_device_attrs[] = {
 	&class_device_attr_path,
-	NULL
+	&class_device_attr_size,
+	NULL,
 };
 
 

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/kernel/stgt_vsd.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -62,6 +62,7 @@
 		goto out;
 	}
 
+	device->size = inode->i_size;
 	printk("%s %llu\n", device->path, inode->i_size >> 9);
 
 	return 0;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/usr/scsi.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -11,9 +11,14 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <dirent.h>
+#include <unistd.h>
 #include <scsi/scsi.h>
 #include <asm/byteorder.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 
+
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
 #define cpu_to_be64 __cpu_to_be64
@@ -27,7 +32,6 @@
 #endif
 
 static uint32_t blk_shift = 9;
-static uint64_t blk_cnt = 1 << 20;
 
 #define eprintf(fmt, args...)						\
 do {									\
@@ -51,6 +55,23 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
+static int device_info(int tid, uint32_t lun, uint64_t *size)
+{
+	int fd, err;
+	char path[PATH_MAX], buf[128];
+
+	sprintf(path, "/sys/class/stgt_device/device%d:%u/size", tid, lun);
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		return fd;
+	err = read(fd, buf, sizeof(buf));
+	if (err < 0)
+		return err;
+	*size = strtoull(buf, NULL, 10);
+	return 0;
+}
+
 static int insert_disconnect_pg(uint8_t *ptr)
 {
 	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
@@ -112,18 +133,22 @@
 	return sizeof(geo_m_pg);
 }
 
-static int build_mode_sense_response(uint8_t *scb, uint8_t *data)
+static int mode_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
 {
 	int len = 4, err = 0;
 	uint8_t pcode = scb[2] & 0x3f;
+	uint64_t size;
 
+	device_info(tid, lun, &size);
+	size >>= blk_shift;
+
 	if ((scb[1] & 0x8))
 		data[3] = 0;
 	else {
 		data[3] = 8;
 		len += 8;
-		*(uint32_t *)(data + 4) = (blk_cnt >> 32) ?
-			cpu_to_be32(0xffffffff) : cpu_to_be32(blk_cnt);
+		*(uint32_t *)(data + 4) = (size >> 32) ?
+			cpu_to_be32(0xffffffff) : cpu_to_be32(size);
 		*(uint32_t *)(data + 8) = cpu_to_be32(1 << blk_shift);
 	}
 
@@ -137,7 +162,7 @@
 		len += insert_format_m_pg(data + len);
 		break;
 	case 0x4:
-		len += insert_geo_m_pg(data + len, blk_cnt);
+		len += insert_geo_m_pg(data + len, size);
 		break;
 	case 0x8:
 		len += insert_caching_pg(data + len);
@@ -151,7 +176,7 @@
 	case 0x3f:
 		len += insert_disconnect_pg(data + len);
 		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, blk_cnt);
+		len += insert_geo_m_pg(data + len, size);
 		len += insert_caching_pg(data + len);
 		len += insert_ctrl_m_pg(data + len);
 		len += insert_iec_m_pg(data + len);
@@ -169,7 +194,7 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int build_inquiry_response(uint8_t *scb, uint8_t *data)
+static int inquiry(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
 {
 	int err = -1;
 	int len = 0;
@@ -229,7 +254,8 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			memcpy(data + 8, "deadbeaf", tmp);
+			if (lun != ~0UL)
+				sprintf(data + 8, "deadbeaf%d:%u", tid, lun);
 			len = tmp + 8;
 			err = 0;
 		}
@@ -237,41 +263,75 @@
 
 	len = min_t(int, len, scb[4]);
 
-/* 	if (!cmnd->lun) */
-/* 		data[0] = TYPE_NO_LUN; */
+	if (lun == ~0UL)
+		data[0] = TYPE_NO_LUN;
 
 	return len;
 }
 
-static int build_report_luns_response(uint8_t *scb, uint8_t *p)
+static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p)
 {
-	uint32_t size, len, lun = 0;
+	uint32_t lun;
 	uint32_t *data = (uint32_t *) p;
+	int idx, alen, oalen, rbuflen, nr_luns;
+	DIR *dir;
+	struct dirent *ent;
+	char buf[128];
 
-	size = be32_to_cpu(*(uint32_t *)&scb[6]);
-	if (size < 16)
+	dir = opendir("/sys/class/stgt_device");
+	if (!dir)
 		return -1;
 
-	len = 8;
-	size = min(size & ~(8 - 1), len + 8);
+	alen = be32_to_cpu(*(uint32_t *)&scb[6]);
+	if (alen < 16)
+		return -1;
 
-	*data++ = cpu_to_be32(len);
-	*data++ = 0;
+	alen &= ~(8 - 1);
+	oalen = alen;
 
-	*data++ = cpu_to_be32((0x3ff & lun) << 16 |
-			      (lun > 0xff) ? (0x1 << 30) : 0);
-	*data++ = 0;
+	/* We'll set data[0] later. */
+	data[1] = 0;
 
-	return size;
+	alen -= 8;
+	rbuflen = 8192 - 8; /* FIXME */
+	idx = 2;
+	nr_luns = 0;
+
+	sprintf(buf, "device%d:", tid);
+	while ((ent = readdir(dir))) {
+		if (!strncmp(ent->d_name, buf, strlen(buf))) {
+			sscanf(ent->d_name, "device%d:%u", &tid, &lun);
+			data[idx++] = cpu_to_be32((0x3ff & lun) << 16 |
+						  ((lun > 0xff) ? (0x1 << 30) : 0));
+			data[idx++] = 0;
+			if (!(alen -= 8))
+				break;
+			if (!(rbuflen -= 8)) {
+				fprintf(stderr, "FIXME: too many luns\n");
+				exit(-1);
+			}
+			nr_luns++;
+		}
+	}
+
+	data[0] = cpu_to_be32(nr_luns * 8);
+
+	closedir(dir);
+
+	return min(oalen, nr_luns * 8 + 8);
 }
 
-static int build_read_capacity_response(uint8_t *scb, uint8_t *p)
+static int read_capacity(int tid, uint32_t lun, uint8_t *scb, uint8_t *p)
 {
 	int len;
 	uint32_t *data = (uint32_t *) p;
+	uint64_t size;
 
-	data[0] = (blk_cnt >> 32) ?
-		cpu_to_be32(0xffffffff) : cpu_to_be32(blk_cnt - 1);
+	device_info(tid, lun, &size);
+	size >>= blk_shift;
+
+	data[0] = (size >> 32) ?
+		cpu_to_be32(0xffffffff) : cpu_to_be32(size - 1);
 	data[1] = cpu_to_be32(1U << blk_shift);
 
 	len = 8;
@@ -279,7 +339,7 @@
 	return len;
 }
 
-static int build_request_sense_response(uint8_t *scb, uint8_t *data)
+static int request_sense(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
 {
 	int len;
 
@@ -293,14 +353,17 @@
 	return len;
 }
 
-static int build_sevice_action_response(uint8_t *scb, uint8_t *p)
+static int sevice_action(int tid, uint32_t lun, uint8_t *scb, uint8_t *p)
 {
 	int len;
 	uint32_t *data = (uint32_t *) p;
-	uint64_t *data64;
+	uint64_t *data64, size;
 
+	device_info(tid, lun, &size);
+	size >>= blk_shift;
+
 	data64 = (uint64_t *) data;
-	data64[0] = cpu_to_be64(blk_cnt - 1);
+	data64[0] = cpu_to_be64(size - 1);
 	data[2] = cpu_to_be32(1UL << blk_shift);
 
 	len = 32;
@@ -308,7 +371,7 @@
 	return len;
 }
 
-int disk_execute_cmnd(uint8_t *scb, uint8_t *data)
+int disk_execute_cmnd(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
 {
 	int len = -1;
 
@@ -316,22 +379,22 @@
 
 	switch (scb[0]) {
 	case INQUIRY:
-		len = build_inquiry_response(scb, data);
+		len = inquiry(tid, lun, scb, data);
 		break;
 	case REPORT_LUNS:
-		len = build_report_luns_response(scb, data);
+		len = report_luns(tid, lun, scb, data);
 		break;
 	case READ_CAPACITY:
-		len = build_read_capacity_response(scb, data);
+		len = read_capacity(tid, lun, scb, data);
 		break;
 	case MODE_SENSE:
-		len = build_mode_sense_response(scb, data);
+		len = mode_sense(tid, lun, scb, data);
 		break;
 	case REQUEST_SENSE:
-		len = build_request_sense_response(scb, data);
+		len = request_sense(tid, lun, scb, data);
 		break;
 	case SERVICE_ACTION_IN:
-		len = build_sevice_action_response(scb, data);
+		len = sevice_action(tid, lun, scb, data);
 		break;
 	case START_STOP:
 	case TEST_UNIT_READY:

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-25 17:05:38 UTC (rev 19)
+++ trunk/usr/stgtd.c	2005-08-26 05:35:30 UTC (rev 20)
@@ -27,7 +27,7 @@
 	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
 } while (0)
 
-extern int disk_execute_cmnd(char *scb, char *data);
+extern int disk_execute_cmnd(int tid, uint32_t lun, char *scb, char *data);
 
 static struct sockaddr_nl src_addr, dest_addr;
 static void *nlm_recvbuf;
@@ -155,7 +155,10 @@
 	scb = recvbuf + sizeof(*ev);
 	eprintf("%" PRIu64 " %x\n", ev->u.msg_scsi_cmnd.cid, scb[0]);
 
-	if ((err = disk_execute_cmnd(scb, sendbuf)) < 0)
+	err = disk_execute_cmnd(ev->u.msg_scsi_cmnd.tid,
+				ev->u.msg_scsi_cmnd.lun,
+				scb, sendbuf);
+	if (err < 0)
 		return err;
 
 	uev.u.msg_scsi_cmnd.size = err;



From tomo at berlios.de  Fri Aug 26 08:28:19 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Fri, 26 Aug 2005 08:28:19 +0200
Subject: [Stgt-svn] r21 - in trunk: include kernel usr
Message-ID: <200508260628.j7Q6SJsC013662@sheep.berlios.de>

Author: tomo
Date: 2005-08-26 08:28:17 +0200 (Fri, 26 Aug 2005)
New Revision: 21

Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/usr/stgtd.c
Log:
Cleanup of struct stgt_event.

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-08-26 05:35:30 UTC (rev 20)
+++ trunk/include/stgt_if.h	2005-08-26 06:28:17 UTC (rev 21)
@@ -11,19 +11,27 @@
 	STGT_UEVENT_START,
 	STGT_UEVENT_SCSI_CMND_RES,
 
-	/* user <- kernel */
+	/* kernel -> user */
 	STGT_KEVENT_SCSI_CMND_REQ,
 };
 
 struct stgt_event {
+	/* user-> kernel */
 	union {
 		struct {
-			uint64_t tid;
-			uint32_t lun;
 			uint64_t cid;
 			uint32_t size;
-		} msg_scsi_cmnd;
+		} cmnd_res;
 	} u;
+
+	/* kernel -> user */
+	union {
+		struct {
+			uint64_t cid;
+			int32_t tid;
+			uint32_t lun;
+		} cmnd_req;
+	} k;
 };
 
 #endif

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-26 05:35:30 UTC (rev 20)
+++ trunk/kernel/stgt.c	2005-08-26 06:28:17 UTC (rev 21)
@@ -621,9 +621,9 @@
 	memset(ev, 0, sizeof(*ev));
 
 	pdu = (char *) ev + sizeof(*ev);
-	ev->u.msg_scsi_cmnd.tid = cmnd->session->target->tid;
-	ev->u.msg_scsi_cmnd.lun = cmnd->lun;
-	ev->u.msg_scsi_cmnd.cid = cmnd->cid;
+	ev->k.cmnd_req.tid = cmnd->session->target->tid;
+	ev->k.cmnd_req.lun = cmnd->lun;
+	ev->k.cmnd_req.cid = cmnd->cid;
 
 	memcpy(pdu, cmnd->scb, sizeof(cmnd->scb));
 
@@ -772,13 +772,13 @@
 		dprintk("start %d\n", daemon_pid);
 		break;
 	case STGT_UEVENT_SCSI_CMND_RES:
-		dprintk("start %llu\n", ev->u.msg_scsi_cmnd.cid);
-		cmnd = find_cmnd_by_id(ev->u.msg_scsi_cmnd.cid);
+		uint64_t cid = ev->u.cmnd_req.cid;
+		cmnd = find_cmnd_by_id(cid);
 		if (cmnd)
 			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
-					 ev->u.msg_scsi_cmnd.size);
+					 ev->u.cmnd_req.size);
 		else {
-			eprintk("cannot found %llu\n", ev->u.msg_scsi_cmnd.cid);
+			eprintk("cannot found %llu\n", cid);
 			err = -EEXIST;
 		}
 		break;

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-26 05:35:30 UTC (rev 20)
+++ trunk/usr/stgtd.c	2005-08-26 06:28:17 UTC (rev 21)
@@ -153,16 +153,16 @@
 	uint8_t *scb;
 
 	scb = recvbuf + sizeof(*ev);
-	eprintf("%" PRIu64 " %x\n", ev->u.msg_scsi_cmnd.cid, scb[0]);
+	eprintf("%" PRIu64 " %x\n", ev->k.cmnd_req.cid, scb[0]);
 
-	err = disk_execute_cmnd(ev->u.msg_scsi_cmnd.tid,
-				ev->u.msg_scsi_cmnd.lun,
+	err = disk_execute_cmnd(ev->k.cmnd_req.tid,
+				ev->k.cmnd_req.lun,
 				scb, sendbuf);
 	if (err < 0)
 		return err;
 
-	uev.u.msg_scsi_cmnd.size = err;
-	uev.u.msg_scsi_cmnd.cid = ev->u.msg_scsi_cmnd.cid;
+	uev.u.cmnd_res.cid = ev->k.cmnd_req.cid;
+	uev.u.cmnd_res.size = err;
 
 	iov[0].iov_base = (void *) &uev;
 	iov[0].iov_len = sizeof(uev);



From tomo at berlios.de  Sat Aug 27 17:51:14 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 27 Aug 2005 17:51:14 +0200
Subject: [Stgt-svn] r22 - in trunk: include kernel usr
Message-ID: <200508271551.j7RFpEgK009479@sheep.berlios.de>

Author: tomo
Date: 2005-08-27 17:51:13 +0200 (Sat, 27 Aug 2005)
New Revision: 22

Added:
   trunk/usr/ipc.c
Modified:
   trunk/include/stgt_if.h
   trunk/kernel/stgt.c
   trunk/kernel/stgt_device.h
   trunk/usr/Makefile
   trunk/usr/stgtd.c
Log:
The stgt devices can be configured only by using netlink (target drivers don't
need to handle devices in kernel space).


Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/include/stgt_if.h	2005-08-27 15:51:13 UTC (rev 22)
@@ -9,9 +9,12 @@
 enum stgt_event_type {
 	/* user -> kernel */
 	STGT_UEVENT_START,
+	STGT_UEVENT_DEVICE_CREATE,
+	STGT_UEVENT_DEVICE_DESTROY,
 	STGT_UEVENT_SCSI_CMND_RES,
 
 	/* kernel -> user */
+	STGT_KEVENT_RESPONSE,
 	STGT_KEVENT_SCSI_CMND_REQ,
 };
 
@@ -19,6 +22,16 @@
 	/* user-> kernel */
 	union {
 		struct {
+			int tid;
+			uint32_t lun;
+			uint32_t flags;
+			char type[32];
+		} c_device;
+		struct {
+			int tid;
+			uint32_t lun;
+		} d_device;
+		struct {
 			uint64_t cid;
 			uint32_t size;
 		} cmnd_res;
@@ -27,8 +40,11 @@
 	/* kernel -> user */
 	union {
 		struct {
+			int err;
+		} event_res;
+		struct {
 			uint64_t cid;
-			int32_t tid;
+			int tid;
 			uint32_t lun;
 		} cmnd_req;
 	} k;

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/kernel/stgt.c	2005-08-27 15:51:13 UTC (rev 22)
@@ -133,6 +133,20 @@
 	schedule_work(&target->work);
 }
 
+static struct stgt_target *target_find(int tid)
+{
+	struct stgt_target *target;
+
+	spin_lock(&all_targets_lock);
+	list_for_each_entry(target, &all_targets, tlist)
+		if (target->tid == tid)
+			goto found;
+	spin_unlock(&all_targets_lock);
+	target = NULL;
+found:
+	return target;
+}
+
 struct stgt_target *stgt_target_create(struct stgt_target_template *stt)
 {
 	static int target_id;
@@ -391,19 +405,22 @@
 }
 EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
 
-struct stgt_device *stgt_device_create(struct stgt_target *target,
-				       char *device_type, char *path,
-				       uint32_t lun, unsigned long dflags)
+static int stgt_device_create(int tid, uint32_t lun, char *device_type, char *path,
+			      unsigned long dflags)
 {
+	struct stgt_target *target;
 	struct stgt_device *device;
 	unsigned long flags;
 
+	dprintk("%d %u %s %s\n", tid, lun, device_type, path);
+
+	target = target_find(tid);
 	if (!target)
-		return NULL;
+		return -EINVAL;
 
 	device = kmalloc(sizeof(*device), GFP_KERNEL);
 	if (!device)
-		return NULL;
+		return -ENOMEM;
 
 	memset(device, 0, sizeof(*device));
 
@@ -433,7 +450,7 @@
 	list_add(&device->dlist, &target->device_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	return device;
+	return 0;
 
 sdt_destroy:
 	if (device->sdt->destroy)
@@ -446,22 +463,29 @@
 	kfree(device->path);
 free_device:
 	kfree(device);
-	return NULL;
+	return -EINVAL;
 }
-EXPORT_SYMBOL(stgt_device_create);
 
-int stgt_device_destroy(struct stgt_device *device)
+static int stgt_device_destroy(int tid, uint32_t lun)
 {
+	struct stgt_device *device;
 	struct stgt_target *target = device->target;
 	unsigned long flags;
 
-	if (!device)
-		return -EINVAL;
+	target = target_find(tid);
+	if (!target)
+		return -ENOENT;
 
 	spin_lock_irqsave(&target->lock, flags);
-	list_del(&device->dlist);
+	list_for_each_entry(device, &target->device_list, dlist)
+		if (device->lun == lun) {
+			list_del(&device->dlist);
+			goto found;
+		}
 	spin_unlock_irqrestore(&target->lock, flags);
 
+	return -EINVAL;
+found:
 	if (device->sdt->destroy)
 		device->sdt->destroy(device);
 
@@ -470,7 +494,6 @@
 
 	return 0;
 }
-EXPORT_SYMBOL(stgt_device_destroy);
 
 struct stgt_cmnd *stgt_cmnd_create(struct stgt_session *session)
 {
@@ -771,14 +794,24 @@
 	case STGT_UEVENT_START:
 		dprintk("start %d\n", daemon_pid);
 		break;
+	case STGT_UEVENT_DEVICE_CREATE:
+		err = stgt_device_create(ev->u.c_device.tid,
+					 ev->u.c_device.lun,
+					 ev->u.c_device.type,
+					 (char *) ev + sizeof(*ev),
+					 ev->u.c_device.flags);
+		break;
+	case STGT_UEVENT_DEVICE_DESTROY:
+		err = stgt_device_destroy(ev->u.d_device.tid,
+					  ev->u.d_device.lun);
+		break;
 	case STGT_UEVENT_SCSI_CMND_RES:
-		uint64_t cid = ev->u.cmnd_req.cid;
-		cmnd = find_cmnd_by_id(cid);
+		cmnd = find_cmnd_by_id(ev->u.cmnd_res.cid);
 		if (cmnd)
 			uspace_cmnd_done(cmnd, (char *) ev + sizeof(*ev),
-					 ev->u.cmnd_req.size);
+					 ev->u.cmnd_res.size);
 		else {
-			eprintk("cannot found %llu\n", cid);
+			eprintk("cannot found %llu\n", ev->u.cmnd_res.cid);
 			err = -EEXIST;
 		}
 		break;
@@ -790,24 +823,42 @@
 	return err;
 }
 
+static int send_event_res(uint32_t pid, uint16_t type, void *data, uint32_t size)
+{
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len = NLMSG_SPACE(size);
+
+	skb = alloc_skb(len, GFP_KERNEL | __GFP_NOFAIL);
+	nlh = __nlmsg_put(skb, pid, 0, type, size, 0);
+	memcpy(NLMSG_DATA(nlh), data, size);
+
+	return netlink_unicast(nls, skb, pid, 0);
+}
+
 static int event_recv_skb(struct sk_buff *skb)
 {
 	int err;
+	uint32_t rlen;
 	struct nlmsghdr	*nlh;
-	u32 rlen;
+	struct stgt_event *ev;
 
 	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *)skb->data;
+		nlh = (struct nlmsghdr *) skb->data;
 		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
 			return 0;
+		ev = NLMSG_DATA(nlh);
 		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
 		if (rlen > skb->len)
 			rlen = skb->len;
 		err = event_recv_msg(skb, nlh);
-		if (err)
-			netlink_ack(skb, nlh, -err);
-		else if (nlh->nlmsg_flags & NLM_F_ACK)
-			netlink_ack(skb, nlh, 0);
+
+		printk("%d %d\n", nlh->nlmsg_type, err);
+		ev->k.event_res.err = err;
+		if (nlh->nlmsg_type != STGT_UEVENT_SCSI_CMND_RES)
+			send_event_res(NETLINK_CREDS(skb)->pid,
+				       STGT_KEVENT_RESPONSE,
+				       ev, sizeof(*ev));
 		skb_pull(skb, rlen);
 	}
 	return 0;

Modified: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/kernel/stgt_device.h	2005-08-27 15:51:13 UTC (rev 22)
@@ -48,11 +48,6 @@
 #define cdev_to_stgt_device(cdev) \
         container_of(cdev, struct stgt_device, cdev)
 
-extern struct stgt_device* stgt_device_create(struct stgt_target *target,
-					      char *device_type, char *path,
-					      uint32_t lun,
-					      unsigned long dflags);
-extern int stgt_device_destroy(struct stgt_device *device);
 extern int stgt_sysfs_register_device(struct stgt_device *device);
 extern void stgt_sysfs_unregister_device(struct stgt_device *device);
 extern int stgt_device_template_register(struct stgt_device_template *sdt);

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/usr/Makefile	2005-08-27 15:51:13 UTC (rev 22)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-stgtd: stgtd.o scsi.o
+stgtd: stgtd.o scsi.o ipc.o
 	$(CC) $^ -o $@ $(LIBS)
 
 clean:

Added: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/usr/ipc.c	2005-08-27 15:51:13 UTC (rev 22)
@@ -0,0 +1,138 @@
+/*
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ *
+ * This code is licenced under the GPL.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <asm/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+
+#include <stgt_if.h>
+
+extern int nl_fd;
+extern int request_execute(int fd, int type, struct iovec *iovp, int count, int *res);
+
+#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
+
+int ipc_listen(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
+	       strlen(STGT_IPC_NAMESPACE));
+
+	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		return err;
+
+	if ((err = listen(fd, 32)) < 0)
+		return err;
+
+	return fd;
+}
+
+static int ipc_exec(struct nlmsghdr *nlh, char *data, int len, int *res)
+{
+	int err;
+	struct iovec iov;
+
+	iov.iov_base = data;
+	iov.iov_len = len;
+
+	err = request_execute(nl_fd, nlh->nlmsg_type, &iov, 1, res);
+
+	return err;
+}
+
+int ipc_recv(int accept_fd)
+{
+	struct sockaddr addr;
+	struct ucred cred;
+	int fd, err, res;
+	socklen_t len;
+	struct stgt_event *ev;
+	char nlm_ev[8192], *data;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+	struct iovec iov;
+	struct msghdr msg;
+
+	printf("%s %d\n", __FUNCTION__, __LINE__);
+
+	len = sizeof(addr);
+	if ((fd = accept(accept_fd, (struct sockaddr *) &addr, &len)) < 0) {
+		if (errno == EINTR)
+			err = -EINTR;
+		else
+			err = -EIO;
+
+		goto out;
+	}
+
+	len = sizeof(cred);
+	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
+	if (err < 0)
+		goto send;
+
+	if (cred.uid || cred.gid) {
+		err = -EPERM;
+		goto send;
+	}
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
+		err = -EIO;
+		goto out;
+	}
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		goto out;
+	data = NLMSG_DATA(nlh);
+
+	err = ipc_exec(nlh, data,
+		       nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)), &res);
+
+	printf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, res);
+
+send:
+	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
+	nlh->nlmsg_type = STGT_KEVENT_RESPONSE;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = 0;
+	ev = NLMSG_DATA(nlh);
+	ev->k.event_res.err = res;
+
+	err = write(fd, nlh, NLMSG_SPACE(sizeof(*ev)));
+
+out:
+	if (fd > 0)
+		close(fd);
+	return err;
+}

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-26 06:28:17 UTC (rev 21)
+++ trunk/usr/stgtd.c	2005-08-27 15:51:13 UTC (rev 22)
@@ -28,11 +28,15 @@
 } while (0)
 
 extern int disk_execute_cmnd(int tid, uint32_t lun, char *scb, char *data);
+extern int ipc_recv(int accept_fd);
+extern int ipc_listen(void);
 
 static struct sockaddr_nl src_addr, dest_addr;
 static void *nlm_recvbuf;
 static void *nlm_sendbuf;
 
+int nl_fd, ipc_fd;
+
 static int nl_write(int fd, int type, struct iovec *iovp, int count)
 {
 	int i, datalen;
@@ -69,7 +73,7 @@
 	return sendmsg(fd, &msg, 0);
 }
 
-static int nl_read(int ctrl_fd, char *data, int size, int flags)
+static int nl_read(int ctrl_fd, void *data, int size, int flags)
 {
 	int rc;
 	struct iovec iov;
@@ -89,9 +93,27 @@
 	return rc;
 }
 
+int request_execute(int fd, int type, struct iovec *iovp, int count, int *res)
+{
+	int err;
+	struct stgt_event *ev;
+	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
+
+	err = nl_write(fd, type, iovp, count);
+	if (err < 0)
+		return err;
+
+	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
+
+	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
+	*res = ev->k.event_res.err;
+
+	return err;
+}
+
 static int nl_open(void)
 {
-	int nl_fd, res;
+	int nl_fd, err, res;
 	struct stgt_event ev;
 	struct iovec iov;
 
@@ -114,9 +136,7 @@
 	iov.iov_base = &ev;
 	iov.iov_len = sizeof(ev);
 
-	if ((res = nl_write(nl_fd, STGT_UEVENT_START, &iov, 1)) < 0) {
-		return res;
-	}
+	err = request_execute(nl_fd, STGT_UEVENT_START, &iov, 1, &res);
 
 	return nl_fd;
 }
@@ -214,26 +234,35 @@
 	}
 }
 
-#define POLL_CTRL 0
+enum {
+	POLL_NL,
+	POLL_IPC,
+	POLL_MAX,
+};
 
 int main(int argc, char **argv)
 {
-	static struct pollfd poll_array[POLL_CTRL + 1];
-	int fd, err;
+	static struct pollfd poll_array[POLL_IPC + 1];
+	int err;
 
 	nlm_sendbuf = malloc(8192);
 	nlm_recvbuf = malloc(8192);
 
 	memset(poll_array, 0, sizeof(poll_array));
 
-	if ((fd = nl_open()) < 0)
-		exit(fd);
+	if ((nl_fd = nl_open()) < 0)
+		exit(nl_fd);
 
-	poll_array[POLL_CTRL].fd = fd;
-	poll_array[POLL_CTRL].events = POLLIN;
+	if ((ipc_fd = ipc_listen()) < 0)
+		exit(ipc_fd);
 
+	poll_array[POLL_NL].fd = nl_fd;
+	poll_array[POLL_NL].events = POLLIN;
+	poll_array[POLL_IPC].fd = ipc_fd;
+	poll_array[POLL_IPC].events = POLLIN;
+
 	while (1) {
-		if ((err = poll(poll_array, 1, -1)) < 0) {
+		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
 			if (errno != EINTR) {
 				eprintf("%d %d\n", err, errno);
 				exit(1);
@@ -241,8 +270,11 @@
 			continue;
 		}
 
-		if (poll_array[POLL_CTRL].revents)
-			handle_events(fd);
+		if (poll_array[POLL_NL].revents)
+			handle_events(nl_fd);
+
+		if (poll_array[POLL_IPC].revents)
+			ipc_recv(ipc_fd);
 	}
 
 	return 0;



From tomo at berlios.de  Sat Aug 27 17:53:08 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sat, 27 Aug 2005 17:53:08 +0200
Subject: [Stgt-svn] r23 - in trunk/iscsi: include kernel usr
Message-ID: <200508271553.j7RFr8LW009610@sheep.berlios.de>

Author: tomo
Date: 2005-08-27 17:53:08 +0200 (Sat, 27 Aug 2005)
New Revision: 23

Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/config.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/Makefile
   trunk/iscsi/usr/ctldev.c
   trunk/iscsi/usr/iscsid.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/plain.c
   trunk/iscsi/usr/target.c
Log:
IET configures devices through stgt (all IET device code has gone).

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/include/iet_u.h	2005-08-27 15:53:08 UTC (rev 23)
@@ -15,13 +15,6 @@
 	char name[ISCSI_NAME_LEN];
 };
 
-struct volume_info {
-	u32 tid;
-
-	u32 lun;
-	char args[ISCSI_ARGS_LEN]; /* FIXME */
-};
-
 struct session_info {
 	u32 tid;
 
@@ -118,8 +111,6 @@
 #define DEL_TARGET _IOW('i', 1, struct target_info)
 #define START_TARGET _IO('i', 2)
 #define STOP_TARGET _IO('i', 3)
-#define ADD_VOLUME _IOW('i', 4, struct volume_info)
-#define DEL_VOLUME _IOW('i', 5, struct volume_info)
 #define ADD_SESSION _IOW('i', 6, struct session_info)
 #define DEL_SESSION _IOW('i', 7, struct session_info)
 #define GET_SESSION_INFO _IOWR('i', 8, struct session_info)

Modified: trunk/iscsi/kernel/config.c
===================================================================
--- trunk/iscsi/kernel/config.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/kernel/config.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -162,28 +162,6 @@
 	return session_del(target, info.sid);
 }
 
-static int add_volume(struct iscsi_target *target, unsigned long ptr)
-{
-	int err;
-	struct volume_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	return volume_add(target, &info);
-}
-
-static int del_volume(struct iscsi_target *target, unsigned long ptr)
-{
-	int err;
-	struct volume_info info;
-
-	if ((err = copy_from_user(&info, (void *) ptr, sizeof(info))) < 0)
-		return err;
-
-	return volume_del(target, &info);
-}
-
 static int iscsi_param_config(struct iscsi_target *target, unsigned long ptr, int set)
 {
 	int err;
@@ -230,18 +208,11 @@
 		goto done;
 	}
 
-	target = target_lookup_by_id(id);
+	if (cmd != ADD_TARGET)
+		target = target_lookup_by_id(id);
 
-	if (cmd == ADD_TARGET)
-		if (target) {
-			err = -EEXIST;
-			eprintk("Target %u already exist!\n", id);
-			goto done;
-		}
-
 	switch (cmd) {
 	case ADD_TARGET:
-		assert(!target);
 		err = add_target(arg);
 		goto done;
 	}
@@ -258,14 +229,6 @@
 	}
 
 	switch (cmd) {
-	case ADD_VOLUME:
-		err = add_volume(target, arg);
-		break;
-
-	case DEL_VOLUME:
-		err = del_volume(target, arg);
-		break;
-
 	case ADD_SESSION:
 		err = add_session(target, arg);
 		break;

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-27 15:53:08 UTC (rev 23)
@@ -232,8 +232,6 @@
 struct iscsi_target *target_lookup_by_id(u32);
 extern int target_add(struct target_info *);
 extern int target_del(u32 id);
-extern int volume_del(struct iscsi_target *target, struct volume_info *info);
-extern int volume_add(struct iscsi_target *target, struct volume_info *info);
 
 /* config.c */
 extern int iet_procfs_init(void);

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/kernel/target.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -17,7 +17,6 @@
 
 static LIST_HEAD(target_list);
 static DECLARE_MUTEX(target_list_sem);
-static u32 next_target_id;
 static u32 nr_targets;
 
 static struct iscsi_sess_param default_session_param = {
@@ -118,21 +117,21 @@
 	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
 };
 
-static int iscsi_target_create(struct target_info *info, u32 tid)
+static int iscsi_target_create(struct target_info *info)
 {
 	int err = -EINVAL, len;
 	char *name = info->name;
 	struct iscsi_target *target;
 
-	dprintk(D_SETUP, "%u %s\n", tid, name);
+	dprintk(D_SETUP, "%s\n", name);
 
 	if (!(len = strlen(name))) {
-		eprintk("The length of the target name is zero %u\n", tid);
+		eprintk("%s", "The length of the target name is zero");
 		return err;
 	}
 
 	if (!try_module_get(THIS_MODULE)) {
-		eprintk("Fail to get module %u\n", tid);
+		eprintk("%s\n", "Fail to get module");
 		return err;
 	}
 
@@ -142,8 +141,6 @@
 	}
 	memset(target, 0, sizeof(*target));
 
-	target->tid = info->tid = tid;
-
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
@@ -165,6 +162,9 @@
 	target->stt = stgt_target_create(&iet_stgt_target_template);
 	assert(target->stt);
 
+	/* FIXME: We shouldn't access stt inside. */
+	target->tid = info->tid = target->stt->tid;
+
 	return 0;
 out:
 	kfree(target);
@@ -176,7 +176,6 @@
 int target_add(struct target_info *info)
 {
 	int err = -EEXIST;
-	u32 tid = info->tid;
 
 	down(&target_list_sem);
 
@@ -188,19 +187,10 @@
 	if (__target_lookup_by_name(info->name))
 		goto out;
 
-	if (tid && __target_lookup_by_id(tid))
+	if (info->tid)
 		goto out;
 
-	if (!tid) {
-		do {
-			if (!++next_target_id)
-				++next_target_id;
-		} while (__target_lookup_by_id(next_target_id));
-
-		tid = next_target_id;
-	}
-
-	if (!(err = iscsi_target_create(info, tid)))
+	if (!(err = iscsi_target_create(info)))
 		nr_targets++;
 out:
 	up(&target_list_sem);
@@ -279,81 +269,3 @@
 
 	return 0;
 }
-
-/*
- * Temporary device code
- */
-
-struct iscsi_device {
-	uint64_t lun;
-	struct list_head list;
-	struct stgt_device *sd;
-};
-
-struct iscsi_device *volume_lookup(struct iscsi_target *target, u32 lun)
-{
-	struct iscsi_device *device;
-	list_for_each_entry(device, &target->device_list, list) {
-		if (device->lun == lun)
-			return device;
-	}
-	return NULL;
-}
-
-int volume_add(struct iscsi_target *target, struct volume_info *info)
-{
-	char key_path[] = "Path=", key_type[] = "Type=";
-	char *p, *path = NULL, *type = NULL;
-	struct iscsi_device *device;
-	struct stgt_device *sd;
-	char *args = info->args;
-
-	while ((p = strsep(&args, ",")) != NULL) {
-		if (!*p) continue;
-
-		if (!strncmp(p, key_path, strlen(key_path)))
-			path = p + strlen(key_path);
-		else if (!strncmp(p, key_type, strlen(key_type)))
-			type = p + strlen(key_type);
-	}
-
-	if (volume_lookup(target, info->lun)) {
-		eprintk("%u\n", info->lun);
-		return -EEXIST;
-	}
-
-	if (!path)
-		return -EINVAL;
-
-	device = kmalloc(sizeof(*device), GFP_KERNEL);
-	if (!device)
-		return -ENOMEM;
-
-	eprintk("%u %s %s\n", info->lun, path, type);
-	sd = stgt_device_create(target->stt, type ? : "stgt_sd",
-				path, info->lun, 0);
-	if (!sd)
-		goto out;
-
-	device->sd = sd;
-	device->lun = info->lun;
-	list_add(&device->list, &target->device_list);
-	return 0;
-out:
-	kfree(device);
-	return -EINVAL;
-}
-
-int volume_del(struct iscsi_target *target, struct volume_info *info)
-{
-	struct iscsi_device *device;
-
-	device = volume_lookup(target, info->lun);
-	if (!device)
-		return -ENOENT;
-
-	stgt_device_destroy(device->sd);
-	list_del(&device->list);
-	kfree(device);
-	return 0;
-}

Modified: trunk/iscsi/usr/Makefile
===================================================================
--- trunk/iscsi/usr/Makefile	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/Makefile	2005-08-27 15:53:08 UTC (rev 23)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -I../include -I../../include
 PROGRAMS = ietd ietadm
 LIBS = -lcrypto
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/ctldev.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -103,45 +103,6 @@
 	return ioctl(ctrl_fd, DEL_TARGET, &info);
 }
 
-static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
-{
-	int err;
-	struct volume_info info;
-	char *p;
-
-	memset(&info, 0, sizeof(info));
-
-	info.tid = tid;
-	info.lun = lun;
-
-	while (isspace(*args))
-		args++;
-	if ((p = strchr(args, '\n')))
-		*p = '\0';
-
-	strncpy(info.args, args, sizeof(info.args) - 1);
-
-	if ((err = ioctl(ctrl_fd, ADD_VOLUME, &info)) < 0)
-		fprintf(stderr, "%s %d %d", __FUNCTION__, errno, err);
-
-	return err;
-}
-
-static int iscsi_lunit_destroy(u32 tid, u32 lun)
-{
-	int err;
-	struct volume_info info;
-
-	memset(&info, 0, sizeof(info));
-	info.tid = tid;
-	info.lun = lun;
-
-	if ((err = ioctl(ctrl_fd, DEL_VOLUME, &info)) < 0)
-		fprintf(stderr, "%s %d %d", __FUNCTION__, errno, err);
-
-	return err;
-}
-
 static int iscsi_conn_destroy(u32 tid, u64 sid, u32 cid)
 {
 	int err;
@@ -371,8 +332,6 @@
 
 struct iscsi_kernel_interface ioctl_ki = {
 	.ctldev_open = ctrdev_open,
-	.lunit_create = iscsi_lunit_create,
-	.lunit_destroy = iscsi_lunit_destroy,
 	.param_get = iscsi_param_get,
 	.param_set = iscsi_param_set,
 	.target_create = iscsi_target_create,

Modified: trunk/iscsi/usr/iscsid.c
===================================================================
--- trunk/iscsi/usr/iscsid.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/iscsid.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -356,7 +356,7 @@
 			return;
 		}
 
-		if (!(conn->tid = target_find_by_name(target_name)) ||
+		if (target_find_by_name(target_name, &conn->tid) < 0 ||
 		    cops->initiator_access(conn->tid, conn->fd) < 0) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/iscsid.h	2005-08-27 15:53:08 UTC (rev 23)
@@ -191,7 +191,7 @@
 /* target.c */
 extern int target_add(u32 *, char *);
 extern int target_del(u32);
-extern u32 target_find_by_name(const char *name);
+extern int target_find_by_name(const char *name, u32 *tid);
 struct target * target_find_by_id(u32);
 extern void target_list_build(struct connection *, char *, char *);
 
@@ -202,8 +202,6 @@
 /* ctldev.c */
 struct iscsi_kernel_interface {
 	int (*ctldev_open) (void);
-	int (*lunit_create) (u32 tid, u32 lun, char *args);
-	int (*lunit_destroy) (u32 tid, u32 lun);
 	int (*param_get) (u32, u64, struct iscsi_param *);
 	int (*param_set) (u32, u64, int, u32, struct iscsi_param *);
 	int (*target_create) (u32 *, char *);

Modified: trunk/iscsi/usr/plain.c
===================================================================
--- trunk/iscsi/usr/plain.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/plain.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -10,10 +10,13 @@
 #include <errno.h>
 #include <netdb.h>
 #include <stdio.h>
+#include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/socket.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
 
 #include <netinet/in.h>
 #include <netinet/tcp.h>
@@ -21,6 +24,7 @@
 #include <arpa/inet.h>
 
 #include "iscsid.h"
+#include "stgt_if.h"
 
 #define BUFSIZE		4096
 #define CONFIG_FILE	"/etc/ietd.conf"
@@ -108,10 +112,10 @@
 			continue;
 
 		if (!strcasecmp(p, "Target")) {
-			tid = 0;
 			if (!(p = target_sep_string(&q)))
 				continue;
-			tid = target_find_by_name(p);
+			if (target_find_by_name(p, &tid) < 0)
+				continue;
 		} else if (!((idx = param_index_by_name(p, user_keys)) < 0)) {
 			char *name, *pass;
 			name = target_sep_string(&q);
@@ -374,7 +378,7 @@
 
 static int initiator_match(u32 tid, int fd, char *filename)
 {
-	int err = 0;
+	int err = 0, tmp;
 	FILE *fp;
 	char buf[BUFSIZE], *p;
 
@@ -398,7 +402,7 @@
 			continue;
 		*(p++) = '\0';
 
-		if (target_find_by_name(buf) != tid)
+		if (target_find_by_name(buf, &tmp) < 0)
 			continue;
 
 		err = __initiator_match(fd, p);
@@ -424,15 +428,7 @@
 
 static int __plain_target_create(u32 *tid, char *name, int update)
 {
-	int err;
-
-	if ((err = target_add(tid, name)) < 0)
-		return err;
-
-	if (update)
-		; /* Update the config file here. */
-
-	return err;
+	return target_add(tid, name);
 }
 
 static int plain_target_create(u32 *tid, char *name)
@@ -451,27 +447,119 @@
 	return err;
 }
 
-static int __plain_lunit_create(u32 tid, u32 lun, char *args, int update)
+#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
+
+static int ipc_connect(void)
 {
-	int err;
+	int fd, err;
+	struct sockaddr_un addr;
 
-	if ((err = ki->lunit_create(tid, lun, args)) < 0)
-		return err;
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
 
-	if (update)
-		;
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
+	       strlen(STGT_IPC_NAMESPACE));
 
-	return err;
+	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		fd = err;
+
+	return fd;
 }
 
 static int plain_lunit_create(u32 tid, u32 lun, char *args)
 {
-	return __plain_lunit_create(tid, lun, args, 1);
+	int fd, err;
+	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
+	char dtype[] = "stgt_vsd";
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
+
+	fd = ipc_connect();
+	if (fd < 0) {
+		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, fd);
+		return fd;
+	}
+
+	if (isspace(*args))
+		args++;
+	if ((p = strchr(args, '\n')))
+		*p = '\0';
+
+	while ((p = strsep(&args, ","))) {
+		if (!p)
+			continue;
+
+		if (!(q = strchr(p, '=')))
+			continue;
+		*q++ = '\0';
+
+		if (!strcmp(p, "Path"))
+			path = q;
+		else if (!strcmp(p, "Type"))
+			type = q;
+	}
+
+	if (!type)
+		type = dtype;
+	if (!path) {
+		fprintf(stderr, "%s %d NULL path\n", __FUNCTION__, __LINE__);
+		return -EINVAL;
+	}
+
+	fprintf(stderr, "%s %d %s %s %d %d\n",
+		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev) + strlen(path));
+	nlh->nlmsg_type = STGT_UEVENT_DEVICE_CREATE;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = getpid();
+
+	ev = NLMSG_DATA(nlh);
+	ev->u.c_device.tid = tid;
+	ev->u.c_device.lun = lun;
+	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
+	memcpy((char *) ev + sizeof(*ev), path, strlen(path));
+
+	err = write(fd, nlm_ev, nlh->nlmsg_len);
+	if (err < 0)
+		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, err);
+
+	return err;
 }
 
 static int plain_lunit_destroy(u32 tid, u32 lun)
 {
-	return ki->lunit_destroy(tid, lun);
+	int fd, err;
+	char nlm_ev[8912];
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	fd = ipc_connect();
+	if (fd < 0) {
+		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, fd);
+		return fd;
+	}
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+
+	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
+	nlh->nlmsg_type = STGT_UEVENT_DEVICE_CREATE;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = getpid();
+
+	ev = NLMSG_DATA(nlh);
+	ev->u.d_device.tid = tid;
+	ev->u.d_device.lun = lun;
+
+	err = write(fd, nlm_ev, nlh->nlmsg_len);
+
+	return err;
 }
 
 static int __plain_param_set(u32 tid, u64 sid, int type,
@@ -515,13 +603,13 @@
 	FILE *config;
 	char buf[BUFSIZE];
 	char *p, *q;
-	int idx;
-	u32 tid, val;
+	int idx, tid;
+	u32 val;
 
 	if (!(config = fopen(filename, "r")))
 		return -errno;
 
-	tid = 0;
+	tid = -1;
 	while (fgets(buf, BUFSIZE, config)) {
 		q = buf;
 		p = target_sep_string(&q);
@@ -531,21 +619,22 @@
 			tid = 0;
 			if (!(p = target_sep_string(&q)))
 				continue;
-			if (__plain_target_create(&tid, p, 0))
-				log_debug(1, "creaing target %s", p);
-		} else if (!strcasecmp(p, "Alias") && tid) {
+			log_debug(1, "creaing target %s", p);
+			if (__plain_target_create(&tid, p, 0) < 0)
+				tid = -1;
+		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
 			;
-		} else if (!strcasecmp(p, "MaxSessions") && tid) {
+		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
 			/* target->max_sessions = strtol(q, &q, 0); */
-		} else if (!strcasecmp(p, "Lun") && tid) {
+		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
 			u32 lun = strtol(q, &q, 10);
-			__plain_lunit_create(tid, lun, q, 0);
-		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid) {
+			plain_lunit_create(tid, lun, q);
+		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
 			val = strtol(q, &q, 0);
 			if (param_check_val(target_keys, idx, &val) < 0)
 				log_warning("%s, %u\n", target_keys[idx].name, val);
 			iscsi_param_partial_set(tid, 0, key_target, idx, val);
-		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid) {
+		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
 			char *str = target_sep_string(&q);
 			if (param_str_to_val(session_keys, idx, str, &val) < 0)
 				continue;

Modified: trunk/iscsi/usr/target.c
===================================================================
--- trunk/iscsi/usr/target.c	2005-08-27 15:51:13 UTC (rev 22)
+++ trunk/iscsi/usr/target.c	2005-08-27 15:53:08 UTC (rev 23)
@@ -31,16 +31,18 @@
 	}
 }
 
-u32 target_find_by_name(const char *name)
+int target_find_by_name(const char *name, u32 *tid)
 {
 	struct target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
-		if (!strcmp(target->name, name))
-			return target->tid;
+		if (!strcmp(target->name, name)) {
+			*tid = target->tid;
+			return 0;
+		}
 	}
 
-	return 0;
+	return -ENOENT;
 }
 
 struct target* target_find_by_id(u32 tid)



From tomo at berlios.de  Sun Aug 28 05:31:26 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 28 Aug 2005 05:31:26 +0200
Subject: [Stgt-svn] r24 - in trunk: iscsi/usr kernel usr
Message-ID: <200508280331.j7S3VQ8B019924@sheep.berlios.de>

Author: tomo
Date: 2005-08-28 05:31:21 +0200 (Sun, 28 Aug 2005)
New Revision: 24

Modified:
   trunk/iscsi/usr/ctldev.c
   trunk/iscsi/usr/ietadm.c
   trunk/iscsi/usr/iscsid.h
   trunk/iscsi/usr/plain.c
   trunk/kernel/stgt.c
   trunk/usr/stgtd.c
Log:
Fix and clean up IET shutdown code. 'ietadm --op delete' works with no activity.


Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/iscsi/usr/ctldev.c	2005-08-28 03:31:21 UTC (rev 24)
@@ -10,12 +10,17 @@
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
+#include <dirent.h>
 
 #include <sys/ioctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
 
 #include "iscsid.h"
+#include "stgt_if.h"
 
 #define CTL_DEVICE	"/dev/ietctl"
 
@@ -123,11 +128,6 @@
 	return ki->conn_destroy(tid, sid, cid);
 }
 
-static int __target_del(int fd, u32 tid, void *arg)
-{
-	return ki->target_destroy(tid);
-}
-
 static int proc_session_parse(int fd, struct session_file_operations *ops, void *arg)
 {
 	FILE *f;
@@ -195,19 +195,37 @@
 	.connection_op = conn_retry,
 };
 
-struct session_file_operations target_del_ops = {
-	.target_op = __target_del,
-};
-
 int server_stop(void)
 {
-	proc_session_parse(ctrl_fd, &conn_close_ops, NULL);
+	DIR *dir;
+	struct dirent *ent;
+	int tid, err;
+	int32_t lun;
 
-	while (proc_session_parse(ctrl_fd, &shutdown_wait_ops, NULL) < 0)
-		sleep(1);
+	dir = opendir("/sys/class/stgt_device");
+	if (!dir)
+		return errno;
 
-	proc_session_parse(ctrl_fd, &target_del_ops, NULL);
+	while ((ent = readdir(dir))) {
+		err = sscanf(ent->d_name, "device%d:%u", &tid, &lun);
+		if (err == 2)
+			err = cops->lunit_del(tid, lun);
+	}
 
+	closedir(dir);
+
+	dir = opendir("/sys/class/stgt_target");
+	if (!dir)
+		return errno;
+
+	while ((ent = readdir(dir))) {
+		err = sscanf(ent->d_name, "target%d", &tid);
+		if (err == 1)
+			err = cops->target_del(tid);
+	}
+
+	closedir(dir);
+
 	return 0;
 }
 
@@ -330,8 +348,138 @@
 	return ioctl(ctrl_fd, ADD_CONN, &info);
 }
 
+/* Temporary stgt glue */
+#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
+
+static int ipc_cmnd_execute(char *data, int len)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+	char nlm_ev[NLMSG_SPACE(sizeof(struct stgt_event))];
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
+	       strlen(STGT_IPC_NAMESPACE));
+
+	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0)
+		return err;
+
+	err = write(fd, data, len);
+	if (err < 0)
+		goto out;
+
+	err = read(fd, nlm_ev, sizeof(nlm_ev));
+	if (err < 0)
+		goto out;
+
+	ev = NLMSG_DATA(nlh);
+	err = ev->k.event_res.err;
+
+out:
+	if (fd > 0)
+		close(fd);
+
+	return fd;
+}
+
+static void nlmsg_init(struct nlmsghdr *nlh, u32 pid, u32 seq, int type,
+		       int len, int flags)
+{
+	nlh->nlmsg_pid = pid;
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_type = type;
+	nlh->nlmsg_seq = seq;
+}
+
+static int iscsi_lunit_create(u32 tid, u32 lun, char *args)
+{
+	int err;
+	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
+	char dtype[] = "stgt_vsd";
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
+
+	if (isspace(*args))
+		args++;
+	if ((p = strchr(args, '\n')))
+		*p = '\0';
+
+	while ((p = strsep(&args, ","))) {
+		if (!p)
+			continue;
+
+		if (!(q = strchr(p, '=')))
+			continue;
+		*q++ = '\0';
+
+		if (!strcmp(p, "Path"))
+			path = q;
+		else if (!strcmp(p, "Type"))
+			type = q;
+	}
+
+	if (!type)
+		type = dtype;
+	if (!path) {
+		fprintf(stderr, "%s %d NULL path\n", __FUNCTION__, __LINE__);
+		return -EINVAL;
+	}
+
+	fprintf(stderr, "%s %d %s %s %d %d\n",
+		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_CREATE,
+		   NLMSG_SPACE(sizeof(*ev) + strlen(path)), 0);
+
+	ev = NLMSG_DATA(nlh);
+	ev->u.c_device.tid = tid;
+	ev->u.c_device.lun = lun;
+	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
+	memcpy((char *) ev + sizeof(*ev), path, strlen(path));
+
+	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+
+	return err;
+}
+
+static int iscsi_lunit_destroy(u32 tid, u32 lun)
+{
+	int err;
+	char nlm_ev[8912];
+	struct stgt_event *ev;
+	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
+
+	fprintf(stderr, "%s %d %d %u\n", __FUNCTION__, __LINE__, tid, lun);
+
+	memset(nlm_ev, 0, sizeof(nlm_ev));
+	nlmsg_init(nlh, getpid(), 0, STGT_UEVENT_DEVICE_DESTROY,
+		   NLMSG_SPACE(sizeof(*ev)), 0);
+
+	ev = NLMSG_DATA(nlh);
+	ev->u.d_device.tid = tid;
+	ev->u.d_device.lun = lun;
+
+	err = ipc_cmnd_execute(nlm_ev, nlh->nlmsg_len);
+
+	return err;
+}
+
 struct iscsi_kernel_interface ioctl_ki = {
 	.ctldev_open = ctrdev_open,
+	.lunit_create = iscsi_lunit_create,
+	.lunit_destroy = iscsi_lunit_destroy,
 	.param_get = iscsi_param_get,
 	.param_set = iscsi_param_set,
 	.target_create = iscsi_target_create,

Modified: trunk/iscsi/usr/ietadm.c
===================================================================
--- trunk/iscsi/usr/ietadm.c	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/iscsi/usr/ietadm.c	2005-08-28 03:31:21 UTC (rev 24)
@@ -462,7 +462,7 @@
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1;
-	u32 tid = 0, cid = 0, lun = 0, set = 0;
+	u32 tid = -1, cid = 0, lun = 0, set = 0;
 	u64 sid = 0;
 	char *params = NULL;
 

Modified: trunk/iscsi/usr/iscsid.h
===================================================================
--- trunk/iscsi/usr/iscsid.h	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/iscsi/usr/iscsid.h	2005-08-28 03:31:21 UTC (rev 24)
@@ -202,6 +202,8 @@
 /* ctldev.c */
 struct iscsi_kernel_interface {
 	int (*ctldev_open) (void);
+	int (*lunit_create) (u32 tid, u32 lun, char *args);
+	int (*lunit_destroy) (u32 tid, u32 lun);
 	int (*param_get) (u32, u64, struct iscsi_param *);
 	int (*param_set) (u32, u64, int, u32, struct iscsi_param *);
 	int (*target_create) (u32 *, char *);

Modified: trunk/iscsi/usr/plain.c
===================================================================
--- trunk/iscsi/usr/plain.c	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/iscsi/usr/plain.c	2005-08-28 03:31:21 UTC (rev 24)
@@ -24,7 +24,6 @@
 #include <arpa/inet.h>
 
 #include "iscsid.h"
-#include "stgt_if.h"
 
 #define BUFSIZE		4096
 #define CONFIG_FILE	"/etc/ietd.conf"
@@ -447,119 +446,14 @@
 	return err;
 }
 
-#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
-
-static int ipc_connect(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
-
-	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		fd = err;
-
-	return fd;
-}
-
 static int plain_lunit_create(u32 tid, u32 lun, char *args)
 {
-	int fd, err;
-	char nlm_ev[8912], *p, *q, *type = NULL, *path = NULL;
-	char dtype[] = "stgt_vsd";
-	struct stgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
-
-	fprintf(stderr, "%s %d %s\n", __FUNCTION__, __LINE__, args);
-
-	fd = ipc_connect();
-	if (fd < 0) {
-		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, fd);
-		return fd;
-	}
-
-	if (isspace(*args))
-		args++;
-	if ((p = strchr(args, '\n')))
-		*p = '\0';
-
-	while ((p = strsep(&args, ","))) {
-		if (!p)
-			continue;
-
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-
-		if (!strcmp(p, "Path"))
-			path = q;
-		else if (!strcmp(p, "Type"))
-			type = q;
-	}
-
-	if (!type)
-		type = dtype;
-	if (!path) {
-		fprintf(stderr, "%s %d NULL path\n", __FUNCTION__, __LINE__);
-		return -EINVAL;
-	}
-
-	fprintf(stderr, "%s %d %s %s %d %d\n",
-		__FUNCTION__, __LINE__, type, path, strlen(path), sizeof(*ev));
-
-	memset(nlm_ev, 0, sizeof(nlm_ev));
-	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev) + strlen(path));
-	nlh->nlmsg_type = STGT_UEVENT_DEVICE_CREATE;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
-
-	ev = NLMSG_DATA(nlh);
-	ev->u.c_device.tid = tid;
-	ev->u.c_device.lun = lun;
-	strncpy(ev->u.c_device.type, type, sizeof(ev->u.c_device.type));
-	memcpy((char *) ev + sizeof(*ev), path, strlen(path));
-
-	err = write(fd, nlm_ev, nlh->nlmsg_len);
-	if (err < 0)
-		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, err);
-
-	return err;
+	return ki->lunit_create(tid, lun, args);
 }
 
 static int plain_lunit_destroy(u32 tid, u32 lun)
 {
-	int fd, err;
-	char nlm_ev[8912];
-	struct stgt_event *ev;
-	struct nlmsghdr *nlh = (struct nlmsghdr *) nlm_ev;
-
-	fd = ipc_connect();
-	if (fd < 0) {
-		fprintf(stderr, "%s %d %d\n", __FUNCTION__, __LINE__, fd);
-		return fd;
-	}
-
-	memset(nlm_ev, 0, sizeof(nlm_ev));
-
-	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
-	nlh->nlmsg_type = STGT_UEVENT_DEVICE_CREATE;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
-
-	ev = NLMSG_DATA(nlh);
-	ev->u.d_device.tid = tid;
-	ev->u.d_device.lun = lun;
-
-	err = write(fd, nlm_ev, nlh->nlmsg_len);
-
-	return err;
+	return ki->lunit_destroy(tid, lun);
 }
 
 static int __plain_param_set(u32 tid, u64 sid, int type,

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/kernel/stgt.c	2005-08-28 03:31:21 UTC (rev 24)
@@ -138,9 +138,10 @@
 	struct stgt_target *target;
 
 	spin_lock(&all_targets_lock);
-	list_for_each_entry(target, &all_targets, tlist)
+	list_for_each_entry(target, &all_targets, tlist) {
 		if (target->tid == tid)
 			goto found;
+	}
 	spin_unlock(&all_targets_lock);
 	target = NULL;
 found:
@@ -190,6 +191,8 @@
 
 int stgt_target_destroy(struct stgt_target *target)
 {
+	dprintk("%p\n", target);
+
 	spin_lock(&all_targets_lock);
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
@@ -469,7 +472,7 @@
 static int stgt_device_destroy(int tid, uint32_t lun)
 {
 	struct stgt_device *device;
-	struct stgt_target *target = device->target;
+	struct stgt_target *target;
 	unsigned long flags;
 
 	target = target_find(tid);
@@ -795,6 +798,10 @@
 		dprintk("start %d\n", daemon_pid);
 		break;
 	case STGT_UEVENT_DEVICE_CREATE:
+		if (nlh->nlmsg_len <= NLMSG_SPACE(sizeof(*ev))) {
+			err = -EINVAL;
+			break;
+		}
 		err = stgt_device_create(ev->u.c_device.tid,
 					 ev->u.c_device.lun,
 					 ev->u.c_device.type,
@@ -853,7 +860,7 @@
 			rlen = skb->len;
 		err = event_recv_msg(skb, nlh);
 
-		printk("%d %d\n", nlh->nlmsg_type, err);
+		eprintk("%d %d\n", nlh->nlmsg_type, err);
 		ev->k.event_res.err = err;
 		if (nlh->nlmsg_type != STGT_UEVENT_SCSI_CMND_RES)
 			send_event_res(NETLINK_CREDS(skb)->pid,

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-27 15:53:08 UTC (rev 23)
+++ trunk/usr/stgtd.c	2005-08-28 03:31:21 UTC (rev 24)
@@ -14,10 +14,11 @@
 #include <string.h>
 #include <stdint.h>
 #include <unistd.h>
+#include <signal.h>
+#include <sys/signal.h>
 #include <sys/poll.h>
-
+#include <sys/socket.h>
 #include <asm/types.h>
-#include <sys/socket.h>
 #include <linux/netlink.h>
 
 #include <stgt_if.h>
@@ -208,7 +209,9 @@
 			return;
 		if (errno == EINTR)
 			goto retry;
-		exit(1);
+
+		eprintf("%d\n", err);
+		return;
 	}
 
 	nlh = (struct nlmsghdr *) nlm_ev;
@@ -229,6 +232,7 @@
 		execute_cmnd(fd, recvbuf, sendbuf);
 		break;
 	default:
+		eprintf("unknown %u\n", nlh->nlmsg_type);
 		exit(-1);
 		break;
 	}
@@ -240,6 +244,9 @@
 	POLL_MAX,
 };
 
+static void catch_signal(int signo) {
+}
+
 int main(int argc, char **argv)
 {
 	static struct pollfd poll_array[POLL_IPC + 1];
@@ -248,6 +255,17 @@
 	nlm_sendbuf = malloc(8192);
 	nlm_recvbuf = malloc(8192);
 
+	struct sigaction sa_old;
+	struct sigaction sa_new;
+
+	/* do not allow ctrl-c for now... */
+	sa_new.sa_handler = catch_signal;
+	sigemptyset(&sa_new.sa_mask);
+	sa_new.sa_flags = 0;
+	sigaction(SIGINT, &sa_new, &sa_old );
+	sigaction(SIGPIPE, &sa_new, &sa_old );
+	sigaction(SIGTERM, &sa_new, &sa_old );
+
 	memset(poll_array, 0, sizeof(poll_array));
 
 	if ((nl_fd = nl_open()) < 0)



From tomo at berlios.de  Sun Aug 28 10:38:38 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Sun, 28 Aug 2005 10:38:38 +0200
Subject: [Stgt-svn] r25 - in trunk: include iscsi/usr usr
Message-ID: <200508280838.j7S8cctq005270@sheep.berlios.de>

Author: tomo
Date: 2005-08-28 10:38:37 +0200 (Sun, 28 Aug 2005)
New Revision: 25

Added:
   trunk/usr/netlink.c
   trunk/usr/stgtd.h
Modified:
   trunk/include/stgt_if.h
   trunk/iscsi/usr/ctldev.c
   trunk/usr/Makefile
   trunk/usr/ipc.c
   trunk/usr/scsi.c
   trunk/usr/stgtd.c
Log:
Cleanup of user-space stgt code.

Modified: trunk/include/stgt_if.h
===================================================================
--- trunk/include/stgt_if.h	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/include/stgt_if.h	2005-08-28 08:38:37 UTC (rev 25)
@@ -6,6 +6,8 @@
 #ifndef __SCSI_TARGET_IF_H
 #define __SCSI_TARGET_IF_H
 
+#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
+
 enum stgt_event_type {
 	/* user -> kernel */
 	STGT_UEVENT_START,
@@ -34,6 +36,7 @@
 		struct {
 			uint64_t cid;
 			uint32_t size;
+			int err;
 		} cmnd_res;
 	} u;
 

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/iscsi/usr/ctldev.c	2005-08-28 08:38:37 UTC (rev 25)
@@ -349,7 +349,6 @@
 }
 
 /* Temporary stgt glue */
-#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
 
 static int ipc_cmnd_execute(char *data, int len)
 {

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/Makefile	2005-08-28 08:38:37 UTC (rev 25)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-stgtd: stgtd.o scsi.o ipc.o
+stgtd: stgtd.o scsi.o netlink.o ipc.o
 	$(CC) $^ -o $@ $(LIBS)
 
 clean:

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/ipc.c	2005-08-28 08:38:37 UTC (rev 25)
@@ -1,4 +1,6 @@
 /*
+ * Unix domain socket for ipc
+ *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  *
  * This code is licenced under the GPL.
@@ -17,50 +19,10 @@
 #include <linux/netlink.h>
 
 #include <stgt_if.h>
+#include "stgtd.h"
 
-extern int nl_fd;
-extern int request_execute(int fd, int type, struct iovec *iovp, int count, int *res);
-
-#define STGT_IPC_NAMESPACE "STGT_IPC_ABSTRACT_NAMESPACE"
-
-int ipc_listen(void)
+void ipc_event_handle(int accept_fd)
 {
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
-	       strlen(STGT_IPC_NAMESPACE));
-
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		return err;
-
-	if ((err = listen(fd, 32)) < 0)
-		return err;
-
-	return fd;
-}
-
-static int ipc_exec(struct nlmsghdr *nlh, char *data, int len, int *res)
-{
-	int err;
-	struct iovec iov;
-
-	iov.iov_base = data;
-	iov.iov_len = len;
-
-	err = request_execute(nl_fd, nlh->nlmsg_type, &iov, 1, res);
-
-	return err;
-}
-
-int ipc_recv(int accept_fd)
-{
 	struct sockaddr addr;
 	struct ucred cred;
 	int fd, err, res;
@@ -71,7 +33,7 @@
 	struct iovec iov;
 	struct msghdr msg;
 
-	printf("%s %d\n", __FUNCTION__, __LINE__);
+	dprintf("%s %d\n", __FUNCTION__, __LINE__);
 
 	len = sizeof(addr);
 	if ((fd = accept(accept_fd, (struct sockaddr *) &addr, &len)) < 0) {
@@ -116,10 +78,11 @@
 		goto out;
 	data = NLMSG_DATA(nlh);
 
-	err = ipc_exec(nlh, data,
-		       nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)), &res);
+	err = nl_cmnd_call(nl_fd, nlh->nlmsg_type, data,
+			   nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr)),
+			   &res);
 
-	printf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, res);
+	dprintf("%s %d %d %d\n", __FUNCTION__, __LINE__, err, res);
 
 send:
 	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
@@ -134,5 +97,27 @@
 out:
 	if (fd > 0)
 		close(fd);
-	return err;
 }
+
+int ipc_open(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, STGT_IPC_NAMESPACE,
+	       strlen(STGT_IPC_NAMESPACE));
+
+	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		return err;
+
+	if ((err = listen(fd, 32)) < 0)
+		return err;
+
+	return fd;
+}

Copied: trunk/usr/netlink.c (from rev 24, trunk/usr/stgtd.c)
===================================================================
--- trunk/usr/stgtd.c	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/netlink.c	2005-08-28 08:38:37 UTC (rev 25)
@@ -0,0 +1,232 @@
+/*
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ *
+ * Netlink functions are based on open-iscsi code
+ * written by Dmitry Yusupov and Alex Aizman.
+ *
+ * This code is licenced under the GPL.
+ */
+
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/signal.h>
+#include <sys/poll.h>
+#include <sys/socket.h>
+#include <asm/types.h>
+#include <linux/netlink.h>
+
+#include <stgt_if.h>
+#include "stgtd.h"
+
+#define	NL_BUFSIZE	8192
+
+static struct sockaddr_nl src_addr, dest_addr;
+static char *recvbuf, *sendbuf;
+
+static int nl_write(int fd, int type, struct iovec *iovp, int count)
+{
+	int i, datalen;
+	struct iovec iov[8];
+	struct msghdr msg;
+	struct nlmsghdr nlh;
+
+	for (datalen = 0, i = 0; i < count; i++)
+		datalen += iovp[i].iov_len;
+
+	memset(&nlh, 0, sizeof(nlh));
+	nlh.nlmsg_len = NLMSG_SPACE(datalen);
+	nlh.nlmsg_type = type;
+	nlh.nlmsg_flags = 0;
+	nlh.nlmsg_pid = getpid();
+
+	iov[0].iov_base = &nlh;
+	iov[0].iov_len = sizeof(nlh);
+
+	for (i = 1; i <= count; i++) {
+		iov[i].iov_base = iovp->iov_base;
+		iov[i].iov_len = iovp->iov_len;
+		iovp++;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_name= (void*) &dest_addr;
+	msg.msg_namelen = sizeof(dest_addr);
+	msg.msg_iov = (void *) &iov;
+	msg.msg_iovlen = count + 1;
+
+	return sendmsg(fd, &msg, 0);
+}
+
+static int nl_read(int fd, void *data, int size, int flags)
+{
+	int rc;
+	struct iovec iov;
+	struct msghdr msg;
+
+	iov.iov_base = data;
+	iov.iov_len = size;
+
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_name= (void*) &src_addr;
+	msg.msg_namelen = sizeof(src_addr);
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	rc = recvmsg(fd, &msg, flags);
+
+	return rc;
+}
+
+int nl_cmnd_call(int fd, int type, char *data, int size, int *res)
+{
+	int err;
+	struct iovec iov;
+	struct stgt_event *ev;
+	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
+
+	iov.iov_base = data;
+	iov.iov_len = size;
+
+	err = nl_write(fd, type, &iov, 1);
+	if (err < 0)
+		return err;
+
+	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
+
+	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
+	*res = ev->k.event_res.err;
+
+	return err;
+}
+
+static int scsi_cmnd_queue(int fd, char *reqbuf, char *resbuf)
+{
+	int size;
+	struct iovec iov[2];
+	struct stgt_event *ev = (struct stgt_event *) reqbuf;
+	uint64_t cid = ev->k.cmnd_req.cid;
+	uint8_t *scb;
+
+	memset(resbuf, 0, NL_BUFSIZE);
+	scb = reqbuf + sizeof(*ev);
+	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
+
+	size = scsi_cmnd_process(ev->k.cmnd_req.tid, ev->k.cmnd_req.lun,
+				scb, resbuf);
+
+	/* TODO: error handling */
+	memset(ev, 0, sizeof(*ev));
+	ev->u.cmnd_res.cid = cid;
+	ev->u.cmnd_res.size = size;
+	ev->u.cmnd_res.err = 0;
+
+	iov[0].iov_base = ev;
+	iov[0].iov_len = sizeof(*ev);
+	iov[1].iov_base = resbuf;
+	iov[1].iov_len = size;
+
+	return nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, size ? 2 : 1);
+}
+
+void nl_event_handle(int fd)
+{
+	struct nlmsghdr *nlh;
+	struct stgt_event *ev;
+	int err;
+
+peek_again:
+	err = nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN)
+			return;
+		if (errno == EINTR)
+			goto peek_again;
+		return;
+	}
+
+	nlh = (struct nlmsghdr *) recvbuf;
+	ev = (struct stgt_event *) NLMSG_DATA(nlh);
+
+	dprintf("%d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
+
+read_again:
+	err = nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN)
+			return;
+		if (errno == EINTR)
+			goto read_again;
+		return;
+	}
+
+	switch (nlh->nlmsg_type) {
+	case STGT_KEVENT_SCSI_CMND_REQ:
+		scsi_cmnd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
+		break;
+	default:
+		/* kernel module bug */
+		eprintf("unknown event %u\n", nlh->nlmsg_type);
+		exit(-1);
+		break;
+	}
+}
+
+static void nl_start(int fd)
+{
+	int err, res;
+	struct stgt_event ev;
+
+	err = nl_cmnd_call(fd, STGT_UEVENT_START, (char *) &ev, sizeof(ev), &res);
+	if (err < 0 || res < 0) {
+		eprintf("%d %d\n", err, res);
+		exit(-1);
+	}
+}
+
+int nl_open(void)
+{
+	int fd, err;
+
+	sendbuf = malloc(NL_BUFSIZE * 2);
+	if (!sendbuf)
+		return -ENOMEM;
+	recvbuf = sendbuf + NL_BUFSIZE;
+
+	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_STGT);
+	if (fd < 0) {
+		eprintf("%d\n", fd);
+		return fd;
+	}
+
+	memset(&src_addr, 0, sizeof(src_addr));
+	src_addr.nl_family = AF_NETLINK;
+	src_addr.nl_pid = getpid();
+	src_addr.nl_groups = 0; /* not in mcast groups */
+
+	err = bind(fd, (struct sockaddr *)&src_addr, sizeof(src_addr));
+	if (err < 0) {
+		eprintf("%d\n", fd);
+		goto out;
+	}
+
+	memset(&dest_addr, 0, sizeof(dest_addr));
+	dest_addr.nl_family = AF_NETLINK;
+	dest_addr.nl_pid = 0; /* kernel */
+	dest_addr.nl_groups = 0; /* unicast */
+
+	nl_start(fd);
+
+	return fd;
+
+out:
+	close(fd);
+	return err;
+}

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/scsi.c	2005-08-28 08:38:37 UTC (rev 25)
@@ -1,4 +1,6 @@
 /*
+ * SCSI command processing
+ *
  * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
  * This code is licenced under the GPL.
  *
@@ -18,6 +20,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
+#include "stgtd.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -33,11 +36,6 @@
 
 static uint32_t blk_shift = 9;
 
-#define eprintf(fmt, args...)						\
-do {									\
-	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
 #define min(x,y) ({ \
 	typeof(x) _x = (x);	\
 	typeof(y) _y = (y);	\
@@ -371,11 +369,11 @@
 	return len;
 }
 
-int disk_execute_cmnd(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
+int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data)
 {
-	int len = -1;
+	int len = 0;
 
-	eprintf("%x\n", scb[0]);
+	dprintf("%x\n", scb[0]);
 
 	switch (scb[0]) {
 	case INQUIRY:

Modified: trunk/usr/stgtd.c
===================================================================
--- trunk/usr/stgtd.c	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/stgtd.c	2005-08-28 08:38:37 UTC (rev 25)
@@ -1,277 +1,152 @@
 /*
- * Event notification code.
+ * SCSI target framework user-space daemon
+ *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * This code is licenced under the GPL.
  *
- * Netlink functions are taken from open-iscsi code
- * written by Dmitry Yusupov and Alex Aizman.
+ * This code is licenced under the GPL.
  */
 
 #include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
 #include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
+#include <signal.h>
 #include <string.h>
 #include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
-#include <signal.h>
-#include <sys/signal.h>
-#include <sys/poll.h>
-#include <sys/socket.h>
 #include <asm/types.h>
-#include <linux/netlink.h>
+#include <sys/poll.h>
+#include <sys/signal.h>
+#include <sys/stat.h>
 
 #include <stgt_if.h>
+#include "stgtd.h"
 
-#define eprintf(fmt, args...)						\
-do {									\
-	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
-} while (0)
-
-extern int disk_execute_cmnd(int tid, uint32_t lun, char *scb, char *data);
-extern int ipc_recv(int accept_fd);
-extern int ipc_listen(void);
-
-static struct sockaddr_nl src_addr, dest_addr;
-static void *nlm_recvbuf;
-static void *nlm_sendbuf;
-
 int nl_fd, ipc_fd;
+uint32_t stgtd_debug = 1;
 
-static int nl_write(int fd, int type, struct iovec *iovp, int count)
+enum {
+	POLL_NL,
+	POLL_IPC,
+	POLL_MAX,
+};
+
+static struct option const long_options[] =
 {
-	int i, datalen;
-	struct iovec iov;
-	struct msghdr msg;
-	struct nlmsghdr *nlh;
+	{"foreground", no_argument, 0, 'f'},
+	{"debug", required_argument, 0, 'd'},
+	{"version", no_argument, 0, 'v'},
+	{"help", no_argument, 0, 'h'},
+	{0, 0, 0, 0},
+};
 
-	for (datalen = 0, i = 0; i < count; i++)
-		datalen += iovp[i].iov_len;
+static char program_name[] = "stgtd";
 
-	nlh = nlm_sendbuf;
-	memset(nlh, 0, NLMSG_SPACE(datalen));
-
-	nlh->nlmsg_len = NLMSG_SPACE(datalen);
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
-
-	for (datalen = 0, i = 0; i < count; i++) {
-		memcpy(NLMSG_DATA(nlh) + datalen, iovp[i].iov_base,
-		       iovp[i].iov_len);
-		datalen += iovp[i].iov_len;
+static void usage(int status)
+{
+	if (status != 0)
+		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
+	else {
+		printf("Usage: %s [OPTION]\n", program_name);
+		printf("\
+SCSI target daemon.\n\
+  -f, --foreground        make the program run in the foreground\n\
+  -d, --debug debuglevel  print debugging information\n\
+  -h, --help              display this help and exit\n\
+");
 	}
-
-	iov.iov_base = (void *) nlh;
-	iov.iov_len = nlh->nlmsg_len;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &dest_addr;
-	msg.msg_namelen = sizeof(dest_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	return sendmsg(fd, &msg, 0);
+	exit(1);
 }
 
-static int nl_read(int ctrl_fd, void *data, int size, int flags)
-{
-	int rc;
-	struct iovec iov;
-	struct msghdr msg;
-
-	iov.iov_base = data;
-	iov.iov_len = size;
-
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*)&src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	rc = recvmsg(ctrl_fd, &msg, flags);
-
-	return rc;
+static void signal_catch(int signo) {
 }
 
-int request_execute(int fd, int type, struct iovec *iovp, int count, int *res)
+static void init(void)
 {
-	int err;
-	struct stgt_event *ev;
-	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
+	int fd;
+	char path[64];
+	struct sigaction sa_old;
+	struct sigaction sa_new;
 
-	err = nl_write(fd, type, iovp, count);
-	if (err < 0)
-		return err;
+	/* do not allow ctrl-c for now... */
+	sa_new.sa_handler = signal_catch;
+	sigemptyset(&sa_new.sa_mask);
+	sa_new.sa_flags = 0;
+	sigaction(SIGINT, &sa_new, &sa_old );
+	sigaction(SIGPIPE, &sa_new, &sa_old );
+	sigaction(SIGTERM, &sa_new, &sa_old );
 
-	err = nl_read(fd, nlm_ev, sizeof(nlm_ev), 0);
+	/* Should we use RT stuff? */
+	nice(-20);
 
-	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
-	*res = ev->k.event_res.err;
-
-	return err;
-}
-
-static int nl_open(void)
-{
-	int nl_fd, err, res;
-	struct stgt_event ev;
-	struct iovec iov;
-
-	if (!(nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_STGT)))
-		return -1;
-
-	memset(&src_addr, 0, sizeof(src_addr));
-	src_addr.nl_family = AF_NETLINK;
-	src_addr.nl_pid = getpid();
-	src_addr.nl_groups = 0; /* not in mcast groups */
-	if (bind(nl_fd, (struct sockaddr *)&src_addr, sizeof(src_addr))) {
-		return -1;
+	/* Avoid oom-killer */
+	sprintf(path, "/proc/%d/oom_adj", getpid());
+	fd = open(path, O_WRONLY);
+	if (fd < 0) {
+		eprintf("can not adjust oom-killer's pardon %s\n", path);
+		return;
 	}
-
-	memset(&dest_addr, 0, sizeof(dest_addr));
-	dest_addr.nl_family = AF_NETLINK;
-	dest_addr.nl_pid = 0; /* kernel */
-	dest_addr.nl_groups = 0; /* unicast */
-
-	iov.iov_base = &ev;
-	iov.iov_len = sizeof(ev);
-
-	err = request_execute(nl_fd, STGT_UEVENT_START, &iov, 1, &res);
-
-	return nl_fd;
+	write(fd, "-17\n", 4);
+	close(fd);
 }
 
-static int
-nlpayload_read(int ctrl_fd, char *data, int count, int flags)
+static void event_loop(struct pollfd *poll_array)
 {
-	int rc;
-	struct iovec iov;
-	struct msghdr msg;
-
-	iov.iov_base = nlm_recvbuf;
-	iov.iov_len = NLMSG_SPACE(count);
-	memset(iov.iov_base, 0, iov.iov_len);
-
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*)&src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	rc = recvmsg(ctrl_fd, &msg, flags);
-
-	memcpy(data, NLMSG_DATA(iov.iov_base), count);
-
-	return rc;
-}
-
-static int execute_cmnd(int fd, char *recvbuf, char *sendbuf)
-{
 	int err;
-	struct iovec iov[2];
-	struct stgt_event uev, *ev = (struct stgt_event *) recvbuf;
-	uint8_t *scb;
 
-	scb = recvbuf + sizeof(*ev);
-	eprintf("%" PRIu64 " %x\n", ev->k.cmnd_req.cid, scb[0]);
+	while (1) {
+		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
+			if (errno != EINTR) {
+				eprintf("%d %d\n", err, errno);
+				exit(1);
+			}
+			continue;
+		}
 
-	err = disk_execute_cmnd(ev->k.cmnd_req.tid,
-				ev->k.cmnd_req.lun,
-				scb, sendbuf);
-	if (err < 0)
-		return err;
+		if (poll_array[POLL_NL].revents)
+			nl_event_handle(nl_fd);
 
-	uev.u.cmnd_res.cid = ev->k.cmnd_req.cid;
-	uev.u.cmnd_res.size = err;
-
-	iov[0].iov_base = (void *) &uev;
-	iov[0].iov_len = sizeof(uev);
-	iov[1].iov_base = sendbuf;
-	iov[1].iov_len = err;
-
-	err = nl_write(fd, STGT_UEVENT_SCSI_CMND_RES, iov, err ? 2 : 1);
-
-	return 0;
-}
-
-static void handle_events(int fd)
-{
-	struct nlmsghdr *nlh;
-	struct stgt_event *ev;
-	char nlm_ev[NLMSG_SPACE(sizeof(*ev))];
-	int err, ev_size;
-	char recvbuf[4096], sendbuf[4096];
-
-retry:
-	if ((err = nl_read(fd, nlm_ev, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK)) < 0) {
-		if (errno == EAGAIN)
-			return;
-		if (errno == EINTR)
-			goto retry;
-
-		eprintf("%d\n", err);
-		return;
+		if (poll_array[POLL_IPC].revents)
+			ipc_event_handle(ipc_fd);
 	}
-
-	nlh = (struct nlmsghdr *) nlm_ev;
-	ev = (struct stgt_event *) NLMSG_DATA(nlm_ev);
-
-	ev_size = nlh->nlmsg_len - NLMSG_ALIGN(sizeof(struct nlmsghdr));
-
-	eprintf("%d %d\n", nlh->nlmsg_type, ev_size);
-
-	if ((err = nlpayload_read(fd, recvbuf, ev_size, 0)) < 0) {
-		eprintf("%d\n", err);
-		exit(err);
-	}
-
-	switch (nlh->nlmsg_type) {
-	case STGT_KEVENT_SCSI_CMND_REQ:
-		memset(sendbuf, 0, sizeof(sendbuf));
-		execute_cmnd(fd, recvbuf, sendbuf);
-		break;
-	default:
-		eprintf("unknown %u\n", nlh->nlmsg_type);
-		exit(-1);
-		break;
-	}
 }
 
-enum {
-	POLL_NL,
-	POLL_IPC,
-	POLL_MAX,
-};
-
-static void catch_signal(int signo) {
-}
-
 int main(int argc, char **argv)
 {
-	static struct pollfd poll_array[POLL_IPC + 1];
-	int err;
+	int ch, longindex;
+	struct pollfd poll_array[POLL_MAX + 1];
 
-	nlm_sendbuf = malloc(8192);
-	nlm_recvbuf = malloc(8192);
+	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
+		switch (ch) {
+		case 'f':
+			break;
+		case 'd':
+			stgtd_debug = atoi(optarg);
+			break;
+		case 'v':
+			exit(0);
+			break;
+		case 'h':
+			usage(0);
+			break;
+		default:
+			usage(1);
+			break;
+		}
+	}
 
-	struct sigaction sa_old;
-	struct sigaction sa_new;
+	init();
 
-	/* do not allow ctrl-c for now... */
-	sa_new.sa_handler = catch_signal;
-	sigemptyset(&sa_new.sa_mask);
-	sa_new.sa_flags = 0;
-	sigaction(SIGINT, &sa_new, &sa_old );
-	sigaction(SIGPIPE, &sa_new, &sa_old );
-	sigaction(SIGTERM, &sa_new, &sa_old );
-
 	memset(poll_array, 0, sizeof(poll_array));
 
-	if ((nl_fd = nl_open()) < 0)
+	nl_fd = nl_open();
+	if (nl_fd < 0)
 		exit(nl_fd);
 
-	if ((ipc_fd = ipc_listen()) < 0)
+	ipc_fd = ipc_open();
+	if (ipc_fd < 0)
 		exit(ipc_fd);
 
 	poll_array[POLL_NL].fd = nl_fd;
@@ -279,21 +154,7 @@
 	poll_array[POLL_IPC].fd = ipc_fd;
 	poll_array[POLL_IPC].events = POLLIN;
 
-	while (1) {
-		if ((err = poll(poll_array, POLL_MAX, -1)) < 0) {
-			if (errno != EINTR) {
-				eprintf("%d %d\n", err, errno);
-				exit(1);
-			}
-			continue;
-		}
+	event_loop(poll_array);
 
-		if (poll_array[POLL_NL].revents)
-			handle_events(nl_fd);
-
-		if (poll_array[POLL_IPC].revents)
-			ipc_recv(ipc_fd);
-	}
-
 	return 0;
 }

Added: trunk/usr/stgtd.h
===================================================================
--- trunk/usr/stgtd.h	2005-08-28 03:31:21 UTC (rev 24)
+++ trunk/usr/stgtd.h	2005-08-28 08:38:37 UTC (rev 25)
@@ -0,0 +1,29 @@
+#ifndef __SCSI_TARGET_DAEMON_H
+#define __SCSI_TARGET_DAEMON_H
+
+#define eprintf(fmt, args...)						\
+do {									\
+	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, args);	\
+} while (0)
+
+
+#define dprintf(fmt, args...)						\
+do {									\
+	if ((stgtd_debug)) {						\
+		eprintf(fmt, args);					\
+	}								\
+} while (0)
+
+extern uint32_t stgtd_debug;
+extern int nl_fd;
+
+extern int nl_open(void);
+extern void nl_event_handle(int fd);
+extern int nl_cmnd_call(int fd, int type, char *data, int size, int *res);
+
+extern int ipc_open(void);
+extern void ipc_event_handle(int fd);
+
+extern int scsi_cmnd_process(int tid, uint32_t lun, uint8_t *scb, uint8_t *data);
+
+#endif



From tomo at berlios.de  Tue Aug 30 15:21:57 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 30 Aug 2005 15:21:57 +0200
Subject: [Stgt-svn] r26 - in trunk: iscsi/kernel kernel
Message-ID: <200508301321.j7UDLvih013164@sheep.berlios.de>

Author: tomo
Date: 2005-08-30 15:21:56 +0200 (Tue, 30 Aug 2005)
New Revision: 26

Modified:
   trunk/iscsi/kernel/iscsi.c
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/kernel/stgt.c
   trunk/kernel/stgt_target.h
Log:
Move the stgt_target_template registration to the target driver's module_init function.


Modified: trunk/iscsi/kernel/iscsi.c
===================================================================
--- trunk/iscsi/kernel/iscsi.c	2005-08-28 08:38:37 UTC (rev 25)
+++ trunk/iscsi/kernel/iscsi.c	2005-08-30 13:21:56 UTC (rev 26)
@@ -13,6 +13,7 @@
 #include <iscsi.h>
 #include <iscsi_dbg.h>
 #include <stgt.h>
+#include <stgt_target.h>
 
 unsigned long debug_enable_flags;
 
@@ -1533,6 +1534,11 @@
 	}
 }
 
+static struct stgt_target_template iet_stgt_target_template = {
+	.name = "iet",
+	.module = THIS_MODULE,
+};
+
 static void iscsi_exit(void)
 {
 	unregister_chrdev(ctr_major, ctr_name);
@@ -1541,12 +1547,10 @@
 
 	event_exit();
 
-/* 	tio_exit(); */
-
-/* 	iotype_exit(); */
-
 	if (iscsi_cmnd_cache)
 		kmem_cache_destroy(iscsi_cmnd_cache);
+
+	stgt_target_template_unregister(&iet_stgt_target_template);
 }
 
 static int iscsi_init(void)
@@ -1571,12 +1575,10 @@
 	if (!iscsi_cmnd_cache)
 		goto err;
 
-/* 	if ((err = tio_init()) < 0) */
-/* 		goto err; */
+	err = stgt_target_template_register(&iet_stgt_target_template);
+	if (err < 0)
+		goto err;
 
-/* 	if ((err = iotype_init()) < 0) */
-/* 		goto err; */
-
 	return 0;
 
 err:

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-28 08:38:37 UTC (rev 25)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-30 13:21:56 UTC (rev 26)
@@ -73,7 +73,6 @@
 	struct iscsi_trgt_param trgt_param;
 
 	struct list_head session_list;
-	struct list_head device_list;
 
 	struct network_thread_info nthread_info;
 

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-08-28 08:38:37 UTC (rev 25)
+++ trunk/iscsi/kernel/target.c	2005-08-30 13:21:56 UTC (rev 26)
@@ -10,8 +10,8 @@
 #include <digest.h>
 #include <iscsi_dbg.h>
 #include <stgt.h>
-#include <stgt_target.h>
 #include <stgt_device.h>
+#include <stgt_target.h>
 
 #define	MAX_NR_TARGETS	(1UL << 30)
 
@@ -112,11 +112,6 @@
 	nthread_stop(target);
 }
 
-static struct stgt_target_template iet_stgt_target_template = {
-	.name = "iet",
-	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
-};
-
 static int iscsi_target_create(struct target_info *info)
 {
 	int err = -EINVAL, len;
@@ -130,11 +125,6 @@
 		return err;
 	}
 
-	if (!try_module_get(THIS_MODULE)) {
-		eprintk("%s\n", "Fail to get module");
-		return err;
-	}
-
 	if (!(target = kmalloc(sizeof(*target), GFP_KERNEL))) {
 		err = -ENOMEM;
 		goto out;
@@ -149,7 +139,6 @@
 	init_MUTEX(&target->target_sem);
 
 	INIT_LIST_HEAD(&target->session_list);
-	INIT_LIST_HEAD(&target->device_list);
 	list_add(&target->t_list, &target_list);
 
 	nthread_init(target);
@@ -159,8 +148,7 @@
 		goto out;
 	}
 
-	target->stt = stgt_target_create(&iet_stgt_target_template);
-	assert(target->stt);
+	target->stt = stgt_target_create("iet", DEFAULT_NR_QUEUED_CMNDS);
 
 	/* FIXME: We shouldn't access stt inside. */
 	target->tid = info->tid = target->stt->tid;
@@ -168,7 +156,6 @@
 	return 0;
 out:
 	kfree(target);
-	module_put(THIS_MODULE);
 
 	return err;
 }
@@ -207,8 +194,6 @@
 	target_thread_stop(target);
 
 	kfree(target);
-
-	module_put(THIS_MODULE);
 }
 
 int target_del(u32 id)

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-28 08:38:37 UTC (rev 25)
+++ trunk/kernel/stgt.c	2005-08-30 13:21:56 UTC (rev 26)
@@ -49,6 +49,9 @@
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
+static spinlock_t target_tmpl_lock;
+static LIST_HEAD(target_tmpl_list);
+
 static spinlock_t device_tmpl_lock;
 static LIST_HEAD(device_tmpl_list);
 
@@ -133,6 +136,74 @@
 	schedule_work(&target->work);
 }
 
+struct target_type_internal {
+	struct list_head list;
+	struct stgt_target_template *stt;
+};
+
+static struct stgt_target_template *target_template_get(const char *name)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &target_tmpl_list, list)
+		if (!strcmp(name, ti->stt->name)) {
+			if (!try_module_get(ti->stt->module))
+				ti = NULL;
+			spin_unlock_irqrestore(&target_tmpl_lock, flags);
+			return ti ? ti->stt : NULL;
+		}
+
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	return NULL;
+}
+
+static void target_template_put(struct stgt_target_template *stt)
+{
+	module_put(stt->module);
+}
+
+int stgt_target_template_register(struct stgt_target_template *stt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	ti = kmalloc(sizeof(*ti), GFP_KERNEL);
+	if (!ti)
+		return -ENOMEM;
+	memset(ti, 0, sizeof(*ti));
+	INIT_LIST_HEAD(&ti->list);
+	ti->stt = stt;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+	list_add_tail(&ti->list, &target_tmpl_list);
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(stgt_target_template_register);
+
+void stgt_target_template_unregister(struct stgt_target_template *stt)
+{
+	unsigned long flags;
+	struct target_type_internal *ti;
+
+	spin_lock_irqsave(&target_tmpl_lock, flags);
+
+	list_for_each_entry(ti, &target_tmpl_list, list)
+		if (ti->stt == stt) {
+			list_del(&ti->list);
+			kfree(ti);
+			break;
+		}
+
+	spin_unlock_irqrestore(&target_tmpl_lock, flags);
+}
+EXPORT_SYMBOL_GPL(stgt_target_template_unregister);
+
 static struct stgt_target *target_find(int tid)
 {
 	struct stgt_target *target;
@@ -148,7 +219,7 @@
 	return target;
 }
 
-struct stgt_target *stgt_target_create(struct stgt_target_template *stt)
+struct stgt_target *stgt_target_create(char *target_type, int queued_cmnds)
 {
 	static int target_id;
 	struct stgt_target *target;
@@ -161,10 +232,13 @@
 	target = kmalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
-
 	dprintk("%p\n", target);
+	memset(target, 0, sizeof(*target));
 
-	memset(target, 0, sizeof(*target));
+	target->stt = target_template_get(target_type);
+	if (!target->stt)
+		goto free_target;
+
 	target->tid = target_id++;
 	spin_lock_init(&target->lock);
 
@@ -173,19 +247,21 @@
 	INIT_LIST_HEAD(&target->work_list);
 
 	INIT_WORK(&target->work, stgt_worker, target);
-	target->stt = stt;
-	target->queued_cmnds = stt->queued_cmnds;
+	target->queued_cmnds = queued_cmnds;
 
-	if (stgt_sysfs_register_target(target)) {
-		kfree(target);
-		return NULL;
-	}
+	if (stgt_sysfs_register_target(target))
+		goto put_template;
 
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
+	return target;
 
-	return target;
+put_template:
+	target_template_put(target->stt);
+free_target:
+	kfree(target);
+	return NULL;
 }
 EXPORT_SYMBOL(stgt_target_create);
 
@@ -197,6 +273,7 @@
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 
+	target_template_put(target->stt);
 	stgt_sysfs_unregister_target(target);
 
 	return 0;
@@ -904,6 +981,7 @@
 	spin_lock_init(&all_targets_lock);
 	spin_lock_init(&atomic_sessions_lock);
 	spin_lock_init(&cmnd_hash_lock);
+	spin_lock_init(&target_tmpl_lock);
 	spin_lock_init(&device_tmpl_lock);
 
 	err = stgt_sysfs_init();

Modified: trunk/kernel/stgt_target.h
===================================================================
--- trunk/kernel/stgt_target.h	2005-08-28 08:38:37 UTC (rev 25)
+++ trunk/kernel/stgt_target.h	2005-08-30 13:21:56 UTC (rev 26)
@@ -13,8 +13,8 @@
 
 struct stgt_target_template {
 	const char *name;
+	struct module *module;
 
-	int queued_cmnds;
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
 	 */
@@ -43,9 +43,11 @@
 #define cdev_to_stgt_target(cdev) \
 	container_of(cdev, struct stgt_target, cdev)
 
-extern struct stgt_target *stgt_target_create(struct stgt_target_template *stt);
+extern struct stgt_target *stgt_target_create(char *target_type, int nr_cmnds);
 extern int stgt_target_destroy(struct stgt_target *target);
 extern int stgt_sysfs_register_target(struct stgt_target *target);
 extern void stgt_sysfs_unregister_target(struct stgt_target *target);
+extern int stgt_target_template_register(struct stgt_target_template *stt);
+extern void stgt_target_template_unregister(struct stgt_target_template *stt);
 
 #endif



From tomo at berlios.de  Tue Aug 30 17:39:21 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 30 Aug 2005 17:39:21 +0200
Subject: [Stgt-svn] r27 - trunk/kernel
Message-ID: <200508301539.j7UFdLqa023005@sheep.berlios.de>

Author: tomo
Date: 2005-08-30 17:39:21 +0200 (Tue, 30 Aug 2005)
New Revision: 27

Modified:
   trunk/kernel/stgt.c
   trunk/kernel/stgt_device.h
   trunk/kernel/stgt_vsd.c
Log:
The stgt_vsd code might work.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-30 13:21:56 UTC (rev 26)
+++ trunk/kernel/stgt.c	2005-08-30 15:39:21 UTC (rev 27)
@@ -485,6 +485,17 @@
 }
 EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
 
+static struct stgt_device *device_find(struct stgt_target *target, uint32_t lun)
+{
+	struct stgt_device *device;
+
+	list_for_each_entry(device, &target->device_list, dlist)
+		if (device->lun == lun)
+			return device;
+
+	return NULL;
+}
+
 static int stgt_device_create(int tid, uint32_t lun, char *device_type, char *path,
 			      unsigned long dflags)
 {
@@ -557,11 +568,11 @@
 		return -ENOENT;
 
 	spin_lock_irqsave(&target->lock, flags);
-	list_for_each_entry(device, &target->device_list, dlist)
-		if (device->lun == lun) {
-			list_del(&device->dlist);
-			goto found;
-		}
+	device = device_find(target, lun);
+	if (device) {
+		list_del(&device->dlist);
+		goto found;
+	}
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return -EINVAL;
@@ -759,10 +770,20 @@
 
 static void queuecommand(void *data)
 {
+	int err;
+	enum stgt_cmnd_type type = STGT_CMND_USPACE;
+	unsigned long flags;
 	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
+	struct stgt_target *target = cmnd->session->target;
+	struct stgt_device *device;
 
 	dprintk("%x\n", cmnd->scb[0]);
 
+	/* Should we do this earlier? */
+	spin_lock_irqsave(&target->lock, flags);
+	device = device_find(target, cmnd->lun);
+	spin_unlock_irqrestore(&target->lock, flags);
+
 	/*
 	 * seperate vsd (virtual disk from sd (real sd))
 	 * call scsi_device_temaplte->prepcommand to see if they want it
@@ -770,24 +791,24 @@
 	 *
 	 * Then call queuecommand
 	 */
-	switch (cmnd->scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-		/* TODO */
+
+	if (device)
+		dprintk("found %u\n", cmnd->lun);
+
+	if (device && device->sdt->prepcommand)
+		type = device->sdt->prepcommand(device, cmnd);
+
+	dprintk("type %u\n", type);
+
+	switch (type) {
+	case STGT_CMND_KSPACE:
+		err = device->sdt->queuecommand(device, cmnd);
 		cmnd_done(cmnd);
 		break;
+	case STGT_CMND_USPACE:
+		err = uspace_cmnd_send(cmnd);
+		break;
 	default:
-		if (uspace_cmnd_send(cmnd) < 0)
-			assert(0);
 		break;
 	}
 }

Modified: trunk/kernel/stgt_device.h
===================================================================
--- trunk/kernel/stgt_device.h	2005-08-30 13:21:56 UTC (rev 26)
+++ trunk/kernel/stgt_device.h	2005-08-30 15:39:21 UTC (rev 27)
@@ -14,6 +14,12 @@
 struct stgt_device;
 struct stgt_cmnd;
 
+enum stgt_cmnd_type {
+	STGT_CMND_UNKNOWN,
+	STGT_CMND_KSPACE,
+	STGT_CMND_USPACE,
+};
+
 struct stgt_device_template {
 	const char *name;
 	struct module *module;

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-08-30 13:21:56 UTC (rev 26)
+++ trunk/kernel/stgt_vsd.c	2005-08-30 15:39:21 UTC (rev 27)
@@ -9,7 +9,11 @@
 #include <linux/types.h>
 #include <linux/blkdev.h>
 #include <linux/namei.h>
+#include <linux/uio.h>
+#include <linux/fs.h>
+#include <scsi/scsi.h>
 
+#include <stgt.h>
 #include <stgt_device.h>
 
 struct stgt_vsd_dev {
@@ -71,14 +75,117 @@
 	return err;
 }
 
+static loff_t translate_offset(uint8_t *scb)
+{
+	loff_t off = 0;
+
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(u32 *)&scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(u64 *)&scb[2]);
+		break;
+	default:
+		BUG();
+	}
+
+	return off << 9;
+}
+
+static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
+{
+	struct iovec* iov;
+	int i;
+
+	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
+	if (!iov) {
+		printk("%s %d ENOMEM %d\n", __FUNCTION__, __LINE__, sg_count);
+		return NULL;
+	}
+
+	for (i = 0; i < sg_count; i++) {
+		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
+		iov[i].iov_len = sg[i].length;
+	}
+
+	return iov;
+}
+
 static int stgt_vsd_queue(struct stgt_device *device, struct stgt_cmnd *cmnd)
 {
+	struct stgt_vsd_dev *vsddev = device->sdt_data;
+	loff_t pos = translate_offset(cmnd->scb);
+	ssize_t size;
+	struct iovec *iov = NULL;
+	int err = 0;
+
+	switch (cmnd->scb[0]) {
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+		if (!iov)
+			goto out;
+		size = generic_file_readv(vsddev->filp, iov, cmnd->sg_count, &pos);
+		kfree(iov);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+		if (!iov)
+			goto out;
+		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
+		err = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
+		kfree(iov);
+		break;
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+		break;
+	default:
+		BUG();
+	}
+
+	if (err < 0)
+		printk("%s %d: %d %llu\n", __FUNCTION__, __LINE__, err, pos);
+out:
 	return 0;
 }
 
 static int stgt_vsd_prep(struct stgt_device *device, struct stgt_cmnd *cmnd)
 {
-	return 0;
+	enum stgt_cmnd_type type;
+
+	switch (cmnd->scb[0]) {
+	case READ_6:
+	case READ_10:
+	case READ_16:
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+		type = STGT_CMND_KSPACE;
+		break;
+	default:
+		type = STGT_CMND_USPACE;
+	}
+
+	return type;
 }
 
 static struct stgt_device_template stgt_vsd = {



From tomo at berlios.de  Tue Aug 30 19:23:48 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 30 Aug 2005 19:23:48 +0200
Subject: [Stgt-svn] r28 - in trunk/iscsi: include kernel usr
Message-ID: <200508301723.j7UHNmYc024274@sheep.berlios.de>

Author: tomo
Date: 2005-08-30 19:23:46 +0200 (Tue, 30 Aug 2005)
New Revision: 28

Modified:
   trunk/iscsi/include/iet_u.h
   trunk/iscsi/kernel/iscsi.h
   trunk/iscsi/kernel/target.c
   trunk/iscsi/usr/ctldev.c
Log:
Kill iscsi_target->name.

Modified: trunk/iscsi/include/iet_u.h
===================================================================
--- trunk/iscsi/include/iet_u.h	2005-08-30 15:39:21 UTC (rev 27)
+++ trunk/iscsi/include/iet_u.h	2005-08-30 17:23:46 UTC (rev 28)
@@ -11,8 +11,7 @@
 #define SCSI_ID_LEN	24
 
 struct target_info {
-	u32 tid;
-	char name[ISCSI_NAME_LEN];
+	int tid;
 };
 
 struct session_info {

Modified: trunk/iscsi/kernel/iscsi.h
===================================================================
--- trunk/iscsi/kernel/iscsi.h	2005-08-30 15:39:21 UTC (rev 27)
+++ trunk/iscsi/kernel/iscsi.h	2005-08-30 17:23:46 UTC (rev 28)
@@ -64,11 +64,9 @@
 };
 
 struct iscsi_target {
+	int tid;
 	struct list_head t_list;
-	u32 tid;
 
-	char name[ISCSI_NAME_LEN];
-
 	struct iscsi_sess_param sess_param;
 	struct iscsi_trgt_param trgt_param;
 

Modified: trunk/iscsi/kernel/target.c
===================================================================
--- trunk/iscsi/kernel/target.c	2005-08-30 15:39:21 UTC (rev 27)
+++ trunk/iscsi/kernel/target.c	2005-08-30 17:23:46 UTC (rev 28)
@@ -75,17 +75,6 @@
 	return NULL;
 }
 
-static struct iscsi_target *__target_lookup_by_name(char *name)
-{
-	struct iscsi_target *target;
-
-	list_for_each_entry(target, &target_list, t_list) {
-		if (!strcmp(target->name, name))
-			return target;
-	}
-	return NULL;
-}
-
 struct iscsi_target *target_lookup_by_id(u32 id)
 {
 	struct iscsi_target *target;
@@ -114,17 +103,9 @@
 
 static int iscsi_target_create(struct target_info *info)
 {
-	int err = -EINVAL, len;
-	char *name = info->name;
+	int err = -EINVAL;
 	struct iscsi_target *target;
 
-	dprintk(D_SETUP, "%s\n", name);
-
-	if (!(len = strlen(name))) {
-		eprintk("%s", "The length of the target name is zero");
-		return err;
-	}
-
 	if (!(target = kmalloc(sizeof(*target), GFP_KERNEL))) {
 		err = -ENOMEM;
 		goto out;
@@ -134,8 +115,6 @@
 	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
 	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
 
-	strncpy(target->name, name, sizeof(target->name) - 1);
-
 	init_MUTEX(&target->target_sem);
 
 	INIT_LIST_HEAD(&target->session_list);
@@ -150,7 +129,6 @@
 
 	target->stt = stgt_target_create("iet", DEFAULT_NR_QUEUED_CMNDS);
 
-	/* FIXME: We shouldn't access stt inside. */
 	target->tid = info->tid = target->stt->tid;
 
 	return 0;
@@ -171,9 +149,6 @@
 		goto out;
 	}
 
-	if (__target_lookup_by_name(info->name))
-		goto out;
-
 	if (info->tid)
 		goto out;
 
@@ -240,7 +215,7 @@
 		return err;
 
 	list_for_each_entry(target, &target_list, t_list) {
-		seq_printf(seq, "tid:%u name:%s\n", target->tid, target->name);
+		seq_printf(seq, "tid:%u\n", target->tid);
 
 		if ((err = target_lock(target, 1)) < 0)
 			break;

Modified: trunk/iscsi/usr/ctldev.c
===================================================================
--- trunk/iscsi/usr/ctldev.c	2005-08-30 15:39:21 UTC (rev 27)
+++ trunk/iscsi/usr/ctldev.c	2005-08-30 17:23:46 UTC (rev 28)
@@ -89,7 +89,6 @@
 
 	memset(&info, 0, sizeof(info));
 
-	memcpy(info.name, name, sizeof(info.name) - 1);
 	info.tid = *tid;
 	if ((err = ioctl(ctrl_fd, ADD_TARGET, &info)) < 0)
 		log_warning("can't create a target %d %u\n", errno, info.tid);



From tomo at berlios.de  Tue Aug 30 19:50:18 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Tue, 30 Aug 2005 19:50:18 +0200
Subject: [Stgt-svn] r29 - trunk/kernel
Message-ID: <200508301750.j7UHoIV4014469@sheep.berlios.de>

Author: tomo
Date: 2005-08-30 19:50:18 +0200 (Tue, 30 Aug 2005)
New Revision: 29

Modified:
   trunk/kernel/stgt.c
Log:
Cleanup of stgt_device_find stuff.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-30 17:23:46 UTC (rev 28)
+++ trunk/kernel/stgt.c	2005-08-30 17:50:18 UTC (rev 29)
@@ -485,7 +485,8 @@
 }
 EXPORT_SYMBOL_GPL(stgt_device_template_unregister);
 
-static struct stgt_device *device_find(struct stgt_target *target, uint32_t lun)
+static struct stgt_device *
+stgt_device_find_nolock(struct stgt_target *target, uint32_t lun)
 {
 	struct stgt_device *device;
 
@@ -496,6 +497,19 @@
 	return NULL;
 }
 
+static struct stgt_device *
+stgt_device_find(struct stgt_target *target, uint32_t lun)
+{
+	static struct stgt_device *device;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+	device = stgt_device_find_nolock(target, lun);
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return device;
+}
+
 static int stgt_device_create(int tid, uint32_t lun, char *device_type, char *path,
 			      unsigned long dflags)
 {
@@ -568,7 +582,7 @@
 		return -ENOENT;
 
 	spin_lock_irqsave(&target->lock, flags);
-	device = device_find(target, lun);
+	device = stgt_device_find_nolock(target, lun);
 	if (device) {
 		list_del(&device->dlist);
 		goto found;
@@ -772,7 +786,6 @@
 {
 	int err;
 	enum stgt_cmnd_type type = STGT_CMND_USPACE;
-	unsigned long flags;
 	struct stgt_cmnd *cmnd = (struct stgt_cmnd *) data;
 	struct stgt_target *target = cmnd->session->target;
 	struct stgt_device *device;
@@ -780,9 +793,7 @@
 	dprintk("%x\n", cmnd->scb[0]);
 
 	/* Should we do this earlier? */
-	spin_lock_irqsave(&target->lock, flags);
-	device = device_find(target, cmnd->lun);
-	spin_unlock_irqrestore(&target->lock, flags);
+	device = stgt_device_find(target, cmnd->lun);
 
 	/*
 	 * seperate vsd (virtual disk from sd (real sd))



From tomo at berlios.de  Wed Aug 31 05:24:18 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 31 Aug 2005 05:24:18 +0200
Subject: [Stgt-svn] r30 - trunk/kernel
Message-ID: <200508310324.j7V3OIJT010579@sheep.berlios.de>

Author: tomo
Date: 2005-08-31 05:24:14 +0200 (Wed, 31 Aug 2005)
New Revision: 30

Modified:
   trunk/kernel/stgt_vsd.c
Log:
Fix memory leak in stgt_vsd.

Modified: trunk/kernel/stgt_vsd.c
===================================================================
--- trunk/kernel/stgt_vsd.c	2005-08-30 17:50:18 UTC (rev 29)
+++ trunk/kernel/stgt_vsd.c	2005-08-31 03:24:14 UTC (rev 30)
@@ -144,7 +144,6 @@
 		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
 		if (!iov)
 			goto out;
-		iov = sg_to_iovec(cmnd->sg, cmnd->sg_count);
 		err = generic_file_writev(vsddev->filp, iov, cmnd->sg_count, &pos);
 		kfree(iov);
 		break;



From tomo at berlios.de  Wed Aug 31 17:48:52 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 31 Aug 2005 17:48:52 +0200
Subject: [Stgt-svn] r32 - in trunk: kernel usr
Message-ID: <200508311548.j7VFmqxR002206@sheep.berlios.de>

Author: tomo
Date: 2005-08-31 17:48:52 +0200 (Wed, 31 Aug 2005)
New Revision: 32

Modified:
   trunk/kernel/stgt.c
   trunk/usr/scsi.c
Log:
Move the makeshift fix for access to nonexistent lun to user space.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-31 15:34:25 UTC (rev 31)
+++ trunk/kernel/stgt.c	2005-08-31 15:48:52 UTC (rev 32)
@@ -792,20 +792,6 @@
 
 	dprintk("%x\n", cmnd->scb[0]);
 
-	/* Should we do this earlier? */
-	device = stgt_device_find(target, cmnd->lun);
-	if (!device) {
-		switch (cmnd->scb[0]) {
-		case INQUIRY:
-		case REPORT_LUNS:
-			break;
-		default:
-			eprintk("FIXME: access to nonexistent lun %u\n",
-				cmnd->lun);
-			cmnd_done(cmnd);
-			break;
-		}
-	}
 	/*
 	 * seperate vsd (virtual disk from sd (real sd))
 	 * call scsi_device_temaplte->prepcommand to see if they want it
@@ -814,6 +800,8 @@
 	 * Then call queuecommand
 	 */
 
+	/* Should we do this earlier? */
+	device = stgt_device_find(target, cmnd->lun);
 	if (device)
 		dprintk("found %u\n", cmnd->lun);
 

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-08-31 15:34:25 UTC (rev 31)
+++ trunk/usr/scsi.c	2005-08-31 15:48:52 UTC (rev 32)
@@ -410,8 +410,8 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		eprintf("kernel module bug %d\n", scb[0]);
-		exit(-1);
+		dprintf("FIXME: access to nonexistent lun %u\n", lun);
+		len = 0;
 		break;
 	}
 



From tomo at berlios.de  Wed Aug 31 17:34:27 2005
From: tomo at berlios.de (Tomonori Fujita at BerliOS)
Date: Wed, 31 Aug 2005 17:34:27 +0200
Subject: [Stgt-svn] r31 - trunk/kernel
Message-ID: <200508311534.j7VFYRx5001112@sheep.berlios.de>

Author: tomo
Date: 2005-08-31 17:34:25 +0200 (Wed, 31 Aug 2005)
New Revision: 31

Modified:
   trunk/kernel/stgt.c
Log:
Makeshift fix for access to nonexistent lun.

Modified: trunk/kernel/stgt.c
===================================================================
--- trunk/kernel/stgt.c	2005-08-31 03:24:14 UTC (rev 30)
+++ trunk/kernel/stgt.c	2005-08-31 15:34:25 UTC (rev 31)
@@ -794,7 +794,18 @@
 
 	/* Should we do this earlier? */
 	device = stgt_device_find(target, cmnd->lun);
-
+	if (!device) {
+		switch (cmnd->scb[0]) {
+		case INQUIRY:
+		case REPORT_LUNS:
+			break;
+		default:
+			eprintk("FIXME: access to nonexistent lun %u\n",
+				cmnd->lun);
+			cmnd_done(cmnd);
+			break;
+		}
+	}
 	/*
 	 * seperate vsd (virtual disk from sd (real sd))
 	 * call scsi_device_temaplte->prepcommand to see if they want it
@@ -809,8 +820,6 @@
 	if (device && device->sdt->prepcommand)
 		type = device->sdt->prepcommand(device, cmnd);
 
-	dprintk("type %u\n", type);
-
 	switch (type) {
 	case STGT_CMND_KSPACE:
 		err = device->sdt->queuecommand(device, cmnd);



