From mnc at berlios.de  Thu Dec  1 09:29:47 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 1 Dec 2005 09:29:47 +0100
Subject: [Stgt-svn] r191 - trunk/kernel
Message-ID: <200512010829.jB18TlaL013517@sheep.berlios.de>

Author: mnc
Date: 2005-12-01 09:29:32 +0100 (Thu, 01 Dec 2005)
New Revision: 191

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_vsd.c
Log:
Bah! Could not use the iosched or barrier code for what we wanted. Back it out for now since it also does not even compile on 2.6.15

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt.c	2005-12-01 08:29:32 UTC (rev 191)
@@ -149,7 +149,6 @@
 
 static void tgt_request_fn(struct request_queue *q)
 {
-	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 	struct request *rq;
 	int err;
@@ -176,13 +175,17 @@
 
 		spin_unlock_irq(q->queue_lock);
 
-		/*
-		 * TODO: kill cid. We can use the request queue tag instead
-		 */
 		dprintk("cmd %p tag %d\n", cmd, rq->tag);
 
-		target = cmd->session->target;
-	        err = target->proto->execute_cmd(cmd);
+		if (!cmd->device) {
+			struct tgt_target *target = cmd->session->target;
+
+			INIT_WORK(&cmd->work, target->proto->uspace_cmd_execute,
+				  cmd);
+			queue_work(target->twq, &cmd->work);
+			err = TGT_CMD_USPACE_QUEUED;
+		} else
+			err = cmd->device->dt->execute_cmd(cmd);
 	        switch (err) {
 	        case TGT_CMD_FAILED:
 		case TGT_CMD_COMPLETED:
@@ -198,7 +201,6 @@
 
 static void tgt_queue_destroy(struct request_queue *q)
 {
-	kfree(q->queuedata);
 	blk_cleanup_queue(q);
 }
 
@@ -212,23 +214,8 @@
 	if (!q)
 		return -ENOMEM;
 
-	q->queuedata = kzalloc(sizeof(struct tgt_queuedata), GFP_KERNEL);
-	if (!q->queuedata)
-		goto out;
-
-	/*
-	 * this is a tmp hack: we do not register this queue
-	 * becuase we do not have a proper parent. We can remove
-	 * this code and do this from userspace when the queue's parent
-	 * is not the gendisk.
-	 */
 	elevator_exit(q->elevator);
-	/*
-	 * for the virtual devices iosched happens there, and for passthru
-	 * devs we do noop for now (do we need to since the initiator does
-	 * ioscheduling)
-	 */
-	err = elevator_init(q, proto->elevator ? : "noop");
+	err = elevator_init(q, "noop");
 	if (err)
 		goto out;
 
@@ -566,7 +553,7 @@
 	spin_lock_irqsave(&target->lock, flags);
 	device = tgt_device_find_nolock(target, dev_id);
 	if (device) {
-		if (test_bit(TGT_QUEUE_DEL, &tgt_qdata(device->q)->qflags))
+		if (test_bit(TGT_DEV_DEL, &device->state))
 			device = NULL;
 		else
 			class_device_get(&device->cdev);
@@ -730,8 +717,7 @@
 	spin_lock_irqsave(&target->lock, flags);
 	device = tgt_device_find_nolock(target, dev_id);
 	if (device)
-		err = test_and_set_bit(TGT_QUEUE_DEL,
-				       &tgt_qdata(device->q)->qflags);
+		err = test_and_set_bit(TGT_DEV_DEL, &device->state);
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	if (!device)
@@ -776,6 +762,9 @@
 		spin_unlock_irqrestore(q->queue_lock, flags);
 	}
 
+	if (cmd->device)
+		tgt_device_put(cmd->device);
+
 	mempool_free(cmd, cmd->session->cmd_pool);
 
 	if (q)
@@ -805,9 +794,6 @@
 	struct tgt_target *target = cmd->session->target;
 	int err;
 
-	if (target->proto->complete_cmd)
-		target->proto->complete_cmd(cmd);
-
 	cmd->done = tgt_cmd_destroy;
 	err = target->tt->transfer_response(cmd);
 	switch (err) {
@@ -825,7 +811,8 @@
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
-struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *tgt_priv)
+struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, uint64_t dev_id,
+			       void *tgt_priv)
 {
 	struct tgt_cmd *cmd;
 
@@ -836,6 +823,8 @@
 	}
 
 	memset(cmd, 0, sizeof(*cmd));
+	cmd->dev_id = dev_id;
+	cmd->device = tgt_device_get(session->target, cmd->dev_id);
 	cmd->session = session;
 	cmd->private = tgt_priv;
 	cmd->done = tgt_cmd_destroy;
@@ -960,6 +949,9 @@
 	struct tgt_session *session = cmd->session;
 	int err;
 
+	if (cmd->device)
+		cmd->device->dt->prep_cmd(cmd);
+
 	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
 	if (err)
 		return err;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt.h	2005-12-01 08:29:32 UTC (rev 191)
@@ -83,16 +83,6 @@
 	unsigned long proto_priv[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
-enum {
-	TGT_QUEUE_DEL,
-	TGT_QUEUE_PRIVATE_START,
-};
-
-struct tgt_queuedata {
-	int active_cmd; /* should we use q->in_flight? */
-	unsigned long qflags;
-};
-
 extern struct tgt_session *
 tgt_session_create(struct tgt_target *target,
 		   tgt_session_done_t *done, void *arg);
@@ -101,18 +91,13 @@
 extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
 			gfp_t flags);
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask);
-extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, void *priv);
+extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, uint64_t id,
+				      void *priv);
 extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 
-static inline struct tgt_queuedata *tgt_qdata(struct request_queue *q)
-{
-	return (struct tgt_queuedata *) q->queuedata;
-}
-
-
 #define DEBUG_TGT
 
 #define eprintk(fmt, args...)					\

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt_device.h	2005-12-01 08:29:32 UTC (rev 191)
@@ -25,7 +25,8 @@
 	 * for completing it
 	 */
 	TGT_CMD_USPACE_QUEUED,
-	TGT_CMD_KERN_QUEUED
+	TGT_CMD_KERN_QUEUED,
+	TGT_DEV_DEL = 0,
 };
 
 struct tgt_device_template {
@@ -53,7 +54,7 @@
 	/*
 	 * setup buffer or device fields if needed
 	 */
-	void (* prep_cmd)(struct tgt_cmd *cmd, uint32_t data_len);
+	void (* prep_cmd)(struct tgt_cmd *cmd);
 
 	/*
 	 * Pointer to the sysfs class properties for this host, NULL terminated.
@@ -73,6 +74,7 @@
 	uint32_t blk_shift;
 	uint64_t size;
 
+	unsigned long state;
 	/*
 	 * queue for tgt <-> tgt LLD requests
 	 */

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt_protocol.h	2005-12-01 08:29:32 UTC (rev 191)
@@ -27,7 +27,6 @@
 	kmem_cache_t *cmd_cache;
 	unsigned uspace_pdu_size;
 
-	char *elevator;
 	/*
 	 * Create a command and allocate a buffer of size data_len for
 	 * for transfer. The buffer will be allocated with GFP_KERNEL
@@ -41,15 +40,13 @@
 				       enum dma_data_direction data_dir,
 				       uint8_t *dev_id_buff, int id_buff_size,
 				       int flags);
-
-	int (* execute_cmd) (struct tgt_cmd *cmd);
-	void (* complete_cmd) (struct tgt_cmd *cmd);
 	/*
 	 * Build userspace packet
 	 */
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
+	void (* uspace_cmd_execute)(void *cmd);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt_scsi.c	2005-12-01 08:29:32 UTC (rev 191)
@@ -19,115 +19,6 @@
 
 static kmem_cache_t *scsi_tgt_cmd_cache;
 
-enum {
-	TGT_SCSI_QUEUE_BLOCKED = TGT_QUEUE_PRIVATE_START,
-};
-
-static struct request *elevator_tgt_scsi_next_request(request_queue_t *q)
-{
-	struct request *rq;
-	struct scsi_tgt_cmd *scmd;
-	int enabled = 0;
-	struct tgt_queuedata *tqd = tgt_qdata(q);
-
-	if (list_empty(&q->queue_head))
-		return NULL;
-
-	rq = list_entry_rq(q->queue_head.next);
-
-	scmd = tgt_cmd_to_scsi(rq->special);
-	dprintk("%p %x %x %llx %d\n", rq->special, scmd->tags, scmd->scb[0],
-		(unsigned long long) tqd->qflags, tqd->active_cmd);
-	switch (scmd->tags) {
-	case MSG_SIMPLE_TAG:
-		if (!test_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags))
-			enabled = 1;
-	case MSG_ORDERED_TAG:
-		if (!test_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags) &&
-		    !tqd->active_cmd)
-			enabled = 1;
-		break;
-	case MSG_HEAD_TAG:
-		enabled = 1;
-		break;
-	default:
-		BUG();
-	}
-
-	return enabled ? rq : NULL;
-}
-
-static void elevator_tgt_scsi_add_request(request_queue_t *q,
-					  struct request *rq, int where)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(rq->special);
-
-	switch (scmd->tags) {
-	case MSG_SIMPLE_TAG:
-	case MSG_ORDERED_TAG:
-		list_add_tail(&rq->queuelist, &q->queue_head);
-		break;
-	case MSG_HEAD_TAG:
-		list_add(&rq->queuelist, &q->queue_head);
-		break;
-	default:
-		eprintk("unknown scsi tag %p %x %x\n",
-			rq->special, scmd->tags, scmd->scb[0]);
-
-		scmd->tags = MSG_SIMPLE_TAG;
-		list_add_tail(&rq->queuelist, &q->queue_head);
-	}
-}
-
-static void elevator_tgt_scsi_remove_request(request_queue_t *q,
-					     struct request *rq)
-{
-	struct tgt_queuedata *tqd = tgt_qdata(q);
-	struct tgt_cmd *cmd = rq->special;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	tqd->active_cmd++;
-
-	dprintk("%p %x %x %llx %d %llu\n", rq->special, scmd->tags, scmd->scb[0],
-		(unsigned long long) tqd->qflags, tqd->active_cmd,
-		cmd->device ? (unsigned long long) cmd->device->dev_id : ~0ULL);
-
-	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
-		set_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
-}
-
-static struct elevator_type elevator_tgt_scsi = {
-	.ops = {
-		.elevator_next_req_fn = elevator_tgt_scsi_next_request,
-		.elevator_add_req_fn = elevator_tgt_scsi_add_request,
-		.elevator_remove_req_fn = elevator_tgt_scsi_remove_request,
-	},
-	.elevator_name = __stringify(KBUILD_MODNAME),
-	.elevator_owner = THIS_MODULE,
-};
-
-static void scsi_tgt_complete_cmd(struct tgt_cmd *cmd)
-{
-	struct request_queue *q = cmd->rq->q;
-	struct tgt_queuedata *tqd = tgt_qdata(q);
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	unsigned long flags;
-
-	dprintk("%p %x %x %llx %d %llu\n", cmd, scmd->tags, scmd->scb[0],
-		(unsigned long long) tqd->qflags, tqd->active_cmd,
-		cmd->device ? (unsigned long long) cmd->device->dev_id : ~0ULL);
-
-	spin_lock_irqsave(q->queue_lock, flags);
-	tqd->active_cmd--;
-	if (scmd->tags == MSG_ORDERED_TAG || scmd->tags == MSG_HEAD_TAG)
-		clear_bit(TGT_SCSI_QUEUE_BLOCKED, &tqd->qflags);
-	blk_plug_device(q);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
-	if (cmd->device)
-		tgt_device_put(cmd->device);
-}
-
 /*
  * we should be able to use scsi-ml's functions for this
  */
@@ -160,11 +51,14 @@
 		    uint32_t data_len, enum dma_data_direction data_dir,
 		    uint8_t *lun, int lun_size, int tags)
 {
-	struct tgt_device *device;
 	struct tgt_cmd *cmd;
 	struct scsi_tgt_cmd *scmd;
+	uint64_t id;
 
-	cmd = tgt_cmd_create(session, tgt_priv);
+	/* translate target driver LUN to device id */
+	id = scsi_tgt_translate_lun(lun, lun_size);
+
+	cmd = tgt_cmd_create(session, id, tgt_priv);
 	if (!cmd) {
 		eprintk("Could not allocate command\n");
 		return NULL;
@@ -173,10 +67,6 @@
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
 	scmd->tags = tags;
 
-	/* translate target driver LUN to device id */
-	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
-	cmd->device = device = tgt_device_get(session->target, cmd->dev_id);
-
 	/* is this device specific */
 	cmd->data_dir = data_dir;
 	/*
@@ -184,12 +74,8 @@
 	 * handler overide just in case
 	 */
 	cmd->bufflen = data_len;
-	/* do scsi device specific setup */
-	if (device)
-		device->dt->prep_cmd(cmd, data_len);
 
 	tgt_cmd_start(cmd);
-
 	return cmd;
 }
 
@@ -233,7 +119,7 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-static void __tgt_uspace_cmd_send(void *data)
+static void scsi_tgt_uspace_cmd_exec(void *data)
 {
 	struct tgt_cmd *cmd = data;
 	int err;
@@ -246,18 +132,6 @@
 	tgt_transfer_response(cmd);
 }
 
-static int scsi_tgt_execute_cmd(struct tgt_cmd *cmd)
-{
-	dprintk("%p %x\n", cmd, tgt_cmd_to_scsi(cmd)->scb[0]);
-
-	if (!cmd->device) {
-		INIT_WORK(&cmd->work, __tgt_uspace_cmd_send, cmd);
-		queue_work(cmd->session->target->twq, &cmd->work);
-		return TGT_CMD_KERN_QUEUED;
-	} else
-		return cmd->device->dt->execute_cmd(cmd);
-}
-
 static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
 {
 	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
@@ -274,12 +148,10 @@
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
-	.elevator = elevator_tgt_scsi.elevator_name,
 	.create_cmd = scsi_tgt_create_cmd,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
+	.uspace_cmd_execute = scsi_tgt_uspace_cmd_exec,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
-	.execute_cmd = scsi_tgt_execute_cmd,
-	.complete_cmd = scsi_tgt_complete_cmd,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };
 
@@ -298,24 +170,17 @@
 
 	err = tgt_protocol_register(&scsi_tgt_proto);
 	if (err)
-		goto protocol_unregister;
-
-	err = elv_register(&elevator_tgt_scsi);
-	if (err)
 		goto cache_destroy;
 
 	return 0;
 cache_destroy:
 	kmem_cache_destroy(scsi_tgt_cmd_cache);
-protocol_unregister:
-	tgt_protocol_unregister(&scsi_tgt_proto);
 
 	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
-	elv_unregister(&elevator_tgt_scsi);
 	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	tgt_protocol_unregister(&scsi_tgt_proto);
 }

Modified: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt_sd.c	2005-12-01 08:29:32 UTC (rev 191)
@@ -58,7 +58,7 @@
 	return 0;
 }
 
-static void tgt_sd_prep(struct tgt_cmd *cmd, uint32_t data_len)
+static void tgt_sd_prep(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	uint8_t *scb = scmd->scb;
@@ -87,10 +87,6 @@
 
 	off <<= 9;
 
-	/*
-	 * we trust the data_len passed in for now
-	 */
-	cmd->bufflen = data_len;
 	cmd->offset = off;
 }
 

Modified: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-11-21 22:49:54 UTC (rev 190)
+++ trunk/kernel/tgt_vsd.c	2005-12-01 08:29:32 UTC (rev 191)
@@ -42,7 +42,7 @@
 /*
  * is this device specific or common? Should it be moved to the protocol.
  */
-static void tgt_vsd_prep(struct tgt_cmd *cmd, uint32_t data_len)
+static void tgt_vsd_prep(struct tgt_cmd *cmd)
 {
 	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
 	uint8_t *scb = scmd->scb;
@@ -71,10 +71,6 @@
 
 	off <<= 9;
 
-	/*
-	 * we trust the data_len passed in for now
-	 */
-	cmd->bufflen = data_len;
 	cmd->offset = off;
 }
 



From mnc at berlios.de  Thu Dec  1 09:31:59 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 1 Dec 2005 09:31:59 +0100
Subject: [Stgt-svn] r192 - trunk/kernel
Message-ID: <200512010831.jB18VxsI015308@sheep.berlios.de>

Author: mnc
Date: 2005-12-01 09:31:50 +0100 (Thu, 01 Dec 2005)
New Revision: 192

Added:
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
Modified:
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
Log:
seperate netlink code

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-12-01 08:29:32 UTC (rev 191)
+++ trunk/kernel/Makefile	2005-12-01 08:31:50 UTC (rev 192)
@@ -6,7 +6,7 @@
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= tgt_core.o
-tgt_core-objs	:= tgt.o tgt_sysfs.o tgt_protocol.o
+tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o
 
 obj-m		+= tgt_vsd.o tgt_scsi.o
 #obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-01 08:29:32 UTC (rev 191)
+++ trunk/kernel/tgt.c	2005-12-01 08:31:50 UTC (rev 192)
@@ -12,11 +12,9 @@
 #include <linux/pagemap.h>
 #include <linux/slab.h>
 #include <linux/mempool.h>
-#include <linux/netlink.h>
 #include <linux/blkdev.h>
 #include <linux/file.h>
 #include <asm/scatterlist.h>
-#include <net/tcp.h>
 
 #include <tgt.h>
 #include <tgt_target.h>
@@ -24,6 +22,8 @@
 #include <tgt_if.h>
 #include <tgt_protocol.h>
 
+#include "tgt_priv.h"
+
 MODULE_LICENSE("GPL");
 
 static spinlock_t all_targets_lock;
@@ -35,9 +35,6 @@
 static spinlock_t device_tmpl_lock;
 static LIST_HEAD(device_tmpl_list);
 
-static int tgtd_pid;
-static struct sock *nls;
-
 static struct target_type_internal *target_template_get(const char *name)
 {
 	unsigned long flags;
@@ -230,7 +227,7 @@
 	return err;
 }
 
-static struct tgt_target *target_find(int tid)
+struct tgt_target *target_find(int tid)
 {
 	struct tgt_target *target;
 
@@ -606,8 +603,8 @@
 	return 0;
 }
 
-static int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
-			     int fd, unsigned long dflags)
+int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
+		      int fd, unsigned long dflags)
 {
 	struct tgt_target *target;
 	struct tgt_device *device;
@@ -699,7 +696,7 @@
 	kfree(device);
 }
 
-static int tgt_device_destroy(int tid, uint64_t dev_id)
+int tgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct tgt_device *device;
 	struct tgt_target *target;
@@ -967,38 +964,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_start);
 
-int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
-{
-	struct tgt_protocol *proto = cmd->session->target->proto;
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	char *pdu;
-	int len, proto_pdu_size = proto->uspace_pdu_size;
-
-	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev->data;
-	ev->k.cmd_req.tid = cmd->session->target->tid;
-	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
-	ev->k.cmd_req.cid = cmd->rq->tag;
-	ev->k.cmd_req.typeid = cmd->session->target->typeid;
-
-	proto->uspace_pdu_build(cmd, pdu);
-
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
-}
-EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
-
 static struct tgt_cmd *find_cmd_by_id(struct request_queue *q, uint64_t cid)
 {
 
@@ -1010,8 +975,8 @@
 	return NULL;
 }
 
-static int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-			   int result, uint32_t len)
+int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+		    int result, uint32_t len)
 {
 	struct tgt_target *target;
 	struct tgt_device *device;
@@ -1082,159 +1047,9 @@
 	return 0;
 }
 
-static int send_event_res(uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags)
-{
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len;
-
-	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-	skb = alloc_skb(len, flags);
-	if (!skb)
-		return -ENOMEM;
-
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, type, len - sizeof(*nlh), 0);
-
-	ev = NLMSG_DATA(nlh);
-	memcpy(ev, p, sizeof(*ev));
-	if (dlen)
-		memcpy(ev->data, data, dlen);
-
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
-}
-
-int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
-{
-	struct tgt_event ev;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.tgt_passthru.tid = target->tid;
-	ev.k.tgt_passthru.typeid = target->typeid;
-	ev.k.tgt_passthru.len = dlen;
-
-	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
-			      &ev, data, dlen, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_msg_send);
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	int err = 0;
-	struct tgt_event *ev = NLMSG_DATA(nlh);
-	struct tgt_target *target;
-
-	dprintk("%d %d %d\n", nlh->nlmsg_type,
-		nlh->nlmsg_pid, current->pid);
-
-	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_START:
-		tgtd_pid  = NETLINK_CREDS(skb)->pid;
-		eprintk("start target drivers\n");
-		break;
-	case TGT_UEVENT_TARGET_CREATE:
-		target = tgt_target_create(ev->u.c_target.type,
-					   ev->u.c_target.nr_cmds);
-		if (target)
-			err = target->tid;
-		else
-			err = -EINVAL;
-		break;
-	case TGT_UEVENT_TARGET_DESTROY:
-		target = target_find(ev->u.d_target.tid);
-		if (target)
-			err = tgt_target_destroy(target);
-		else
-			err = -EINVAL;
-		break;
-	case TGT_UEVENT_TARGET_PASSTHRU:
-		target = target_find(ev->u.tgt_passthru.tid);
-		if (!target || !target->tt->msg_recv) {
-			dprintk("Could not find target %d for passthru\n",
-				ev->u.tgt_passthru.tid);
-			err = -EINVAL;
-			break;
-		}
-
-		err = target->tt->msg_recv(target, ev->u.tgt_passthru.len,
-					   ev->data);
-		break;
-	case TGT_UEVENT_DEVICE_CREATE:
-		err = tgt_device_create(ev->u.c_device.tid,
-					ev->u.c_device.dev_id,
-					ev->u.c_device.type,
-					ev->u.c_device.fd,
-					ev->u.c_device.flags);
-		break;
-	case TGT_UEVENT_DEVICE_DESTROY:
-		err = tgt_device_destroy(ev->u.d_device.tid,
-					 ev->u.d_device.dev_id);
-		break;
-	case TGT_UEVENT_CMD_RES:
-		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
-				      ev->u.cmd_res.cid, ev->data,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len);
-		break;
-	default:
-		eprintk("unknown type %d\n", nlh->nlmsg_type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		err = event_recv_msg(skb, nlh);
-
-		eprintk("%d %d\n", nlh->nlmsg_type, err);
-		/*
-		 * TODO for passthru commands the lower level should
-		 * probably handle the result or we should modify this
-		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
-		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
-			struct tgt_event ev;
-
-			memset(&ev, 0, sizeof(ev));
-			ev.k.event_res.err = err;
-			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-				       GFP_KERNEL | __GFP_NOFAIL);
-		}
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
 static void __exit tgt_exit(void)
 {
-	if (nls)
-		sock_release(nls->sk_socket);
-
+	tgt_nl_exit();
 	tgt_sysfs_exit();
 }
 
@@ -1252,13 +1067,13 @@
 	if (err)
 		return err;
 
-	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
-	if (!nls)
+	err = tgt_nl_init();
+	if (err)
 		goto out;
 
 	return 0;
 out:
-	tgt_exit();
+	tgt_sysfs_exit();
 	return err;
 }
 

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-01 08:29:32 UTC (rev 191)
+++ trunk/kernel/tgt.h	2005-12-01 08:31:50 UTC (rev 192)
@@ -95,8 +95,6 @@
 				      void *priv);
 extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
-extern int tgt_sysfs_init(void);
-extern void tgt_sysfs_exit(void);
 
 #define DEBUG_TGT
 

Added: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-01 08:29:32 UTC (rev 191)
+++ trunk/kernel/tgt_nl.c	2005-12-01 08:31:50 UTC (rev 192)
@@ -0,0 +1,214 @@
+/*
+ * Target Netlink Framework code
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/netlink.h>
+#include <net/tcp.h>
+
+#include <tgt.h>
+#include <tgt_target.h>
+#include <tgt_device.h>
+#include <tgt_if.h>
+#include <tgt_protocol.h>
+#include "tgt_priv.h"
+
+static int tgtd_pid;
+static struct sock *nls;
+
+int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
+{
+	struct tgt_protocol *proto = cmd->session->target->proto;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+	char *pdu;
+	int len, proto_pdu_size = proto->uspace_pdu_size;
+
+	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
+	if (!skb)
+		return -ENOMEM;
+
+	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
+			  len - sizeof(*nlh), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+
+	pdu = (char *) ev->data;
+	ev->k.cmd_req.tid = cmd->session->target->tid;
+	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
+	ev->k.cmd_req.cid = cmd->rq->tag;
+	ev->k.cmd_req.typeid = cmd->session->target->typeid;
+
+	proto->uspace_pdu_build(cmd, pdu);
+
+	return netlink_unicast(nls, skb, tgtd_pid, 0);
+}
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
+
+static int send_event_res(uint16_t type, struct tgt_event *p,
+			  void *data, int dlen, gfp_t flags)
+{
+	struct tgt_event *ev;
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len;
+
+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
+	skb = alloc_skb(len, flags);
+	if (!skb)
+		return -ENOMEM;
+
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, type, len - sizeof(*nlh), 0);
+
+	ev = NLMSG_DATA(nlh);
+	memcpy(ev, p, sizeof(*ev));
+	if (dlen)
+		memcpy(ev->data, data, dlen);
+
+	return netlink_unicast(nls, skb, tgtd_pid, 0);
+}
+
+int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.tgt_passthru.tid = target->tid;
+	ev.k.tgt_passthru.typeid = target->typeid;
+	ev.k.tgt_passthru.len = dlen;
+
+	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
+			      &ev, data, dlen, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_msg_send);
+
+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+{
+	int err = 0;
+	struct tgt_event *ev = NLMSG_DATA(nlh);
+	struct tgt_target *target;
+
+	dprintk("%d %d %d\n", nlh->nlmsg_type,
+		nlh->nlmsg_pid, current->pid);
+
+	switch (nlh->nlmsg_type) {
+	case TGT_UEVENT_START:
+		tgtd_pid  = NETLINK_CREDS(skb)->pid;
+		eprintk("start target drivers\n");
+		break;
+	case TGT_UEVENT_TARGET_CREATE:
+		target = tgt_target_create(ev->u.c_target.type,
+					   ev->u.c_target.nr_cmds);
+		if (target)
+			err = target->tid;
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_TARGET_DESTROY:
+		target = target_find(ev->u.d_target.tid);
+		if (target)
+			err = tgt_target_destroy(target);
+		else
+			err = -EINVAL;
+		break;
+	case TGT_UEVENT_TARGET_PASSTHRU:
+		target = target_find(ev->u.tgt_passthru.tid);
+		if (!target || !target->tt->msg_recv) {
+			dprintk("Could not find target %d for passthru\n",
+				ev->u.tgt_passthru.tid);
+			err = -EINVAL;
+			break;
+		}
+
+		err = target->tt->msg_recv(target, ev->u.tgt_passthru.len,
+					   ev->data);
+		break;
+	case TGT_UEVENT_DEVICE_CREATE:
+		err = tgt_device_create(ev->u.c_device.tid,
+					ev->u.c_device.dev_id,
+					ev->u.c_device.type,
+					ev->u.c_device.fd,
+					ev->u.c_device.flags);
+		break;
+	case TGT_UEVENT_DEVICE_DESTROY:
+		err = tgt_device_destroy(ev->u.d_device.tid,
+					 ev->u.d_device.dev_id);
+		break;
+	case TGT_UEVENT_CMD_RES:
+		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
+				      ev->u.cmd_res.cid, ev->data,
+				      ev->u.cmd_res.result, ev->u.cmd_res.len);
+		break;
+	default:
+		eprintk("unknown type %d\n", nlh->nlmsg_type);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int event_recv_skb(struct sk_buff *skb)
+{
+	int err;
+	uint32_t rlen;
+	struct nlmsghdr	*nlh;
+
+	while (skb->len >= NLMSG_SPACE(0)) {
+		nlh = (struct nlmsghdr *) skb->data;
+		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+			return 0;
+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+		if (rlen > skb->len)
+			rlen = skb->len;
+		err = event_recv_msg(skb, nlh);
+
+		eprintk("%d %d\n", nlh->nlmsg_type, err);
+		/*
+		 * TODO for passthru commands the lower level should
+		 * probably handle the result or we should modify this
+		 */
+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
+		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
+			struct tgt_event ev;
+
+			memset(&ev, 0, sizeof(ev));
+			ev.k.event_res.err = err;
+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+				       GFP_KERNEL | __GFP_NOFAIL);
+		}
+		skb_pull(skb, rlen);
+	}
+	return 0;
+}
+
+static void event_recv(struct sock *sk, int length)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+		if (event_recv_skb(skb) && skb->len)
+			skb_queue_head(&sk->sk_receive_queue, skb);
+		else
+			kfree_skb(skb);
+	}
+}
+
+void __exit tgt_nl_exit(void)
+{
+	sock_release(nls->sk_socket);
+}
+
+int __init tgt_nl_init(void)
+{
+	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
+	if (!nls)
+		return -ENOMEM;
+
+	return 0;
+}

Added: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-01 08:29:32 UTC (rev 191)
+++ trunk/kernel/tgt_priv.h	2005-12-01 08:31:50 UTC (rev 192)
@@ -0,0 +1,17 @@
+#ifndef _TGT_PRIV_H
+#define _TGT_PRIV_H
+
+struct tgt_target;
+
+extern struct tgt_target *target_find(int tid);
+extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
+			     int fd, unsigned long dflags);
+extern int tgt_device_destroy(int tid, uint64_t dev_id);
+extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+			   int result, uint32_t len);
+extern void tgt_nl_exit(void);
+extern int tgt_nl_init(void);
+extern int tgt_sysfs_init(void);
+extern void tgt_sysfs_exit(void);
+
+#endif



From tomo at berlios.de  Thu Dec  1 13:53:55 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 1 Dec 2005 13:53:55 +0100
Subject: [Stgt-svn] r193 - trunk/kernel
Message-ID: <200512011253.jB1Crtkw020641@sheep.berlios.de>

Author: tomo
Date: 2005-12-01 13:53:41 +0100 (Thu, 01 Dec 2005)
New Revision: 193

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
Log:
Remove synchronous interface of session operations to simplify the code.


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-01 08:31:50 UTC (rev 192)
+++ trunk/kernel/tgt.c	2005-12-01 12:53:41 UTC (rev 193)
@@ -334,11 +334,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_destroy);
 
-struct tgt_session_wait {
-	struct completion event;
-	int err;
-};
-
 static void tgt_session_op_init(struct tgt_session *session,
 				void (*func)(void *),
 				tgt_session_done_t *done, void *arg)
@@ -349,17 +344,6 @@
 	queue_work(session->target->twq, &session->work);
 }
 
-static void tgt_session_sync_helper(void *arg, struct tgt_session *session)
-{
-	struct tgt_session_wait *w = (struct tgt_session_wait *) arg;
-
-	if (session)
-		w->err = 0;
-	else
-		w->err = 1;
-	complete(&w->event);
-}
-
 static void tgt_session_async_create(void *data)
 {
 	struct tgt_session *session = (struct tgt_session *) data;
@@ -377,8 +361,6 @@
 		spin_lock_irqsave(&target->lock, flags);
 		list_add(&session->slist, &target->session_list);
 		spin_unlock_irqrestore(&target->lock, flags);
-
-		set_bit(TGT_SESSION_CREATED, &session->state);
 	}
 
 	session->done(session->arg, err ? NULL : session);
@@ -386,28 +368,21 @@
 		kfree(session);
 }
 
-struct tgt_session *tgt_session_create(struct tgt_target *target,
-				       tgt_session_done_t *done, void *arg)
+int tgt_session_create(struct tgt_target *target, tgt_session_done_t *done,
+		       void *arg)
 {
 	struct tgt_session *session;
-	struct tgt_session_wait w;
 
-	session = kzalloc(sizeof(*session), done ? GFP_ATOMIC : GFP_KERNEL);
+	BUG_ON(!done);
+	session = kzalloc(sizeof(*session), GFP_ATOMIC);
 	if (!session)
-		return NULL;
+		return -ENOMEM;
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 
-	init_completion(&w.event);
-	tgt_session_op_init(session, tgt_session_async_create,
-			    done ? : tgt_session_sync_helper,
-			    arg ? : &w);
-	if (!done) {
-		wait_for_completion(&w.event);
-		if (w.err)
-			return NULL;
-	}
-	return session;
+	tgt_session_op_init(session, tgt_session_async_create, done, arg);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(tgt_session_create);
 
@@ -421,7 +396,8 @@
 	list_del(&session->slist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	session->done(session->arg, NULL);
+	if (session->done)
+		session->done(session->arg, NULL);
 
 	mempool_destroy(session->cmd_pool);
 	kfree(session);
@@ -430,19 +406,8 @@
 int tgt_session_destroy(struct tgt_session *session,
 			tgt_session_done_t *done, void *arg)
 {
-	struct tgt_session_wait w;
-
-	/* We cannot handle unfinished sessions. Should we do? */
-	BUG_ON(!test_bit(TGT_SESSION_CREATED, &session->state));
-
-	init_completion(&w.event);
 	tgt_session_op_init(session, tgt_session_async_destroy,
-			    done ? : tgt_session_sync_helper,
-			    arg ? : &w);
-
-	if (!done)
-		wait_for_completion(&w.event);
-
+			    done, arg);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(tgt_session_destroy);

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-01 08:31:50 UTC (rev 192)
+++ trunk/kernel/tgt.h	2005-12-01 12:53:41 UTC (rev 193)
@@ -27,16 +27,11 @@
 
 typedef void (tgt_session_done_t) (void *, struct tgt_session *);
 
-enum {
-	TGT_SESSION_CREATED,
-};
-
 struct tgt_session {
 	struct tgt_target *target;
 	struct list_head slist;
 
 	mempool_t *cmd_pool;
-	unsigned long state;
 
 	struct work_struct work;
 	tgt_session_done_t *done;
@@ -83,9 +78,8 @@
 	unsigned long proto_priv[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
-extern struct tgt_session *
-tgt_session_create(struct tgt_target *target,
-		   tgt_session_done_t *done, void *arg);
+extern int tgt_session_create(struct tgt_target *target,
+			      tgt_session_done_t *done, void *arg);
 extern int tgt_session_destroy(struct tgt_session *session,
 			       tgt_session_done_t *done, void *arg);
 extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,



From tomo at berlios.de  Thu Dec  1 13:55:38 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 1 Dec 2005 13:55:38 +0100
Subject: [Stgt-svn] r194 - trunk/ibmvstgt/kernel
Message-ID: <200512011255.jB1CtcBE022501@sheep.berlios.de>

Author: tomo
Date: 2005-12-01 13:55:32 +0100 (Thu, 01 Dec 2005)
New Revision: 194

Modified:
   trunk/ibmvstgt/kernel/ibmvstgt.c
Log:
ibmvstgt uses the new session interface.

Modified: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-01 12:53:41 UTC (rev 193)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-01 12:55:32 UTC (rev 194)
@@ -1074,9 +1074,23 @@
 	handle_cmd_queue(adapter);
 }
 
+struct session_wait {
+	struct completion event;
+	struct tgt_session *ts;
+};
+
+static void session_done(void *arg, struct tgt_session *session)
+{
+	struct session_wait *w = (struct session_wait *) arg;
+
+	w->ts = session;
+	complete(&w->event);
+}
+
 static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
 {
 	struct tgt_target *tt;
+	struct session_wait w;
 	struct server_adapter *adapter;
 	unsigned int *dma, dma_size;
 	int err = -ENOMEM;
@@ -1114,10 +1128,13 @@
 	INIT_WORK(&adapter->crq_work, handle_crq, adapter);
 	INIT_LIST_HEAD(&adapter->cmd_queue);
 
-	adapter->ts = tgt_session_create(tt, NULL, NULL);
-	if (!adapter->ts)
+	init_completion(&w.event);
+	if (tgt_session_create(tt, session_done, &w))
 		goto free_tt;
-
+	wait_for_completion(&w.event);
+	if (!w.ts)
+		goto free_tt;
+	adapter->ts = w.ts;
 	adapter->iu_pool = mempool_create(INITIAL_SRP_LIMIT,
 					  mempool_alloc_slab,
 					  mempool_free_slab, iu_cache);



From tomo at berlios.de  Thu Dec  1 13:56:05 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 1 Dec 2005 13:56:05 +0100
Subject: [Stgt-svn] r195 - trunk/istgt/kernel
Message-ID: <200512011256.jB1Cu5Wn023113@sheep.berlios.de>

Author: tomo
Date: 2005-12-01 13:56:00 +0100 (Thu, 01 Dec 2005)
New Revision: 195

Modified:
   trunk/istgt/kernel/session.c
Log:
istgt uses the new session interface.

Modified: trunk/istgt/kernel/session.c
===================================================================
--- trunk/istgt/kernel/session.c	2005-12-01 12:55:32 UTC (rev 194)
+++ trunk/istgt/kernel/session.c	2005-12-01 12:56:00 UTC (rev 195)
@@ -19,9 +19,23 @@
 	return NULL;
 }
 
+struct session_wait {
+	struct completion event;
+	struct tgt_session *ts;
+};
+
+static void session_done(void *arg, struct tgt_session *session)
+{
+	struct session_wait *w = (struct session_wait *) arg;
+
+	w->ts = session;
+	complete(&w->event);
+}
+
 int session_add(struct iscsi_target *target, struct session_info *info)
 {
 	struct iscsi_session *session;
+	struct session_wait w;
 	int i;
 
 	dprintk("%p %u %" PRIx64 "\n", target, target->tid, info->sid);
@@ -34,6 +48,14 @@
 	if (!session)
 		return -ENOMEM;
 
+	init_completion(&w.event);
+	if (tgt_session_create(target->tt, session_done, &w))
+		goto kfree_session;
+	wait_for_completion(&w.event);
+	if (!w.ts)
+		goto kfree_session;
+
+	session->ts = w.ts;
 	session->target = target;
 	session->sid = info->sid;
 	memcpy(&session->param, &target->sess_param, sizeof(session->param));
@@ -53,9 +75,10 @@
 
 	list_add(&session->list, &target->session_list);
 
-	session->ts = tgt_session_create(target->tt, NULL, NULL);
-
 	return 0;
+kfree_session:
+	kfree(session);
+	return -ENOMEM;
 }
 
 int session_del(struct iscsi_target *target, uint64_t sid)



From tomo at berlios.de  Sun Dec  4 08:19:22 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 4 Dec 2005 08:19:22 +0100
Subject: [Stgt-svn] r196 - trunk/kernel
Message-ID: <200512040719.jB47JMwc003552@sheep.berlios.de>

Author: tomo
Date: 2005-12-04 08:19:09 +0100 (Sun, 04 Dec 2005)
New Revision: 196

Modified:
   trunk/kernel/tgt.c
Log:
Kill unnecessary check in __tgt_cmd_destroy().


Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-01 12:56:00 UTC (rev 195)
+++ trunk/kernel/tgt.c	2005-12-04 07:19:09 UTC (rev 196)
@@ -709,28 +709,22 @@
 {
 	struct tgt_cmd *cmd = data;
 	struct request *rq = cmd->rq;
-	struct request_queue *q = NULL;
+	struct request_queue *q = rq->q;
 	unsigned long flags;
 
-	if (rq) {
-		q = rq->q;
+	dprintk("tag %d\n", rq->tag);
+	spin_lock_irqsave(q->queue_lock, flags);
+	if (blk_rq_tagged(rq))
+		blk_queue_end_tag(q, rq);
+	end_that_request_last(rq);
+	spin_unlock_irqrestore(q->queue_lock, flags);
 
-		dprintk("tag %d\n", rq->tag);
-
-		spin_lock_irqsave(q->queue_lock, flags);
-		if (blk_rq_tagged(rq))
-			blk_queue_end_tag(q, rq);
-		end_that_request_last(rq);
-		spin_unlock_irqrestore(q->queue_lock, flags);
-	}
-
 	if (cmd->device)
 		tgt_device_put(cmd->device);
 
 	mempool_free(cmd, cmd->session->cmd_pool);
 
-	if (q)
-		blk_run_queue(q);
+	blk_run_queue(q);
 }
 
 static void tgt_cmd_destroy(struct tgt_cmd *cmd)



From mnc at berlios.de  Wed Dec  7 10:54:09 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Wed, 7 Dec 2005 10:54:09 +0100
Subject: [Stgt-svn] r197 - in trunk: ibmvstgt/kernel istgt/kernel kernel
Message-ID: <200512070954.jB79s9vF015194@sheep.berlios.de>

Author: mnc
Date: 2005-12-07 10:53:53 +0100 (Wed, 07 Dec 2005)
New Revision: 197

Modified:
   trunk/ibmvstgt/kernel/ibmvstgt.c
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
Log:
I think the proto->create_cmd was a bad idea on part. This erases it and makes the protocol only used between tgt-core.

Modified: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-04 07:19:09 UTC (rev 196)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-07 09:53:53 UTC (rev 197)
@@ -22,7 +22,6 @@
 #include <tgt.h>
 #include <tgt_target.h>
 #include <tgt_scsi.h>
-#include <tgt_protocol.h>
 
 #include "viosrp.h"
 
@@ -297,15 +296,12 @@
 static int process_cmd(struct iu_entry *iue)
 {
 	struct tgt_target *tt = iue->adapter->tt;
-	struct tgt_protocol *proto;
 	union viosrp_iu *iu = vio_iu(iue);
 	enum dma_data_direction data_dir;
 	int tags, len;
 	uint8_t lun[8];
 
 	dprintk("%p %p %p\n", tt, iue->adapter, iue);
-	proto = tt->proto;
-	BUG_ON(!proto);
 
 	if (getlink(iue))
 		__set_bit(V_LINKED, &iue->req.flags);
@@ -353,9 +349,8 @@
 		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, lun[1], tags);
 
 	BUG_ON(!iue->adapter->ts);
-	BUG_ON(!proto->create_cmd);
-	iue->tc = proto->create_cmd(iue->adapter->ts, iue, iu->srp.cmd.cdb,
-				    len, data_dir, lun, sizeof(lun), tags);
+	iue->tc = scsi_tgt_create_cmd(iue->adapter->ts, iue, iu->srp.cmd.cdb,
+				      len, data_dir, lun, sizeof(lun), tags);
 	BUG_ON(!iue->tc);
 	dprintk("%p\n", iue->tc);
 

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-12-04 07:19:09 UTC (rev 196)
+++ trunk/istgt/kernel/iscsi.c	2005-12-07 09:53:53 UTC (rev 197)
@@ -761,7 +761,6 @@
 {
 	struct iscsi_cmd *req_hdr = cmd_hdr(req);
 	struct iscsi_conn *conn = req->conn;
-	struct tgt_protocol *proto = conn->session->ts->target->proto;
 	enum dma_data_direction data_dir;
 	int tags = MSG_SIMPLE_TAG;;
 
@@ -790,11 +789,11 @@
 		break;
 	}
 
-	req->tc = proto->create_cmd(conn->session->ts, req, req_hdr->cdb,
-				    be32_to_cpu(req_hdr->data_length),
-				    data_dir, req_hdr->lun,
-				    sizeof(req_hdr->lun),
-				    tags);
+	req->tc = scsi_tgt_create_cmd(conn->session->ts, req, req_hdr->cdb,
+				     be32_to_cpu(req_hdr->data_length),
+				     data_dir, req_hdr->lun,
+				     sizeof(req_hdr->lun),
+				     tags);
 	BUG_ON(!req->tc);
 
 	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-12-04 07:19:09 UTC (rev 196)
+++ trunk/kernel/tgt_protocol.h	2005-12-07 09:53:53 UTC (rev 197)
@@ -26,21 +26,7 @@
 
 	kmem_cache_t *cmd_cache;
 	unsigned uspace_pdu_size;
-
 	/*
-	 * Create a command and allocate a buffer of size data_len for
-	 * for transfer. The buffer will be allocated with GFP_KERNEL
-	 * and preprocesed by tgt/scsi_proto so the next time
-	 * the target driver is notified about the cmd is when
-	 * the transfer* is called.
-	 */
-	struct tgt_cmd *(* create_cmd)(struct tgt_session *session,
-				       void *tgt_priv, uint8_t *cmd,
-				       uint32_t data_len,
-				       enum dma_data_direction data_dir,
-				       uint8_t *dev_id_buff, int id_buff_size,
-				       int flags);
-	/*
 	 * Build userspace packet
 	 */
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-04 07:19:09 UTC (rev 196)
+++ trunk/kernel/tgt_scsi.c	2005-12-07 09:53:53 UTC (rev 197)
@@ -46,7 +46,7 @@
  * we may have to add a wrapper becuase people are passing the lun in
  * differently
  */
-static struct tgt_cmd *
+struct tgt_cmd *
 scsi_tgt_create_cmd(struct tgt_session *session, void *tgt_priv, uint8_t *scb,
 		    uint32_t data_len, enum dma_data_direction data_dir,
 		    uint8_t *lun, int lun_size, int tags)
@@ -79,6 +79,8 @@
 	return cmd;
 }
 
+EXPORT_SYMBOL_GPL(scsi_tgt_create_cmd);
+
 /* kspace command failure */
 int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 			      uint8_t ascode, uint8_t ascodeq)
@@ -148,7 +150,6 @@
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
-	.create_cmd = scsi_tgt_create_cmd,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
 	.uspace_cmd_execute = scsi_tgt_uspace_cmd_exec,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-12-04 07:19:09 UTC (rev 196)
+++ trunk/kernel/tgt_scsi.h	2005-12-07 09:53:53 UTC (rev 197)
@@ -27,4 +27,9 @@
 extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
 extern int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 				     uint8_t ascode, uint8_t ascodeq);
+extern struct tgt_cmd *scsi_tgt_create_cmd(struct tgt_session *session,
+			void *tgt_priv, uint8_t *scb, uint32_t data_len,
+			enum dma_data_direction data_dir, uint8_t *lun,
+			int lun_size, int tags);
+
 #endif



From mnc at berlios.de  Wed Dec  7 11:08:26 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Wed, 7 Dec 2005 11:08:26 +0100
Subject: [Stgt-svn] r198 - in trunk: . kernel
Message-ID: <200512071008.jB7A8QBd002142@sheep.berlios.de>

Author: mnc
Date: 2005-12-07 11:08:02 +0100 (Wed, 07 Dec 2005)
New Revision: 198

Added:
   trunk/qla2xxx/
Modified:
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_target.h
Log:
trivial header cleanup: move soem private functions to the tgt_priv header

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-07 09:53:53 UTC (rev 197)
+++ trunk/kernel/tgt_priv.h	2005-12-07 10:08:02 UTC (rev 198)
@@ -3,15 +3,24 @@
 
 struct tgt_target;
 
+/* tgt core */
 extern struct tgt_target *target_find(int tid);
 extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags);
 extern int tgt_device_destroy(int tid, uint64_t dev_id);
 extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
 			   int result, uint32_t len);
+
+/* netlink */
 extern void tgt_nl_exit(void);
 extern int tgt_nl_init(void);
+
+/* Sysfs */
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
+extern int tgt_sysfs_register_type(struct target_type_internal *ti);
+extern void tgt_sysfs_unregister_type(struct target_type_internal *ti);
+extern int tgt_sysfs_register_target(struct tgt_target *target);
+extern void tgt_sysfs_unregister_target(struct tgt_target *target);
 
 #endif

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-12-07 09:53:53 UTC (rev 197)
+++ trunk/kernel/tgt_target.h	2005-12-07 10:08:02 UTC (rev 198)
@@ -122,12 +122,8 @@
 
 extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds);
 extern int tgt_target_destroy(struct tgt_target *target);
-extern int tgt_sysfs_register_target(struct tgt_target *target);
-extern void tgt_sysfs_unregister_target(struct tgt_target *target);
 
 extern int tgt_target_template_register(struct tgt_target_template *tt);
 extern void tgt_target_template_unregister(struct tgt_target_template *tt);
-extern int tgt_sysfs_register_type(struct target_type_internal *ti);
-extern void tgt_sysfs_unregister_type(struct target_type_internal *ti);
 
 #endif



From mnc at berlios.de  Wed Dec  7 11:44:25 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Wed, 7 Dec 2005 11:44:25 +0100
Subject: [Stgt-svn] r199 - trunk/kernel
Message-ID: <200512071044.jB7AiPUx007014@sheep.berlios.de>

Author: mnc
Date: 2005-12-07 11:44:20 +0100 (Wed, 07 Dec 2005)
New Revision: 199

Modified:
   trunk/kernel/tgt.c
Log:
a hw target could be removed from userspace or kernel (due to hotunplug). TODO: We must add refcouting now

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-07 10:08:02 UTC (rev 198)
+++ trunk/kernel/tgt.c	2005-12-07 10:44:20 UTC (rev 199)
@@ -313,12 +313,23 @@
 
 int tgt_target_destroy(struct tgt_target *target)
 {
+	unsigned long flags;
+
 	dprintk("%p\n", target);
 
-	if (!list_empty(&target->device_list))
+	spin_lock_irqsave(&target->lock, flags);
+	if (!list_empty(&target->device_list)) {
+		spin_unlock_irqrestore(&target->lock, flags);
 		return -EBUSY;
+	}
+	spin_unlock_irqrestore(&target->lock, flags);
 
 	spin_lock(&all_targets_lock);
+	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
+	if (list_empty(&target->tlist)) {
+		spin_unlock(&all_targets_lock);
+		return -ENODEV;
+	}
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 



From mnc at berlios.de  Wed Dec  7 11:51:14 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Wed, 7 Dec 2005 11:51:14 +0100
Subject: [Stgt-svn] r200 - trunk/kernel
Message-ID: <200512071051.jB7ApEL8008393@sheep.berlios.de>

Author: mnc
Date: 2005-12-07 11:51:09 +0100 (Wed, 07 Dec 2005)
New Revision: 200

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt_target.h
Log:
nevermind the last patch, we should just add a state field which will come in handy later

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-07 10:44:20 UTC (rev 199)
+++ trunk/kernel/tgt.c	2005-12-07 10:51:09 UTC (rev 200)
@@ -258,6 +258,7 @@
 	if (!ti)
 		goto free_target;
 
+	target->state = TGT_CREATED;
 	target->tt = ti->tt;
 	target->proto = ti->proto;
 	target->typeid = ti->typeid;
@@ -322,14 +323,13 @@
 		spin_unlock_irqrestore(&target->lock, flags);
 		return -EBUSY;
 	}
+	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
+	if (target->state == TGT_DESTROYED)
+		return -ENODEV;
+	target->state = TGT_DESTROYED;
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	spin_lock(&all_targets_lock);
-	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
-	if (list_empty(&target->tlist)) {
-		spin_unlock(&all_targets_lock);
-		return -ENODEV;
-	}
 	list_del(&target->tlist);
 	spin_unlock(&all_targets_lock);
 

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-12-07 10:44:20 UTC (rev 199)
+++ trunk/kernel/tgt_target.h	2005-12-07 10:51:09 UTC (rev 200)
@@ -94,6 +94,11 @@
 	struct class_device_attribute **target_attrs;
 };
 
+enum {
+	TGT_CREATED,
+	TGT_DESTROYED,
+};
+
 struct tgt_target {
 	int typeid;
 	int tid;
@@ -105,8 +110,9 @@
 
 	struct request_queue *q;
 	int queued_cmds;
+	int state;
 
-	/* Protects session_list and device_list */
+	/* Protects session_list and device_list and state */
 	spinlock_t lock;
 
 	struct list_head tlist;



From mnc at berlios.de  Wed Dec  7 12:03:36 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Wed, 7 Dec 2005 12:03:36 +0100
Subject: [Stgt-svn] r201 - trunk/kernel
Message-ID: <200512071103.jB7B3abY010296@sheep.berlios.de>

Author: mnc
Date: 2005-12-07 12:03:27 +0100 (Wed, 07 Dec 2005)
New Revision: 201

Modified:
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
Log:
move internal struct to priv header

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-07 10:51:09 UTC (rev 200)
+++ trunk/kernel/tgt_priv.h	2005-12-07 11:03:27 UTC (rev 201)
@@ -16,6 +16,14 @@
 extern int tgt_nl_init(void);
 
 /* Sysfs */
+struct target_type_internal {
+	int typeid;
+	struct list_head list;
+	struct tgt_target_template *tt;
+	struct tgt_protocol *proto;
+	struct class_device cdev;
+};
+
 extern int tgt_sysfs_init(void);
 extern void tgt_sysfs_exit(void);
 extern int tgt_sysfs_register_type(struct target_type_internal *ti);

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-12-07 10:51:09 UTC (rev 200)
+++ trunk/kernel/tgt_sysfs.c	2005-12-07 11:03:27 UTC (rev 201)
@@ -9,6 +9,8 @@
 #include <tgt_target.h>
 #include <tgt_device.h>
 
+#include "tgt_priv.h"
+
 static struct class_device_attribute *class_attr_overridden(
 				struct class_device_attribute **attrs,
 				struct class_device_attribute *attr)

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-12-07 10:51:09 UTC (rev 200)
+++ trunk/kernel/tgt_target.h	2005-12-07 11:03:27 UTC (rev 201)
@@ -15,14 +15,6 @@
 struct tgt_target;
 struct tgt_cmd;
 
-struct target_type_internal {
-	int typeid;
-	struct list_head list;
-	struct tgt_target_template *tt;
-	struct tgt_protocol *proto;
-	struct class_device cdev;
-};
-
 enum {
 	TGT_CMD_XMIT_OK,
 	TGT_CMD_XMIT_FAILED,



From tomo at berlios.de  Wed Dec  7 12:19:11 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 7 Dec 2005 12:19:11 +0100
Subject: [Stgt-svn] r202 - in trunk: ibmvstgt/kernel istgt/kernel kernel
Message-ID: <200512071119.jB7BJBen012617@sheep.berlios.de>

Author: tomo
Date: 2005-12-07 12:19:08 +0100 (Wed, 07 Dec 2005)
New Revision: 202

Modified:
   trunk/ibmvstgt/kernel/ibmvstgt.c
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
Log:
Now tgt_cmd_create calls proto->cmd_create and then tgt_cmd_start. Target LLDs should not call proto->cmd_create directly.


Modified: trunk/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/ibmvstgt/kernel/ibmvstgt.c	2005-12-07 11:19:08 UTC (rev 202)
@@ -349,8 +349,8 @@
 		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, lun[1], tags);
 
 	BUG_ON(!iue->adapter->ts);
-	iue->tc = scsi_tgt_create_cmd(iue->adapter->ts, iue, iu->srp.cmd.cdb,
-				      len, data_dir, lun, sizeof(lun), tags);
+	iue->tc = tgt_cmd_create(iue->adapter->ts, iue, iu->srp.cmd.cdb,
+				 len, data_dir, lun, sizeof(lun), tags);
 	BUG_ON(!iue->tc);
 	dprintk("%p\n", iue->tc);
 

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/istgt/kernel/iscsi.c	2005-12-07 11:19:08 UTC (rev 202)
@@ -789,11 +789,11 @@
 		break;
 	}
 
-	req->tc = scsi_tgt_create_cmd(conn->session->ts, req, req_hdr->cdb,
-				     be32_to_cpu(req_hdr->data_length),
-				     data_dir, req_hdr->lun,
-				     sizeof(req_hdr->lun),
-				     tags);
+	req->tc = tgt_cmd_create(conn->session->ts, req, req_hdr->cdb,
+				 be32_to_cpu(req_hdr->data_length),
+				 data_dir, req_hdr->lun,
+				 sizeof(req_hdr->lun),
+				 tags);
 	BUG_ON(!req->tc);
 
 	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/kernel/tgt.c	2005-12-07 11:19:08 UTC (rev 202)
@@ -778,8 +778,10 @@
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
-struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, uint64_t dev_id,
-			       void *tgt_priv)
+struct tgt_cmd *
+tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
+	       uint32_t data_len, enum dma_data_direction data_dir,
+	       uint8_t *dev_buf, int dev_buf_size, int flags)
 {
 	struct tgt_cmd *cmd;
 
@@ -788,9 +790,10 @@
 		eprintk("Could not allocate tgt_cmd for %p\n", session);
 		return NULL;
 	}
+	memset(cmd, 0, sizeof(*cmd));
+	session->target->proto->cmd_create(cmd, cb, data_len, data_dir,
+					   dev_buf, dev_buf_size, flags);
 
-	memset(cmd, 0, sizeof(*cmd));
-	cmd->dev_id = dev_id;
 	cmd->device = tgt_device_get(session->target, cmd->dev_id);
 	cmd->session = session;
 	cmd->private = tgt_priv;
@@ -798,6 +801,9 @@
 	atomic_set(&cmd->state, TGT_CMD_CREATED);
 
 	dprintk("%p %p\n", session, cmd);
+
+	tgt_cmd_start(cmd);
+
 	return cmd;
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_create);

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/kernel/tgt.h	2005-12-07 11:19:08 UTC (rev 202)
@@ -85,8 +85,10 @@
 extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
 			gfp_t flags);
 extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask);
-extern struct tgt_cmd *tgt_cmd_create(struct tgt_session *session, uint64_t id,
-				      void *priv);
+extern struct tgt_cmd *
+tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
+	       uint32_t data_len, enum dma_data_direction data_dir,
+	       uint8_t *dev_buf, int dev_buf_size, int flags);
 extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
 

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/kernel/tgt_protocol.h	2005-12-07 11:19:08 UTC (rev 202)
@@ -26,9 +26,22 @@
 
 	kmem_cache_t *cmd_cache;
 	unsigned uspace_pdu_size;
+
+ 	/*
+	 * Create a command and allocate a buffer of size data_len for
+	 * for transfer. The buffer will be allocated with GFP_KERNEL
+	 * and preprocesed by tgt/scsi_proto so the next time
+	 * the target driver is notified about the cmd is when
+	 * the transfer* is called.
+	 */
+	void (* cmd_create)(struct tgt_cmd *cmd, uint8_t *cb,
+			    uint32_t data_len, enum dma_data_direction data_dir,
+			    uint8_t *dev_id_buff, int id_buff_size,
+			    int flags);
 	/*
 	 * Build userspace packet
 	 */
+
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/kernel/tgt_scsi.c	2005-12-07 11:19:08 UTC (rev 202)
@@ -46,23 +46,15 @@
  * we may have to add a wrapper becuase people are passing the lun in
  * differently
  */
-struct tgt_cmd *
-scsi_tgt_create_cmd(struct tgt_session *session, void *tgt_priv, uint8_t *scb,
+static void
+scsi_tgt_cmd_create(struct tgt_cmd *cmd, uint8_t *scb,
 		    uint32_t data_len, enum dma_data_direction data_dir,
 		    uint8_t *lun, int lun_size, int tags)
 {
-	struct tgt_cmd *cmd;
 	struct scsi_tgt_cmd *scmd;
-	uint64_t id;
 
 	/* translate target driver LUN to device id */
-	id = scsi_tgt_translate_lun(lun, lun_size);
-
-	cmd = tgt_cmd_create(session, id, tgt_priv);
-	if (!cmd) {
-		eprintk("Could not allocate command\n");
-		return NULL;
-	}
+	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	scmd = tgt_cmd_to_scsi(cmd);
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
 	scmd->tags = tags;
@@ -74,13 +66,8 @@
 	 * handler overide just in case
 	 */
 	cmd->bufflen = data_len;
-
-	tgt_cmd_start(cmd);
-	return cmd;
 }
 
-EXPORT_SYMBOL_GPL(scsi_tgt_create_cmd);
-
 /* kspace command failure */
 int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 			      uint8_t ascode, uint8_t ascodeq)
@@ -150,6 +137,7 @@
 static struct tgt_protocol scsi_tgt_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
+	.cmd_create = scsi_tgt_cmd_create,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
 	.uspace_cmd_execute = scsi_tgt_uspace_cmd_exec,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-12-07 11:03:27 UTC (rev 201)
+++ trunk/kernel/tgt_scsi.h	2005-12-07 11:19:08 UTC (rev 202)
@@ -27,9 +27,4 @@
 extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
 extern int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
 				     uint8_t ascode, uint8_t ascodeq);
-extern struct tgt_cmd *scsi_tgt_create_cmd(struct tgt_session *session,
-			void *tgt_priv, uint8_t *scb, uint32_t data_len,
-			enum dma_data_direction data_dir, uint8_t *lun,
-			int lun_size, int tags);
-
 #endif



From tomo at berlios.de  Thu Dec 22 01:41:14 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 22 Dec 2005 01:41:14 +0100
Subject: [Stgt-svn] r205 - in trunk: istgt/kernel kernel
Message-ID: <200512220041.jBM0fEUe023930@sheep.berlios.de>

Author: tomo
Date: 2005-12-22 01:40:54 +0100 (Thu, 22 Dec 2005)
New Revision: 205

Modified:
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt_nl.c
Log:
Replace wrong eprintk with dprintk.

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-12-19 15:12:43 UTC (rev 204)
+++ trunk/istgt/kernel/iscsi.c	2005-12-22 00:40:54 UTC (rev 205)
@@ -164,7 +164,7 @@
 	expsize = cmnd_read_size(cmnd);
 	BUG_ON(!cmnd->tc);
 	size = min(expsize, cmnd->tc->bufflen);
-	eprintk("%u %u\n", expsize, cmnd->tc->bufflen);
+	dprintk("%u %u\n", expsize, cmnd->tc->bufflen);
 	offset = 0;
 	sn = 0;
 

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-19 15:12:43 UTC (rev 204)
+++ trunk/kernel/tgt_nl.c	2005-12-22 00:40:54 UTC (rev 205)
@@ -196,7 +196,7 @@
 			rlen = skb->len;
 		err = event_recv_msg(skb, nlh);
 
-		eprintk("%d %d\n", nlh->nlmsg_type, err);
+		dprintk("%d %d\n", nlh->nlmsg_type, err);
 		/*
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this



From tomo at berlios.de  Fri Dec 23 05:36:53 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 05:36:53 +0100
Subject: [Stgt-svn] r206 - branches
Message-ID: <200512230436.jBN4arcW019571@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 05:36:50 +0100 (Fri, 23 Dec 2005)
New Revision: 206

Added:
   branches/uio-mmap/
Log:
Create a new tree for mmap I/O in user space.

Copied: branches/uio-mmap (from rev 205, trunk)



From tomo at berlios.de  Fri Dec 23 07:52:04 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 07:52:04 +0100
Subject: [Stgt-svn] r207 - in branches/uio-mmap: . include istgt/usr kernel usr
Message-ID: <200512230652.jBN6q47c003975@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 07:51:07 +0100 (Fri, 23 Dec 2005)
New Revision: 207

Modified:
   branches/uio-mmap/include/tgt_if.h
   branches/uio-mmap/initd
   branches/uio-mmap/istgt/usr/istgt.c
   branches/uio-mmap/kernel/Makefile
   branches/uio-mmap/kernel/tgt.c
   branches/uio-mmap/kernel/tgt.h
   branches/uio-mmap/kernel/tgt_device.h
   branches/uio-mmap/kernel/tgt_nl.c
   branches/uio-mmap/kernel/tgt_priv.h
   branches/uio-mmap/kernel/tgt_protocol.h
   branches/uio-mmap/kernel/tgt_scsi.c
   branches/uio-mmap/kernel/tgt_sysfs.c
   branches/uio-mmap/kernel/tgt_vsd.c
   branches/uio-mmap/usr/dl.c
   branches/uio-mmap/usr/dl.h
   branches/uio-mmap/usr/netlink.c
   branches/uio-mmap/usr/scsi.c
Log:
execute READ/WRITE commands in user space using mmap.

Modified: branches/uio-mmap/include/tgt_if.h
===================================================================
--- branches/uio-mmap/include/tgt_if.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/include/tgt_if.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -22,7 +22,8 @@
 	TGT_KEVENT_RESPONSE,
 	TGT_KEVENT_CMD_REQ,
 	TGT_KEVENT_TARGET_PASSTHRU,
-	TGT_KEVENT_TASK_MGMT
+	TGT_KEVENT_TASK_MGMT,
+	TGT_KEVENT_CMD_DONE,
 };
 
 #define	TGT_INVALID_DEV_ID	~0ULL
@@ -58,6 +59,14 @@
 			uint64_t cid;
 			uint32_t len;
 			int result;
+			/*
+			 * this is screwed for setups with 64 bit kernel
+			 * and 32 bit userspace
+			 */
+			unsigned long uaddr;
+			uint64_t offset;
+			uint8_t rw;
+			uint8_t try_map;
 		} cmd_res;
 		struct {
 			uint64_t rid;
@@ -80,6 +89,8 @@
 			uint64_t dev_id;
 			uint64_t cid;
 			int typeid;
+			int fd;
+			uint32_t data_len;
 		} cmd_req;
 		struct {
 			int tid;
@@ -95,6 +106,12 @@
 			uint64_t dev_id;
 			uint64_t tag;
 		} task_mgmt;
+		struct {
+			int tid;
+			int typeid;
+			unsigned long uaddr;
+			uint32_t len;
+		} cmd_done;
 	} k;
 
 	/*

Modified: branches/uio-mmap/initd
===================================================================
--- branches/uio-mmap/initd	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/initd	2005-12-23 06:51:07 UTC (rev 207)
@@ -15,8 +15,6 @@
 {
 	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/tgt_vsd.ko
-#	insmod ${PWD}/kernel/tgt_sd.ko
 
 	if [ $TARGET = "istgt" ] ; then
 		modprobe -q crc32c
@@ -25,7 +23,7 @@
 		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
 	fi
 
-	${PWD}/usr/tgtd
+	${PWD}/usr/tgtd -d 0
 }
 	
 stop_server()

Modified: branches/uio-mmap/istgt/usr/istgt.c
===================================================================
--- branches/uio-mmap/istgt/usr/istgt.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/istgt/usr/istgt.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -174,8 +174,6 @@
 	struct pollfd *pfd;
 	int i, res, opt;
 
-	eprintf("%d\n", nr);
-
 	for (i = 0; i < LISTEN_MAX; i++) {
 		if (pfds[POLL_LISTEN + i].revents)
 			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);

Modified: branches/uio-mmap/kernel/Makefile
===================================================================
--- branches/uio-mmap/kernel/Makefile	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/Makefile	2005-12-23 06:51:07 UTC (rev 207)
@@ -8,8 +8,7 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vsd.o tgt_scsi.o
-#obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o
+obj-m		+= tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: branches/uio-mmap/kernel/tgt.c
===================================================================
--- branches/uio-mmap/kernel/tgt.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -26,6 +26,8 @@
 
 MODULE_LICENSE("GPL");
 
+struct task_struct *tgtd_tsk;
+
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
@@ -148,24 +150,13 @@
 {
 	struct tgt_cmd *cmd;
 	struct request *rq;
-	int err;
 
 	while ((rq = elv_next_request(q)) != NULL) {
 		/* we need to set state or refcount under this lock! */
 		cmd = rq->special;
-
 		/*
-		 * the iosched nicely ordered these, should we try to keep the
-		 * ordering or for most cases will it not make a difference
-		 * since the lower levels will iosched again (not for
-		 * passthrough though). Maybe we should use a tgt_device
-		 * flag to indicate what is best for the real device.
-		 */
-		if (atomic_read(&cmd->state) != TGT_CMD_READY)
-			break;
-		/*
 		 * hit queue depth (command completion will run the
-		 * queue again
+		 * queue again)
 		 */
 		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
 			break;
@@ -174,23 +165,14 @@
 
 		dprintk("cmd %p tag %d\n", cmd, rq->tag);
 
-		if (!cmd->device) {
-			struct tgt_target *target = cmd->session->target;
+		/*
+		 * TODO: build a vector of commands and then do the
+	 	 * userspace send call
+		 */
 
-			INIT_WORK(&cmd->work, target->proto->uspace_cmd_execute,
-				  cmd);
-			queue_work(target->twq, &cmd->work);
-			err = TGT_CMD_USPACE_QUEUED;
-		} else
-			err = cmd->device->dt->execute_cmd(cmd);
-	        switch (err) {
-	        case TGT_CMD_FAILED:
-		case TGT_CMD_COMPLETED:
-			dprintk("command completed %d\n", err);
-			tgt_transfer_response(cmd);
-		default:
-			dprintk("command %d queued to real dev\n", rq->tag);
-		}
+		/* what should we do on failure here ? */
+		if (tgt_uspace_cmd_send(cmd, GFP_ATOMIC) < 0)
+			eprintk("command %d failed\n", rq->tag);
 
 		spin_lock_irq(q->queue_lock);
 	}
@@ -423,74 +405,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_session_destroy);
 
-struct device_type_internal {
-	struct tgt_device_template *sdt;
-	struct list_head list;
-};
-
-static struct tgt_device_template *device_template_get(const char *name)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (!strcmp(name, ti->sdt->name)) {
-			if (!try_module_get(ti->sdt->module))
-				ti = NULL;
-			spin_unlock_irqrestore(&device_tmpl_lock, flags);
-			return ti ? ti->sdt : NULL;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void device_template_put(struct tgt_device_template *sdt)
-{
-	module_put(sdt->module);
-}
-
-int tgt_device_template_register(struct tgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-
-	INIT_LIST_HEAD(&ti->list);
-	ti->sdt = sdt;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-	list_add_tail(&ti->list, &device_tmpl_list);
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_device_template_register);
-
-void tgt_device_template_unregister(struct tgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (ti->sdt == sdt) {
-			list_del(&ti->list);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_device_template_unregister);
-
 /*
  * TODO: use a hash or any better alg/ds
  */
@@ -585,6 +499,7 @@
 	struct tgt_target *target;
 	struct tgt_device *device;
 	unsigned long flags;
+	struct inode *inode;
 
 	dprintk("tid %d dev_id %" PRIu64 " type %s fd %d\n",
 		tid, dev_id, device_type, fd);
@@ -607,22 +522,18 @@
 		goto free_device;
 	}
 
-	device->dt = device_template_get(device_type);
-	if (!device->dt) {
-		eprintk("Could not get devive type %s\n", device_type);
-		goto put_fd;
-	}
+	/* TODO: kill me */
+	inode = device->file->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
 
-	device->dt_data = kzalloc(device->dt->priv_data_size, GFP_KERNEL);
-	if (!device->dt_data)
-		goto put_template;
+	device->use_clustering = 1;
+	device->size = inode->i_size;
 
-	if (device->dt->create)
-		if (device->dt->create(device))
-			goto free_priv_dt_data;
-
 	if (tgt_queue_create(target->proto, TGT_QUEUE_DEPTH, &device->q))
-		goto dt_destroy;
+		goto put_fd;
 	tgt_device_queue_setup(device);
 
 	if (tgt_sysfs_register_device(device))
@@ -636,13 +547,6 @@
 
 queue_destroy:
 	tgt_queue_destroy(device->q);
-dt_destroy:
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-free_priv_dt_data:
-	kfree(device->dt_data);
-put_template:
-	device_template_put(device->dt);
 put_fd:
 	fput(device->file);
 free_device:
@@ -661,14 +565,9 @@
 	list_del(&device->dlist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-
 	tgt_queue_destroy(device->q);
 	fput(device->file);
-	device_template_put(device->dt);
 
-	kfree(device->dt_data);
 	kfree(device);
 }
 
@@ -716,6 +615,22 @@
 	kfree(cmd->sg);
 }
 
+static void tgt_unmap_user_pages(struct tgt_cmd *cmd)
+{
+	struct page *page;
+	int i;
+
+	for (i = 0; i < cmd->sg_count; i++) {
+		page = cmd->pages[i];
+		if(!page)
+			break;
+		if (test_bit(TGT_CMD_RW, &cmd->flags))
+			set_page_dirty_lock(page);
+		page_cache_release(page);
+	}
+	kfree(cmd->pages);
+}
+
 static void __tgt_cmd_destroy(void *data)
 {
 	struct tgt_cmd *cmd = data;
@@ -724,6 +639,14 @@
 	unsigned long flags;
 
 	dprintk("tag %d\n", rq->tag);
+
+	if (test_bit(TGT_CMD_MAPPED, &cmd->flags)) {
+		tgt_unmap_user_pages(cmd);
+		kfree(cmd->sg);
+		tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
+	} else
+		tgt_free_buffer(cmd);
+
 	spin_lock_irqsave(q->queue_lock, flags);
 	if (blk_rq_tagged(rq))
 		blk_queue_end_tag(q, rq);
@@ -742,8 +665,6 @@
 {
 	dprintk("cmd %p\n", cmd);
 
-	tgt_free_buffer(cmd);
-
 	/*
 	 * Goose the queue incase we are blocked on a queue depth
 	 * limit or resource problem.
@@ -761,6 +682,8 @@
 	struct tgt_target *target = cmd->session->target;
 	int err;
 
+	dprintk("cmd %p\n", cmd);
+
 	cmd->done = tgt_cmd_destroy;
 	err = target->tt->transfer_response(cmd);
 	switch (err) {
@@ -778,12 +701,35 @@
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
+static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
+{
+	int write = (cmd->data_dir == DMA_TO_DEVICE);
+	struct request_queue *q;
+	struct request *rq;
+
+	if (cmd->device)
+		q = cmd->device->q;
+	else
+		q = cmd->session->target->q;
+
+	rq = blk_get_request(q, write, gfp_mask);
+	if (!rq)
+		return -ENOMEM;
+
+	cmd->rq = rq;
+	rq->special = cmd;
+	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
+	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 1);
+	return 0;
+}
+
 struct tgt_cmd *
 tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
 	       uint32_t data_len, enum dma_data_direction data_dir,
 	       uint8_t *dev_buf, int dev_buf_size, int flags)
 {
 	struct tgt_cmd *cmd;
+	int err;
 
 	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
 	if (!cmd) {
@@ -802,56 +748,23 @@
 
 	dprintk("%p %p\n", session, cmd);
 
-	tgt_cmd_start(cmd);
+	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
+	if (err) {
+		mempool_free(cmd, cmd->session->cmd_pool);
+		return NULL;
+	}
 
 	return cmd;
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_create);
 
-static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
-{
-	int write = (cmd->data_dir == DMA_TO_DEVICE);
-	struct request_queue *q;
-	struct request *rq;
-
-	if (cmd->device)
-		q = cmd->device->q;
-	else
-		q = cmd->session->target->q;
-
-	rq = blk_get_request(q, write, gfp_mask);
-	if (!rq)
-		return -ENOMEM;
-
-	cmd->rq = rq;
-	rq->special = cmd;
-	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
-	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 0);
-	return 0;
-}
-
-static void set_cmd_ready(struct tgt_cmd *cmd)
-{
-	unsigned long flags;
-	struct request_queue *q = cmd->rq->q;
-
-	/*
-	 * we have a request that is ready for processing so
-	 * plug the queue
-	 */
-	spin_lock_irqsave(q->queue_lock, flags);
-	atomic_set(&cmd->state, TGT_CMD_READY);
-	blk_plug_device(q);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-}
-
 static void tgt_write_data_transfer_done(struct tgt_cmd *cmd)
 {
 	/*
 	 * TODO check for errors and add state checking. we may have
 	 * to internally queue for the target driver
 	 */
-	set_cmd_ready(cmd);
+	tgt_transfer_response(cmd);
 }
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
@@ -894,72 +807,16 @@
 	}
 }
 
-static void tgt_alloc_buffer(void *data)
+/*
+ * we should jsut pass the cmd pointer between userspace and the kernel
+ * as a handle like open-iscsi
+ */
+static struct tgt_cmd *find_cmd_by_id(int tid, uint64_t dev_id, uint64_t cid)
 {
-	struct tgt_cmd *cmd = data;
-
-	__tgt_alloc_buffer(cmd);
-	atomic_set(&cmd->state, TGT_CMD_BUF_ALLOCATED);
-
-	/*
-	 * we probably will not be able to rely on the target
-	 * driver knowing the data_dir so this may have to move
-	 * the devices or protocol if it becomes command specific
-	 */
-	if (cmd->data_dir == DMA_TO_DEVICE) {
-		cmd->done = tgt_write_data_transfer_done;
-		/*
-		 * TODO handle errors and possibly requeue for the
-		 * target driver
-		 */
-		cmd->session->target->tt->transfer_write_data(cmd);
-	} else
-		set_cmd_ready(cmd);
-}
-
-int tgt_cmd_start(struct tgt_cmd *cmd)
-{
-	struct tgt_session *session = cmd->session;
-	int err;
-
-	if (cmd->device)
-		cmd->device->dt->prep_cmd(cmd);
-
-	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
-	if (err)
-		return err;
-
-	if (cmd->bufflen) {
-		atomic_set(&cmd->state, TGT_CMD_STARTED);
-		INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
-		queue_work(session->target->twq, &cmd->work);
-	} else
-		set_cmd_ready(cmd);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_start);
-
-static struct tgt_cmd *find_cmd_by_id(struct request_queue *q, uint64_t cid)
-{
-
-	struct request *rq;
-
-	rq = blk_queue_find_tag(q, cid);
-	if (rq)
-		return rq->special;
-	return NULL;
-}
-
-int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-		    int result, uint32_t len)
-{
 	struct tgt_target *target;
 	struct tgt_device *device;
-	struct tgt_cmd *cmd;
 	struct request_queue *q;
-	char *p = data;
-	int i;
+	struct request *rq;
 
 	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
 		(unsigned long long) cid);
@@ -967,7 +824,7 @@
 	target = target_find(tid);
 	if (!target) {
 		eprintk("Could not find target %d\n", tid);
-		return -EINVAL;
+		return NULL;
 	}
 
 	if (dev_id == TGT_INVALID_DEV_ID)
@@ -977,12 +834,101 @@
 		if (!device) {
 			eprintk("Could not find device %llu\n",
 				(unsigned long long) dev_id);
-			return -EINVAL;
+			return NULL;
 		}
 		q = device->q;
 	}
 
-	cmd = find_cmd_by_id(q, cid);
+	rq = blk_queue_find_tag(q, cid);
+	if (rq)
+		return rq->special;
+
+	eprintk("Could not find rq for cid %llu\n", (unsigned long long) cid);
+	return NULL;
+}
+
+static int tgt_map_user_pages(int rw, struct tgt_cmd *cmd)
+{
+	int i, err = -EIO, cnt;
+	struct page *page, **pages;
+	uint64_t poffset = cmd->offset & ~PAGE_MASK;
+	uint32_t size, rest = cmd->bufflen;
+
+	cnt = pgcnt(cmd->bufflen, cmd->offset);
+	pages = kzalloc(cnt * sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+	cmd->pages = pages;
+
+	cmd->sg = kmalloc(cnt * sizeof(struct scatterlist), GFP_KERNEL);
+	if (!cmd->sg)
+		goto release_pages;
+	cmd->sg_count = cnt;
+
+	dprintk("cmd %p addr %lx cnt %d\n", cmd, cmd->uaddr, cnt);
+
+	if (rw == WRITE)
+		__set_bit(TGT_CMD_RW, &cmd->flags);
+
+	down_read(&tgtd_tsk->mm->mmap_sem);
+	err = get_user_pages(tgtd_tsk, tgtd_tsk->mm, cmd->uaddr, cnt,
+			     rw == WRITE, 0, pages, NULL);
+	up_read(&tgtd_tsk->mm->mmap_sem);
+
+	if (err < cnt) {
+		err = -EIO;
+		goto free_sg;
+	}
+
+	__set_bit(TGT_CMD_MAPPED, &cmd->flags);
+	/*
+	 * We have a request_queue and we have a the SGIO scatterlist stuff in
+	 * scsi-misc so we can use those functions to make us a request with
+	 * a proper scatterlist by using block layer funciotns ?????
+	 *
+	 * do a:
+	 * scsi_req_map_sg(cmd->rq, tmp_sg, cnt, orig_size, GFP_KERNEL);
+	 * blk_rq_map_sg(cmd->device->q or cmd->target->q, cmd->rq, cmd->sg);
+	 */
+	for (i = 0; i < cnt; i++) {
+		size = min_t(uint32_t, rest, PAGE_SIZE - poffset);
+
+		cmd->sg[i].page = pages[i];
+		cmd->sg[i].offset = poffset;
+		cmd->sg[i].length = size;
+
+		poffset = 0;
+		rest -= size;
+	}
+
+	return 0;
+
+free_sg:
+	kfree(cmd->sg);
+release_pages:
+	for (i = 0; i < cnt; i++) {
+		page = pages[i];
+		if(!page)
+			break;
+		if (!err && rw == WRITE)
+			set_page_dirty_lock(page);
+		page_cache_release(page);
+	}
+	kfree(pages);
+
+	return err;
+}
+
+int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+		    int result, uint32_t len, uint64_t offset,
+		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
+{
+	struct tgt_target *target;
+	struct tgt_cmd *cmd;
+	char *p = data;
+	int i;
+
+	cmd = find_cmd_by_id(tid, dev_id, cid);
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);
@@ -992,20 +938,30 @@
 	dprintk("cmd %p tag %d result %d len %d bufflen %u\n",
 		cmd, cmd->rq->tag, result, len, cmd->bufflen);
 
-	if (len) {
-		/*
-		 * yuck TODO fix.
-		 * This will happen if we thought we were going to do some
-		 * IO but we ended up just gettting some sense back
-		 */
-		if (len != cmd->bufflen) {
-			tgt_free_buffer(cmd);
+	cmd->uaddr = uaddr;
+	cmd->result = result;
+	cmd->offset = offset;
 
-			cmd->bufflen = len;
-			cmd->offset = 0;
+	target = cmd->session->target;
+	target->proto->uspace_cmd_complete(cmd);
 
-			__tgt_alloc_buffer(cmd);
+	if (try_map && !cmd->result) {
+		if (tgt_map_user_pages(rw, cmd))
+			return -EIO;
+		/* what to do for errors */
+
+		if (cmd->data_dir == DMA_TO_DEVICE) {
+			cmd->done = tgt_write_data_transfer_done;
+			/*
+			 * TODO handle errors and possibly requeue for the
+			 * target driver
+			 */
+			target->tt->transfer_write_data(cmd);
+			return 0;
 		}
+	} else if (len) {
+		cmd->bufflen = len;
+		__tgt_alloc_buffer(cmd);
 
 		for (i = 0; i < cmd->sg_count; i++) {
 			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
@@ -1016,10 +972,7 @@
 		}
 	}
 
-	cmd->result = result;
-	target->proto->uspace_cmd_complete(cmd);
 	tgt_transfer_response(cmd);
-
 	return 0;
 }
 

Modified: branches/uio-mmap/kernel/tgt.h
===================================================================
--- branches/uio-mmap/kernel/tgt.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -48,6 +48,11 @@
 	TGT_CMD_DONE,
 };
 
+enum {
+	TGT_CMD_MAPPED,
+	TGT_CMD_RW,		/* not set == read, set == write */
+};
+
 struct tgt_cmd {
 	struct tgt_session *session;
 	struct tgt_device *device;
@@ -55,6 +60,7 @@
 
 	atomic_t state;
 	uint64_t dev_id;
+	unsigned long flags;
 
 	struct work_struct work;
 	void (*done) (struct tgt_cmd *);
@@ -62,10 +68,13 @@
 	enum dma_data_direction data_dir;
 	int sg_count;
 	struct scatterlist *sg;
+	struct page **pages;
 	uint32_t bufflen;
 	uint64_t offset;
 	int result;
 
+	unsigned long uaddr;
+
 	struct request *rq;
 	/*
 	 * target driver private
@@ -89,13 +98,13 @@
 tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
 	       uint32_t data_len, enum dma_data_direction data_dir,
 	       uint8_t *dev_buf, int dev_buf_size, int flags);
-extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
 extern int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
 			      int func, uint64_t dev_id, uint64_t tag,
 			      gfp_t gfp_mask);
+extern int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags);
 
-#define DEBUG_TGT
+#define DEBUG_TGT 1
 
 #define eprintk(fmt, args...)					\
 do {								\

Modified: branches/uio-mmap/kernel/tgt_device.h
===================================================================
--- branches/uio-mmap/kernel/tgt_device.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_device.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -29,43 +29,11 @@
 	TGT_DEV_DEL = 0,
 };
 
-struct tgt_device_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	/*
-	 * setup and destroy private structures
-	 */
-	int (* create)(struct tgt_device *);
-	void (* destroy)(struct tgt_device *);
-	/*
-	 * queue or execute command. Return TGT_CMD*.
-	 * If returning TGT_CMD_COMPLETED or TGT_CMD_FAILED the result
-	 * field must be set.
-	 */
-	int (* execute_cmd)(struct tgt_cmd *cmd);
-	/*
-	 * complete a kernel command if your queue_command was async
-	 * and the device used one of the tgt threads to process the
-	 * command
-	 */
-	void (* complete_kern_cmd)(struct tgt_cmd *cmd);
-	/*
-	 * setup buffer or device fields if needed
-	 */
-	void (* prep_cmd)(struct tgt_cmd *cmd);
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **device_attrs;
-};
-
+/*
+ * TODO: we could do a queue per target instead of per device and kill
+ * all the tgt_device code
+ */
 struct tgt_device {
-	struct tgt_device_template *dt;
-	void *dt_data;
-
 	struct class_device cdev;
 
 	int fd;
@@ -100,7 +68,5 @@
 
 extern int tgt_sysfs_register_device(struct tgt_device *device);
 extern void tgt_sysfs_unregister_device(struct tgt_device *device);
-extern int tgt_device_template_register(struct tgt_device_template *dt);
-extern void tgt_device_template_unregister(struct tgt_device_template *dt);
 
 #endif

Modified: branches/uio-mmap/kernel/tgt_nl.c
===================================================================
--- branches/uio-mmap/kernel/tgt_nl.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_nl.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -44,6 +44,8 @@
 	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
 	ev->k.cmd_req.cid = cmd->rq->tag;
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
+	ev->k.cmd_req.fd = cmd->device ? cmd->device->fd : 0;
+	ev->k.cmd_req.data_len = cmd->bufflen;
 
 	proto->uspace_pdu_build(cmd, pdu);
 
@@ -88,6 +90,20 @@
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
+int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.cmd_done.tid = cmd->session->target->tid;
+	ev.k.cmd_done.typeid = cmd->session->target->typeid;
+	ev.k.cmd_done.uaddr = cmd->uaddr;
+	ev.k.cmd_done.len = cmd->bufflen;
+
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
+
 int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
 		       int func, uint64_t dev_id, uint64_t tag, gfp_t flags)
 {
@@ -121,6 +137,7 @@
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
 		tgtd_pid  = NETLINK_CREDS(skb)->pid;
+		tgtd_tsk = current;
 		eprintk("start target drivers\n");
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
@@ -164,7 +181,10 @@
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
 				      ev->u.cmd_res.cid, ev->data,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len);
+				      ev->u.cmd_res.result, ev->u.cmd_res.len,
+				      ev->u.cmd_res.offset,
+				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
+				      ev->u.cmd_res.try_map);
 		break;
 	case TGT_UEVENT_TASK_MGMT:
 		err = tgt_task_mgmt(ev->u.task_mgmt.rid, ev->u.task_mgmt.func,

Modified: branches/uio-mmap/kernel/tgt_priv.h
===================================================================
--- branches/uio-mmap/kernel/tgt_priv.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_priv.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -9,10 +9,14 @@
 			     int fd, unsigned long dflags);
 extern int tgt_device_destroy(int tid, uint64_t dev_id);
 extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-			   int result, uint32_t len);
+			   int result, uint32_t len, uint64_t offset,
+			   unsigned long addr,
+			   uint8_t rw, uint8_t try_map);
 extern int tgt_task_mgmt(uint64_t fid, int func, int tid, uint64_t sid,
 			 uint64_t lun, uint64_t tag, int res);
 
+extern struct task_struct *tgtd_tsk;
+
 /* netlink */
 extern void tgt_nl_exit(void);
 extern int tgt_nl_init(void);

Modified: branches/uio-mmap/kernel/tgt_protocol.h
===================================================================
--- branches/uio-mmap/kernel/tgt_protocol.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_protocol.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -45,7 +45,6 @@
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
-	void (* uspace_cmd_execute)(void *cmd);
 };
 
 extern void tgt_protocol_init(void);

Modified: branches/uio-mmap/kernel/tgt_scsi.c
===================================================================
--- branches/uio-mmap/kernel/tgt_scsi.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_scsi.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -108,19 +108,6 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-static void scsi_tgt_uspace_cmd_exec(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	int err;
-
-	err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
-	if (err >= 0)
-		return;
-
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-	tgt_transfer_response(cmd);
-}
-
 static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
 {
 	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
@@ -129,9 +116,14 @@
 
 static void scsi_tgt_uspace_cmd_complete(struct tgt_cmd *cmd)
 {
-	/* userspace did everything for us just copy the buffer */
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+
+	dprintk("%d %lu\n", cmd->result, cmd->uaddr);
+
 	if (cmd->result != SAM_STAT_GOOD)
 		scsi_tgt_sense_copy(cmd);
+
+	dprintk("res %d, cmd %p op 0x%02x\n", cmd->result, cmd, scmd->scb[0]);
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
@@ -139,7 +131,6 @@
 	.module = THIS_MODULE,
 	.cmd_create = scsi_tgt_cmd_create,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
-	.uspace_cmd_execute = scsi_tgt_uspace_cmd_exec,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };

Modified: branches/uio-mmap/kernel/tgt_sysfs.c
===================================================================
--- branches/uio-mmap/kernel/tgt_sysfs.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_sysfs.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -257,24 +257,11 @@
 	if (!class_device_get(&target->cdev))
 		return -EINVAL;
 
-	if (device->dt->device_attrs) {
-		for (i = 0; device->dt->device_attrs[i]; i++) {
-			err = class_attr_add(&device->cdev,
-					     tgt_target_attrs,
-					     device->dt->device_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
 	for (i = 0; tgt_device_attrs[i]; i++) {
-		if (!class_attr_overridden(device->dt->device_attrs,
-					   tgt_device_attrs[i])) {
-			err = class_device_create_file(&device->cdev,
-						       tgt_device_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
+		err = class_device_create_file(&device->cdev,
+					       tgt_device_attrs[i]);
+		if (err)
+			goto cleanup;
 	}
 
 	return 0;

Modified: branches/uio-mmap/kernel/tgt_vsd.c
===================================================================
--- branches/uio-mmap/kernel/tgt_vsd.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/kernel/tgt_vsd.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -74,102 +74,17 @@
 	cmd->offset = off;
 }
 
-/*
- * TODO: We need to redo our scatter lists so they take into account
- * this common usage, but also not violate HW limits
- */
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i < sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-/*
- * TODO this will move to a io_handler callout
- */
-static int vsd_execute_file_io(struct tgt_cmd *cmd, int op)
-{
-	struct file *file = cmd->device->file;
-	ssize_t ret;
-	struct iovec *iov;
-	loff_t pos = cmd->offset;
-
-	iov = sg_to_iovec(cmd->sg, cmd->sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (op == READ)
-		ret = generic_file_readv(file, iov, cmd->sg_count, &pos);
-	else
-		ret = generic_file_writev(file, iov, cmd->sg_count, &pos);
-
-	kfree(iov);
-
-	if (ret < 0 || ret != cmd->bufflen) {
-		eprintk("I/O error %d %Zd %u %lld %" PRIu64 "\n",
-			op, ret, cmd->bufflen, pos, cmd->device->size);
-		return -EINVAL;
-	}
-
-	/* sync_page_range(inode, inode->i_mapping, pos, (size_t) cmd->bufflen); */
-	return 0;
-}
-
 static void __tgt_vsd_execute(void *data)
 {
 	struct tgt_cmd *cmd = data;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	int err, rw;
+	int err;
 
-	switch (scmd->scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		rw = READ;
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		rw = WRITE;
-		break;
-	default:
-		err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
-		/*
-		 * successfully queued
-		 */
-		if (err >= 0)
-			return;
+	err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
+	if (err >= 0)
+		return;
 
-		goto failed;
-	};
-
-	err = vsd_execute_file_io(cmd, rw);
-	if (!err) {
-		cmd->result = SAM_STAT_GOOD;
-		goto done;
-	}
-
-	/*
-	 * we should do a switch but I am not sure of all the err values
-	 * returned. If you find one add it
-	 */
-failed:
 	/* TODO if -ENOMEM return QUEUEFULL or BUSY ??? */
 	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-done:
-	tgt_transfer_response(cmd);
 }
 
 static int tgt_vsd_execute(struct tgt_cmd *cmd)

Modified: branches/uio-mmap/usr/dl.c
===================================================================
--- branches/uio-mmap/usr/dl.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/usr/dl.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -178,3 +178,11 @@
 
 	return NULL;
 }
+
+void *dl_cmd_done_fn(int typeid)
+{
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, "cmd_done");
+
+	return NULL;
+}

Modified: branches/uio-mmap/usr/dl.h
===================================================================
--- branches/uio-mmap/usr/dl.h	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/usr/dl.h	2005-12-23 06:51:07 UTC (rev 207)
@@ -13,6 +13,7 @@
 extern void *dl_event_fn(int tid, int typeid);
 extern void *dl_proto_cmd_process(int tid, int typeid);
 extern void *dl_task_mgmt_fn(int typeid);
+extern void *dl_cmd_done_fn(int typeid);
 
 extern char *typeid_to_name(int typeid);
 

Modified: branches/uio-mmap/usr/netlink.c
===================================================================
--- branches/uio-mmap/usr/netlink.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/usr/netlink.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -112,9 +112,11 @@
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t cid = ev_req->k.cmd_req.cid;
-	uint8_t *scb;
-	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *);
+	uint64_t offset, cid = ev_req->k.cmd_req.cid;
+	uint8_t *scb, rw = 0, try_map = 0;
+	unsigned long uaddr;
+	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *, int, uint32_t,
+		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
 	scb = (uint8_t *) ev_req->data;
@@ -125,8 +127,13 @@
 
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
-			    ev_req->k.cmd_req.dev_id, scb,
-			    (uint8_t *) ev_res->data, &len);
+			    ev_req->k.cmd_req.dev_id,
+			    scb,
+			    (uint8_t *) ev_res->data,
+			    &len,
+			    ev_req->k.cmd_req.fd,
+			    ev_req->k.cmd_req.data_len,
+			    &uaddr, &rw, &try_map, &offset);
 	else {
 		result = -EINVAL;
 		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
@@ -139,8 +146,12 @@
 	ev_res->u.cmd_res.cid = cid;
 	ev_res->u.cmd_res.len = len;
 	ev_res->u.cmd_res.result = result;
+	ev_res->u.cmd_res.uaddr = uaddr;
+	ev_res->u.cmd_res.rw = rw;
+	ev_res->u.cmd_res.try_map = try_map;
+	ev_res->u.cmd_res.offset = offset;
 
-	log_error("scsi_cmd_process res %d len %d\n", result, len);
+	log_debug("scsi_cmd_process res %d len %d\n", result, len);
 
 	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
 			  NLMSG_SPACE(sizeof(*ev_res) + len));
@@ -188,6 +199,14 @@
 	case TGT_KEVENT_TASK_MGMT:
 		nl_task_mgmt(ev);
 		break;
+	case TGT_KEVENT_CMD_DONE:
+		fn = dl_cmd_done_fn(ev->k.cmd_done.typeid);
+		if (fn)
+			fn(NLMSG_DATA(recvbuf));
+		else
+			eprintf("Cannot handle cmd done %d\n",
+				ev->k.cmd_done.tid);
+		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);

Modified: branches/uio-mmap/usr/scsi.c
===================================================================
--- branches/uio-mmap/usr/scsi.c	2005-12-23 04:36:50 UTC (rev 206)
+++ branches/uio-mmap/usr/scsi.c	2005-12-23 06:51:07 UTC (rev 207)
@@ -26,9 +26,12 @@
 #include <scsi/srp.h>
 #include <scsi/iscsi_proto.h>
 #include <asm/byteorder.h>
+#include <asm/page.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <fcntl.h>
-#include <sys/socket.h>
 #include <linux/netlink.h>
 
 #include "tgtd.h"
@@ -39,7 +42,11 @@
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
 #define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
 
+#define READ 0
+#define WRITE 1
+
 #ifndef REPORT_LUNS
 #define REPORT_LUNS           0xa0
 #endif
@@ -501,13 +508,83 @@
 	return SAM_STAT_GOOD;
 }
 
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+
+static int io(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
+	      int fd, uint32_t datalen, unsigned long *uaddr)
+{
+	uint64_t off = 0;
+	void *p;
+	*len = 0;
+
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(uint32_t *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(uint64_t *) &scb[2]);
+		break;
+	default:
+		break;
+	}
+
+	off <<= 9;
+
+	p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
+
+	*uaddr = (unsigned long) p;
+	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
+
+	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
+}
+
+static uint64_t get_offset(uint8_t *scb)
+{
+	uint64_t off;
+
+	/*
+	 * set bufflen and offset
+	 */
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(uint32_t *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(uint64_t *) &scb[2]);
+		break;
+	default:
+		off = 0;
+		break;
+	}
+
+	return off << 9;
+}
+
 int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
-		uint32_t flags)
+		int fd, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+		uint8_t *try_map, uint64_t *offset)
 {
 	int result = SAM_STAT_GOOD;
 
-	dprintf("%d %" PRIu64 " %x %x\n", tid, lun, scb[0], flags);
+	dprintf("%d %" PRIu64 " %x %d %u\n", tid, lun, scb[0], fd, datalen);
 
+	*offset = get_offset(scb);
+
 	if (lun == TGT_INVALID_DEV_ID)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
@@ -515,6 +592,7 @@
 		case REPORT_LUNS:
 			break;
 		default:
+			*offset = 0;
 			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 						0x25, 0);
 			result = SAM_STAT_CHECK_CONDITION;
@@ -550,9 +628,19 @@
 		break;
 	case READ_6:
 	case READ_10:
+	case READ_16:
+		*rw = READ;
+		goto run_io;
 	case WRITE_6:
 	case WRITE_10:
+	case WRITE_16:
 	case WRITE_VERIFY:
+		*rw = WRITE;
+run_io:
+		result = io(tid, lun, scb, data, len, fd, datalen, uaddr);
+		if (result == SAM_STAT_GOOD)
+			*try_map = 1;
+		break;
 	case RESERVE:
 	case RELEASE:
 	case RESERVE_10:
@@ -717,3 +805,12 @@
 			    ev->k.task_mgmt.sid, ev->k.task_mgmt.dev_id,
 			    ev->k.task_mgmt.tag);
 }
+
+int cmd_done(struct tgt_event *ev)
+{
+	int err;
+	err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
+	dprintf("%lx %u %d\n", ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+	return err;
+}
+



From tomo at berlios.de  Fri Dec 23 08:02:04 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 08:02:04 +0100
Subject: [Stgt-svn] r208 - branches/uio-mmap
Message-ID: <200512230702.jBN724T8008623@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 08:01:50 +0100 (Fri, 23 Dec 2005)
New Revision: 208

Modified:
   branches/uio-mmap/initd
Log:
Fix initd script.

Modified: branches/uio-mmap/initd
===================================================================
--- branches/uio-mmap/initd	2005-12-23 06:51:07 UTC (rev 207)
+++ branches/uio-mmap/initd	2005-12-23 07:01:50 UTC (rev 208)
@@ -42,8 +42,6 @@
 		rmmod ibmvstgt
 	fi
 
-#	rmmod tgt_sd
-	rmmod tgt_vsd
 	rmmod tgt_scsi
 	rmmod tgt_core
 }



From tomo at berlios.de  Fri Dec 23 10:09:36 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 10:09:36 +0100
Subject: [Stgt-svn] r209 - branches/uio-mmap
Message-ID: <200512230909.jBN99aGV003631@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 10:09:25 +0100 (Fri, 23 Dec 2005)
New Revision: 209

Modified:
   branches/uio-mmap/initd
Log:
Enable tgt debug option in the init script again.

Modified: branches/uio-mmap/initd
===================================================================
--- branches/uio-mmap/initd	2005-12-23 07:01:50 UTC (rev 208)
+++ branches/uio-mmap/initd	2005-12-23 09:09:25 UTC (rev 209)
@@ -23,7 +23,7 @@
 		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
 	fi
 
-	${PWD}/usr/tgtd -d 0
+	${PWD}/usr/tgtd
 }
 	
 stop_server()



From tomo at berlios.de  Fri Dec 23 10:11:37 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 10:11:37 +0100
Subject: [Stgt-svn] r210 - in branches/uio-mmap: include kernel usr
Message-ID: <200512230911.jBN9BbnB004539@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 10:11:25 +0100 (Fri, 23 Dec 2005)
New Revision: 210

Modified:
   branches/uio-mmap/include/tgt_if.h
   branches/uio-mmap/kernel/tgt.c
   branches/uio-mmap/kernel/tgt_nl.c
   branches/uio-mmap/kernel/tgt_priv.h
   branches/uio-mmap/usr/netlink.c
   branches/uio-mmap/usr/scsi.c
Log:
Kill buffer allocation in kernel space. tgtd allocates buffer for Non I/O commands and then send it like the direct I/O code.


Modified: branches/uio-mmap/include/tgt_if.h
===================================================================
--- branches/uio-mmap/include/tgt_if.h	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/include/tgt_if.h	2005-12-23 09:11:25 UTC (rev 210)
@@ -111,6 +111,7 @@
 			int typeid;
 			unsigned long uaddr;
 			uint32_t len;
+			int mmapped;
 		} cmd_done;
 	} k;
 

Modified: branches/uio-mmap/kernel/tgt.c
===================================================================
--- branches/uio-mmap/kernel/tgt.c	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/kernel/tgt.c	2005-12-23 09:11:25 UTC (rev 210)
@@ -606,15 +606,6 @@
 	}
 }
 
-static void tgt_free_buffer(struct tgt_cmd *cmd)
-{
-	int i;
-
-	for (i = 0; i < cmd->sg_count; i++)
-		__free_page(cmd->sg[i].page);
-	kfree(cmd->sg);
-}
-
 static void tgt_unmap_user_pages(struct tgt_cmd *cmd)
 {
 	struct page *page;
@@ -640,12 +631,9 @@
 
 	dprintk("tag %d\n", rq->tag);
 
-	if (test_bit(TGT_CMD_MAPPED, &cmd->flags)) {
-		tgt_unmap_user_pages(cmd);
-		kfree(cmd->sg);
-		tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
-	} else
-		tgt_free_buffer(cmd);
+	tgt_unmap_user_pages(cmd);
+	kfree(cmd->sg);
+	tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
 
 	spin_lock_irqsave(q->queue_lock, flags);
 	if (blk_rq_tagged(rq))
@@ -767,47 +755,7 @@
 	tgt_transfer_response(cmd);
 }
 
-#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
-
 /*
- * TODO: this will have to obey at least the target driver's limits,
- * but to support passthrough commands we will need to obey the
- * something like's tgt_sd devices's queue's limits.
- */
-void __tgt_alloc_buffer(struct tgt_cmd *cmd)
-{
-	uint64_t offset = cmd->offset;
-	uint32_t len = cmd->bufflen;
-	int i;
-
-	cmd->sg_count = pgcnt(len, offset);
-	offset &= ~PAGE_CACHE_MASK;
-
-	dprintk("cmd %p tag %d pg_count %d offset %" PRIu64 " len %d\n",
-		cmd, cmd->rq->tag, cmd->sg_count, cmd->offset, cmd->bufflen);
-
-	/*
-	 * TODO: mempool this like in scsi_lib.c
-	 */
-	cmd->sg = kmalloc(cmd->sg_count * sizeof(struct scatterlist),
-			   GFP_KERNEL | __GFP_NOFAIL);
-
-	/*
-	 * TODO need to create reserves
-	 */
-	for (i = 0; i < cmd->sg_count; i++) {
-		struct scatterlist *sg = &cmd->sg[i];
-
-		sg->page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
-		sg->offset = offset;
-		sg->length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
-
-		offset = 0;
-		len -= sg->length;
-	}
-}
-
-/*
  * we should jsut pass the cmd pointer between userspace and the kernel
  * as a handle like open-iscsi
  */
@@ -847,6 +795,8 @@
 	return NULL;
 }
 
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
+
 static int tgt_map_user_pages(int rw, struct tgt_cmd *cmd)
 {
 	int i, err = -EIO, cnt;
@@ -880,7 +830,6 @@
 		goto free_sg;
 	}
 
-	__set_bit(TGT_CMD_MAPPED, &cmd->flags);
 	/*
 	 * We have a request_queue and we have a the SGIO scatterlist stuff in
 	 * scsi-misc so we can use those functions to make us a request with
@@ -919,14 +868,12 @@
 	return err;
 }
 
-int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
 		    int result, uint32_t len, uint64_t offset,
 		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
 {
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
-	char *p = data;
-	int i;
 
 	cmd = find_cmd_by_id(tid, dev_id, cid);
 	if (!cmd) {
@@ -941,15 +888,17 @@
 	cmd->uaddr = uaddr;
 	cmd->result = result;
 	cmd->offset = offset;
+	if (len)
+		cmd->bufflen = len;
+	if (try_map)
+		set_bit(TGT_CMD_MAPPED, &cmd->flags);
 
 	target = cmd->session->target;
-	target->proto->uspace_cmd_complete(cmd);
+/* 	target->proto->uspace_cmd_complete(cmd); */
 
-	if (try_map && !cmd->result) {
+	if (cmd->bufflen) {
 		if (tgt_map_user_pages(rw, cmd))
 			return -EIO;
-		/* what to do for errors */
-
 		if (cmd->data_dir == DMA_TO_DEVICE) {
 			cmd->done = tgt_write_data_transfer_done;
 			/*
@@ -959,17 +908,6 @@
 			target->tt->transfer_write_data(cmd);
 			return 0;
 		}
-	} else if (len) {
-		cmd->bufflen = len;
-		__tgt_alloc_buffer(cmd);
-
-		for (i = 0; i < cmd->sg_count; i++) {
-			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-
-			memcpy(page_address(cmd->sg[i].page), p, copy);
-			p += copy;
-			len -= copy;
-		}
 	}
 
 	tgt_transfer_response(cmd);

Modified: branches/uio-mmap/kernel/tgt_nl.c
===================================================================
--- branches/uio-mmap/kernel/tgt_nl.c	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/kernel/tgt_nl.c	2005-12-23 09:11:25 UTC (rev 210)
@@ -99,6 +99,8 @@
 	ev.k.cmd_done.typeid = cmd->session->target->typeid;
 	ev.k.cmd_done.uaddr = cmd->uaddr;
 	ev.k.cmd_done.len = cmd->bufflen;
+	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
+		ev.k.cmd_done.mmapped = 1;
 
 	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, flags);
 }
@@ -180,7 +182,7 @@
 		break;
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
-				      ev->u.cmd_res.cid, ev->data,
+				      ev->u.cmd_res.cid,
 				      ev->u.cmd_res.result, ev->u.cmd_res.len,
 				      ev->u.cmd_res.offset,
 				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,

Modified: branches/uio-mmap/kernel/tgt_priv.h
===================================================================
--- branches/uio-mmap/kernel/tgt_priv.h	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/kernel/tgt_priv.h	2005-12-23 09:11:25 UTC (rev 210)
@@ -8,7 +8,7 @@
 extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags);
 extern int tgt_device_destroy(int tid, uint64_t dev_id);
-extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
+extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,
 			   uint8_t rw, uint8_t try_map);

Modified: branches/uio-mmap/usr/netlink.c
===================================================================
--- branches/uio-mmap/usr/netlink.c	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/usr/netlink.c	2005-12-23 09:11:25 UTC (rev 210)
@@ -115,7 +115,7 @@
 	uint64_t offset, cid = ev_req->k.cmd_req.cid;
 	uint8_t *scb, rw = 0, try_map = 0;
 	unsigned long uaddr;
-	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *, int, uint32_t,
+	int (*fn) (int, uint64_t, uint8_t *, int *, int, uint32_t,
 		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
@@ -129,7 +129,6 @@
 		result = fn(ev_req->k.cmd_req.tid,
 			    ev_req->k.cmd_req.dev_id,
 			    scb,
-			    (uint8_t *) ev_res->data,
 			    &len,
 			    ev_req->k.cmd_req.fd,
 			    ev_req->k.cmd_req.data_len,
@@ -154,7 +153,7 @@
 	log_debug("scsi_cmd_process res %d len %d\n", result, len);
 
 	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res) + len));
+			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
 static void nl_task_mgmt(struct tgt_event *ev)

Modified: branches/uio-mmap/usr/scsi.c
===================================================================
--- branches/uio-mmap/usr/scsi.c	2005-12-23 09:09:25 UTC (rev 209)
+++ branches/uio-mmap/usr/scsi.c	2005-12-23 09:11:25 UTC (rev 210)
@@ -510,11 +510,12 @@
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 
-static int io(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
-	      int fd, uint32_t datalen, unsigned long *uaddr)
+static int mmap_device(int tid, uint64_t lun, uint8_t *scb,
+		       int *len, int fd, uint32_t datalen, unsigned long *uaddr,
+		       uint64_t *offset)
 {
-	uint64_t off = 0;
 	void *p;
+	uint64_t off;
 	*len = 0;
 
 	switch (scb[0]) {
@@ -532,6 +533,7 @@
 		off = be64_to_cpu(*(uint64_t *) &scb[2]);
 		break;
 	default:
+		off = 0;
 		break;
 	}
 
@@ -541,49 +543,46 @@
 		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
 
 	*uaddr = (unsigned long) p;
+	*offset = off;
 	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
 	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
 }
 
-static uint64_t get_offset(uint8_t *scb)
+static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
 {
-	uint64_t off;
+	int result = 1;
 
-	/*
-	 * set bufflen and offset
-	 */
 	switch (scb[0]) {
 	case READ_6:
+	case READ_10:
+	case READ_16:
+		*rw = READ;
+		break;
 	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
 	case WRITE_10:
+	case WRITE_16:
 	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
+		*rw = WRITE;
 		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
 	default:
-		off = 0;
-		break;
+		result = 0;
 	}
-
-	return off << 9;
+	return result;
 }
 
-int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
+int cmd_process(int tid, uint64_t lun, uint8_t *scb, int *len,
 		int fd, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		uint8_t *try_map, uint64_t *offset)
 {
 	int result = SAM_STAT_GOOD;
+	uint8_t *data = NULL;
 
 	dprintf("%d %" PRIu64 " %x %d %u\n", tid, lun, scb[0], fd, datalen);
 
-	*offset = get_offset(scb);
+	*offset = 0;
+	if (!mmap_cmd_init(scb, rw))
+		data = valloc(PAGE_SIZE);
 
 	if (lun == TGT_INVALID_DEV_ID)
 		switch (scb[0]) {
@@ -593,6 +592,8 @@
 			break;
 		default:
 			*offset = 0;
+			if (!data)
+				data = valloc(PAGE_SIZE);
 			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 						0x25, 0);
 			result = SAM_STAT_CHECK_CONDITION;
@@ -629,17 +630,20 @@
 	case READ_6:
 	case READ_10:
 	case READ_16:
-		*rw = READ;
-		goto run_io;
 	case WRITE_6:
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		*rw = WRITE;
-run_io:
-		result = io(tid, lun, scb, data, len, fd, datalen, uaddr);
+		result = mmap_device(tid, lun, scb, len, fd, datalen, uaddr, offset);
 		if (result == SAM_STAT_GOOD)
 			*try_map = 1;
+		else {
+			*offset = 0;
+			if (!data)
+				data = valloc(PAGE_SIZE);
+			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
+						0x25, 0);
+		}
 		break;
 	case RESERVE:
 	case RELEASE:
@@ -652,6 +656,9 @@
 	}
 
 out:
+	if (data)
+		*uaddr = (unsigned long) data;
+
 	return result;
 }
 
@@ -808,9 +815,15 @@
 
 int cmd_done(struct tgt_event *ev)
 {
-	int err;
-	err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
-	dprintf("%lx %u %d\n", ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+	int err = 0;
+
+	if (ev->k.cmd_done.mmapped)
+		err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
+	else
+		free((void *) ev->k.cmd_done.uaddr);
+
+	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
+		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+
 	return err;
 }
-



From tomo at berlios.de  Fri Dec 23 10:35:28 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Dec 2005 10:35:28 +0100
Subject: [Stgt-svn] r211 - branches/uio-mmap/kernel
Message-ID: <200512230935.jBN9ZSee018524@sheep.berlios.de>

Author: tomo
Date: 2005-12-23 10:35:11 +0100 (Fri, 23 Dec 2005)
New Revision: 211

Modified:
   branches/uio-mmap/kernel/tgt.c
Log:
set_bit TGT_CMD_RW in uspace_cmd_done().

Modified: branches/uio-mmap/kernel/tgt.c
===================================================================
--- branches/uio-mmap/kernel/tgt.c	2005-12-23 09:11:25 UTC (rev 210)
+++ branches/uio-mmap/kernel/tgt.c	2005-12-23 09:35:11 UTC (rev 211)
@@ -817,9 +817,6 @@
 
 	dprintk("cmd %p addr %lx cnt %d\n", cmd, cmd->uaddr, cnt);
 
-	if (rw == WRITE)
-		__set_bit(TGT_CMD_RW, &cmd->flags);
-
 	down_read(&tgtd_tsk->mm->mmap_sem);
 	err = get_user_pages(tgtd_tsk, tgtd_tsk->mm, cmd->uaddr, cnt,
 			     rw == WRITE, 0, pages, NULL);
@@ -890,8 +887,10 @@
 	cmd->offset = offset;
 	if (len)
 		cmd->bufflen = len;
+	if (rw == WRITE)
+		__set_bit(TGT_CMD_RW, &cmd->flags);
 	if (try_map)
-		set_bit(TGT_CMD_MAPPED, &cmd->flags);
+		__set_bit(TGT_CMD_MAPPED, &cmd->flags);
 
 	target = cmd->session->target;
 /* 	target->proto->uspace_cmd_complete(cmd); */



From mnc at berlios.de  Sat Dec 24 05:23:28 2005
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 24 Dec 2005 05:23:28 +0100
Subject: [Stgt-svn] r212 - branches/uio-mmap/kernel
Message-ID: <200512240423.jBO4NSog032749@sheep.berlios.de>

Author: mnc
Date: 2005-12-24 05:23:24 +0100 (Sat, 24 Dec 2005)
New Revision: 212

Removed:
   branches/uio-mmap/kernel/tgt_sd.c
   branches/uio-mmap/kernel/tgt_vsd.c
Log:
test ci: rm old files

Deleted: branches/uio-mmap/kernel/tgt_sd.c
===================================================================
--- branches/uio-mmap/kernel/tgt_sd.c	2005-12-23 09:35:11 UTC (rev 211)
+++ branches/uio-mmap/kernel/tgt_sd.c	2005-12-24 04:23:24 UTC (rev 212)
@@ -1,187 +0,0 @@
-/*
- * scsi disk functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <scsi/scsi.h>
-
-#include <tgt.h>
-#include <tgt_device.h>
-#include <tgt_scsi.h>
-
-/*
- * TODO set per device segment, max_sectors, etc limits
- */
-static int tgt_sd_create(struct tgt_device *device)
-{
-	struct file *file = device->file;
-	struct io_restrictions *limits = &device->limits;
-	struct request_queue *q;
-	struct inode *inode;
-
-	q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
-	limits->max_sectors = q->max_hw_sectors;
-	limits->max_phys_segments = q->max_phys_segments;
-	limits->max_hw_segments = q->max_hw_segments;
-	limits->hardsect_size = q->hardsect_size;
-	limits->max_segment_size = q->max_segment_size;
-	limits->seg_boundary_mask = q->seg_boundary_mask;
-	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
-		device->use_clustering = 1;
-	else
-		device->use_clustering = 0;
-
-	inode = file->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else
-		/*
-		 * can we handle scsi tape too actually?
-		 */
-		return -EINVAL;
-
-	device->size = inode->i_size;
-	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-}
-
-static void tgt_sd_prep(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	uint8_t *scb = scmd->scb;
-	uint64_t off = 0;
-
-	/*
-	 * set offset
-	 */
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		break;
-	}
-
-	off <<= 9;
-
-	cmd->offset = off;
-}
-
-static void tgt_sd_end_rq(struct request *rq)
-{
-	struct tgt_cmd *cmd = rq->end_io_data;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	if (rq->sense_len) {
-		memcpy(scmd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);
-		cmd->result = SAM_STAT_CHECK_CONDITION;
-	} else if (rq->errors) {
-		/*
-		 * TODO check *_byte and just send error upwards
-		 */
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		cmd->result = SAM_STAT_CHECK_CONDITION;
-	} else
-		cmd->result = SAM_STAT_GOOD;
-
-	tgt_transfer_response(cmd);
-	__blk_put_request(rq->q, rq);
-}
-
-/*
- * TODO part of this will move to a io_handler callout
- */
-static int tgt_sd_execute_rq(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	struct file *file = cmd->device->file;
-	request_queue_t *q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
-	struct request *rq;
-	int write = (cmd->data_dir == DMA_TO_DEVICE);
-
-	rq = blk_get_request(q, write, GFP_KERNEL | __GFP_NOFAIL);
-	if (!rq)
-		goto hw_error;
-
-/*	if (req_map_sg(q, rq, cmd->sg, cmd->sg_count,
-			GFP_KERNEL | __GFP_NOFAIL))
-		goto free_request;
-*/
-	rq->cmd_len = COMMAND_SIZE(scmd->scb[0]);
-	memcpy(rq->cmd, scmd->scb, rq->cmd_len);
-	rq->sense_len = 0;
-	rq->sense = scmd->sense_buff;
-	rq->end_io_data = cmd;
-	rq->timeout = 60 * HZ; /* TODO */
-	rq->flags |= REQ_BLOCK_PC;
-
-	blk_execute_rq_nowait(q, NULL, rq, 0, tgt_sd_end_rq);
-	return 0;
-
- free_request:
-	blk_put_request(rq);
- hw_error:
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-	return -ENOMEM;
-}
-
-static int tgt_sd_execute(struct tgt_cmd *cmd)
-{
-	struct tgt_device *device = cmd->device;
-	loff_t pos = cmd->offset;
-
-	if (cmd->bufflen + pos > device->size) {
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMD_FAILED;
-	}
-	/*
-	 * TODO this will become device->io_handler->queue_cmd
-	 * when we seperate the io_handlers
-	 */
-	return tgt_sd_execute_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
-}
-
-static struct tgt_device_template tgt_sd = {
-	.name = "tgt_sd",
-	.module = THIS_MODULE,
-	.create = tgt_sd_create,
-	.execute_cmd = tgt_sd_execute,
-	.prep_cmd = tgt_sd_prep,
-};
-
-static int __init tgt_sd_init(void)
-{
-	return tgt_device_template_register(&tgt_sd);
-}
-
-static void __exit tgt_sd_exit(void)
-{
-	tgt_device_template_unregister(&tgt_sd);
-}
-
-module_init(tgt_sd_init);
-module_exit(tgt_sd_exit);
-MODULE_LICENSE("GPL");

Deleted: branches/uio-mmap/kernel/tgt_vsd.c
===================================================================
--- branches/uio-mmap/kernel/tgt_vsd.c	2005-12-23 09:35:11 UTC (rev 211)
+++ branches/uio-mmap/kernel/tgt_vsd.c	2005-12-24 04:23:24 UTC (rev 212)
@@ -1,121 +0,0 @@
-/*
- * virtual scsi disk functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <scsi/scsi.h>
-
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_device.h>
-#include <tgt_scsi.h>
-
-static int tgt_vsd_create(struct tgt_device *device)
-{
-	struct inode *inode;
-
-	inode = device->file->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else
-		return -EINVAL;
-
-	device->use_clustering = 1;
-	device->size = inode->i_size;
-	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-}
-
-/*
- * is this device specific or common? Should it be moved to the protocol.
- */
-static void tgt_vsd_prep(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	uint8_t *scb = scmd->scb;
-	uint64_t off = 0;
-
-	/*
-	 * set bufflen and offset
-	 */
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		break;
-	}
-
-	off <<= 9;
-
-	cmd->offset = off;
-}
-
-static void __tgt_vsd_execute(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	int err;
-
-	err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
-	if (err >= 0)
-		return;
-
-	/* TODO if -ENOMEM return QUEUEFULL or BUSY ??? */
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-}
-
-static int tgt_vsd_execute(struct tgt_cmd *cmd)
-{
-	/*
-	 * TODO: this module needs to do async non blocking io or create
-	 * its own threads
-	 */
-	INIT_WORK(&cmd->work, __tgt_vsd_execute, cmd);
-	queue_work(cmd->session->target->twq, &cmd->work);
-	return TGT_CMD_KERN_QUEUED;
-}
-
-static struct tgt_device_template tgt_vsd = {
-	.name = "tgt_vsd",
-	.module = THIS_MODULE,
-	.create = tgt_vsd_create,
-	.execute_cmd = tgt_vsd_execute,
-	.prep_cmd = tgt_vsd_prep,
-};
-
-static int __init tgt_vsd_init(void)
-{
-	return tgt_device_template_register(&tgt_vsd);
-}
-
-static void __exit tgt_vsd_exit(void)
-{
-	tgt_device_template_unregister(&tgt_vsd);
-}
-
-module_init(tgt_vsd_init);
-module_exit(tgt_vsd_exit);
-MODULE_LICENSE("GPL");



From tomo at berlios.de  Thu Dec 29 02:19:57 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 29 Dec 2005 02:19:57 +0100
Subject: [Stgt-svn] r213 - in trunk: . include istgt/usr kernel usr
Message-ID: <200512290119.jBT1JvO9004566@sheep.berlios.de>

Author: tomo
Date: 2005-12-29 02:19:48 +0100 (Thu, 29 Dec 2005)
New Revision: 213

Removed:
   trunk/kernel/tgt_sd.c
   trunk/kernel/tgt_vsd.c
Modified:
   trunk/include/tgt_if.h
   trunk/initd
   trunk/istgt/usr/istgt.c
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sysfs.c
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Merged uio-mmap branch changes r206:212 into the trunk.

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/include/tgt_if.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -22,7 +22,8 @@
 	TGT_KEVENT_RESPONSE,
 	TGT_KEVENT_CMD_REQ,
 	TGT_KEVENT_TARGET_PASSTHRU,
-	TGT_KEVENT_TASK_MGMT
+	TGT_KEVENT_TASK_MGMT,
+	TGT_KEVENT_CMD_DONE,
 };
 
 #define	TGT_INVALID_DEV_ID	~0ULL
@@ -58,6 +59,14 @@
 			uint64_t cid;
 			uint32_t len;
 			int result;
+			/*
+			 * this is screwed for setups with 64 bit kernel
+			 * and 32 bit userspace
+			 */
+			unsigned long uaddr;
+			uint64_t offset;
+			uint8_t rw;
+			uint8_t try_map;
 		} cmd_res;
 		struct {
 			uint64_t rid;
@@ -80,6 +89,8 @@
 			uint64_t dev_id;
 			uint64_t cid;
 			int typeid;
+			int fd;
+			uint32_t data_len;
 		} cmd_req;
 		struct {
 			int tid;
@@ -95,6 +106,13 @@
 			uint64_t dev_id;
 			uint64_t tag;
 		} task_mgmt;
+		struct {
+			int tid;
+			int typeid;
+			unsigned long uaddr;
+			uint32_t len;
+			int mmapped;
+		} cmd_done;
 	} k;
 
 	/*

Modified: trunk/initd
===================================================================
--- trunk/initd	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/initd	2005-12-29 01:19:48 UTC (rev 213)
@@ -15,8 +15,6 @@
 {
 	insmod ${PWD}/kernel/tgt_core.ko
 	insmod ${PWD}/kernel/tgt_scsi.ko
-	insmod ${PWD}/kernel/tgt_vsd.ko
-#	insmod ${PWD}/kernel/tgt_sd.ko
 
 	if [ $TARGET = "istgt" ] ; then
 		modprobe -q crc32c
@@ -44,8 +42,6 @@
 		rmmod ibmvstgt
 	fi
 
-#	rmmod tgt_sd
-	rmmod tgt_vsd
 	rmmod tgt_scsi
 	rmmod tgt_core
 }

Modified: trunk/istgt/usr/istgt.c
===================================================================
--- trunk/istgt/usr/istgt.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/istgt/usr/istgt.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -174,8 +174,6 @@
 	struct pollfd *pfd;
 	int i, res, opt;
 
-	eprintf("%d\n", nr);
-
 	for (i = 0; i < LISTEN_MAX; i++) {
 		if (pfds[POLL_LISTEN + i].revents)
 			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/Makefile	2005-12-29 01:19:48 UTC (rev 213)
@@ -8,8 +8,7 @@
 obj-m		+= tgt_core.o
 tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o
 
-obj-m		+= tgt_vsd.o tgt_scsi.o
-#obj-m		+= tgt_vsd.o tgt_scsi.o tgt_sd.o
+obj-m		+= tgt_scsi.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -26,6 +26,8 @@
 
 MODULE_LICENSE("GPL");
 
+struct task_struct *tgtd_tsk;
+
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
@@ -148,24 +150,13 @@
 {
 	struct tgt_cmd *cmd;
 	struct request *rq;
-	int err;
 
 	while ((rq = elv_next_request(q)) != NULL) {
 		/* we need to set state or refcount under this lock! */
 		cmd = rq->special;
-
 		/*
-		 * the iosched nicely ordered these, should we try to keep the
-		 * ordering or for most cases will it not make a difference
-		 * since the lower levels will iosched again (not for
-		 * passthrough though). Maybe we should use a tgt_device
-		 * flag to indicate what is best for the real device.
-		 */
-		if (atomic_read(&cmd->state) != TGT_CMD_READY)
-			break;
-		/*
 		 * hit queue depth (command completion will run the
-		 * queue again
+		 * queue again)
 		 */
 		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
 			break;
@@ -174,23 +165,14 @@
 
 		dprintk("cmd %p tag %d\n", cmd, rq->tag);
 
-		if (!cmd->device) {
-			struct tgt_target *target = cmd->session->target;
+		/*
+		 * TODO: build a vector of commands and then do the
+	 	 * userspace send call
+		 */
 
-			INIT_WORK(&cmd->work, target->proto->uspace_cmd_execute,
-				  cmd);
-			queue_work(target->twq, &cmd->work);
-			err = TGT_CMD_USPACE_QUEUED;
-		} else
-			err = cmd->device->dt->execute_cmd(cmd);
-	        switch (err) {
-	        case TGT_CMD_FAILED:
-		case TGT_CMD_COMPLETED:
-			dprintk("command completed %d\n", err);
-			tgt_transfer_response(cmd);
-		default:
-			dprintk("command %d queued to real dev\n", rq->tag);
-		}
+		/* what should we do on failure here ? */
+		if (tgt_uspace_cmd_send(cmd, GFP_ATOMIC) < 0)
+			eprintk("command %d failed\n", rq->tag);
 
 		spin_lock_irq(q->queue_lock);
 	}
@@ -423,74 +405,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_session_destroy);
 
-struct device_type_internal {
-	struct tgt_device_template *sdt;
-	struct list_head list;
-};
-
-static struct tgt_device_template *device_template_get(const char *name)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (!strcmp(name, ti->sdt->name)) {
-			if (!try_module_get(ti->sdt->module))
-				ti = NULL;
-			spin_unlock_irqrestore(&device_tmpl_lock, flags);
-			return ti ? ti->sdt : NULL;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void device_template_put(struct tgt_device_template *sdt)
-{
-	module_put(sdt->module);
-}
-
-int tgt_device_template_register(struct tgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-
-	INIT_LIST_HEAD(&ti->list);
-	ti->sdt = sdt;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-	list_add_tail(&ti->list, &device_tmpl_list);
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_device_template_register);
-
-void tgt_device_template_unregister(struct tgt_device_template *sdt)
-{
-	unsigned long flags;
-	struct device_type_internal *ti;
-
-	spin_lock_irqsave(&device_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &device_tmpl_list, list)
-		if (ti->sdt == sdt) {
-			list_del(&ti->list);
-			kfree(ti);
-			break;
-		}
-
-	spin_unlock_irqrestore(&device_tmpl_lock, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_device_template_unregister);
-
 /*
  * TODO: use a hash or any better alg/ds
  */
@@ -585,6 +499,7 @@
 	struct tgt_target *target;
 	struct tgt_device *device;
 	unsigned long flags;
+	struct inode *inode;
 
 	dprintk("tid %d dev_id %" PRIu64 " type %s fd %d\n",
 		tid, dev_id, device_type, fd);
@@ -607,22 +522,18 @@
 		goto free_device;
 	}
 
-	device->dt = device_template_get(device_type);
-	if (!device->dt) {
-		eprintk("Could not get devive type %s\n", device_type);
-		goto put_fd;
-	}
+	/* TODO: kill me */
+	inode = device->file->f_dentry->d_inode;
+	if (S_ISREG(inode->i_mode))
+		;
+	else if (S_ISBLK(inode->i_mode))
+		inode = inode->i_bdev->bd_inode;
 
-	device->dt_data = kzalloc(device->dt->priv_data_size, GFP_KERNEL);
-	if (!device->dt_data)
-		goto put_template;
+	device->use_clustering = 1;
+	device->size = inode->i_size;
 
-	if (device->dt->create)
-		if (device->dt->create(device))
-			goto free_priv_dt_data;
-
 	if (tgt_queue_create(target->proto, TGT_QUEUE_DEPTH, &device->q))
-		goto dt_destroy;
+		goto put_fd;
 	tgt_device_queue_setup(device);
 
 	if (tgt_sysfs_register_device(device))
@@ -636,13 +547,6 @@
 
 queue_destroy:
 	tgt_queue_destroy(device->q);
-dt_destroy:
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-free_priv_dt_data:
-	kfree(device->dt_data);
-put_template:
-	device_template_put(device->dt);
 put_fd:
 	fput(device->file);
 free_device:
@@ -661,14 +565,9 @@
 	list_del(&device->dlist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	if (device->dt->destroy)
-		device->dt->destroy(device);
-
 	tgt_queue_destroy(device->q);
 	fput(device->file);
-	device_template_put(device->dt);
 
-	kfree(device->dt_data);
 	kfree(device);
 }
 
@@ -707,13 +606,20 @@
 	}
 }
 
-static void tgt_free_buffer(struct tgt_cmd *cmd)
+static void tgt_unmap_user_pages(struct tgt_cmd *cmd)
 {
+	struct page *page;
 	int i;
 
-	for (i = 0; i < cmd->sg_count; i++)
-		__free_page(cmd->sg[i].page);
-	kfree(cmd->sg);
+	for (i = 0; i < cmd->sg_count; i++) {
+		page = cmd->pages[i];
+		if(!page)
+			break;
+		if (test_bit(TGT_CMD_RW, &cmd->flags))
+			set_page_dirty_lock(page);
+		page_cache_release(page);
+	}
+	kfree(cmd->pages);
 }
 
 static void __tgt_cmd_destroy(void *data)
@@ -724,6 +630,11 @@
 	unsigned long flags;
 
 	dprintk("tag %d\n", rq->tag);
+
+	tgt_unmap_user_pages(cmd);
+	kfree(cmd->sg);
+	tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
+
 	spin_lock_irqsave(q->queue_lock, flags);
 	if (blk_rq_tagged(rq))
 		blk_queue_end_tag(q, rq);
@@ -742,8 +653,6 @@
 {
 	dprintk("cmd %p\n", cmd);
 
-	tgt_free_buffer(cmd);
-
 	/*
 	 * Goose the queue incase we are blocked on a queue depth
 	 * limit or resource problem.
@@ -761,6 +670,8 @@
 	struct tgt_target *target = cmd->session->target;
 	int err;
 
+	dprintk("cmd %p\n", cmd);
+
 	cmd->done = tgt_cmd_destroy;
 	err = target->tt->transfer_response(cmd);
 	switch (err) {
@@ -778,12 +689,35 @@
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
+static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
+{
+	int write = (cmd->data_dir == DMA_TO_DEVICE);
+	struct request_queue *q;
+	struct request *rq;
+
+	if (cmd->device)
+		q = cmd->device->q;
+	else
+		q = cmd->session->target->q;
+
+	rq = blk_get_request(q, write, gfp_mask);
+	if (!rq)
+		return -ENOMEM;
+
+	cmd->rq = rq;
+	rq->special = cmd;
+	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
+	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 1);
+	return 0;
+}
+
 struct tgt_cmd *
 tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
 	       uint32_t data_len, enum dma_data_direction data_dir,
 	       uint8_t *dev_buf, int dev_buf_size, int flags)
 {
 	struct tgt_cmd *cmd;
+	int err;
 
 	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
 	if (!cmd) {
@@ -802,187 +736,143 @@
 
 	dprintk("%p %p\n", session, cmd);
 
-	tgt_cmd_start(cmd);
+	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
+	if (err) {
+		mempool_free(cmd, cmd->session->cmd_pool);
+		return NULL;
+	}
 
 	return cmd;
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_create);
 
-static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
-{
-	int write = (cmd->data_dir == DMA_TO_DEVICE);
-	struct request_queue *q;
-	struct request *rq;
-
-	if (cmd->device)
-		q = cmd->device->q;
-	else
-		q = cmd->session->target->q;
-
-	rq = blk_get_request(q, write, gfp_mask);
-	if (!rq)
-		return -ENOMEM;
-
-	cmd->rq = rq;
-	rq->special = cmd;
-	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
-	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 0);
-	return 0;
-}
-
-static void set_cmd_ready(struct tgt_cmd *cmd)
-{
-	unsigned long flags;
-	struct request_queue *q = cmd->rq->q;
-
-	/*
-	 * we have a request that is ready for processing so
-	 * plug the queue
-	 */
-	spin_lock_irqsave(q->queue_lock, flags);
-	atomic_set(&cmd->state, TGT_CMD_READY);
-	blk_plug_device(q);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-}
-
 static void tgt_write_data_transfer_done(struct tgt_cmd *cmd)
 {
 	/*
 	 * TODO check for errors and add state checking. we may have
 	 * to internally queue for the target driver
 	 */
-	set_cmd_ready(cmd);
+	tgt_transfer_response(cmd);
 }
 
-#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
-
 /*
- * TODO: this will have to obey at least the target driver's limits,
- * but to support passthrough commands we will need to obey the
- * something like's tgt_sd devices's queue's limits.
+ * we should jsut pass the cmd pointer between userspace and the kernel
+ * as a handle like open-iscsi
  */
-void __tgt_alloc_buffer(struct tgt_cmd *cmd)
+static struct tgt_cmd *find_cmd_by_id(int tid, uint64_t dev_id, uint64_t cid)
 {
-	uint64_t offset = cmd->offset;
-	uint32_t len = cmd->bufflen;
-	int i;
+	struct tgt_target *target;
+	struct tgt_device *device;
+	struct request_queue *q;
+	struct request *rq;
 
-	cmd->sg_count = pgcnt(len, offset);
-	offset &= ~PAGE_CACHE_MASK;
+	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
+		(unsigned long long) cid);
 
-	dprintk("cmd %p tag %d pg_count %d offset %" PRIu64 " len %d\n",
-		cmd, cmd->rq->tag, cmd->sg_count, cmd->offset, cmd->bufflen);
+	target = target_find(tid);
+	if (!target) {
+		eprintk("Could not find target %d\n", tid);
+		return NULL;
+	}
 
-	/*
-	 * TODO: mempool this like in scsi_lib.c
-	 */
-	cmd->sg = kmalloc(cmd->sg_count * sizeof(struct scatterlist),
-			   GFP_KERNEL | __GFP_NOFAIL);
+	if (dev_id == TGT_INVALID_DEV_ID)
+		q = target->q;
+	else {
+		device = tgt_device_find(target, dev_id);
+		if (!device) {
+			eprintk("Could not find device %llu\n",
+				(unsigned long long) dev_id);
+			return NULL;
+		}
+		q = device->q;
+	}
 
-	/*
-	 * TODO need to create reserves
-	 */
-	for (i = 0; i < cmd->sg_count; i++) {
-		struct scatterlist *sg = &cmd->sg[i];
+	rq = blk_queue_find_tag(q, cid);
+	if (rq)
+		return rq->special;
 
-		sg->page = alloc_page(GFP_KERNEL | __GFP_NOFAIL);
-		sg->offset = offset;
-		sg->length = min_t(uint32_t, PAGE_CACHE_SIZE - offset, len);
-
-		offset = 0;
-		len -= sg->length;
-	}
+	eprintk("Could not find rq for cid %llu\n", (unsigned long long) cid);
+	return NULL;
 }
 
-static void tgt_alloc_buffer(void *data)
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
+
+static int tgt_map_user_pages(int rw, struct tgt_cmd *cmd)
 {
-	struct tgt_cmd *cmd = data;
+	int i, err = -EIO, cnt;
+	struct page *page, **pages;
+	uint64_t poffset = cmd->offset & ~PAGE_MASK;
+	uint32_t size, rest = cmd->bufflen;
 
-	__tgt_alloc_buffer(cmd);
-	atomic_set(&cmd->state, TGT_CMD_BUF_ALLOCATED);
+	cnt = pgcnt(cmd->bufflen, cmd->offset);
+	pages = kzalloc(cnt * sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+	cmd->pages = pages;
 
-	/*
-	 * we probably will not be able to rely on the target
-	 * driver knowing the data_dir so this may have to move
-	 * the devices or protocol if it becomes command specific
-	 */
-	if (cmd->data_dir == DMA_TO_DEVICE) {
-		cmd->done = tgt_write_data_transfer_done;
-		/*
-		 * TODO handle errors and possibly requeue for the
-		 * target driver
-		 */
-		cmd->session->target->tt->transfer_write_data(cmd);
-	} else
-		set_cmd_ready(cmd);
-}
+	cmd->sg = kmalloc(cnt * sizeof(struct scatterlist), GFP_KERNEL);
+	if (!cmd->sg)
+		goto release_pages;
+	cmd->sg_count = cnt;
 
-int tgt_cmd_start(struct tgt_cmd *cmd)
-{
-	struct tgt_session *session = cmd->session;
-	int err;
+	dprintk("cmd %p addr %lx cnt %d\n", cmd, cmd->uaddr, cnt);
 
-	if (cmd->device)
-		cmd->device->dt->prep_cmd(cmd);
+	down_read(&tgtd_tsk->mm->mmap_sem);
+	err = get_user_pages(tgtd_tsk, tgtd_tsk->mm, cmd->uaddr, cnt,
+			     rw == WRITE, 0, pages, NULL);
+	up_read(&tgtd_tsk->mm->mmap_sem);
 
-	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
-	if (err)
-		return err;
+	if (err < cnt) {
+		err = -EIO;
+		goto free_sg;
+	}
 
-	if (cmd->bufflen) {
-		atomic_set(&cmd->state, TGT_CMD_STARTED);
-		INIT_WORK(&cmd->work, tgt_alloc_buffer, cmd);
-		queue_work(session->target->twq, &cmd->work);
-	} else
-		set_cmd_ready(cmd);
+	/*
+	 * We have a request_queue and we have a the SGIO scatterlist stuff in
+	 * scsi-misc so we can use those functions to make us a request with
+	 * a proper scatterlist by using block layer funciotns ?????
+	 *
+	 * do a:
+	 * scsi_req_map_sg(cmd->rq, tmp_sg, cnt, orig_size, GFP_KERNEL);
+	 * blk_rq_map_sg(cmd->device->q or cmd->target->q, cmd->rq, cmd->sg);
+	 */
+	for (i = 0; i < cnt; i++) {
+		size = min_t(uint32_t, rest, PAGE_SIZE - poffset);
 
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_start);
+		cmd->sg[i].page = pages[i];
+		cmd->sg[i].offset = poffset;
+		cmd->sg[i].length = size;
 
-static struct tgt_cmd *find_cmd_by_id(struct request_queue *q, uint64_t cid)
-{
+		poffset = 0;
+		rest -= size;
+	}
 
-	struct request *rq;
+	return 0;
 
-	rq = blk_queue_find_tag(q, cid);
-	if (rq)
-		return rq->special;
-	return NULL;
+free_sg:
+	kfree(cmd->sg);
+release_pages:
+	for (i = 0; i < cnt; i++) {
+		page = pages[i];
+		if(!page)
+			break;
+		if (!err && rw == WRITE)
+			set_page_dirty_lock(page);
+		page_cache_release(page);
+	}
+	kfree(pages);
+
+	return err;
 }
 
-int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-		    int result, uint32_t len)
+int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
+		    int result, uint32_t len, uint64_t offset,
+		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
 {
 	struct tgt_target *target;
-	struct tgt_device *device;
 	struct tgt_cmd *cmd;
-	struct request_queue *q;
-	char *p = data;
-	int i;
 
-	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
-		(unsigned long long) cid);
-
-	target = target_find(tid);
-	if (!target) {
-		eprintk("Could not find target %d\n", tid);
-		return -EINVAL;
-	}
-
-	if (dev_id == TGT_INVALID_DEV_ID)
-		q = target->q;
-	else {
-		device = tgt_device_find(target, dev_id);
-		if (!device) {
-			eprintk("Could not find device %llu\n",
-				(unsigned long long) dev_id);
-			return -EINVAL;
-		}
-		q = device->q;
-	}
-
-	cmd = find_cmd_by_id(q, cid);
+	cmd = find_cmd_by_id(tid, dev_id, cid);
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);
@@ -992,34 +882,34 @@
 	dprintk("cmd %p tag %d result %d len %d bufflen %u\n",
 		cmd, cmd->rq->tag, result, len, cmd->bufflen);
 
-	if (len) {
-		/*
-		 * yuck TODO fix.
-		 * This will happen if we thought we were going to do some
-		 * IO but we ended up just gettting some sense back
-		 */
-		if (len != cmd->bufflen) {
-			tgt_free_buffer(cmd);
+	cmd->uaddr = uaddr;
+	cmd->result = result;
+	cmd->offset = offset;
+	if (len)
+		cmd->bufflen = len;
+	if (rw == WRITE)
+		__set_bit(TGT_CMD_RW, &cmd->flags);
+	if (try_map)
+		__set_bit(TGT_CMD_MAPPED, &cmd->flags);
 
-			cmd->bufflen = len;
-			cmd->offset = 0;
+	target = cmd->session->target;
+/* 	target->proto->uspace_cmd_complete(cmd); */
 
-			__tgt_alloc_buffer(cmd);
+	if (cmd->bufflen) {
+		if (tgt_map_user_pages(rw, cmd))
+			return -EIO;
+		if (cmd->data_dir == DMA_TO_DEVICE) {
+			cmd->done = tgt_write_data_transfer_done;
+			/*
+			 * TODO handle errors and possibly requeue for the
+			 * target driver
+			 */
+			target->tt->transfer_write_data(cmd);
+			return 0;
 		}
-
-		for (i = 0; i < cmd->sg_count; i++) {
-			uint32_t copy = min_t(uint32_t, len, PAGE_CACHE_SIZE);
-
-			memcpy(page_address(cmd->sg[i].page), p, copy);
-			p += copy;
-			len -= copy;
-		}
 	}
 
-	cmd->result = result;
-	target->proto->uspace_cmd_complete(cmd);
 	tgt_transfer_response(cmd);
-
 	return 0;
 }
 

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -48,6 +48,11 @@
 	TGT_CMD_DONE,
 };
 
+enum {
+	TGT_CMD_MAPPED,
+	TGT_CMD_RW,		/* not set == read, set == write */
+};
+
 struct tgt_cmd {
 	struct tgt_session *session;
 	struct tgt_device *device;
@@ -55,6 +60,7 @@
 
 	atomic_t state;
 	uint64_t dev_id;
+	unsigned long flags;
 
 	struct work_struct work;
 	void (*done) (struct tgt_cmd *);
@@ -62,10 +68,13 @@
 	enum dma_data_direction data_dir;
 	int sg_count;
 	struct scatterlist *sg;
+	struct page **pages;
 	uint32_t bufflen;
 	uint64_t offset;
 	int result;
 
+	unsigned long uaddr;
+
 	struct request *rq;
 	/*
 	 * target driver private
@@ -89,13 +98,13 @@
 tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
 	       uint32_t data_len, enum dma_data_direction data_dir,
 	       uint8_t *dev_buf, int dev_buf_size, int flags);
-extern int tgt_cmd_start(struct tgt_cmd *cmd);
 extern void tgt_transfer_response(void *cmd);
 extern int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
 			      int func, uint64_t dev_id, uint64_t tag,
 			      gfp_t gfp_mask);
+extern int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags);
 
-#define DEBUG_TGT
+#define DEBUG_TGT 1
 
 #define eprintk(fmt, args...)					\
 do {								\

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_device.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -29,43 +29,11 @@
 	TGT_DEV_DEL = 0,
 };
 
-struct tgt_device_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	/*
-	 * setup and destroy private structures
-	 */
-	int (* create)(struct tgt_device *);
-	void (* destroy)(struct tgt_device *);
-	/*
-	 * queue or execute command. Return TGT_CMD*.
-	 * If returning TGT_CMD_COMPLETED or TGT_CMD_FAILED the result
-	 * field must be set.
-	 */
-	int (* execute_cmd)(struct tgt_cmd *cmd);
-	/*
-	 * complete a kernel command if your queue_command was async
-	 * and the device used one of the tgt threads to process the
-	 * command
-	 */
-	void (* complete_kern_cmd)(struct tgt_cmd *cmd);
-	/*
-	 * setup buffer or device fields if needed
-	 */
-	void (* prep_cmd)(struct tgt_cmd *cmd);
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **device_attrs;
-};
-
+/*
+ * TODO: we could do a queue per target instead of per device and kill
+ * all the tgt_device code
+ */
 struct tgt_device {
-	struct tgt_device_template *dt;
-	void *dt_data;
-
 	struct class_device cdev;
 
 	int fd;
@@ -100,7 +68,5 @@
 
 extern int tgt_sysfs_register_device(struct tgt_device *device);
 extern void tgt_sysfs_unregister_device(struct tgt_device *device);
-extern int tgt_device_template_register(struct tgt_device_template *dt);
-extern void tgt_device_template_unregister(struct tgt_device_template *dt);
 
 #endif

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_nl.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -44,6 +44,8 @@
 	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
 	ev->k.cmd_req.cid = cmd->rq->tag;
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
+	ev->k.cmd_req.fd = cmd->device ? cmd->device->fd : 0;
+	ev->k.cmd_req.data_len = cmd->bufflen;
 
 	proto->uspace_pdu_build(cmd, pdu);
 
@@ -88,6 +90,22 @@
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
+int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.cmd_done.tid = cmd->session->target->tid;
+	ev.k.cmd_done.typeid = cmd->session->target->typeid;
+	ev.k.cmd_done.uaddr = cmd->uaddr;
+	ev.k.cmd_done.len = cmd->bufflen;
+	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
+		ev.k.cmd_done.mmapped = 1;
+
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, flags);
+}
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
+
 int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
 		       int func, uint64_t dev_id, uint64_t tag, gfp_t flags)
 {
@@ -121,6 +139,7 @@
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
 		tgtd_pid  = NETLINK_CREDS(skb)->pid;
+		tgtd_tsk = current;
 		eprintk("start target drivers\n");
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
@@ -163,8 +182,11 @@
 		break;
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
-				      ev->u.cmd_res.cid, ev->data,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len);
+				      ev->u.cmd_res.cid,
+				      ev->u.cmd_res.result, ev->u.cmd_res.len,
+				      ev->u.cmd_res.offset,
+				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
+				      ev->u.cmd_res.try_map);
 		break;
 	case TGT_UEVENT_TASK_MGMT:
 		err = tgt_task_mgmt(ev->u.task_mgmt.rid, ev->u.task_mgmt.func,

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_priv.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -8,11 +8,15 @@
 extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags);
 extern int tgt_device_destroy(int tid, uint64_t dev_id);
-extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid, void *data,
-			   int result, uint32_t len);
+extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
+			   int result, uint32_t len, uint64_t offset,
+			   unsigned long addr,
+			   uint8_t rw, uint8_t try_map);
 extern int tgt_task_mgmt(uint64_t fid, int func, int tid, uint64_t sid,
 			 uint64_t lun, uint64_t tag, int res);
 
+extern struct task_struct *tgtd_tsk;
+
 /* netlink */
 extern void tgt_nl_exit(void);
 extern int tgt_nl_init(void);

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_protocol.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -45,7 +45,6 @@
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
-	void (* uspace_cmd_execute)(void *cmd);
 };
 
 extern void tgt_protocol_init(void);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_scsi.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -108,19 +108,6 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
 
-static void scsi_tgt_uspace_cmd_exec(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	int err;
-
-	err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
-	if (err >= 0)
-		return;
-
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-	tgt_transfer_response(cmd);
-}
-
 static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
 {
 	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
@@ -129,9 +116,14 @@
 
 static void scsi_tgt_uspace_cmd_complete(struct tgt_cmd *cmd)
 {
-	/* userspace did everything for us just copy the buffer */
+	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+
+	dprintk("%d %lu\n", cmd->result, cmd->uaddr);
+
 	if (cmd->result != SAM_STAT_GOOD)
 		scsi_tgt_sense_copy(cmd);
+
+	dprintk("res %d, cmd %p op 0x%02x\n", cmd->result, cmd, scmd->scb[0]);
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
@@ -139,7 +131,6 @@
 	.module = THIS_MODULE,
 	.cmd_create = scsi_tgt_cmd_create,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
-	.uspace_cmd_execute = scsi_tgt_uspace_cmd_exec,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
 	.uspace_pdu_size = MAX_COMMAND_SIZE,
 };

Deleted: trunk/kernel/tgt_sd.c
===================================================================
--- trunk/kernel/tgt_sd.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_sd.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -1,187 +0,0 @@
-/*
- * scsi disk functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <scsi/scsi.h>
-
-#include <tgt.h>
-#include <tgt_device.h>
-#include <tgt_scsi.h>
-
-/*
- * TODO set per device segment, max_sectors, etc limits
- */
-static int tgt_sd_create(struct tgt_device *device)
-{
-	struct file *file = device->file;
-	struct io_restrictions *limits = &device->limits;
-	struct request_queue *q;
-	struct inode *inode;
-
-	q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
-	limits->max_sectors = q->max_hw_sectors;
-	limits->max_phys_segments = q->max_phys_segments;
-	limits->max_hw_segments = q->max_hw_segments;
-	limits->hardsect_size = q->hardsect_size;
-	limits->max_segment_size = q->max_segment_size;
-	limits->seg_boundary_mask = q->seg_boundary_mask;
-	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
-		device->use_clustering = 1;
-	else
-		device->use_clustering = 0;
-
-	inode = file->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else
-		/*
-		 * can we handle scsi tape too actually?
-		 */
-		return -EINVAL;
-
-	device->size = inode->i_size;
-	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-}
-
-static void tgt_sd_prep(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	uint8_t *scb = scmd->scb;
-	uint64_t off = 0;
-
-	/*
-	 * set offset
-	 */
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		break;
-	}
-
-	off <<= 9;
-
-	cmd->offset = off;
-}
-
-static void tgt_sd_end_rq(struct request *rq)
-{
-	struct tgt_cmd *cmd = rq->end_io_data;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	if (rq->sense_len) {
-		memcpy(scmd->sense_buff, rq->sense, SCSI_SENSE_BUFFERSIZE);
-		cmd->result = SAM_STAT_CHECK_CONDITION;
-	} else if (rq->errors) {
-		/*
-		 * TODO check *_byte and just send error upwards
-		 */
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		cmd->result = SAM_STAT_CHECK_CONDITION;
-	} else
-		cmd->result = SAM_STAT_GOOD;
-
-	tgt_transfer_response(cmd);
-	__blk_put_request(rq->q, rq);
-}
-
-/*
- * TODO part of this will move to a io_handler callout
- */
-static int tgt_sd_execute_rq(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	struct file *file = cmd->device->file;
-	request_queue_t *q = bdev_get_queue(file->f_dentry->d_inode->i_bdev);
-	struct request *rq;
-	int write = (cmd->data_dir == DMA_TO_DEVICE);
-
-	rq = blk_get_request(q, write, GFP_KERNEL | __GFP_NOFAIL);
-	if (!rq)
-		goto hw_error;
-
-/*	if (req_map_sg(q, rq, cmd->sg, cmd->sg_count,
-			GFP_KERNEL | __GFP_NOFAIL))
-		goto free_request;
-*/
-	rq->cmd_len = COMMAND_SIZE(scmd->scb[0]);
-	memcpy(rq->cmd, scmd->scb, rq->cmd_len);
-	rq->sense_len = 0;
-	rq->sense = scmd->sense_buff;
-	rq->end_io_data = cmd;
-	rq->timeout = 60 * HZ; /* TODO */
-	rq->flags |= REQ_BLOCK_PC;
-
-	blk_execute_rq_nowait(q, NULL, rq, 0, tgt_sd_end_rq);
-	return 0;
-
- free_request:
-	blk_put_request(rq);
- hw_error:
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-	return -ENOMEM;
-}
-
-static int tgt_sd_execute(struct tgt_cmd *cmd)
-{
-	struct tgt_device *device = cmd->device;
-	loff_t pos = cmd->offset;
-
-	if (cmd->bufflen + pos > device->size) {
-		scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-		return TGT_CMD_FAILED;
-	}
-	/*
-	 * TODO this will become device->io_handler->queue_cmd
-	 * when we seperate the io_handlers
-	 */
-	return tgt_sd_execute_rq(cmd) ? TGT_CMD_FAILED : TGT_CMD_KERN_QUEUED;
-}
-
-static struct tgt_device_template tgt_sd = {
-	.name = "tgt_sd",
-	.module = THIS_MODULE,
-	.create = tgt_sd_create,
-	.execute_cmd = tgt_sd_execute,
-	.prep_cmd = tgt_sd_prep,
-};
-
-static int __init tgt_sd_init(void)
-{
-	return tgt_device_template_register(&tgt_sd);
-}
-
-static void __exit tgt_sd_exit(void)
-{
-	tgt_device_template_unregister(&tgt_sd);
-}
-
-module_init(tgt_sd_init);
-module_exit(tgt_sd_exit);
-MODULE_LICENSE("GPL");

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_sysfs.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -257,24 +257,11 @@
 	if (!class_device_get(&target->cdev))
 		return -EINVAL;
 
-	if (device->dt->device_attrs) {
-		for (i = 0; device->dt->device_attrs[i]; i++) {
-			err = class_attr_add(&device->cdev,
-					     tgt_target_attrs,
-					     device->dt->device_attrs[i]);
-                        if (err)
-                                goto cleanup;
-		}
-	}
-
 	for (i = 0; tgt_device_attrs[i]; i++) {
-		if (!class_attr_overridden(device->dt->device_attrs,
-					   tgt_device_attrs[i])) {
-			err = class_device_create_file(&device->cdev,
-						       tgt_device_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
+		err = class_device_create_file(&device->cdev,
+					       tgt_device_attrs[i]);
+		if (err)
+			goto cleanup;
 	}
 
 	return 0;

Deleted: trunk/kernel/tgt_vsd.c
===================================================================
--- trunk/kernel/tgt_vsd.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/kernel/tgt_vsd.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -1,206 +0,0 @@
-/*
- * virtual scsi disk functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/types.h>
-#include <linux/blkdev.h>
-#include <linux/uio.h>
-#include <linux/fs.h>
-#include <linux/file.h>
-#include <linux/writeback.h>
-
-#include <scsi/scsi.h>
-
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_device.h>
-#include <tgt_scsi.h>
-
-static int tgt_vsd_create(struct tgt_device *device)
-{
-	struct inode *inode;
-
-	inode = device->file->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-	else
-		return -EINVAL;
-
-	device->use_clustering = 1;
-	device->size = inode->i_size;
-	dprintk("%d %llu\n", device->fd, inode->i_size >> 9);
-
-	return 0;
-}
-
-/*
- * is this device specific or common? Should it be moved to the protocol.
- */
-static void tgt_vsd_prep(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	uint8_t *scb = scmd->scb;
-	uint64_t off = 0;
-
-	/*
-	 * set bufflen and offset
-	 */
-	switch (scb[0]) {
-	case READ_6:
-	case WRITE_6:
-		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
-		break;
-	case READ_10:
-	case WRITE_10:
-	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
-		break;
-	case READ_16:
-	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
-		break;
-	default:
-		break;
-	}
-
-	off <<= 9;
-
-	cmd->offset = off;
-}
-
-/*
- * TODO: We need to redo our scatter lists so they take into account
- * this common usage, but also not violate HW limits
- */
-static struct iovec* sg_to_iovec(struct scatterlist *sg, int sg_count)
-{
-	struct iovec* iov;
-	int i;
-
-	iov = kmalloc(sizeof(struct iovec) * sg_count, GFP_KERNEL);
-	if (!iov)
-		return NULL;
-
-	for (i = 0; i < sg_count; i++) {
-		iov[i].iov_base = page_address(sg[i].page) + sg[i].offset;
-		iov[i].iov_len = sg[i].length;
-	}
-
-	return iov;
-}
-
-/*
- * TODO this will move to a io_handler callout
- */
-static int vsd_execute_file_io(struct tgt_cmd *cmd, int op)
-{
-	struct file *file = cmd->device->file;
-	ssize_t ret;
-	struct iovec *iov;
-	loff_t pos = cmd->offset;
-
-	iov = sg_to_iovec(cmd->sg, cmd->sg_count);
-	if (!iov)
-		return -ENOMEM;
-
-	if (op == READ)
-		ret = generic_file_readv(file, iov, cmd->sg_count, &pos);
-	else
-		ret = generic_file_writev(file, iov, cmd->sg_count, &pos);
-
-	kfree(iov);
-
-	if (ret < 0 || ret != cmd->bufflen) {
-		eprintk("I/O error %d %Zd %u %lld %" PRIu64 "\n",
-			op, ret, cmd->bufflen, pos, cmd->device->size);
-		return -EINVAL;
-	}
-
-	/* sync_page_range(inode, inode->i_mapping, pos, (size_t) cmd->bufflen); */
-	return 0;
-}
-
-static void __tgt_vsd_execute(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	int err, rw;
-
-	switch (scmd->scb[0]) {
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		rw = READ;
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		rw = WRITE;
-		break;
-	default:
-		err = tgt_uspace_cmd_send(cmd, GFP_KERNEL);
-		/*
-		 * successfully queued
-		 */
-		if (err >= 0)
-			return;
-
-		goto failed;
-	};
-
-	err = vsd_execute_file_io(cmd, rw);
-	if (!err) {
-		cmd->result = SAM_STAT_GOOD;
-		goto done;
-	}
-
-	/*
-	 * we should do a switch but I am not sure of all the err values
-	 * returned. If you find one add it
-	 */
-failed:
-	/* TODO if -ENOMEM return QUEUEFULL or BUSY ??? */
-	scsi_tgt_sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
-done:
-	tgt_transfer_response(cmd);
-}
-
-static int tgt_vsd_execute(struct tgt_cmd *cmd)
-{
-	/*
-	 * TODO: this module needs to do async non blocking io or create
-	 * its own threads
-	 */
-	INIT_WORK(&cmd->work, __tgt_vsd_execute, cmd);
-	queue_work(cmd->session->target->twq, &cmd->work);
-	return TGT_CMD_KERN_QUEUED;
-}
-
-static struct tgt_device_template tgt_vsd = {
-	.name = "tgt_vsd",
-	.module = THIS_MODULE,
-	.create = tgt_vsd_create,
-	.execute_cmd = tgt_vsd_execute,
-	.prep_cmd = tgt_vsd_prep,
-};
-
-static int __init tgt_vsd_init(void)
-{
-	return tgt_device_template_register(&tgt_vsd);
-}
-
-static void __exit tgt_vsd_exit(void)
-{
-	tgt_device_template_unregister(&tgt_vsd);
-}
-
-module_init(tgt_vsd_init);
-module_exit(tgt_vsd_exit);
-MODULE_LICENSE("GPL");

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/usr/dl.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -178,3 +178,11 @@
 
 	return NULL;
 }
+
+void *dl_cmd_done_fn(int typeid)
+{
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, "cmd_done");
+
+	return NULL;
+}

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/usr/dl.h	2005-12-29 01:19:48 UTC (rev 213)
@@ -13,6 +13,7 @@
 extern void *dl_event_fn(int tid, int typeid);
 extern void *dl_proto_cmd_process(int tid, int typeid);
 extern void *dl_task_mgmt_fn(int typeid);
+extern void *dl_cmd_done_fn(int typeid);
 
 extern char *typeid_to_name(int typeid);
 

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/usr/netlink.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -112,9 +112,11 @@
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t cid = ev_req->k.cmd_req.cid;
-	uint8_t *scb;
-	int (*fn) (int, uint64_t, uint8_t *, uint8_t *, int *);
+	uint64_t offset, cid = ev_req->k.cmd_req.cid;
+	uint8_t *scb, rw = 0, try_map = 0;
+	unsigned long uaddr;
+	int (*fn) (int, uint64_t, uint8_t *, int *, int, uint32_t,
+		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
 	scb = (uint8_t *) ev_req->data;
@@ -125,8 +127,12 @@
 
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
-			    ev_req->k.cmd_req.dev_id, scb,
-			    (uint8_t *) ev_res->data, &len);
+			    ev_req->k.cmd_req.dev_id,
+			    scb,
+			    &len,
+			    ev_req->k.cmd_req.fd,
+			    ev_req->k.cmd_req.data_len,
+			    &uaddr, &rw, &try_map, &offset);
 	else {
 		result = -EINVAL;
 		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
@@ -139,11 +145,15 @@
 	ev_res->u.cmd_res.cid = cid;
 	ev_res->u.cmd_res.len = len;
 	ev_res->u.cmd_res.result = result;
+	ev_res->u.cmd_res.uaddr = uaddr;
+	ev_res->u.cmd_res.rw = rw;
+	ev_res->u.cmd_res.try_map = try_map;
+	ev_res->u.cmd_res.offset = offset;
 
-	log_error("scsi_cmd_process res %d len %d\n", result, len);
+	log_debug("scsi_cmd_process res %d len %d\n", result, len);
 
 	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res) + len));
+			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
 static void nl_task_mgmt(struct tgt_event *ev)
@@ -188,6 +198,14 @@
 	case TGT_KEVENT_TASK_MGMT:
 		nl_task_mgmt(ev);
 		break;
+	case TGT_KEVENT_CMD_DONE:
+		fn = dl_cmd_done_fn(ev->k.cmd_done.typeid);
+		if (fn)
+			fn(NLMSG_DATA(recvbuf));
+		else
+			eprintf("Cannot handle cmd done %d\n",
+				ev->k.cmd_done.tid);
+		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-12-24 04:23:24 UTC (rev 212)
+++ trunk/usr/scsi.c	2005-12-29 01:19:48 UTC (rev 213)
@@ -26,9 +26,12 @@
 #include <scsi/srp.h>
 #include <scsi/iscsi_proto.h>
 #include <asm/byteorder.h>
+#include <asm/page.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/types.h>
 #include <fcntl.h>
-#include <sys/socket.h>
 #include <linux/netlink.h>
 
 #include "tgtd.h"
@@ -39,7 +42,11 @@
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
 #define cpu_to_be64 __cpu_to_be64
+#define be64_to_cpu __be64_to_cpu
 
+#define READ 0
+#define WRITE 1
+
 #ifndef REPORT_LUNS
 #define REPORT_LUNS           0xa0
 #endif
@@ -501,13 +508,82 @@
 	return SAM_STAT_GOOD;
 }
 
-int cmd_process(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len,
-		uint32_t flags)
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+
+static int mmap_device(int tid, uint64_t lun, uint8_t *scb,
+		       int *len, int fd, uint32_t datalen, unsigned long *uaddr,
+		       uint64_t *offset)
 {
+	void *p;
+	uint64_t off;
+	*len = 0;
+
+	switch (scb[0]) {
+	case READ_6:
+	case WRITE_6:
+		off = ((scb[1] & 0x1f) << 16) + (scb[2] << 8) + scb[3];
+		break;
+	case READ_10:
+	case WRITE_10:
+	case WRITE_VERIFY:
+		off = be32_to_cpu(*(uint32_t *) &scb[2]);
+		break;
+	case READ_16:
+	case WRITE_16:
+		off = be64_to_cpu(*(uint64_t *) &scb[2]);
+		break;
+	default:
+		off = 0;
+		break;
+	}
+
+	off <<= 9;
+
+	p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
+
+	*uaddr = (unsigned long) p;
+	*offset = off;
+	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
+
+	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
+}
+
+static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
+{
+	int result = 1;
+
+	switch (scb[0]) {
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		*rw = READ;
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+		*rw = WRITE;
+		break;
+	default:
+		result = 0;
+	}
+	return result;
+}
+
+int cmd_process(int tid, uint64_t lun, uint8_t *scb, int *len,
+		int fd, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+		uint8_t *try_map, uint64_t *offset)
+{
 	int result = SAM_STAT_GOOD;
+	uint8_t *data = NULL;
 
-	dprintf("%d %" PRIu64 " %x %x\n", tid, lun, scb[0], flags);
+	dprintf("%d %" PRIu64 " %x %d %u\n", tid, lun, scb[0], fd, datalen);
 
+	*offset = 0;
+	if (!mmap_cmd_init(scb, rw))
+		data = valloc(PAGE_SIZE);
+
 	if (lun == TGT_INVALID_DEV_ID)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
@@ -515,6 +591,9 @@
 		case REPORT_LUNS:
 			break;
 		default:
+			*offset = 0;
+			if (!data)
+				data = valloc(PAGE_SIZE);
 			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 						0x25, 0);
 			result = SAM_STAT_CHECK_CONDITION;
@@ -550,9 +629,22 @@
 		break;
 	case READ_6:
 	case READ_10:
+	case READ_16:
 	case WRITE_6:
 	case WRITE_10:
+	case WRITE_16:
 	case WRITE_VERIFY:
+		result = mmap_device(tid, lun, scb, len, fd, datalen, uaddr, offset);
+		if (result == SAM_STAT_GOOD)
+			*try_map = 1;
+		else {
+			*offset = 0;
+			if (!data)
+				data = valloc(PAGE_SIZE);
+			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
+						0x25, 0);
+		}
+		break;
 	case RESERVE:
 	case RELEASE:
 	case RESERVE_10:
@@ -564,6 +656,9 @@
 	}
 
 out:
+	if (data)
+		*uaddr = (unsigned long) data;
+
 	return result;
 }
 
@@ -717,3 +812,18 @@
 			    ev->k.task_mgmt.sid, ev->k.task_mgmt.dev_id,
 			    ev->k.task_mgmt.tag);
 }
+
+int cmd_done(struct tgt_event *ev)
+{
+	int err = 0;
+
+	if (ev->k.cmd_done.mmapped)
+		err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
+	else
+		free((void *) ev->k.cmd_done.uaddr);
+
+	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
+		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+
+	return err;
+}



From tomo at berlios.de  Thu Dec 29 02:27:23 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 29 Dec 2005 02:27:23 +0100
Subject: [Stgt-svn] r214 - in trunk: include istgt/kernel kernel usr
Message-ID: <200512290127.jBT1RNin006565@sheep.berlios.de>

Author: tomo
Date: 2005-12-29 02:27:05 +0100 (Thu, 29 Dec 2005)
New Revision: 214

Modified:
   trunk/include/tgt_if.h
   trunk/istgt/kernel/iscsi.c
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Remove mgmt code.

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/include/tgt_if.h	2005-12-29 01:27:05 UTC (rev 214)
@@ -16,13 +16,11 @@
 	TGT_UEVENT_DEVICE_CREATE,
 	TGT_UEVENT_DEVICE_DESTROY,
 	TGT_UEVENT_CMD_RES,
-	TGT_UEVENT_TASK_MGMT,
 
 	/* kernel -> user */
 	TGT_KEVENT_RESPONSE,
 	TGT_KEVENT_CMD_REQ,
 	TGT_KEVENT_TARGET_PASSTHRU,
-	TGT_KEVENT_TASK_MGMT,
 	TGT_KEVENT_CMD_DONE,
 };
 
@@ -68,15 +66,6 @@
 			uint8_t rw;
 			uint8_t try_map;
 		} cmd_res;
-		struct {
-			uint64_t rid;
-			int func;
-			int tid;
-			uint64_t sid;
-			uint64_t dev_id;
-			uint64_t tag;
-			int result;
-		} task_mgmt;
 	} u;
 
 	/* kernel -> user */
@@ -98,17 +87,8 @@
 			int typeid;
 		} tgt_passthru;
 		struct {
-			uint64_t rid;
-			int func;
 			int tid;
 			int typeid;
-			uint64_t sid;
-			uint64_t dev_id;
-			uint64_t tag;
-		} task_mgmt;
-		struct {
-			int tid;
-			int typeid;
 			unsigned long uaddr;
 			uint32_t len;
 			int mmapped;

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/istgt/kernel/iscsi.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -1149,14 +1149,15 @@
 /* 	} */
 /* } */
 
-static void istgt_task_mgmt_done(uint64_t rid, int err)
+static void execute_task_management(struct istgt_cmd *req)
 {
+/* 	struct iscsi_conn *conn = req->conn; */
+/* 	struct iscsi_target *target = conn->session->target; */
 	struct istgt_cmd *rsp;
-	struct iscsi_tm_rsp *rsp_hdr;
-	struct istgt_cmd *req = (void*)(unsigned long) rid;
 	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
+	int function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
 
-	eprintk("%llu %d\n", (unsigned long long) rid, err);
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 	rsp_hdr = (struct iscsi_tm_rsp *)&rsp->pdu.bhs;
 
@@ -1166,20 +1167,8 @@
 /* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
 	rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
 
-	iscsi_cmnd_init_write(rsp);
-}
+	eprintk("%x %d %x\n", cmd_itt(req), function, req_hdr->rtt);
 
-static void execute_task_management(struct istgt_cmd *req)
-{
-	struct iscsi_conn *conn = req->conn;
-	struct iscsi_target *target = conn->session->target;
-	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
-	int func = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
-
-	eprintk("%p %x %d %x\n", req, cmd_itt(req), func, req_hdr->rtt);
-	tgt_task_mgmt_send(target->tt, (uint64_t) (unsigned long) req,
-			   func, 0, 0, GFP_KERNEL);
-
 /* 	switch (function) { */
 /* 	case ISCSI_FUNCTION_ABORT_TASK: */
 /* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
@@ -1224,6 +1213,7 @@
 /* 		break; */
 /* 	} */
 /* out: */
+	iscsi_cmnd_init_write(rsp);
 }
 
 static void noop_out_exec(struct istgt_cmd *req)
@@ -1706,7 +1696,6 @@
 	.msg_recv = iet_msg_recv,
 	.transfer_response = scsi_cmnd_done,
 	.transfer_write_data = buffer_ready,
-	.task_mgmt_done = istgt_task_mgmt_done,
 	.priv_data_size = sizeof(struct iscsi_target),
 };
 

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/kernel/tgt.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -913,50 +913,6 @@
 	return 0;
 }
 
-/* Should we create proto->task_mgmt ? */
-
-struct tgt_task_mgmt_info {
-	struct tgt_target *target;
-	struct work_struct work;
-	uint64_t rid;
-	int res;
-};
-
-static void tgt_task_mgmt_done(void *data)
-{
-	struct tgt_task_mgmt_info *mi = (struct tgt_task_mgmt_info *) data;
-	struct tgt_target *target = mi->target;
-
-	target->tt->task_mgmt_done(mi->rid, mi->res);
-	kfree(mi);
-}
-
-int tgt_task_mgmt(uint64_t rid, int func, int tid, uint64_t sid,
-		  uint64_t dev_id, uint64_t tag, int res)
-{
-	int err = 0;
-	struct tgt_target *target = target_find(tid);
-	struct tgt_task_mgmt_info *mi;
-
-	dprintk("%llu %d %d %llu %llu %llu %d\n",
-		rid, func, tid, sid, dev_id, tag, res);
-
-	if (target && target->tt->task_mgmt_done) {
-		mi = kzalloc(sizeof(*mi), GFP_KERNEL);
-		if (!mi)
-			return -ENOMEM;
-
-		mi->target = target;
-		mi->rid = rid;
-		mi->res = res;
-		INIT_WORK(&mi->work, tgt_task_mgmt_done, mi);
-		queue_work(target->twq, &mi->work);
-	} else
-		err = -EINVAL;
-
-	return err;
-}
-
 static void __exit tgt_exit(void)
 {
 	tgt_nl_exit();

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/kernel/tgt.h	2005-12-29 01:27:05 UTC (rev 214)
@@ -99,9 +99,6 @@
 	       uint32_t data_len, enum dma_data_direction data_dir,
 	       uint8_t *dev_buf, int dev_buf_size, int flags);
 extern void tgt_transfer_response(void *cmd);
-extern int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
-			      int func, uint64_t dev_id, uint64_t tag,
-			      gfp_t gfp_mask);
 extern int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags);
 
 #define DEBUG_TGT 1

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/kernel/tgt_nl.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -106,27 +106,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
 
-int tgt_task_mgmt_send(struct tgt_target *target, uint64_t rid,
-		       int func, uint64_t dev_id, uint64_t tag, gfp_t flags)
-{
-	struct tgt_event ev;
-
-	memset(&ev, 0, sizeof(ev));
-
-	dprintk("%llu %d %llu %llu\n", rid, func, dev_id, tag);
-
-	ev.k.task_mgmt.rid = rid;
-	ev.k.task_mgmt.func = func;
-	ev.k.task_mgmt.tid = target->tid;
-	ev.k.task_mgmt.typeid = target->typeid;
-/* 	ev.k.task_mgmt.sid = (uint64_t) session; */
-	ev.k.task_mgmt.dev_id = dev_id;
-	ev.k.task_mgmt.tag = tag;
-
-	return send_event_res(TGT_KEVENT_TASK_MGMT, &ev, NULL, 0, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_task_mgmt_send);
-
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;
@@ -188,13 +167,6 @@
 				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
 				      ev->u.cmd_res.try_map);
 		break;
-	case TGT_UEVENT_TASK_MGMT:
-		err = tgt_task_mgmt(ev->u.task_mgmt.rid, ev->u.task_mgmt.func,
-				    ev->u.task_mgmt.tid, ev->u.task_mgmt.sid,
-				    ev->u.task_mgmt.dev_id,
-				    ev->u.task_mgmt.tag,
-				    ev->u.task_mgmt.result);
-		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);
 		err = -EINVAL;

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/kernel/tgt_priv.h	2005-12-29 01:27:05 UTC (rev 214)
@@ -12,9 +12,6 @@
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,
 			   uint8_t rw, uint8_t try_map);
-extern int tgt_task_mgmt(uint64_t fid, int func, int tid, uint64_t sid,
-			 uint64_t lun, uint64_t tag, int res);
-
 extern struct task_struct *tgtd_tsk;
 
 /* netlink */

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/usr/dl.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -171,14 +171,6 @@
 	return NULL;
 }
 
-void *dl_task_mgmt_fn(int typeid)
-{
-	if (dinfo[typeid].pdl)
-		return dlsym(dinfo[typeid].pdl, "task_mgmt");
-
-	return NULL;
-}
-
 void *dl_cmd_done_fn(int typeid)
 {
 	if (dinfo[typeid].pdl)

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/usr/dl.h	2005-12-29 01:27:05 UTC (rev 214)
@@ -12,7 +12,6 @@
 extern void *dl_ipc_fn(int typeid);
 extern void *dl_event_fn(int tid, int typeid);
 extern void *dl_proto_cmd_process(int tid, int typeid);
-extern void *dl_task_mgmt_fn(int typeid);
 extern void *dl_cmd_done_fn(int typeid);
 
 extern char *typeid_to_name(int typeid);

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/usr/netlink.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -156,18 +156,6 @@
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
-static void nl_task_mgmt(struct tgt_event *ev)
-{
-	void (*fn) (char *);
-
-	fn = dl_task_mgmt_fn(ev->k.task_mgmt.typeid);
-	if (fn)
-		fn((char *) ev);
-	else
-		eprintf("Cannot handle task management %d\n",
-			ev->k.task_mgmt.tid);
-}
-
 void nl_event_handle(int fd)
 {
 	struct nlmsghdr *nlh;
@@ -195,9 +183,6 @@
 			eprintf("Cannot handle async event %d\n",
 				ev->k.tgt_passthru.tid);
 		break;
-	case TGT_KEVENT_TASK_MGMT:
-		nl_task_mgmt(ev);
-		break;
 	case TGT_KEVENT_CMD_DONE:
 		fn = dl_cmd_done_fn(ev->k.cmd_done.typeid);
 		if (fn)

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-12-29 01:19:48 UTC (rev 213)
+++ trunk/usr/scsi.c	2005-12-29 01:27:05 UTC (rev 214)
@@ -662,157 +662,6 @@
 	return result;
 }
 
-/* TODO: Create transport specific library. */
-
-int iscsi_task_mgmt(int *func)
-{
-	int err = 0;
-
-	switch (*func) {
-	case ISCSI_TM_FUNC_ABORT_TASK:
-		*func = ABORT_TASK;
-		break;
-	case ISCSI_TM_FUNC_ABORT_TASK_SET:
-		*func = ABORT_TASK_SET;
-		break;
-	case ISCSI_TM_FUNC_CLEAR_ACA:
-		*func = CLEAR_ACA;
-		break;
-	case ISCSI_TM_FUNC_CLEAR_TASK_SET:
-		*func = CLEAR_TASK_SET;
-		break;
-	case ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:
-		*func = LOGICAL_UNIT_RESET;
-		break;
-	case ISCSI_TM_FUNC_TARGET_WARM_RESET:
-	case ISCSI_TM_FUNC_TARGET_COLD_RESET:
-		/* TODO: call tgt task mgmt function again and again. */
-		err = TMF_RSP_REJECTED;
-		break;
-	case ISCSI_TM_FUNC_TASK_REASSIGN:
-	default:
-		err = TMF_RSP_REJECTED;
-		break;
-	}
-	return err;
-}
-
-int srp_task_mgmt(int *func)
-{
-	int err = 0;
-
-	switch (*func) {
-	case SRP_TSK_ABORT_TASK:
-		*func = ABORT_TASK;
-		break;
-	case SRP_TSK_ABORT_TASK_SET:
-		*func = ABORT_TASK_SET;
-		break;
-	case SRP_TSK_CLEAR_TASK_SET:
-		*func = CLEAR_TASK_SET;
-		break;
-	case SRP_TSK_LUN_RESET:
-		*func = LOGICAL_UNIT_RESET;
-		break;
-	case SRP_TSK_CLEAR_ACA:
-		*func = CLEAR_ACA;
-		break;
-	default:
-		err = TMF_RSP_REJECTED;
-		break;
-	}
-	return err;
-}
-
-static int do_task_mgmt(uint64_t rid, int func, int tid, int type,
-			uint64_t sid, uint64_t lun, uint64_t tag)
-{
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	char nlm_sev[NLMSG_SPACE(sizeof(struct tgt_event))];
-	char nlm_rev[NLMSG_SPACE(sizeof(struct tgt_event))];
-	int fd, err;
-	uint64_t size;
-	char path[PATH_MAX], buf[128];
-
-	snprintf(path, sizeof(path),
-		 TGT_TYPE_SYSFSDIR "/driver%d/subprotocol", type);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		err = TMF_RSP_TARGET_FAILURE;
-		goto out;
-	}
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		err = TMF_RSP_TARGET_FAILURE;
-		goto out;
-	}
-
-	if (!strncmp(buf, "iscsi", 5))
-		err = iscsi_task_mgmt(&func);
-	else if (!strncmp(buf, "srp", 3))
-		err = srp_task_mgmt(&func);
-	else {
-		eprintf("Cannot subprotocol %s\n", buf);
-		err = TMF_RSP_TARGET_FAILURE;
-	}
-
-	if (err) {
-		err = TMF_RSP_TARGET_FAILURE;
-		goto out;
-	}
-
-	/* We support only I_T_L or I_T_L_Q now. */
-
-	errno = 0;
-	device_info(tid, lun, &size);
-	if (errno == ENOENT) {
-		err = TMF_RSP_INCORRECT_LUN;
-		goto out;
-	}
-	err = 0;
-
-out:
-	memset(nlm_sev, 0, sizeof(nlm_sev));
-	memset(nlm_rev, 0, sizeof(nlm_rev));
-
-	nlh = (struct nlmsghdr *) nlm_sev;
-	nlh->nlmsg_pid = getpid();
-	nlh->nlmsg_len = NLMSG_SPACE(sizeof(*ev));
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_type = TGT_UEVENT_TASK_MGMT;
-
-	ev = NLMSG_DATA(nlh);
-	ev->u.task_mgmt.rid = rid;
-	ev->u.task_mgmt.func = func;
-	ev->u.task_mgmt.tid = tid;
-	ev->u.task_mgmt.sid = sid;
-	ev->u.task_mgmt.dev_id = lun;
-	ev->u.task_mgmt.tag = tag;
-	ev->u.task_mgmt.result = err;
-
-	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, (char *) nlh,
-			  nlh->nlmsg_len, nlm_rev, sizeof(nlm_rev));
-
-	return err;
-}
-
-int task_mgmt(struct tgt_event *ev)
-{
-	dprintf("%" PRIu64 " %d %d %d %" PRIu64 " %" PRIu64 " %" PRIu64 "\n",
-		ev->k.task_mgmt.rid, ev->k.task_mgmt.func,
-		ev->k.task_mgmt.tid, ev->k.task_mgmt.typeid,
-		ev->k.task_mgmt.sid, ev->k.task_mgmt.dev_id,
-		ev->k.task_mgmt.tag);
-
-	return do_task_mgmt(ev->k.task_mgmt.rid, ev->k.task_mgmt.func,
-			    ev->k.task_mgmt.tid, ev->k.task_mgmt.typeid,
-			    ev->k.task_mgmt.sid, ev->k.task_mgmt.dev_id,
-			    ev->k.task_mgmt.tag);
-}
-
 int cmd_done(struct tgt_event *ev)
 {
 	int err = 0;



From tomo at berlios.de  Thu Dec 29 16:52:43 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 29 Dec 2005 16:52:43 +0100
Subject: [Stgt-svn] r215 - in trunk: include usr
Message-ID: <200512291552.jBTFqhfQ003913@sheep.berlios.de>

Author: tomo
Date: 2005-12-29 16:52:42 +0100 (Thu, 29 Dec 2005)
New Revision: 215

Removed:
   trunk/include/tgt_scsi.h
Modified:
   trunk/usr/scsi.c
Log:
Remove mgmt code again.

Deleted: trunk/include/tgt_scsi.h
===================================================================
--- trunk/include/tgt_scsi.h	2005-12-29 01:27:05 UTC (rev 214)
+++ trunk/include/tgt_scsi.h	2005-12-29 15:52:42 UTC (rev 215)
@@ -1,19 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __TGT_SCSI_H
-#define __TGT_SCSI_H
-
-#define TMF_RSP_COMPLETE	0x00
-#define TMF_RSP_SUCCEEDED	0x01
-#define TMF_RSP_REJECTED	0x02
-#define TMF_RSP_INCORRECT_LUN	0x03
-#define TMF_RSP_TARGET_FAILURE	0x04
-
-/* for transport specific */
-#define TMF_RSP_NO_TASK		0x05
-
-#endif

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-12-29 01:27:05 UTC (rev 214)
+++ trunk/usr/scsi.c	2005-12-29 15:52:42 UTC (rev 215)
@@ -11,9 +11,6 @@
  *   licensed under the terms of the GNU GPL v2.0,
  */
 
-#define	u8	__u8
-#define	u64	__u64
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -23,7 +20,6 @@
 #include <unistd.h>
 #include <errno.h>
 #include <scsi/scsi.h>
-#include <scsi/srp.h>
 #include <scsi/iscsi_proto.h>
 #include <asm/byteorder.h>
 #include <asm/page.h>
@@ -36,7 +32,6 @@
 
 #include "tgtd.h"
 #include "tgt_if.h"
-#include "tgt_scsi.h"
 #include "tgt_sysfs.h"
 
 #define cpu_to_be32 __cpu_to_be32



From tomo at berlios.de  Thu Dec 29 17:15:42 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 29 Dec 2005 17:15:42 +0100
Subject: [Stgt-svn] r216 - in trunk/istgt: include kernel usr
Message-ID: <200512291615.jBTGFgpZ006297@sheep.berlios.de>

Author: tomo
Date: 2005-12-29 17:15:41 +0100 (Thu, 29 Dec 2005)
New Revision: 216

Removed:
   trunk/istgt/include/iscsi_proto.h
Modified:
   trunk/istgt/kernel/iscsi.h
   trunk/istgt/usr/Makefile
   trunk/istgt/usr/iscsid.h
   trunk/istgt/usr/types.h
Log:
Kill iscsi_proto.h.

Deleted: trunk/istgt/include/iscsi_proto.h
===================================================================
--- trunk/istgt/include/iscsi_proto.h	2005-12-29 15:52:42 UTC (rev 215)
+++ trunk/istgt/include/iscsi_proto.h	2005-12-29 16:15:41 UTC (rev 216)
@@ -1,589 +0,0 @@
-/*
- * RFC 3720 (iSCSI) protocol data types
- *
- * Copyright (C) 2005 Dmitry Yusupov
- * Copyright (C) 2005 Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#ifndef ISCSI_PROTO_H
-#define ISCSI_PROTO_H
-
-#define ISCSI_VERSION_STR	"0.3"
-#define ISCSI_DATE_STR		"22-Apr-2005"
-#define ISCSI_DRAFT20_VERSION	0x00
-
-/* default iSCSI listen port for incoming connections */
-#define ISCSI_LISTEN_PORT	3260
-
-/* Padding word length */
-#define PAD_WORD_LEN		4
-
-/*
- * useful common(control and data pathes) macro
- */
-#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
-#define hton24(p, v) { \
-        p[0] = (((v) >> 16) & 0xFF); \
-        p[1] = (((v) >> 8) & 0xFF); \
-        p[2] = ((v) & 0xFF); \
-}
-#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
-
-/*
- * iSCSI Template Message Header
- */
-struct iscsi_hdr {
-	uint8_t		opcode;
-	uint8_t		flags;		/* Final bit */
-	uint8_t		rsvd2[2];
-	uint8_t		hlength;	/* AHSs total length */
-	uint8_t		dlength[3];	/* Data length */
-	uint8_t		lun[8];
-	__be32		itt;		/* Initiator Task Tag */
-	__be32		ttt;		/* Target Task Tag */
-	__be32		statsn;
-	__be32		exp_statsn;
-	__be32		max_statsn;
-	uint8_t		other[12];
-};
-
-/************************* RFC 3720 Begin *****************************/
-
-#define ISCSI_RESERVED_TAG		0xffffffff
-
-/* Opcode encoding bits */
-#define ISCSI_OP_RETRY			0x80
-#define ISCSI_OP_IMMEDIATE		0x40
-#define ISCSI_OPCODE_MASK		0x3F
-
-/* Initiator Opcode values */
-#define ISCSI_OP_NOOP_OUT		0x00
-#define ISCSI_OP_SCSI_CMD		0x01
-#define ISCSI_OP_SCSI_TMFUNC		0x02
-#define ISCSI_OP_LOGIN			0x03
-#define ISCSI_OP_TEXT			0x04
-#define ISCSI_OP_SCSI_DATA_OUT		0x05
-#define ISCSI_OP_LOGOUT			0x06
-#define ISCSI_OP_SNACK			0x10
-
-#define ISCSI_OP_VENDOR1_CMD		0x1c
-#define ISCSI_OP_VENDOR2_CMD		0x1d
-#define ISCSI_OP_VENDOR3_CMD		0x1e
-#define ISCSI_OP_VENDOR4_CMD		0x1f
-
-/* Target Opcode values */
-#define ISCSI_OP_NOOP_IN		0x20
-#define ISCSI_OP_SCSI_CMD_RSP		0x21
-#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
-#define ISCSI_OP_LOGIN_RSP		0x23
-#define ISCSI_OP_TEXT_RSP		0x24
-#define ISCSI_OP_SCSI_DATA_IN		0x25
-#define ISCSI_OP_LOGOUT_RSP		0x26
-#define ISCSI_OP_R2T			0x31
-#define ISCSI_OP_ASYNC_EVENT		0x32
-#define ISCSI_OP_REJECT			0x3f
-
-struct iscsi_ahs_hdr {
-	__be16 ahslength;
-	uint8_t ahstype;
-	uint8_t ahspec[5];
-};
-
-#define ISCSI_AHSTYPE_CDB		1
-#define ISCSI_AHSTYPE_RLENGTH		2
-
-/* iSCSI PDU Header */
-struct iscsi_cmd {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16 rsvd2;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32 itt;	/* Initiator Task Tag */
-	__be32 data_length;
-	__be32 cmdsn;
-	__be32 exp_statsn;
-	uint8_t cdb[16];	/* SCSI Command Block */
-	/* Additional Data (Command Dependent) */
-};
-
-/* Command PDU flags */
-#define ISCSI_FLAG_CMD_FINAL		0x80
-#define ISCSI_FLAG_CMD_READ		0x40
-#define ISCSI_FLAG_CMD_WRITE		0x20
-#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
-
-/* SCSI Command Attribute values */
-#define ISCSI_ATTR_UNTAGGED		0
-#define ISCSI_ATTR_SIMPLE		1
-#define ISCSI_ATTR_ORDERED		2
-#define ISCSI_ATTR_HEAD_OF_QUEUE	3
-#define ISCSI_ATTR_ACA			4
-
-struct iscsi_rlength_ahdr {
-	__be16 ahslength;
-	uint8_t ahstype;
-	uint8_t reserved;
-	__be32 read_length;
-};
-
-/* SCSI Response Header */
-struct iscsi_cmd_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;
-	uint8_t cmd_status;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd1;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	exp_datasn;
-	__be32	bi_residual_count;
-	__be32	residual_count;
-	/* Response or Sense Data (optional) */
-};
-
-/* Command Response PDU flags */
-#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
-#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
-#define ISCSI_FLAG_CMD_OVERFLOW		0x04
-#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
-
-/* iSCSI Status values. Valid if Rsp Selector bit is not set */
-#define ISCSI_STATUS_CMD_COMPLETED	0
-#define ISCSI_STATUS_TARGET_FAILURE	1
-#define ISCSI_STATUS_SUBSYS_FAILURE	2
-
-/* Asynchronous Event Header */
-struct iscsi_async {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	uint8_t rsvd4[8];
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t async_event;
-	uint8_t async_vcode;
-	__be16	param1;
-	__be16	param2;
-	__be16	param3;
-	uint8_t rsvd5[4];
-};
-
-/* iSCSI Event Codes */
-#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
-#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
-#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
-#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
-#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
-#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
-
-/* NOP-Out Message */
-struct iscsi_nopout {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16	rsvd2;
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd4[16];
-};
-
-/* NOP-In Message */
-struct iscsi_nopin {
-	uint8_t opcode;
-	uint8_t flags;
-	__be16	rsvd2;
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd4[12];
-};
-
-/* SCSI Task Management Message Header */
-struct iscsi_tm {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd1[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rtt;	/* Reference Task Tag */
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	__be32	refcmdsn;
-	__be32	exp_datasn;
-	uint8_t rsvd2[8];
-};
-
-#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
-
-/* Function values */
-#define ISCSI_TM_FUNC_ABORT_TASK		1
-#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
-#define ISCSI_TM_FUNC_CLEAR_ACA			3
-#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
-#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
-#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
-#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
-#define ISCSI_TM_FUNC_TASK_REASSIGN		8
-
-/* SCSI Task Management Response Header */
-struct iscsi_tm_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;	/* see Response values below */
-	uint8_t qualifier;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd2[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rtt;	/* Reference Task Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd3[12];
-};
-
-/* Response values */
-#define ISCSI_TMF_RSP_COMPLETE		0x00
-#define ISCSI_TMF_RSP_NO_TASK		0x01
-#define ISCSI_TMF_RSP_NO_LUN		0x02
-#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
-#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
-#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
-#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
-#define ISCSI_TMF_RSP_REJECTED		0xff
-
-/* Ready To Transfer Header */
-struct iscsi_r2t_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t	hlength;
-	uint8_t	dlength[3];
-	uint8_t lun[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	ttt;	/* Target Transfer Tag */
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	r2tsn;
-	__be32	data_offset;
-	__be32	data_length;
-};
-
-/* SCSI Data Hdr */
-struct iscsi_data {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t rsvd3;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	rsvd4;
-	__be32	exp_statsn;
-	__be32	rsvd5;
-	__be32	datasn;
-	__be32	offset;
-	__be32	rsvd6;
-	/* Payload */
-};
-
-/* SCSI Data Response Hdr */
-struct iscsi_data_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2;
-	uint8_t cmd_status;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t lun[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	datasn;
-	__be32	offset;
-	__be32	residual_count;
-};
-
-/* Data Response PDU flags */
-#define ISCSI_FLAG_DATA_ACK		0x40
-#define ISCSI_FLAG_DATA_OVERFLOW	0x04
-#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
-#define ISCSI_FLAG_DATA_STATUS		0x01
-
-/* Text Header */
-struct iscsi_text {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd4[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd5[16];
-	/* Text - key=value pairs */
-};
-
-#define ISCSI_FLAG_TEXT_CONTINUE	0x40
-
-/* Text Response Header */
-struct iscsi_text_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd4[8];
-	__be32	itt;
-	__be32	ttt;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t rsvd5[12];
-	/* Text Response - key:value pairs */
-};
-
-/* Login Header */
-struct iscsi_login {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t max_version;	/* Max. version supported */
-	uint8_t min_version;	/* Min. version supported */
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t isid[6];	/* Initiator Session ID */
-	__be16	tsih;	/* Target Session Handle */
-	__be32	itt;	/* Initiator Task Tag */
-	__be16	cid;
-	__be16	rsvd3;
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd5[16];
-};
-
-/* Login PDU flags */
-#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
-#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
-#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
-#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
-
-#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
-	((flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) >> 2)
-#define ISCSI_LOGIN_NEXT_STAGE(flags) \
-	(flags & ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
-
-/* Login Response Header */
-struct iscsi_login_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t max_version;	/* Max. version supported */
-	uint8_t active_version;	/* Active version */
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t isid[6];	/* Initiator Session ID */
-	__be16	tsih;	/* Target Session Handle */
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd3;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	uint8_t status_class;	/* see Login RSP ststus classes below */
-	uint8_t status_detail;	/* see Login RSP Status details below */
-	uint8_t rsvd4[10];
-};
-
-/* Login stage (phase) codes for CSG, NSG */
-#define ISCSI_INITIAL_LOGIN_STAGE		-1
-#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
-#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
-#define ISCSI_FULL_FEATURE_PHASE		3
-
-/* Login Status response classes */
-#define ISCSI_STATUS_CLS_SUCCESS		0x00
-#define ISCSI_STATUS_CLS_REDIRECT		0x01
-#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
-#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
-
-/* Login Status response detail codes */
-/* Class-0 (Success) */
-#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
-
-/* Class-1 (Redirection) */
-#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
-#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
-
-/* Class-2 (Initiator Error) */
-#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
-#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
-#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
-#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
-#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
-#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
-#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
-#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
-#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
-#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
-#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
-#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
-
-/* Class-3 (Target Error) */
-#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
-#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
-#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
-
-/* Logout Header */
-struct iscsi_logout {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd1[2];
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd2[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be16	cid;
-	uint8_t rsvd3[2];
-	__be32	cmdsn;
-	__be32	exp_statsn;
-	uint8_t rsvd4[16];
-};
-
-/* Logout PDU flags */
-#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
-
-/* logout reason_code values */
-
-#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
-#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
-#define ISCSI_LOGOUT_REASON_RECOVERY		2
-#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
-
-/* Logout Response Header */
-struct iscsi_logout_rsp {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t response;	/* see Logout response values below */
-	uint8_t rsvd2;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd3[8];
-	__be32	itt;	/* Initiator Task Tag */
-	__be32	rsvd4;
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	rsvd5;
-	__be16	t2wait;
-	__be16	t2retain;
-	__be32	rsvd6;
-};
-
-/* logout response status values */
-
-#define ISCSI_LOGOUT_SUCCESS			0
-#define ISCSI_LOGOUT_CID_NOT_FOUND		1
-#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
-#define ISCSI_LOGOUT_CLEANUP_FAILED		3
-
-/* SNACK Header */
-struct iscsi_snack {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t rsvd2[14];
-	__be32	itt;
-	__be32	begrun;
-	__be32	runlength;
-	__be32	exp_statsn;
-	__be32	rsvd3;
-	__be32	exp_datasn;
-	uint8_t rsvd6[8];
-};
-
-/* SNACK PDU flags */
-#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
-
-/* Reject Message Header */
-struct iscsi_reject {
-	uint8_t opcode;
-	uint8_t flags;
-	uint8_t reason;
-	uint8_t rsvd2;
-	uint8_t hlength;
-	uint8_t dlength[3];
-	uint8_t rsvd3[8];
-	__be32  ffffffff;
-	uint8_t rsvd4[4];
-	__be32	statsn;
-	__be32	exp_cmdsn;
-	__be32	max_cmdsn;
-	__be32	datasn;
-	uint8_t rsvd5[8];
-	/* Text - Rejected hdr */
-};
-
-/* Reason for Reject */
-#define ISCSI_REASON_CMD_BEFORE_LOGIN	1
-#define ISCSI_REASON_DATA_DIGEST_ERROR	2
-#define ISCSI_REASON_DATA_SNACK_REJECT	3
-#define ISCSI_REASON_PROTOCOL_ERROR	4
-#define ISCSI_REASON_CMD_NOT_SUPPORTED	5
-#define ISCSI_REASON_IMM_CMD_REJECT		6
-#define ISCSI_REASON_TASK_IN_PROGRESS	7
-#define ISCSI_REASON_INVALID_SNACK		8
-#define ISCSI_REASON_BOOKMARK_INVALID	9
-#define ISCSI_REASON_BOOKMARK_NO_RESOURCES	10
-#define ISCSI_REASON_NEGOTIATION_RESET	11
-
-/* Max. number of Key=Value pairs in a text message */
-#define MAX_KEY_VALUE_PAIRS	8192
-
-/* maximum length for text keys/values */
-#define KEY_MAXLEN		64
-#define VALUE_MAXLEN		255
-#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
-
-#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
-
-/************************* RFC 3720 End *****************************/
-
-#endif /* ISCSI_PROTO_H */

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-12-29 15:52:42 UTC (rev 215)
+++ trunk/istgt/kernel/iscsi.h	2005-12-29 16:15:41 UTC (rev 216)
@@ -14,7 +14,7 @@
 #include <asm/scatterlist.h>
 #include <linux/blkdev.h>
 
-#include <iscsi_proto.h>
+#include <scsi/iscsi_proto.h>
 #include <istgt_u.h>
 
 #include <tgt.h>

Modified: trunk/istgt/usr/Makefile
===================================================================
--- trunk/istgt/usr/Makefile	2005-12-29 15:52:42 UTC (rev 215)
+++ trunk/istgt/usr/Makefile	2005-12-29 16:15:41 UTC (rev 216)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I../include -I../../include -I../../usr
+CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../include -I../../include -I../../usr
 #LIBS = -lcrypto
 OBJS = istgt.o conn.o param.o iscsid.o session.o target.o chap.o ctldev.o
 SHAREDLIB = istgt.so

Modified: trunk/istgt/usr/iscsid.h
===================================================================
--- trunk/istgt/usr/iscsid.h	2005-12-29 15:52:42 UTC (rev 215)
+++ trunk/istgt/usr/iscsid.h	2005-12-29 16:15:41 UTC (rev 216)
@@ -9,14 +9,16 @@
 
 #include <search.h>
 #include <sys/types.h>
+#include <linux/types.h>
 
 #include "types.h"
 #include "istgt_u.h"
 #include "param.h"
 #include "misc.h"
 #include "log.h"
-#include <iscsi_proto.h>
 
+#include <scsi/iscsi_proto.h>
+
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\

Modified: trunk/istgt/usr/types.h
===================================================================
--- trunk/istgt/usr/types.h	2005-12-29 15:52:42 UTC (rev 215)
+++ trunk/istgt/usr/types.h	2005-12-29 16:15:41 UTC (rev 216)
@@ -27,7 +27,4 @@
 #error "unknown endianess!"
 #endif
 
-typedef uint16_t __be16;
-typedef uint32_t __be32;
-
 #endif	/* TYPES_H */



From tomo at berlios.de  Fri Dec 30 05:34:45 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 05:34:45 +0100
Subject: [Stgt-svn] r217 - trunk/kernel
Message-ID: <200512300434.jBU4Yjaj006320@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 05:34:42 +0100 (Fri, 30 Dec 2005)
New Revision: 217

Modified:
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_target.h
Log:
Replace request_queue with a simple queue .

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-29 16:15:41 UTC (rev 216)
+++ trunk/kernel/tgt.c	2005-12-30 04:34:42 UTC (rev 217)
@@ -14,6 +14,7 @@
 #include <linux/mempool.h>
 #include <linux/blkdev.h>
 #include <linux/file.h>
+#include <linux/hash.h>
 #include <asm/scatterlist.h>
 
 #include <tgt.h>
@@ -146,67 +147,42 @@
 }
 EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
 
-static void tgt_request_fn(struct request_queue *q)
+static void tgt_cmd_uspace_queue(struct tgt_target *target, gfp_t gfp_mask)
 {
+	unsigned long flags;
 	struct tgt_cmd *cmd;
-	struct request *rq;
+	int err = 0;
 
-	while ((rq = elv_next_request(q)) != NULL) {
-		/* we need to set state or refcount under this lock! */
-		cmd = rq->special;
-		/*
-		 * hit queue depth (command completion will run the
-		 * queue again)
-		 */
-		if (blk_queue_tagged(q) && blk_queue_start_tag(q, rq))
-			break;
+retry:
+	spin_lock_irqsave(&target->lock, flags);
+	if (!list_empty(&target->uspace_cmd_queue)) {
+		cmd = list_entry(target->uspace_cmd_queue.next,
+				 struct tgt_cmd, cqueue);
+		list_del(&cmd->cqueue);
+		spin_unlock_irqrestore(&target->lock, flags);
 
-		spin_unlock_irq(q->queue_lock);
-
-		dprintk("cmd %p tag %d\n", cmd, rq->tag);
-
-		/*
-		 * TODO: build a vector of commands and then do the
-	 	 * userspace send call
-		 */
-
-		/* what should we do on failure here ? */
-		if (tgt_uspace_cmd_send(cmd, GFP_ATOMIC) < 0)
-			eprintk("command %d failed\n", rq->tag);
-
-		spin_lock_irq(q->queue_lock);
+		err = tgt_uspace_cmd_send(cmd, gfp_mask);
+		if (err < 0) {
+			spin_lock_irqsave(&target->lock, flags);
+			list_add(&cmd->cqueue, &target->uspace_cmd_queue);
+			goto out;
+		}
+		goto retry;
 	}
-}
+out:
+	spin_unlock_irqrestore(&target->lock, flags);
 
-static void tgt_queue_destroy(struct request_queue *q)
-{
-	blk_cleanup_queue(q);
+	if (err < 0)
+		queue_work(target->twq, &target->send_work);
 }
 
-static int tgt_queue_create(struct tgt_protocol *proto, int depth,
-			    struct request_queue **queue)
+static void tgt_cmd_uspace_queue_worker(void *data)
 {
-	struct request_queue *q;
-	int err = -ENOMEM;
+	struct tgt_target *target = data;
 
-	*queue = q = blk_init_queue(tgt_request_fn, NULL);
-	if (!q)
-		return -ENOMEM;
-
-	elevator_exit(q->elevator);
-	err = elevator_init(q, "noop");
-	if (err)
-		goto out;
-
-	/* who should set this limit ? */
-	err = blk_queue_init_tags(q, depth, NULL);
-	if (err)
-		goto out;
-
-	return 0;
-out:
-	tgt_queue_destroy(q);
-	return err;
+	down(&target->uspace_sem);
+	tgt_cmd_uspace_queue(target, GFP_KERNEL);
+	up(&target->uspace_sem);
 }
 
 struct tgt_target *target_find(int tid)
@@ -228,7 +204,7 @@
 struct tgt_target *tgt_target_create(char *target_type, int queued_cmds)
 {
 	char name[16];
-	static int target_id;
+	static int i, target_id;
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
@@ -246,11 +222,15 @@
 	target->typeid = ti->typeid;
 	target->tid = target_id++;
 	spin_lock_init(&target->lock);
+	init_MUTEX(&target->uspace_sem);
 
 	INIT_LIST_HEAD(&target->session_list);
 	INIT_LIST_HEAD(&target->device_list);
+	for (i = 0; i < ARRAY_SIZE(target->cmd_hlist); i++)
+		INIT_LIST_HEAD(&target->cmd_hlist[i]);
+	INIT_LIST_HEAD(&target->uspace_cmd_queue);
 
-	target->queued_cmds = queued_cmds;
+	target->queued_cmds = queued_cmds ? : TGT_QUEUE_DEPTH;
 
 	snprintf(name, sizeof(name), "tgtd%d", target->tid);
 	target->twq = create_workqueue(name);
@@ -265,20 +245,16 @@
 		if (target->tt->target_create(target))
 			goto free_priv_tt_data;
 
-	if (tgt_queue_create(target->proto, queued_cmds ? : TGT_QUEUE_DEPTH,
-			     &target->q))
+	if (tgt_sysfs_register_target(target))
 		goto tt_destroy;
 
-	if (tgt_sysfs_register_target(target))
-		goto queue_destroy;
+	INIT_WORK(&target->send_work, tgt_cmd_uspace_queue_worker, target);
 
 	spin_lock(&all_targets_lock);
 	list_add(&target->tlist, &all_targets);
 	spin_unlock(&all_targets_lock);
 	return target;
 
-queue_destroy:
-	tgt_queue_destroy(target->q);
 tt_destroy:
 	if (target->tt->target_destroy)
 		target->tt->target_destroy(target);
@@ -319,7 +295,6 @@
 		target->tt->target_destroy(target);
 
 	destroy_workqueue(target->twq);
-	tgt_queue_destroy(target->q);
 	target_template_put(target->tt);
 	tgt_sysfs_unregister_target(target);
 
@@ -420,18 +395,6 @@
 	return NULL;
 }
 
-static struct tgt_device *tgt_device_find(struct tgt_target *target, uint64_t dev_id)
-{
-	static struct tgt_device *device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	device = tgt_device_find_nolock(target, dev_id);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return device;
-}
-
 struct tgt_device *tgt_device_get(struct tgt_target *target, uint64_t dev_id)
 {
 	static struct tgt_device *device;
@@ -457,42 +420,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_device_put);
 
-#define min_not_zero(l, r) (l == 0) ? r : ((r == 0) ? l : min(l, r))
-
-static int tgt_device_queue_setup(struct tgt_device *device)
-{
-	struct io_restrictions *limits = &device->limits;
-	struct tgt_target_template *tt = device->target->tt;
-	struct request_queue *q = device->q;
-
-	device->q = q;
-
-	blk_queue_max_sectors(q, min_not_zero(tt->max_sectors,
-					limits->max_sectors));
-	blk_queue_max_phys_segments(q, min_not_zero(limits->max_phys_segments,
-					(unsigned short)TGT_MAX_PHYS_SEGMENTS));
-	blk_queue_max_hw_segments(q, min_not_zero(tt->max_hw_segments,
-					limits->max_hw_segments));
-	blk_queue_max_segment_size(q, min_not_zero(tt->max_segment_size,
-					limits->max_segment_size));
-	blk_queue_segment_boundary(q, min_not_zero(tt->seg_boundary_mask,
-					limits->seg_boundary_mask));
-	if (!tt->use_clustering || !device->use_clustering)
-		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
-
-	dprintk("max_sectors %u\n", q->max_sectors);
-	dprintk("max_phys_segments %u\n", q->max_phys_segments);
-	dprintk("max_hw_segments %u\n", q->max_hw_segments);
-	dprintk("max_segment_size %u\n", q->max_segment_size);
-	dprintk("seg_boundary_mask %lx\n", q->seg_boundary_mask);
-	if (test_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags))
-		dprintk("clustering set\n");
-	else
-		dprintk("clustering not set\n");
-
-	return 0;
-}
-
 int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 		      int fd, unsigned long dflags)
 {
@@ -529,24 +456,17 @@
 	else if (S_ISBLK(inode->i_mode))
 		inode = inode->i_bdev->bd_inode;
 
-	device->use_clustering = 1;
 	device->size = inode->i_size;
 
-	if (tgt_queue_create(target->proto, TGT_QUEUE_DEPTH, &device->q))
+	if (tgt_sysfs_register_device(device))
 		goto put_fd;
-	tgt_device_queue_setup(device);
 
-	if (tgt_sysfs_register_device(device))
-		goto queue_destroy;
-
 	spin_lock_irqsave(&target->lock, flags);
 	list_add(&device->dlist, &target->device_list);
 	spin_unlock_irqrestore(&target->lock, flags);
 
 	return 0;
 
-queue_destroy:
-	tgt_queue_destroy(device->q);
 put_fd:
 	fput(device->file);
 free_device:
@@ -565,7 +485,6 @@
 	list_del(&device->dlist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	tgt_queue_destroy(device->q);
 	fput(device->file);
 
 	kfree(device);
@@ -622,31 +541,83 @@
 	kfree(cmd->pages);
 }
 
+static struct tgt_cmd *__tgt_cmd_hlist_find(struct tgt_target *target,
+					    uint64_t tag)
+{
+	struct tgt_cmd *cmd;
+	struct list_head *head = &target->cmd_hlist[cmd_hashfn(tag)];
+
+	list_for_each_entry(cmd, head, hash_list) {
+		if (cmd_tag(cmd) == tag)
+			return cmd;
+	}
+	return NULL;
+}
+
+static struct tgt_cmd *tgt_cmd_hlist_find(struct tgt_target *target, uint64_t tag)
+{
+	unsigned long flags;
+	struct tgt_cmd *cmd;
+
+	spin_lock_irqsave(&target->lock, flags);
+	cmd = __tgt_cmd_hlist_find(target, tag);
+	spin_unlock_irqrestore(&target->lock, flags);
+	return cmd;
+}
+
+static int tgt_cmd_hlist_add(struct tgt_cmd *cmd)
+{
+	struct tgt_target *target = cmd->session->target;
+	struct list_head *head;
+	unsigned long flags;
+	uint64_t tag = cmd_tag(cmd);
+	int err = 0;
+
+	spin_lock_irqsave(&target->lock, flags);
+
+	if (__tgt_cmd_hlist_find(target, tag)) {
+		err = -EINVAL;
+		eprintk("%p is already on the hash list.\n", cmd);
+	} else {
+		head = &target->cmd_hlist[cmd_hashfn(tag)];
+		list_add_tail(&cmd->hash_list, head);
+	}
+	spin_unlock_irqrestore(&target->lock, flags);
+
+	return err;
+}
+
+static void tgt_cmd_hlist_del(struct tgt_cmd *cmd)
+{
+	struct tgt_target *target = cmd->session->target;
+	unsigned long flags;
+
+	spin_lock_irqsave(&target->lock, flags);
+
+	cmd = __tgt_cmd_hlist_find(target, cmd_tag(cmd));
+	if (cmd)
+		list_del(&cmd->hash_list);
+	else
+		eprintk("%p is not on the hash list.\n", cmd);
+
+	spin_unlock_irqrestore(&target->lock, flags);
+}
+
 static void __tgt_cmd_destroy(void *data)
 {
 	struct tgt_cmd *cmd = data;
-	struct request *rq = cmd->rq;
-	struct request_queue *q = rq->q;
-	unsigned long flags;
 
-	dprintk("tag %d\n", rq->tag);
+	dprintk("cmd %p\n", cmd);
 
 	tgt_unmap_user_pages(cmd);
 	kfree(cmd->sg);
 	tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
 
-	spin_lock_irqsave(q->queue_lock, flags);
-	if (blk_rq_tagged(rq))
-		blk_queue_end_tag(q, rq);
-	end_that_request_last(rq);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
+	tgt_cmd_hlist_del(cmd);
 	if (cmd->device)
 		tgt_device_put(cmd->device);
 
 	mempool_free(cmd, cmd->session->cmd_pool);
-
-	blk_run_queue(q);
 }
 
 static void tgt_cmd_destroy(struct tgt_cmd *cmd)
@@ -689,26 +660,13 @@
 }
 EXPORT_SYMBOL_GPL(tgt_transfer_response);
 
-static int tgt_cmd_queue(struct tgt_cmd *cmd, gfp_t gfp_mask)
+static inline void tgt_cmd_queue(struct tgt_target *target, struct tgt_cmd *cmd)
 {
-	int write = (cmd->data_dir == DMA_TO_DEVICE);
-	struct request_queue *q;
-	struct request *rq;
+	unsigned long flags;
 
-	if (cmd->device)
-		q = cmd->device->q;
-	else
-		q = cmd->session->target->q;
-
-	rq = blk_get_request(q, write, gfp_mask);
-	if (!rq)
-		return -ENOMEM;
-
-	cmd->rq = rq;
-	rq->special = cmd;
-	rq->flags |= REQ_SPECIAL | REQ_SOFTBARRIER | REQ_NOMERGE | REQ_BLOCK_PC;
-	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 1);
-	return 0;
+	spin_lock_irqsave(&target->lock, flags);
+	list_add_tail(&cmd->cqueue, &target->uspace_cmd_queue);
+	spin_unlock_irqrestore(&target->lock, flags);
 }
 
 struct tgt_cmd *
@@ -717,6 +675,7 @@
 	       uint8_t *dev_buf, int dev_buf_size, int flags)
 {
 	struct tgt_cmd *cmd;
+	struct tgt_target *target = session->target;
 	int err;
 
 	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
@@ -725,10 +684,10 @@
 		return NULL;
 	}
 	memset(cmd, 0, sizeof(*cmd));
-	session->target->proto->cmd_create(cmd, cb, data_len, data_dir,
-					   dev_buf, dev_buf_size, flags);
+	target->proto->cmd_create(cmd, cb, data_len, data_dir,
+				  dev_buf, dev_buf_size, flags);
 
-	cmd->device = tgt_device_get(session->target, cmd->dev_id);
+	cmd->device = tgt_device_get(target, cmd->dev_id);
 	cmd->session = session;
 	cmd->private = tgt_priv;
 	cmd->done = tgt_cmd_destroy;
@@ -736,12 +695,21 @@
 
 	dprintk("%p %p\n", session, cmd);
 
-	err = tgt_cmd_queue(cmd, GFP_ATOMIC);
+	err = tgt_cmd_hlist_add(cmd);
 	if (err) {
+		if (cmd->device)
+			tgt_device_put(cmd->device);
 		mempool_free(cmd, cmd->session->cmd_pool);
 		return NULL;
 	}
 
+	tgt_cmd_queue(target, cmd);
+        if (!in_interrupt() && !down_trylock(&target->uspace_sem)) {
+		tgt_cmd_uspace_queue(target, GFP_ATOMIC);
+		up(&target->uspace_sem);
+	} else
+		queue_work(target->twq, &target->send_work);
+
 	return cmd;
 }
 EXPORT_SYMBOL_GPL(tgt_cmd_create);
@@ -762,9 +730,7 @@
 static struct tgt_cmd *find_cmd_by_id(int tid, uint64_t dev_id, uint64_t cid)
 {
 	struct tgt_target *target;
-	struct tgt_device *device;
-	struct request_queue *q;
-	struct request *rq;
+	struct tgt_cmd *cmd;
 
 	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
 		(unsigned long long) cid);
@@ -775,24 +741,10 @@
 		return NULL;
 	}
 
-	if (dev_id == TGT_INVALID_DEV_ID)
-		q = target->q;
-	else {
-		device = tgt_device_find(target, dev_id);
-		if (!device) {
-			eprintk("Could not find device %llu\n",
-				(unsigned long long) dev_id);
-			return NULL;
-		}
-		q = device->q;
-	}
-
-	rq = blk_queue_find_tag(q, cid);
-	if (rq)
-		return rq->special;
-
-	eprintk("Could not find rq for cid %llu\n", (unsigned long long) cid);
-	return NULL;
+	cmd = tgt_cmd_hlist_find(target, cid);
+	if (!cmd)
+		eprintk("Could not find rq for cid %llu\n", (unsigned long long) cid);
+	return cmd;
 }
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
@@ -879,8 +831,8 @@
 		return -EINVAL;
 	}
 
-	dprintk("cmd %p tag %d result %d len %d bufflen %u\n",
-		cmd, cmd->rq->tag, result, len, cmd->bufflen);
+	dprintk("cmd %p tag %llu result %d len %d bufflen %u\n", cmd,
+		(unsigned long long) cmd_tag(cmd), result, len, cmd->bufflen);
 
 	cmd->uaddr = uaddr;
 	cmd->result = result;

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-29 16:15:41 UTC (rev 216)
+++ trunk/kernel/tgt.h	2005-12-30 04:34:42 UTC (rev 217)
@@ -15,7 +15,6 @@
 
 #include <tgt_types.h>
 
-struct request;
 struct tgt_device;
 struct tgt_protocol;
 struct tgt_session;
@@ -58,6 +57,9 @@
 	struct tgt_device *device;
 	struct tgt_protocol *proto;
 
+	struct list_head hash_list;
+	struct list_head cqueue;
+
 	atomic_t state;
 	uint64_t dev_id;
 	unsigned long flags;
@@ -75,7 +77,6 @@
 
 	unsigned long uaddr;
 
-	struct request *rq;
 	/*
 	 * target driver private
 	 */

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-12-29 16:15:41 UTC (rev 216)
+++ trunk/kernel/tgt_device.h	2005-12-30 04:34:42 UTC (rev 217)
@@ -13,7 +13,6 @@
 #include <linux/device.h>
 #include <linux/list.h>
 
-struct request_queue;
 struct tgt_device;
 struct tgt_cmd;
 
@@ -43,15 +42,6 @@
 	uint64_t size;
 
 	unsigned long state;
-	/*
-	 * queue for tgt <-> tgt LLD requests
-	 */
-	struct request_queue *q;
-	/*
-	 * end device io limits (should be set by tgt_device drivers)
-	 */
-	struct io_restrictions limits;
-	unsigned use_clustering;
 
 	struct tgt_target *target;
 	struct list_head dlist;

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-29 16:15:41 UTC (rev 216)
+++ trunk/kernel/tgt_nl.c	2005-12-30 04:34:42 UTC (rev 217)
@@ -42,7 +42,7 @@
 	pdu = (char *) ev->data;
 	ev->k.cmd_req.tid = cmd->session->target->tid;
 	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
-	ev->k.cmd_req.cid = cmd->rq->tag;
+	ev->k.cmd_req.cid = cmd_tag(cmd);
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
 	ev->k.cmd_req.fd = cmd->device ? cmd->device->fd : 0;
 	ev->k.cmd_req.data_len = cmd->bufflen;

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-12-29 16:15:41 UTC (rev 216)
+++ trunk/kernel/tgt_target.h	2005-12-30 04:34:42 UTC (rev 217)
@@ -88,6 +88,10 @@
 	struct class_device_attribute **target_attrs;
 };
 
+#define TGT_CMD_HASH_ORDER		4
+#define	cmd_tag(p)	((uint64_t)(unsigned long) p)
+#define	cmd_hashfn(tag)	hash_long((tag), TGT_CMD_HASH_ORDER)
+
 enum {
 	TGT_CREATED,
 	TGT_DESTROYED,
@@ -102,18 +106,23 @@
 
 	struct class_device cdev;
 
-	struct request_queue *q;
 	int queued_cmds;
 	int state;
 
-	/* Protects session_list and device_list and state */
+	/* Protects session_list, device_list, cmd_hlist, and state */
 	spinlock_t lock;
 
+	/* Serializes commands going to user space */
+	struct semaphore uspace_sem;
 	struct list_head tlist;
 
 	struct list_head device_list;
 	struct list_head session_list;
+	struct list_head cmd_hlist[1 << TGT_CMD_HASH_ORDER];
 
+	struct list_head uspace_cmd_queue;
+	struct work_struct send_work;
+
 	struct workqueue_struct *twq;
 };
 



From tomo at berlios.de  Fri Dec 30 05:43:54 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 05:43:54 +0100
Subject: [Stgt-svn] r218 - trunk/kernel
Message-ID: <200512300443.jBU4hsgg007165@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 05:43:53 +0100 (Fri, 30 Dec 2005)
New Revision: 218

Modified:
   trunk/kernel/tgt.c
Log:
Rename find_cmd_by_id tgt_cmd_find.

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-30 04:34:42 UTC (rev 217)
+++ trunk/kernel/tgt.c	2005-12-30 04:43:53 UTC (rev 218)
@@ -727,13 +727,13 @@
  * we should jsut pass the cmd pointer between userspace and the kernel
  * as a handle like open-iscsi
  */
-static struct tgt_cmd *find_cmd_by_id(int tid, uint64_t dev_id, uint64_t cid)
+static struct tgt_cmd *tgt_cmd_find(int tid, uint64_t dev_id, uint64_t tag)
 {
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 
 	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
-		(unsigned long long) cid);
+		(unsigned long long) tag);
 
 	target = target_find(tid);
 	if (!target) {
@@ -741,9 +741,9 @@
 		return NULL;
 	}
 
-	cmd = tgt_cmd_hlist_find(target, cid);
+	cmd = tgt_cmd_hlist_find(target, tag);
 	if (!cmd)
-		eprintk("Could not find rq for cid %llu\n", (unsigned long long) cid);
+		eprintk("Could not find rq for cid %llu\n", (unsigned long long) tag);
 	return cmd;
 }
 
@@ -824,7 +824,7 @@
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 
-	cmd = find_cmd_by_id(tid, dev_id, cid);
+	cmd = tgt_cmd_find(tid, dev_id, cid);
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);



From tomo at berlios.de  Fri Dec 30 06:50:06 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 06:50:06 +0100
Subject: [Stgt-svn] r219 - trunk/kernel
Message-ID: <200512300550.jBU5o6SB028987@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 06:50:02 +0100 (Fri, 30 Dec 2005)
New Revision: 219

Modified:
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
Log:
Kill unused scsi_tgt_sense_data_build.

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 04:43:53 UTC (rev 218)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 05:50:02 UTC (rev 219)
@@ -68,28 +68,6 @@
 	cmd->bufflen = data_len;
 }
 
-/* kspace command failure */
-int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
-			      uint8_t ascode, uint8_t ascodeq)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	int len = 8, alen = 6;
-	uint8_t *data = scmd->sense_buff;
-
-	memset(data, 0, sizeof(scmd->sense_buff));
-
-	data[0] = 0x70 | 1U << 7;
-	data[2] = key;
-	data[7] = alen;
-	data[12] = ascode;
-	data[13] = ascodeq;
-	cmd->result = SAM_STAT_CHECK_CONDITION;
-	scmd->sense_len = len + alen;
-
-	return len + alen;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_sense_data_build);
-
 /* uspace command failure */
 int scsi_tgt_sense_copy(struct tgt_cmd *cmd)
 {

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-12-30 04:43:53 UTC (rev 218)
+++ trunk/kernel/tgt_scsi.h	2005-12-30 05:50:02 UTC (rev 219)
@@ -25,6 +25,4 @@
 }
 
 extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
-extern int scsi_tgt_sense_data_build(struct tgt_cmd *cmd, uint8_t key,
-				     uint8_t ascode, uint8_t ascodeq);
 #endif



From tomo at berlios.de  Fri Dec 30 08:53:43 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 08:53:43 +0100
Subject: [Stgt-svn] r220 - trunk/kernel
Message-ID: <200512300753.jBU7rh8W019027@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 08:53:43 +0100 (Fri, 30 Dec 2005)
New Revision: 220

Modified:
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
Log:
Kill tags in scsi_tgt_cmd struct because the kernel module does not need to know it.

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 05:50:02 UTC (rev 219)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 07:53:43 UTC (rev 220)
@@ -57,7 +57,6 @@
 	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	scmd = tgt_cmd_to_scsi(cmd);
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
-	scmd->tags = tags;
 
 	/* is this device specific */
 	cmd->data_dir = data_dir;

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-12-30 05:50:02 UTC (rev 219)
+++ trunk/kernel/tgt_scsi.h	2005-12-30 07:53:43 UTC (rev 220)
@@ -16,7 +16,6 @@
 	uint8_t scb[MAX_COMMAND_SIZE];
 	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
 	int sense_len;
-	int tags;
 };
 
 static inline struct scsi_tgt_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)



From tomo at berlios.de  Fri Dec 30 14:12:12 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 14:12:12 +0100
Subject: [Stgt-svn] r221 - in trunk: include istgt/kernel kernel usr
Message-ID: <200512301312.jBUDCCa8031599@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 14:12:06 +0100 (Fri, 30 Dec 2005)
New Revision: 221

Added:
   trunk/include/tgt_scsi_if.h
Modified:
   trunk/include/tgt_if.h
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/kernel/iscsi.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_device.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_protocol.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_scsi.h
   trunk/usr/netlink.c
   trunk/usr/scsi.c
Log:
Move logical unit translation to user space. Device stuff will be moved to user space later.


Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/include/tgt_if.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -24,8 +24,6 @@
 	TGT_KEVENT_CMD_DONE,
 };
 
-#define	TGT_INVALID_DEV_ID	~0ULL
-
 struct tgt_event {
 	/* user-> kernel */
 	union {
@@ -53,7 +51,6 @@
 		} d_device;
 		struct {
 			int tid;
-			uint64_t dev_id;
 			uint64_t cid;
 			uint32_t len;
 			int result;
@@ -75,10 +72,8 @@
 		} event_res;
 		struct {
 			int tid;
-			uint64_t dev_id;
 			uint64_t cid;
 			int typeid;
-			int fd;
 			uint32_t data_len;
 		} cmd_req;
 		struct {

Added: trunk/include/tgt_scsi_if.h
===================================================================
--- trunk/include/tgt_scsi_if.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/include/tgt_scsi_if.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -0,0 +1,20 @@
+/*
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#ifndef __TGT_SCSI_IF_H
+#define __TGT_SCSI_IF_H
+
+#ifndef MAX_COMMAND_SIZE
+#define MAX_COMMAND_SIZE	16
+#endif
+
+struct tgt_scsi_cmd {
+	uint8_t scb[MAX_COMMAND_SIZE];
+	uint8_t lun[8];
+	int tags;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+#endif

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/istgt/kernel/iscsi.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -247,18 +247,14 @@
 	iscsi_cmnd_init_write(rsp);
 }
 
-struct iscsi_sense_data {
-	uint16_t length;
-	uint8_t  data[0];
-} __packed;
-
 static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
 {
 	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
-	struct iscsi_sense_data *sense;
-	struct scsi_tgt_cmd *stc;
+	struct iscsi_sense_data *sense = &req->sense;
 	struct scatterlist *sg = &req->sense_sg;
+	struct page *page = req->tc->sg[0].page;
+	char *p;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
@@ -269,17 +265,18 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmd_hdr(req)->itt;
 
-	stc = tgt_cmd_to_scsi(req->tc);
-	sense = (struct iscsi_sense_data *) stc->sense_buff;
-	memmove(sense->data, sense, stc->sense_len);
+	p = kmap(page);
+	memcpy(sense->sense_buff, p, sizeof(sense->sense_buff));
+	kunmap(page);
+
 	/*
 	 * this looks broken for ppc
 	 */
-	sense->length = cpu_to_be16(stc->sense_len);
+	sense->length = cpu_to_be16(tgt_scsi_sense_length(req->tc));
 
-	sg->page = virt_to_page(stc->sense_buff);
-	sg->offset = offset_in_page(stc->sense_buff);
-	sg->length = stc->sense_len + sizeof(struct iscsi_sense_data);
+	sg->page = virt_to_page(sense);
+	sg->offset = offset_in_page(sense);
+	sg->length = tgt_scsi_sense_length(req->tc) + sizeof(uint16_t);
 	rsp->pdu.datasize = sg->length;
 	rsp->sg = sg;
 
@@ -289,11 +286,11 @@
 static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
 					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
 {
-	struct scsi_tgt_cmd *stc;
 	struct istgt_cmd *rsp;
 	struct iscsi_cmd_rsp *rsp_hdr;
-	struct iscsi_sense_data *sense;
 	struct scatterlist *sg = &req->sense_sg;
+	struct iscsi_sense_data *sense = &req->sense;
+	uint8_t *data = sense->sense_buff;
 
 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
 
@@ -304,22 +301,21 @@
 	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
 	rsp_hdr->itt = cmd_hdr(req)->itt;
 
-	stc = tgt_cmd_to_scsi(req->tc);
-	sg->page = virt_to_page(stc->sense_buff);
-	sg->offset = offset_in_page(stc->sense_buff);
-	sg->length = stc->sense_len;
+	sg->page = virt_to_page(sense);
+	sg->offset = offset_in_page(sense);
 
-	sense = (struct iscsi_sense_data *) stc->sense_buff;
 	sense->length = cpu_to_be16(14);
-	sense->data[0] = 0xf0;
-	sense->data[2] = sense_key;
-	sense->data[7] = 6;	// Additional sense length
-	sense->data[12] = asc;
-	sense->data[13] = ascq;
+	data[0] = 0xf0;
+	data[2] = sense_key;
+	data[7] = 6;	// Additional sense length
+	data[12] = asc;
+	data[13] = ascq;
 
-	rsp->pdu.datasize = sizeof(struct iscsi_sense_data) + 14;
+	rsp->pdu.datasize = sizeof(uint16_t) + 14;
 	rsp->sg = sg;
 
+	sg->length = (rsp->pdu.datasize + 3) & -4;
+
 	return rsp;
 }
 

Modified: trunk/istgt/kernel/iscsi.h
===================================================================
--- trunk/istgt/kernel/iscsi.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/istgt/kernel/iscsi.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -15,6 +15,7 @@
 #include <linux/blkdev.h>
 
 #include <scsi/iscsi_proto.h>
+#include <scsi/scsi_cmnd.h>
 #include <istgt_u.h>
 
 #include <tgt.h>
@@ -156,6 +157,11 @@
 	unsigned int datasize;
 };
 
+struct iscsi_sense_data {
+	uint16_t length;
+	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
+} __attribute__((packed));
+
 struct istgt_cmd {
 	struct list_head list;
 	struct list_head conn_list;
@@ -181,6 +187,8 @@
 	struct work_struct work;
 	struct completion event;
 
+	struct iscsi_sense_data sense;
+
 	struct istgt_cmd *req;
 	struct tgt_cmd *tc;
 };

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -395,31 +395,6 @@
 	return NULL;
 }
 
-struct tgt_device *tgt_device_get(struct tgt_target *target, uint64_t dev_id)
-{
-	static struct tgt_device *device;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	device = tgt_device_find_nolock(target, dev_id);
-	if (device) {
-		if (test_bit(TGT_DEV_DEL, &device->state))
-			device = NULL;
-		else
-			class_device_get(&device->cdev);
-	}
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return device;
-}
-EXPORT_SYMBOL_GPL(tgt_device_get);
-
-void tgt_device_put(struct tgt_device *device)
-{
-	class_device_put(&device->cdev);
-}
-EXPORT_SYMBOL_GPL(tgt_device_put);
-
 int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 		      int fd, unsigned long dflags)
 {
@@ -614,8 +589,6 @@
 	tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
 
 	tgt_cmd_hlist_del(cmd);
-	if (cmd->device)
-		tgt_device_put(cmd->device);
 
 	mempool_free(cmd, cmd->session->cmd_pool);
 }
@@ -687,7 +660,6 @@
 	target->proto->cmd_create(cmd, cb, data_len, data_dir,
 				  dev_buf, dev_buf_size, flags);
 
-	cmd->device = tgt_device_get(target, cmd->dev_id);
 	cmd->session = session;
 	cmd->private = tgt_priv;
 	cmd->done = tgt_cmd_destroy;
@@ -697,8 +669,6 @@
 
 	err = tgt_cmd_hlist_add(cmd);
 	if (err) {
-		if (cmd->device)
-			tgt_device_put(cmd->device);
 		mempool_free(cmd, cmd->session->cmd_pool);
 		return NULL;
 	}
@@ -727,13 +697,12 @@
  * we should jsut pass the cmd pointer between userspace and the kernel
  * as a handle like open-iscsi
  */
-static struct tgt_cmd *tgt_cmd_find(int tid, uint64_t dev_id, uint64_t tag)
+static struct tgt_cmd *tgt_cmd_find(int tid, uint64_t tag)
 {
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 
-	dprintk("%d %llu %llu\n", tid, (unsigned long long) dev_id,
-		(unsigned long long) tag);
+	dprintk("%d %llu\n", tid, (unsigned long long) tag);
 
 	target = target_find(tid);
 	if (!target) {
@@ -817,14 +786,14 @@
 	return err;
 }
 
-int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
+int uspace_cmd_done(int tid, uint64_t cid,
 		    int result, uint32_t len, uint64_t offset,
 		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
 {
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 
-	cmd = tgt_cmd_find(tid, dev_id, cid);
+	cmd = tgt_cmd_find(tid, cid);
 	if (!cmd) {
 		eprintk("Could not find command %llu\n",
 			(unsigned long long) cid);

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -54,14 +54,12 @@
 
 struct tgt_cmd {
 	struct tgt_session *session;
-	struct tgt_device *device;
 	struct tgt_protocol *proto;
 
 	struct list_head hash_list;
 	struct list_head cqueue;
 
 	atomic_t state;
-	uint64_t dev_id;
 	unsigned long flags;
 
 	struct work_struct work;

Modified: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_device.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -51,11 +51,7 @@
         container_of(cdev, struct tgt_device, cdev)
 
 extern void tgt_device_free(struct tgt_device *device);
-extern struct tgt_device *tgt_device_get(struct tgt_target *target,
-					 uint64_t dev_id);
-extern void tgt_device_put(struct tgt_device *device);
 
-
 extern int tgt_sysfs_register_device(struct tgt_device *device);
 extern void tgt_sysfs_unregister_device(struct tgt_device *device);
 

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_nl.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -41,10 +41,8 @@
 
 	pdu = (char *) ev->data;
 	ev->k.cmd_req.tid = cmd->session->target->tid;
-	ev->k.cmd_req.dev_id = cmd->device ? cmd->dev_id : TGT_INVALID_DEV_ID;
 	ev->k.cmd_req.cid = cmd_tag(cmd);
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
-	ev->k.cmd_req.fd = cmd->device ? cmd->device->fd : 0;
 	ev->k.cmd_req.data_len = cmd->bufflen;
 
 	proto->uspace_pdu_build(cmd, pdu);
@@ -160,7 +158,7 @@
 					 ev->u.d_device.dev_id);
 		break;
 	case TGT_UEVENT_CMD_RES:
-		err = uspace_cmd_done(ev->u.cmd_res.tid, ev->u.cmd_res.dev_id,
+		err = uspace_cmd_done(ev->u.cmd_res.tid,
 				      ev->u.cmd_res.cid,
 				      ev->u.cmd_res.result, ev->u.cmd_res.len,
 				      ev->u.cmd_res.offset,

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_priv.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -8,7 +8,7 @@
 extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
 			     int fd, unsigned long dflags);
 extern int tgt_device_destroy(int tid, uint64_t dev_id);
-extern int uspace_cmd_done(int tid, uint64_t dev_id, uint64_t cid,
+extern int uspace_cmd_done(int tid, uint64_t cid,
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,
 			   uint8_t rw, uint8_t try_map);

Modified: trunk/kernel/tgt_protocol.h
===================================================================
--- trunk/kernel/tgt_protocol.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_protocol.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -38,10 +38,10 @@
 			    uint32_t data_len, enum dma_data_direction data_dir,
 			    uint8_t *dev_id_buff, int id_buff_size,
 			    int flags);
+
 	/*
 	 * Build userspace packet
 	 */
-
 	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
 
 	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -10,53 +10,32 @@
 #include <linux/highmem.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_tcq.h>
+#include <scsi/scsi_cmnd.h>
 
 #include <tgt.h>
-#include <tgt_scsi.h>
 #include <tgt_device.h>
 #include <tgt_protocol.h>
 #include <tgt_target.h>
+#include <tgt_scsi_if.h>
 
-static kmem_cache_t *scsi_tgt_cmd_cache;
+static kmem_cache_t *tgt_scsi_cmd_cache;
 
-/*
- * we should be able to use scsi-ml's functions for this
- */
-static uint64_t scsi_tgt_translate_lun(uint8_t *p, int size)
+static inline struct tgt_scsi_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)
 {
-	uint64_t lun = ~0ULL;
-
-	switch (*p >> 6) {
-	case 0:
-		lun = p[1];
-		break;
-	case 1:
-		lun = (0x3f & p[0]) << 8 | p[1];
-		break;
-	case 2:
-	case 3:
-	default:
-		break;
-	}
-
-	return lun;
+	return (struct tgt_scsi_cmd *) cmd->proto_priv;
 }
 
-/*
- * we may have to add a wrapper becuase people are passing the lun in
- * differently
- */
 static void
 scsi_tgt_cmd_create(struct tgt_cmd *cmd, uint8_t *scb,
 		    uint32_t data_len, enum dma_data_direction data_dir,
 		    uint8_t *lun, int lun_size, int tags)
 {
-	struct scsi_tgt_cmd *scmd;
+	struct tgt_scsi_cmd *scmd;
 
-	/* translate target driver LUN to device id */
-	cmd->dev_id = scsi_tgt_translate_lun(lun, lun_size);
 	scmd = tgt_cmd_to_scsi(cmd);
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
+	memcpy(scmd->lun, lun, sizeof(scmd->lun));
+	scmd->tags = tags;
 
 	/* is this device specific */
 	cmd->data_dir = data_dir;
@@ -67,40 +46,18 @@
 	cmd->bufflen = data_len;
 }
 
-/* uspace command failure */
-int scsi_tgt_sense_copy(struct tgt_cmd *cmd)
-{
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
-	uint8_t *data = scmd->sense_buff;
-	int len;
-
-	memset(data, 0, sizeof(scmd->sense_buff));
-	len = min_t(int, cmd->bufflen, sizeof(scmd->sense_buff));
-
-	/* userspace did everything for us */
-	memcpy(data, page_address(cmd->sg[0].page), len);
-	scmd->sense_len = len;
-
-	return len;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_sense_copy);
-
 static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
 {
-	struct scsi_tgt_cmd *scmd = (struct scsi_tgt_cmd *)cmd->proto_priv;
-	memcpy(data, scmd->scb, sizeof(scmd->scb));
+	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	memcpy(data, scmd, sizeof(struct tgt_scsi_cmd));
 }
 
 static void scsi_tgt_uspace_cmd_complete(struct tgt_cmd *cmd)
 {
-	struct scsi_tgt_cmd *scmd = tgt_cmd_to_scsi(cmd);
+	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
-	dprintk("%d %lu\n", cmd->result, cmd->uaddr);
-
-	if (cmd->result != SAM_STAT_GOOD)
-		scsi_tgt_sense_copy(cmd);
-
-	dprintk("res %d, cmd %p op 0x%02x\n", cmd->result, cmd, scmd->scb[0]);
+	dprintk("res %d, cmd %p op 0x%02x %lx\n", cmd->result, cmd, scmd->scb[0],
+		cmd->uaddr);
 }
 
 static struct tgt_protocol scsi_tgt_proto = {
@@ -109,21 +66,21 @@
 	.cmd_create = scsi_tgt_cmd_create,
 	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
 	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
-	.uspace_pdu_size = MAX_COMMAND_SIZE,
+	.uspace_pdu_size = sizeof(struct tgt_scsi_cmd),
 };
 
 static int __init scsi_tgt_init(void)
 {
 	int err;
-	size_t size = sizeof(struct tgt_cmd) + sizeof(struct scsi_tgt_cmd);
+	size_t size = sizeof(struct tgt_cmd) + sizeof(struct tgt_scsi_cmd);
 
-	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
+	tgt_scsi_cmd_cache = kmem_cache_create("tgt_scsi_cmd",
 					       size, 0,
 					       SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
 					       NULL, NULL);
-	if (!scsi_tgt_cmd_cache)
+	if (!tgt_scsi_cmd_cache)
 		return -ENOMEM;
-	scsi_tgt_proto.cmd_cache = scsi_tgt_cmd_cache;
+	scsi_tgt_proto.cmd_cache = tgt_scsi_cmd_cache;
 
 	err = tgt_protocol_register(&scsi_tgt_proto);
 	if (err)
@@ -131,14 +88,14 @@
 
 	return 0;
 cache_destroy:
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
+	kmem_cache_destroy(tgt_scsi_cmd_cache);
 
 	return err;
 }
 
 static void __exit scsi_tgt_exit(void)
 {
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
+	kmem_cache_destroy(tgt_scsi_cmd_cache);
 	tgt_protocol_unregister(&scsi_tgt_proto);
 }
 

Modified: trunk/kernel/tgt_scsi.h
===================================================================
--- trunk/kernel/tgt_scsi.h	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/kernel/tgt_scsi.h	2005-12-30 13:12:06 UTC (rev 221)
@@ -10,18 +10,7 @@
 #define __TGT_SCSI_H
 
 #include <tgt.h>
-#include <scsi/scsi_cmnd.h>
 
-struct scsi_tgt_cmd {
-	uint8_t scb[MAX_COMMAND_SIZE];
-	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
-	int sense_len;
-};
+#define	tgt_scsi_sense_length(cmd)	(cmd)->bufflen
 
-static inline struct scsi_tgt_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)
-{
-	return (struct scsi_tgt_cmd *) cmd->proto_priv;
-}
-
-extern int scsi_tgt_sense_copy(struct tgt_cmd *cmd);
 #endif

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/usr/netlink.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -113,35 +113,32 @@
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
 	uint64_t offset, cid = ev_req->k.cmd_req.cid;
-	uint8_t *scb, rw = 0, try_map = 0;
+	uint8_t *pdu, rw = 0, try_map = 0;
 	unsigned long uaddr;
-	int (*fn) (int, uint64_t, uint8_t *, int *, int, uint32_t,
+	int (*fn) (int, uint8_t *, int *, uint32_t,
 		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
 
 	memset(resbuf, 0, NL_BUFSIZE);
-	scb = (uint8_t *) ev_req->data;
-	dprintf("%" PRIu64 " %x\n", cid, scb[0]);
+	pdu = (uint8_t *) ev_req->data;
+	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
 
 	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid,
 				  ev_req->k.cmd_req.typeid);
 
 	if (fn)
 		result = fn(ev_req->k.cmd_req.tid,
-			    ev_req->k.cmd_req.dev_id,
-			    scb,
+			    pdu,
 			    &len,
-			    ev_req->k.cmd_req.fd,
 			    ev_req->k.cmd_req.data_len,
 			    &uaddr, &rw, &try_map, &offset);
 	else {
 		result = -EINVAL;
-		eprintf("Cannot process cmd %d %" PRIu64 " %" PRIu64 "\n",
-			ev_req->k.cmd_req.tid, ev_req->k.cmd_req.dev_id, cid);
+		eprintf("Cannot process cmd %d %" PRIu64 "\n",
+			ev_req->k.cmd_req.tid, cid);
 	}
 
 	memset(ev_res, 0, (char *) ev_res->data - (char *) ev_res);
 	ev_res->u.cmd_res.tid = ev_req->k.cmd_req.tid;
-	ev_res->u.cmd_res.dev_id = ev_req->k.cmd_req.dev_id;
 	ev_res->u.cmd_res.cid = cid;
 	ev_res->u.cmd_res.len = len;
 	ev_res->u.cmd_res.result = result;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2005-12-30 07:53:43 UTC (rev 220)
+++ trunk/usr/scsi.c	2005-12-30 13:12:06 UTC (rev 221)
@@ -32,6 +32,7 @@
 
 #include "tgtd.h"
 #include "tgt_if.h"
+#include "tgt_scsi_if.h"
 #include "tgt_sysfs.h"
 
 #define cpu_to_be32 __cpu_to_be32
@@ -411,6 +412,37 @@
 	return SAM_STAT_GOOD;
 }
 
+static int getfd(int tid, uint64_t lun)
+{
+	int fd, err;
+	char path[PATH_MAX], buf[PATH_MAX];
+
+	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
+		tid, lun);
+
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		log_error("scsi sync_cache could not get LU's fd err %d",
+			  errno);
+		goto out;
+	}
+
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		log_error("scsi sync_cache could not read LUN path err %d",
+			  errno);
+		fd = -EIO;
+		goto out;
+	}
+
+	fd = 0;
+	sscanf(buf, "%d\n", &fd);
+
+out:
+	return fd;
+}
+
 static int sync_cache(int tid, uint64_t lun, uint8_t *scb, uint8_t *data,
 		      int *len)
 {
@@ -566,14 +598,39 @@
 	return result;
 }
 
-int cmd_process(int tid, uint64_t lun, uint8_t *scb, int *len,
-		int fd, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+#define	TGT_INVALID_DEV_ID	~0ULL
+
+static uint64_t translate_lun(uint8_t *p, int size)
+{
+	uint64_t lun = TGT_INVALID_DEV_ID;
+
+	switch (*p >> 6) {
+	case 0:
+		lun = p[1];
+		break;
+	case 1:
+		lun = (0x3f & p[0]) << 8 | p[1];
+		break;
+	case 2:
+	case 3:
+	default:
+		break;
+	}
+
+	return lun;
+}
+
+int cmd_process(int tid, uint8_t *pdu, int *len,
+		uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		uint8_t *try_map, uint64_t *offset)
 {
-	int result = SAM_STAT_GOOD;
-	uint8_t *data = NULL;
+	int fd, result = SAM_STAT_GOOD;
+	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
+	uint8_t *data = NULL, *scb = scmd->scb;
+	uint64_t lun;
 
-	dprintf("%d %" PRIu64 " %x %d %u\n", tid, lun, scb[0], fd, datalen);
+	lun = translate_lun(scmd->lun, sizeof(scmd->lun));
+	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
 
 	*offset = 0;
 	if (!mmap_cmd_init(scb, rw))
@@ -629,10 +686,15 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		result = mmap_device(tid, lun, scb, len, fd, datalen, uaddr, offset);
-		if (result == SAM_STAT_GOOD)
-			*try_map = 1;
-		else {
+		fd = getfd(tid, lun);
+		if (fd >= 0) {
+			result = mmap_device(tid, lun, scb, len, fd, datalen,
+					     uaddr, offset);
+			if (result == SAM_STAT_GOOD)
+				*try_map = 1;
+		}
+
+		if (fd < 0 || result != SAM_STAT_GOOD) {
 			*offset = 0;
 			if (!data)
 				data = valloc(PAGE_SIZE);



From tomo at berlios.de  Fri Dec 30 14:21:04 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 14:21:04 +0100
Subject: [Stgt-svn] r222 - trunk/kernel
Message-ID: <200512301321.jBUDL4qp005524@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 14:21:02 +0100 (Fri, 30 Dec 2005)
New Revision: 222

Modified:
   trunk/kernel/tgt_scsi.c
Log:
Just clean up tgt_scsi.c

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 13:12:06 UTC (rev 221)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 13:21:02 UTC (rev 222)
@@ -26,18 +26,16 @@
 }
 
 static void
-scsi_tgt_cmd_create(struct tgt_cmd *cmd, uint8_t *scb,
+tgt_scsi_cmd_create(struct tgt_cmd *cmd, uint8_t *scb,
 		    uint32_t data_len, enum dma_data_direction data_dir,
 		    uint8_t *lun, int lun_size, int tags)
 {
-	struct tgt_scsi_cmd *scmd;
+	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
 
-	scmd = tgt_cmd_to_scsi(cmd);
 	memcpy(scmd->scb, scb, sizeof(scmd->scb));
 	memcpy(scmd->lun, lun, sizeof(scmd->lun));
 	scmd->tags = tags;
 
-	/* is this device specific */
 	cmd->data_dir = data_dir;
 	/*
 	 * set bufflen based on data_len for now, but let device specific
@@ -46,30 +44,22 @@
 	cmd->bufflen = data_len;
 }
 
-static void scsi_tgt_uspace_pdu_build(struct tgt_cmd *cmd, void *data)
+static void tgt_scsi_pdu_build(struct tgt_cmd *cmd, void *data)
 {
 	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
+
 	memcpy(data, scmd, sizeof(struct tgt_scsi_cmd));
 }
 
-static void scsi_tgt_uspace_cmd_complete(struct tgt_cmd *cmd)
-{
-	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	dprintk("res %d, cmd %p op 0x%02x %lx\n", cmd->result, cmd, scmd->scb[0],
-		cmd->uaddr);
-}
-
-static struct tgt_protocol scsi_tgt_proto = {
+static struct tgt_protocol tgt_scsi_proto = {
 	.name = "scsi",
 	.module = THIS_MODULE,
-	.cmd_create = scsi_tgt_cmd_create,
-	.uspace_pdu_build = scsi_tgt_uspace_pdu_build,
-	.uspace_cmd_complete = scsi_tgt_uspace_cmd_complete,
+	.cmd_create = tgt_scsi_cmd_create,
+	.uspace_pdu_build = tgt_scsi_pdu_build,
 	.uspace_pdu_size = sizeof(struct tgt_scsi_cmd),
 };
 
-static int __init scsi_tgt_init(void)
+static int __init tgt_scsi_init(void)
 {
 	int err;
 	size_t size = sizeof(struct tgt_cmd) + sizeof(struct tgt_scsi_cmd);
@@ -80,9 +70,9 @@
 					       NULL, NULL);
 	if (!tgt_scsi_cmd_cache)
 		return -ENOMEM;
-	scsi_tgt_proto.cmd_cache = tgt_scsi_cmd_cache;
+	tgt_scsi_proto.cmd_cache = tgt_scsi_cmd_cache;
 
-	err = tgt_protocol_register(&scsi_tgt_proto);
+	err = tgt_protocol_register(&tgt_scsi_proto);
 	if (err)
 		goto cache_destroy;
 
@@ -93,12 +83,12 @@
 	return err;
 }
 
-static void __exit scsi_tgt_exit(void)
+static void __exit tgt_scsi_exit(void)
 {
 	kmem_cache_destroy(tgt_scsi_cmd_cache);
-	tgt_protocol_unregister(&scsi_tgt_proto);
+	tgt_protocol_unregister(&tgt_scsi_proto);
 }
 
-module_init(scsi_tgt_init);
-module_exit(scsi_tgt_exit);
+module_init(tgt_scsi_init);
+module_exit(tgt_scsi_exit);
 MODULE_LICENSE("GPL");



From tomo at berlios.de  Fri Dec 30 14:27:17 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 14:27:17 +0100
Subject: [Stgt-svn] r223 - in trunk: include kernel
Message-ID: <200512301327.jBUDRHxS008675@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 14:26:51 +0100 (Fri, 30 Dec 2005)
New Revision: 223

Modified:
   trunk/include/tgt_scsi_if.h
   trunk/kernel/tgt_scsi.c
Log:
Clean up again.

Modified: trunk/include/tgt_scsi_if.h
===================================================================
--- trunk/include/tgt_scsi_if.h	2005-12-30 13:21:02 UTC (rev 222)
+++ trunk/include/tgt_scsi_if.h	2005-12-30 13:26:51 UTC (rev 223)
@@ -7,7 +7,7 @@
 #ifndef __TGT_SCSI_IF_H
 #define __TGT_SCSI_IF_H
 
-#ifndef MAX_COMMAND_SIZE
+#ifndef __KERNEL__
 #define MAX_COMMAND_SIZE	16
 #endif
 

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 13:21:02 UTC (rev 222)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 13:26:51 UTC (rev 223)
@@ -5,11 +5,8 @@
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  * This code is licenced under the GPL.
  */
+
 #include <linux/module.h>
-#include <linux/mm.h>
-#include <linux/highmem.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_tcq.h>
 #include <scsi/scsi_cmnd.h>
 
 #include <tgt.h>



From tomo at berlios.de  Fri Dec 30 16:51:51 2005
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 30 Dec 2005 16:51:51 +0100
Subject: [Stgt-svn] r224 - in trunk: include kernel usr
Message-ID: <200512301551.jBUFppWs029334@sheep.berlios.de>

Author: tomo
Date: 2005-12-30 16:51:50 +0100 (Fri, 30 Dec 2005)
New Revision: 224

Added:
   trunk/usr/tgt_device.c
Removed:
   trunk/kernel/tgt_device.h
Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt.c
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_scsi.c
   trunk/kernel/tgt_sysfs.c
   trunk/kernel/tgt_target.h
   trunk/usr/Makefile
   trunk/usr/mgmt.c
   trunk/usr/tgt_sysfs.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Kill tgt_device stuff in kernel. Now tgtd creates /var/run/tgt_device directroy and works in the same way. This is a makeshift solution and should be replaced soon.


Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/include/tgt_if.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -13,8 +13,6 @@
 	TGT_UEVENT_TARGET_CREATE,
 	TGT_UEVENT_TARGET_DESTROY,
 	TGT_UEVENT_TARGET_PASSTHRU,
-	TGT_UEVENT_DEVICE_CREATE,
-	TGT_UEVENT_DEVICE_DESTROY,
 	TGT_UEVENT_CMD_RES,
 
 	/* kernel -> user */
@@ -40,17 +38,6 @@
 		} tgt_passthru;
 		struct {
 			int tid;
-			uint64_t dev_id;
-			uint32_t flags;
-			char type[32];
-			int fd;
-		} c_device;
-		struct {
-			int tid;
-			uint64_t dev_id;
-		} d_device;
-		struct {
-			int tid;
 			uint64_t cid;
 			uint32_t len;
 			int result;

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -19,7 +19,6 @@
 
 #include <tgt.h>
 #include <tgt_target.h>
-#include <tgt_device.h>
 #include <tgt_if.h>
 #include <tgt_protocol.h>
 
@@ -35,9 +34,6 @@
 static spinlock_t target_tmpl_lock;
 static LIST_HEAD(target_tmpl_list);
 
-static spinlock_t device_tmpl_lock;
-static LIST_HEAD(device_tmpl_list);
-
 static struct target_type_internal *target_template_get(const char *name)
 {
 	unsigned long flags;
@@ -225,7 +221,6 @@
 	init_MUTEX(&target->uspace_sem);
 
 	INIT_LIST_HEAD(&target->session_list);
-	INIT_LIST_HEAD(&target->device_list);
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hlist); i++)
 		INIT_LIST_HEAD(&target->cmd_hlist[i]);
 	INIT_LIST_HEAD(&target->uspace_cmd_queue);
@@ -277,10 +272,6 @@
 	dprintk("%p\n", target);
 
 	spin_lock_irqsave(&target->lock, flags);
-	if (!list_empty(&target->device_list)) {
-		spin_unlock_irqrestore(&target->lock, flags);
-		return -EBUSY;
-	}
 	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
 	if (target->state == TGT_DESTROYED)
 		return -ENODEV;
@@ -380,126 +371,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_session_destroy);
 
-/*
- * TODO: use a hash or any better alg/ds
- */
-static struct tgt_device *
-tgt_device_find_nolock(struct tgt_target *target, uint64_t dev_id)
-{
-	struct tgt_device *device;
-
-	list_for_each_entry(device, &target->device_list, dlist)
-		if (device->dev_id == dev_id)
-			return device;
-
-	return NULL;
-}
-
-int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
-		      int fd, unsigned long dflags)
-{
-	struct tgt_target *target;
-	struct tgt_device *device;
-	unsigned long flags;
-	struct inode *inode;
-
-	dprintk("tid %d dev_id %" PRIu64 " type %s fd %d\n",
-		tid, dev_id, device_type, fd);
-
-	target = target_find(tid);
-	if (!target)
-		return -EINVAL;
-
-	device = kzalloc(sizeof(*device), GFP_KERNEL);
-	if (!device)
-		return -ENOMEM;
-
-	device->dev_id = dev_id;
-	device->target = target;
-	device->fd = fd;
-
-	device->file = fget(fd);
-	if (!device->file) {
-		eprintk("Could not get fd %d\n", fd);
-		goto free_device;
-	}
-
-	/* TODO: kill me */
-	inode = device->file->f_dentry->d_inode;
-	if (S_ISREG(inode->i_mode))
-		;
-	else if (S_ISBLK(inode->i_mode))
-		inode = inode->i_bdev->bd_inode;
-
-	device->size = inode->i_size;
-
-	if (tgt_sysfs_register_device(device))
-		goto put_fd;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add(&device->dlist, &target->device_list);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return 0;
-
-put_fd:
-	fput(device->file);
-free_device:
-	kfree(device);
-	return -EINVAL;
-}
-
-void tgt_device_free(struct tgt_device *device)
-{
-	struct tgt_target *target = device->target;
-	unsigned long flags;
-
-	dprintk("%d %lld\n", target->tid, (unsigned long long) device->dev_id);
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_del(&device->dlist);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	fput(device->file);
-
-	kfree(device);
-}
-
-int tgt_device_destroy(int tid, uint64_t dev_id)
-{
-	struct tgt_device *device;
-	struct tgt_target *target;
-	unsigned long flags;
-	int err = 0;
-
-	target = target_find(tid);
-	if (!target)
-		return -ENOENT;
-
-	/*
-	 * We cannot delete the device from the list because
-	 * uspace_cmd_done would use it later.
-	 */
-	spin_lock_irqsave(&target->lock, flags);
-	device = tgt_device_find_nolock(target, dev_id);
-	if (device)
-		err = test_and_set_bit(TGT_DEV_DEL, &device->state);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	if (!device)
-		return -ENOENT;
-
-	if (err) {
-		eprintk("the device is being removed %d %lld\n",
-			tid, (unsigned long long) dev_id);
-		return -EBUSY;
-	} else {
-		/* TODO: revoke commands in the devece queue here. */
-		tgt_sysfs_unregister_device(device);
-		return 0;
-	}
-}
-
 static void tgt_unmap_user_pages(struct tgt_cmd *cmd)
 {
 	struct page *page;
@@ -846,7 +717,6 @@
 
 	spin_lock_init(&all_targets_lock);
 	spin_lock_init(&target_tmpl_lock);
-	spin_lock_init(&device_tmpl_lock);
 
 	tgt_protocol_init();
 

Deleted: trunk/kernel/tgt_device.h
===================================================================
--- trunk/kernel/tgt_device.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_device.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -1,58 +0,0 @@
-/*
- * Target Framework Device definitions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#ifndef __TGT_DEVICE_H
-#define __TGT_DEVICE_H
-
-#include <linux/blkdev.h>
-#include <linux/device-mapper.h>
-#include <linux/device.h>
-#include <linux/list.h>
-
-struct tgt_device;
-struct tgt_cmd;
-
-enum {
-	TGT_CMD_COMPLETED,
-	TGT_CMD_FAILED,
-	/*
-	 * if the device has queued the command it is responsible for
-	 * for completing it
-	 */
-	TGT_CMD_USPACE_QUEUED,
-	TGT_CMD_KERN_QUEUED,
-	TGT_DEV_DEL = 0,
-};
-
-/*
- * TODO: we could do a queue per target instead of per device and kill
- * all the tgt_device code
- */
-struct tgt_device {
-	struct class_device cdev;
-
-	int fd;
-	struct file *file;
-	uint64_t dev_id;
-	uint32_t blk_shift;
-	uint64_t size;
-
-	unsigned long state;
-
-	struct tgt_target *target;
-	struct list_head dlist;
-};
-
-#define cdev_to_tgt_device(cdev) \
-        container_of(cdev, struct tgt_device, cdev)
-
-extern void tgt_device_free(struct tgt_device *device);
-
-extern int tgt_sysfs_register_device(struct tgt_device *device);
-extern void tgt_sysfs_unregister_device(struct tgt_device *device);
-
-#endif

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_nl.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -11,7 +11,6 @@
 
 #include <tgt.h>
 #include <tgt_target.h>
-#include <tgt_device.h>
 #include <tgt_if.h>
 #include <tgt_protocol.h>
 #include "tgt_priv.h"
@@ -146,17 +145,6 @@
 		err = target->tt->msg_recv(target, ev->u.tgt_passthru.len,
 					   ev->data);
 		break;
-	case TGT_UEVENT_DEVICE_CREATE:
-		err = tgt_device_create(ev->u.c_device.tid,
-					ev->u.c_device.dev_id,
-					ev->u.c_device.type,
-					ev->u.c_device.fd,
-					ev->u.c_device.flags);
-		break;
-	case TGT_UEVENT_DEVICE_DESTROY:
-		err = tgt_device_destroy(ev->u.d_device.tid,
-					 ev->u.d_device.dev_id);
-		break;
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid,
 				      ev->u.cmd_res.cid,

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_priv.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -5,9 +5,6 @@
 
 /* tgt core */
 extern struct tgt_target *target_find(int tid);
-extern int tgt_device_create(int tid, uint64_t dev_id, char *device_type,
-			     int fd, unsigned long dflags);
-extern int tgt_device_destroy(int tid, uint64_t dev_id);
 extern int uspace_cmd_done(int tid, uint64_t cid,
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,

Modified: trunk/kernel/tgt_scsi.c
===================================================================
--- trunk/kernel/tgt_scsi.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_scsi.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -10,7 +10,6 @@
 #include <scsi/scsi_cmnd.h>
 
 #include <tgt.h>
-#include <tgt_device.h>
 #include <tgt_protocol.h>
 #include <tgt_target.h>
 #include <tgt_scsi_if.h>

Modified: trunk/kernel/tgt_sysfs.c
===================================================================
--- trunk/kernel/tgt_sysfs.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_sysfs.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -7,7 +7,6 @@
  */
 #include <tgt_types.h>
 #include <tgt_target.h>
-#include <tgt_device.h>
 
 #include "tgt_priv.h"
 
@@ -199,85 +198,6 @@
 	class_device_unregister(&target->cdev);
 }
 
-/*
- * Device files
- */
-#define tgt_device_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct tgt_device *device = cdev_to_tgt_device(cdev);		\
-	return sprintf(buf, format_string, device->field);	\
-}
-
-#define tgt_device_rd_attr(field, format_string)		\
-	tgt_device_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-tgt_device_rd_attr(fd, "%d\n");
-tgt_device_rd_attr(size, "%" PRIu64 "\n");
-
-static struct class_device_attribute *tgt_device_attrs[] = {
-	&class_device_attr_fd,
-	&class_device_attr_size,
-	NULL,
-};
-
-static void tgt_device_class_release(struct class_device *cdev)
-{
-	struct tgt_device *device = cdev_to_tgt_device(cdev);
-	struct class_device *parent = &device->target->cdev;
-
-	tgt_device_free(device);
-	class_device_put(parent);
-}
-
-static struct class tgt_device_class = {
-	.name = "tgt_device",
-	.release = tgt_device_class_release,
-};
-
-int tgt_sysfs_register_device(struct tgt_device *device)
-{
-	struct tgt_target *target = device->target;
-	struct class_device *cdev = &device->cdev;
-	int err, i;
-
-	cdev->class = &tgt_device_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "device%d:%" PRIu64,
-		 target->tid, device->dev_id);
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	/*
-	 * get handle to target so our parent is never released before
-	 * us
-	 */
-	if (!class_device_get(&target->cdev))
-		return -EINVAL;
-
-	for (i = 0; tgt_device_attrs[i]; i++) {
-		err = class_device_create_file(&device->cdev,
-					       tgt_device_attrs[i]);
-		if (err)
-			goto cleanup;
-	}
-
-	return 0;
-
-cleanup:
-	class_device_put(&target->cdev);
-	class_device_unregister(cdev);
-	return err;
-
-}
-
-void tgt_sysfs_unregister_device(struct tgt_device *device)
-{
-	class_device_unregister(&device->cdev);
-}
-
 int tgt_sysfs_init(void)
 {
 	int err;
@@ -290,14 +210,8 @@
 	if (err)
 		goto unregister_type;
 
-	err = class_register(&tgt_device_class);
-	if (err)
-		goto unregister_target;
-
 	return 0;
 
-unregister_target:
-	class_unregister(&tgt_target_class);
 unregister_type:
 	class_unregister(&tgt_type_class);
 
@@ -308,5 +222,4 @@
 {
 	class_unregister(&tgt_type_class);
 	class_unregister(&tgt_target_class);
-	class_unregister(&tgt_device_class);
 }

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/kernel/tgt_target.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -109,14 +109,13 @@
 	int queued_cmds;
 	int state;
 
-	/* Protects session_list, device_list, cmd_hlist, and state */
+	/* Protects session_list, cmd_hlist, and state */
 	spinlock_t lock;
 
 	/* Serializes commands going to user space */
 	struct semaphore uspace_sem;
 	struct list_head tlist;
 
-	struct list_head device_list;
 	struct list_head session_list;
 	struct list_head cmd_hlist[1 << TGT_CMD_HASH_ORDER];
 

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/Makefile	2005-12-30 15:51:50 UTC (rev 224)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o log.o
+tgtd: tgtd.o tgt_device.o netlink.o ipc.o dl.o mgmt.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/mgmt.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -98,23 +98,6 @@
 				 __ktarget_destroy);
 }
 
-struct kdevice_create_info {
-	int fd;
-	char devtype[256];
-};
-
-static void __kdevice_create(struct tgt_event *ev, struct tgtadm_req *req)
-{
-	struct kdevice_create_info *info =
-		(struct kdevice_create_info *) ((char *) req + sizeof(*req));
-
-	ev->u.c_device.tid = req->tid;
-	ev->u.c_device.dev_id = req->lun;
-	ev->u.c_device.fd = info->fd;
-	strncpy(ev->u.c_device.type, info->devtype,
-		sizeof(ev->u.c_device.type));
-}
-
 void kdevice_create_parser(char *args, char **path, char **devtype)
 {
 	char *p, *q;
@@ -141,46 +124,28 @@
 
 int kdevice_create(int tid, uint64_t devid, char *path, char *devtype)
 {
-	int fd;
-	char buf[sizeof(struct tgtadm_req) + sizeof(struct kdevice_create_info)];
-	struct tgtadm_req *req;
-	struct kdevice_create_info *info;
+	int fd, err;
 
 	dprintf("%d %" PRIu64 " %s %s\n", tid, devid, path, devtype);
 
-	req = (struct tgtadm_req *) buf;
-	info = (struct kdevice_create_info *) (buf + sizeof(*req));
-
-	req->tid = tid;
-	req->lun = devid;
-
 	fd = open(path, O_RDWR | O_LARGEFILE);
 	if (fd < 0) {
 		eprintf("Could not open %s errno %d\n", path, errno);
 		return -errno;
 	}
-	info->fd = fd;
-	strncpy(info->devtype, devtype, sizeof(info->devtype));
 
-	return tgt_event_execute(req, TGT_UEVENT_DEVICE_CREATE,
-				 __kdevice_create);
-}
+	err = tgt_device_create(tid, devid, fd);
+	if (err < 0)
+		close(fd);
 
-static void __kdevice_destroy(struct tgt_event *ev, struct tgtadm_req *req)
-{
-	ev->u.d_device.tid = req->tid;
-	ev->u.d_device.dev_id = req->lun;
+	return err;
 }
 
 int kdevice_destroy(int tid, uint64_t devid)
 {
 	int fd, err;
-	struct tgtadm_req req;
 	char path[PATH_MAX], buf[PATH_MAX];
 
-	req.tid = tid;
-	req.lun = devid;
-
 	dprintf("%u %" PRIu64 "\n", tid, devid);
 
 	snprintf(path, sizeof(path),
@@ -199,8 +164,8 @@
 	}
 	sscanf(buf, "%d\n", &fd);
 
-	err = tgt_event_execute(&req, TGT_UEVENT_DEVICE_DESTROY,
-				__kdevice_destroy);
+	err = tgt_device_destroy(tid, devid);
+
 	if (!err)
 		close(fd);
 

Added: trunk/usr/tgt_device.c
===================================================================
--- trunk/usr/tgt_device.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/tgt_device.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -0,0 +1,140 @@
+/*
+ * target framework Device
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+/*
+ * This is just makeshift for removing device stuff in kernel space
+ * and should be replaced soon.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <errno.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <linux/fs.h>
+
+#include "tgtd.h"
+#include "tgt_sysfs.h"
+
+static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
+static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+
+int tgt_device_create(int tid, uint64_t lun, int dfd)
+{
+	int err, fd;
+	struct stat st;
+	char path[PATH_MAX], buf[32];
+	uint64_t size;
+
+	err = ioctl(dfd, BLKGETSIZE64, &size);
+	if (err < 0) {
+		eprintf("Cannot get size %d\n", dfd);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
+	err = stat(path, &st);
+	if (err < 0) {
+		eprintf("Cannot find target %d\n", tid);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
+		 tid, lun);
+
+	err = mkdir(path, dmode);
+	if (err < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
+		 tid, lun);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+	snprintf(buf, sizeof(buf), "%d", dfd);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot write %s\n", path);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
+		 tid, lun);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+	snprintf(buf, sizeof(buf), "%" PRIu64, size);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot write %s\n", path);
+		return err;
+	}
+
+	return 0;
+}
+
+int tgt_device_destroy(int tid, uint64_t lun)
+{
+	char path[PATH_MAX];
+	int err;
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
+		 tid, lun);
+	err = unlink(path);
+	if (err < 0) {
+		eprintf("Cannot unlink %s\n", path);
+		goto out;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
+		 tid, lun);
+	err = unlink(path);
+	if (err < 0) {
+		eprintf("Cannot unlink %s\n", path);
+		goto out;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
+		 tid, lun);
+	err = rmdir(path);
+	if (err < 0)
+		eprintf("Cannot unlink %s\n", path);
+
+out:
+	return err;
+}
+
+int tgt_device_init(void)
+{
+	int err;
+
+	rmdir(TGT_DEVICE_SYSFSDIR);
+	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
+	if (err < 0)
+		perror("Cannot create");
+
+	return err;
+}

Modified: trunk/usr/tgt_sysfs.h
===================================================================
--- trunk/usr/tgt_sysfs.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/tgt_sysfs.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -3,6 +3,6 @@
 
 #define	TGT_TYPE_SYSFSDIR	"/sys/class/tgt_type"
 #define	TGT_TARGET_SYSFSDIR	"/sys/class/tgt_target"
-#define	TGT_DEVICE_SYSFSDIR	"/sys/class/tgt_device"
+#define	TGT_DEVICE_SYSFSDIR	"/var/run/tgt_device"
 
 #endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/tgtd.c	2005-12-30 15:51:50 UTC (rev 224)
@@ -197,6 +197,9 @@
 		setsid();
 	}
 
+	if (tgt_device_init() < 0)
+		exit(0);
+
 	nl_fd = nl_open();
 	if (nl_fd < 0)
 		exit(nl_fd);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2005-12-30 13:26:51 UTC (rev 223)
+++ trunk/usr/tgtd.h	2005-12-30 15:51:50 UTC (rev 224)
@@ -12,4 +12,8 @@
 extern int ipc_open(void);
 extern void ipc_event_handle(int fd);
 
+extern int tgt_device_init(void);
+extern int tgt_device_create(int tid, uint64_t lun, int dfd);
+extern int tgt_device_destroy(int tid, uint64_t lun);
+
 #endif



