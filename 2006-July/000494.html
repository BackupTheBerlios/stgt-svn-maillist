<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r507 - trunk/patchset
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r507%20-%20trunk/patchset&In-Reply-To=%3C200607260505.k6Q55K58029755%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000493.html">
   <LINK REL="Next"  HREF="000495.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r507 - trunk/patchset</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r507%20-%20trunk/patchset&In-Reply-To=%3C200607260505.k6Q55K58029755%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r507 - trunk/patchset">tomo at mail.berlios.de
       </A><BR>
    <I>Wed Jul 26 07:05:20 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000493.html">[Stgt-svn] r506 - trunk/patchset
</A></li>
        <LI>Next message: <A HREF="000495.html">[Stgt-svn] r508 - trunk/patchset
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#494">[ date ]</a>
              <a href="thread.html#494">[ thread ]</a>
              <a href="subject.html#494">[ subject ]</a>
              <a href="author.html#494">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-07-26 07:05:04 +0200 (Wed, 26 Jul 2006)
New Revision: 507

Added:
   trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   trunk/patchset/0005-scsi-target-kill-target-command-list.txt
Log:
Add the latest patchset.

Added: trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,583 @@
+Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
+From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: 1143376921 +0900
+
+---
+
+ drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
+ drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
+ drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
+ drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
+ 4 files changed, 142 insertions(+), 125 deletions(-)
+
+74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
+index eaefedd..e7bd028 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
+@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
+ 			++in_use;
+ 		if (pool-&gt;events[i].ext_list) {
+ 			dma_free_coherent(hostdata-&gt;dev,
+-				  SG_ALL * sizeof(struct memory_descriptor),
++				  SG_ALL * sizeof(struct srp_direct_buf),
+ 				  pool-&gt;events[i].ext_list,
+ 				  pool-&gt;events[i].ext_list_token);
+ 		}
+@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
+ 			      struct srp_cmd *srp_cmd, 
+ 			      int numbuf)
+ {
++	u8 fmt;
++
+ 	if (numbuf == 0)
+ 		return;
+ 	
+-	if (numbuf == 1) {
++	if (numbuf == 1)
++		fmt = SRP_DATA_DESC_DIRECT;
++	else {
++		fmt = SRP_DATA_DESC_INDIRECT;
++		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
++
+ 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
+-			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
+-		else 
+-			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
+-	} else {
+-		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
+-			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd-&gt;data_out_count =
+-				numbuf &lt; MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		} else {
+-			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd-&gt;data_in_count =
+-				numbuf &lt; MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		}
++			srp_cmd-&gt;data_out_desc_cnt = numbuf;
++		else
++			srp_cmd-&gt;data_in_desc_cnt = numbuf;
+ 	}
++
++	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
++		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
++	else
++		srp_cmd-&gt;buf_fmt = fmt;
+ }
+ 
+-static void unmap_sg_list(int num_entries, 
++static void unmap_sg_list(int num_entries,
+ 		struct device *dev,
+-		struct memory_descriptor *md)
+-{ 
++		struct srp_direct_buf *md)
++{
+ 	int i;
+ 
+-	for (i = 0; i &lt; num_entries; ++i) {
+-		dma_unmap_single(dev,
+-			md[i].virtual_address,
+-			md[i].length, DMA_BIDIRECTIONAL);
+-	}
++	for (i = 0; i &lt; num_entries; ++i)
++		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
+ }
+ 
+ /**
+@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
+ 			   struct srp_event_struct *evt_struct,
+ 			   struct device *dev)
+ {
+-	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
+-	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
++	u8 out_fmt, in_fmt;
++
++	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
++	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++
++	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
+ 		return;
+-	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
+-		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
+-		struct memory_descriptor *data =
+-			(struct memory_descriptor *)cmd-&gt;additional_data;
+-		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
+-				 DMA_BIDIRECTIONAL);
++	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
++		 in_fmt == SRP_DATA_DESC_DIRECT) {
++		struct srp_direct_buf *data =
++			(struct srp_direct_buf *) cmd-&gt;add_data;
++		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
+ 	} else {
+-		struct indirect_descriptor *indirect =
+-			(struct indirect_descriptor *)cmd-&gt;additional_data;
+-		int num_mapped = indirect-&gt;head.length / 
+-			sizeof(indirect-&gt;list[0]);
++		struct srp_indirect_buf *indirect =
++			(struct srp_indirect_buf *) cmd-&gt;add_data;
++		int num_mapped = indirect-&gt;table_desc.len /
++			sizeof(struct srp_direct_buf);
+ 
+ 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
+-			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
++			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
+ 			return;
+ 		}
+ 
+@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
+ 
+ static int map_sg_list(int num_entries, 
+ 		       struct scatterlist *sg,
+-		       struct memory_descriptor *md)
++		       struct srp_direct_buf *md)
+ {
+ 	int i;
+ 	u64 total_length = 0;
+ 
+ 	for (i = 0; i &lt; num_entries; ++i) {
+-		struct memory_descriptor *descr = md + i;
++		struct srp_direct_buf *descr = md + i;
+ 		struct scatterlist *sg_entry = &amp;sg[i];
+-		descr-&gt;virtual_address = sg_dma_address(sg_entry);
+-		descr-&gt;length = sg_dma_len(sg_entry);
+-		descr-&gt;memory_handle = 0;
++		descr-&gt;va = sg_dma_address(sg_entry);
++		descr-&gt;len = sg_dma_len(sg_entry);
++		descr-&gt;key = 0;
+ 		total_length += sg_dma_len(sg_entry);
+  	}
+ 	return total_length;
+@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
+ 	int sg_mapped;
+ 	u64 total_length = 0;
+ 	struct scatterlist *sg = cmd-&gt;request_buffer;
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
+-	struct indirect_descriptor *indirect =
+-	    (struct indirect_descriptor *)data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
++	struct srp_indirect_buf *indirect =
++		(struct srp_indirect_buf *) data;
+ 
+ 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
+ 
+@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	/* special case; we can use a single direct descriptor */
+ 	if (sg_mapped == 1) {
+-		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
+-		data-&gt;length = sg_dma_len(&amp;sg[0]);
+-		data-&gt;memory_handle = 0;
++		data-&gt;va = sg_dma_address(&amp;sg[0]);
++		data-&gt;len = sg_dma_len(&amp;sg[0]);
++		data-&gt;key = 0;
+ 		return 1;
+ 	}
+ 
+@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
+ 		return 0;
+ 	}
+ 
+-	indirect-&gt;head.virtual_address = 0;
+-	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
+-	indirect-&gt;head.memory_handle = 0;
++	indirect-&gt;table_desc.va = 0;
++	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
++	indirect-&gt;table_desc.key = 0;
+ 
+ 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
+-		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
+-		indirect-&gt;total_length = total_length;
++		total_length = map_sg_list(sg_mapped, sg,
++					   &amp;indirect-&gt;desc_list[0]);
++		indirect-&gt;len = total_length;
+ 		return 1;
+ 	}
+ 
+ 	/* get indirect table */
+ 	if (!evt_struct-&gt;ext_list) {
+-		evt_struct-&gt;ext_list =(struct memory_descriptor*)
++		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
+ 			dma_alloc_coherent(dev, 
+-				SG_ALL * sizeof(struct memory_descriptor),
+-				&amp;evt_struct-&gt;ext_list_token, 0);
++					   SG_ALL * sizeof(struct srp_direct_buf),
++					   &amp;evt_struct-&gt;ext_list_token, 0);
+ 		if (!evt_struct-&gt;ext_list) {
+-		    printk(KERN_ERR
+-		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
++			printk(KERN_ERR
++			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
+ 			return 0;
+ 			
+ 		}
+@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
+ 
+-	indirect-&gt;total_length = total_length;
+-	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
+-	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
+-	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
+-		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
++	indirect-&gt;len = total_length;
++	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
++	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
++	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
++	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
+ 	
+  	return 1;
+ }
+@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
+ static int map_single_data(struct scsi_cmnd *cmd,
+ 			   struct srp_cmd *srp_cmd, struct device *dev)
+ {
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
+ 
+-	data-&gt;virtual_address =
++	data-&gt;va =
+ 		dma_map_single(dev, cmd-&gt;request_buffer,
+ 			       cmd-&gt;request_bufflen,
+ 			       DMA_BIDIRECTIONAL);
+-	if (dma_mapping_error(data-&gt;virtual_address)) {
++	if (dma_mapping_error(data-&gt;va)) {
+ 		printk(KERN_ERR
+ 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
+ 		return 0;
+ 	}
+-	data-&gt;length = cmd-&gt;request_bufflen;
+-	data-&gt;memory_handle = 0;
++	data-&gt;len = cmd-&gt;request_bufflen;
++	data-&gt;key = 0;
+ 
+ 	set_srp_direction(cmd, srp_cmd, 1);
+ 
+@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
+ 
+ 	/* Copy the IU into the transfer area */
+ 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
+-	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
++	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
+ 
+ 	/* Add this to the sent list.  We need to do this 
+ 	 * before we actually send 
+@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
+ 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
+ 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
+ 
+-	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
++	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
+-			       rsp-&gt;type);
++			       rsp-&gt;opcode);
+ 	}
+ 	
+ 	if (cmnd) {
+ 		cmnd-&gt;result = rsp-&gt;status;
+ 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
+ 			memcpy(cmnd-&gt;sense_buffer,
+-			       rsp-&gt;sense_and_response_data,
+-			       rsp-&gt;sense_data_list_length);
++			       rsp-&gt;data,
++			       rsp-&gt;sense_data_len);
+ 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
+ 			       evt_struct, 
+ 			       evt_struct-&gt;hostdata-&gt;dev);
+ 
+-		if (rsp-&gt;doover)
+-			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
+-		else if (rsp-&gt;diover)
+-			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
++		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
++			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
++		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
++			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
+ 	}
+ 
+ 	if (evt_struct-&gt;cmnd_done)
+@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
+ {
+ 	struct srp_cmd *srp_cmd;
+ 	struct srp_event_struct *evt_struct;
+-	struct indirect_descriptor *indirect;
++	struct srp_indirect_buf *indirect;
+ 	struct ibmvscsi_host_data *hostdata =
+ 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
+ 	u16 lun = lun_from_dev(cmnd-&gt;device);
++	u8 out_fmt, in_fmt;
+ 
+ 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
+ 	if (!evt_struct)
+@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
+ 
+ 	/* Set up the actual SRP IU */
+ 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
+-	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
+-	srp_cmd-&gt;type = SRP_CMD_TYPE;
++	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
++	srp_cmd-&gt;opcode = SRP_CMD;
+ 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
+ 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
+ 
+@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
+ 	evt_struct-&gt;cmnd_done = done;
+ 
+ 	/* Fix up dma address of the buffer itself */
+-	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
+-	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
+-	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
+-	    (indirect-&gt;head.virtual_address == 0)) {
+-		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
+-		    offsetof(struct srp_cmd, additional_data) +
+-		    offsetof(struct indirect_descriptor, list);
++	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
++	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
++	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
++	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
++	    indirect-&gt;table_desc.va == 0) {
++		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
++			offsetof(struct srp_cmd, add_data) +
++			offsetof(struct srp_indirect_buf, desc_list);
+ 	}
+ 
+ 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
+@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
+ static void login_rsp(struct srp_event_struct *evt_struct)
+ {
+ 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
+-	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
+-	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
++	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
++	case SRP_LOGIN_RSP:	/* it worked! */
+ 		break;
+-	case SRP_LOGIN_REJ_TYPE:	/* refused! */
++	case SRP_LOGIN_REJ:	/* refused! */
+ 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
+ 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
+ 		/* Login failed.  */
+@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
+ 	default:
+ 		printk(KERN_ERR
+ 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
+-		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
++		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
+ 		/* Login failed.  */
+ 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
+ 		return;
+@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
+ 
+-	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
++	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
+ 	    (max_requests - 2))
+-		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
++		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
+ 		    max_requests - 2;
+ 
+ 	/* Now we know what the real request-limit is */
+ 	atomic_set(&amp;hostdata-&gt;request_limit,
+-		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
++		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
+ 
+ 	hostdata-&gt;host-&gt;can_queue =
+-	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
++	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
+ 
+ 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
+ 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
+@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
+ 
+ 	login = &amp;evt_struct-&gt;iu.srp.login_req;
+ 	memset(login, 0x00, sizeof(struct srp_login_req));
+-	login-&gt;type = SRP_LOGIN_REQ_TYPE;
+-	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
+-	login-&gt;required_buffer_formats = 0x0006;
++	login-&gt;opcode = SRP_LOGIN_REQ;
++	login-&gt;req_it_iu_len = sizeof(union srp_iu);
++	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
+ 	
+ 	/* Start out with a request limit of 1, since this is negotiated in
+ 	 * the login request we are just sending
+@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 	
+ 	/* Set up an abort SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
+-	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
+-	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
++	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
++	tsk_mgmt-&gt;task_tag = (u64) found_evt;
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
+-	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
++	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
+ 
+ 	evt-&gt;sync_srp = &amp;srp_rsp;
+ 	init_completion(&amp;evt-&gt;comp);
+@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
+ 	wait_for_completion(&amp;evt-&gt;comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+ 	if (rsp_rc) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+-		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
++			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
+ 			       rsp_rc,
+-			       tsk_mgmt-&gt;managed_task_tag);
++			       tsk_mgmt-&gt;task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
+ 		printk(KERN_INFO
+ 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
+-		       tsk_mgmt-&gt;managed_task_tag);
++		       tsk_mgmt-&gt;task_tag);
+ 		return SUCCESS;
+ 	}
+ 
+ 	printk(KERN_INFO
+ 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
+-	       tsk_mgmt-&gt;managed_task_tag);
++	       tsk_mgmt-&gt;task_tag);
+ 
+ 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
+ 	list_del(&amp;found_evt-&gt;list);
+@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
+ 
+ 	/* Set up a lun reset SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
+-	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
++	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
+ 	       tsk_mgmt-&gt;lun);
+@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
+ 	wait_for_completion(&amp;evt-&gt;comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
+-		       rsp_rc,
+-			       tsk_mgmt-&gt;managed_task_tag);
++			       rsp_rc, tsk_mgmt-&gt;task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
+ 	}
+ 
+ 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
+-		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
++		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
+ 			   &amp;hostdata-&gt;request_limit);
+ 
+ 	if (evt_struct-&gt;done)
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
+index 4550d71..5c6d935 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.h
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
+@@ -68,7 +68,7 @@ struct srp_event_struct {
+ 	void (*cmnd_done) (struct scsi_cmnd *);
+ 	struct completion comp;
+ 	union viosrp_iu *sync_srp;
+-	struct memory_descriptor *ext_list;
++	struct srp_direct_buf *ext_list;
+ 	dma_addr_t ext_list_token;
+ };
+ 
+diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+index f47dd87..58aa530 100644
+--- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
++++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+@@ -34,7 +34,6 @@
+ #include &lt;linux/dma-mapping.h&gt;
+ #include &lt;linux/interrupt.h&gt;
+ #include &quot;ibmvscsi.h&quot;
+-#include &quot;srp.h&quot;
+ 
+ static char partition_name[97] = &quot;UNKNOWN&quot;;
+ static unsigned int partition_number = -1;
+diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
+index 6a6bba8..90f1a61 100644
+--- a/drivers/scsi/ibmvscsi/viosrp.h
++++ b/drivers/scsi/ibmvscsi/viosrp.h
+@@ -33,7 +33,22 @@
+ /*****************************************************************************/
+ #ifndef VIOSRP_H
+ #define VIOSRP_H
+-#include &quot;srp.h&quot;
++#include &lt;scsi/srp.h&gt;
++
++#define SRP_VERSION &quot;16.a&quot;
++#define SRP_MAX_IU_LEN	256
++
++union srp_iu {
++	struct srp_login_req login_req;
++	struct srp_login_rsp login_rsp;
++	struct srp_login_rej login_rej;
++	struct srp_i_logout i_logout;
++	struct srp_t_logout t_logout;
++	struct srp_tsk_mgmt tsk_mgmt;
++	struct srp_cmd cmd;
++	struct srp_rsp rsp;
++	u8 reserved[SRP_MAX_IU_LEN];
++};
+ 
+ enum viosrp_crq_formats {
+ 	VIOSRP_SRP_FORMAT = 0x01,
+-- 
+1.1.3

Added: trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,246 @@
+Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
+From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: 1143377151 +0900
+
+---
+
+ drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
+ 1 files changed, 0 insertions(+), 227 deletions(-)
+ delete mode 100644 drivers/scsi/ibmvscsi/srp.h
+
+acbd74e89dc7bcf4e2596800e46a19378db44641
+diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
+deleted file mode 100644
+index 7d8e4c4..0000000
+--- a/drivers/scsi/ibmvscsi/srp.h
++++ /dev/null
+@@ -1,227 +0,0 @@
+-/*****************************************************************************/
+-/* srp.h -- SCSI RDMA Protocol definitions                                   */
+-/*                                                                           */
+-/* Written By: Colin Devilbis, IBM Corporation                               */
+-/*                                                                           */
+-/* Copyright (C) 2003 IBM Corporation                                        */
+-/*                                                                           */
+-/* This program is free software; you can redistribute it and/or modify      */
+-/* it under the terms of the GNU General Public License as published by      */
+-/* the Free Software Foundation; either version 2 of the License, or         */
+-/* (at your option) any later version.                                       */
+-/*                                                                           */
+-/* This program is distributed in the hope that it will be useful,           */
+-/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
+-/* GNU General Public License for more details.                              */
+-/*                                                                           */
+-/* You should have received a copy of the GNU General Public License         */
+-/* along with this program; if not, write to the Free Software               */
+-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+-/*                                                                           */
+-/*                                                                           */
+-/* This file contains structures and definitions for the SCSI RDMA Protocol  */
+-/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
+-/* file was based on the 16a version of the standard                         */
+-/*                                                                           */
+-/*****************************************************************************/
+-#ifndef SRP_H
+-#define SRP_H
+-
+-#define SRP_VERSION &quot;16.a&quot;
+-
+-#define PACKED __attribute__((packed))
+-
+-enum srp_types {
+-	SRP_LOGIN_REQ_TYPE = 0x00,
+-	SRP_LOGIN_RSP_TYPE = 0xC0,
+-	SRP_LOGIN_REJ_TYPE = 0xC2,
+-	SRP_I_LOGOUT_TYPE = 0x03,
+-	SRP_T_LOGOUT_TYPE = 0x80,
+-	SRP_TSK_MGMT_TYPE = 0x01,
+-	SRP_CMD_TYPE = 0x02,
+-	SRP_RSP_TYPE = 0xC1,
+-	SRP_CRED_REQ_TYPE = 0x81,
+-	SRP_CRED_RSP_TYPE = 0x41,
+-	SRP_AER_REQ_TYPE = 0x82,
+-	SRP_AER_RSP_TYPE = 0x42
+-};
+-
+-enum srp_descriptor_formats {
+-	SRP_NO_BUFFER = 0x00,
+-	SRP_DIRECT_BUFFER = 0x01,
+-	SRP_INDIRECT_BUFFER = 0x02
+-};
+-
+-struct memory_descriptor {
+-	u64 virtual_address;
+-	u32 memory_handle;
+-	u32 length;
+-};
+-
+-struct indirect_descriptor {
+-	struct memory_descriptor head;
+-	u32 total_length;
+-	struct memory_descriptor list[1] PACKED;
+-};
+-
+-struct srp_generic {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_login_req {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 max_requested_initiator_to_target_iulen;
+-	u32 reserved2;
+-	u16 required_buffer_formats;
+-	u8 reserved3:6;
+-	u8 multi_channel_action:2;
+-	u8 reserved4;
+-	u32 reserved5;
+-	u8 initiator_port_identifier[16];
+-	u8 target_port_identifier[16];
+-};
+-
+-struct srp_login_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 max_initiator_to_target_iulen;
+-	u32 max_target_to_initiator_iulen;
+-	u16 supported_buffer_formats;
+-	u8 reserved2:6;
+-	u8 multi_channel_result:2;
+-	u8 reserved3;
+-	u8 reserved4[24];
+-};
+-
+-struct srp_login_rej {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-	u64 reserved2;
+-	u16 supported_buffer_formats;
+-	u8 reserved3[6];
+-};
+-
+-struct srp_i_logout {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_t_logout {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-};
+-
+-struct srp_tsk_mgmt {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4;
+-	u8 task_mgmt_flags;
+-	u8 reserved5;
+-	u64 managed_task_tag;
+-	u64 reserved6;
+-};
+-
+-struct srp_cmd {
+-	u8 type;
+-	u32 reserved1 PACKED;
+-	u8 data_out_format:4;
+-	u8 data_in_format:4;
+-	u8 data_out_count;
+-	u8 data_in_count;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4:5;
+-	u8 task_attribute:3;
+-	u8 reserved5;
+-	u8 additional_cdb_len;
+-	u8 cdb[16];
+-	u8 additional_data[0x100 - 0x30];
+-};
+-
+-struct srp_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u16 reserved2;
+-	u8 reserved3:2;
+-	u8 diunder:1;
+-	u8 diover:1;
+-	u8 dounder:1;
+-	u8 doover:1;
+-	u8 snsvalid:1;
+-	u8 rspvalid:1;
+-	u8 status;
+-	u32 data_in_residual_count;
+-	u32 data_out_residual_count;
+-	u32 sense_data_list_length;
+-	u32 response_data_list_length;
+-	u8 sense_and_response_data[18];
+-};
+-
+-struct srp_cred_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-};
+-
+-struct srp_cred_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_aer_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun;
+-	u32 sense_data_list_length;
+-	u32 reserved3;
+-	u8 sense_data[20];
+-};
+-
+-struct srp_aer_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-union srp_iu {
+-	struct srp_generic generic;
+-	struct srp_login_req login_req;
+-	struct srp_login_rsp login_rsp;
+-	struct srp_login_rej login_rej;
+-	struct srp_i_logout i_logout;
+-	struct srp_t_logout t_logout;
+-	struct srp_tsk_mgmt tsk_mgmt;
+-	struct srp_cmd cmd;
+-	struct srp_rsp rsp;
+-	struct srp_cred_req cred_req;
+-	struct srp_cred_rsp cred_rsp;
+-	struct srp_aer_req aer_req;
+-	struct srp_aer_rsp aer_rsp;
+-};
+-
+-#endif
+-- 
+1.1.3

Added: trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,375 @@
+Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
+
+This patch moves scsi_host_get_command and scsi_host_put_command to
+scsi_tgt_lib.c from scsi.c
+
+A target driver allocates scsi_cmnd structure via
+scsi_host_get_command, then pass it to tgt core via
+scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
+needs to allocate scsi_tgt_cmd structure (for tgt specific data).
+Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
+target drivers.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+
+---
+
+ drivers/scsi/scsi.c         |  102 ++++------------------------------------
+ drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
+ include/scsi/scsi_cmnd.h    |    6 +-
+ include/scsi/scsi_tgt.h     |    4 ++
+ 4 files changed, 112 insertions(+), 109 deletions(-)
+
+b8f2574dbd844ac43602d9fa74e6196027528c63
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index 9c22465..1d2fbe0 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
+-
+-/*
+- * Function:	scsi_host_get_command()
+- *
+- * Purpose:	Allocate and setup a scsi command block and blk request
+- *
+- * Arguments:	shost	- scsi host
+- *		data_dir - dma data dir
+- *		gfp_mask- allocator flags
+- *
+- * Returns:	The allocated scsi command structure.
+- *
+- * This should be called by target LLDs to get a command.
+- */
+-struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
+-					enum dma_data_direction data_dir,
+-					gfp_t gfp_mask)
+-{
+-	int write = (data_dir == DMA_TO_DEVICE);
+-	struct request *rq;
+-	struct scsi_cmnd *cmd;
+-
+-	/* Bail if we can't get a reference to the device */
+-	if (!get_device(&amp;shost-&gt;shost_gendev))
+-		return NULL;
+-
+-	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
+-	if (!rq)
+-		goto put_dev;
+-
+-	cmd = __scsi_get_command(shost, gfp_mask);
+-	if (!cmd)
+-		goto release_rq;
+-
+-	memset(cmd, 0, sizeof(*cmd));
+-	cmd-&gt;sc_data_direction = data_dir;
+-	cmd-&gt;jiffies_at_alloc = jiffies;
+-	cmd-&gt;request = rq;
+-
+-	rq-&gt;special = cmd;
+-	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
+-
+-	return cmd;
+-
+-release_rq:
+-	blk_put_request(rq);
+-put_dev:
+-	put_device(&amp;shost-&gt;shost_gendev);
+-	return NULL;
+-
+-}
+-EXPORT_SYMBOL_GPL(scsi_host_get_command);
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&amp;dev-&gt;sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+-/*
+- * Function:	scsi_host_put_command()
+- *
+- * Purpose:	Free a scsi command block
+- *
+- * Arguments:	shost	- scsi host
+- * 		cmd	- command block to free
+- *
+- * Returns:	Nothing.
+- *
+- * Notes:	The command must not belong to any lists.
+- */
+-void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
+ {
+-	struct request_queue *q = shost-&gt;uspace_req_q;
+-	struct request *rq = cmd-&gt;request;
+ 	unsigned long flags;
+ 
+ 	/* changing locks here, don't need to restore the irq state */
+@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
+ 		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
+ 		cmd = NULL;
+ 	}
+-	spin_unlock(&amp;shost-&gt;free_list_lock);
+-
+-	spin_lock(q-&gt;queue_lock);
+-	__blk_put_request(q, rq);
+-	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
++	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
+ 
+ 	if (likely(cmd != NULL))
+ 		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
+ 
+-	put_device(&amp;shost-&gt;shost_gendev);
++	put_device(dev);
+ }
+-EXPORT_SYMBOL_GPL(scsi_host_put_command);
++EXPORT_SYMBOL(__scsi_put_command);
+ 
+ /*
+  * Function:	scsi_put_command()
+@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd-&gt;device;
+-	struct Scsi_Host *shost = sdev-&gt;host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&amp;cmd-&gt;device-&gt;list_lock, flags);
+ 	BUG_ON(list_empty(&amp;cmd-&gt;list));
+ 	list_del_init(&amp;cmd-&gt;list);
+-	spin_unlock(&amp;cmd-&gt;device-&gt;list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&amp;shost-&gt;free_list_lock);
+-	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
+-		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&amp;shost-&gt;free_list_lock, flags);
+-
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
++	spin_unlock_irqrestore(&amp;cmd-&gt;device-&gt;list_lock, flags);
+ 
+-	put_device(&amp;sdev-&gt;sdev_gendev);
++	__scsi_put_command(cmd-&gt;device-&gt;host, cmd, &amp;sdev-&gt;sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index aea3e4d..e82340c 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
+ 	struct list_head cmd_req;
+ };
+ 
++/*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&amp;shost-&gt;shost_gendev))
++		return NULL;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		goto put_dev;
++
++	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto free_tcmd;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd-&gt;sc_data_direction = data_dir;
++	cmd-&gt;jiffies_at_alloc = jiffies;
++	cmd-&gt;request = rq;
++
++	rq-&gt;special = cmd;
++	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++	rq-&gt;end_io_data = tcmd;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++free_tcmd:
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++put_dev:
++	put_device(&amp;shost-&gt;shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++static void scsi_host_put_command(struct Scsi_Host *shost,
++				  struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost-&gt;uspace_req_q;
++	struct request *rq = cmd-&gt;request;
++	struct scsi_tgt_cmd *tcmd = rq-&gt;end_io_data;
++	unsigned long flags;
++
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++
++	spin_lock_irqsave(q-&gt;queue_lock, flags);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
++
++	__scsi_put_command(shost, cmd, &amp;shost-&gt;shost_gendev);
++}
++
+ static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
+ {
+ 	struct bio *bio;
+@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
+ 		cmd-&gt;request-&gt;flags &amp;= ~1UL;
+ 
+ 	scsi_unmap_user_pages(tcmd);
+-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+ 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
+ }
+ 
+@@ -177,13 +265,13 @@ out:
+ 		goto retry;
+ }
+ 
+-/**
++/*
+  * scsi_tgt_alloc_queue - setup queue used for message passing
+  * shost: scsi host
+  *
+  * This should be called by the LLD after host allocation.
+  * And will be released when the host is released.
+- **/
++ */
+ int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
+ {
+ 	struct scsi_tgt_queuedata *queuedata;
+@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
+ }
+ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+ 
+-/**
++/*
+  * scsi_tgt_queue_command - queue command for userspace processing
+  * @cmd:	scsi command
+  * @scsilun:	scsi lun
+  * @noblock:	set to nonzero if the command should be queued
+- **/
++ */
+ int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+ 			   u64 tag)
+ {
+ 	struct request_queue *q = cmd-&gt;request-&gt;q;
+ 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
+ 	unsigned long flags;
+-	struct scsi_tgt_cmd *tcmd;
+-
+-	/*
+-	 * It would be better to allocate scsi_tgt_cmd structure in
+-	 * scsi_host_get_command and not to fail due to OOM.
+-	 */
+-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+-	if (!tcmd)
+-		return -ENOMEM;
+-	cmd-&gt;request-&gt;end_io_data = tcmd;
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
+ 
+ 	bio_list_init(&amp;tcmd-&gt;xfer_list);
+ 	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 51156c7..c822bc2 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -150,11 +150,11 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
+-extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
+-					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
+-extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
+ extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+index 2d65be7..61e8ee9 100644
+--- a/include/scsi/scsi_tgt.h
++++ b/include/scsi/scsi_tgt.h
+@@ -2,6 +2,8 @@
+  * SCSI target definitions
+  */
+ 
++#include &lt;linux/dma-mapping.h&gt;
++
+ struct Scsi_Host;
+ struct scsi_cmnd;
+ struct scsi_lun;
+@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
+ extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
+ extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
+ 				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
+-- 
+1.1.3

Added: trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,554 @@
+Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
+
+The user-space damoen and tgt kernel module need to exhange mmapped
+addresses. netlink cannot do that. We need two-way kernel/user
+high-performance interface, however, mainline kernel provides no
+standard interface like that.
+
+This patch replaces netlink shared memory between kernel and user
+spaces. The user-space damoen and tgt kernel module creates shared
+memory via mmap and use it like ring buffer. poll (kernel to user) and
+write (user to kernel) system calls are used for notification.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+
+---
+
+ drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
+ drivers/scsi/scsi_tgt_lib.c  |   10 +
+ drivers/scsi/scsi_tgt_priv.h |    6 -
+ include/linux/netlink.h      |    1 
+ include/scsi/scsi_tgt_if.h   |   19 +--
+ 5 files changed, 216 insertions(+), 131 deletions(-)
+
+cd29acfca7cdeb8c351db14af357207e9dcb17f3
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+index 37e0feb..c4c5bdb 100644
+--- a/drivers/scsi/scsi_tgt_if.c
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -21,7 +21,6 @@
+  */
+ #include &lt;linux/blkdev.h&gt;
+ #include &lt;linux/file.h&gt;
+-#include &lt;linux/netlink.h&gt;
+ #include &lt;net/tcp.h&gt;
+ #include &lt;scsi/scsi.h&gt;
+ #include &lt;scsi/scsi_cmnd.h&gt;
+@@ -32,87 +31,129 @@
+ 
+ #include &quot;scsi_tgt_priv.h&quot;
+ 
+-static int tgtd_pid;
+-static struct sock *nl_sk;
++struct rbuf {
++	u32 idx;
++	u32 nr_entry;
++	int entry_size;
++	char *buf;
++	int buf_size;
++	spinlock_t lock;
++};
++
++static int chrdev;
++static struct rbuf txbuf, rxbuf;
++static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
+ 
+-static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
+-			  pid_t pid)
++static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
++{
++	u32 offset = (idx &amp; (rbuf-&gt;nr_entry - 1)) * rbuf-&gt;entry_size;
++	return (struct rbuf_hdr *) (rbuf-&gt;buf + offset);
++}
++
++static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
++{
++	int i;
++
++	esize += sizeof(struct rbuf_hdr);
++	rbuf-&gt;idx = 0;
++	rbuf-&gt;entry_size = esize;
++	rbuf-&gt;buf = buf;
++	spin_lock_init(&amp;rbuf-&gt;lock);
++
++	bsize /= esize;
++	for (i = 0; (1 &lt;&lt; i) &lt; bsize &amp;&amp; (1 &lt;&lt; (i + 1)) &lt;= bsize; i++)
++		;
++	rbuf-&gt;nr_entry = 1 &lt;&lt; i;
++}
++
++static int send_event_rsp(u32 type, struct tgt_event *p)
+ {
+ 	struct tgt_event *ev;
+-	struct nlmsghdr *nlh;
+-	struct sk_buff *skb;
+-	uint32_t len;
+-
+-	len = NLMSG_SPACE(sizeof(*ev));
+-	skb = alloc_skb(len, flags);
+-	if (!skb)
+-		return -ENOMEM;
++	struct rbuf_hdr *hdr;
++	struct page *sp, *ep;
++	unsigned long flags;
++	int err = 0;
++
++	spin_lock_irqsave(&amp;txbuf.lock, flags);
++
++	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx);
++	if (hdr-&gt;status)
++		err = 1;
++	else
++		txbuf.idx++;
+ 
+-	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
+ 
+-	ev = NLMSG_DATA(nlh);
++	if (err)
++		return err;
++
++	ev = (struct tgt_event *) hdr-&gt;data;
+ 	memcpy(ev, p, sizeof(*ev));
++	ev-&gt;type = type;
++	hdr-&gt;status = 1;
++	mb();
++
++	sp = virt_to_page(hdr);
++	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
++	for (;sp &lt;= ep; sp++)
++		flush_dcache_page(sp);
++
++	wake_up_interruptible(&amp;tgt_poll_wait);
+ 
+-	return netlink_unicast(nl_sk, skb, pid, 0);
++	return 0;
+ }
+ 
+-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
+-			 gfp_t flags)
++int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
+ {
+ 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
+-	struct sk_buff *skb;
+-	struct nlmsghdr *nlh;
+-	struct tgt_event *ev;
+-	int err, len;
++	struct tgt_event ev;
++	int err;
+ 
+-	len = NLMSG_SPACE(sizeof(*ev));
+-	/*
+-	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
+-	 */
+-	skb = alloc_skb(NLMSG_SPACE(len), flags);
+-	if (!skb)
+-		return -ENOMEM;
+-
+-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
+-			  len - sizeof(*nlh), 0);
+-
+-	ev = NLMSG_DATA(nlh);
+-	ev-&gt;k.cmd_req.host_no = shost-&gt;host_no;
+-	ev-&gt;k.cmd_req.cid = cmd-&gt;request-&gt;tag;
+-	ev-&gt;k.cmd_req.data_len = cmd-&gt;request_bufflen;
+-	memcpy(ev-&gt;k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev-&gt;k.cmd_req.scb));
+-	memcpy(ev-&gt;k.cmd_req.lun, lun, sizeof(ev-&gt;k.cmd_req.lun));
+-	ev-&gt;k.cmd_req.attribute = cmd-&gt;tag;
+-	ev-&gt;k.cmd_req.tag = tag;
+-
+-	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev-&gt;k.cmd_req.cid,
+-		ev-&gt;k.cmd_req.data_len, cmd-&gt;tag,
+-		(unsigned long long) ev-&gt;k.cmd_req.tag);
+-
+-	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
+-	if (err &lt; 0)
+-		printk(KERN_ERR &quot;scsi_tgt_uspace_send: could not send skb %d\n&quot;,
+-		       err);
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.cmd_req.host_no = shost-&gt;host_no;
++	ev.k.cmd_req.cid = cmd-&gt;request-&gt;tag;
++	ev.k.cmd_req.data_len = cmd-&gt;request_bufflen;
++	memcpy(ev.k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev.k.cmd_req.scb));
++	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
++	ev.k.cmd_req.attribute = cmd-&gt;tag;
++	ev.k.cmd_req.tag = tag;
++
++	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
++		ev.k.cmd_req.data_len, cmd-&gt;tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
+ 	return err;
+ }
+ 
+-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
+ {
+ 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
+ 	struct tgt_event ev;
++	int err;
+ 
+ 	memset(&amp;ev, 0, sizeof(ev));
+ 	ev.k.cmd_done.host_no = shost-&gt;host_no;
+ 	ev.k.cmd_done.cid = cmd-&gt;request-&gt;tag;
+ 	ev.k.cmd_done.result = cmd-&gt;result;
+ 
+-	return send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev, gfp_mask, tgtd_pid);
++	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev.k.cmd_req.cid,
++		ev.k.cmd_req.data_len, cmd-&gt;tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
++	return err;
+ }
+ 
+ int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+ 				  struct scsi_lun *scsilun, void *data)
+ {
+ 	struct tgt_event ev;
++	int err;
+ 
+ 	memset(&amp;ev, 0, sizeof(ev));
+ 	ev.k.tsk_mgmt_req.host_no = host_no;
+@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
+ 	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
+ 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
+ 
+-	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev, GFP_KERNEL, tgtd_pid);
++	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev);
++	if (err)
++		eprintk(&quot;tx buf is full, could not send\n&quot;);
++	return err;
+ }
+ 
+-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++static int event_recv_msg(struct tgt_event *ev)
+ {
+-	struct tgt_event *ev = NLMSG_DATA(nlh);
+ 	int err = 0;
+ 
+-	dprintk(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type,
+-		nlh-&gt;nlmsg_pid, current-&gt;pid);
+-
+-	switch (nlh-&gt;nlmsg_type) {
+-	case TGT_UEVENT_REQ:
+-		tgtd_pid = NETLINK_CREDS(skb)-&gt;pid;
+-		break;
++	switch (ev-&gt;type) {
+ 	case TGT_UEVENT_CMD_RSP:
+-		/* TODO: handle multiple cmds in one event */
+ 		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_rsp.host_no,
+ 					   ev-&gt;u.cmd_rsp.cid,
+ 					   ev-&gt;u.cmd_rsp.result,
+@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
+ 					       ev-&gt;u.tsk_mgmt_rsp.result);
+ 		break;
+ 	default:
+-		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
++		eprintk(&quot;unknown type %d\n&quot;, ev-&gt;type);
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err;
+ }
+ 
+-static int event_recv_skb(struct sk_buff *skb)
++static ssize_t tgt_write(struct file *file, const char __user * buffer,
++			 size_t count, loff_t * ppos)
+ {
+-	int err;
+-	uint32_t rlen;
+-	struct nlmsghdr	*nlh;
+-	struct tgt_event ev;
++	struct rbuf_hdr *hdr;
++	struct tgt_event *ev;
++	struct page *sp, *ep;
+ 
+-	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
+-		nlh = (struct nlmsghdr *) skb-&gt;data;
+-		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
+-			return 0;
+-		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
+-		if (rlen &gt; skb-&gt;len)
+-			rlen = skb-&gt;len;
+-		err = event_recv_msg(skb, nlh);
+-
+-		dprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
+-		/*
+-		 * TODO for passthru commands the lower level should
+-		 * probably handle the result or we should modify this
+-		 */
+-		switch (nlh-&gt;nlmsg_type) {
+-		case TGT_UEVENT_CMD_RSP:
+-		case TGT_UEVENT_TSK_MGMT_RSP:
+-			break;
+-		default:
+-			memset(&amp;ev, 0, sizeof(ev));
+-			ev.k.event_rsp.err = err;
+-			send_event_rsp(TGT_KEVENT_RSP, &amp;ev,
+-				       GFP_KERNEL | __GFP_NOFAIL,
+-					nlh-&gt;nlmsg_pid);
+-		}
+-		skb_pull(skb, rlen);
+-	}
+-	return 0;
++retry:
++	hdr = head_rbuf_hdr(&amp;rxbuf, rxbuf.idx);
++
++	sp = virt_to_page(hdr);
++	ep = virt_to_page((char *) hdr-&gt;data + sizeof(*ev));
++	for (;sp &lt;= ep; sp++)
++		flush_dcache_page(sp);
++
++	if (!hdr-&gt;status)
++		return count;
++
++	rxbuf.idx++;
++	ev = (struct tgt_event *) hdr-&gt;data;
++	event_recv_msg(ev);
++	hdr-&gt;status = 0;
++
++	goto retry;
+ }
+ 
+-static void event_recv(struct sock *sk, int length)
++static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
+ {
+-	struct sk_buff *skb;
++	struct rbuf_hdr *hdr;
++	unsigned long flags;
++	unsigned int mask = 0;
+ 
+-	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
+-		if (NETLINK_CREDS(skb)-&gt;uid) {
+-			skb_pull(skb, skb-&gt;len);
+-			kfree_skb(skb);
+-			continue;
+-		}
++	poll_wait(file, &amp;tgt_poll_wait, wait);
++
++	spin_lock_irqsave(&amp;txbuf.lock, flags);
+ 
+-		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
+-			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
+-		else
+-			kfree_skb(skb);
++	hdr = head_rbuf_hdr(&amp;txbuf, txbuf.idx - 1);
++	if (hdr-&gt;status)
++		mask |= POLLIN | POLLRDNORM;
++
++	spin_unlock_irqrestore(&amp;txbuf.lock, flags);
++
++	return mask;
++}
++
++static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	unsigned long size, addr;
++	struct page *page;
++	int err, i;
++
++	if (vma-&gt;vm_pgoff) {
++		eprintk(&quot;bug\n&quot;);
++		return -EINVAL;
++	}
++
++	size = vma-&gt;vm_end - vma-&gt;vm_start;
++	if (size != TGT_RINGBUF_SIZE * 2) {
++		eprintk(&quot;%lu\n&quot;, size);
++		return -EINVAL;
++	}
++	addr = vma-&gt;vm_start;
++	page = virt_to_page(txbuf.buf);
++	for (i = 0; i &lt; size &gt;&gt; PAGE_SHIFT; i++) {
++		err = vm_insert_page(vma, addr, page);
++		if (err) {
++			eprintk(&quot;%d %d %lu\n&quot;, err, i, addr);
++			return -EINVAL;
++		}
++		addr += PAGE_SIZE;
++		page++;
+ 	}
++
++	return 0;
+ }
+ 
++static struct file_operations tgt_fops = {
++	.owner	= THIS_MODULE,
++	.poll	= tgt_poll,
++	.write	= tgt_write,
++	.mmap	= tgt_mmap,
++};
++
+ void __exit scsi_tgt_if_exit(void)
+ {
+-	sock_release(nl_sk-&gt;sk_socket);
++	int order = long_log2(TGT_RINGBUF_SIZE * 2);
++
++	unregister_chrdev(chrdev, &quot;tgt&quot;);
++	free_pages((unsigned long) txbuf.buf, order);
+ }
+ 
+ int __init scsi_tgt_if_init(void)
+ {
+-	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
+-				    THIS_MODULE);
+-	if (!nl_sk)
+-		return -ENOMEM;
++	u32 bsize = TGT_RINGBUF_SIZE;
++	int order;
++	char *buf;
++
++	chrdev = register_chrdev(0, &quot;tgt&quot;, &amp;tgt_fops);
++	if (chrdev &lt; 0)
++		return chrdev;
++
++	order = long_log2((bsize * 2) &gt;&gt; PAGE_SHIFT);
++	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
++					order);
++	if (!buf)
++		goto free_dev;
++	rbuf_init(&amp;txbuf, buf, bsize, sizeof(struct tgt_event));
++	rbuf_init(&amp;rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
+ 
+ 	return 0;
++
++free_dev:
++	unregister_chrdev(chrdev, &quot;tgt&quot;);
++
++	return -ENOMEM;
+ }
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index e82340c..7ebfbc0 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -246,7 +246,7 @@ retry:
+ 	tcmd = rq-&gt;end_io_data;
+ 	init_scsi_tgt_cmd(rq, tcmd);
+ 	cmd = rq-&gt;special;
+-	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, tcmd-&gt;tag, GFP_ATOMIC);
++	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
+ 	if (err &lt; 0) {
+ 		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
+ 
+@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
+ 
+ 	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
+ 
+-	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++	scsi_tgt_uspace_send_status(cmd);
+ 	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
+ 	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
+ }
+@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
+ 		return;
+ 
+ 	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
+-	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
++	err = scsi_tgt_uspace_send_status(cmd);
++	if (err &lt;= 0)
+ 		/* the eh will have to pick this up */
+ 		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
+ }
+@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
+ 	/* should we free resources here on error ? */
+ 	if (cmd-&gt;result) {
+ send_uspace_err:
+-		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
++		err = scsi_tgt_uspace_send_status(cmd);
++		if (err &lt;= 0)
+ 			/* the tgt uspace eh will have to pick this up */
+ 			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
+ 		return;
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+index 77a1d06..bd16a2c 100644
+--- a/drivers/scsi/scsi_tgt_priv.h
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -14,9 +14,9 @@ do {								\
+ extern void scsi_tgt_if_exit(void);
+ extern int scsi_tgt_if_init(void);
+ 
+-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
+-				u64 tag, gfp_t flags);
+-extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				    u64 tag);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
+ extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
+ 				unsigned long uaddr, u8 rw);
+ extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 9422ae5..c256ebe 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,7 +21,6 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
+-#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+index 63b2e3a..74392a9 100644
+--- a/include/scsi/scsi_tgt_if.h
++++ b/include/scsi/scsi_tgt_if.h
+@@ -24,25 +24,20 @@
+ 
+ enum tgt_event_type {
+ 	/* user -&gt; kernel */
+-	TGT_UEVENT_REQ,
+ 	TGT_UEVENT_CMD_RSP,
+ 	TGT_UEVENT_TSK_MGMT_RSP,
+ 
+ 	/* kernel -&gt; user */
+-	TGT_KEVENT_RSP,
+ 	TGT_KEVENT_CMD_REQ,
+ 	TGT_KEVENT_CMD_DONE,
+ 	TGT_KEVENT_TSK_MGMT_REQ,
+ };
+ 
+ struct tgt_event {
++	uint32_t type;
+ 	/* user-&gt; kernel */
+ 	union {
+ 		struct {
+-			int type;
+-			int host_no;
+-		} event_req;
+-		struct {
+ 			int host_no;
+ 			uint32_t cid;
+ 			uint32_t len;
+@@ -60,9 +55,6 @@ struct tgt_event {
+ 	/* kernel -&gt; user */
+ 	union {
+ 		struct {
+-			int err;
+-		} event_rsp;
+-		struct {
+ 			int host_no;
+ 			uint32_t cid;
+ 			uint32_t data_len;
+@@ -86,4 +78,13 @@ struct tgt_event {
+ 	} k;
+ 
+ } __attribute__ ((aligned (sizeof(uint64_t))));
++
++#define TGT_RINGBUF_SIZE (1UL &lt;&lt; 16)
++
++struct rbuf_hdr {
++	uint32_t status;
++	uint32_t len;
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
+ #endif
+-- 
+1.1.3

Added: trunk/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,197 @@
+Subject: [PATCH] scsi target: kill target command list
+
+scsi_tgt_queue_command just adds a command to the list and then kernel
+thread sends it to user space because scsi_tgt_queue_command cannot
+use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
+
+Now we don't use netlink any more. So we can kill the list and
+scsi_tgt_queue_command just sends a command to user space.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+
+---
+
+ drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
+ 1 files changed, 24 insertions(+), 82 deletions(-)
+
+0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index 7ebfbc0..5c66f10 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
+ 	/* TODO replace the lists with a large bio */
+ 	struct bio_list xfer_done_list;
+ 	struct bio_list xfer_list;
+-	struct scsi_lun *lun;
+ 
+ 	struct list_head hash_list;
+ 	struct request *rq;
+-	u64 tag;
+ 
+ 	void *buffer;
+ 	unsigned bufflen;
+@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
+ 	struct Scsi_Host *shost;
+ 	struct list_head cmd_hash[1 &lt;&lt; TGT_HASH_ORDER];
+ 	spinlock_t cmd_hash_lock;
+-
+-	struct work_struct uspace_send_work;
+-
+-	spinlock_t cmd_req_lock;
+-	struct mutex cmd_req_mutex;
+-	struct list_head cmd_req;
+ };
+ 
+ /*
+@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
+ 	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
+ 	rq-&gt;end_io_data = tcmd;
+ 
++	bio_list_init(&amp;tcmd-&gt;xfer_list);
++	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
++	tcmd-&gt;rq = rq;
++
+ 	return cmd;
+ 
+ release_rq:
+@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
+ 	}
+ }
+ 
++static void cmd_hashlist_del(struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = cmd-&gt;request-&gt;q;
++	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
++	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
++	list_del(&amp;tcmd-&gt;hash_list);
++	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
++}
++
+ static void scsi_tgt_cmd_destroy(void *data)
+ {
+ 	struct scsi_cmnd *cmd = data;
+ 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
+-	struct scsi_tgt_queuedata *qdata = cmd-&gt;request-&gt;q-&gt;queuedata;
+-	unsigned long flags;
+ 
+ 	dprintk(&quot;cmd %p %d %lu\n&quot;, cmd, cmd-&gt;sc_data_direction,
+ 		rq_data_dir(cmd-&gt;request));
+ 
+-	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
+-	list_del(&amp;tcmd-&gt;hash_list);
+-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
++	cmd_hashlist_del(cmd);
+ 
+ 	/*
+ 	 * We must set rq-&gt;flags here because bio_map_user and
+@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
+ 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
+ }
+ 
+-static void scsi_tgt_uspace_send_fn(void *data)
+-{
+-	struct request_queue *q = data;
+-	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
+-	struct request *rq;
+-	struct scsi_cmnd *cmd;
+-	struct scsi_tgt_cmd *tcmd;
+-	unsigned long flags;
+-	int err;
+-
+-retry:
+-	err = 0;
+-	if (list_empty(&amp;qdata-&gt;cmd_req))
+-		return;
+-
+-	mutex_lock(&amp;qdata-&gt;cmd_req_mutex);
+-
+-	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
+-	if (list_empty(&amp;qdata-&gt;cmd_req)) {
+-		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+-		mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
+-		goto out;
+-	}
+-	rq = list_entry_rq(qdata-&gt;cmd_req.next);
+-	list_del_init(&amp;rq-&gt;queuelist);
+-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+-
+-	tcmd = rq-&gt;end_io_data;
+-	init_scsi_tgt_cmd(rq, tcmd);
+-	cmd = rq-&gt;special;
+-	err = scsi_tgt_uspace_send_cmd(cmd, tcmd-&gt;lun, tcmd-&gt;tag);
+-	if (err &lt; 0) {
+-		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
+-
+-		spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
+-		list_add(&amp;rq-&gt;queuelist, &amp;qdata-&gt;cmd_req);
+-		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+-	}
+-
+-	mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
+-out:
+-	/* TODO: proper error handling */
+-	if (err &lt; 0)
+-		queue_delayed_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work,
+-				   HZ / 10);
+-	else
+-		goto retry;
+-}
+-
+ /*
+  * scsi_tgt_alloc_queue - setup queue used for message passing
+  * shost: scsi host
+@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
+ 		INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_hash[i]);
+ 	spin_lock_init(&amp;queuedata-&gt;cmd_hash_lock);
+ 
+-	INIT_LIST_HEAD(&amp;queuedata-&gt;cmd_req);
+-	spin_lock_init(&amp;queuedata-&gt;cmd_req_lock);
+-	INIT_WORK(&amp;queuedata-&gt;uspace_send_work, scsi_tgt_uspace_send_fn, q);
+-	mutex_init(&amp;queuedata-&gt;cmd_req_mutex);
+-
+ 	return 0;
+ 
+ cleanup_queue:
+@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+  * scsi_tgt_queue_command - queue command for userspace processing
+  * @cmd:	scsi command
+  * @scsilun:	scsi lun
+- * @noblock:	set to nonzero if the command should be queued
++ * @tag:	unique value to identify this command for tmf
+  */
+ int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+ 			   u64 tag)
+ {
+-	struct request_queue *q = cmd-&gt;request-&gt;q;
+-	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
+-	unsigned long flags;
+ 	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++	int err;
+ 
+-	bio_list_init(&amp;tcmd-&gt;xfer_list);
+-	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
+-	tcmd-&gt;lun = scsilun;
+-	tcmd-&gt;tag = tag;
+-	tcmd-&gt;rq = cmd-&gt;request;
+-
+-	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
+-	list_add_tail(&amp;cmd-&gt;request-&gt;queuelist, &amp;qdata-&gt;cmd_req);
+-	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
++	init_scsi_tgt_cmd(cmd-&gt;request, tcmd);
++	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
++	if (err)
++		cmd_hashlist_del(cmd);
+ 
+-	queue_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work);
+-	return 0;
++	return err;
+ }
+ EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
+ 
+-- 
+1.1.3


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000493.html">[Stgt-svn] r506 - trunk/patchset
</A></li>
	<LI>Next message: <A HREF="000495.html">[Stgt-svn] r508 - trunk/patchset
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#494">[ date ]</a>
              <a href="thread.html#494">[ thread ]</a>
              <a href="subject.html#494">[ subject ]</a>
              <a href="author.html#494">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
