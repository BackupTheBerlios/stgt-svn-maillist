From tomo at berlios.de  Thu Feb  2 11:24:05 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Feb 2006 11:24:05 +0100
Subject: [Stgt-svn] r252 - branches/use-scsi-ml
Message-ID: <200602021024.k12AO5Fb024607@sheep.berlios.de>

Author: tomo
Date: 2006-02-02 11:24:05 +0100 (Thu, 02 Feb 2006)
New Revision: 252

Modified:
   branches/use-scsi-ml/Makefile
Log:
No ppc64 after 2.6.15.

Modified: branches/use-scsi-ml/Makefile
===================================================================
--- branches/use-scsi-ml/Makefile	2006-01-30 23:50:28 UTC (rev 251)
+++ branches/use-scsi-ml/Makefile	2006-02-02 10:24:05 UTC (rev 252)
@@ -7,18 +7,19 @@
 export KERNELSRC
 
 all:
-ifeq ($(ARCH), ppc64)
+ifeq ($(ARCH), powerpc)
 	make -C ibmvstgt
+else
+	make -C istgt
 endif
-	make -C istgt
-
 	make -C usr
 	make -C kernel
 clean:
 	make -C usr clean
 	make -C kernel clean
 
-ifeq ($(ARCH), ppc64)
+ifeq ($(ARCH), powerpc)
 	make -C ibmvstgt clean
+else
+	make -C istgt clean
 endif
-	make -C istgt clean



From tomo at berlios.de  Thu Feb  2 12:36:26 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Feb 2006 12:36:26 +0100
Subject: [Stgt-svn] r253 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602021136.k12BaQoQ018642@sheep.berlios.de>

Author: tomo
Date: 2006-02-02 12:36:24 +0100 (Thu, 02 Feb 2006)
New Revision: 253

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Add proc_name and eh_abort_handler (just for cheating scsi_host_alloc now).


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-02 10:24:05 UTC (rev 252)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-02 11:36:24 UTC (rev 253)
@@ -1078,6 +1078,15 @@
 	handle_cmd_queue(adapter);
 }
 
+/*
+ * TODO: just for cheating scsi_host_alloc now.
+ */
+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *cmd)
+{
+	BUG();
+	return 0;
+}
+
 static struct scsi_host_template ibmvstgt_sht = {
 	.name			= TGT_NAME,
 	.module			= THIS_MODULE,
@@ -1087,6 +1096,8 @@
 	.max_sectors		= DEFAULT_MAX_SECTORS,
 	.transfer_response	= ibmvstgt_cmd_done,
 	.transfer_data		= recv_cmd_data,
+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
+	.proc_name		= TGT_NAME,
 };
 
 static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)



From tomo at berlios.de  Thu Feb  2 13:24:09 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Feb 2006 13:24:09 +0100
Subject: [Stgt-svn] r254 - branches/use-scsi-ml/kernel
Message-ID: <200602021224.k12CO9jL022875@sheep.berlios.de>

Author: tomo
Date: 2006-02-02 13:24:02 +0100 (Thu, 02 Feb 2006)
New Revision: 254

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
Log:
Add debug message to scsi_tgt_bind_host().

Modified: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-02 11:36:24 UTC (rev 253)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-02 12:24:02 UTC (rev 254)
@@ -111,6 +111,8 @@
 	struct task_struct *tsk;
 	int err = 0;
 
+	dprintk("%d %d\n", ev->u.target_bind.host_no, ev->u.target_bind.pid);
+
 	shost = scsi_host_lookup(ev->u.target_bind.host_no);
 	if (IS_ERR(shost)) {
 		eprintk("Could not find host no %d\n",



From tomo at berlios.de  Thu Feb  2 13:27:22 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Feb 2006 13:27:22 +0100
Subject: [Stgt-svn] r255 - branches/use-scsi-ml/usr
Message-ID: <200602021227.k12CRM92024935@sheep.berlios.de>

Author: tomo
Date: 2006-02-02 13:27:10 +0100 (Thu, 02 Feb 2006)
New Revision: 255

Modified:
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/dl.h
   branches/use-scsi-ml/usr/ipc.c
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgt_sysfs.h
   branches/use-scsi-ml/usr/tgtadm.c
   branches/use-scsi-ml/usr/tgtadm.h
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Seems the bind operation works only with ibmvstgt (needs more work for istgt).


Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/Makefile	2006-02-02 12:27:10 UTC (rev 255)
@@ -1,16 +1,13 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../include -DNETLINK_TGT=20
-PROGRAMS = tgtd tgtadm scsi.so
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../include
+PROGRAMS = tgtd tgtadm
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o scsi.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
-scsi.so: scsi.o
-	$(CC) -shared -o $@ $^
-
 clean:
 	rm -f *.o $(PROGRAMS)

Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/dl.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -1,5 +1,5 @@
 /*
- * Dynamic library
+ * LLD dynamic library
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -7,8 +7,6 @@
  * This code is licenced under the GPL.
  */
 
-/* TODO : better handling of dynamic library. */
-
 #include <string.h>
 #include <fcntl.h>
 #include <dlfcn.h>
@@ -25,88 +23,52 @@
 #include "dl.h"
 #include "tgt_sysfs.h"
 
-struct driver_info dlinfo[MAX_DL_HANDLES];
+/*
+ * Software LLDs needs to set up a target (that means tgtd must load
+ * thier libraries) before a scsi_host is created in kernel space. In
+ * short, tgtd needs to load LLD libraries before it knows what
+ * libraries are avilable (through sysfs). I chose the easiest way.
+ */
 
-char *typeid_to_name(struct driver_info *dinfo, int typeid)
-{
-	return dinfo[typeid].name;
-}
+struct driver_info dlinfo[] = {
+	{"istgt", }, {"ibmvstgt",},
+};
 
-static char *dlname(char *d_name, char *entry)
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+int dl_init(struct driver_info *dinfo)
 {
-	int fd, err;
-	char *p, path[PATH_MAX], buf[PATH_MAX];
+	int i, fd, err;
+	char path[PATH_MAX];
+	mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+	mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
 
-	snprintf(path, sizeof(path),
-		 TGT_TYPE_SYSFSDIR "/%s/%s", d_name, entry);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		eprintf("%s\n", path);
-		return NULL;
-	}
-	memset(buf, 0, sizeof(buf));
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
+	system("rm -rf " TGT_LLD_SYSFSDIR);
+	err = mkdir(TGT_LLD_SYSFSDIR, dmode);
 	if (err < 0) {
-		eprintf("%s %d\n", path, errno);
-		return NULL;
+		perror("Cannot create " TGT_LLD_SYSFSDIR);
+		return err;
 	}
 
-	p = strchr(buf, '\n');
-	if (p)
-		*p = '\0';
+	for (i = 0; i < ARRAY_SIZE(dlinfo); i++) {
+		snprintf(path, sizeof(path), "%s.so", dlinfo[i].name);
+		dlinfo[i].dl = dlopen(path, RTLD_LAZY);
+		if (dlinfo[i].dl)
+			eprintf("%s library was loaded.\n", dlinfo[i].name);
+		else
+			eprintf("%s library is not loaded.\n", dlinfo[i].name);
 
-	return strdup(buf);
-}
+		snprintf(path, sizeof(path), TGT_LLD_SYSFSDIR "/%d-%s",
+			 i, dlinfo[i].name);
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-int dl_init(struct driver_info *dinfo)
-{
-	int i, nr, idx;
-	char path[PATH_MAX], *p;
-	struct dirent **namelist;
-	struct driver_info *di;
-
-	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
-	for (i = 0; i < nr; i++) {
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		idx = atoi(p);
-		if (idx > MAX_DL_HANDLES) {
-			eprintf("Too large dl idx %s %d\n",
-				namelist[i]->d_name, idx);
-			continue;
+		fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+		if (fd < 0) {
+			eprintf("Cannot create %s.\n", path);
+			exit(-1);
 		}
-		di = &dinfo[idx];
-
-		di->name = dlname(namelist[i]->d_name, "name");
-		if (!di->name)
-			continue;
-
-		snprintf(path, sizeof(path), "%s.so", di->name);
-		di->dl = dlopen(path, RTLD_LAZY);
-		if (!di->dl)
-			eprintf("%s %s\n", path, dlerror());
-
-		di->proto = dlname(namelist[i]->d_name, "protocol");
-		if (!di->proto)
-			continue;
-
-		snprintf(path, sizeof(path), "%s.so", di->proto);
-		di->pdl = dlopen(path, RTLD_LAZY);
-		if (!di->pdl)
-			eprintf("%s %s\n", path, dlerror());
 	}
 
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
+	return ARRAY_SIZE(dlinfo);
 }
 
 void *dl_poll_init_fn(struct driver_info *dinfo, int idx)
@@ -131,22 +93,6 @@
 	return NULL;
 }
 
-void *dl_proto_cmd_process(struct driver_info *dinfo, int tid, int typeid)
-{
-	if (dinfo[typeid].pdl)
-		return dlsym(dinfo[typeid].pdl, "cmd_process");
-
-	return NULL;
-}
-
-void *dl_proto_get_devid(struct driver_info *dinfo, int tid, int typeid)
-{
-	if (dinfo[typeid].pdl)
-		return dlsym(dinfo[typeid].pdl, "get_devid");
-
-	return NULL;
-}
-
 void *dl_event_fn(struct driver_info *dinfo, int tid, int typeid)
 {
 	if (dinfo[typeid].dl)
@@ -154,11 +100,3 @@
 
 	return NULL;
 }
-
-void *dl_cmd_done_fn(struct driver_info *dinfo, int typeid)
-{
-	if (dinfo[typeid].pdl)
-		return dlsym(dinfo[typeid].pdl, "cmd_done");
-
-	return NULL;
-}

Modified: branches/use-scsi-ml/usr/dl.h
===================================================================
--- branches/use-scsi-ml/usr/dl.h	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/dl.h	2006-02-02 12:27:10 UTC (rev 255)
@@ -5,12 +5,10 @@
 
 struct driver_info {
 	char *name;
-	char *proto;
 	void *dl;
-	void *pdl;
 };
 
-extern struct driver_info dlinfo[MAX_DL_HANDLES];
+extern struct driver_info dlinfo[];
 
 extern int dl_init(struct driver_info *);
 extern struct pollfd * dl_poll_init(struct driver_info *, int *nr);
@@ -19,9 +17,5 @@
 extern void *dl_poll_fn(struct driver_info *, int idx);
 extern void *dl_ipc_fn(struct driver_info *, int typeid);
 extern void *dl_event_fn(struct driver_info *, int tid, int typeid);
-extern void *dl_proto_cmd_process(struct driver_info *, int tid, int typeid);
-extern void *dl_proto_get_devid(struct driver_info *, int tid, int typeid);
-extern void *dl_cmd_done_fn(struct driver_info *, int typeid);
-extern char *typeid_to_name(struct driver_info *, int typeid);
 
 #endif

Modified: branches/use-scsi-ml/usr/ipc.c
===================================================================
--- branches/use-scsi-ml/usr/ipc.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/ipc.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -161,9 +161,8 @@
 
 	switch (req->mode) {
 	case MODE_DEVICE:
-		dprintf("%d %d %d %d %lx\n",
-			req->tid, req->typeid, err, nlh->nlmsg_len,
-			(unsigned long) task);
+		dprintf("%d %d %d %lx\n",
+			req->tid, err, nlh->nlmsg_len, (unsigned long) task);
 		req->addr = (unsigned long) task;
 		write(poll_array[POLLS_PER_DRV + req->tid].fd,
 		      sbuf, NLMSG_ALIGN(nlh->nlmsg_len));

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -21,7 +21,7 @@
 #include <linux/types.h>
 #include <linux/netlink.h>
 
-#include <tgt_if.h>
+#include <scsi/scsi_tgt_if.h>
 #include "tgtd.h"
 #include "dl.h"
 #include "log.h"
@@ -71,48 +71,66 @@
 	return err;
 }
 
-static void __ktarget_create(struct tgt_event *ev, struct tgtadm_req *req)
+static void __bind(struct tgt_event *ev, struct tgtadm_req *req)
 {
-	sprintf(ev->u.c_target.type, "%s", typeid_to_name(dlinfo, req->typeid));
-	ev->u.c_target.pid = req->pid;
+	char path[PATH_MAX], buf[32];
+	int err, fd, pid;
+
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/pid",
+		 req->tid);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		eprintf("Cannot open %s\n", path);
+		return;
+	}
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot read\n");
+		return;
+	}
+	sscanf(buf, "%d\n", &pid);
+
+	ev->u.target_bind.host_no = req->host_no;
+	ev->u.target_bind.pid = pid;
 }
 
+int ktarget_bind(int tid, int host_no)
+{
+	struct tgtadm_req req;
+
+	dprintf("%d %d\n", tid, host_no);
+
+	req.tid = tid;
+	req.host_no = host_no;
+	return tgt_event_execute(&req, TGT_UEVENT_TARGET_BIND, __bind);
+}
+
 int ktarget_create(int typeid)
 {
 	struct tgtadm_req req;
-	int fd, err;
+	int fd, tid;
 
 	req.typeid = typeid;
-	req.pid = target_thread_create(&fd);
-	err = tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
-				__ktarget_create);
-	if (err >= 0) {
-		dprintf("%d %d\n", err, fd);
+	tid = target_thread_create(&fd);
+	if (tid >= 0) {
+		dprintf("%d %d\n", tid, fd);
 
 		/* FIXME */
-		if (err > POLLS_PER_DRV)
-			eprintf("too large tid %d\n", err);
+		if (tid > POLLS_PER_DRV)
+			eprintf("too large tid %d\n", tid);
 		else {
-			poll_array[POLLS_PER_DRV + err].fd = fd;
-			poll_array[POLLS_PER_DRV + err].events = POLLIN;
+			poll_array[POLLS_PER_DRV + tid].fd = fd;
+			poll_array[POLLS_PER_DRV + tid].events = POLLIN;
 		}
 	}
 
-	return err;
+	return tid;
 }
 
-static void __ktarget_destroy(struct tgt_event *ev, struct tgtadm_req *req)
-{
-	ev->u.d_target.tid = req->tid;
-}
-
 int ktarget_destroy(int tid)
 {
-	struct tgtadm_req req;
-	req.tid = tid;
-
-	return tgt_event_execute(&req, TGT_UEVENT_TARGET_DESTROY,
-				 __ktarget_destroy);
+	return 0;
 }
 
 static void kdevice_create_parser(char *args, char **path, char **devtype)
@@ -200,6 +218,9 @@
 	case OP_DELETE:
 		err = ktarget_destroy(req->tid);
 		break;
+	case OP_BIND:
+		err = ktarget_bind(req->tid, req->host_no);
+		break;
 	default:
 		break;
 	}

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -22,7 +22,7 @@
 #include <asm/types.h>
 #include <linux/netlink.h>
 
-#include <tgt_if.h>
+#include <scsi/scsi_tgt_if.h>
 #include "tgtd.h"
 #include "dl.h"
 
@@ -99,7 +99,6 @@
 	struct tgt_event *ev;
 	char rbuf[NL_BUFSIZE];
 	int err;
-	void (*fn) (char *);
 
 	err = nl_read(fd, rbuf);
 	if (err < 0)
@@ -111,15 +110,6 @@
 	dprintf("%d %d\n", getpid(), nlh->nlmsg_type);
 
 	switch (nlh->nlmsg_type) {
-	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dl_event_fn(dinfo, ev->k.tgt_passthru.tid,
-				 ev->k.tgt_passthru.typeid);
-		if (fn)
-			fn(NLMSG_DATA(rbuf));
-		else
-			eprintf("Cannot handle async event %d\n",
-				ev->k.tgt_passthru.tid);
-		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -11,29 +11,40 @@
  *   licensed under the terms of the GNU GPL v2.0,
  */
 
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
-#include <inttypes.h>
-#include <dirent.h>
 #include <unistd.h>
-#include <errno.h>
-#include <scsi/scsi.h>
-#include <scsi/iscsi_proto.h>
 #include <asm/byteorder.h>
 #include <asm/page.h>
+#include <scsi/iscsi_proto.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <fcntl.h>
+
 #include <linux/netlink.h>
 
 #include "tgtd.h"
-#include "tgt_scsi_if.h"
 #include "tgt_sysfs.h"
 
+/*
+ * FIXME: in some architectures (e.g., powerpc) don't export PAGE_* to
+ * user space by asm/page.h. How should we handle this?
+ */
+#ifndef PAGE_SHIFT
+#define	PAGE_SHIFT	12
+#define	PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define	PAGE_MASK	(~(PAGE_SIZE-1))
+#endif
+
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
 #define cpu_to_be64 __cpu_to_be64
@@ -604,10 +615,8 @@
 	return result;
 }
 
-uint64_t get_devid(uint8_t *pdu)
+uint64_t scsi_get_devid(uint8_t *p)
 {
-	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
-	uint8_t *p = scmd->lun;
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
 	switch (*p >> 6) {
@@ -626,13 +635,12 @@
 	return lun;
 }
 
-int cmd_process(int tid, uint8_t *pdu, int *len,
-		uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		uint8_t *try_map, uint64_t *offset, uint64_t lun)
+int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
+		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+		     uint8_t *try_map, uint64_t *offset, uint64_t lun)
 {
 	int fd, result = SAM_STAT_GOOD;
-	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
-	uint8_t *data = NULL, *scb = scmd->scb;
+	uint8_t *data = NULL, *scb = pdu;
 
 	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
 
@@ -726,7 +734,7 @@
 	return result;
 }
 
-int cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/target.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -13,6 +13,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <search.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
@@ -21,8 +22,8 @@
 #include <sys/stat.h>
 #include <linux/fs.h>
 #include <linux/netlink.h>
+#include <scsi/scsi_tgt_if.h>
 
-#include <tgt_if.h>
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "dl.h"
@@ -47,6 +48,7 @@
 
 struct target {
 	struct pollfd pfd[2];
+	int tid;
 
 	struct device **devt;
 	uint64_t max_device;
@@ -209,11 +211,18 @@
 {
 	int err;
 
+	system("rm -rf " TGT_TARGET_SYSFSDIR);
 	system("rm -rf " TGT_DEVICE_SYSFSDIR);
 
+	err = mkdir(TGT_TARGET_SYSFSDIR, dmode);
+	if (err < 0) {
+		perror("Cannot create " TGT_TARGET_SYSFSDIR);
+		return err;
+	}
+
 	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
 	if (err < 0)
-		perror("Cannot create" TGT_DEVICE_SYSFSDIR);
+		perror("Cannot create " TGT_DEVICE_SYSFSDIR);
 
 	return err;
 }
@@ -279,8 +288,62 @@
 	return nlh->nlmsg_len;
 }
 
-static int cmd_queue(struct driver_info *dinfo, int fd, char *reqbuf)
+/* FIXME */
+
+#undef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
+} while (0)
+
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
+	     &pos->member != (head); 	\
+	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
+
+struct qelem {
+	struct qelem *q_forw;
+	struct qelem *q_back;
+};
+
+static struct qelem cqueue = LIST_HEAD_INIT(cqueue);
+
+struct cmd {
+	struct qelem clist;
+	uint32_t cid;
+	uint64_t devid;
+	uint64_t uaddr;
+	uint32_t len;
+	int mmap;
+};
+
+static struct cmd *find_cmd(uint32_t cid)
 {
+	struct cmd *cmd;
+
+	list_for_each_entry(cmd, &cqueue, clist) {
+		if (cmd->cid == cid)
+			return cmd;
+	}
+	return NULL;
+}
+
+static int cmd_queue(int fd, char *reqbuf)
+{
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
@@ -288,46 +351,34 @@
 	uint64_t offset, cid = ev_req->k.cmd_req.cid, devid;
 	uint8_t *pdu, rw = 0, try_map = 0;
 	unsigned long uaddr = 0;
-	static int (*fn) (int, uint8_t *, int *, uint32_t,
-			  unsigned long *, uint8_t *, uint8_t *, uint64_t *, uint64_t);
-	static uint64_t (*get_devid) (uint8_t *pdu);
-	int tid = ev_req->k.cmd_req.tid;
-	int typeid = ev_req->k.cmd_req.typeid;
+	int host_no = ev_req->k.cmd_req.host_no;
+	struct cmd *cmd;
 
 	memset(resbuf, 0, sizeof(resbuf));
 	pdu = (uint8_t *) ev_req->data;
 	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
 
-	if (!get_devid)
-		get_devid = dl_proto_get_devid(dinfo, tid, typeid);
+	devid = scsi_get_devid(pdu);
 
-	if (get_devid)
-		devid = get_devid(pdu);
-	else {
-		eprintf("Cannot find get_devid\n");
-		devid = TGT_INVALID_DEV_ID;
-	}
-
 	if (target->max_device > devid && target->devt[devid])
 		uaddr = target->devt[devid]->addr;
 
-	if (!fn)
-		fn = dl_proto_cmd_process(dinfo, tid, typeid);
-	if (fn)
-		result = fn(tid,
-			    pdu,
-			    &len,
-			    ev_req->k.cmd_req.data_len,
-			    &uaddr, &rw, &try_map, &offset, devid);
-	else {
-		result = -EINVAL;
-		eprintf("Cannot process cmd %d %" PRIu64 "\n",
-			tid, cid);
-	}
+	/* FIXME */
+	result = scsi_cmd_process(target->tid, pdu, &len,
+				  ev_req->k.cmd_req.data_len,
+				  &uaddr, &rw, &try_map, &offset, devid);
 
-	ev_res->u.cmd_res.tid = tid;
+	cmd = malloc(sizeof(*cmd));
+	cmd->cid = cid;
+	cmd->devid = devid;
+	cmd->uaddr = uaddr;
+	cmd->len = len;
+	cmd->mmap = try_map;
+
+	insque(&cmd->clist, &cqueue);
+
+	ev_res->u.cmd_res.host_no = host_no;
 	ev_res->u.cmd_res.cid = cid;
-	ev_res->u.cmd_res.devid = devid;
 	ev_res->u.cmd_res.len = len;
 	ev_res->u.cmd_res.result = result;
 	ev_res->u.cmd_res.uaddr = uaddr;
@@ -341,44 +392,46 @@
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
-static void cmd_done(struct driver_info *dinfo, char *buf)
+static void cmd_done(char *buf)
 {
-	static int (*done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 	struct tgt_event *ev = (struct tgt_event *) buf;
 	int err = 0;
-	int do_munmap = ev->k.cmd_done.mmapped;
+	uint32_t cid = ev->k.cmd_done.cid;
+	struct cmd *cmd;
+	int do_munmap;
 
-	if (!done)
-		done = dl_cmd_done_fn(dinfo, ev->k.cmd_done.typeid);
+	cmd = find_cmd(cid);
+	if (!cmd) {
+		eprintf("Cannot find cmd %u\n", cid);
+		return;
+	}
+	remque(&cmd->clist);
+	do_munmap = cmd->mmap;
 
-	if (done) {
-		if (do_munmap) {
-			uint64_t devid = ev->k.cmd_done.devid;
+	if (do_munmap) {
+		if (cmd->devid >= target->max_device) {
+			eprintf("%" PRIu64 " %" PRIu64 "\n",
+				cmd->devid, target->max_device);
+			exit(1);
+		}
 
-			if (devid >= target->max_device) {
-				eprintf("%" PRIu64 " %" PRIu64 "\n",
-					devid, target->max_device);
-				exit(1);
-			}
-
-			if (target->devt[devid]) {
-				if (target->devt[devid]->addr)
-					do_munmap = 0;
-			} else {
-				eprintf("%" PRIu64 " is null\n", devid);
-				exit(1);
-			}
+		if (target->devt[cmd->devid]) {
+			if (target->devt[cmd->devid]->addr)
+				do_munmap = 0;
+		} else {
+			eprintf("%" PRIu64 " is null\n", cmd->devid);
+			exit(1);
 		}
-		err = done(do_munmap, !ev->k.cmd_done.mmapped,
-			 ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
-	} else
-		eprintf("Cannot handle cmd done\n");
+	}
 
-	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
-		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+	err = scsi_cmd_done(do_munmap, !cmd->mmap, cmd->uaddr, cmd->len);
+
+	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmap, cmd->uaddr, cmd->len, err);
+
+	free(cmd);
 }
 
-static void nl_cmd(struct driver_info *dinfo, int fd)
+static void nl_cmd(int fd)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
@@ -401,10 +454,10 @@
 
 	switch (nlh->nlmsg_type) {
 	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(dinfo, fd, NLMSG_DATA(buf));
+		cmd_queue(fd, NLMSG_DATA(buf));
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		cmd_done(dinfo, NLMSG_DATA(buf));
+		cmd_done(NLMSG_DATA(buf));
 		break;
 	default:
 		eprintf("unknown event %u\n", nlh->nlmsg_type);
@@ -427,7 +480,6 @@
 
 static void tthread_event_loop(struct target *target)
 {
-	struct driver_info d[MAX_DL_HANDLES];
 	struct pollfd *pfd = target->pfd;
 	int fd, err;
 
@@ -439,9 +491,6 @@
 	target->pfd[POLL_NL_CMD].fd = fd;
 	target->pfd[POLL_NL_CMD].events = POLLIN;
 
-	err = dl_init(d);
-	dprintf("%d\n", err);
-
 	dprintf("Target thread started %u %d\n", getpid(), fd);
 
 	while (1) {
@@ -459,29 +508,58 @@
 			ipc_ctrl(pfd[POLL_IPC_CTRL].fd);
 
 		if (pfd[POLL_NL_CMD].revents)
-			nl_cmd(d, pfd[POLL_NL_CMD].fd);
+			nl_cmd(pfd[POLL_NL_CMD].fd);
 	}
 
 	free(target);
 }
 
+static int target_dir_create(int tid, int pid)
+{
+	char path[PATH_MAX], buf[32];
+	int err, fd;
+
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
+	err = mkdir(path, dmode);
+	if (err < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/pid", tid);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+	snprintf(buf, sizeof(buf), "%d", pid);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+
+	return 0;
+}
+
 int target_thread_create(int *sfd)
 {
 	pid_t pid;
 	int fd[2];
+	static int tid = 0;
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) {
 		eprintf("Cannot create socketpair %d\n", errno);
 		return -1;
 	}
 
+	tid++;
+
 	pid = fork();
 	if (pid < 0)
 		return -ENOMEM;
 	else if (pid) {
 		*sfd = fd[0];
 		close(fd[1]);
-		return pid;
+		target_dir_create(tid, pid);
+		return tid;
 	}
 
 	target = malloc(sizeof(*target));
@@ -492,6 +570,7 @@
 
 	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct device *));
 	target->max_device = DEFAULT_NR_DEVICE;
+	target->tid = tid;
 
 	close(fd[0]);
 	target->pfd[POLL_IPC_CTRL].fd = fd[1];

Modified: branches/use-scsi-ml/usr/tgt_sysfs.h
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.h	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/tgt_sysfs.h	2006-02-02 12:27:10 UTC (rev 255)
@@ -1,8 +1,8 @@
 #ifndef	__TGT_SYSFS_H
 #define	__TGT_SYSFS_H
 
-#define	TGT_TYPE_SYSFSDIR	"/sys/class/tgt_type"
-#define	TGT_TARGET_SYSFSDIR	"/sys/class/tgt_target"
+#define	TGT_LLD_SYSFSDIR	"/var/run/tgt_lld"
+#define	TGT_TARGET_SYSFSDIR	"/var/run/tgt_target"
 #define	TGT_DEVICE_SYSFSDIR	"/var/run/tgt_device"
 
 #endif

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -53,6 +53,7 @@
 	{"lun", required_argument, NULL, 'l'},
 	{"params", required_argument, NULL, 'p'},
 	{"user", no_argument, NULL, 'u'},
+	{"hostno", required_argument, NULL, 'b'},
 	{"version", no_argument, NULL, 'v'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
@@ -146,125 +147,87 @@
 	free(namelist);
 }
 
-static int system_mgmt(struct tgtadm_req *req)
+static int tid_to_hostno(int tid)
 {
-	int err = -EINVAL, i, nr, fd;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], cmd[PATH_MAX], *p;
+	int fd, hostno, err;
+	char path[PATH_MAX], buf[32];
 
-	if (req->op != OP_DELETE)
-		return err;
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/hostno", tid);
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		eprintf("Cannot open %s\n", path);
+		return -EINVAL;
+	}
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot read\n");
+		return -EINVAL;
+	}
 
-	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
+	sscanf(buf, "%d\n", &hostno);
 
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
-			 namelist[i]->d_name);
+	return hostno;
+}
 
-		fd = open(path, O_RDONLY);
-		if (fd < 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0)
-			continue;
+static int hostno_to_name(int hostno, char *buf, int len)
+{
+	int fd, err;
+	char path[PATH_MAX];
 
-		if (req->typeid == atoi(buf)) {
-			int tid;
+	snprintf(path, sizeof(path), "/sys/class/scsi_host/host%d/proc_name",
+		 hostno);
 
-			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-				;
-			tid = atoi(p);
-			all_devices_destroy(tid);
-
-			snprintf(cmd, sizeof(cmd),
-				 "./usr/tgtadm --driver %s --op delete --tid %d",
-				 driver, tid);
-			err = system(cmd);
-		}
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		eprintf("Cannot open %s\n", path);
+		return -EINVAL;
 	}
+	err = read(fd, buf, len);
+	close(fd);
 
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
+	return strlen(buf);
 }
 
-static int driver_to_typeid(char *name)
+static int system_mgmt(struct tgtadm_req *req, char *lld)
 {
-	int i, nr, err, fd, id = -ENOENT;
-	char *p, path[PATH_MAX], buf[PATH_MAX];
+	int err = -EINVAL, i, nr, hostno;
 	struct dirent **namelist;
+	char cmd[PATH_MAX], buf[64], *p;
 
-	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TYPE_SYSFSDIR "/%s/name",
-			 namelist[i]->d_name);
+	if (req->op != OP_DELETE)
+		return err;
 
-		fd = open(path, O_RDONLY);
-		if (fd < 0) {
-			eprintf("%s %d\n", path, errno);
-			continue;
-		}
+	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
 
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0) {
-			eprintf("%s %d\n", path, err);
+	for (i = 0; i < nr; i++) {
+		int tid;
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		tid = atoi(p);
+		hostno = tid_to_hostno(tid);
+		if (hostno < 0)
 			continue;
-		}
-
-		if (strncmp(name, buf, strlen(name)))
+		hostno_to_name(hostno, buf, sizeof(buf));
+		if (strcmp(buf, lld))
 			continue;
 
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		id = atoi(p);
-		break;
+		all_devices_destroy(tid);
+		snprintf(cmd, sizeof(cmd),
+			 "./usr/tgtadm --driver %s --op delete --tid %d",
+			 lld, tid);
+		err = system(cmd);
 	}
 
 	for (i = 0; i < nr; i++)
 		free(namelist[i]);
 	free(namelist);
 
-	return id;
+	return 0;
 }
 
-static int driver_dl_init(int argc, char **argv)
-{
-	int ch, longindex, id;
-	char *name = NULL;
-
-	while ((ch = getopt_long(argc, argv, "n:", long_options,
-				 &longindex)) >= 0) {
-		switch (ch) {
-		case 'n':
-			name = optarg;
-			break;
-		}
-	}
-
-	if (!name) {
-		eprintf("You must specify the driver name\n");
-		goto out;
-	}
-
-	id = driver_to_typeid(name);
-	if (id < 0) {
-		eprintf("Invalid driver name %s\n", name);
-		goto out;
-	}
-
-	driver = name;
-
-	return id;
-out:
-	exit(0);
-}
-
 static int ipc_mgmt_connect(void)
 {
 	int fd, err;
@@ -373,8 +336,8 @@
 		op = OP_NEW;
 	else if (!strcmp("delete", str))
 		op = OP_DELETE;
-	else if (!strcmp("update", str))
-		op = OP_UPDATE;
+	else if (!strcmp("bind", str))
+		op = OP_BIND;
 	else if (!strcmp("show", str))
 		op = OP_SHOW;
 	else
@@ -383,26 +346,78 @@
 	return op;
 }
 
+static int lldname_to_id(char *name)
+{
+	struct dirent **namelist;
+	int i, nr, id = -EINVAL;
+	char *p;
+
+	nr = scandir(TGT_LLD_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -EINVAL;
+
+	for (i = 0; i < nr; i++) {
+		p = strchr(namelist[i]->d_name, '-');
+		if (p && !strcmp(name, p + 1)) {
+			*p='\0';
+			id = atoi(namelist[i]->d_name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return id;
+}
+
+static int lld_id_get(int argc, char **argv)
+{
+	int ch, longindex, id = -EINVAL;
+	char *name = NULL;
+
+	while ((ch = getopt_long(argc, argv, "n:", long_options,
+				 &longindex)) >= 0) {
+		switch (ch) {
+		case 'n':
+			name = optarg;
+			break;
+		}
+	}
+
+	if (name)
+		id = lldname_to_id(name);
+
+	if (id < 0) {
+		eprintf("You must specify the driver name\n");
+		exit(-1);
+	}
+
+	return id;
+}
+
 int main(int argc, char **argv)
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len;
-	int tid = -1, typeid;
-	uint32_t cid = 0, set = 0;
+	int tid = -1;
+	uint32_t cid = 0, set = 0, hostno = 0, lld_id;
 	uint64_t sid = 0, lun = 0;
-	char *params = NULL;
+	char *params = NULL, *lld_name = NULL;
 	struct tgtadm_req *req;
 	char sbuf[8192], rbuf[8912];
 
-	typeid = driver_dl_init(argc, argv);
-	if (typeid < 0)
+	lld_id = lld_id_get(argc, argv);
+	if (lld_id < 0)
 		goto out;
 
 	optind = 1;
-	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvh",
+	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:b:p:uvh",
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'n':
+			lld_name = optarg;
 			break;
 		case 'o':
 			op = str_to_op(optarg);
@@ -423,6 +438,9 @@
 			lun = strtoull(optarg, NULL, 10);
 			set |= (1 << MODE_DEVICE);
 			break;
+		case 'b':
+			hostno = strtol(optarg, NULL, 10);
+			break;
 		case 'p':
 			params = optarg;
 			break;
@@ -457,12 +475,13 @@
 	memset(rbuf, 0, sizeof(rbuf));
 
 	req = (struct tgtadm_req *) sbuf;
-	req->typeid = typeid;
+	req->typeid = lld_id;
 	req->mode = set_to_mode(set);
 	req->op = op;
 	req->tid = tid;
 	req->sid = sid;
 	req->lun = lun;
+	req->host_no = hostno;
 
 	len = sizeof(struct tgtadm_req);
 	if (params) {
@@ -471,7 +490,7 @@
 	}
 
 	if (req->mode == MODE_SYSTEM)
-		err = system_mgmt(req);
+		err = system_mgmt(req, lld_name);
 	else {
 		err = ipc_mgmt_call(sbuf, len, rbuf);
 		ipc_mgmt_result(rbuf);

Modified: branches/use-scsi-ml/usr/tgtadm.h
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.h	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/tgtadm.h	2006-02-02 12:27:10 UTC (rev 255)
@@ -6,8 +6,8 @@
 enum tgtadm_op {
 	OP_NEW,
 	OP_DELETE,
-	OP_UPDATE,
 	OP_SHOW,
+	OP_BIND,
 };
 
 enum tgtadm_mode {
@@ -21,8 +21,6 @@
 };
 
 struct tgtadm_req {
-	int typeid;
-
 	enum tgtadm_mode mode;
 	enum tgtadm_op op;
 
@@ -30,8 +28,8 @@
 	uint64_t sid;
 	int cid;
 	uint64_t lun;
-	int pid;
-
+	int typeid;
+	int host_no;
 	unsigned long addr;
 };
 

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-02-02 12:27:10 UTC (rev 255)
@@ -22,7 +22,7 @@
 #include <sys/stat.h>
 #include <dirent.h>
 
-#include <tgt_if.h>
+#include <scsi/scsi_tgt_if.h>
 #include "tgtd.h"
 #include "dl.h"
 
@@ -225,11 +225,12 @@
 
 	ipc_fd = ipc_open();
 	if (ipc_fd < 0)
-		exit(ipc_fd);
+		exit(1);
 
-	dl_init(dlinfo);
+	nr = dl_init(dlinfo);
+	if (nr < nr)
+		exit(1);
 
-	nr = MAX_DL_HANDLES;
 	poll_array = poll_init(nr);
 
 	event_loop(nr, poll_array);

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-02 12:24:02 UTC (rev 254)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-02 12:27:10 UTC (rev 255)
@@ -28,4 +28,10 @@
 extern int tgt_device_create(int tid, uint64_t lun, int dfd);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 
+extern uint64_t scsi_get_devid(uint8_t *pdu);
+extern int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
+			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+			    uint8_t *try_map, uint64_t *offset, uint64_t lun);
+extern int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len);
+
 #endif



From tomo at berlios.de  Fri Feb  3 07:09:01 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 07:09:01 +0100
Subject: [Stgt-svn] r256 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602030609.k13691bG018104@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 07:08:44 +0100 (Fri, 03 Feb 2006)
New Revision: 256

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Use scmd->bufflen instead of request_bufflen. Fix this later on.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-02 12:27:10 UTC (rev 255)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-03 06:08:44 UTC (rev 256)
@@ -363,7 +363,9 @@
 	BUG_ON(!scmd);
 
 	scmd->SCp.ptr = (char *) iue;
-	scsi_tgt_queue_command(scmd, (struct scsi_lun *) iu->srp.cmd.lun, 0);
+	memcpy(scmd->data_cmnd, iu->srp.cmd.cdb, MAX_COMMAND_SIZE);
+	scmd->request_bufflen = len;
+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
 
 	return 0;
 }
@@ -401,7 +403,7 @@
 	long err;
 	dma_addr_t token;
 
-	dprintk("%p %u %u %d\n", iue, scmd->request_bufflen,
+	dprintk("%p %u %u %u %d\n", iue, scmd->request_bufflen, scmd->bufflen,
 		md->length, scmd->use_sg);
 
 	nsg = dma_map_sg(adapter->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
@@ -410,7 +412,7 @@
 		return 0;
 	}
 
-	rest = min(scmd->request_bufflen, md->length);
+	rest = min(scmd->bufflen, md->length);
 
 	for (i = 0, done = 0; i < nsg && rest; i++) {
 		token = sg_dma_address(sg + i);
@@ -456,8 +458,9 @@
 
 	nmd = id->head.length / sizeof(struct memory_descriptor);
 
-	dprintk("%p %u %u %u %d %d %d\n",
-		iue, scmd->request_bufflen, id->total_length, scmd->offset, nmd,
+	dprintk("%p %u %u %u %u %d %d %d\n",
+		iue, scmd->request_bufflen, scmd->bufflen,
+		id->total_length, scmd->offset, nmd,
 		cmd->data_in_count, cmd->data_out_count);
 
 	if ((op == SEND && nmd == cmd->data_in_count) ||
@@ -489,7 +492,7 @@
 
 	sidx = soff = 0;
 	token = sg_dma_address(sg + sidx);
-	rest = min(scmd->request_bufflen, id->total_length);
+	rest = min(scmd->bufflen, id->total_length);
 	for (i = 0; i < nmd && rest; i++) {
 		unsigned int mdone, mlen;
 
@@ -670,9 +673,9 @@
 	}
 
 	sent = handle_cmd_data(scmd, SEND);
-	if (sent != scmd->request_bufflen) {
+	if (sent != scmd->bufflen) {
 		eprintk("sending data on response %p (tried %u, sent %d\n",
-			iue, scmd->request_bufflen, sent);
+			iue, scmd->bufflen, sent);
 		send_rsp(iue, ABORTED_COMMAND, 0x00);
 	} else
 		send_rsp(iue, NO_SENSE, 0x00);



From tomo at berlios.de  Fri Feb  3 07:13:57 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 07:13:57 +0100
Subject: [Stgt-svn] r257 - branches/use-scsi-ml/kernel
Message-ID: <200602030613.k136Dvu6018771@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 07:13:43 +0100 (Fri, 03 Feb 2006)
New Revision: 257

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
Log:
o Add workaround to cheat queue_dma_alignment in __bio_map_user_iov.
o Save scmd->bufflen for LLDs. Need to fix this later.
o Put dummy data in uspace_send_status.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-03 06:08:44 UTC (rev 256)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-03 06:13:43 UTC (rev 257)
@@ -234,6 +234,7 @@
 		return 0;
 	}
 
+	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
 	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
 	return -EINVAL;
 }
@@ -248,13 +249,22 @@
 	struct bio *bio;
 	int err;
 
+	/*
+	 * TODO: We need to cheat queue_dma_alignment in
+	 * __bio_map_user_iov.
+	 */
+	len = (len + PAGE_SIZE - 1) & PAGE_MASK;
+
 	bio_list_init(&cmd->xfer_list);
 	bio_list_init(&cmd->xfer_done_list);
 
 	while (len > 0) {
-		bio = bio_map_user(q, NULL, (unsigned long)uaddr, len, rw, 1);
+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
 		if (IS_ERR(bio)) {
 			err = PTR_ERR(bio);
+			dprintk("fail to map %lx %u\n",
+				(unsigned long) uaddr, len);
 			goto unmap_bios;
 		}
 
@@ -284,9 +294,11 @@
 	return 0;
 
 unmap_bios:
-	bio_unmap_user(rq->bio);
-	while ((bio = bio_list_pop(&cmd->xfer_list)))
-		bio_unmap_user(bio);
+	if (rq->bio) {
+		bio_unmap_user(rq->bio);
+		while ((bio = bio_list_pop(&cmd->xfer_list)))
+			bio_unmap_user(bio);
+	}
 
 	return err;
 }
@@ -313,11 +325,10 @@
 	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
 	bio_list_add(&cmd->xfer_done_list, cmd->request->bio);
 
-	cmd->bufflen -= cmd->request_bufflen;
 	cmd->buffer += cmd->request_bufflen;
 	cmd->offset += cmd->request_bufflen;
 
-	if (!cmd->bufflen) {
+	if (!cmd->xfer_list.head) {
 		scsi_tgt_transfer_response(cmd);
 		return;
 	}
@@ -376,6 +387,9 @@
 	struct request *rq;
 	int err = 0;
 
+	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
+		len, (unsigned long long) offset, uaddr, rw, try_map);
+
 	/* TODO: replace with a O(1) alg */
 	shost = scsi_host_lookup(host_no);
 	if (IS_ERR(shost)) {

Modified: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-03 06:08:44 UTC (rev 256)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-03 06:13:43 UTC (rev 257)
@@ -9,6 +9,7 @@
 #include <linux/netlink.h>
 #include <linux/blkdev.h>
 #include <net/tcp.h>
+#include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tgt_if.h>
@@ -42,7 +43,8 @@
 	pid_t pid;
 
 	pid = scsi_tgt_get_pid(cmd->shost);
-	len = NLMSG_SPACE(sizeof(*ev) + MAX_COMMAND_SIZE);
+	len = NLMSG_SPACE(sizeof(*ev) +
+			  MAX_COMMAND_SIZE + sizeof(struct scsi_lun));
 	/*
 	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
 	 */
@@ -60,8 +62,13 @@
 	ev->k.cmd_req.host_no = cmd->shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
-	memcpy(ev->data, cmd->cmnd, MAX_COMMAND_SIZE);
 
+	/* FIXME: we need scsi core to do that. */
+	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
+	memcpy(pdu, cmd->cmnd, MAX_COMMAND_SIZE);
+	memcpy(pdu + MAX_COMMAND_SIZE, cmd->request->end_io_data,
+	       sizeof(struct scsi_lun));
+
 	err = netlink_unicast(nls, skb, pid, 0);
 	if (err < 0)
 		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb "
@@ -95,14 +102,15 @@
 int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
 {
 	struct tgt_event ev;
+	char dummy[MAX_COMMAND_SIZE + sizeof(struct scsi_lun)];
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.cmd_done.host_no = cmd->shost->host_no;
-	ev.k.cmd_done.cid = (unsigned long)cmd;
+	ev.k.cmd_done.cid = cmd->request->tag;
 	ev.k.cmd_done.result = cmd->result;
 
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, gfp_mask,
-			     scsi_tgt_get_pid(cmd->shost));
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
+			      gfp_mask, scsi_tgt_get_pid(cmd->shost));
 }
 
 static int scsi_tgt_bind_host(struct tgt_event *ev)



From tomo at berlios.de  Fri Feb  3 07:15:24 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 07:15:24 +0100
Subject: [Stgt-svn] r258 - branches/use-scsi-ml/usr
Message-ID: <200602030615.k136FOex018900@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 07:15:14 +0100 (Fri, 03 Feb 2006)
New Revision: 258

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Fix License stuff.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-03 06:13:43 UTC (rev 257)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-03 06:15:14 UTC (rev 258)
@@ -3,7 +3,6 @@
  *
  * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
  *
  * SCSI target emulation code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/



From tomo at berlios.de  Fri Feb  3 07:17:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 07:17:33 +0100
Subject: [Stgt-svn] r259 - branches/use-scsi-ml/usr
Message-ID: <200602030617.k136HXgI019071@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 07:16:31 +0100 (Fri, 03 Feb 2006)
New Revision: 259

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
tgtd parses lun buffer.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-03 06:15:14 UTC (rev 258)
+++ branches/use-scsi-ml/usr/target.c	2006-02-03 06:16:31 UTC (rev 259)
@@ -342,13 +342,16 @@
 	return NULL;
 }
 
+#define	MAX_COMMAND_SIZE	16
+
 static int cmd_queue(int fd, char *reqbuf)
 {
 	int result, len = 0;
 	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t offset, cid = ev_req->k.cmd_req.cid, devid;
+	uint64_t offset, devid;
+	uint32_t cid = ev_req->k.cmd_req.cid;
 	uint8_t *pdu, rw = 0, try_map = 0;
 	unsigned long uaddr = 0;
 	int host_no = ev_req->k.cmd_req.host_no;
@@ -356,9 +359,9 @@
 
 	memset(resbuf, 0, sizeof(resbuf));
 	pdu = (uint8_t *) ev_req->data;
-	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
+	dprintf("%u %x\n", cid, pdu[0]);
 
-	devid = scsi_get_devid(pdu);
+	devid = scsi_get_devid(pdu + MAX_COMMAND_SIZE);
 
 	if (target->max_device > devid && target->devt[devid])
 		uaddr = target->devt[devid]->addr;
@@ -368,6 +371,8 @@
 				  ev_req->k.cmd_req.data_len,
 				  &uaddr, &rw, &try_map, &offset, devid);
 
+	dprintf("%u %x %lx %" PRIu64 " %d\n", cid, pdu[0], uaddr, offset, result);
+
 	cmd = malloc(sizeof(*cmd));
 	cmd->cid = cid;
 	cmd->devid = devid;
@@ -386,8 +391,6 @@
 	ev_res->u.cmd_res.try_map = try_map;
 	ev_res->u.cmd_res.offset = offset;
 
-	log_debug("scsi_cmd_process res %d len %d\n", result, len);
-
 	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }



From tomo at berlios.de  Fri Feb  3 07:20:15 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 07:20:15 +0100
Subject: [Stgt-svn] r260 - branches/use-scsi-ml
Message-ID: <200602030620.k136KFsS019525@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 07:20:12 +0100 (Fri, 03 Feb 2006)
New Revision: 260

Modified:
   branches/use-scsi-ml/initd
Log:
Update the init script.

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-02-03 06:16:31 UTC (rev 259)
+++ branches/use-scsi-ml/initd	2006-02-03 06:20:12 UTC (rev 260)
@@ -13,8 +13,7 @@
 
 start_server()
 {
-	insmod ${PWD}/kernel/tgt_core.ko
-	insmod ${PWD}/kernel/tgt_scsi.ko
+	insmod ${PWD}/kernel/scsi_tgt_core.ko
 
 	if [ $TARGET = "istgt" ] ; then
 		modprobe -q crc32c
@@ -23,7 +22,20 @@
 		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
 	fi
 
-	${PWD}/usr/tgtd
+	${PWD}/usr/tgtd -d1
+
+	sleep 1
+
+	if [ $TARGET = "istgt" ] ; then
+		echo "Start istgt"    
+#		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+#		${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
+#		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
+	else
+		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 0
+		${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --hostno 1
+		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+	fi
 }
 	
 stop_server()
@@ -36,14 +48,15 @@
 
 	killall -9 tgtd
 
+	sleep 1
+
 	if [ $TARGET = "istgt" ] ; then
 		rmmod istgt
 	else
 		rmmod ibmvstgt
 	fi
 
-	rmmod tgt_scsi
-	rmmod tgt_core
+	rmmod scsi_tgt_core
 }
 
 case "$1" in



From tomo at berlios.de  Fri Feb  3 10:37:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 10:37:50 +0100
Subject: [Stgt-svn] r261 - branches/use-scsi-ml/usr
Message-ID: <200602030937.k139boU0021072@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 10:37:50 +0100 (Fri, 03 Feb 2006)
New Revision: 261

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Fix mmap_device bug. And add some workaround for ibmvstgt. This doesn't work with other LLDs.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-03 06:20:12 UTC (rev 260)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-03 09:37:50 UTC (rev 261)
@@ -334,17 +334,15 @@
 
 static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p, int *len)
 {
-	/*
-	 * TODO Convert to 64 bits
-	 */
-	uint32_t lun;
-	uint32_t *data = (uint32_t *) p;
-	int idx, alen, oalen, rbuflen, nr_luns;
+	uint64_t lun, *data = (uint64_t *) p;
+	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	DIR *dir;
 	struct dirent *ent;
 	char buf[128];
 	int result = SAM_STAT_GOOD;
 
+	memset(data, 0, rbuflen);
+
 	dir = opendir(TGT_DEVICE_SYSFSDIR);
 	if (!dir) {
 		eprintf("can't open %s %d\n", TGT_DEVICE_SYSFSDIR, errno);
@@ -362,21 +360,24 @@
 	alen &= ~(8 - 1);
 	oalen = alen;
 
-	/* We'll set data[0] later. */
-	data[1] = 0;
-
 	alen -= 8;
-	rbuflen = 8192 - 8; /* FIXME */
-	idx = 2;
+	rbuflen -= 8; /* FIXME */
+	idx = 1;
 	nr_luns = 0;
 
+	/* ibmvstgt hack */
+	idx = 2;
+	nr_luns = 1;
+
 	sprintf(buf, "device%d:", tid);
 	while ((ent = readdir(dir))) {
 		if (!strncmp(ent->d_name, buf, strlen(buf))) {
-			sscanf(ent->d_name, "device%d:%u", &tid, &lun);
-			data[idx++] = cpu_to_be32((0x3ff & lun) << 16 |
-						  ((lun > 0xff) ? (0x1 << 30) : 0));
-			data[idx++] = 0;
+			sscanf(ent->d_name, "device%d:%" SCNu64, &tid, &lun);
+
+			lun = (0x8000 | (lun & 0x001f)) << 48;
+			dprintf("%d %" PRIx64 "\n", tid, lun);
+
+			data[idx++] = cpu_to_be64(lun);
 			if (!(alen -= 8))
 				break;
 			if (!(rbuflen -= 8)) {
@@ -387,7 +388,7 @@
 		}
 	}
 
-	data[0] = cpu_to_be32(nr_luns * 8);
+	*data = (cpu_to_be64(nr_luns * 8) << 32);
 	*len = min(oalen, nr_luns * 8 + 8);
 out:
 	closedir(dir);
@@ -587,6 +588,7 @@
 			err = SAM_STAT_CHECK_CONDITION;
 	}
 	*offset = off;
+	*len = datalen;
 	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
 	return err;
@@ -614,10 +616,17 @@
 	return result;
 }
 
+#define        TGT_INVALID_DEV_ID      ~0ULL
+
 uint64_t scsi_get_devid(uint8_t *p)
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
+	/* ibmvstgt hack */
+	lun = (uint64_t) *p;
+	lun = (lun >> 48) & 0x001f;
+	return lun;
+
 	switch (*p >> 6) {
 	case 0:
 		lun = p[1];

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-03 06:20:12 UTC (rev 260)
+++ branches/use-scsi-ml/usr/target.c	2006-02-03 09:37:50 UTC (rev 261)
@@ -359,9 +359,9 @@
 
 	memset(resbuf, 0, sizeof(resbuf));
 	pdu = (uint8_t *) ev_req->data;
-	dprintf("%u %x\n", cid, pdu[0]);
 
 	devid = scsi_get_devid(pdu + MAX_COMMAND_SIZE);
+	dprintf("%u %x %" PRIx64 "\n", cid, pdu[0], devid);
 
 	if (target->max_device > devid && target->devt[devid])
 		uaddr = target->devt[devid]->addr;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-03 06:20:12 UTC (rev 260)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-03 09:37:50 UTC (rev 261)
@@ -4,8 +4,6 @@
 #include "log.h"
 #include "dl.h"
 
-#define	TGT_INVALID_DEV_ID	~0ULL
-
 /* temporarily */
 #define	POLLS_PER_DRV	32
 extern int nl_fd;



From tomo at berlios.de  Fri Feb  3 13:39:26 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Feb 2006 13:39:26 +0100
Subject: [Stgt-svn] r262 - branches/use-scsi-ml/usr
Message-ID: <200602031239.k13CdQAL008011@sheep.berlios.de>

Author: tomo
Date: 2006-02-03 13:39:25 +0100 (Fri, 03 Feb 2006)
New Revision: 262

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Improve inquiry and fix ibmvstgt hack in scsi_get_devid.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-03 09:37:50 UTC (rev 261)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-03 12:39:25 UTC (rev 262)
@@ -249,13 +249,12 @@
 static int inquiry(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
 {
 	uint64_t size;
-	int result = SAM_STAT_CHECK_CONDITION;
+	int err, result = SAM_STAT_CHECK_CONDITION;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
-	errno = 0;
-	device_info(tid, lun, &size);
+	err = device_info(tid, lun, &size);
 
 	if (!(scb[1] & 0x3)) {
 		data[2] = 4;
@@ -309,7 +308,7 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (errno == ENOENT)
+			if (err < 0)
 				sprintf(data + 8, "deadbeaf%d:%" PRIu64, tid, lun);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
@@ -321,8 +320,10 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (errno == ENOENT)
+	if (err < 0) {
+		dprintf("%" PRIu64 "\n", lun);
 		data[0] = TYPE_NO_LUN;
+	}
 
 	return SAM_STAT_GOOD;
 
@@ -618,15 +619,23 @@
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
 
+#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
+#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
+#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
+
 uint64_t scsi_get_devid(uint8_t *p)
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
 	/* ibmvstgt hack */
-	lun = (uint64_t) *p;
-	lun = (lun >> 48) & 0x001f;
-	return lun;
+	lun = *((uint64_t *) p);
+	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
 
+	if (GETBUS(lun) || GETTARGET(lun))
+		return TGT_INVALID_DEV_ID;
+	else
+		return GETLUN(lun);
+
 	switch (*p >> 6) {
 	case 0:
 		lun = p[1];



From tomo at berlios.de  Sun Feb  5 04:45:26 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 04:45:26 +0100
Subject: [Stgt-svn] r263 - branches/use-scsi-ml/kernel
Message-ID: <200602050345.k153jQ0d025737@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 04:45:22 +0100 (Sun, 05 Feb 2006)
New Revision: 263

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Fix scsi_host_get_command and regenerate patches against the latest scsi-misc tree.


Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-03 12:39:25 UTC (rev 262)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-05 03:45:22 UTC (rev 263)
@@ -1,8 +1,8 @@
 diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index 8e27d0a..9e7375f 100644
+index f9fc07e..65c56b6 100644
 --- a/block/ll_rw_blk.c
 +++ b/block/ll_rw_blk.c
-@@ -2291,7 +2291,7 @@ int blk_rq_map_user(request_queue_t *q, 
+@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
  	 */
  	uaddr = (unsigned long) ubuf;
  	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
@@ -11,7 +11,7 @@
  	else
  		bio = bio_copy_user(q, uaddr, len, reading);
  
-@@ -2343,7 +2343,8 @@ int blk_rq_map_user_iov(request_queue_t 
+@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
  	/* we don't allow misaligned data like bio_map_user() does.  If the
  	 * user is using sg, they're expected to know the alignment constraints
  	 * and respect them accordingly */
@@ -131,7 +131,7 @@
  #include <linux/init.h>
  #include <linux/mempool.h>
 diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
-index 4b9dd8f..f6d44e9 100644
+index f3759dd..2e65db8 100644
 --- a/drivers/md/dm-snap.c
 +++ b/drivers/md/dm-snap.c
 @@ -18,9 +18,9 @@
@@ -146,7 +146,7 @@
  
  /*
 diff --git a/drivers/md/dm.c b/drivers/md/dm.c
-index 097d1e5..f51568a 100644
+index e9adeb9..020f415 100644
 --- a/drivers/md/dm.c
 +++ b/drivers/md/dm.c
 @@ -6,8 +6,8 @@
@@ -160,7 +160,7 @@
  #include <linux/module.h>
  #include <linux/moduleparam.h>
 diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
-index a06ff91..76798dc 100644
+index d39f584..4e43ce2 100644
 --- a/drivers/md/raid1.c
 +++ b/drivers/md/raid1.c
 @@ -31,7 +31,7 @@
@@ -173,7 +173,7 @@
  #include <linux/raid/bitmap.h>
  
 diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
-index 9e658e5..c480fe6 100644
+index ab90a6d..3ced1b9 100644
 --- a/drivers/md/raid10.c
 +++ b/drivers/md/raid10.c
 @@ -18,7 +18,7 @@
@@ -202,7 +202,7 @@
  	kfree(shost->shost_data);
  
 diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 245ca99..48cfdf2 100644
+index 245ca99..3bf557f 100644
 --- a/drivers/scsi/scsi.c
 +++ b/drivers/scsi/scsi.c
 @@ -236,6 +236,59 @@ static struct scsi_cmnd *__scsi_get_comm
@@ -229,17 +229,17 @@
 +	struct request *rq;
 +	struct scsi_cmnd *cmd;
 +
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
 +	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
 +	if (!rq)
-+		return NULL;
++		goto put_dev;
 +
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		goto release_rq;
-+
 +	cmd = __scsi_get_command(shost, gfp_mask);
 +	if (!cmd)
-+		goto put_dev;
++		goto release_rq;
 +
 +	memset(cmd, 0, sizeof(*cmd));
 +	cmd->sc_data_direction = data_dir;
@@ -252,13 +252,13 @@
 +
 +	return cmd;
 +
++release_rq:
++	blk_put_request(rq);
 +put_dev:
 +	put_device(&shost->shost_gendev);
-+release_rq:
-+	blk_put_request(rq);
 +	return NULL;
 +
-+}				
++}
 +EXPORT_SYMBOL_GPL(scsi_host_get_command);
 +
 +/*
@@ -285,7 +285,7 @@
 +	struct request_queue *q = cmd->shost->uspace_req_q;
 +	struct request *rq = cmd->request;
 +	unsigned long flags;
-+	
++
 +	/* changing locks here, don't need to restore the irq state */
 +	spin_lock_irqsave(&shost->free_list_lock, flags);
 +	if (unlikely(list_empty(&shost->free_list))) {
@@ -312,10 +312,10 @@
   *
   * Purpose:	Free a scsi command block
 diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 3574ba9..ab66ca4 100644
+index 4a60285..cbd16d6 100644
 --- a/drivers/scsi/scsi_lib.c
 +++ b/drivers/scsi/scsi_lib.c
-@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+@@ -803,7 +803,7 @@ static struct scsi_cmnd *scsi_end_reques
  	return NULL;
  }
  
@@ -324,7 +324,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  	struct scatterlist *sgl;
-@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+@@ -844,7 +844,9 @@ static struct scatterlist *scsi_alloc_sg
  	return sgl;
  }
  
@@ -335,7 +335,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  
-@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+@@ -854,6 +856,8 @@ static void scsi_free_sgtable(struct sca
  	mempool_free(sgl, sgp->pool);
  }
  
@@ -344,7 +344,7 @@
  /*
   * Function:    scsi_release_buffers()
   *
-@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+@@ -1686,29 +1690,40 @@ u64 scsi_calculate_bounce_limit(struct S
  }
  EXPORT_SYMBOL(scsi_calculate_bounce_limit);
  
@@ -393,10 +393,10 @@
  void scsi_free_queue(struct request_queue *q)
  {
 diff --git a/fs/bio.c b/fs/bio.c
-index 7b30695..aba3ce9 100644
+index 1f3bb50..fd1e419 100644
 --- a/fs/bio.c
 +++ b/fs/bio.c
-@@ -718,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
+@@ -719,19 +719,21 @@ static struct bio *__bio_map_user_iov(re
   *	@uaddr: start of user address
   *	@len: length in bytes
   *	@write_to_vm: bool indicating writing to pages or not
@@ -420,7 +420,7 @@
  }
  
  /**
-@@ -740,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
+@@ -741,13 +743,14 @@ struct bio *bio_map_user(request_queue_t
   *	@iov:	the iovec.
   *	@iov_count: number of elements in the iovec
   *	@write_to_vm: bool indicating writing to pages or not
@@ -436,7 +436,7 @@
  {
  	struct bio *bio;
  	int len = 0, i;
-@@ -767,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
+@@ -768,7 +771,7 @@ struct bio *bio_map_user_iov(request_que
  	for (i = 0; i < iov_count; i++)
  		len += iov[i].iov_len;
  
@@ -632,7 +632,7 @@
  
  #endif /* _SCSI_SCSI_CMND_H */
 diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index 467274a..6b06850 100644
+index 8279929..8b799db 100644
 --- a/include/scsi/scsi_host.h
 +++ b/include/scsi/scsi_host.h
 @@ -7,6 +7,7 @@
@@ -680,7 +680,7 @@
  	 * This is an error handling strategy routine.  You don't need to
  	 * define one of these if you don't want to - there is a default
  	 * routine that is present that should work in most cases.  For those
-@@ -573,6 +604,12 @@ struct Scsi_Host {
+@@ -572,6 +603,12 @@ struct Scsi_Host {
  	 */
  	unsigned int max_host_blocked;
  
@@ -693,7 +693,7 @@
  	/* legacy crap */
  	unsigned long base;
  	unsigned long io_port;
-@@ -675,6 +712,9 @@ extern void scsi_unblock_requests(struct
+@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
  extern void scsi_block_requests(struct Scsi_Host *);
  
  struct class_container;



From tomo at berlios.de  Sun Feb  5 13:05:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 13:05:33 +0100
Subject: [Stgt-svn] r264 - in trunk: . include kernel usr
Message-ID: <200602051205.k15C5X01028470@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 13:05:13 +0100 (Sun, 05 Feb 2006)
New Revision: 264

Added:
   trunk/kernel/tgt_packet.c
Modified:
   trunk/include/tgt_if.h
   trunk/initd
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_target.h
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.h
Log:
Replace TGT_KEVENT_CMD_REQ netlink with packet socket.

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/include/tgt_if.h	2006-02-05 12:05:13 UTC (rev 264)
@@ -29,6 +29,7 @@
 			char type[32];
 			int nr_cmds;
 			int pid;
+			int fd;
 		} c_target;
 		struct {
 			int tid;

Modified: trunk/initd
===================================================================
--- trunk/initd	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/initd	2006-02-05 12:05:13 UTC (rev 264)
@@ -28,7 +28,7 @@
 	sleep 1
 
 	${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-	${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
+	${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/hdc1
 }
 	
 stop_server()

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/kernel/Makefile	2006-02-05 12:05:13 UTC (rev 264)
@@ -6,7 +6,7 @@
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= tgt_core.o
-tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o
+tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o tgt_packet.o
 
 obj-m		+= tgt_scsi.o
 else

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/kernel/tgt.c	2006-02-05 12:05:13 UTC (rev 264)
@@ -15,6 +15,7 @@
 #include <linux/blkdev.h>
 #include <linux/file.h>
 #include <linux/hash.h>
+#include <linux/net.h>
 #include <asm/scatterlist.h>
 
 #include <tgt.h>
@@ -197,19 +198,26 @@
 	return target;
 }
 
-struct tgt_target *tgt_target_create(char *target_type, int queued_cmds, int pid)
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmds, int pid, int fd)
 {
 	char name[16];
-	static int i, target_id;
+	static int target_id;
+	static int i, err;
 	struct tgt_target *target;
 	struct target_type_internal *ti;
+	struct socket *sock;
 
-	dprintk("%s %d %d\n", target_type, queued_cmds, pid);
+	dprintk("%s %d %d %d\n", target_type, queued_cmds, pid, fd);
 
 	target = kzalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
 
+	sock = sockfd_lookup(fd, &err);
+	eprintk("%d\n", err);
+	target->sock = sock;
+	fget(fd);
+
 	target->tsk = find_task_by_pid(pid);
 	if (!target->tsk)
 		goto free_target;
@@ -276,6 +284,9 @@
 
 	dprintk("%p\n", target);
 
+	if (target->sock)
+		fput(target->sock->file);
+
 	spin_lock_irqsave(&target->lock, flags);
 	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
 	if (target->state == TGT_DESTROYED)

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/kernel/tgt_nl.c	2006-02-05 12:05:13 UTC (rev 264)
@@ -19,43 +19,6 @@
 static struct sock *nls;
 static void *zero_page;
 
-int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
-{
-	struct tgt_protocol *proto = cmd->session->target->proto;
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	pid_t pid = cmd->session->target->tsk->pid;
-	char *pdu;
-	int err, len, proto_pdu_size = proto->uspace_pdu_size;
-
-	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev->data;
-	ev->k.cmd_req.tid = cmd->session->target->tid;
-	ev->k.cmd_req.cid = cmd_tag(cmd);
-	ev->k.cmd_req.typeid = cmd->session->target->typeid;
-	ev->k.cmd_req.data_len = cmd->bufflen;
-
-	proto->uspace_pdu_build(cmd, pdu);
-	err = netlink_unicast(nls, skb, pid, 0);
-	if (err < 0) {
-		eprintk("%d %d\n", pid, err);
-		BUG();
-	}
-	return err;
-}
-EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
-
 static int send_event_res(uint16_t type, struct tgt_event *p,
 			  void *data, int dlen, gfp_t flags, uint32_t pid)
 {
@@ -136,7 +99,8 @@
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
 					   ev->u.c_target.nr_cmds,
-					   ev->u.c_target.pid);
+					   ev->u.c_target.pid,
+					   ev->u.c_target.fd);
 		if (target) {
 			err = target->tid;
 			dprintk("%d %d %d\n", target->tid,

Added: trunk/kernel/tgt_packet.c
===================================================================
--- trunk/kernel/tgt_packet.c	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/kernel/tgt_packet.c	2006-02-05 12:05:13 UTC (rev 264)
@@ -0,0 +1,65 @@
+/*
+ * Target packet socket code
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <net/sock.h>
+#include <net/af_packet.h>
+#include <linux/if_packet.h>
+
+#include <tgt.h>
+#include <tgt_target.h>
+#include <tgt_if.h>
+#include <tgt_protocol.h>
+#include "tgt_priv.h"
+
+int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
+{
+	struct tgt_protocol *proto = cmd->session->target->proto;
+	int proto_pdu_size = proto->uspace_pdu_size;
+	struct sock *sk = cmd->session->target->sock->sk;
+	struct tpacket_hdr *h;
+	struct tgt_event *ev;
+	char *pdu;
+
+	h = packet_frame(sk);
+	if (IS_ERR(h)) {
+		eprintk("Queue is full\n");
+		return PTR_ERR(h);
+	}
+
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+	pdu = (char *) ev->data;
+
+	ev->k.cmd_req.tid = cmd->session->target->tid;
+	ev->k.cmd_req.cid = cmd_tag(cmd);
+	ev->k.cmd_req.typeid = cmd->session->target->typeid;
+	ev->k.cmd_req.data_len = cmd->bufflen;
+
+	proto->uspace_pdu_build(cmd, pdu);
+
+	dprintk("%d %llu %d %d\n", ev->k.cmd_req.tid, ev->k.cmd_req.cid,
+		ev->k.cmd_req.typeid, ev->k.cmd_req.data_len);
+
+	h->tp_status = TP_STATUS_USER;
+	mb();
+	{
+		struct page *p_start, *p_end;
+		char *h_end = pdu + TPACKET_HDRLEN + proto_pdu_size - 1;
+
+		p_start = virt_to_page(h);
+		p_end = virt_to_page(h_end);
+		while (p_start <= p_end) {
+			flush_dcache_page(p_start);
+			p_start++;
+		}
+	}
+
+	sk->sk_data_ready(sk, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/kernel/tgt_target.h	2006-02-05 12:05:13 UTC (rev 264)
@@ -124,12 +124,14 @@
 
 	struct workqueue_struct *twq;
 	struct task_struct *tsk;
+	struct socket *sock;
 };
 
 #define cdev_to_tgt_target(cdev) \
 	container_of(cdev, struct tgt_target, cdev)
 
-extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds, int pid);
+extern struct tgt_target *tgt_target_create(char *target_type,
+					    int nr_cmds, int pid, int fd);
 extern int tgt_target_destroy(struct tgt_target *target);
 
 extern int tgt_target_template_register(struct tgt_target_template *tt);

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/usr/mgmt.c	2006-02-05 12:05:13 UTC (rev 264)
@@ -18,8 +18,8 @@
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <linux/netlink.h>
 #include <linux/types.h>
-#include <linux/netlink.h>
 
 #include <tgt_if.h>
 #include "tgtd.h"
@@ -75,25 +75,27 @@
 {
 	sprintf(ev->u.c_target.type, "%s", typeid_to_name(dlinfo, req->typeid));
 	ev->u.c_target.pid = req->pid;
+	ev->u.c_target.fd = req->fd;
 }
 
 int ktarget_create(int typeid)
 {
 	struct tgtadm_req req;
-	int fd, err;
+	int fd[2], err;
 
 	req.typeid = typeid;
-	req.pid = target_thread_create(&fd);
+	req.pid = target_thread_create(fd);
+	req.fd = fd[1];
 	err = tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
 				__ktarget_create);
 	if (err >= 0) {
-		dprintf("%d %d\n", err, fd);
+		dprintf("%d %d\n", err, fd[0]);
 
 		/* FIXME */
 		if (err > POLLS_PER_DRV)
 			eprintf("too large tid %d\n", err);
 		else {
-			poll_array[POLLS_PER_DRV + err].fd = fd;
+			poll_array[POLLS_PER_DRV + err].fd = fd[0];
 			poll_array[POLLS_PER_DRV + err].events = POLLIN;
 		}
 	}

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/usr/target.c	2006-02-05 12:05:13 UTC (rev 264)
@@ -14,15 +14,20 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <netinet/in.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/user.h>
 #include <linux/fs.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
 #include <linux/netlink.h>
 
 #include <tgt_if.h>
+#include <tgt_scsi_if.h>
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "dl.h"
@@ -34,6 +39,7 @@
 enum {
 	POLL_IPC_CTRL,
 	POLL_NL_CMD,
+	POLL_PACKET,
 };
 
 struct device {
@@ -46,10 +52,15 @@
 };
 
 struct target {
-	struct pollfd pfd[2];
+	struct pollfd pfd[3];
 
 	struct device **devt;
 	uint64_t max_device;
+
+	char *ringbuf;
+	uint32_t frame_size;
+	uint32_t frame_nr;
+	uint32_t idx;
 };
 
 static struct target *target;
@@ -296,7 +307,7 @@
 
 	memset(resbuf, 0, sizeof(resbuf));
 	pdu = (uint8_t *) ev_req->data;
-	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
+	dprintf("%d %" PRIu64 " %x\n", tid, cid, pdu[0]);
 
 	if (!get_devid)
 		get_devid = dl_proto_get_devid(dinfo, tid, typeid);
@@ -425,12 +436,64 @@
 	return bind(fd, (struct sockaddr *)&addr, sizeof(addr));
 }
 
-static void tthread_event_loop(struct target *target)
+static void packet_cmd(struct driver_info *dinfo, int fd)
 {
+	struct tpacket_hdr *h;
+
+retry:
+	h = (struct tpacket_hdr *) (target->ringbuf + target->idx * target->frame_size);
+
+	dprintf("%lx %u\n", h->tp_status, target->idx);
+	if (!(h->tp_status & TP_STATUS_USER))
+		return;
+
+	cmd_queue(dinfo, fd, (char *) h + TPACKET_HDRLEN);
+	target->idx = target->idx == target->frame_nr - 1 ? 0: target->idx + 1;
+	h->tp_status &= ~TP_STATUS_USER;
+
+	goto retry;
+}
+
+static void *ringbuf_init(int fd)
+{
+	struct tpacket_req req;
+	int err;
+	socklen_t len = sizeof(req);
+	unsigned int size = PAGE_SIZE * 8;
+	void *ptr;
+
+	req.tp_frame_size = TPACKET_ALIGN(TPACKET_HDRLEN +
+					  sizeof(struct tgt_event) +
+					  sizeof(struct tgt_scsi_cmd));
+	req.tp_block_size = size;
+	req.tp_frame_nr = req.tp_block_size / req.tp_frame_size;
+	req.tp_block_nr = 1;
+
+	err = setsockopt(fd, SOL_PACKET, PACKET_RX_RING, &req, len);
+	dprintf("%d %u %u\n", err, req.tp_frame_size, req.tp_frame_nr);
+	if (err < 0)
+		return NULL;
+
+	ptr = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
+	if (ptr == MAP_FAILED) {
+		eprintf("fail to mmap\n");
+		ptr = NULL;
+	}
+
+	target->frame_size = req.tp_frame_size;
+	target->frame_nr = req.tp_frame_nr;
+
+	return ptr;
+}
+
+static void tthread_event_loop(struct target *target, int packetfd)
+{
 	struct driver_info d[MAX_DL_HANDLES];
 	struct pollfd *pfd = target->pfd;
 	int fd, err;
 
+	target->ringbuf = ringbuf_init(packetfd);
+	dprintf("%p %d\n", target->ringbuf, packetfd);
 	fd = nl_init();
 	dprintf("%d\n", fd);
 	err = bind_nls(fd);
@@ -439,13 +502,16 @@
 	target->pfd[POLL_NL_CMD].fd = fd;
 	target->pfd[POLL_NL_CMD].events = POLLIN;
 
+	target->pfd[POLL_PACKET].fd = packetfd;
+	target->pfd[POLL_PACKET].events = POLLIN;
+
 	err = dl_init(d);
 	dprintf("%d\n", err);
 
 	dprintf("Target thread started %u %d\n", getpid(), fd);
 
 	while (1) {
-		err = poll(pfd, 2, -1);
+		err = poll(pfd, 3, -1);
 		dprintf("target thread event %d\n", err);
 
 		if (err < 0) {
@@ -460,6 +526,9 @@
 
 		if (pfd[POLL_NL_CMD].revents)
 			nl_cmd(d, pfd[POLL_NL_CMD].fd);
+
+		if (pfd[POLL_PACKET].revents)
+			packet_cmd(d, pfd[POLL_NL_CMD].fd);
 	}
 
 	free(target);
@@ -467,7 +536,7 @@
 
 int target_thread_create(int *sfd)
 {
-	pid_t pid;
+	pid_t pid, pfd;
 	int fd[2];
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) {
@@ -475,11 +544,17 @@
 		return -1;
 	}
 
+	pfd = socket(PF_PACKET, SOCK_RAW, 0);
+	dprintf("%d\n", pfd);
+
 	pid = fork();
 	if (pid < 0)
 		return -ENOMEM;
 	else if (pid) {
-		*sfd = fd[0];
+		sfd[0] = fd[0];
+		sfd[1] = pfd;
+
+/* 		close(pfd); */
 		close(fd[1]);
 		return pid;
 	}
@@ -489,6 +564,7 @@
 		eprintf("Out of memoryn\n");
 		exit(1);
 	}
+	memset(target, 0, sizeof(*target));
 
 	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct device *));
 	target->max_device = DEFAULT_NR_DEVICE;
@@ -497,7 +573,7 @@
 	target->pfd[POLL_IPC_CTRL].fd = fd[1];
 	target->pfd[POLL_IPC_CTRL].events = POLLIN;
 
-	tthread_event_loop(target);
+	tthread_event_loop(target, pfd);
 
 	return 0;
 }

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-02-05 03:45:22 UTC (rev 263)
+++ trunk/usr/tgtadm.h	2006-02-05 12:05:13 UTC (rev 264)
@@ -31,6 +31,7 @@
 	int cid;
 	uint64_t lun;
 	int pid;
+	int fd;
 
 	unsigned long addr;
 };



From tomo at berlios.de  Sun Feb  5 13:07:21 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 13:07:21 +0100
Subject: [Stgt-svn] r265 - trunk/kernel
Message-ID: <200602051207.k15C7LJc028711@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 13:06:55 +0100 (Sun, 05 Feb 2006)
New Revision: 265

Added:
   trunk/kernel/tgt-packet.diff
Log:
Add a kernel patch to export packet the socket interface.

Added: trunk/kernel/tgt-packet.diff
===================================================================
--- trunk/kernel/tgt-packet.diff	2006-02-05 12:05:13 UTC (rev 264)
+++ trunk/kernel/tgt-packet.diff	2006-02-05 12:06:55 UTC (rev 265)
@@ -0,0 +1,41 @@
+diff --git a/include/net/af_packet.h b/include/net/af_packet.h
+new file mode 100644
+index 0000000..e280e7c
+--- /dev/null
++++ b/include/net/af_packet.h
+@@ -0,0 +1,6 @@
++#ifndef __LINUX_NET_AFPACKET_H
++#define __LINUX_NET_AFPACKET_H
++
++extern void *packet_frame(struct sock *sk);
++
++#endif
+diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
+index 9db7dbd..aee86cd 100644
+--- a/net/packet/af_packet.c
++++ b/net/packet/af_packet.c
+@@ -562,6 +562,24 @@ drop:
+ }
+ 
+ #ifdef CONFIG_PACKET_MMAP
++void *packet_frame(struct sock *sk)
++{
++	struct packet_sock *po;
++	struct tpacket_hdr *h;
++	int err;
++
++	po = pkt_sk(sk);
++	spin_lock(&sk->sk_receive_queue.lock);
++	h = (struct tpacket_hdr *) packet_lookup_frame(po, po->head);
++	if (h->tp_status)
++		h = ERR_PTR(-ENOBUFS);
++	else
++		po->head = po->head != po->frame_max ? po->head+1 : 0;
++	spin_unlock(&sk->sk_receive_queue.lock);
++	return h;
++}
++EXPORT_SYMBOL_GPL(packet_frame);
++
+ static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
+ {
+ 	struct sock *sk;



From tomo at berlios.de  Sun Feb  5 13:29:51 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 13:29:51 +0100
Subject: [Stgt-svn] r266 - branches/use-scsi-ml/kernel
Message-ID: <200602051229.k15CTp41010547@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 13:29:45 +0100 (Sun, 05 Feb 2006)
New Revision: 266

Added:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
Removed:
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
Modified:
   branches/use-scsi-ml/kernel/Makefile
Log:
Rename scsi_tgt_nl.c scsi_tgt_if.c. scsi_tgt_if.c has netlink and packet socket code.


Modified: branches/use-scsi-ml/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/kernel/Makefile	2006-02-05 12:06:55 UTC (rev 265)
+++ branches/use-scsi-ml/kernel/Makefile	2006-02-05 12:29:45 UTC (rev 266)
@@ -6,7 +6,7 @@
 
 ifneq ($(KERNELRELEASE),)
 obj-m			+= scsi_tgt_core.o
-scsi_tgt_core-objs	:= scsi_tgt_lib.o scsi_tgt_nl.o
+scsi_tgt_core-objs	:= scsi_tgt_lib.o scsi_tgt_if.o
 
 else
 

Copied: branches/use-scsi-ml/kernel/scsi_tgt_if.c (from rev 262, branches/use-scsi-ml/kernel/scsi_tgt_nl.c)

Deleted: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-05 12:06:55 UTC (rev 265)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-02-05 12:29:45 UTC (rev 266)
@@ -1,246 +0,0 @@
-/*
- * Target Netlink Framework code
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/netlink.h>
-#include <linux/blkdev.h>
-#include <net/tcp.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_tgt_if.h>
-
-#include "scsi_tgt_priv.h"
-
-/* default task when host is not setup in userspace yet */
-static int tgtd_pid;
-static struct sock *nls;
-
-static int scsi_tgt_get_pid(struct Scsi_Host *shost)
-{
-	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
-
-	if (likely(queue->task))
-		return queue->task->pid;
-	else {
-		printk(KERN_INFO "Sending cmd to tgtd. Host%d is unbound\n",
-		       shost->host_no);
-		return tgtd_pid;
-	}
-}
-
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-{
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	char *pdu;
-	int len, err;
-	pid_t pid;
-
-	pid = scsi_tgt_get_pid(cmd->shost);
-	len = NLMSG_SPACE(sizeof(*ev) +
-			  MAX_COMMAND_SIZE + sizeof(struct scsi_lun));
-	/*
-	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
-	 */
-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), MAX_COMMAND_SIZE);
-	nlh = __nlmsg_put(skb, pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev->data;
-	ev->k.cmd_req.host_no = cmd->shost->host_no;
-	ev->k.cmd_req.cid = cmd->request->tag;
-	ev->k.cmd_req.data_len = cmd->request_bufflen;
-
-	/* FIXME: we need scsi core to do that. */
-	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-	memcpy(pdu, cmd->cmnd, MAX_COMMAND_SIZE);
-	memcpy(pdu + MAX_COMMAND_SIZE, cmd->request->end_io_data,
-	       sizeof(struct scsi_lun));
-
-	err = netlink_unicast(nls, skb, pid, 0);
-	if (err < 0)
-		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb "
-		      "to pid %d err %d\n", pid, err);
-	return err;
-}
-
-static int send_event_res(uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags, pid_t pid)
-{
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len;
-
-	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-	skb = alloc_skb(len, flags);
-	if (!skb)
-		return -ENOMEM;
-
-	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-
-	ev = NLMSG_DATA(nlh);
-	memcpy(ev, p, sizeof(*ev));
-	if (dlen)
-		memcpy(ev->data, data, dlen);
-
-	return netlink_unicast(nls, skb, pid, 0);
-}
-
-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-{
-	struct tgt_event ev;
-	char dummy[MAX_COMMAND_SIZE + sizeof(struct scsi_lun)];
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.host_no = cmd->shost->host_no;
-	ev.k.cmd_done.cid = cmd->request->tag;
-	ev.k.cmd_done.result = cmd->result;
-
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-			      gfp_mask, scsi_tgt_get_pid(cmd->shost));
-}
-
-static int scsi_tgt_bind_host(struct tgt_event *ev)
-{
-	struct Scsi_Host *shost;
-	struct task_struct *tsk;
-	int err = 0;
-
-	dprintk("%d %d\n", ev->u.target_bind.host_no, ev->u.target_bind.pid);
-
-	shost = scsi_host_lookup(ev->u.target_bind.host_no);
-	if (IS_ERR(shost)) {
-		eprintk("Could not find host no %d\n",
-			ev->u.target_bind.host_no);
-			return -EINVAL;
-	}
-
-	tsk = find_task_by_pid(ev->u.target_bind.pid);
-	if (tsk) {
-		struct scsi_tgt_queuedata *queue;
-
-		queue = shost->uspace_req_q->queuedata;
-		queue->task = tsk;
-	} else {
-		eprintk("Could not find process %d\n",
-			ev->u.target_bind.pid);
-		err = EINVAL;
-	}
-
-	scsi_host_put(shost);
-	return 0;
-}
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	struct tgt_event *ev = NLMSG_DATA(nlh);
-	int err = 0;
-
-	dprintk("%d %d %d\n", nlh->nlmsg_type,
-		nlh->nlmsg_pid, current->pid);
-
-	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_START:
-		tgtd_pid = NETLINK_CREDS(skb)->pid;
-		break;
-	case TGT_UEVENT_TARGET_BIND:
-		err = scsi_tgt_bind_host(ev);
-		break;
-	case TGT_UEVENT_CMD_RES:
-		/* TODO: handle multiple cmds in one event */
-		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
-					   ev->u.cmd_res.cid,
-					   ev->u.cmd_res.result,
-					   ev->u.cmd_res.len,
-					   ev->u.cmd_res.offset,
-					   ev->u.cmd_res.uaddr,
-					   ev->u.cmd_res.rw,
-					   ev->u.cmd_res.try_map);
-		break;
-	default:
-		eprintk("unknown type %d\n", nlh->nlmsg_type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		err = event_recv_msg(skb, nlh);
-
-		dprintk("%d %d\n", nlh->nlmsg_type, err);
-		/*
-		 * TODO for passthru commands the lower level should
-		 * probably handle the result or we should modify this
-		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
-			struct tgt_event ev;
-
-			memset(&ev, 0, sizeof(ev));
-			ev.k.event_res.err = err;
-			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-				       GFP_KERNEL | __GFP_NOFAIL,
-					nlh->nlmsg_pid);
-		}
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (NETLINK_CREDS(skb)->uid) {
-			skb_pull(skb, skb->len);
-			kfree_skb(skb);
-			continue;
-		}
-
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
-void __exit scsi_tgt_nl_exit(void)
-{
-	sock_release(nls->sk_socket);
-}
-
-int __init scsi_tgt_nl_init(void)
-{
-	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
-				    THIS_MODULE);
-	if (!nls)
-		return -ENOMEM;
-
-	return 0;
-}



From tomo at berlios.de  Sun Feb  5 15:45:44 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 15:45:44 +0100
Subject: [Stgt-svn] r267 - branches/use-scsi-ml/kernel
Message-ID: <200602051445.k15Eji29031621@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 15:45:44 +0100 (Sun, 05 Feb 2006)
New Revision: 267

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Replace TGT_KEVENT_CMD_REQ netlink with packet socket. Note that I
don't finish the user-space code yet. This tree is broken now.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-05 12:29:45 UTC (rev 266)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-05 14:45:44 UTC (rev 267)
@@ -6,8 +6,10 @@
  * This code is licenced under the GPL.
  */
 
+#include <linux/blkdev.h>
+#include <linux/if_packet.h>
 #include <linux/netlink.h>
-#include <linux/blkdev.h>
+#include <net/af_packet.h>
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -33,47 +35,67 @@
 	}
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+static struct sock *scsi_tgt_get_sock(struct Scsi_Host *shost)
 {
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
+	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
+	struct socket *sock = queue->sock;
+	return sock ? sock->sk : NULL;
+}
+
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd)
+{
+	struct sock *sk;
+	struct tpacket_hdr *h;
 	struct tgt_event *ev;
-	char *pdu;
-	int len, err;
-	pid_t pid;
+	struct tgt_cmd *tcmd;
 
-	pid = scsi_tgt_get_pid(cmd->shost);
-	len = NLMSG_SPACE(sizeof(*ev) +
-			  MAX_COMMAND_SIZE + sizeof(struct scsi_lun));
-	/*
-	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
-	 */
-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-	if (!skb)
-		return -ENOMEM;
+	sk = scsi_tgt_get_sock(cmd->shost);
+	if (!sk) {
+		printk(KERN_INFO "Host%d not connected\n",
+		       cmd->shost->host_no);
+		return -ENOTCONN;
+	}
 
-	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), MAX_COMMAND_SIZE);
-	nlh = __nlmsg_put(skb, pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
+	h = packet_frame(sk);
+	if (IS_ERR(h)) {
+		eprintk("Queue is full\n");
+		return PTR_ERR(h);
+	}
 
-	pdu = (char *) ev->data;
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+
 	ev->k.cmd_req.host_no = cmd->shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
 
+	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
+		ev->k.cmd_req.data_len);
+
 	/* FIXME: we need scsi core to do that. */
 	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-	memcpy(pdu, cmd->cmnd, MAX_COMMAND_SIZE);
-	memcpy(pdu + MAX_COMMAND_SIZE, cmd->request->end_io_data,
-	       sizeof(struct scsi_lun));
 
-	err = netlink_unicast(nls, skb, pid, 0);
-	if (err < 0)
-		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb "
-		      "to pid %d err %d\n", pid, err);
-	return err;
+	tcmd = (struct tgt_cmd *) ev->data;
+	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
+	memcpy(tcmd->lun, cmd->request->end_io_data, sizeof(struct scsi_lun));
+
+	h->tp_status = TP_STATUS_USER;
+	mb();
+	{
+		struct page *p_start, *p_end;
+		char *h_end = (char *) h + TPACKET_HDRLEN +
+			sizeof(struct tgt_event) + sizeof(struct tgt_cmd) - 1;
+
+		p_start = virt_to_page(h);
+		p_end = virt_to_page(h_end);
+		while (p_start <= p_end) {
+			flush_dcache_page(p_start);
+			p_start++;
+		}
+	}
+
+	sk->sk_data_ready(sk, 0);
+
+	return 0;
 }
 
 static int send_event_res(uint16_t type, struct tgt_event *p,
@@ -113,13 +135,15 @@
 			      gfp_mask, scsi_tgt_get_pid(cmd->shost));
 }
 
+/* TODO: unbind to call fput. */
 static int scsi_tgt_bind_host(struct tgt_event *ev)
 {
 	struct Scsi_Host *shost;
 	struct task_struct *tsk;
 	int err = 0;
 
-	dprintk("%d %d\n", ev->u.target_bind.host_no, ev->u.target_bind.pid);
+	dprintk("%d %d %d\n", ev->u.target_bind.host_no,
+		ev->u.target_bind.pid, ev->u.target_bind.psfd);
 
 	shost = scsi_host_lookup(ev->u.target_bind.host_no);
 	if (IS_ERR(shost)) {
@@ -134,6 +158,7 @@
 
 		queue = shost->uspace_req_q->queuedata;
 		queue->task = tsk;
+		queue->sock = sockfd_lookup(ev->u.target_bind.psfd, &err);
 	} else {
 		eprintk("Could not find process %d\n",
 			ev->u.target_bind.pid);
@@ -141,7 +166,7 @@
 	}
 
 	scsi_host_put(shost);
-	return 0;
+	return err;
 }
 
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-05 12:29:45 UTC (rev 266)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-05 14:45:44 UTC (rev 267)
@@ -49,7 +49,7 @@
 			break;
 
 		spin_unlock_irq(q->queue_lock);
-		if (scsi_tgt_uspace_send(cmd, GFP_ATOMIC) < 0)
+		if (scsi_tgt_uspace_send(cmd) < 0)
 			goto requeue;
 		spin_lock_irq(q->queue_lock);
 	}

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-05 12:29:45 UTC (rev 266)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-05 14:45:44 UTC (rev 267)
@@ -11,12 +11,13 @@
 
 struct scsi_tgt_queuedata {
 	struct task_struct *task;
+	struct socket *sock;
 };
 
 extern void scsi_tgt_nl_exit(void);
 extern int scsi_tgt_nl_init(void);
 
-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, gfp_t gfp_mask);
+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				u64 offset, unsigned long uaddr, u8 rw,



From tomo at berlios.de  Sun Feb  5 15:57:30 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 15:57:30 +0100
Subject: [Stgt-svn] r268 - branches/use-scsi-ml/kernel
Message-ID: <200602051457.k15EvUU9000298@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 15:57:30 +0100 (Sun, 05 Feb 2006)
New Revision: 268

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Update the kernel patch.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-05 14:45:44 UTC (rev 267)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-05 14:57:30 UTC (rev 268)
@@ -568,6 +568,18 @@
  
  #define	LEVEL_MULTIPATH		(-4)
  #define	LEVEL_LINEAR		(-1)
+diff --git a/include/net/af_packet.h b/include/net/af_packet.h
+new file mode 100644
+index 0000000..e280e7c
+--- /dev/null
++++ b/include/net/af_packet.h
+@@ -0,0 +1,6 @@
++#ifndef __LINUX_NET_AFPACKET_H
++#define __LINUX_NET_AFPACKET_H
++
++extern void *packet_frame(struct sock *sk);
++
++#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
 index 7529f43..ce97272 100644
 --- a/include/scsi/scsi_cmnd.h
@@ -721,10 +733,10 @@
 +extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
 diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
 new file mode 100644
-index 0000000..f7961d6
+index 0000000..51ada8d
 --- /dev/null
 +++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,71 @@
+@@ -0,0 +1,81 @@
 +/*
 + * SCSI target netlink interface
 + *
@@ -745,7 +757,6 @@
 +
 +	/* kernel -> user */
 +	TGT_KEVENT_RESPONSE,
-+	TGT_KEVENT_CMD_REQ,
 +	TGT_KEVENT_CMD_DONE,
 +};
 +
@@ -755,6 +766,7 @@
 +		struct {
 +			int host_no;
 +			int pid;
++			int psfd;
 +		} target_bind;
 +		struct {
 +			int host_no;
@@ -795,4 +807,43 @@
 +	uint64_t data[0];
 +} __attribute__ ((aligned (sizeof(uint64_t))));
 +
++#ifndef __KERNEL__
++#define MAX_COMMAND_SIZE	16
 +#endif
++
++struct tgt_cmd {
++	uint8_t scb[MAX_COMMAND_SIZE];
++	uint8_t lun[8];
++	int tags;
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif
+diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
+index 9db7dbd..aee86cd 100644
+--- a/net/packet/af_packet.c
++++ b/net/packet/af_packet.c
+@@ -562,6 +562,24 @@ drop:
+ }
+ 
+ #ifdef CONFIG_PACKET_MMAP
++void *packet_frame(struct sock *sk)
++{
++	struct packet_sock *po;
++	struct tpacket_hdr *h;
++	int err;
++
++	po = pkt_sk(sk);
++	spin_lock(&sk->sk_receive_queue.lock);
++	h = (struct tpacket_hdr *) packet_lookup_frame(po, po->head);
++	if (h->tp_status)
++		h = ERR_PTR(-ENOBUFS);
++	else
++		po->head = po->head != po->frame_max ? po->head+1 : 0;
++	spin_unlock(&sk->sk_receive_queue.lock);
++	return h;
++}
++EXPORT_SYMBOL_GPL(packet_frame);
++
+ static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
+ {
+ 	struct sock *sk;



From tomo at berlios.de  Sun Feb  5 17:30:14 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 5 Feb 2006 17:30:14 +0100
Subject: [Stgt-svn] r269 - in trunk: include kernel usr
Message-ID: <200602051630.k15GUEJi011624@sheep.berlios.de>

Author: tomo
Date: 2006-02-05 17:30:14 +0100 (Sun, 05 Feb 2006)
New Revision: 269

Modified:
   trunk/include/tgt_if.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_packet.c
   trunk/usr/target.c
Log:
Replace TGT_KEVENT_CMD_DONE with packet socket.

Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2006-02-05 14:57:30 UTC (rev 268)
+++ trunk/include/tgt_if.h	2006-02-05 16:30:14 UTC (rev 269)
@@ -23,6 +23,7 @@
 };
 
 struct tgt_event {
+	int type;
 	/* user-> kernel */
 	union {
 		struct {

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2006-02-05 14:57:30 UTC (rev 268)
+++ trunk/kernel/tgt_nl.c	2006-02-05 16:30:14 UTC (rev 269)
@@ -56,27 +56,6 @@
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
-int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags)
-{
-	struct tgt_protocol *proto = cmd->session->target->proto;
-	struct tgt_event ev;
-	pid_t pid = cmd->session->target->tsk->pid;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.tid = cmd->session->target->tid;
-	ev.k.cmd_done.typeid = cmd->session->target->typeid;
-	ev.k.cmd_done.devid = cmd->devid;
-	ev.k.cmd_done.uaddr = cmd->uaddr;
-	ev.k.cmd_done.len = cmd->bufflen;
-	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
-		ev.k.cmd_done.mmapped = 1;
-
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev,
-			      zero_page,
-			      proto->uspace_pdu_size, flags, pid);
-}
-EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
-
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;

Modified: trunk/kernel/tgt_packet.c
===================================================================
--- trunk/kernel/tgt_packet.c	2006-02-05 14:57:30 UTC (rev 268)
+++ trunk/kernel/tgt_packet.c	2006-02-05 16:30:14 UTC (rev 269)
@@ -16,6 +16,56 @@
 #include <tgt_protocol.h>
 #include "tgt_priv.h"
 
+static struct tpacket_hdr *tp_hdr_get(struct sock *sk)
+{
+	struct tpacket_hdr *h;
+	h = packet_frame(sk);
+	return IS_ERR(h) ? NULL : h;
+}
+
+static void tp_send(struct sock *sk, struct tpacket_hdr *h, int len)
+{
+	h->tp_status = TP_STATUS_USER;
+	mb();
+	{
+		struct page *p_start, *p_end;
+		char *h_end = (char *) h + TPACKET_HDRLEN + len - 1;
+
+		p_start = virt_to_page(h);
+		p_end = virt_to_page(h_end);
+		while (p_start <= p_end) {
+			flush_dcache_page(p_start);
+			p_start++;
+		}
+	}
+	sk->sk_data_ready(sk, 0);
+}
+
+int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
+{
+	struct sock *sk = cmd->session->target->sock->sk;
+	struct tpacket_hdr *h;
+	struct tgt_event *ev;
+
+	h = tp_hdr_get(sk);
+	if (!h)
+		return -ENOMEM;
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+
+	ev->type = TGT_KEVENT_CMD_DONE;
+	ev->k.cmd_done.tid = cmd->session->target->tid;
+	ev->k.cmd_done.typeid = cmd->session->target->typeid;
+	ev->k.cmd_done.devid = cmd->devid;
+	ev->k.cmd_done.uaddr = cmd->uaddr;
+	ev->k.cmd_done.len = cmd->bufflen;
+	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
+		ev->k.cmd_done.mmapped = 1;
+
+	tp_send(sk, h, sizeof(struct tgt_event));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
+
 int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
 	struct tgt_protocol *proto = cmd->session->target->proto;
@@ -25,15 +75,13 @@
 	struct tgt_event *ev;
 	char *pdu;
 
-	h = packet_frame(sk);
-	if (IS_ERR(h)) {
-		eprintk("Queue is full\n");
-		return PTR_ERR(h);
-	}
-
+	h = tp_hdr_get(sk);
+	if (!h)
+		return -ENOMEM;
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
 	pdu = (char *) ev->data;
 
+	ev->type = TGT_KEVENT_CMD_REQ;
 	ev->k.cmd_req.tid = cmd->session->target->tid;
 	ev->k.cmd_req.cid = cmd_tag(cmd);
 	ev->k.cmd_req.typeid = cmd->session->target->typeid;
@@ -44,22 +92,7 @@
 	dprintk("%d %llu %d %d\n", ev->k.cmd_req.tid, ev->k.cmd_req.cid,
 		ev->k.cmd_req.typeid, ev->k.cmd_req.data_len);
 
-	h->tp_status = TP_STATUS_USER;
-	mb();
-	{
-		struct page *p_start, *p_end;
-		char *h_end = pdu + TPACKET_HDRLEN + proto_pdu_size - 1;
-
-		p_start = virt_to_page(h);
-		p_end = virt_to_page(h_end);
-		while (p_start <= p_end) {
-			flush_dcache_page(p_start);
-			p_start++;
-		}
-	}
-
-	sk->sk_data_ready(sk, 0);
-
+	tp_send(sk, h, sizeof(struct tgt_event) + proto_pdu_size);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-02-05 14:57:30 UTC (rev 268)
+++ trunk/usr/target.c	2006-02-05 16:30:14 UTC (rev 269)
@@ -439,7 +439,7 @@
 static void packet_cmd(struct driver_info *dinfo, int fd)
 {
 	struct tpacket_hdr *h;
-
+	struct tgt_event *ev;
 retry:
 	h = (struct tpacket_hdr *) (target->ringbuf + target->idx * target->frame_size);
 
@@ -447,7 +447,19 @@
 	if (!(h->tp_status & TP_STATUS_USER))
 		return;
 
-	cmd_queue(dinfo, fd, (char *) h + TPACKET_HDRLEN);
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+	switch (ev->type) {
+	case TGT_KEVENT_CMD_REQ:
+		cmd_queue(dinfo, fd, (char *) ev);
+		break;
+	case TGT_KEVENT_CMD_DONE:
+		cmd_done(dinfo, (char *) ev);
+		break;
+	default:
+		eprintf("unknown event %u\n", ev->type);
+		exit(1);
+	}
+
 	target->idx = target->idx == target->frame_nr - 1 ? 0: target->idx + 1;
 	h->tp_status &= ~TP_STATUS_USER;
 



From tomo at berlios.de  Mon Feb  6 02:34:46 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 02:34:46 +0100
Subject: [Stgt-svn] r270 - branches/use-scsi-ml/kernel
Message-ID: <200602060134.k161YkiY013744@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 02:34:25 +0100 (Mon, 06 Feb 2006)
New Revision: 270

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Kill shost in scsi_cmnd (use device->host).

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-05 16:30:14 UTC (rev 269)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 01:34:25 UTC (rev 270)
@@ -13,6 +13,7 @@
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tgt_if.h>
 
@@ -49,10 +50,10 @@
 	struct tgt_event *ev;
 	struct tgt_cmd *tcmd;
 
-	sk = scsi_tgt_get_sock(cmd->shost);
+	sk = scsi_tgt_get_sock(cmd->device->host);
 	if (!sk) {
 		printk(KERN_INFO "Host%d not connected\n",
-		       cmd->shost->host_no);
+		       cmd->device->host->host_no);
 		return -ENOTCONN;
 	}
 
@@ -64,7 +65,7 @@
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
 
-	ev->k.cmd_req.host_no = cmd->shost->host_no;
+	ev->k.cmd_req.host_no = cmd->device->host->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
 
@@ -127,12 +128,12 @@
 	char dummy[MAX_COMMAND_SIZE + sizeof(struct scsi_lun)];
 
 	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.host_no = cmd->shost->host_no;
+	ev.k.cmd_done.host_no = cmd->device->host->host_no;
 	ev.k.cmd_done.cid = cmd->request->tag;
 	ev.k.cmd_done.result = cmd->result;
 
 	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-			      gfp_mask, scsi_tgt_get_pid(cmd->shost));
+			      gfp_mask, scsi_tgt_get_pid(cmd->device->host));
 }
 
 /* TODO: unbind to call fput. */

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-05 16:30:14 UTC (rev 269)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 01:34:25 UTC (rev 270)
@@ -19,10 +19,10 @@
  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/module.h>
-#include <linux/pagemap.h>
+#include <linux/bio-list.h>
 #include <linux/blkdev.h>
 #include <linux/elevator.h>
-#include <linux/bio-list.h>
+#include <linux/pagemap.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -135,7 +135,7 @@
 	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
 	 */
 	cmd->request->end_io_data = scsilun;
-	elv_add_request(cmd->shost->uspace_req_q, cmd->request,
+	elv_add_request(cmd->device->host->uspace_req_q, cmd->request,
 			ELEVATOR_INSERT_BACK, 1);
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
@@ -186,7 +186,7 @@
 
 static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
 {
-	struct Scsi_Host *shost = cmd->shost;
+	struct Scsi_Host *shost = cmd->device->host;
 	int err;
 
 	dprintk("cmd %p\n", cmd);
@@ -242,7 +242,7 @@
 /* TODO: test this crap and replace bio_map_user with new interface maybe */
 static int scsi_map_user_pages(struct scsi_cmnd *cmd, int rw)
 {
-	struct request_queue *q = cmd->shost->uspace_req_q;
+	struct request_queue *q = cmd->device->host->uspace_req_q;
 	struct request *rq = cmd->request;
 	void *uaddr = cmd->buffer;
 	unsigned int len = cmd->bufflen;
@@ -339,7 +339,7 @@
 	bio = bio_list_pop(&cmd->xfer_list);
 	BUG_ON(!bio);
 
-	blk_rq_bio_prep(cmd->shost->uspace_req_q, cmd->request, bio);
+	blk_rq_bio_prep(cmd->device->host->uspace_req_q, cmd->request, bio);
 	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
 	if (err) {
 		cmd->result = DID_ERROR << 16;
@@ -355,8 +355,9 @@
 static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
 {
 	int err;
+	struct Scsi_Host *host = cmd->device->host;
 
-	err = cmd->shost->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
 	switch (err) {
 		case SCSI_MLQUEUE_HOST_BUSY:
 		case SCSI_MLQUEUE_DEVICE_BUSY:



From tomo at berlios.de  Mon Feb  6 02:41:49 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 02:41:49 +0100
Subject: [Stgt-svn] r271 - branches/use-scsi-ml/kernel
Message-ID: <200602060141.k161fnL9015384@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 02:41:20 +0100 (Mon, 06 Feb 2006)
New Revision: 271

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Kill shost in scsi_cmd in the kernel patch.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 01:34:25 UTC (rev 270)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 01:41:20 UTC (rev 271)
@@ -581,7 +581,7 @@
 +
 +#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 7529f43..ce97272 100644
+index 7529f43..6d92a83 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
 @@ -5,9 +5,11 @@
@@ -596,15 +596,7 @@
  struct scsi_device;
  struct scsi_request;
  
-@@ -31,6 +33,7 @@ struct scsi_pointer {
- struct scsi_cmnd {
- 	int     sc_magic;
- 
-+	struct Scsi_Host *shost;
- 	struct scsi_device *device;
- 	struct scsi_request *sc_request;
- 
-@@ -84,6 +87,8 @@ struct scsi_cmnd {
+@@ -84,6 +86,8 @@ struct scsi_cmnd {
  	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
  	unsigned bufflen;	/* Size of data buffer */
  	void *buffer;		/* Data buffer */
@@ -613,7 +605,7 @@
  
  	unsigned underflow;	/* Return error if less than
  				   this amount is transferred */
-@@ -131,6 +136,14 @@ struct scsi_cmnd {
+@@ -131,6 +135,14 @@ struct scsi_cmnd {
  
  	unsigned char tag;	/* SCSI-II queued command tag */
  	unsigned long pid;	/* Process ID, starts at 0. Unique per host. */
@@ -628,7 +620,7 @@
  };
  
  /*
-@@ -147,9 +160,14 @@ struct scsi_cmnd {
+@@ -147,9 +159,14 @@ struct scsi_cmnd {
  #define SCSI_STATE_MLQUEUE         0x100b
  
  



From tomo at berlios.de  Mon Feb  6 07:34:24 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 07:34:24 +0100
Subject: [Stgt-svn] r272 - branches/use-scsi-ml/kernel
Message-ID: <200602060634.k166YOwN002388@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 07:34:17 +0100 (Mon, 06 Feb 2006)
New Revision: 272

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Update the kernel patch.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 01:41:20 UTC (rev 271)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 06:34:17 UTC (rev 272)
@@ -202,10 +202,10 @@
  	kfree(shost->shost_data);
  
 diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 245ca99..3bf557f 100644
+index 245ca99..fbb71e7 100644
 --- a/drivers/scsi/scsi.c
 +++ b/drivers/scsi/scsi.c
-@@ -236,6 +236,59 @@ static struct scsi_cmnd *__scsi_get_comm
+@@ -236,6 +236,58 @@ static struct scsi_cmnd *__scsi_get_comm
  }
  
  /*
@@ -244,7 +244,6 @@
 +	memset(cmd, 0, sizeof(*cmd));
 +	cmd->sc_data_direction = data_dir;
 +	cmd->jiffies_at_alloc = jiffies;
-+	cmd->shost = shost;
 +	cmd->request = rq;
 +
 +	rq->special = cmd;
@@ -265,7 +264,7 @@
   * Function:	scsi_get_command()
   *
   * Purpose:	Allocate and setup a scsi command block
-@@ -274,6 +327,45 @@ struct scsi_cmnd *scsi_get_command(struc
+@@ -274,6 +326,45 @@ struct scsi_cmnd *scsi_get_command(struc
  EXPORT_SYMBOL(scsi_get_command);
  
  /*
@@ -281,8 +280,8 @@
 + */
 +void scsi_host_put_command(struct scsi_cmnd *cmd)
 +{
-+	struct Scsi_Host *shost = cmd->shost;
-+	struct request_queue *q = cmd->shost->uspace_req_q;
++	struct Scsi_Host *shost = cmd->device->host;
++	struct request_queue *q = shost->uspace_req_q;
 +	struct request *rq = cmd->request;
 +	unsigned long flags;
 +
@@ -725,20 +724,33 @@
 +extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
 diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
 new file mode 100644
-index 0000000..51ada8d
+index 0000000..0830107
 --- /dev/null
 +++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,81 @@
+@@ -0,0 +1,95 @@
 +/*
-+ * SCSI target netlink interface
++ * SCSI target kernel/user interface
 + *
-+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * This code is licenced under the GPL.
++ * Copyright 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2, or (at your option)
++ * any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; see the file COPYING.  If not, write to
++ * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 + */
 +
-+#ifndef SCSI_TARGET_FRAMEWORK_IF_H
-+#define SCSI_TARGET_FRAMEWORK_IF_H
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
 +
 +enum tgt_event_type {
 +	/* user -> kernel */
@@ -749,6 +761,7 @@
 +
 +	/* kernel -> user */
 +	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
 +	TGT_KEVENT_CMD_DONE,
 +};
 +



From tomo at berlios.de  Mon Feb  6 07:43:40 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 07:43:40 +0100
Subject: [Stgt-svn] r273 - in branches/use-scsi-ml: ibmvstgt/kernel kernel
Message-ID: <200602060643.k166heVA005349@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 07:43:33 +0100 (Mon, 06 Feb 2006)
New Revision: 273

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
Log:
Cleanup copyright stuff.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-06 06:34:17 UTC (rev 272)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-06 06:43:33 UTC (rev 273)
@@ -4,7 +4,7 @@
  *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
  *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
  *
- * Copyright (C) 2005 - 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 06:34:17 UTC (rev 272)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 06:43:33 UTC (rev 273)
@@ -1,11 +1,23 @@
 /*
- * Target Netlink Framework code
+ * SCSI target kernel/user interface functions
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * Copyright 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, write to
+ * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
 #include <linux/blkdev.h>
 #include <linux/if_packet.h>
 #include <linux/netlink.h>



From tomo at berlios.de  Mon Feb  6 07:47:02 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 07:47:02 +0100
Subject: [Stgt-svn] r274 - branches/use-scsi-ml/kernel
Message-ID: <200602060647.k166l2Aq006153@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 07:46:58 +0100 (Mon, 06 Feb 2006)
New Revision: 274

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Rename scsi_tgt_nl_init/exit scsi_tgt_if_init/exit.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 06:43:33 UTC (rev 273)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 06:46:58 UTC (rev 274)
@@ -268,12 +268,12 @@
 	}
 }
 
-void __exit scsi_tgt_nl_exit(void)
+void __exit scsi_tgt_if_exit(void)
 {
 	sock_release(nls->sk_socket);
 }
 
-int __init scsi_tgt_nl_init(void)
+int __init scsi_tgt_if_init(void)
 {
 	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
 				    THIS_MODULE);

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 06:43:33 UTC (rev 273)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 06:46:58 UTC (rev 274)
@@ -457,7 +457,7 @@
 	if (!scsi_tgtd)
 		return -ENOMEM;
 
-	err = scsi_tgt_nl_init();
+	err = scsi_tgt_if_init();
 	if (err)
 		destroy_workqueue(scsi_tgtd);
 	return err;
@@ -466,7 +466,7 @@
 static void __exit scsi_tgt_exit(void)
 {
 	destroy_workqueue(scsi_tgtd);
-	scsi_tgt_nl_exit();
+	scsi_tgt_if_exit();
 }
 
 module_init(scsi_tgt_init);

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-06 06:43:33 UTC (rev 273)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-06 06:46:58 UTC (rev 274)
@@ -14,8 +14,8 @@
 	struct socket *sock;
 };
 
-extern void scsi_tgt_nl_exit(void);
-extern int scsi_tgt_nl_init(void);
+extern void scsi_tgt_if_exit(void);
+extern int scsi_tgt_if_init(void);
 
 extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);



From tomo at berlios.de  Mon Feb  6 08:23:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Feb 2006 08:23:42 +0100
Subject: [Stgt-svn] r275 - branches/use-scsi-ml/kernel
Message-ID: <200602060723.k167NgA9018109@sheep.berlios.de>

Author: tomo
Date: 2006-02-06 08:23:41 +0100 (Mon, 06 Feb 2006)
New Revision: 275

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
Log:
Replace TGT_KEVENT_CMD_DONE netlink with packet socket.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 06:46:58 UTC (rev 274)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 07:23:41 UTC (rev 275)
@@ -35,19 +35,6 @@
 static int tgtd_pid;
 static struct sock *nls;
 
-static int scsi_tgt_get_pid(struct Scsi_Host *shost)
-{
-	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
-
-	if (likely(queue->task))
-		return queue->task->pid;
-	else {
-		printk(KERN_INFO "Sending cmd to tgtd. Host%d is unbound\n",
-		       shost->host_no);
-		return tgtd_pid;
-	}
-}
-
 static struct sock *scsi_tgt_get_sock(struct Scsi_Host *shost)
 {
 	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
@@ -55,6 +42,24 @@
 	return sock ? sock->sk : NULL;
 }
 
+static void tpacket_done(struct sock *sk, struct tpacket_hdr *h, int len)
+{
+	h->tp_status = TP_STATUS_USER;
+	mb();
+	{
+		struct page *p_start, *p_end;
+		char *h_end = (char *) h + TPACKET_HDRLEN + len - 1;
+
+		p_start = virt_to_page(h);
+		p_end = virt_to_page(h_end);
+		while (p_start <= p_end) {
+			flush_dcache_page(p_start);
+			p_start++;
+		}
+	}
+	sk->sk_data_ready(sk, 0);
+}
+
 int scsi_tgt_uspace_send(struct scsi_cmnd *cmd)
 {
 	struct sock *sk;
@@ -76,7 +81,7 @@
 	}
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-
+	ev->type = TGT_KEVENT_CMD_REQ;
 	ev->k.cmd_req.host_no = cmd->device->host->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
@@ -91,23 +96,36 @@
 	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
 	memcpy(tcmd->lun, cmd->request->end_io_data, sizeof(struct scsi_lun));
 
-	h->tp_status = TP_STATUS_USER;
-	mb();
-	{
-		struct page *p_start, *p_end;
-		char *h_end = (char *) h + TPACKET_HDRLEN +
-			sizeof(struct tgt_event) + sizeof(struct tgt_cmd) - 1;
+	tpacket_done(sk, h, sizeof(struct tgt_event) + sizeof(struct tgt_cmd));
+	return 0;
+}
 
-		p_start = virt_to_page(h);
-		p_end = virt_to_page(h_end);
-		while (p_start <= p_end) {
-			flush_dcache_page(p_start);
-			p_start++;
-		}
+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+{
+	struct sock *sk;
+	struct tgt_event *ev;
+	struct tpacket_hdr *h;
+
+	sk = scsi_tgt_get_sock(cmd->device->host);
+	if (!sk) {
+		printk(KERN_INFO "Host%d not connected\n",
+		       cmd->device->host->host_no);
+		return -ENOTCONN;
 	}
 
-	sk->sk_data_ready(sk, 0);
+	h = packet_frame(sk);
+	if (IS_ERR(h)) {
+		eprintk("Queue is full\n");
+		return PTR_ERR(h);
+	}
 
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+	ev->type = TGT_KEVENT_CMD_DONE;
+	ev->k.cmd_done.host_no = cmd->device->host->host_no;
+	ev->k.cmd_done.cid = cmd->request->tag;
+	ev->k.cmd_done.result = cmd->result;
+
+	tpacket_done(sk, h, sizeof(struct tgt_event));
 	return 0;
 }
 
@@ -134,20 +152,6 @@
 	return netlink_unicast(nls, skb, pid, 0);
 }
 
-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-{
-	struct tgt_event ev;
-	char dummy[MAX_COMMAND_SIZE + sizeof(struct scsi_lun)];
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.host_no = cmd->device->host->host_no;
-	ev.k.cmd_done.cid = cmd->request->tag;
-	ev.k.cmd_done.result = cmd->result;
-
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-			      gfp_mask, scsi_tgt_get_pid(cmd->device->host));
-}
-
 /* TODO: unbind to call fput. */
 static int scsi_tgt_bind_host(struct tgt_event *ev)
 {



From mnc at berlios.de  Mon Feb  6 22:41:52 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Mon, 6 Feb 2006 22:41:52 +0100
Subject: [Stgt-svn] r276 - branches/use-scsi-ml/kernel
Message-ID: <200602062141.k16LfqIi005168@sheep.berlios.de>

Author: mnc
Date: 2006-02-06 22:41:51 +0100 (Mon, 06 Feb 2006)
New Revision: 276

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
we cannot do cmd->device because we have not device in the kernel. Instead we go through cmd->request->q->hostdata to get to the host

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 07:23:41 UTC (rev 275)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 21:41:51 UTC (rev 276)
@@ -27,6 +27,7 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_tgt.h>
 #include <scsi/scsi_tgt_if.h>
 
 #include "scsi_tgt_priv.h"
@@ -62,15 +63,15 @@
 
 int scsi_tgt_uspace_send(struct scsi_cmnd *cmd)
 {
+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct sock *sk;
 	struct tpacket_hdr *h;
 	struct tgt_event *ev;
 	struct tgt_cmd *tcmd;
 
-	sk = scsi_tgt_get_sock(cmd->device->host);
+	sk = scsi_tgt_get_sock(shost);
 	if (!sk) {
-		printk(KERN_INFO "Host%d not connected\n",
-		       cmd->device->host->host_no);
+		printk(KERN_INFO "Host%d not connected\n", shost->host_no);
 		return -ENOTCONN;
 	}
 
@@ -82,7 +83,7 @@
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
 	ev->type = TGT_KEVENT_CMD_REQ;
-	ev->k.cmd_req.host_no = cmd->device->host->host_no;
+	ev->k.cmd_req.host_no = shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
 
@@ -102,14 +103,15 @@
 
 int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
 {
+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct sock *sk;
 	struct tgt_event *ev;
 	struct tpacket_hdr *h;
 
-	sk = scsi_tgt_get_sock(cmd->device->host);
+	sk = scsi_tgt_get_sock(shost);
 	if (!sk) {
 		printk(KERN_INFO "Host%d not connected\n",
-		       cmd->device->host->host_no);
+		       shost->host_no);
 		return -ENOTCONN;
 	}
 
@@ -121,7 +123,7 @@
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
 	ev->type = TGT_KEVENT_CMD_DONE;
-	ev->k.cmd_done.host_no = cmd->device->host->host_no;
+	ev->k.cmd_done.host_no = shost->host_no;
 	ev->k.cmd_done.cid = cmd->request->tag;
 	ev->k.cmd_done.result = cmd->result;
 

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 07:23:41 UTC (rev 275)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 21:41:51 UTC (rev 276)
@@ -88,6 +88,7 @@
 		err = -ENOMEM;
 		goto cleanup_queue;
 	}
+	queuedata->shost = shost;
 	q->queuedata = queuedata;
 
 	elevator_exit(q->elevator);
@@ -119,6 +120,13 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
 
+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
+{
+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
+	return queue->shost;
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+
 /**
  * scsi_tgt_queue_command - queue command for userspace processing
  * @cmd:	scsi command
@@ -135,8 +143,7 @@
 	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
 	 */
 	cmd->request->end_io_data = scsilun;
-	elv_add_request(cmd->device->host->uspace_req_q, cmd->request,
-			ELEVATOR_INSERT_BACK, 1);
+	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
 
@@ -164,7 +171,7 @@
 
 	scsi_unmap_user_pages(cmd);
 	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
-	scsi_host_put_command(cmd);
+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
 }
 
 /*
@@ -186,7 +193,7 @@
 
 static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
 {
-	struct Scsi_Host *shost = cmd->device->host;
+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	int err;
 
 	dprintk("cmd %p\n", cmd);
@@ -242,7 +249,7 @@
 /* TODO: test this crap and replace bio_map_user with new interface maybe */
 static int scsi_map_user_pages(struct scsi_cmnd *cmd, int rw)
 {
-	struct request_queue *q = cmd->device->host->uspace_req_q;
+	struct request_queue *q = cmd->request->q;
 	struct request *rq = cmd->request;
 	void *uaddr = cmd->buffer;
 	unsigned int len = cmd->bufflen;
@@ -339,7 +346,7 @@
 	bio = bio_list_pop(&cmd->xfer_list);
 	BUG_ON(!bio);
 
-	blk_rq_bio_prep(cmd->device->host->uspace_req_q, cmd->request, bio);
+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
 	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
 	if (err) {
 		cmd->result = DID_ERROR << 16;
@@ -355,7 +362,7 @@
 static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
 {
 	int err;
-	struct Scsi_Host *host = cmd->device->host;
+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
 
 	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
 	switch (err) {

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-06 07:23:41 UTC (rev 275)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-06 21:41:51 UTC (rev 276)
@@ -1,4 +1,5 @@
 struct scsi_cmnd;
+struct Scsi_Host;
 struct task_struct;
 
 /* tmp - will replace with SCSI logging stuff */
@@ -12,6 +13,7 @@
 struct scsi_tgt_queuedata {
 	struct task_struct *task;
 	struct socket *sock;
+	struct Scsi_Host *shost;
 };
 
 extern void scsi_tgt_if_exit(void);

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 07:23:41 UTC (rev 275)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 21:41:51 UTC (rev 276)
@@ -186,7 +186,7 @@
  #include <linux/raid/bitmap.h>
  
 diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index 5881079..64e687a 100644
+index ef57f25..a122624 100644
 --- a/drivers/scsi/hosts.c
 +++ b/drivers/scsi/hosts.c
 @@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
@@ -202,10 +202,10 @@
  	kfree(shost->shost_data);
  
 diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 245ca99..fbb71e7 100644
+index d182bad..701973e 100644
 --- a/drivers/scsi/scsi.c
 +++ b/drivers/scsi/scsi.c
-@@ -236,6 +236,58 @@ static struct scsi_cmnd *__scsi_get_comm
+@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
  }
  
  /*
@@ -264,7 +264,7 @@
   * Function:	scsi_get_command()
   *
   * Purpose:	Allocate and setup a scsi command block
-@@ -274,6 +326,45 @@ struct scsi_cmnd *scsi_get_command(struc
+@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
  EXPORT_SYMBOL(scsi_get_command);
  
  /*
@@ -272,15 +272,15 @@
 + *
 + * Purpose:	Free a scsi command block
 + *
-+ * Arguments:	cmd	- command block to free
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
 + *
 + * Returns:	Nothing.
 + *
 + * Notes:	The command must not belong to any lists.
 + */
-+void scsi_host_put_command(struct scsi_cmnd *cmd)
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
 +{
-+	struct Scsi_Host *shost = cmd->device->host;
 +	struct request_queue *q = shost->uspace_req_q;
 +	struct request *rq = cmd->request;
 +	unsigned long flags;
@@ -311,10 +311,10 @@
   *
   * Purpose:	Free a scsi command block
 diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 4a60285..cbd16d6 100644
+index 5ac8749..2dcc500 100644
 --- a/drivers/scsi/scsi_lib.c
 +++ b/drivers/scsi/scsi_lib.c
-@@ -803,7 +803,7 @@ static struct scsi_cmnd *scsi_end_reques
+@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
  	return NULL;
  }
  
@@ -323,7 +323,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  	struct scatterlist *sgl;
-@@ -844,7 +844,9 @@ static struct scatterlist *scsi_alloc_sg
+@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
  	return sgl;
  }
  
@@ -334,7 +334,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  
-@@ -854,6 +856,8 @@ static void scsi_free_sgtable(struct sca
+@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
  	mempool_free(sgl, sgp->pool);
  }
  
@@ -343,7 +343,7 @@
  /*
   * Function:    scsi_release_buffers()
   *
-@@ -1686,29 +1690,40 @@ u64 scsi_calculate_bounce_limit(struct S
+@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
  }
  EXPORT_SYMBOL(scsi_calculate_bounce_limit);
  
@@ -580,7 +580,7 @@
 +
 +#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 7529f43..6d92a83 100644
+index 1ace1b9..aaa8740 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
 @@ -5,9 +5,11 @@
@@ -626,7 +626,7 @@
 +extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
 +					       enum dma_data_direction, gfp_t);
  extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern void scsi_host_put_command(struct scsi_cmnd *);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
  extern void scsi_put_command(struct scsi_cmnd *);
  extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
  extern void scsi_finish_command(struct scsi_cmnd *cmd);
@@ -708,10 +708,10 @@
   * which will connect to the host adapter itself rather than any
 diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
 new file mode 100644
-index 0000000..c1dc0d2
+index 0000000..91ad6bc
 --- /dev/null
 +++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,10 @@
+@@ -0,0 +1,11 @@
 +/*
 + * SCSI target definitions
 + */
@@ -720,6 +720,7 @@
 +struct scsi_cmnd;
 +struct scsi_lun;
 +
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
 +extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
 +extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
 diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h



From mnc at berlios.de  Tue Feb  7 01:40:34 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Tue, 7 Feb 2006 01:40:34 +0100
Subject: [Stgt-svn] r277 - branches/use-scsi-ml/kernel
Message-ID: <200602070040.k170eYvT023410@sheep.berlios.de>

Author: mnc
Date: 2006-02-07 01:40:21 +0100 (Tue, 07 Feb 2006)
New Revision: 277

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
mv most target specific scsi_cmnd fields to private structure. This struct will be deleted when we convert to james's work struct code and do the large bio/request work

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-06 21:41:51 UTC (rev 276)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 00:40:21 UTC (rev 277)
@@ -61,7 +61,7 @@
 	sk->sk_data_ready(sk, 0);
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd)
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct sock *sk;
@@ -95,7 +95,7 @@
 
 	tcmd = (struct tgt_cmd *) ev->data;
 	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
-	memcpy(tcmd->lun, cmd->request->end_io_data, sizeof(struct scsi_lun));
+	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
 
 	tpacket_done(sk, h, sizeof(struct tgt_event) + sizeof(struct tgt_cmd));
 	return 0;

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-06 21:41:51 UTC (rev 276)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 00:40:21 UTC (rev 277)
@@ -27,15 +27,79 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_tgt.h>
 
 #include "scsi_tgt_priv.h"
 
 static struct workqueue_struct *scsi_tgtd;
+static kmem_cache_t *scsi_tgt_cmd_cache;
 
+/*
+ * TODO: this struct will be killed when the block layer supports large bios
+ * and James's work struct code is in
+ */
+struct scsi_tgt_cmd {
+	/* TODO replace work with James b's code */
+	struct work_struct work;
+	/* TODO replace the lists with a large bio */
+	struct bio_list xfer_done_list;
+	struct bio_list xfer_list;
+	struct scsi_lun *lun;
+};
+
+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
+{
+	struct bio *bio;
+
+	/* must call bio_endio in case bio was bounced */
+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
+		bio_endio(bio, bio->bi_size, 0);
+		bio_unmap_user(bio);
+	}
+
+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
+		bio_endio(bio, bio->bi_size, 0);
+		bio_unmap_user(bio);
+	}
+}
+
+static void scsi_tgt_cmd_destroy(void *data)
+{
+	struct scsi_cmnd *cmd = data;
+
+	dprintk("cmd %p\n", cmd);
+
+	scsi_unmap_user_pages(cmd->request->end_io_data);
+	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
+}
+
+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
+{
+	tcmd->lun = rq->end_io_data;
+	bio_list_init(&tcmd->xfer_list);
+	bio_list_init(&tcmd->xfer_done_list);
+}
+
+static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
+{
+	struct scsi_tgt_cmd *tcmd;
+
+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+	if (!tcmd)
+		return BLKPREP_DEFER;
+
+	init_scsi_tgt_cmd(rq, tcmd);
+	rq->end_io_data = tcmd;
+	rq->flags |= REQ_DONTPREP;
+	return BLKPREP_OK;
+}
+
 static void scsi_uspace_request_fn(struct request_queue *q)
 {
 	struct request *rq;
 	struct scsi_cmnd *cmd;
+	struct scsi_tgt_cmd *tcmd;
 
 	/*
 	 * TODO: just send everthing in the queue to userspace in
@@ -43,13 +107,14 @@
 	 */
 	while ((rq = elv_next_request(q)) != NULL) {
 		cmd = rq->special;
+		tcmd = rq->end_io_data;
 
 		/* the completion code kicks us in case we hit this */
 		if (blk_queue_start_tag(q, rq))
 			break;
 
 		spin_unlock_irq(q->queue_lock);
-		if (scsi_tgt_uspace_send(cmd) < 0)
+		if (scsi_tgt_uspace_send(cmd, tcmd->lun) < 0)
 			goto requeue;
 		spin_lock_irq(q->queue_lock);
 	}
@@ -95,6 +160,8 @@
 	err = elevator_init(q, "noop");
 	if (err)
 		goto free_data;
+
+	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
 	/*
 	 * this is a silly hack. We should probably just queue as many
 	 * command as is recvd to userspace. uspace can then make
@@ -147,48 +214,24 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
 
-static void scsi_unmap_user_pages(struct scsi_cmnd *cmd)
-{
-	struct bio *bio;
-
-	/* must call bio_endio in case bio was bounced */
-	while ((bio = bio_list_pop(&cmd->xfer_done_list))) {
-		bio_endio(bio, bio->bi_size, 0);
-		bio_unmap_user(bio);
-	}
-
-	while ((bio = bio_list_pop(&cmd->xfer_list))) {
-		bio_endio(bio, bio->bi_size, 0);
-		bio_unmap_user(bio);
-	}
-}
-
-static void scsi_tgt_cmd_destroy(void *data)
-{
-	struct scsi_cmnd *cmd = data;
-
-	dprintk("cmd %p\n", cmd);
-
-	scsi_unmap_user_pages(cmd);
-	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
-	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-}
-
 /*
  * This is run from a interrpt handler normally and the unmap
  * needs process context so we must queue
  */
 static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
 {
+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+
 	dprintk("cmd %p\n", cmd);
 
+	/* don't we have to call this if result is set or not */
 	if (cmd->result) {
 		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
 		return;
 	}
 
-	INIT_WORK(&cmd->work, scsi_tgt_cmd_destroy, cmd);
-	queue_work(scsi_tgtd, &cmd->work);
+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
+	queue_work(scsi_tgtd, &tcmd->work);
 }
 
 static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
@@ -247,7 +290,8 @@
 }
 
 /* TODO: test this crap and replace bio_map_user with new interface maybe */
-static int scsi_map_user_pages(struct scsi_cmnd *cmd, int rw)
+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
+			       int rw)
 {
 	struct request_queue *q = cmd->request->q;
 	struct request *rq = cmd->request;
@@ -262,9 +306,6 @@
 	 */
 	len = (len + PAGE_SIZE - 1) & PAGE_MASK;
 
-	bio_list_init(&cmd->xfer_list);
-	bio_list_init(&cmd->xfer_done_list);
-
 	while (len > 0) {
 		dprintk("%lx %u\n", (unsigned long) uaddr, len);
 		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
@@ -290,7 +331,7 @@
 			blk_rq_bio_prep(q, rq, bio);
 		else
 			/* put list of bios to transfer in next go around */
-			bio_list_add(&cmd->xfer_list, bio);
+			bio_list_add(&tcmd->xfer_list, bio);
 	}
 
 	cmd->offset = 0;
@@ -303,7 +344,7 @@
 unmap_bios:
 	if (rq->bio) {
 		bio_unmap_user(rq->bio);
-		while ((bio = bio_list_pop(&cmd->xfer_list)))
+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
 			bio_unmap_user(bio);
 	}
 
@@ -314,6 +355,7 @@
 
 static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
 {
+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 	struct bio *bio;
 	int err;
 
@@ -330,12 +372,12 @@
 		cmd, cmd->request_bufflen, cmd->bufflen);
 
 	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-	bio_list_add(&cmd->xfer_done_list, cmd->request->bio);
+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
 
 	cmd->buffer += cmd->request_bufflen;
 	cmd->offset += cmd->request_bufflen;
 
-	if (!cmd->xfer_list.head) {
+	if (!tcmd->xfer_list.head) {
 		scsi_tgt_transfer_response(cmd);
 		return;
 	}
@@ -343,7 +385,7 @@
 	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
 		cmd, cmd->request_bufflen, cmd->bufflen);
 
-	bio = bio_list_pop(&cmd->xfer_list);
+	bio = bio_list_pop(&tcmd->xfer_list);
 	BUG_ON(!bio);
 
 	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
@@ -434,7 +476,7 @@
 	 * TODO: Do we need to handle case where request does not
 	 * align with LLD.
 	 */
-	err = scsi_map_user_pages(cmd, rw);
+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
 	if (err) {
 		eprintk("%p %d\n", cmd, err);
 		err = -EAGAIN;
@@ -460,13 +502,28 @@
 {
 	int err;
 
-	scsi_tgtd = create_workqueue("scsi_tgtd");
-	if (!scsi_tgtd)
+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
+					       sizeof(struct scsi_tgt_cmd),
+					       0, 0, NULL, NULL);
+	if (!scsi_tgt_cmd_cache)
 		return -ENOMEM;
 
+	scsi_tgtd = create_workqueue("scsi_tgtd");
+	if (!scsi_tgtd) {
+		err = -ENOMEM;
+		goto free_kmemcache;
+	}
+
 	err = scsi_tgt_if_init();
 	if (err)
-		destroy_workqueue(scsi_tgtd);
+		goto destroy_wq;
+
+	return 0;
+
+destroy_wq:
+	destroy_workqueue(scsi_tgtd);	
+free_kmemcache:
+	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	return err;
 }
 
@@ -474,6 +531,7 @@
 {
 	destroy_workqueue(scsi_tgtd);
 	scsi_tgt_if_exit();
+	kmem_cache_destroy(scsi_tgt_cmd_cache);
 }
 
 module_init(scsi_tgt_init);

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-06 21:41:51 UTC (rev 276)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-07 00:40:21 UTC (rev 277)
@@ -1,4 +1,5 @@
 struct scsi_cmnd;
+struct scsi_lun;
 struct Scsi_Host;
 struct task_struct;
 
@@ -19,7 +20,7 @@
 extern void scsi_tgt_if_exit(void);
 extern int scsi_tgt_if_init(void);
 
-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd);
+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				u64 offset, unsigned long uaddr, u8 rw,

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-06 21:41:51 UTC (rev 276)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 00:40:21 UTC (rev 277)
@@ -580,7 +580,7 @@
 +
 +#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..aaa8740 100644
+index 1ace1b9..59f0981 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
 @@ -5,9 +5,11 @@
@@ -604,22 +604,7 @@
  
  	unsigned underflow;	/* Return error if less than
  				   this amount is transferred */
-@@ -131,6 +135,14 @@ struct scsi_cmnd {
- 
- 	unsigned char tag;	/* SCSI-II queued command tag */
- 	unsigned long pid;	/* Process ID, starts at 0. Unique per host. */
-+	/*
-+	 * Work struct to process completion of scsi commands in process
-+	 * context. (this should be ifdefd since the work struct is large)
-+	 */
-+	struct work_struct work;
-+	/* list of bios to be unmapped in work struct */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
- };
- 
- /*
-@@ -147,9 +159,14 @@ struct scsi_cmnd {
+@@ -147,9 +151,14 @@ struct scsi_cmnd {
  #define SCSI_STATE_MLQUEUE         0x100b
  
  



From tomo at berlios.de  Tue Feb  7 07:43:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 07:43:43 +0100
Subject: [Stgt-svn] r278 - in branches/use-scsi-ml: . kernel usr
Message-ID: <200602070643.k176hhYo025616@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 07:43:36 +0100 (Tue, 07 Feb 2006)
New Revision: 278

Added:
   branches/use-scsi-ml/usr/util.h
Removed:
   branches/use-scsi-ml/usr/ipc.c
   branches/use-scsi-ml/usr/tgt_device.c
Modified:
   branches/use-scsi-ml/Makefile
   branches/use-scsi-ml/initd
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Go back to the single process model, replace some of netlink code with the packet socket interface, and clean up the user-space code.


Modified: branches/use-scsi-ml/Makefile
===================================================================
--- branches/use-scsi-ml/Makefile	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/Makefile	2006-02-07 06:43:36 UTC (rev 278)
@@ -9,8 +9,8 @@
 all:
 ifeq ($(ARCH), powerpc)
 	make -C ibmvstgt
-else
-	make -C istgt
+#else
+#	make -C istgt
 endif
 	make -C usr
 	make -C kernel

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/initd	2006-02-07 06:43:36 UTC (rev 278)
@@ -32,7 +32,7 @@
 #		${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
 #		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
 	else
-		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 0
+		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
 		${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --hostno 1
 		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1
 	fi

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -19,6 +19,7 @@
  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/blkdev.h>
+#include <linux/file.h>
 #include <linux/if_packet.h>
 #include <linux/netlink.h>
 #include <net/af_packet.h>
@@ -32,17 +33,10 @@
 
 #include "scsi_tgt_priv.h"
 
-/* default task when host is not setup in userspace yet */
 static int tgtd_pid;
-static struct sock *nls;
+static struct sock *nl_sk;
+static struct socket *pk_sock;
 
-static struct sock *scsi_tgt_get_sock(struct Scsi_Host *shost)
-{
-	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
-	struct socket *sock = queue->sock;
-	return sock ? sock->sk : NULL;
-}
-
 static void tpacket_done(struct sock *sk, struct tpacket_hdr *h, int len)
 {
 	h->tp_status = TP_STATUS_USER;
@@ -69,11 +63,11 @@
 	struct tgt_event *ev;
 	struct tgt_cmd *tcmd;
 
-	sk = scsi_tgt_get_sock(shost);
-	if (!sk) {
+	if (!pk_sock) {
 		printk(KERN_INFO "Host%d not connected\n", shost->host_no);
 		return -ENOTCONN;
 	}
+	sk = pk_sock->sk;
 
 	h = packet_frame(sk);
 	if (IS_ERR(h)) {
@@ -82,7 +76,7 @@
 	}
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-	ev->type = TGT_KEVENT_CMD_REQ;
+	h->tp_len = TGT_KEVENT_CMD_REQ;
 	ev->k.cmd_req.host_no = shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
@@ -108,12 +102,12 @@
 	struct tgt_event *ev;
 	struct tpacket_hdr *h;
 
-	sk = scsi_tgt_get_sock(shost);
-	if (!sk) {
+	if (!pk_sock) {
 		printk(KERN_INFO "Host%d not connected\n",
 		       shost->host_no);
 		return -ENOTCONN;
 	}
+	sk = pk_sock->sk;
 
 	h = packet_frame(sk);
 	if (IS_ERR(h)) {
@@ -122,7 +116,7 @@
 	}
 
 	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-	ev->type = TGT_KEVENT_CMD_DONE;
+	h->tp_len = TGT_KEVENT_CMD_DONE;
 	ev->k.cmd_done.host_no = shost->host_no;
 	ev->k.cmd_done.cid = cmd->request->tag;
 	ev->k.cmd_done.result = cmd->result;
@@ -151,41 +145,19 @@
 	if (dlen)
 		memcpy(ev->data, data, dlen);
 
-	return netlink_unicast(nls, skb, pid, 0);
+	return netlink_unicast(nl_sk, skb, pid, 0);
 }
 
-/* TODO: unbind to call fput. */
-static int scsi_tgt_bind_host(struct tgt_event *ev)
+static int tgtd_bind(struct tgt_event *ev)
 {
-	struct Scsi_Host *shost;
-	struct task_struct *tsk;
-	int err = 0;
+	int err, pk_fd = ev->u.tgtd_bind.pk_fd;
 
-	dprintk("%d %d %d\n", ev->u.target_bind.host_no,
-		ev->u.target_bind.pid, ev->u.target_bind.psfd);
-
-	shost = scsi_host_lookup(ev->u.target_bind.host_no);
-	if (IS_ERR(shost)) {
-		eprintk("Could not find host no %d\n",
-			ev->u.target_bind.host_no);
-			return -EINVAL;
+	pk_sock = sockfd_lookup(pk_fd, &err);
+	if (!pk_sock) {
+		eprintk("Invalid fd %d\n", pk_fd);
+		return err;
 	}
-
-	tsk = find_task_by_pid(ev->u.target_bind.pid);
-	if (tsk) {
-		struct scsi_tgt_queuedata *queue;
-
-		queue = shost->uspace_req_q->queuedata;
-		queue->task = tsk;
-		queue->sock = sockfd_lookup(ev->u.target_bind.psfd, &err);
-	} else {
-		eprintk("Could not find process %d\n",
-			ev->u.target_bind.pid);
-		err = EINVAL;
-	}
-
-	scsi_host_put(shost);
-	return err;
+	return 0;
 }
 
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -197,12 +169,10 @@
 		nlh->nlmsg_pid, current->pid);
 
 	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_START:
+	case TGT_UEVENT_TGTD_BIND:
 		tgtd_pid = NETLINK_CREDS(skb)->pid;
+		err = tgtd_bind(ev);
 		break;
-	case TGT_UEVENT_TARGET_BIND:
-		err = scsi_tgt_bind_host(ev);
-		break;
 	case TGT_UEVENT_CMD_RES:
 		/* TODO: handle multiple cmds in one event */
 		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
@@ -276,14 +246,16 @@
 
 void __exit scsi_tgt_if_exit(void)
 {
-	sock_release(nls->sk_socket);
+	sock_release(nl_sk->sk_socket);
+	if (pk_sock)
+		fput(pk_sock->file);
 }
 
 int __init scsi_tgt_if_init(void)
 {
-	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
+	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
 				    THIS_MODULE);
-	if (!nls)
+	if (!nl_sk)
 		return -ENOMEM;
 
 	return 0;

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -521,7 +521,7 @@
 	return 0;
 
 destroy_wq:
-	destroy_workqueue(scsi_tgtd);	
+	destroy_workqueue(scsi_tgtd);
 free_kmemcache:
 	kmem_cache_destroy(scsi_tgt_cmd_cache);
 	return err;

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-07 06:43:36 UTC (rev 278)
@@ -12,8 +12,6 @@
 #define eprintk dprintk
 
 struct scsi_tgt_queuedata {
-	struct task_struct *task;
-	struct socket *sock;
 	struct Scsi_Host *shost;
 };
 

Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/Makefile	2006-02-07 06:43:36 UTC (rev 278)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o scsi.o log.o
+tgtd: tgtd.o netlink.o dl.o mgmt.o target.o scsi.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Deleted: branches/use-scsi-ml/usr/ipc.c
===================================================================
--- branches/use-scsi-ml/usr/ipc.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/ipc.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -1,220 +0,0 @@
-/*
- * Unix domain socket for ipc
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <inttypes.h>
-#include <poll.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/un.h>
-#include <asm/types.h>
-#include <sys/socket.h>
-#include <linux/netlink.h>
-
-#include "tgtd.h"
-#include "tgtadm.h"
-#include "dl.h"
-
-struct tgt_task {
-	int fd;
-};
-
-static int ipc_accept(int afd)
-{
-	struct sockaddr addr;
-	socklen_t len;
-
-	len = sizeof(addr);
-	return accept(afd, (struct sockaddr *) &addr, &len);
-}
-
-static int ipc_perm(int fd)
-{
-	struct ucred cred;
-	socklen_t len;
-	int err;
-
-	len = sizeof(cred);
-	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
-	if (err < 0)
-		goto out;
-
-	if (cred.uid || cred.gid) {
-		err = -EPERM;
-		goto out;
-	}
-out:
-	return err;
-}
-
-void pipe_event_handle(int fd)
-{
-	struct nlmsghdr *nlh;
-	struct iovec iov;
-	struct msghdr msg;
-	char buf[1024];
-	struct tgtadm_res *res;
-	struct tgt_task *task;
-	int err;
-
-	nlh = (struct nlmsghdr *) buf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_PEEK);
-	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr)))
-		return;
-
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err < 0)
-		return;
-
-	res = NLMSG_DATA(nlh);
-	dprintf("%d %d %lx\n", err, nlh->nlmsg_len, res->addr);
-
-	task = (struct tgt_task *) res->addr;
-	if (!task)
-		return;
-
-	dprintf("%d\n", task->fd);
-
-	err = write(task->fd, nlh, nlh->nlmsg_len);
-	close(task->fd);
-	free(task);
-}
-
-void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
-{
-	int fd, err, done = 0;
-	char sbuf[4096], rbuf[4096];
-	struct nlmsghdr *nlh;
-	struct iovec iov;
-	struct msghdr msg;
-	struct tgtadm_res *res;
-	struct tgtadm_req *req;
-	struct tgt_task *task;
-	int (*fn) (char *, char *);
-
-	fd = ipc_accept(accept_fd);
-	if (fd < 0) {
-		eprintf("%d\n", fd);
-		return;
-	}
-
-	err = ipc_perm(fd);
-	if (err < 0)
-		goto fail;
-
-	memset(sbuf, 0, sizeof(sbuf));
-	memset(rbuf, 0, sizeof(rbuf));
-
-	nlh = (struct nlmsghdr *) sbuf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_PEEK);
-	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
-		err = -EIO;
-		goto fail;
-	}
-
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err < 0)
-		goto fail;
-
-	task = calloc(1, sizeof(*task));
-	if (!task) {
-		err = -ENOMEM;
-		goto fail;
-	}
-	task->fd = fd;
-
-	req = NLMSG_DATA(nlh);
-	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
-
-	switch (req->mode) {
-	case MODE_DEVICE:
-		dprintf("%d %d %d %lx\n",
-			req->tid, err, nlh->nlmsg_len, (unsigned long) task);
-		req->addr = (unsigned long) task;
-		write(poll_array[POLLS_PER_DRV + req->tid].fd,
-		      sbuf, NLMSG_ALIGN(nlh->nlmsg_len));
-		break;
-	default:
-		fn = dl_ipc_fn(dinfo, req->typeid);
-		if (fn)
-			err = fn((char *) nlh, rbuf);
-		else
-			err = tgt_mgmt((char *) nlh, rbuf);
-		done = 1;
-	}
-
-	if (!done)
-		return;
-
-send:
-	err = write(fd, nlh, nlh->nlmsg_len);
-	if (err < 0)
-		eprintf("%d\n", err);
-
-	if (fd > 0)
-		close(fd);
-
-	return;
-fail:
-	nlh = (struct nlmsghdr *) rbuf;
-	res = NLMSG_DATA(nlh);
-	res->err = err;
-	nlh->nlmsg_len = NLMSG_LENGTH(0);
-	goto send;
-}
-
-int ipc_open(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
-	       strlen(TGT_IPC_NAMESPACE));
-
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		return err;
-
-	if ((err = listen(fd, 32)) < 0)
-		return err;
-
-	return fd;
-}

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -1,5 +1,5 @@
 /*
- * Generic management functions
+ * SCSI target management functions
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -11,130 +11,26 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
+#include <poll.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <poll.h>
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
-#include <linux/types.h>
+#include <sys/types.h>
+#include <sys/un.h>
 #include <linux/netlink.h>
-
+#include <linux/types.h>
 #include <scsi/scsi_tgt_if.h>
+
 #include "tgtd.h"
 #include "dl.h"
 #include "log.h"
 #include "tgtadm.h"
-#include "tgt_sysfs.h"
 
-#ifndef O_LARGEFILE
-#define O_LARGEFILE	0100000
-#endif
-
-static void nlmsg_init(struct nlmsghdr *nlh, uint32_t seq,
-		       uint16_t type, uint32_t len, uint16_t flags)
+static void device_create_parser(char *args, char **path, char **devtype)
 {
-	nlh->nlmsg_pid = getpid();
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_seq = seq;
-}
-
-typedef void (init_tgt_event_t) (struct tgt_event *ev, struct tgtadm_req *req);
-
-int tgt_event_execute(struct tgtadm_req *req, int event, init_tgt_event_t *func)
-{
-	int err;
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	char nlm_sev[NLMSG_SPACE(sizeof(struct tgt_event))];
-	char nlm_rev[NLMSG_SPACE(sizeof(struct tgt_event))];
-
-	memset(nlm_sev, 0, sizeof(nlm_sev));
-	memset(nlm_rev, 0, sizeof(nlm_rev));
-
-	nlh = (struct nlmsghdr *) nlm_sev;
-
-	nlmsg_init(nlh, 0, event, NLMSG_SPACE(sizeof(*ev)), 0);
-	ev = NLMSG_DATA(nlh);
-	func(ev, req);
-
-	err = nl_cmd_call(nl_fd, nlh->nlmsg_type, (char *) nlh,
-			  nlh->nlmsg_len, nlm_rev, sizeof(nlm_rev));
-	if (err < 0)
-		eprintf("%d\n", err);
-	else
-		err = ((struct tgt_event *) NLMSG_DATA(nlm_rev))->k.event_res.err;
-
-	return err;
-}
-
-static void __bind(struct tgt_event *ev, struct tgtadm_req *req)
-{
-	char path[PATH_MAX], buf[32];
-	int err, fd, pid;
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/pid",
-		 req->tid);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		eprintf("Cannot open %s\n", path);
-		return;
-	}
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot read\n");
-		return;
-	}
-	sscanf(buf, "%d\n", &pid);
-
-	ev->u.target_bind.host_no = req->host_no;
-	ev->u.target_bind.pid = pid;
-}
-
-int ktarget_bind(int tid, int host_no)
-{
-	struct tgtadm_req req;
-
-	dprintf("%d %d\n", tid, host_no);
-
-	req.tid = tid;
-	req.host_no = host_no;
-	return tgt_event_execute(&req, TGT_UEVENT_TARGET_BIND, __bind);
-}
-
-int ktarget_create(int typeid)
-{
-	struct tgtadm_req req;
-	int fd, tid;
-
-	req.typeid = typeid;
-	tid = target_thread_create(&fd);
-	if (tid >= 0) {
-		dprintf("%d %d\n", tid, fd);
-
-		/* FIXME */
-		if (tid > POLLS_PER_DRV)
-			eprintf("too large tid %d\n", tid);
-		else {
-			poll_array[POLLS_PER_DRV + tid].fd = fd;
-			poll_array[POLLS_PER_DRV + tid].events = POLLIN;
-		}
-	}
-
-	return tid;
-}
-
-int ktarget_destroy(int tid)
-{
-	return 0;
-}
-
-static void kdevice_create_parser(char *args, char **path, char **devtype)
-{
 	char *p, *q;
 
 	if (isspace(*args))
@@ -157,69 +53,20 @@
 	}
 }
 
-static int kdevice_create(int tid, uint64_t devid, char *path)
+static int target_mgmt(struct tgtadm_req *req, char *params,
+		       char *rbuf, int *rlen)
 {
-	int fd, err;
-
-	dprintf("%d %" PRIu64 " %s\n", tid, devid, path);
-
-	fd = open(path, O_RDWR | O_LARGEFILE);
-	if (fd < 0) {
-		eprintf("Could not open %s errno %d\n", path, errno);
-		return -errno;
-	}
-
-	err = tgt_device_create(tid, devid, fd);
-	if (err < 0)
-		close(fd);
-
-	return err;
-}
-
-static int kdevice_destroy(int tid, uint64_t devid)
-{
-	int fd, err;
-	char path[PATH_MAX], buf[PATH_MAX];
-
-	dprintf("%u %" PRIu64 "\n", tid, devid);
-
-	snprintf(path, sizeof(path),
-		 TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd", tid, devid);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		eprintf("%s %d\n", path, errno);
-		return -errno;
-	}
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		return err;
-	}
-	sscanf(buf, "%d\n", &fd);
-
-	err = tgt_device_destroy(tid, devid);
-
-	if (!err)
-		close(fd);
-
-	return err;
-}
-
-static int target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
 	int err = -EINVAL;
 
 	switch (req->op) {
 	case OP_NEW:
-		err = ktarget_create(req->typeid);
+		err = tgt_target_create(req->typeid);
 		break;
 	case OP_DELETE:
-		err = ktarget_destroy(req->tid);
+		err = tgt_target_destroy(req->tid);
 		break;
 	case OP_BIND:
-		err = ktarget_bind(req->tid, req->host_no);
+		err = tgt_target_bind(req->tid, req->host_no);
 		break;
 	default:
 		break;
@@ -228,7 +75,8 @@
 	return err;
 }
 
-static int device_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
+static int device_mgmt(struct tgtadm_req *req, char *params,
+		       char *rbuf, int *rlen)
 {
 	int err = -EINVAL;
 	char *path, *devtype;
@@ -236,14 +84,14 @@
 	switch (req->op) {
 	case OP_NEW:
 		path = devtype = NULL;
-		kdevice_create_parser(params, &path, &devtype);
+		device_create_parser(params, &path, &devtype);
 		if (!path)
 			eprintf("Invalid path\n");
 		else
-			err = kdevice_create(req->tid, req->lun, path);
+			err = tgt_device_create(req->tid, req->lun, path);
 		break;
 	case OP_DELETE:
-		err = kdevice_destroy(req->tid, req->lun);
+		err = tgt_device_destroy(req->tid, req->lun);
 		break;
 	default:
 		break;
@@ -263,9 +111,9 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun,
-		params, getpid());
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
+		nlh->nlmsg_len,	req->typeid, req->mode, req->op,
+		req->tid, req->sid, req->lun, params, getpid());
 
 	switch (req->mode) {
 	case MODE_TARGET:
@@ -285,3 +133,127 @@
 
 	return err;
 }
+
+static int ipc_accept(int afd)
+{
+	struct sockaddr addr;
+	socklen_t len;
+
+	len = sizeof(addr);
+	return accept(afd, (struct sockaddr *) &addr, &len);
+}
+
+static int ipc_perm(int fd)
+{
+	struct ucred cred;
+	socklen_t len;
+	int err;
+
+	len = sizeof(cred);
+	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
+	if (err < 0)
+		goto out;
+
+	if (cred.uid || cred.gid) {
+		err = -EPERM;
+		goto out;
+	}
+out:
+	return err;
+}
+
+void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
+{
+	int fd, err;
+	char sbuf[4096], rbuf[4096];
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	struct tgtadm_res *res;
+	struct tgtadm_req *req;
+	int (*fn) (char *, char *);
+
+	fd = ipc_accept(accept_fd);
+	if (fd < 0) {
+		eprintf("%d\n", fd);
+		return;
+	}
+
+	err = ipc_perm(fd);
+	if (err < 0)
+		goto fail;
+
+	memset(sbuf, 0, sizeof(sbuf));
+	memset(rbuf, 0, sizeof(rbuf));
+
+	nlh = (struct nlmsghdr *) sbuf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
+		err = -EIO;
+		goto fail;
+	}
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		goto fail;
+
+	req = NLMSG_DATA(nlh);
+	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
+
+	fn = dl_ipc_fn(dinfo, req->typeid);
+	if (fn)
+		err = fn((char *) nlh, rbuf);
+	else
+		err = tgt_mgmt((char *) nlh, rbuf);
+
+send:
+	err = write(fd, nlh, nlh->nlmsg_len);
+	if (err < 0)
+		eprintf("%d\n", err);
+
+	if (fd > 0)
+		close(fd);
+
+	return;
+fail:
+	nlh = (struct nlmsghdr *) rbuf;
+	res = NLMSG_DATA(nlh);
+	res->err = err;
+	nlh->nlmsg_len = NLMSG_LENGTH(0);
+	goto send;
+}
+
+int ipc_open(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
+	       strlen(TGT_IPC_NAMESPACE));
+
+	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		return err;
+
+	if ((err = listen(fd, 32)) < 0)
+		return err;
+
+	return fd;
+}

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -10,16 +10,19 @@
 
 #include <errno.h>
 #include <inttypes.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
 #include <unistd.h>
-#include <signal.h>
+#include <sys/mman.h>
+#include <sys/poll.h>
 #include <sys/signal.h>
-#include <sys/poll.h>
 #include <sys/socket.h>
 #include <asm/types.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
 #include <linux/netlink.h>
 
 #include <scsi/scsi_tgt_if.h>
@@ -48,7 +51,7 @@
 		      sizeof(daddr));
 }
 
-int __nl_read(int fd, void *data, int size, int flags)
+static int __nl_read(int fd, void *data, int size, int flags)
 {
 	struct sockaddr_nl saddr;
 	socklen_t slen = sizeof(saddr);
@@ -93,31 +96,6 @@
 	return err;
 }
 
-void nl_event_handle(struct driver_info *dinfo, int fd)
-{
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	char rbuf[NL_BUFSIZE];
-	int err;
-
-	err = nl_read(fd, rbuf);
-	if (err < 0)
-		return;
-
-	nlh = (struct nlmsghdr *) rbuf;
-	ev = (struct tgt_event *) NLMSG_DATA(nlh);
-
-	dprintf("%d %d\n", getpid(), nlh->nlmsg_type);
-
-	switch (nlh->nlmsg_type) {
-	default:
-		/* kernel module bug */
-		eprintf("unknown event %u\n", nlh->nlmsg_type);
-		exit(-1);
-		break;
-	}
-}
-
 int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen)
 {
 	int err;
@@ -143,18 +121,55 @@
 	return err;
 }
 
-int nl_start(int fd)
+static int ringbuf_init(int pk_fd, struct ringbuf_info *ri)
 {
+	struct tpacket_req req;
 	int err;
+	socklen_t len = sizeof(req);
+	unsigned int size = RINGBUF_SIZE;
+	void *addr;
+
+	req.tp_frame_size = TPACKET_ALIGN(TPACKET_HDRLEN +
+					  sizeof(struct tgt_event) +
+					  sizeof(struct tgt_cmd));
+	req.tp_block_size = size;
+	req.tp_frame_nr = req.tp_block_size / req.tp_frame_size;
+	req.tp_block_nr = 1;
+
+	err = setsockopt(pk_fd, SOL_PACKET, PACKET_RX_RING, &req, len);
+	dprintf("%d %u %u\n", errno, req.tp_frame_size, req.tp_frame_nr);
+	if (err < 0)
+		return err;
+
+	addr = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, pk_fd, 0);
+
+	ri->frame_size = req.tp_frame_size;
+	ri->frame_nr = req.tp_frame_nr;
+	ri->addr = addr;
+	ri->idx = 0;
+
+	dprintf("%p\n",addr);
+
+	if (addr == MAP_FAILED) {
+		eprintf("fail to mmap %d\n", errno);
+		return -EINVAL;
+	} else
+		return 0;
+}
+
+static int tgtd_bind(int nl_fd, int pk_fd)
+{
+	int err;
 	struct tgt_event *ev;
-	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
-	char buf[NL_BUFSIZE];
+	char sbuf[NL_BUFSIZE], rbuf[NL_BUFSIZE];
 
-	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
+	ev = (struct tgt_event *) NLMSG_DATA(sbuf);
+	ev->u.tgtd_bind.pk_fd = pk_fd;
+	err = nl_cmd_call(nl_fd, TGT_UEVENT_TGTD_BIND, sbuf,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
-			  buf, NL_BUFSIZE);
+			  rbuf, NL_BUFSIZE);
 
-	ev = (struct tgt_event *) NLMSG_DATA(buf);
+	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
 	if (err < 0 || ev->k.event_res.err < 0) {
 		eprintf("%d %d\n", err, ev->k.event_res.err);
 		return -EINVAL;
@@ -163,13 +178,31 @@
 	return 0;
 }
 
-int nl_init(void)
+int nl_init(int *nfd, int *pfd, struct ringbuf_info *ri)
 {
-	int fd;
+	int err, nl_fd, pk_fd;
 
-	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd < 0)
+	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
+	if (nl_fd < 0) {
 		eprintf("Fail to create the netlink socket %d\n", errno);
+		exit(1);
+	}
 
-	return fd;
+	pk_fd = socket(PF_PACKET, SOCK_RAW, 0);
+	if (pk_fd < 0) {
+		eprintf("Fail to create the packet socket %d\n", errno);
+		exit(1);
+	}
+
+	err = ringbuf_init(pk_fd, ri);
+	if (err)
+		exit(1);
+
+	err = tgtd_bind(nl_fd, pk_fd);
+	if (err)
+		exit(1);
+
+	*nfd = nl_fd;
+	*pfd = pk_fd;
+	return 0;
 }

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/target.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -1,5 +1,5 @@
 /*
- * Target framework target daemon
+ * SCSI target daemon
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -20,7 +20,10 @@
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+
 #include <linux/fs.h>
+#include <linux/if_ether.h>
+#include <linux/if_packet.h>
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>
 
@@ -28,13 +31,20 @@
 #include "tgtadm.h"
 #include "dl.h"
 #include "tgt_sysfs.h"
+#include "util.h"
 
-#define	DEFAULT_NR_DEVICE	512
+#define	MAX_NR_TARGET		1024
+#define	MAX_NR_HOST		1024
+#define	DEFAULT_NR_DEVICE	64
 #define	MAX_NR_DEVICE		(1 << 20)
 
-enum {
-	POLL_IPC_CTRL,
-	POLL_NL_CMD,
+struct cmd {
+	struct qelem clist;
+	uint32_t cid;
+	uint64_t dev_id;
+	uint64_t uaddr;
+	uint32_t len;
+	int mmap;
 };
 
 struct device {
@@ -47,18 +57,46 @@
 };
 
 struct target {
-	struct pollfd pfd[2];
 	int tid;
-
 	struct device **devt;
 	uint64_t max_device;
+
+	/* TODO: move to device */
+	struct qelem cqueue;
 };
 
-static struct target *target;
+static struct target *tgtt[MAX_NR_TARGET];
+static struct target *hostt[MAX_NR_HOST];
 
 static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
 static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
 
+static struct target *target_get(int tid)
+{
+	if (tid >= MAX_NR_TARGET) {
+		eprintf("Too larget target id %d\n", tid);
+		return NULL;
+	}
+	return tgtt[tid];
+}
+
+static struct device *device_get(struct target *target, uint64_t dev_id)
+{
+	if (dev_id < target->max_device || dev_id < MAX_NR_DEVICE)
+		return target->devt[dev_id];
+
+	eprintf("Invalid device id %" PRIu64 "%d\n", dev_id, MAX_NR_DEVICE);
+	return NULL;
+}
+
+static struct target *host_to_target(int host_no)
+{
+	if (host_no < MAX_NR_HOST)
+		return hostt[host_no];
+
+	return NULL;
+}
+
 static void resize_device_table(struct target *target, uint64_t did)
 {
 	struct device *device;
@@ -83,50 +121,28 @@
 		return (unsigned long) p;
 }
 
-int tgt_device_create(int tid, uint64_t did, int dfd)
+static int device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size)
 {
-	int err, fd;
-	struct stat st;
-	char path[PATH_MAX], buf[32];
-	uint64_t size;
-	struct device *device;
+	char path[PATH_MAX], buf[64];
+	int fd, err;
 
-	if (did >= MAX_NR_DEVICE) {
-		eprintf("Too big device id %" PRIu64 "%d\n",
-			did, MAX_NR_DEVICE);
-		return -EINVAL;
-	}
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64, tid, dev_id);
 
-	err = ioctl(dfd, BLKGETSIZE64, &size);
-	if (err < 0) {
-		eprintf("Cannot get size %d\n", dfd);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
-	err = stat(path, &st);
-	if (err < 0) {
-		eprintf("Cannot find target %d\n", tid);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, did);
-
 	err = mkdir(path, dmode);
 	if (err < 0) {
 		eprintf("Cannot create %s\n", path);
 		return err;
 	}
 
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, did);
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
 	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
 	if (fd < 0) {
 		eprintf("Cannot create %s\n", path);
 		return err;
 	}
-	snprintf(buf, sizeof(buf), "%d", dfd);
+	snprintf(buf, sizeof(buf), "%d", dev_fd);
 	err = write(fd, buf, strlen(buf));
 	close(fd);
 	if (err < 0) {
@@ -134,8 +150,8 @@
 		return err;
 	}
 
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, did);
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64 "/size", tid, dev_id);
 	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
 	if (fd < 0) {
 		eprintf("Cannot create %s\n", path);
@@ -149,61 +165,137 @@
 		return err;
 	}
 
-	if (did >= target->max_device)
-		resize_device_table(target, did);
+	return 0;
+}
 
+#ifndef O_LARGEFILE
+#define O_LARGEFILE	0100000
+#endif
+
+int tgt_device_create(int tid, uint64_t dev_id, char *path)
+{
+	struct target *target;
+	struct device *device;
+	int err, dev_fd;
+	uint64_t size;
+
+	dprintf("%d %" PRIu64 " %s\n", tid, dev_id, path);
+
+	target = target_get(tid);
+	if (!target)
+		return -ENOENT;
+
+	device = device_get(target, dev_id);
+	if (device) {
+		eprintf("device %" PRIu64 " already exists\n", dev_id);
+		return -EINVAL;
+	}
+
+	dev_fd = open(path, O_RDWR | O_LARGEFILE);
+	if (dev_fd < 0) {
+		eprintf("Could not open %s errno %d\n", path, errno);
+		return dev_fd;
+	}
+
+	err = ioctl(dev_fd, BLKGETSIZE64, &size);
+	if (err < 0) {
+		eprintf("Cannot get size %d\n", dev_fd);
+		return err;
+	}
+
+	err = device_dir_create(tid, dev_id, dev_fd, size);
+	if (err < 0)
+		goto close_dev_fd;
+
+	if (dev_id >= target->max_device)
+		resize_device_table(target, dev_id);
+
 	device = malloc(sizeof(*device));
-	device->fd = dfd;
+	if (!device)
+		goto close_dev_fd;
+
+	device->fd = dev_fd;
 	device->state = 0;
-	device->addr = try_mmap_device(dfd, size);
+	device->addr = try_mmap_device(dev_fd, size);
 	device->size = size;
-	target->devt[did] = device;
+	target->devt[dev_id] = device;
 
 	if (device->addr)
 		eprintf("Succeed to mmap the device %" PRIx64 "\n",
 			device->addr);
 
 	return 0;
+close_dev_fd:
+	close(dev_fd);
+	return err;
 }
 
-int tgt_device_destroy(int tid, uint64_t did)
+static void device_dir_remove(int tid, uint64_t dev_id)
 {
-	char path[PATH_MAX];
 	int err;
-	struct device *device;
+	char path[PATH_MAX];
 
-	if (target->max_device <= did)
-		return -ENOENT;
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, did);
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
 	err = unlink(path);
-	if (err < 0) {
+	if (err < 0)
 		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
 
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, did);
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64 "/size", tid, dev_id);
 	err = unlink(path);
-	if (err < 0) {
+	if (err < 0)
 		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
 
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, did);
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64, tid, dev_id);
 	err = rmdir(path);
 	if (err < 0)
 		eprintf("Cannot unlink %s\n", path);
+}
 
-	device = target->devt[did];
-	target->devt[did] = NULL;
+int tgt_device_destroy(int tid, uint64_t dev_id)
+{
+	struct target *target;
+	struct device *device;
+	char path[PATH_MAX], buf[64];
+	int dev_fd, fd, err;
+
+	/* TODO: check whether the device has flying commands. */
+
+	dprintf("%u %" PRIu64 "\n", tid, dev_id);
+
+	target = target_get(tid);
+	if (!target)
+		return -ENOENT;
+
+	device = device_get(target, dev_id);
+	if (!device) {
+		eprintf("device %" PRIu64 " not found\n", dev_id);
+		return -EINVAL;
+	}
+
+	target->devt[dev_id] = NULL;
 	if (device->addr)
 		munmap((void *) (unsigned long) device->addr, device->size);
 
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
+		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
+	fd = open(path, O_RDONLY);
+	if (fd < 0)
+		eprintf("%s %d\n", path, errno);
+
+	err = read(fd, buf, sizeof(buf));
+	close(fd);
+	if (err < 0)
+		eprintf("%d\n", err);
+
+	sscanf(buf, "%d\n", &dev_fd);
+	close(dev_fd);
+
+	device_dir_remove(tid, dev_id);
+
 	free(device);
-out:
 	return err;
 }
 
@@ -227,160 +319,62 @@
 	return err;
 }
 
-static void ipc_ctrl(int fd)
+static struct cmd *find_cmd(struct target *target, uint32_t cid)
 {
-	struct iovec iov;
-	struct msghdr msg;
-	struct nlmsghdr *nlh;
-	struct tgtadm_req *req;
-	struct tgtadm_res *res;
-	char rbuf[2048], buf[2048];
-	int err;
-
-	nlh = (struct nlmsghdr *) rbuf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_PEEK);
-
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-
-	req = NLMSG_DATA(nlh);
-	dprintf("%d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len);
-
-	tgt_mgmt(rbuf, buf);
-
-	nlh = (struct nlmsghdr *) buf;
-	res = NLMSG_DATA(nlh);
-	res->addr = req->addr;
-	dprintf("%d %lx\n", nlh->nlmsg_len, res->addr);
-	err = write(fd, nlh, nlh->nlmsg_len);
-}
-
-
-static int set_pdu_size(int fd)
-{
-	struct nlmsghdr *nlh;
-	char buf[1024];
-	int err;
-
-peek_again:
-	err = __nl_read(fd, buf, sizeof(buf), MSG_PEEK);
-	if (err < 0) {
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-
-	dprintf("%d\n", nlh->nlmsg_len);
-
-	return nlh->nlmsg_len;
-}
-
-/* FIXME */
-
-#undef offsetof
-#ifdef __compiler_offsetof
-#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
-#else
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-#endif
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
-} while (0)
-
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-#define list_entry(ptr, type, member) \
-	container_of(ptr, type, member)
-
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
-	     &pos->member != (head); 	\
-	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
-
-struct qelem {
-	struct qelem *q_forw;
-	struct qelem *q_back;
-};
-
-static struct qelem cqueue = LIST_HEAD_INIT(cqueue);
-
-struct cmd {
-	struct qelem clist;
-	uint32_t cid;
-	uint64_t devid;
-	uint64_t uaddr;
-	uint32_t len;
-	int mmap;
-};
-
-static struct cmd *find_cmd(uint32_t cid)
-{
 	struct cmd *cmd;
-
-	list_for_each_entry(cmd, &cqueue, clist) {
+	list_for_each_entry(cmd, &target->cqueue, clist) {
 		if (cmd->cid == cid)
 			return cmd;
 	}
 	return NULL;
 }
 
-#define	MAX_COMMAND_SIZE	16
-
-static int cmd_queue(int fd, char *reqbuf)
+/* TODO: coalesce responses */
+static int cmd_queue(struct tgt_event *ev_req, int nl_fd)
 {
+	struct target *target;
+	struct device *device;
 	int result, len = 0;
-	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t offset, devid;
+	struct tgt_cmd *scmd;
+	uint64_t offset, dev_id;
 	uint32_t cid = ev_req->k.cmd_req.cid;
-	uint8_t *pdu, rw = 0, try_map = 0;
+	uint8_t rw = 0, try_map = 0;
 	unsigned long uaddr = 0;
 	int host_no = ev_req->k.cmd_req.host_no;
 	struct cmd *cmd;
 
-	memset(resbuf, 0, sizeof(resbuf));
-	pdu = (uint8_t *) ev_req->data;
+	target = host_to_target(host_no);
+	if (!target) {
+		eprintf("%d is not bind to any target\n", host_no);
+		return 0;
+	}
+	scmd = (struct tgt_cmd *) ev_req->data;
 
-	devid = scsi_get_devid(pdu + MAX_COMMAND_SIZE);
-	dprintf("%u %x %" PRIx64 "\n", cid, pdu[0], devid);
+	dev_id = scsi_get_devid(scmd->lun);
+	dprintf("%u %x %" PRIx64 "\n", cid, scmd->scb[0], dev_id);
 
-	if (target->max_device > devid && target->devt[devid])
-		uaddr = target->devt[devid]->addr;
+	device = device_get(target, dev_id);
+	if (device)
+		uaddr = target->devt[dev_id]->addr;
 
-	/* FIXME */
-	result = scsi_cmd_process(target->tid, pdu, &len,
+	result = scsi_cmd_process(target->tid, scmd->scb, &len,
 				  ev_req->k.cmd_req.data_len,
-				  &uaddr, &rw, &try_map, &offset, devid);
+				  &uaddr, &rw, &try_map, &offset, dev_id);
 
-	dprintf("%u %x %lx %" PRIu64 " %d\n", cid, pdu[0], uaddr, offset, result);
+	dprintf("%u %x %lx %" PRIu64 " %d\n",
+		cid, scmd->scb[0], uaddr, offset, result);
 
+	/* TODO: preallocate cmd */
 	cmd = malloc(sizeof(*cmd));
-	cmd->cid = cid;
-	cmd->devid = devid;
+ 	cmd->cid = cid;
+	cmd->dev_id = dev_id;
 	cmd->uaddr = uaddr;
 	cmd->len = len;
 	cmd->mmap = try_map;
 
-	insque(&cmd->clist, &cqueue);
+	insque(&cmd->clist, &target->cqueue);
 
 	ev_res->u.cmd_res.host_no = host_no;
 	ev_res->u.cmd_res.cid = cid;
@@ -391,42 +385,42 @@
 	ev_res->u.cmd_res.try_map = try_map;
 	ev_res->u.cmd_res.offset = offset;
 
-	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
+	return __nl_write(nl_fd, TGT_UEVENT_CMD_RES, resbuf,
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
-static void cmd_done(char *buf)
+static void cmd_done(struct tgt_event *ev)
 {
-	struct tgt_event *ev = (struct tgt_event *) buf;
-	int err = 0;
-	uint32_t cid = ev->k.cmd_done.cid;
+	struct target *target;
+	struct device *device;
 	struct cmd *cmd;
-	int do_munmap;
+	int err, do_munmap, host_no = ev->k.cmd_done.host_no;
+	uint32_t cid = ev->k.cmd_done.cid;
 
-	cmd = find_cmd(cid);
+	target = host_to_target(host_no);
+	if (!target) {
+		eprintf("%d is not bind to any target\n", host_no);
+		return;
+	}
+
+	cmd = find_cmd(target, cid);
 	if (!cmd) {
-		eprintf("Cannot find cmd %u\n", cid);
+		eprintf("Cannot find cmd %d %u\n", host_no, cid);
 		return;
 	}
 	remque(&cmd->clist);
 	do_munmap = cmd->mmap;
 
 	if (do_munmap) {
-		if (cmd->devid >= target->max_device) {
-			eprintf("%" PRIu64 " %" PRIu64 "\n",
-				cmd->devid, target->max_device);
+		device = device_get(target, cmd->dev_id);
+		if (!device) {
+			eprintf("%" PRIu64 " is null\n", cmd->dev_id);
 			exit(1);
 		}
 
-		if (target->devt[cmd->devid]) {
-			if (target->devt[cmd->devid]->addr)
-				do_munmap = 0;
-		} else {
-			eprintf("%" PRIu64 " is null\n", cmd->devid);
-			exit(1);
-		}
+		if (device->addr)
+			do_munmap = 0;
 	}
-
 	err = scsi_cmd_done(do_munmap, !cmd->mmap, cmd->uaddr, cmd->len);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmap, cmd->uaddr, cmd->len, err);
@@ -434,152 +428,115 @@
 	free(cmd);
 }
 
-static void nl_cmd(int fd)
+void pk_event_handle(struct tgtd_info *ti, int nl_fd)
 {
-	struct nlmsghdr *nlh;
+	struct ringbuf_info *ri = &ti->ri;
+	struct tpacket_hdr *h;
 	struct tgt_event *ev;
-	static int pdu_size;
-	char buf[1024];
-	int err;
+retry:
+	h = (struct tpacket_hdr *) (ri->addr + ri->idx * ri->frame_size);
 
-	if (!pdu_size)
-		pdu_size = set_pdu_size(fd);
+	dprintf("%x %u %p\n", h->tp_status, ri->idx, ri->addr);
+	if (!(h->tp_status & TP_STATUS_USER))
+		return;
 
-	err = __nl_read(fd, buf, pdu_size, MSG_WAITALL);
-
-	nlh = (struct nlmsghdr *) buf;
-	ev = (struct tgt_event *) NLMSG_DATA(nlh);
-
-	if (nlh->nlmsg_len != pdu_size) {
-		eprintf("unexpected len %d %d\n", nlh->nlmsg_len, pdu_size);
-		exit(1);
-	}
-
-	switch (nlh->nlmsg_type) {
+	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
+	switch (h->tp_len) {
 	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(fd, NLMSG_DATA(buf));
+		cmd_queue(ev, nl_fd);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		cmd_done(NLMSG_DATA(buf));
+		cmd_done(ev);
 		break;
 	default:
-		eprintf("unknown event %u\n", nlh->nlmsg_type);
+		eprintf("unknown event %u\n", h->tp_len);
 		exit(1);
 	}
 
-}
+	ri->idx = ri->idx == ri->frame_nr - 1 ? 0: ri->idx + 1;
+	h->tp_status &= ~TP_STATUS_USER;
 
-static int bind_nls(int fd)
-{
-	struct sockaddr_nl addr;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.nl_family = AF_NETLINK;
-	addr.nl_pid = getpid();
-	addr.nl_groups = 0;
-
-	return bind(fd, (struct sockaddr *)&addr, sizeof(addr));
+	goto retry;
 }
 
-static void tthread_event_loop(struct target *target)
+int tgt_target_bind(int tid, int host_no)
 {
-	struct pollfd *pfd = target->pfd;
-	int fd, err;
+	if (!tgtt[tid]) {
+		eprintf("target is not found %d\n", tid);
+		return -EINVAL;
+	}
 
-	fd = nl_init();
-	dprintf("%d\n", fd);
-	err = bind_nls(fd);
-	dprintf("%d\n", err);
-
-	target->pfd[POLL_NL_CMD].fd = fd;
-	target->pfd[POLL_NL_CMD].events = POLLIN;
-
-	dprintf("Target thread started %u %d\n", getpid(), fd);
-
-	while (1) {
-		err = poll(pfd, 2, -1);
-		dprintf("target thread event %d\n", err);
-
-		if (err < 0) {
-			if (errno != EINTR)
-				exit(1);
-			else
-				continue;
-		}
-
-		if (pfd[POLL_IPC_CTRL].revents)
-			ipc_ctrl(pfd[POLL_IPC_CTRL].fd);
-
-		if (pfd[POLL_NL_CMD].revents)
-			nl_cmd(pfd[POLL_NL_CMD].fd);
+	if (hostt[host_no]) {
+		eprintf("host is already binded %d %d\n", tid, host_no);
+		return -EINVAL;
 	}
 
-	free(target);
+	hostt[host_no] = tgtt[tid];
+	return 0;
 }
 
-static int target_dir_create(int tid, int pid)
+static int target_dir_create(int tid)
 {
-	char path[PATH_MAX], buf[32];
-	int err, fd;
+	char path[PATH_MAX];
+	int err;
 
 	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
 	err = mkdir(path, dmode);
 	if (err < 0) {
-		eprintf("Cannot create %s\n", path);
+		eprintf("Cannot create %s %d\n", path, errno);
 		return err;
 	}
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/pid", tid);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%d", pid);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-
 	return 0;
 }
 
-int target_thread_create(int *sfd)
+int tgt_target_create(int tid)
 {
-	pid_t pid;
-	int fd[2];
-	static int tid = 0;
+	int err;
+	struct target *target;
 
-	if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) {
-		eprintf("Cannot create socketpair %d\n", errno);
-		return -1;
+	if (tid >= MAX_NR_TARGET) {
+		eprintf("Too larget target id %d\n", tid);
+		return -EINVAL;
 	}
 
-	tid++;
-
-	pid = fork();
-	if (pid < 0)
-		return -ENOMEM;
-	else if (pid) {
-		*sfd = fd[0];
-		close(fd[1]);
-		target_dir_create(tid, pid);
-		return tid;
+	if (tgtt[tid]) {
+		eprintf("Target id %d already exists\n", tid);
+		return -EINVAL;
 	}
 
 	target = malloc(sizeof(*target));
 	if (!target) {
 		eprintf("Out of memoryn\n");
-		exit(1);
+		return -ENOMEM;
 	}
 
+	target->tid = tid;
+	INIT_LIST_HEAD(&target->cqueue);
+
 	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct device *));
+	if (!target->devt) {
+		eprintf("Out of memoryn\n");
+		err = 0;
+		goto free_target;
+	}
 	target->max_device = DEFAULT_NR_DEVICE;
-	target->tid = tid;
 
-	close(fd[0]);
-	target->pfd[POLL_IPC_CTRL].fd = fd[1];
-	target->pfd[POLL_IPC_CTRL].events = POLLIN;
+	err = target_dir_create(tid);
+	if (err < 0)
+		goto free_device_table;
 
-	tthread_event_loop(target);
+	tgtt[tid] = target;
+	return 0;
 
+free_device_table:
+	free(target->devt);
+free_target:
+	free(target);
+	return err;
+}
+
+int tgt_target_destroy(int tid)
+{
+	/* TODO */
 	return 0;
 }

Deleted: branches/use-scsi-ml/usr/tgt_device.c
===================================================================

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-02-07 06:43:36 UTC (rev 278)
@@ -1,5 +1,5 @@
 /*
- * Target framework user-space main daemon
+ * SCSI target user-space daemon
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -26,12 +26,10 @@
 #include "tgtd.h"
 #include "dl.h"
 
-int nl_fd, ipc_fd;
-struct pollfd *poll_array;
-
 enum {
-	POLL_NL,
-	POLL_IPC,
+	POLL_NL, /* netlink socket between kernel and user space */
+	POLL_PK, /* packet socket between kernel and user space */
+	POLL_UD, /* unix domain socket for tgtdadm */
 };
 
 static struct option const long_options[] =
@@ -115,13 +113,13 @@
 
 /* TODO: rewrite makeshift poll code */
 
-static void event_loop(int nr_dls, struct pollfd *poll_array)
+static void event_loop(struct tgtd_info *ti, struct pollfd *pfd, int nr_dls)
 {
-	int err, i, poll_max = (nr_dls + 2) * POLLS_PER_DRV;
+	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
 
 	while (1) {
-		if ((err = poll(poll_array, poll_max, -1)) < 0) {
+		if ((err = poll(pfd, poll_max, -1)) < 0) {
 			if (errno != EINTR) {
 				eprintf("%d %d\n", err, errno);
 				exit(1);
@@ -129,61 +127,69 @@
 			continue;
 		}
 
-		if (poll_array[POLL_NL].revents) {
-			nl_event_handle(dlinfo, nl_fd);
+		if (pfd[POLL_NL].revents) {
+			/* Currently, never happens. */
+			eprintf("bug\n");
+			exit(1);
 			err--;
 		}
 
-		if (poll_array[POLL_IPC].revents) {
-			ipc_event_handle(dlinfo, ipc_fd);
+		if (pfd[POLL_PK].revents) {
+			pk_event_handle(ti, pfd[POLL_NL].fd);
 			err--;
 		}
 
+		if (pfd[POLL_UD].revents) {
+			ipc_event_handle(dlinfo, pfd[POLL_UD].fd);
+			err--;
+		}
+
 		if (!err)
 			continue;
 
-		for (i = POLLS_PER_DRV; i < POLLS_PER_DRV * 2; i++)
-			if (poll_array[i].revents) {
-				dprintf("target process event %d\n", i);
-				pipe_event_handle(poll_array[i].fd);
-			}
-
 		for (i = 0; i < nr_dls; i++) {
 			fn = dl_poll_fn(dlinfo, i);
 			if (fn)
-				fn(poll_array + ((i + 2) * POLLS_PER_DRV), POLLS_PER_DRV);
+				fn(pfd + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
 	}
 }
 
-static struct pollfd * poll_init(int nr)
+static struct pollfd * poll_init(int nr, int nl_fd, int pk_fd, int ud_fd)
 {
-	struct pollfd *array;
+	struct pollfd *pfd;
 	void (* fn)(struct pollfd *, int);
 	int i;
 
-	array = calloc((nr + 2) * POLLS_PER_DRV, sizeof(struct pollfd));
-	if (!array)
-		exit(-ENOMEM);
+	pfd = calloc((nr + 1) * POLLS_PER_DRV, sizeof(struct pollfd));
+	if (!pfd) {
+		eprintf("Out of memory\n");
+		exit(1);
+	}
 
-	array[POLL_NL].fd = nl_fd;
-	array[POLL_NL].events = POLLIN;
-	array[POLL_IPC].fd = ipc_fd;
-	array[POLL_IPC].events = POLLIN;
+	pfd[POLL_NL].fd = nl_fd;
+	pfd[POLL_NL].events = POLLIN;
+	pfd[POLL_PK].fd = pk_fd;
+	pfd[POLL_PK].events = POLLIN;
+	pfd[POLL_UD].fd = ud_fd;
+	pfd[POLL_UD].events = POLLIN;
 
 	for (i = 0; i < nr; i++) {
 		fn = dl_poll_init_fn(dlinfo, i);
 		if (fn)
-			fn(array + (i + 2) * POLLS_PER_DRV, POLLS_PER_DRV);
+			fn(pfd + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}
 
-	return array;
+	return pfd;
 }
 
 int main(int argc, char **argv)
 {
-	int ch, longindex, nr;
+	struct tgtd_info ti;
+	struct pollfd *pfd;
+	int ch, longindex, nr, err;
 	int is_daemon = 1, is_debug = 1;
+	int nl_fd, pk_fd, ud_fd;
 
 	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
 				 &longindex)) >= 0) {
@@ -217,23 +223,21 @@
 	if (tgt_device_init())
 		exit(1);
 
-	nl_fd = nl_init();
-	if (nl_fd < 0)
+	err = nl_init(&nl_fd, &pk_fd, &ti.ri);
+	if (err < 0)
 		exit(1);
-	if (nl_start(nl_fd))
-		exit(1);
 
-	ipc_fd = ipc_open();
-	if (ipc_fd < 0)
+	ud_fd = ipc_open();
+	if (ud_fd < 0)
 		exit(1);
 
 	nr = dl_init(dlinfo);
 	if (nr < nr)
 		exit(1);
 
-	poll_array = poll_init(nr);
+	pfd = poll_init(nr, nl_fd, pk_fd, ud_fd);
 
-	event_loop(nr, poll_array);
+	event_loop(&ti, pfd, nr);
 
 	return 0;
 }

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-07 06:43:36 UTC (rev 278)
@@ -4,28 +4,36 @@
 #include "log.h"
 #include "dl.h"
 
-/* temporarily */
+/* makeshift */
 #define	POLLS_PER_DRV	32
-extern int nl_fd;
-extern struct pollfd *poll_array;
+#define	RINGBUF_SIZE	(4096 * 8)
 
-extern int target_thread_create(int *fd);
+struct ringbuf_info {
+	char *addr;
+	uint32_t idx;
+	uint32_t frame_size;
+	uint32_t frame_nr;
+};
 
-extern int nl_init(void);
-extern void nl_event_handle(struct driver_info *, int fd);
-extern int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen);
-extern int nl_start(int fd);
+struct tgtd_info {
+	struct ringbuf_info ri;
+};
+
+extern int nl_init(int *, int *, struct ringbuf_info *);
 extern int __nl_write(int fd, int type, char *data, int len);
-extern int __nl_read(int fd, void *data, int size, int flags);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(struct driver_info *, int fd);
-extern void pipe_event_handle(int fd);
 
 extern int tgt_device_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, int dfd);
+extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
+extern int tgt_target_create(int tid);
+extern int tgt_target_destroy(int tid);
+extern int tgt_target_bind(int tid, int host_no);
 
+extern void pk_event_handle(struct tgtd_info *ti, int nl_fd);
+
 extern uint64_t scsi_get_devid(uint8_t *pdu);
 extern int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,

Added: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-02-07 00:40:21 UTC (rev 277)
+++ branches/use-scsi-ml/usr/util.h	2006-02-07 06:43:36 UTC (rev 278)
@@ -0,0 +1,31 @@
+/* taken from linux kernel */
+
+#undef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define INIT_LIST_HEAD(ptr) do { \
+	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
+} while (0)
+
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
+	     &pos->member != (head); 	\
+	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
+
+struct qelem {
+	struct qelem *q_forw;
+	struct qelem *q_back;
+};



From tomo at berlios.de  Tue Feb  7 07:59:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 07:59:03 +0100
Subject: [Stgt-svn] r279 - branches/use-scsi-ml/kernel
Message-ID: <200602070659.k176x3sS031080@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 07:58:59 +0100 (Tue, 07 Feb 2006)
New Revision: 279

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Fix a bug not to free scsi_tgt_cmd.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 06:43:36 UTC (rev 278)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 06:58:59 UTC (rev 279)
@@ -66,11 +66,13 @@
 static void scsi_tgt_cmd_destroy(void *data)
 {
 	struct scsi_cmnd *cmd = data;
+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 
 	dprintk("cmd %p\n", cmd);
 
-	scsi_unmap_user_pages(cmd->request->end_io_data);
+	scsi_unmap_user_pages(tcmd);
 	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
 }
 



From tomo at berlios.de  Tue Feb  7 08:10:26 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 08:10:26 +0100
Subject: [Stgt-svn] r280 - branches/use-scsi-ml/kernel
Message-ID: <200602070710.k177AQav002730@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 08:10:23 +0100 (Tue, 07 Feb 2006)
New Revision: 280

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Cosmetic cleanup on license stuff.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 06:58:59 UTC (rev 279)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 07:10:23 UTC (rev 280)
@@ -1,22 +1,23 @@
 /*
  * SCSI target kernel/user interface functions
  *
- * Copyright 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
 #include <linux/blkdev.h>
 #include <linux/file.h>

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 06:58:59 UTC (rev 279)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 07:10:23 UTC (rev 280)
@@ -1,27 +1,28 @@
 /*
  * SCSI target lib functions
  *
- * Copyright 2005 Mike Christie
- * Copyright 2005 FUJITA Tomonori
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; see the file COPYING.  If not, write to
- * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-#include <linux/module.h>
 #include <linux/bio-list.h>
 #include <linux/blkdev.h>
 #include <linux/elevator.h>
+#include <linux/module.h>
 #include <linux/pagemap.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>



From tomo at berlios.de  Tue Feb  7 08:22:12 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 08:22:12 +0100
Subject: [Stgt-svn] r281 - branches/use-scsi-ml/kernel
Message-ID: <200602070722.k177MCE7005794@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 08:22:10 +0100 (Tue, 07 Feb 2006)
New Revision: 281

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Update the kernel patch.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 07:10:23 UTC (rev 280)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 07:22:10 UTC (rev 281)
@@ -541,6 +541,19 @@
  extern void bio_unmap_user(struct bio *);
  extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
  				gfp_t);
+diff --git a/include/linux/if_packet.h b/include/linux/if_packet.h
+index b925585..c66d555 100644
+--- a/include/linux/if_packet.h
++++ b/include/linux/if_packet.h
+@@ -48,7 +48,7 @@ struct tpacket_stats
+ 
+ struct tpacket_hdr
+ {
+-	unsigned long	tp_status;
++	unsigned int	tp_status;
+ #define TP_STATUS_KERNEL	0
+ #define TP_STATUS_USER		1
+ #define TP_STATUS_COPY		2
 diff --git a/include/linux/netlink.h b/include/linux/netlink.h
 index 6a2ccf7..580fb42 100644
 --- a/include/linux/netlink.h
@@ -710,40 +723,39 @@
 +extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
 diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
 new file mode 100644
-index 0000000..0830107
+index 0000000..04be52d
 --- /dev/null
 +++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,95 @@
+@@ -0,0 +1,92 @@
 +/*
 + * SCSI target kernel/user interface
 + *
-+ * Copyright 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
 + *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2, or (at your option)
-+ * any later version.
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
 + *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
 + *
 + * You should have received a copy of the GNU General Public License
-+ * along with this program; see the file COPYING.  If not, write to
-+ * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
 + */
-+
 +#ifndef __SCSI_TARGET_IF_H
 +#define __SCSI_TARGET_IF_H
 +
 +enum tgt_event_type {
 +	/* user -> kernel */
-+	TGT_UEVENT_START,
++	TGT_UEVENT_TGTD_BIND,
 +	TGT_UEVENT_TARGET_SETUP,
 +	TGT_UEVENT_CMD_RES,
-+	TGT_UEVENT_TARGET_BIND,
 +
 +	/* kernel -> user */
 +	TGT_KEVENT_RESPONSE,
@@ -755,10 +767,8 @@
 +	/* user-> kernel */
 +	union {
 +		struct {
-+			int host_no;
-+			int pid;
-+			int psfd;
-+		} target_bind;
++			int pk_fd;
++		} tgtd_bind;
 +		struct {
 +			int host_no;
 +			uint32_t cid;
@@ -810,10 +820,10 @@
 +
 +#endif
 diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
-index 9db7dbd..aee86cd 100644
+index 9db7dbd..2ab3e7b 100644
 --- a/net/packet/af_packet.c
 +++ b/net/packet/af_packet.c
-@@ -562,6 +562,24 @@ drop:
+@@ -562,6 +562,23 @@ drop:
  }
  
  #ifdef CONFIG_PACKET_MMAP
@@ -821,7 +831,6 @@
 +{
 +	struct packet_sock *po;
 +	struct tpacket_hdr *h;
-+	int err;
 +
 +	po = pkt_sk(sk);
 +	spin_lock(&sk->sk_receive_queue.lock);



From tomo at berlios.de  Tue Feb  7 09:15:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 09:15:28 +0100
Subject: [Stgt-svn] r282 - branches/use-scsi-ml/kernel
Message-ID: <200602070815.k178FShu000982@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 09:15:26 +0100 (Tue, 07 Feb 2006)
New Revision: 282

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Rename packet_frame packet_socket_frame.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 07:22:10 UTC (rev 281)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 08:15:26 UTC (rev 282)
@@ -70,7 +70,7 @@
 	}
 	sk = pk_sock->sk;
 
-	h = packet_frame(sk);
+	h = packet_socket_frame(sk);
 	if (IS_ERR(h)) {
 		eprintk("Queue is full\n");
 		return PTR_ERR(h);
@@ -110,7 +110,7 @@
 	}
 	sk = pk_sock->sk;
 
-	h = packet_frame(sk);
+	h = packet_socket_frame(sk);
 	if (IS_ERR(h)) {
 		eprintk("Queue is full\n");
 		return PTR_ERR(h);

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 07:22:10 UTC (rev 281)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 08:15:26 UTC (rev 282)
@@ -582,14 +582,14 @@
  #define	LEVEL_LINEAR		(-1)
 diff --git a/include/net/af_packet.h b/include/net/af_packet.h
 new file mode 100644
-index 0000000..e280e7c
+index 0000000..5a75e07
 --- /dev/null
 +++ b/include/net/af_packet.h
 @@ -0,0 +1,6 @@
 +#ifndef __LINUX_NET_AFPACKET_H
 +#define __LINUX_NET_AFPACKET_H
 +
-+extern void *packet_frame(struct sock *sk);
++extern struct tpacket_hdr *packet_socket_frame(struct sock *sk);
 +
 +#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
@@ -820,14 +820,14 @@
 +
 +#endif
 diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
-index 9db7dbd..2ab3e7b 100644
+index 9db7dbd..4069fc8 100644
 --- a/net/packet/af_packet.c
 +++ b/net/packet/af_packet.c
 @@ -562,6 +562,23 @@ drop:
  }
  
  #ifdef CONFIG_PACKET_MMAP
-+void *packet_frame(struct sock *sk)
++struct tpacket_hdr *packet_socket_frame(struct sock *sk)
 +{
 +	struct packet_sock *po;
 +	struct tpacket_hdr *h;



From tomo at berlios.de  Tue Feb  7 10:06:41 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 7 Feb 2006 10:06:41 +0100
Subject: [Stgt-svn] r283 - branches/use-scsi-ml/kernel
Message-ID: <200602070906.k1796fea020129@sheep.berlios.de>

Author: tomo
Date: 2006-02-07 10:06:41 +0100 (Tue, 07 Feb 2006)
New Revision: 283

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Rename packet_frame again.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 08:15:26 UTC (rev 282)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-07 09:06:41 UTC (rev 283)
@@ -820,7 +820,7 @@
 +
 +#endif
 diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
-index 9db7dbd..4069fc8 100644
+index 9db7dbd..b5fbd74 100644
 --- a/net/packet/af_packet.c
 +++ b/net/packet/af_packet.c
 @@ -562,6 +562,23 @@ drop:
@@ -842,7 +842,7 @@
 +	spin_unlock(&sk->sk_receive_queue.lock);
 +	return h;
 +}
-+EXPORT_SYMBOL_GPL(packet_frame);
++EXPORT_SYMBOL_GPL(packet_socket_frame);
 +
  static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
  {



From tomo at berlios.de  Wed Feb  8 08:33:31 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 8 Feb 2006 08:33:31 +0100
Subject: [Stgt-svn] r284 - in branches/use-scsi-ml: kernel usr
Message-ID: <200602080733.k187XVLR003641@sheep.berlios.de>

Author: tomo
Date: 2006-02-08 08:33:25 +0100 (Wed, 08 Feb 2006)
New Revision: 284

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Go back to netlink. I'm not sure it's temporary or permanent.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-08 07:33:25 UTC (rev 284)
@@ -21,7 +21,6 @@
  */
 #include <linux/blkdev.h>
 #include <linux/file.h>
-#include <linux/if_packet.h>
 #include <linux/netlink.h>
 #include <net/af_packet.h>
 #include <net/tcp.h>
@@ -36,48 +35,51 @@
 
 static int tgtd_pid;
 static struct sock *nl_sk;
-static struct socket *pk_sock;
 
-static void tpacket_done(struct sock *sk, struct tpacket_hdr *h, int len)
+static int send_event_res(uint16_t type, struct tgt_event *p,
+			  void *data, int dlen, gfp_t flags, pid_t pid)
 {
-	h->tp_status = TP_STATUS_USER;
-	mb();
-	{
-		struct page *p_start, *p_end;
-		char *h_end = (char *) h + TPACKET_HDRLEN + len - 1;
+	struct tgt_event *ev;
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len;
 
-		p_start = virt_to_page(h);
-		p_end = virt_to_page(h_end);
-		while (p_start <= p_end) {
-			flush_dcache_page(p_start);
-			p_start++;
-		}
-	}
-	sk->sk_data_ready(sk, 0);
+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
+	skb = alloc_skb(len, flags);
+	if (!skb)
+		return -ENOMEM;
+
+	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
+
+	ev = NLMSG_DATA(nlh);
+	memcpy(ev, p, sizeof(*ev));
+	if (dlen)
+		memcpy(ev->data, data, dlen);
+
+	return netlink_unicast(nl_sk, skb, pid, 0);
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun)
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct sock *sk;
-	struct tpacket_hdr *h;
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	struct tgt_cmd *tcmd;
+	int err, len;
 
-	if (!pk_sock) {
-		printk(KERN_INFO "Host%d not connected\n", shost->host_no);
-		return -ENOTCONN;
-	}
-	sk = pk_sock->sk;
+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
+	/*
+	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
+	 */
+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
+	if (!skb)
+		return -ENOMEM;
 
-	h = packet_socket_frame(sk);
-	if (IS_ERR(h)) {
-		eprintk("Queue is full\n");
-		return PTR_ERR(h);
-	}
+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
+			  len - sizeof(*nlh), 0);
 
-	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-	h->tp_len = TGT_KEVENT_CMD_REQ;
+	ev = NLMSG_DATA(nlh);
 	ev->k.cmd_req.host_no = shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
@@ -92,75 +94,28 @@
 	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
 	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
 
-	tpacket_done(sk, h, sizeof(struct tgt_event) + sizeof(struct tgt_cmd));
-	return 0;
+	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
+	if (err < 0)
+		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
+		       err);
+	return err;
 }
 
 int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct sock *sk;
-	struct tgt_event *ev;
-	struct tpacket_hdr *h;
+	struct tgt_event ev;
+	char dummy[sizeof(struct tgt_cmd)];
 
-	if (!pk_sock) {
-		printk(KERN_INFO "Host%d not connected\n",
-		       shost->host_no);
-		return -ENOTCONN;
-	}
-	sk = pk_sock->sk;
+	memset(&ev, 0, sizeof(ev));
+	ev.k.cmd_done.host_no = shost->host_no;
+	ev.k.cmd_done.cid = cmd->request->tag;
+	ev.k.cmd_done.result = cmd->result;
 
-	h = packet_socket_frame(sk);
-	if (IS_ERR(h)) {
-		eprintk("Queue is full\n");
-		return PTR_ERR(h);
-	}
-
-	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-	h->tp_len = TGT_KEVENT_CMD_DONE;
-	ev->k.cmd_done.host_no = shost->host_no;
-	ev->k.cmd_done.cid = cmd->request->tag;
-	ev->k.cmd_done.result = cmd->result;
-
-	tpacket_done(sk, h, sizeof(struct tgt_event));
-	return 0;
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
+			      gfp_mask, tgtd_pid);
 }
 
-static int send_event_res(uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags, pid_t pid)
-{
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len;
-
-	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-	skb = alloc_skb(len, flags);
-	if (!skb)
-		return -ENOMEM;
-
-	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-
-	ev = NLMSG_DATA(nlh);
-	memcpy(ev, p, sizeof(*ev));
-	if (dlen)
-		memcpy(ev->data, data, dlen);
-
-	return netlink_unicast(nl_sk, skb, pid, 0);
-}
-
-static int tgtd_bind(struct tgt_event *ev)
-{
-	int err, pk_fd = ev->u.tgtd_bind.pk_fd;
-
-	pk_sock = sockfd_lookup(pk_fd, &err);
-	if (!pk_sock) {
-		eprintk("Invalid fd %d\n", pk_fd);
-		return err;
-	}
-	return 0;
-}
-
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	struct tgt_event *ev = NLMSG_DATA(nlh);
@@ -172,7 +127,6 @@
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_TGTD_BIND:
 		tgtd_pid = NETLINK_CREDS(skb)->pid;
-		err = tgtd_bind(ev);
 		break;
 	case TGT_UEVENT_CMD_RES:
 		/* TODO: handle multiple cmds in one event */
@@ -248,8 +202,6 @@
 void __exit scsi_tgt_if_exit(void)
 {
 	sock_release(nl_sk->sk_socket);
-	if (pk_sock)
-		fput(pk_sock->file);
 }
 
 int __init scsi_tgt_if_init(void)

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-08 07:33:25 UTC (rev 284)
@@ -117,7 +117,7 @@
 			break;
 
 		spin_unlock_irq(q->queue_lock);
-		if (scsi_tgt_uspace_send(cmd, tcmd->lun) < 0)
+		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
 			goto requeue;
 		spin_lock_irq(q->queue_lock);
 	}

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-08 07:33:25 UTC (rev 284)
@@ -18,7 +18,7 @@
 extern void scsi_tgt_if_exit(void);
 extern int scsi_tgt_if_init(void);
 
-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun);
+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				u64 offset, unsigned long uaddr, u8 rw,

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-08 07:33:25 UTC (rev 284)
@@ -21,8 +21,6 @@
 #include <sys/signal.h>
 #include <sys/socket.h>
 #include <asm/types.h>
-#include <linux/if_ether.h>
-#include <linux/if_packet.h>
 #include <linux/netlink.h>
 
 #include <scsi/scsi_tgt_if.h>
@@ -51,7 +49,7 @@
 		      sizeof(daddr));
 }
 
-static int __nl_read(int fd, void *data, int size, int flags)
+int __nl_read(int fd, void *data, int size, int flags)
 {
 	struct sockaddr_nl saddr;
 	socklen_t slen = sizeof(saddr);
@@ -121,50 +119,13 @@
 	return err;
 }
 
-static int ringbuf_init(int pk_fd, struct ringbuf_info *ri)
+static int tgtd_bind(int nl_fd)
 {
-	struct tpacket_req req;
 	int err;
-	socklen_t len = sizeof(req);
-	unsigned int size = RINGBUF_SIZE;
-	void *addr;
-
-	req.tp_frame_size = TPACKET_ALIGN(TPACKET_HDRLEN +
-					  sizeof(struct tgt_event) +
-					  sizeof(struct tgt_cmd));
-	req.tp_block_size = size;
-	req.tp_frame_nr = req.tp_block_size / req.tp_frame_size;
-	req.tp_block_nr = 1;
-
-	err = setsockopt(pk_fd, SOL_PACKET, PACKET_RX_RING, &req, len);
-	dprintf("%d %u %u\n", errno, req.tp_frame_size, req.tp_frame_nr);
-	if (err < 0)
-		return err;
-
-	addr = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, pk_fd, 0);
-
-	ri->frame_size = req.tp_frame_size;
-	ri->frame_nr = req.tp_frame_nr;
-	ri->addr = addr;
-	ri->idx = 0;
-
-	dprintf("%p\n",addr);
-
-	if (addr == MAP_FAILED) {
-		eprintf("fail to mmap %d\n", errno);
-		return -EINVAL;
-	} else
-		return 0;
-}
-
-static int tgtd_bind(int nl_fd, int pk_fd)
-{
-	int err;
 	struct tgt_event *ev;
 	char sbuf[NL_BUFSIZE], rbuf[NL_BUFSIZE];
 
 	ev = (struct tgt_event *) NLMSG_DATA(sbuf);
-	ev->u.tgtd_bind.pk_fd = pk_fd;
 	err = nl_cmd_call(nl_fd, TGT_UEVENT_TGTD_BIND, sbuf,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
 			  rbuf, NL_BUFSIZE);
@@ -178,9 +139,9 @@
 	return 0;
 }
 
-int nl_init(int *nfd, int *pfd, struct ringbuf_info *ri)
+int nl_init(void)
 {
-	int err, nl_fd, pk_fd;
+	int err, nl_fd;
 
 	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
 	if (nl_fd < 0) {
@@ -188,21 +149,9 @@
 		exit(1);
 	}
 
-	pk_fd = socket(PF_PACKET, SOCK_RAW, 0);
-	if (pk_fd < 0) {
-		eprintf("Fail to create the packet socket %d\n", errno);
-		exit(1);
-	}
-
-	err = ringbuf_init(pk_fd, ri);
+	err = tgtd_bind(nl_fd);
 	if (err)
 		exit(1);
 
-	err = tgtd_bind(nl_fd, pk_fd);
-	if (err)
-		exit(1);
-
-	*nfd = nl_fd;
-	*pfd = pk_fd;
-	return 0;
+	return nl_fd;
 }

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/usr/target.c	2006-02-08 07:33:25 UTC (rev 284)
@@ -22,8 +22,6 @@
 #include <sys/stat.h>
 
 #include <linux/fs.h>
-#include <linux/if_ether.h>
-#include <linux/if_packet.h>
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>
 
@@ -428,20 +426,49 @@
 	free(cmd);
 }
 
-void pk_event_handle(struct tgtd_info *ti, int nl_fd)
+static int set_pdu_size(int fd)
 {
-	struct ringbuf_info *ri = &ti->ri;
-	struct tpacket_hdr *h;
+	struct nlmsghdr *nlh;
+	char buf[1024];
+	int err;
+
+peek_again:
+	err = __nl_read(fd, buf, sizeof(buf), MSG_PEEK);
+	if (err < 0) {
+		if (errno == EAGAIN || errno == EINTR)
+			goto peek_again;
+		return err;
+	}
+
+	nlh = (struct nlmsghdr *) buf;
+
+	dprintf("%d\n", nlh->nlmsg_len);
+
+	return nlh->nlmsg_len;
+}
+
+void nl_event_handle(int nl_fd)
+{
+	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
-retry:
-	h = (struct tpacket_hdr *) (ri->addr + ri->idx * ri->frame_size);
+	static int pdu_size;
+	char buf[1024];
+	int err;
 
-	dprintf("%x %u %p\n", h->tp_status, ri->idx, ri->addr);
-	if (!(h->tp_status & TP_STATUS_USER))
-		return;
+	if (!pdu_size)
+		pdu_size = set_pdu_size(nl_fd);
 
-	ev = (struct tgt_event *) ((char *) h + TPACKET_HDRLEN);
-	switch (h->tp_len) {
+	err = __nl_read(nl_fd, buf, pdu_size, MSG_WAITALL);
+
+	nlh = (struct nlmsghdr *) buf;
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
+
+	if (nlh->nlmsg_len != pdu_size) {
+		eprintf("unexpected len %d %d\n", nlh->nlmsg_len, pdu_size);
+		exit(1);
+	}
+
+	switch (nlh->nlmsg_type) {
 	case TGT_KEVENT_CMD_REQ:
 		cmd_queue(ev, nl_fd);
 		break;
@@ -449,14 +476,9 @@
 		cmd_done(ev);
 		break;
 	default:
-		eprintf("unknown event %u\n", h->tp_len);
+		eprintf("unknown event %u\n", nlh->nlmsg_type);
 		exit(1);
 	}
-
-	ri->idx = ri->idx == ri->frame_nr - 1 ? 0: ri->idx + 1;
-	h->tp_status &= ~TP_STATUS_USER;
-
-	goto retry;
 }
 
 int tgt_target_bind(int tid, int host_no)

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-02-08 07:33:25 UTC (rev 284)
@@ -28,7 +28,6 @@
 
 enum {
 	POLL_NL, /* netlink socket between kernel and user space */
-	POLL_PK, /* packet socket between kernel and user space */
 	POLL_UD, /* unix domain socket for tgtdadm */
 };
 
@@ -113,7 +112,7 @@
 
 /* TODO: rewrite makeshift poll code */
 
-static void event_loop(struct tgtd_info *ti, struct pollfd *pfd, int nr_dls)
+static void event_loop(struct driver_info *dlinfo, struct pollfd *pfd, int nr_dls)
 {
 	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
@@ -128,17 +127,10 @@
 		}
 
 		if (pfd[POLL_NL].revents) {
-			/* Currently, never happens. */
-			eprintf("bug\n");
-			exit(1);
+			nl_event_handle(pfd[POLL_NL].fd);
 			err--;
 		}
 
-		if (pfd[POLL_PK].revents) {
-			pk_event_handle(ti, pfd[POLL_NL].fd);
-			err--;
-		}
-
 		if (pfd[POLL_UD].revents) {
 			ipc_event_handle(dlinfo, pfd[POLL_UD].fd);
 			err--;
@@ -155,7 +147,7 @@
 	}
 }
 
-static struct pollfd * poll_init(int nr, int nl_fd, int pk_fd, int ud_fd)
+static struct pollfd * poll_init(int nr, int nl_fd, int ud_fd)
 {
 	struct pollfd *pfd;
 	void (* fn)(struct pollfd *, int);
@@ -169,8 +161,6 @@
 
 	pfd[POLL_NL].fd = nl_fd;
 	pfd[POLL_NL].events = POLLIN;
-	pfd[POLL_PK].fd = pk_fd;
-	pfd[POLL_PK].events = POLLIN;
 	pfd[POLL_UD].fd = ud_fd;
 	pfd[POLL_UD].events = POLLIN;
 
@@ -185,11 +175,10 @@
 
 int main(int argc, char **argv)
 {
-	struct tgtd_info ti;
 	struct pollfd *pfd;
-	int ch, longindex, nr, err;
+	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	int nl_fd, pk_fd, ud_fd;
+	int nl_fd, ud_fd;
 
 	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
 				 &longindex)) >= 0) {
@@ -223,8 +212,8 @@
 	if (tgt_device_init())
 		exit(1);
 
-	err = nl_init(&nl_fd, &pk_fd, &ti.ri);
-	if (err < 0)
+	nl_fd = nl_init();
+	if (nl_fd < 0)
 		exit(1);
 
 	ud_fd = ipc_open();
@@ -235,9 +224,9 @@
 	if (nr < nr)
 		exit(1);
 
-	pfd = poll_init(nr, nl_fd, pk_fd, ud_fd);
+	pfd = poll_init(nr, nl_fd, ud_fd);
 
-	event_loop(&ti, pfd, nr);
+	event_loop(dlinfo, pfd, nr);
 
 	return 0;
 }

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-07 09:06:41 UTC (rev 283)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-08 07:33:25 UTC (rev 284)
@@ -8,19 +8,10 @@
 #define	POLLS_PER_DRV	32
 #define	RINGBUF_SIZE	(4096 * 8)
 
-struct ringbuf_info {
-	char *addr;
-	uint32_t idx;
-	uint32_t frame_size;
-	uint32_t frame_nr;
-};
-
-struct tgtd_info {
-	struct ringbuf_info ri;
-};
-
-extern int nl_init(int *, int *, struct ringbuf_info *);
+extern int nl_init(void);
 extern int __nl_write(int fd, int type, char *data, int len);
+extern int __nl_read(int fd, void *data, int size, int flags);
+void nl_event_handle(int nl_fd);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(struct driver_info *, int fd);
@@ -32,8 +23,6 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no);
 
-extern void pk_event_handle(struct tgtd_info *ti, int nl_fd);
-
 extern uint64_t scsi_get_devid(uint8_t *pdu);
 extern int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,



From tomo at berlios.de  Thu Feb  9 03:13:02 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 9 Feb 2006 03:13:02 +0100
Subject: [Stgt-svn] r285 - branches/use-scsi-ml/kernel
Message-ID: <200602090213.k192D26V012800@sheep.berlios.de>

Author: tomo
Date: 2006-02-09 03:12:53 +0100 (Thu, 09 Feb 2006)
New Revision: 285

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Update the kernel patch.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-08 07:33:25 UTC (rev 284)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-09 02:12:53 UTC (rev 285)
@@ -22,7 +22,6 @@
 #include <linux/blkdev.h>
 #include <linux/file.h>
 #include <linux/netlink.h>
-#include <net/af_packet.h>
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-08 07:33:25 UTC (rev 284)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-09 02:12:53 UTC (rev 285)
@@ -19,7 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
-#include <linux/bio-list.h>
 #include <linux/blkdev.h>
 #include <linux/elevator.h>
 #include <linux/module.h>
@@ -29,6 +28,7 @@
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tgt.h>
+#include <../drivers/md/dm-bio-list.h>
 
 #include "scsi_tgt_priv.h"
 

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-08 07:33:25 UTC (rev 284)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-09 02:12:53 UTC (rev 285)
@@ -21,170 +21,6 @@
  	if (IS_ERR(bio))
  		return PTR_ERR(bio);
  
-diff --git a/drivers/md/dm-bio-list.h b/drivers/md/dm-bio-list.h
-deleted file mode 100644
-index bbf4615..0000000
---- a/drivers/md/dm-bio-list.h
-+++ /dev/null
-@@ -1,71 +0,0 @@
--/*
-- * Copyright (C) 2004 Red Hat UK Ltd.
-- *
-- * This file is released under the GPL.
-- */
--
--#ifndef DM_BIO_LIST_H
--#define DM_BIO_LIST_H
--
--#include <linux/bio.h>
--
--struct bio_list {
--	struct bio *head;
--	struct bio *tail;
--};
--
--static inline void bio_list_init(struct bio_list *bl)
--{
--	bl->head = bl->tail = NULL;
--}
--
--static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
--{
--	bio->bi_next = NULL;
--
--	if (bl->tail)
--		bl->tail->bi_next = bio;
--	else
--		bl->head = bio;
--
--	bl->tail = bio;
--}
--
--static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
--{
--	if (!bl2->head)
--		return;
--
--	if (bl->tail)
--		bl->tail->bi_next = bl2->head;
--	else
--		bl->head = bl2->head;
--
--	bl->tail = bl2->tail;
--}
--
--static inline struct bio *bio_list_pop(struct bio_list *bl)
--{
--	struct bio *bio = bl->head;
--
--	if (bio) {
--		bl->head = bl->head->bi_next;
--		if (!bl->head)
--			bl->tail = NULL;
--
--		bio->bi_next = NULL;
--	}
--
--	return bio;
--}
--
--static inline struct bio *bio_list_get(struct bio_list *bl)
--{
--	struct bio *bio = bl->head;
--
--	bl->head = bl->tail = NULL;
--
--	return bio;
--}
--
--#endif
-diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
-index f72a82f..c6e206f 100644
---- a/drivers/md/dm-mpath.c
-+++ b/drivers/md/dm-mpath.c
-@@ -8,9 +8,9 @@
- #include "dm.h"
- #include "dm-path-selector.h"
- #include "dm-hw-handler.h"
--#include "dm-bio-list.h"
- #include "dm-bio-record.h"
- 
-+#include <linux/bio-list.h>
- #include <linux/ctype.h>
- #include <linux/init.h>
- #include <linux/mempool.h>
-diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
-index 6cfa8d4..53f589b 100644
---- a/drivers/md/dm-raid1.c
-+++ b/drivers/md/dm-raid1.c
-@@ -5,11 +5,11 @@
-  */
- 
- #include "dm.h"
--#include "dm-bio-list.h"
- #include "dm-io.h"
- #include "dm-log.h"
- #include "kcopyd.h"
- 
-+#include <linux/bio-list.h>
- #include <linux/ctype.h>
- #include <linux/init.h>
- #include <linux/mempool.h>
-diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
-index f3759dd..2e65db8 100644
---- a/drivers/md/dm-snap.c
-+++ b/drivers/md/dm-snap.c
-@@ -18,9 +18,9 @@
- #include <linux/module.h>
- #include <linux/slab.h>
- #include <linux/vmalloc.h>
-+#include <linux/bio-list.h>
- 
- #include "dm-snap.h"
--#include "dm-bio-list.h"
- #include "kcopyd.h"
- 
- /*
-diff --git a/drivers/md/dm.c b/drivers/md/dm.c
-index e9adeb9..020f415 100644
---- a/drivers/md/dm.c
-+++ b/drivers/md/dm.c
-@@ -6,8 +6,8 @@
-  */
- 
- #include "dm.h"
--#include "dm-bio-list.h"
- 
-+#include <linux/bio-list.h>
- #include <linux/init.h>
- #include <linux/module.h>
- #include <linux/moduleparam.h>
-diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
-index d39f584..4e43ce2 100644
---- a/drivers/md/raid1.c
-+++ b/drivers/md/raid1.c
-@@ -31,7 +31,7 @@
-  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-  */
- 
--#include "dm-bio-list.h"
-+#include <linux/bio-list.h>
- #include <linux/raid/raid1.h>
- #include <linux/raid/bitmap.h>
- 
-diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
-index ab90a6d..3ced1b9 100644
---- a/drivers/md/raid10.c
-+++ b/drivers/md/raid10.c
-@@ -18,7 +18,7 @@
-  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-  */
- 
--#include "dm-bio-list.h"
-+#include <linux/bio-list.h>
- #include <linux/raid/raid10.h>
- #include <linux/raid/bitmap.h>
- 
 diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
 index ef57f25..a122624 100644
 --- a/drivers/scsi/hosts.c
@@ -444,83 +280,6 @@
  		return bio;
  
  	/*
-diff --git a/include/linux/bio-list.h b/include/linux/bio-list.h
-new file mode 100644
-index 0000000..4653516
---- /dev/null
-+++ b/include/linux/bio-list.h
-@@ -0,0 +1,71 @@
-+/*
-+ * Copyright (C) 2004 Red Hat UK Ltd.
-+ *
-+ * This file is released under the GPL.
-+ */
-+
-+#ifndef _BIO_LIST_H
-+#define _BIO_LIST_H
-+
-+#include <linux/bio.h>
-+
-+struct bio_list {
-+	struct bio *head;
-+	struct bio *tail;
-+};
-+
-+static inline void bio_list_init(struct bio_list *bl)
-+{
-+	bl->head = bl->tail = NULL;
-+}
-+
-+static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
-+{
-+	bio->bi_next = NULL;
-+
-+	if (bl->tail)
-+		bl->tail->bi_next = bio;
-+	else
-+		bl->head = bio;
-+
-+	bl->tail = bio;
-+}
-+
-+static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
-+{
-+	if (!bl2->head)
-+		return;
-+
-+	if (bl->tail)
-+		bl->tail->bi_next = bl2->head;
-+	else
-+		bl->head = bl2->head;
-+
-+	bl->tail = bl2->tail;
-+}
-+
-+static inline struct bio *bio_list_pop(struct bio_list *bl)
-+{
-+	struct bio *bio = bl->head;
-+
-+	if (bio) {
-+		bl->head = bl->head->bi_next;
-+		if (!bl->head)
-+			bl->tail = NULL;
-+
-+		bio->bi_next = NULL;
-+	}
-+
-+	return bio;
-+}
-+
-+static inline struct bio *bio_list_get(struct bio_list *bl)
-+{
-+	struct bio *bio = bl->head;
-+
-+	bl->head = bl->tail = NULL;
-+
-+	return bio;
-+}
-+
-+#endif
 diff --git a/include/linux/bio.h b/include/linux/bio.h
 index b60ffe3..fc0906c 100644
 --- a/include/linux/bio.h
@@ -541,19 +300,6 @@
  extern void bio_unmap_user(struct bio *);
  extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
  				gfp_t);
-diff --git a/include/linux/if_packet.h b/include/linux/if_packet.h
-index b925585..c66d555 100644
---- a/include/linux/if_packet.h
-+++ b/include/linux/if_packet.h
-@@ -48,7 +48,7 @@ struct tpacket_stats
- 
- struct tpacket_hdr
- {
--	unsigned long	tp_status;
-+	unsigned int	tp_status;
- #define TP_STATUS_KERNEL	0
- #define TP_STATUS_USER		1
- #define TP_STATUS_COPY		2
 diff --git a/include/linux/netlink.h b/include/linux/netlink.h
 index 6a2ccf7..580fb42 100644
 --- a/include/linux/netlink.h
@@ -566,41 +312,11 @@
  
  #define MAX_LINKS 32		
  
-diff --git a/include/linux/raid/md_k.h b/include/linux/raid/md_k.h
-index 617b950..2323360 100644
---- a/include/linux/raid/md_k.h
-+++ b/include/linux/raid/md_k.h
-@@ -15,8 +15,7 @@
- #ifndef _MD_K_H
- #define _MD_K_H
- 
--/* and dm-bio-list.h is not under include/linux because.... ??? */
--#include "../../../drivers/md/dm-bio-list.h"
-+#include <linux/bio-list.h>
- 
- #define	LEVEL_MULTIPATH		(-4)
- #define	LEVEL_LINEAR		(-1)
-diff --git a/include/net/af_packet.h b/include/net/af_packet.h
-new file mode 100644
-index 0000000..5a75e07
---- /dev/null
-+++ b/include/net/af_packet.h
-@@ -0,0 +1,6 @@
-+#ifndef __LINUX_NET_AFPACKET_H
-+#define __LINUX_NET_AFPACKET_H
-+
-+extern struct tpacket_hdr *packet_socket_frame(struct sock *sk);
-+
-+#endif
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..59f0981 100644
+index 1ace1b9..8f64515 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
-@@ -5,9 +5,11 @@
- #include <linux/list.h>
- #include <linux/types.h>
- #include <linux/timer.h>
-+#include <linux/bio-list.h>
+@@ -8,6 +8,7 @@
  
  struct request;
  struct scatterlist;
@@ -608,7 +324,7 @@
  struct scsi_device;
  struct scsi_request;
  
-@@ -84,6 +86,8 @@ struct scsi_cmnd {
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
  	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
  	unsigned bufflen;	/* Size of data buffer */
  	void *buffer;		/* Data buffer */
@@ -617,7 +333,7 @@
  
  	unsigned underflow;	/* Return error if less than
  				   this amount is transferred */
-@@ -147,9 +151,14 @@ struct scsi_cmnd {
+@@ -147,9 +150,14 @@ struct scsi_cmnd {
  #define SCSI_STATE_MLQUEUE         0x100b
  
  
@@ -819,31 +535,3 @@
 +} __attribute__ ((aligned (sizeof(uint64_t))));
 +
 +#endif
-diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
-index 9db7dbd..b5fbd74 100644
---- a/net/packet/af_packet.c
-+++ b/net/packet/af_packet.c
-@@ -562,6 +562,23 @@ drop:
- }
- 
- #ifdef CONFIG_PACKET_MMAP
-+struct tpacket_hdr *packet_socket_frame(struct sock *sk)
-+{
-+	struct packet_sock *po;
-+	struct tpacket_hdr *h;
-+
-+	po = pkt_sk(sk);
-+	spin_lock(&sk->sk_receive_queue.lock);
-+	h = (struct tpacket_hdr *) packet_lookup_frame(po, po->head);
-+	if (h->tp_status)
-+		h = ERR_PTR(-ENOBUFS);
-+	else
-+		po->head = po->head != po->frame_max ? po->head+1 : 0;
-+	spin_unlock(&sk->sk_receive_queue.lock);
-+	return h;
-+}
-+EXPORT_SYMBOL_GPL(packet_socket_frame);
-+
- static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev)
- {
- 	struct sock *sk;



From tomo at berlios.de  Fri Feb 10 08:30:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 10 Feb 2006 08:30:47 +0100
Subject: [Stgt-svn] r286 - branches/use-scsi-ml/kernel
Message-ID: <200602100730.k1A7UlJP016711@sheep.berlios.de>

Author: tomo
Date: 2006-02-10 08:30:33 +0100 (Fri, 10 Feb 2006)
New Revision: 286

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Fix data length handling.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-09 02:12:53 UTC (rev 285)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-10 07:30:33 UTC (rev 286)
@@ -278,7 +278,7 @@
 	if (!cmd->request_buffer)
 		return -ENOMEM;
 
-	cmd->request_bufflen = rq->nr_sectors << 9;
+	cmd->request_bufflen = rq->data_len;
 
 	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
 	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
@@ -303,12 +303,6 @@
 	struct bio *bio;
 	int err;
 
-	/*
-	 * TODO: We need to cheat queue_dma_alignment in
-	 * __bio_map_user_iov.
-	 */
-	len = (len + PAGE_SIZE - 1) & PAGE_MASK;
-
 	while (len > 0) {
 		dprintk("%lx %u\n", (unsigned long) uaddr, len);
 		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
@@ -330,9 +324,10 @@
 		 * already but for really large IO we may want to try and
 		 * merge these.
 		 */
-		if (!rq->bio)
+		if (!rq->bio) {
 			blk_rq_bio_prep(q, rq, bio);
-		else
+			rq->data_len = bio->bi_size;
+		} else
 			/* put list of bios to transfer in next go around */
 			bio_list_add(&tcmd->xfer_list, bio);
 	}
@@ -392,6 +387,7 @@
 	BUG_ON(!bio);
 
 	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
+	cmd->request->data_len = bio->bi_size;
 	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
 	if (err) {
 		cmd->result = DID_ERROR << 16;



From tomo at berlios.de  Fri Feb 10 08:32:58 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 10 Feb 2006 08:32:58 +0100
Subject: [Stgt-svn] r287 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602100732.k1A7Ww3b017206@sheep.berlios.de>

Author: tomo
Date: 2006-02-10 08:32:04 +0100 (Fri, 10 Feb 2006)
New Revision: 287

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Fix SEND commands bugs.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-10 07:30:33 UTC (rev 286)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-10 07:32:04 UTC (rev 287)
@@ -412,7 +412,7 @@
 		return 0;
 	}
 
-	rest = min(scmd->bufflen, md->length);
+	rest = min(scmd->request_bufflen, md->length);
 
 	for (i = 0, done = 0; i < nsg && rest; i++) {
 		token = sg_dma_address(sg + i);
@@ -492,7 +492,7 @@
 
 	sidx = soff = 0;
 	token = sg_dma_address(sg + sidx);
-	rest = min(scmd->bufflen, id->total_length);
+	rest = min(scmd->request_bufflen, id->total_length);
 	for (i = 0; i < nmd && rest; i++) {
 		unsigned int mdone, mlen;
 
@@ -585,11 +585,15 @@
 	return err;
 }
 
+/* TODO: this can be called multiple times for a single command. */
 static int recv_cmd_data(struct scsi_cmnd *scmd,
 			 void (*done)(struct scsi_cmnd *))
 {
-	/* TODO: this can be called multiple times for a single command. */
-	handle_cmd_data(scmd, RECV);
+	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
+	int rw;
+
+	rw = test_bit(V_WRITE, &iue->req.flags) ? RECV : SEND;
+	handle_cmd_data(scmd, rw);
 	done(scmd);
 	return 0;
 }
@@ -631,7 +635,6 @@
 static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
 			     void (*done)(struct scsi_cmnd *))
 {
-	int sent = 0;
 	unsigned long flags;
 	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
@@ -646,44 +649,11 @@
 		eprintk("operation failed %p %d %x\n",
 			iue, scmd->result, vio_iu(iue)->srp.cmd.cdb[0]);
 		send_rsp(iue, HARDWARE_ERROR, 0x00);
-		goto out;
-	}
-
-	/* FIXME */
-	switch (vio_iu(iue)->srp.cmd.cdb[0]) {
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_12:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	case WRITE_VERIFY_12:
-	case START_STOP:
-	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
-	case VERIFY:
-	case VERIFY_16:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-		send_rsp(iue, NO_SENSE, 0x00);
-		goto out;
-	default:
-		break;
-	}
-
-	sent = handle_cmd_data(scmd, SEND);
-	if (sent != scmd->bufflen) {
-		eprintk("sending data on response %p (tried %u, sent %d\n",
-			iue, scmd->bufflen, sent);
-		send_rsp(iue, ABORTED_COMMAND, 0x00);
 	} else
 		send_rsp(iue, NO_SENSE, 0x00);
 
-out:
 	done(scmd);
 	put_iu(iue);
-
 	return 0;
 }
 



From tomo at berlios.de  Fri Feb 10 08:37:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 10 Feb 2006 08:37:33 +0100
Subject: [Stgt-svn] r288 - branches/use-scsi-ml/kernel
Message-ID: <200602100737.k1A7bXWl019045@sheep.berlios.de>

Author: tomo
Date: 2006-02-10 08:37:29 +0100 (Fri, 10 Feb 2006)
New Revision: 288

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Update the kernel patch.

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-10 07:32:04 UTC (rev 287)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-10 07:37:29 UTC (rev 288)
@@ -228,10 +228,23 @@
  void scsi_free_queue(struct request_queue *q)
  {
 diff --git a/fs/bio.c b/fs/bio.c
-index 1f3bb50..fd1e419 100644
+index 1f3bb50..3e940c9 100644
 --- a/fs/bio.c
 +++ b/fs/bio.c
-@@ -719,19 +719,21 @@ static struct bio *__bio_map_user_iov(re
+@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+@@ -719,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
   *	@uaddr: start of user address
   *	@len: length in bytes
   *	@write_to_vm: bool indicating writing to pages or not
@@ -255,7 +268,7 @@
  }
  
  /**
-@@ -741,13 +743,14 @@ struct bio *bio_map_user(request_queue_t
+@@ -741,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
   *	@iov:	the iovec.
   *	@iov_count: number of elements in the iovec
   *	@write_to_vm: bool indicating writing to pages or not
@@ -271,7 +284,7 @@
  {
  	struct bio *bio;
  	int len = 0, i;
-@@ -768,7 +771,7 @@ struct bio *bio_map_user_iov(request_que
+@@ -768,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
  	for (i = 0; i < iov_count; i++)
  		len += iov[i].iov_len;
  



From tomo at berlios.de  Fri Feb 10 08:38:34 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 10 Feb 2006 08:38:34 +0100
Subject: [Stgt-svn] r289 - branches/use-scsi-ml
Message-ID: <200602100738.k1A7cYFo019300@sheep.berlios.de>

Author: tomo
Date: 2006-02-10 08:38:17 +0100 (Fri, 10 Feb 2006)
New Revision: 289

Modified:
   branches/use-scsi-ml/initd
Log:
Fix initd.

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-02-10 07:37:29 UTC (rev 288)
+++ branches/use-scsi-ml/initd	2006-02-10 07:38:17 UTC (rev 289)
@@ -15,7 +15,7 @@
 {
 	insmod ${PWD}/kernel/scsi_tgt_core.ko
 
-	if [ $TARGET = "istgt" ] ; then
+	if [ "$TARGET" = "istgt" ] ; then
 		modprobe -q crc32c
 		insmod ${PWD}/istgt/kernel/istgt.ko
 	else
@@ -26,7 +26,7 @@
 
 	sleep 1
 
-	if [ $TARGET = "istgt" ] ; then
+	if [ "$TARGET" = "istgt" ] ; then
 		echo "Start istgt"    
 #		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 #		${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
@@ -40,7 +40,7 @@
 	
 stop_server()
 {
-	if [ $TARGET = "istgt" ] ; then
+	if [ "$TARGET" = "istgt" ] ; then
 		${PWD}/usr/tgtadm --driver istgt --op delete
 	else
 		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
@@ -50,7 +50,7 @@
 
 	sleep 1
 
-	if [ $TARGET = "istgt" ] ; then
+	if [ "$TARGET" = "istgt" ] ; then
 		rmmod istgt
 	else
 		rmmod ibmvstgt



From tomo at berlios.de  Fri Feb 10 12:51:32 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 10 Feb 2006 12:51:32 +0100
Subject: [Stgt-svn] r290 - in branches/use-scsi-ml: . patchset
Message-ID: <200602101151.k1ABpWiK029153@sheep.berlios.de>

Author: tomo
Date: 2006-02-10 12:51:29 +0100 (Fri, 10 Feb 2006)
New Revision: 290

Added:
   branches/use-scsi-ml/patchset/
   branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
   branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
Log:
Add patcheset will be submitted to scsi-ml shortly. It would be better split the 4th patch (scsi_tgt.h and scsi_tgt_if.h, and the rest).


Added: branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,27 @@
+Subject: [PATCH] block layer: kill length alignment test in bin_map_user
+
+---
+
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+de7a82b3681434b79baae0f2636d20bb1c4e004f
+diff --git a/fs/bio.c b/fs/bio.c
+index 1f3bb50..d8259d9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,108 @@
+Subject: [PATCH] Add partial mappings support to bio_map_use
+
+---
+
+ block/ll_rw_blk.c   |    5 +++--
+ fs/bio.c            |   11 +++++++----
+ include/linux/bio.h |    5 +++--
+ 3 files changed, 13 insertions(+), 8 deletions(-)
+
+717736911a4e68d224e377d5d6b529c7a358336e
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index f9fc07e..65c56b6 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	 */
+ 	uaddr = (unsigned long) ubuf;
+ 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
+-		bio = bio_map_user(q, NULL, uaddr, len, reading);
++		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	/* we don't allow misaligned data like bio_map_user() does.  If the
+ 	 * user is using sg, they're expected to know the alignment constraints
+ 	 * and respect them accordingly */
+-	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
++	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
++				0);
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
+diff --git a/fs/bio.c b/fs/bio.c
+index d8259d9..3e940c9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -718,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
+  *	@uaddr: start of user address
+  *	@len: length in bytes
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
+-			 unsigned long uaddr, unsigned int len, int write_to_vm)
++			 unsigned long uaddr, unsigned int len, int write_to_vm,
++			 int support_partial)
+ {
+ 	struct sg_iovec iov;
+ 
+ 	iov.iov_base = (void __user *)uaddr;
+ 	iov.iov_len = len;
+ 
+-	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
++	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
+ }
+ 
+ /**
+@@ -740,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
+  *	@iov:	the iovec.
+  *	@iov_count: number of elements in the iovec
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
+ 			     struct sg_iovec *iov, int iov_count,
+-			     int write_to_vm)
++			     int write_to_vm, int support_partial)
+ {
+ 	struct bio *bio;
+ 	int len = 0, i;
+@@ -767,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
+ 	for (i = 0; i < iov_count; i++)
+ 		len += iov[i].iov_len;
+ 
+-	if (bio->bi_size == len)
++	if (bio->bi_size == len || support_partial)
+ 		return bio;
+ 
+ 	/*
+diff --git a/include/linux/bio.h b/include/linux/bio.h
+index b60ffe3..fc0906c 100644
+--- a/include/linux/bio.h
++++ b/include/linux/bio.h
+@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
+ extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
+ 			   unsigned int, unsigned int);
+ extern int bio_get_nr_vecs(struct block_device *);
++extern int __bio_get_nr_vecs(struct request_queue *);
+ extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
+-				unsigned long, unsigned int, int);
++				unsigned long, unsigned int, int, int);
+ struct sg_iovec;
+ extern struct bio *bio_map_user_iov(struct request_queue *,
+ 				    struct block_device *,
+-				    struct sg_iovec *, int, int);
++				    struct sg_iovec *, int, int, int);
+ extern void bio_unmap_user(struct bio *);
+ extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
+ 				gfp_t);
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,328 @@
+Subject: [PATCH] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+---
+
+ drivers/scsi/hosts.c     |    5 +++
+ drivers/scsi/scsi.c      |   91 ++++++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++-----
+ include/scsi/scsi_cmnd.h |    8 ++++
+ include/scsi/scsi_host.h |   40 ++++++++++++++++++++
+ 5 files changed, 168 insertions(+), 9 deletions(-)
+
+c8d4fed9e1642f3fcfeb18cdde52aaaadabc55fd
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index ef57f25..a122624 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
+ 
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index d182bad..701973e 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
+ }
+ 
+ /*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto put_dev;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
+  * Function:	scsi_get_command()
+  *
+  * Purpose:	Allocate and setup a scsi command block
+@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+ /*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock(&shost->free_list_lock);
++
++	spin_lock(q->queue_lock);
++	if (blk_rq_tagged(rq))
++		blk_queue_end_tag(q, rq);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(&shost->shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++/*
+  * Function:	scsi_put_command()
+  *
+  * Purpose:	Free a scsi command block
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 5ac8749..2dcc500 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 1ace1b9..8f64515 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
+ 
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -147,9 +150,14 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
+ extern void scsi_put_command(struct scsi_cmnd *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8279929..8b799db 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,36 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -572,6 +603,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,985 @@
+Subject: [PATCH] scsi tgt core functions
+
+---
+
+ drivers/scsi/Kconfig         |    7 +
+ drivers/scsi/Makefile        |    3 
+ drivers/scsi/scsi_tgt_if.c   |  214 +++++++++++++++++
+ drivers/scsi/scsi_tgt_lib.c  |  540 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   25 ++
+ include/linux/netlink.h      |    1 
+ include/scsi/scsi_tgt.h      |   11 +
+ include/scsi/scsi_tgt_if.h   |   92 +++++++
+ 8 files changed, 893 insertions(+), 0 deletions(-)
+ create mode 100644 drivers/scsi/scsi_tgt_if.c
+ create mode 100644 drivers/scsi/scsi_tgt_lib.c
+ create mode 100644 drivers/scsi/scsi_tgt_priv.h
+ create mode 100644 include/scsi/scsi_tgt.h
+ create mode 100644 include/scsi/scsi_tgt_if.h
+
+f8f0430d4d268391f61d32745efbd464d861a37a
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 3c606cf..d09c792 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate "SCSI target support"
++	depends on SCSI && EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool "legacy /proc/scsi/ support"
+ 	depends on SCSI && PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index 320e765..3d81b8d 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -155,6 +156,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..38b35da
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,214 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/file.h>
++#include <linux/netlink.h>
++#include <net/tcp.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/scsi_tgt_if.h>
++
++#include "scsi_tgt_priv.h"
++
++static int tgtd_pid;
++static struct sock *nl_sk;
++
++static int send_event_res(uint16_t type, struct tgt_event *p,
++			  void *data, int dlen, gfp_t flags, pid_t pid)
++{
++	struct tgt_event *ev;
++	struct nlmsghdr *nlh;
++	struct sk_buff *skb;
++	uint32_t len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + dlen);
++	skb = alloc_skb(len, flags);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	memcpy(ev, p, sizeof(*ev));
++	if (dlen)
++		memcpy(ev->data, data, dlen);
++
++	return netlink_unicast(nl_sk, skb, pid, 0);
++}
++
++int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct sk_buff *skb;
++	struct nlmsghdr *nlh;
++	struct tgt_event *ev;
++	struct tgt_cmd *tcmd;
++	int err, len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
++	/*
++	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
++	 */
++	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
++			  len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	ev->k.cmd_req.host_no = shost->host_no;
++	ev->k.cmd_req.cid = cmd->request->tag;
++	ev->k.cmd_req.data_len = cmd->request_bufflen;
++
++	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
++		ev->k.cmd_req.data_len);
++
++	/* FIXME: we need scsi core to do that. */
++	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
++
++	tcmd = (struct tgt_cmd *) ev->data;
++	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
++	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
++
++	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
++	if (err < 0)
++		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
++		       err);
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	char dummy[sizeof(struct tgt_cmd)];
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost->host_no;
++	ev.k.cmd_done.cid = cmd->request->tag;
++	ev.k.cmd_done.result = cmd->result;
++
++	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
++			      gfp_mask, tgtd_pid);
++}
++
++static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++{
++	struct tgt_event *ev = NLMSG_DATA(nlh);
++	int err = 0;
++
++	dprintk("%d %d %d\n", nlh->nlmsg_type,
++		nlh->nlmsg_pid, current->pid);
++
++	switch (nlh->nlmsg_type) {
++	case TGT_UEVENT_TGTD_BIND:
++		tgtd_pid = NETLINK_CREDS(skb)->pid;
++		break;
++	case TGT_UEVENT_CMD_RES:
++		/* TODO: handle multiple cmds in one event */
++		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
++					   ev->u.cmd_res.cid,
++					   ev->u.cmd_res.result,
++					   ev->u.cmd_res.len,
++					   ev->u.cmd_res.offset,
++					   ev->u.cmd_res.uaddr,
++					   ev->u.cmd_res.rw,
++					   ev->u.cmd_res.try_map);
++		break;
++	default:
++		eprintk("unknown type %d\n", nlh->nlmsg_type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static int event_recv_skb(struct sk_buff *skb)
++{
++	int err;
++	uint32_t rlen;
++	struct nlmsghdr	*nlh;
++
++	while (skb->len >= NLMSG_SPACE(0)) {
++		nlh = (struct nlmsghdr *) skb->data;
++		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
++			return 0;
++		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
++		if (rlen > skb->len)
++			rlen = skb->len;
++		err = event_recv_msg(skb, nlh);
++
++		dprintk("%d %d\n", nlh->nlmsg_type, err);
++		/*
++		 * TODO for passthru commands the lower level should
++		 * probably handle the result or we should modify this
++		 */
++		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
++			struct tgt_event ev;
++
++			memset(&ev, 0, sizeof(ev));
++			ev.k.event_res.err = err;
++			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
++				       GFP_KERNEL | __GFP_NOFAIL,
++					nlh->nlmsg_pid);
++		}
++		skb_pull(skb, rlen);
++	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (NETLINK_CREDS(skb)->uid) {
++			skb_pull(skb, skb->len);
++			kfree_skb(skb);
++			continue;
++		}
++
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
++}
++
++void __exit scsi_tgt_if_exit(void)
++{
++	sock_release(nl_sk->sk_socket);
++}
++
++int __init scsi_tgt_if_init(void)
++{
++	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
++				    THIS_MODULE);
++	if (!nl_sk)
++		return -ENOMEM;
++
++	return 0;
++}
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..64fd3d7
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,540 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/elevator.h>
++#include <linux/module.h>
++#include <linux/pagemap.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <../drivers/md/dm-bio-list.h>
++
++#include "scsi_tgt_priv.h"
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++	struct scsi_lun *lun;
++};
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p\n", cmd);
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
++{
++	tcmd->lun = rq->end_io_data;
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++}
++
++static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
++{
++	struct scsi_tgt_cmd *tcmd;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		return BLKPREP_DEFER;
++
++	init_scsi_tgt_cmd(rq, tcmd);
++	rq->end_io_data = tcmd;
++	rq->flags |= REQ_DONTPREP;
++	return BLKPREP_OK;
++}
++
++static void scsi_uspace_request_fn(struct request_queue *q)
++{
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/*
++	 * TODO: just send everthing in the queue to userspace in
++	 * one vector instead of multiple calls
++	 */
++	while ((rq = elv_next_request(q)) != NULL) {
++		cmd = rq->special;
++		tcmd = rq->end_io_data;
++
++		/* the completion code kicks us in case we hit this */
++		if (blk_queue_start_tag(q, rq))
++			break;
++
++		spin_unlock_irq(q->queue_lock);
++		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
++			goto requeue;
++		spin_lock_irq(q->queue_lock);
++	}
++
++	return;
++requeue:
++	spin_lock_irq(q->queue_lock);
++	/* need to track cnts and plug */
++	blk_requeue_request(q, rq);
++	spin_lock_irq(q->queue_lock);
++}
++
++/**
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ **/
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata->shost = shost;
++	q->queuedata = queuedata;
++
++	elevator_exit(q->elevator);
++	err = elevator_init(q, "noop");
++	if (err)
++		goto free_data;
++
++	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q->nr_requests = shost->hostt->can_queue;
++	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost->uspace_req_q = q;
++
++	return 0;
++
++free_data:
++	kfree(queuedata);
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
++	return queue->shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/**
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @noblock:	set to nonzero if the command should be queued
++ **/
++void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			    int noblock)
++{
++	/*
++	 * For now this just calls the request_fn from this context.
++	 * For HW llds though we do not want to execute from here so
++	 * the elevator code needs something like a REQ_TGT_CMD or
++	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
++	 */
++	cmd->request->end_io_data = scsilun;
++	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p\n", cmd);
++
++	/* don't we have to call this if result is set or not */
++	if (cmd->result) {
++		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++		return;
++	}
++
++	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &tcmd->work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk("cmd %p\n", cmd);
++
++	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd->result = DID_BUS_BUSY << 16;
++	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd->request;
++	int count;
++
++	cmd->use_sg = rq->nr_phys_segments;
++	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd->request_buffer)
++		return -ENOMEM;
++
++	cmd->request_bufflen = rq->data_len;
++
++	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
++	if (likely(count <= cmd->use_sg)) {
++		cmd->use_sg = count;
++		return 0;
++	}
++
++	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd->request->q;
++	struct request *rq = cmd->request;
++	void *uaddr = cmd->buffer;
++	unsigned int len = cmd->bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len > 0) {
++		dprintk("%lx %u\n", (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk("fail to map %lx %u\n",
++				(unsigned long) uaddr, len);
++			goto unmap_bios;
++		}
++
++		uaddr += bio->bi_size;
++		len -= bio->bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq->bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq->data_len = bio->bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&tcmd->xfer_list, bio);
++	}
++
++	cmd->offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq->bio) {
++		bio_unmap_user(rq->bio);
++		while ((bio = bio_list_pop(&tcmd->xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd->result) {
++send_uspace_err:
++		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++		return;
++	}
++
++	dprintk("cmd %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
++
++	cmd->buffer += cmd->request_bufflen;
++	cmd->offset += cmd->request_bufflen;
++
++	if (!tcmd->xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	bio = bio_list_pop(&tcmd->xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
++	cmd->request->data_len = bio->bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd->result = DID_ERROR << 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd->result = DID_NO_CONNECT << 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd->sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR "Could not copy the sense buffer\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
++			 unsigned long uaddr, u8 rw, u8 try_map)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	int err = 0;
++
++	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
++		len, (unsigned long long) offset, uaddr, rw, try_map);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++
++	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
++	if (!rq) {
++		printk(KERN_ERR "Could not find cid %u\n", cid);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq->special;
++
++	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
++		result, len, cmd->request_bufflen);
++
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	cmd->buffer = (void *)uaddr;
++	if (len)
++		cmd->bufflen = len;
++	cmd->result = result;
++
++	if (!cmd->bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
++	if (err) {
++		eprintk("%p %d\n", cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd->result) {
++		if (status_byte(cmd->result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue("scsi_tgtd");
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION("SCSI target core");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..4236e50
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,25 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define dprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define eprintk dprintk
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++};
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
++				u64 offset, unsigned long uaddr, u8 rw,
++				u8 try_map);
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 6a2ccf7..580fb42 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..91ad6bc
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,11 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..04be52d
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,92 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_TGTD_BIND,
++	TGT_UEVENT_TARGET_SETUP,
++	TGT_UEVENT_CMD_RES,
++
++	/* kernel -> user */
++	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int pk_fd;
++		} tgtd_bind;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint64_t offset;
++			uint8_t rw;
++			uint8_t try_map;
++		} cmd_res;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_res;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint64_t dev_id;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++	} k;
++
++	/*
++	 * I think a pointer is a unsigned long but this struct
++	 * gets passed around from the kernel to userspace and
++	 * back again so to handle some ppc64 setups where userspace is
++	 * 32 bits but the kernel is 64 we do this odd thing
++	 */
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#ifndef __KERNEL__
++#define MAX_COMMAND_SIZE	16
++#endif
++
++struct tgt_cmd {
++	uint8_t scb[MAX_COMMAND_SIZE];
++	uint8_t lun[8];
++	int tags;
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif
+-- 
+1.1.3



From tomo at berlios.de  Mon Feb 13 10:42:19 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Feb 2006 10:42:19 +0100
Subject: [Stgt-svn] r291 - branches/use-scsi-ml/patchset
Message-ID: <200602130942.k1D9gJFX007895@sheep.berlios.de>

Author: tomo
Date: 2006-02-13 10:42:19 +0100 (Mon, 13 Feb 2006)
New Revision: 291

Added:
   branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
   branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
   branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
   branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
Removed:
   branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
   branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
Log:
Replace the old patchset with new one.

Deleted: branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -1,27 +0,0 @@
-Subject: [PATCH] block layer: kill length alignment test in bin_map_user
-
----
-
- fs/bio.c |    5 ++---
- 1 files changed, 2 insertions(+), 3 deletions(-)
-
-de7a82b3681434b79baae0f2636d20bb1c4e004f
-diff --git a/fs/bio.c b/fs/bio.c
-index 1f3bb50..d8259d9 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,328 @@
+Subject: [PATCH] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+---
+
+ drivers/scsi/hosts.c     |    5 +++
+ drivers/scsi/scsi.c      |   91 ++++++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++-----
+ include/scsi/scsi_cmnd.h |    8 ++++
+ include/scsi/scsi_host.h |   40 ++++++++++++++++++++
+ 5 files changed, 168 insertions(+), 9 deletions(-)
+
+4ab7d1a25185748e2aaf86b30784c280bbf5de2b
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index ef57f25..a122624 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
+ 
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index d182bad..701973e 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
+ }
+ 
+ /*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto put_dev;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
+  * Function:	scsi_get_command()
+  *
+  * Purpose:	Allocate and setup a scsi command block
+@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+ /*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock(&shost->free_list_lock);
++
++	spin_lock(q->queue_lock);
++	if (blk_rq_tagged(rq))
++		blk_queue_end_tag(q, rq);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(&shost->shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++/*
+  * Function:	scsi_put_command()
+  *
+  * Purpose:	Free a scsi command block
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 5ac8749..2dcc500 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 1ace1b9..8f64515 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
+ 
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -147,9 +150,14 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
+ extern void scsi_put_command(struct scsi_cmnd *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8279929..8b799db 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,36 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -572,6 +603,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.1.3

Deleted: branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -1,108 +0,0 @@
-Subject: [PATCH] Add partial mappings support to bio_map_use
-
----
-
- block/ll_rw_blk.c   |    5 +++--
- fs/bio.c            |   11 +++++++----
- include/linux/bio.h |    5 +++--
- 3 files changed, 13 insertions(+), 8 deletions(-)
-
-717736911a4e68d224e377d5d6b529c7a358336e
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index f9fc07e..65c56b6 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
- 	 */
- 	uaddr = (unsigned long) ubuf;
- 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
--		bio = bio_map_user(q, NULL, uaddr, len, reading);
-+		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
-@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
- 	/* we don't allow misaligned data like bio_map_user() does.  If the
- 	 * user is using sg, they're expected to know the alignment constraints
- 	 * and respect them accordingly */
--	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
-+	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
-+				0);
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-diff --git a/fs/bio.c b/fs/bio.c
-index d8259d9..3e940c9 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -718,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
-  *	@uaddr: start of user address
-  *	@len: length in bytes
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
--			 unsigned long uaddr, unsigned int len, int write_to_vm)
-+			 unsigned long uaddr, unsigned int len, int write_to_vm,
-+			 int support_partial)
- {
- 	struct sg_iovec iov;
- 
- 	iov.iov_base = (void __user *)uaddr;
- 	iov.iov_len = len;
- 
--	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
-+	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
- }
- 
- /**
-@@ -740,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
-  *	@iov:	the iovec.
-  *	@iov_count: number of elements in the iovec
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
- 			     struct sg_iovec *iov, int iov_count,
--			     int write_to_vm)
-+			     int write_to_vm, int support_partial)
- {
- 	struct bio *bio;
- 	int len = 0, i;
-@@ -767,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
- 	for (i = 0; i < iov_count; i++)
- 		len += iov[i].iov_len;
- 
--	if (bio->bi_size == len)
-+	if (bio->bi_size == len || support_partial)
- 		return bio;
- 
- 	/*
-diff --git a/include/linux/bio.h b/include/linux/bio.h
-index b60ffe3..fc0906c 100644
---- a/include/linux/bio.h
-+++ b/include/linux/bio.h
-@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
- extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
- 			   unsigned int, unsigned int);
- extern int bio_get_nr_vecs(struct block_device *);
-+extern int __bio_get_nr_vecs(struct request_queue *);
- extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
--				unsigned long, unsigned int, int);
-+				unsigned long, unsigned int, int, int);
- struct sg_iovec;
- extern struct bio *bio_map_user_iov(struct request_queue *,
- 				    struct block_device *,
--				    struct sg_iovec *, int, int);
-+				    struct sg_iovec *, int, int, int);
- extern void bio_unmap_user(struct bio *);
- extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
- 				gfp_t);
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,27 @@
+Subject: [PATCH] block layer: kill length alignment test in bin_map_user
+
+---
+
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+8e515bd33c31c8dc5e9727792d2c3cbe08bc28e1
+diff --git a/fs/bio.c b/fs/bio.c
+index 1f3bb50..d8259d9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,108 @@
+Subject: [PATCH] block layer: add partial mappings support to bio_map_user
+
+---
+
+ block/ll_rw_blk.c   |    5 +++--
+ fs/bio.c            |   11 +++++++----
+ include/linux/bio.h |    5 +++--
+ 3 files changed, 13 insertions(+), 8 deletions(-)
+
+97fbe8e42375284c82814b95cde3bc18c00721cd
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index f9fc07e..65c56b6 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	 */
+ 	uaddr = (unsigned long) ubuf;
+ 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
+-		bio = bio_map_user(q, NULL, uaddr, len, reading);
++		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	/* we don't allow misaligned data like bio_map_user() does.  If the
+ 	 * user is using sg, they're expected to know the alignment constraints
+ 	 * and respect them accordingly */
+-	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
++	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
++				0);
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
+diff --git a/fs/bio.c b/fs/bio.c
+index 1f3bb50..fd1e419 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -719,19 +719,21 @@ static struct bio *__bio_map_user_iov(re
+  *	@uaddr: start of user address
+  *	@len: length in bytes
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
+-			 unsigned long uaddr, unsigned int len, int write_to_vm)
++			 unsigned long uaddr, unsigned int len, int write_to_vm,
++			 int support_partial)
+ {
+ 	struct sg_iovec iov;
+ 
+ 	iov.iov_base = (void __user *)uaddr;
+ 	iov.iov_len = len;
+ 
+-	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
++	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
+ }
+ 
+ /**
+@@ -741,13 +743,14 @@ struct bio *bio_map_user(request_queue_t
+  *	@iov:	the iovec.
+  *	@iov_count: number of elements in the iovec
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
+ 			     struct sg_iovec *iov, int iov_count,
+-			     int write_to_vm)
++			     int write_to_vm, int support_partial)
+ {
+ 	struct bio *bio;
+ 	int len = 0, i;
+@@ -768,7 +771,7 @@ struct bio *bio_map_user_iov(request_que
+ 	for (i = 0; i < iov_count; i++)
+ 		len += iov[i].iov_len;
+ 
+-	if (bio->bi_size == len)
++	if (bio->bi_size == len || support_partial)
+ 		return bio;
+ 
+ 	/*
+diff --git a/include/linux/bio.h b/include/linux/bio.h
+index b60ffe3..fc0906c 100644
+--- a/include/linux/bio.h
++++ b/include/linux/bio.h
+@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
+ extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
+ 			   unsigned int, unsigned int);
+ extern int bio_get_nr_vecs(struct block_device *);
++extern int __bio_get_nr_vecs(struct request_queue *);
+ extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
+-				unsigned long, unsigned int, int);
++				unsigned long, unsigned int, int, int);
+ struct sg_iovec;
+ extern struct bio *bio_map_user_iov(struct request_queue *,
+ 				    struct block_device *,
+-				    struct sg_iovec *, int, int);
++				    struct sg_iovec *, int, int, int);
+ extern void bio_unmap_user(struct bio *);
+ extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
+ 				gfp_t);
+-- 
+1.1.3

Deleted: branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -1,328 +0,0 @@
-Subject: [PATCH] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
-
----
-
- drivers/scsi/hosts.c     |    5 +++
- drivers/scsi/scsi.c      |   91 ++++++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_lib.c  |   33 ++++++++++++-----
- include/scsi/scsi_cmnd.h |    8 ++++
- include/scsi/scsi_host.h |   40 ++++++++++++++++++++
- 5 files changed, 168 insertions(+), 9 deletions(-)
-
-c8d4fed9e1642f3fcfeb18cdde52aaaadabc55fd
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index ef57f25..a122624 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
- 
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
-+
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
- 
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index d182bad..701973e 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
- }
- 
- /*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto put_dev;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-  * Function:	scsi_get_command()
-  *
-  * Purpose:	Allocate and setup a scsi command block
-@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
- EXPORT_SYMBOL(scsi_get_command);
- 
- /*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock(&shost->free_list_lock);
-+
-+	spin_lock(q->queue_lock);
-+	if (blk_rq_tagged(rq))
-+		blk_queue_end_tag(q, rq);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(&shost->shost_gendev);
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+
-+/*
-  * Function:	scsi_put_command()
-  *
-  * Purpose:	Free a scsi command block
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 5ac8749..2dcc500 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..8f64515 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- struct scsi_request;
- 
-@@ -84,6 +85,8 @@ struct scsi_cmnd {
- 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
- 	unsigned bufflen;	/* Size of data buffer */
- 	void *buffer;		/* Data buffer */
-+	/* offset in cmd we are at (for multi-transfer tgt cmds) */
-+	unsigned offset;
- 
- 	unsigned underflow;	/* Return error if less than
- 				   this amount is transferred */
-@@ -147,9 +150,14 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
- extern void scsi_put_command(struct scsi_cmnd *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
- 
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index 8279929..8b799db 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -123,6 +124,36 @@ struct scsi_host_template {
- 			     void (*done)(struct scsi_cmnd *));
- 
- 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
- 	 * routine that is present that should work in most cases.  For those
-@@ -572,6 +603,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					     void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,22 @@
+Subject: [PATCH] netlink: add a new netlink number for stgt
+
+---
+
+ include/linux/netlink.h |    1 +
+ 1 files changed, 1 insertions(+), 0 deletions(-)
+
+4ef87917cc44f07d389dfdd189b4f926335fb7ba
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 6a2ccf7..580fb42 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+-- 
+1.1.3

Deleted: branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -1,985 +0,0 @@
-Subject: [PATCH] scsi tgt core functions
-
----
-
- drivers/scsi/Kconfig         |    7 +
- drivers/scsi/Makefile        |    3 
- drivers/scsi/scsi_tgt_if.c   |  214 +++++++++++++++++
- drivers/scsi/scsi_tgt_lib.c  |  540 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   25 ++
- include/linux/netlink.h      |    1 
- include/scsi/scsi_tgt.h      |   11 +
- include/scsi/scsi_tgt_if.h   |   92 +++++++
- 8 files changed, 893 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/scsi_tgt_if.c
- create mode 100644 drivers/scsi/scsi_tgt_lib.c
- create mode 100644 drivers/scsi/scsi_tgt_priv.h
- create mode 100644 include/scsi/scsi_tgt.h
- create mode 100644 include/scsi/scsi_tgt_if.h
-
-f8f0430d4d268391f61d32745efbd464d861a37a
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 3c606cf..d09c792 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -27,6 +27,13 @@ config SCSI
- 	  However, do not compile this as a module if your root file system
- 	  (the one containing the directory /) is located on a SCSI device.
- 
-+config SCSI_TGT
-+	tristate "SCSI target support"
-+	depends on SCSI && EXPERIMENTAL
-+	---help---
-+	  If you want to use SCSI target mode drivers enable this option.
-+	  If you choose M, the module will be called scsi_tgt.
-+
- config SCSI_PROC_FS
- 	bool "legacy /proc/scsi/ support"
- 	depends on SCSI && PROC_FS
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index 320e765..3d81b8d 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
- subdir-$(CONFIG_PCMCIA)		+= pcmcia
- 
- obj-$(CONFIG_SCSI)		+= scsi_mod.o
-+obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
- 
- obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
- 
-@@ -155,6 +156,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
- scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
- scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
- 
-+scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
-+
- sd_mod-objs	:= sd.o
- sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
- ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-new file mode 100644
-index 0000000..38b35da
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,214 @@
-+/*
-+ * SCSI target kernel/user interface functions
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/file.h>
-+#include <linux/netlink.h>
-+#include <net/tcp.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/scsi_tgt_if.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static int tgtd_pid;
-+static struct sock *nl_sk;
-+
-+static int send_event_res(uint16_t type, struct tgt_event *p,
-+			  void *data, int dlen, gfp_t flags, pid_t pid)
-+{
-+	struct tgt_event *ev;
-+	struct nlmsghdr *nlh;
-+	struct sk_buff *skb;
-+	uint32_t len;
-+
-+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-+	skb = alloc_skb(len, flags);
-+	if (!skb)
-+		return -ENOMEM;
-+
-+	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+
-+	ev = NLMSG_DATA(nlh);
-+	memcpy(ev, p, sizeof(*ev));
-+	if (dlen)
-+		memcpy(ev->data, data, dlen);
-+
-+	return netlink_unicast(nl_sk, skb, pid, 0);
-+}
-+
-+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct sk_buff *skb;
-+	struct nlmsghdr *nlh;
-+	struct tgt_event *ev;
-+	struct tgt_cmd *tcmd;
-+	int err, len;
-+
-+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
-+	/*
-+	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
-+	 */
-+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-+	if (!skb)
-+		return -ENOMEM;
-+
-+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
-+			  len - sizeof(*nlh), 0);
-+
-+	ev = NLMSG_DATA(nlh);
-+	ev->k.cmd_req.host_no = shost->host_no;
-+	ev->k.cmd_req.cid = cmd->request->tag;
-+	ev->k.cmd_req.data_len = cmd->request_bufflen;
-+
-+	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
-+		ev->k.cmd_req.data_len);
-+
-+	/* FIXME: we need scsi core to do that. */
-+	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-+
-+	tcmd = (struct tgt_cmd *) ev->data;
-+	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
-+	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
-+
-+	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
-+	if (err < 0)
-+		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
-+		       err);
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	char dummy[sizeof(struct tgt_cmd)];
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_done.host_no = shost->host_no;
-+	ev.k.cmd_done.cid = cmd->request->tag;
-+	ev.k.cmd_done.result = cmd->result;
-+
-+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-+			      gfp_mask, tgtd_pid);
-+}
-+
-+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+{
-+	struct tgt_event *ev = NLMSG_DATA(nlh);
-+	int err = 0;
-+
-+	dprintk("%d %d %d\n", nlh->nlmsg_type,
-+		nlh->nlmsg_pid, current->pid);
-+
-+	switch (nlh->nlmsg_type) {
-+	case TGT_UEVENT_TGTD_BIND:
-+		tgtd_pid = NETLINK_CREDS(skb)->pid;
-+		break;
-+	case TGT_UEVENT_CMD_RES:
-+		/* TODO: handle multiple cmds in one event */
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
-+					   ev->u.cmd_res.cid,
-+					   ev->u.cmd_res.result,
-+					   ev->u.cmd_res.len,
-+					   ev->u.cmd_res.offset,
-+					   ev->u.cmd_res.uaddr,
-+					   ev->u.cmd_res.rw,
-+					   ev->u.cmd_res.try_map);
-+		break;
-+	default:
-+		eprintk("unknown type %d\n", nlh->nlmsg_type);
-+		err = -EINVAL;
-+	}
-+
-+	return err;
-+}
-+
-+static int event_recv_skb(struct sk_buff *skb)
-+{
-+	int err;
-+	uint32_t rlen;
-+	struct nlmsghdr	*nlh;
-+
-+	while (skb->len >= NLMSG_SPACE(0)) {
-+		nlh = (struct nlmsghdr *) skb->data;
-+		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-+			return 0;
-+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-+		if (rlen > skb->len)
-+			rlen = skb->len;
-+		err = event_recv_msg(skb, nlh);
-+
-+		dprintk("%d %d\n", nlh->nlmsg_type, err);
-+		/*
-+		 * TODO for passthru commands the lower level should
-+		 * probably handle the result or we should modify this
-+		 */
-+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
-+			struct tgt_event ev;
-+
-+			memset(&ev, 0, sizeof(ev));
-+			ev.k.event_res.err = err;
-+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-+				       GFP_KERNEL | __GFP_NOFAIL,
-+					nlh->nlmsg_pid);
-+		}
-+		skb_pull(skb, rlen);
-+	}
-+	return 0;
-+}
-+
-+static void event_recv(struct sock *sk, int length)
-+{
-+	struct sk_buff *skb;
-+
-+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-+		if (NETLINK_CREDS(skb)->uid) {
-+			skb_pull(skb, skb->len);
-+			kfree_skb(skb);
-+			continue;
-+		}
-+
-+		if (event_recv_skb(skb) && skb->len)
-+			skb_queue_head(&sk->sk_receive_queue, skb);
-+		else
-+			kfree_skb(skb);
-+	}
-+}
-+
-+void __exit scsi_tgt_if_exit(void)
-+{
-+	sock_release(nl_sk->sk_socket);
-+}
-+
-+int __init scsi_tgt_if_init(void)
-+{
-+	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
-+				    THIS_MODULE);
-+	if (!nl_sk)
-+		return -ENOMEM;
-+
-+	return 0;
-+}
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-new file mode 100644
-index 0000000..64fd3d7
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,540 @@
-+/*
-+ * SCSI target lib functions
-+ *
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/elevator.h>
-+#include <linux/module.h>
-+#include <linux/pagemap.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <../drivers/md/dm-bio-list.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static struct workqueue_struct *scsi_tgtd;
-+static kmem_cache_t *scsi_tgt_cmd_cache;
-+
-+/*
-+ * TODO: this struct will be killed when the block layer supports large bios
-+ * and James's work struct code is in
-+ */
-+struct scsi_tgt_cmd {
-+	/* TODO replace work with James b's code */
-+	struct work_struct work;
-+	/* TODO replace the lists with a large bio */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
-+	struct scsi_lun *lun;
-+};
-+
-+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-+{
-+	struct bio *bio;
-+
-+	/* must call bio_endio in case bio was bounced */
-+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+
-+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+}
-+
-+static void scsi_tgt_cmd_destroy(void *data)
-+{
-+	struct scsi_cmnd *cmd = data;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p\n", cmd);
-+
-+	scsi_unmap_user_pages(tcmd);
-+	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-+}
-+
-+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
-+{
-+	tcmd->lun = rq->end_io_data;
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+}
-+
-+static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
-+{
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		return BLKPREP_DEFER;
-+
-+	init_scsi_tgt_cmd(rq, tcmd);
-+	rq->end_io_data = tcmd;
-+	rq->flags |= REQ_DONTPREP;
-+	return BLKPREP_OK;
-+}
-+
-+static void scsi_uspace_request_fn(struct request_queue *q)
-+{
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/*
-+	 * TODO: just send everthing in the queue to userspace in
-+	 * one vector instead of multiple calls
-+	 */
-+	while ((rq = elv_next_request(q)) != NULL) {
-+		cmd = rq->special;
-+		tcmd = rq->end_io_data;
-+
-+		/* the completion code kicks us in case we hit this */
-+		if (blk_queue_start_tag(q, rq))
-+			break;
-+
-+		spin_unlock_irq(q->queue_lock);
-+		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
-+			goto requeue;
-+		spin_lock_irq(q->queue_lock);
-+	}
-+
-+	return;
-+requeue:
-+	spin_lock_irq(q->queue_lock);
-+	/* need to track cnts and plug */
-+	blk_requeue_request(q, rq);
-+	spin_lock_irq(q->queue_lock);
-+}
-+
-+/**
-+ * scsi_tgt_alloc_queue - setup queue used for message passing
-+ * shost: scsi host
-+ *
-+ * This should be called by the LLD after host allocation.
-+ * And will be released when the host is released.
-+ **/
-+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-+{
-+	struct scsi_tgt_queuedata *queuedata;
-+	struct request_queue *q;
-+	int err;
-+
-+	/*
-+	 * Do we need to send a netlink event or should uspace
-+	 * just respond to the hotplug event?
-+	 */
-+	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
-+	if (!q)
-+		return -ENOMEM;
-+
-+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-+	if (!queuedata) {
-+		err = -ENOMEM;
-+		goto cleanup_queue;
-+	}
-+	queuedata->shost = shost;
-+	q->queuedata = queuedata;
-+
-+	elevator_exit(q->elevator);
-+	err = elevator_init(q, "noop");
-+	if (err)
-+		goto free_data;
-+
-+	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
-+	/*
-+	 * this is a silly hack. We should probably just queue as many
-+	 * command as is recvd to userspace. uspace can then make
-+	 * sure we do not overload the HBA
-+	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
-+	/*
-+	 * We currently only support software LLDs so this does
-+	 * not matter for now. Do we need this for the cards we support?
-+	 * If so we should make it a host template value.
-+	 */
-+	blk_queue_dma_alignment(q, 0);
-+	shost->uspace_req_q = q;
-+
-+	return 0;
-+
-+free_data:
-+	kfree(queuedata);
-+cleanup_queue:
-+	blk_cleanup_queue(q);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-+
-+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-+	return queue->shost;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-+
-+/**
-+ * scsi_tgt_queue_command - queue command for userspace processing
-+ * @cmd:	scsi command
-+ * @scsilun:	scsi lun
-+ * @noblock:	set to nonzero if the command should be queued
-+ **/
-+void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			    int noblock)
-+{
-+	/*
-+	 * For now this just calls the request_fn from this context.
-+	 * For HW llds though we do not want to execute from here so
-+	 * the elevator code needs something like a REQ_TGT_CMD or
-+	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
-+	 */
-+	cmd->request->end_io_data = scsilun;
-+	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-+
-+/*
-+ * This is run from a interrpt handler normally and the unmap
-+ * needs process context so we must queue
-+ */
-+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p\n", cmd);
-+
-+	/* don't we have to call this if result is set or not */
-+	if (cmd->result) {
-+		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+		return;
-+	}
-+
-+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-+	queue_work(scsi_tgtd, &tcmd->work);
-+}
-+
-+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	int err;
-+
-+	dprintk("cmd %p\n", cmd);
-+
-+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-+	switch (err) {
-+	case SCSI_MLQUEUE_HOST_BUSY:
-+	case SCSI_MLQUEUE_DEVICE_BUSY:
-+		return -EAGAIN;
-+	}
-+
-+	return 0;
-+}
-+
-+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = __scsi_tgt_transfer_response(cmd);
-+	if (!err)
-+		return;
-+
-+	cmd->result = DID_BUS_BUSY << 16;
-+	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+		/* the eh will have to pick this up */
-+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+}
-+
-+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct request *rq = cmd->request;
-+	int count;
-+
-+	cmd->use_sg = rq->nr_phys_segments;
-+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-+	if (!cmd->request_buffer)
-+		return -ENOMEM;
-+
-+	cmd->request_bufflen = rq->data_len;
-+
-+	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
-+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-+	if (likely(count <= cmd->use_sg)) {
-+		cmd->use_sg = count;
-+		return 0;
-+	}
-+
-+	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	return -EINVAL;
-+}
-+
-+/* TODO: test this crap and replace bio_map_user with new interface maybe */
-+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-+			       int rw)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct request *rq = cmd->request;
-+	void *uaddr = cmd->buffer;
-+	unsigned int len = cmd->bufflen;
-+	struct bio *bio;
-+	int err;
-+
-+	while (len > 0) {
-+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
-+		if (IS_ERR(bio)) {
-+			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u\n",
-+				(unsigned long) uaddr, len);
-+			goto unmap_bios;
-+		}
-+
-+		uaddr += bio->bi_size;
-+		len -= bio->bi_size;
-+
-+		/*
-+		 * The first bio is added and merged. We could probably
-+		 * try to add others using scsi_merge_bio() but for now
-+		 * we keep it simple. The first bio should be pretty large
-+		 * (either hitting the 1 MB bio pages limit or a queue limit)
-+		 * already but for really large IO we may want to try and
-+		 * merge these.
-+		 */
-+		if (!rq->bio) {
-+			blk_rq_bio_prep(q, rq, bio);
-+			rq->data_len = bio->bi_size;
-+		} else
-+			/* put list of bios to transfer in next go around */
-+			bio_list_add(&tcmd->xfer_list, bio);
-+	}
-+
-+	cmd->offset = 0;
-+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-+	if (err)
-+		goto unmap_bios;
-+
-+	return 0;
-+
-+unmap_bios:
-+	if (rq->bio) {
-+		bio_unmap_user(rq->bio);
-+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-+			bio_unmap_user(bio);
-+	}
-+
-+	return err;
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-+
-+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	struct bio *bio;
-+	int err;
-+
-+	/* should we free resources here on error ? */
-+	if (cmd->result) {
-+send_uspace_err:
-+		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+			/* the tgt uspace eh will have to pick this up */
-+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, cmd->bufflen);
-+
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-+
-+	cmd->buffer += cmd->request_bufflen;
-+	cmd->offset += cmd->request_bufflen;
-+
-+	if (!tcmd->xfer_list.head) {
-+		scsi_tgt_transfer_response(cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, cmd->bufflen);
-+
-+	bio = bio_list_pop(&tcmd->xfer_list);
-+	BUG_ON(!bio);
-+
-+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-+	cmd->request->data_len = bio->bi_size;
-+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-+	if (err) {
-+		cmd->result = DID_ERROR << 16;
-+		goto send_uspace_err;
-+	}
-+
-+	if (scsi_tgt_transfer_data(cmd)) {
-+		cmd->result = DID_NO_CONNECT << 16;
-+		goto send_uspace_err;
-+	}
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-+
-+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-+	switch (err) {
-+		case SCSI_MLQUEUE_HOST_BUSY:
-+		case SCSI_MLQUEUE_DEVICE_BUSY:
-+			return -EAGAIN;
-+	default:
-+		return 0;
-+	}
-+}
-+
-+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-+				unsigned len)
-+{
-+	char __user *p = (char __user *) uaddr;
-+
-+	if (copy_from_user(cmd->sense_buffer, p,
-+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-+		printk(KERN_ERR "Could not copy the sense buffer\n");
-+		return -EIO;
-+	}
-+	return 0;
-+}
-+
-+int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
-+			 unsigned long uaddr, u8 rw, u8 try_map)
-+{
-+	struct Scsi_Host *shost;
-+	struct scsi_cmnd *cmd;
-+	struct request *rq;
-+	int err = 0;
-+
-+	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
-+		len, (unsigned long long) offset, uaddr, rw, try_map);
-+
-+	/* TODO: replace with a O(1) alg */
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+
-+	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
-+	if (!rq) {
-+		printk(KERN_ERR "Could not find cid %u\n", cid);
-+		err = -EINVAL;
-+		goto done;
-+	}
-+	cmd = rq->special;
-+
-+	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
-+		result, len, cmd->request_bufflen);
-+
-+	/*
-+	 * store the userspace values here, the working values are
-+	 * in the request_* values
-+	 */
-+	cmd->buffer = (void *)uaddr;
-+	if (len)
-+		cmd->bufflen = len;
-+	cmd->result = result;
-+
-+	if (!cmd->bufflen) {
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+
-+	/*
-+	 * TODO: Do we need to handle case where request does not
-+	 * align with LLD.
-+	 */
-+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-+	if (err) {
-+		eprintk("%p %d\n", cmd, err);
-+		err = -EAGAIN;
-+		goto done;
-+	}
-+
-+	/* userspace failure */
-+	if (cmd->result) {
-+		if (status_byte(cmd->result) == CHECK_CONDITION)
-+			scsi_tgt_copy_sense(cmd, uaddr, len);
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+	/* ask the target LLD to transfer the data to the buffer */
-+	err = scsi_tgt_transfer_data(cmd);
-+
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+static int __init scsi_tgt_init(void)
-+{
-+	int err;
-+
-+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-+					       sizeof(struct scsi_tgt_cmd),
-+					       0, 0, NULL, NULL);
-+	if (!scsi_tgt_cmd_cache)
-+		return -ENOMEM;
-+
-+	scsi_tgtd = create_workqueue("scsi_tgtd");
-+	if (!scsi_tgtd) {
-+		err = -ENOMEM;
-+		goto free_kmemcache;
-+	}
-+
-+	err = scsi_tgt_if_init();
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(scsi_tgtd);
-+free_kmemcache:
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+	return err;
-+}
-+
-+static void __exit scsi_tgt_exit(void)
-+{
-+	destroy_workqueue(scsi_tgtd);
-+	scsi_tgt_if_exit();
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+}
-+
-+module_init(scsi_tgt_init);
-+module_exit(scsi_tgt_exit);
-+
-+MODULE_DESCRIPTION("SCSI target core");
-+MODULE_LICENSE("GPL");
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-new file mode 100644
-index 0000000..4236e50
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,25 @@
-+struct scsi_cmnd;
-+struct scsi_lun;
-+struct Scsi_Host;
-+struct task_struct;
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define dprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+
-+#define eprintk dprintk
-+
-+struct scsi_tgt_queuedata {
-+	struct Scsi_Host *shost;
-+};
-+
-+extern void scsi_tgt_if_exit(void);
-+extern int scsi_tgt_if_init(void);
-+
-+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-+				u64 offset, unsigned long uaddr, u8 rw,
-+				u8 try_map);
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 6a2ccf7..580fb42 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,6 +21,7 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
-+#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..91ad6bc
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,11 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..04be52d
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,92 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_TGTD_BIND,
-+	TGT_UEVENT_TARGET_SETUP,
-+	TGT_UEVENT_CMD_RES,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_RESPONSE,
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+};
-+
-+struct tgt_event {
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int pk_fd;
-+		} tgtd_bind;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint64_t offset;
-+			uint8_t rw;
-+			uint8_t try_map;
-+		} cmd_res;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int err;
-+		} event_res;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t data_len;
-+			uint64_t dev_id;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			int result;
-+		} cmd_done;
-+	} k;
-+
-+	/*
-+	 * I think a pointer is a unsigned long but this struct
-+	 * gets passed around from the kernel to userspace and
-+	 * back again so to handle some ppc64 setups where userspace is
-+	 * 32 bits but the kernel is 64 we do this odd thing
-+	 */
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#ifndef __KERNEL__
-+#define MAX_COMMAND_SIZE	16
-+#endif
-+
-+struct tgt_cmd {
-+	uint8_t scb[MAX_COMMAND_SIZE];
-+	uint8_t lun[8];
-+	int tags;
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#endif
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,812 @@
+Subject: [PATCH] scsi tgt core functions
+
+---
+
+ drivers/scsi/scsi_tgt_if.c   |  214 +++++++++++++++++
+ drivers/scsi/scsi_tgt_lib.c  |  540 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   25 ++
+ 3 files changed, 779 insertions(+), 0 deletions(-)
+ create mode 100644 drivers/scsi/scsi_tgt_if.c
+ create mode 100644 drivers/scsi/scsi_tgt_lib.c
+ create mode 100644 drivers/scsi/scsi_tgt_priv.h
+
+78f36da6a49c874dcbde755b98ba128356f69275
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..38b35da
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,214 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/file.h>
++#include <linux/netlink.h>
++#include <net/tcp.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/scsi_tgt_if.h>
++
++#include "scsi_tgt_priv.h"
++
++static int tgtd_pid;
++static struct sock *nl_sk;
++
++static int send_event_res(uint16_t type, struct tgt_event *p,
++			  void *data, int dlen, gfp_t flags, pid_t pid)
++{
++	struct tgt_event *ev;
++	struct nlmsghdr *nlh;
++	struct sk_buff *skb;
++	uint32_t len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + dlen);
++	skb = alloc_skb(len, flags);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	memcpy(ev, p, sizeof(*ev));
++	if (dlen)
++		memcpy(ev->data, data, dlen);
++
++	return netlink_unicast(nl_sk, skb, pid, 0);
++}
++
++int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct sk_buff *skb;
++	struct nlmsghdr *nlh;
++	struct tgt_event *ev;
++	struct tgt_cmd *tcmd;
++	int err, len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
++	/*
++	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
++	 */
++	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
++			  len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	ev->k.cmd_req.host_no = shost->host_no;
++	ev->k.cmd_req.cid = cmd->request->tag;
++	ev->k.cmd_req.data_len = cmd->request_bufflen;
++
++	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
++		ev->k.cmd_req.data_len);
++
++	/* FIXME: we need scsi core to do that. */
++	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
++
++	tcmd = (struct tgt_cmd *) ev->data;
++	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
++	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
++
++	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
++	if (err < 0)
++		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
++		       err);
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	char dummy[sizeof(struct tgt_cmd)];
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost->host_no;
++	ev.k.cmd_done.cid = cmd->request->tag;
++	ev.k.cmd_done.result = cmd->result;
++
++	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
++			      gfp_mask, tgtd_pid);
++}
++
++static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++{
++	struct tgt_event *ev = NLMSG_DATA(nlh);
++	int err = 0;
++
++	dprintk("%d %d %d\n", nlh->nlmsg_type,
++		nlh->nlmsg_pid, current->pid);
++
++	switch (nlh->nlmsg_type) {
++	case TGT_UEVENT_TGTD_BIND:
++		tgtd_pid = NETLINK_CREDS(skb)->pid;
++		break;
++	case TGT_UEVENT_CMD_RES:
++		/* TODO: handle multiple cmds in one event */
++		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
++					   ev->u.cmd_res.cid,
++					   ev->u.cmd_res.result,
++					   ev->u.cmd_res.len,
++					   ev->u.cmd_res.offset,
++					   ev->u.cmd_res.uaddr,
++					   ev->u.cmd_res.rw,
++					   ev->u.cmd_res.try_map);
++		break;
++	default:
++		eprintk("unknown type %d\n", nlh->nlmsg_type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static int event_recv_skb(struct sk_buff *skb)
++{
++	int err;
++	uint32_t rlen;
++	struct nlmsghdr	*nlh;
++
++	while (skb->len >= NLMSG_SPACE(0)) {
++		nlh = (struct nlmsghdr *) skb->data;
++		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
++			return 0;
++		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
++		if (rlen > skb->len)
++			rlen = skb->len;
++		err = event_recv_msg(skb, nlh);
++
++		dprintk("%d %d\n", nlh->nlmsg_type, err);
++		/*
++		 * TODO for passthru commands the lower level should
++		 * probably handle the result or we should modify this
++		 */
++		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
++			struct tgt_event ev;
++
++			memset(&ev, 0, sizeof(ev));
++			ev.k.event_res.err = err;
++			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
++				       GFP_KERNEL | __GFP_NOFAIL,
++					nlh->nlmsg_pid);
++		}
++		skb_pull(skb, rlen);
++	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (NETLINK_CREDS(skb)->uid) {
++			skb_pull(skb, skb->len);
++			kfree_skb(skb);
++			continue;
++		}
++
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
++}
++
++void __exit scsi_tgt_if_exit(void)
++{
++	sock_release(nl_sk->sk_socket);
++}
++
++int __init scsi_tgt_if_init(void)
++{
++	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
++				    THIS_MODULE);
++	if (!nl_sk)
++		return -ENOMEM;
++
++	return 0;
++}
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..64fd3d7
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,540 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/elevator.h>
++#include <linux/module.h>
++#include <linux/pagemap.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <../drivers/md/dm-bio-list.h>
++
++#include "scsi_tgt_priv.h"
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++	struct scsi_lun *lun;
++};
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p\n", cmd);
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
++{
++	tcmd->lun = rq->end_io_data;
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++}
++
++static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
++{
++	struct scsi_tgt_cmd *tcmd;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		return BLKPREP_DEFER;
++
++	init_scsi_tgt_cmd(rq, tcmd);
++	rq->end_io_data = tcmd;
++	rq->flags |= REQ_DONTPREP;
++	return BLKPREP_OK;
++}
++
++static void scsi_uspace_request_fn(struct request_queue *q)
++{
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/*
++	 * TODO: just send everthing in the queue to userspace in
++	 * one vector instead of multiple calls
++	 */
++	while ((rq = elv_next_request(q)) != NULL) {
++		cmd = rq->special;
++		tcmd = rq->end_io_data;
++
++		/* the completion code kicks us in case we hit this */
++		if (blk_queue_start_tag(q, rq))
++			break;
++
++		spin_unlock_irq(q->queue_lock);
++		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
++			goto requeue;
++		spin_lock_irq(q->queue_lock);
++	}
++
++	return;
++requeue:
++	spin_lock_irq(q->queue_lock);
++	/* need to track cnts and plug */
++	blk_requeue_request(q, rq);
++	spin_lock_irq(q->queue_lock);
++}
++
++/**
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ **/
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata->shost = shost;
++	q->queuedata = queuedata;
++
++	elevator_exit(q->elevator);
++	err = elevator_init(q, "noop");
++	if (err)
++		goto free_data;
++
++	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q->nr_requests = shost->hostt->can_queue;
++	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost->uspace_req_q = q;
++
++	return 0;
++
++free_data:
++	kfree(queuedata);
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
++	return queue->shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/**
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @noblock:	set to nonzero if the command should be queued
++ **/
++void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			    int noblock)
++{
++	/*
++	 * For now this just calls the request_fn from this context.
++	 * For HW llds though we do not want to execute from here so
++	 * the elevator code needs something like a REQ_TGT_CMD or
++	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
++	 */
++	cmd->request->end_io_data = scsilun;
++	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p\n", cmd);
++
++	/* don't we have to call this if result is set or not */
++	if (cmd->result) {
++		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++		return;
++	}
++
++	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &tcmd->work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk("cmd %p\n", cmd);
++
++	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd->result = DID_BUS_BUSY << 16;
++	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd->request;
++	int count;
++
++	cmd->use_sg = rq->nr_phys_segments;
++	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd->request_buffer)
++		return -ENOMEM;
++
++	cmd->request_bufflen = rq->data_len;
++
++	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
++	if (likely(count <= cmd->use_sg)) {
++		cmd->use_sg = count;
++		return 0;
++	}
++
++	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd->request->q;
++	struct request *rq = cmd->request;
++	void *uaddr = cmd->buffer;
++	unsigned int len = cmd->bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len > 0) {
++		dprintk("%lx %u\n", (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk("fail to map %lx %u\n",
++				(unsigned long) uaddr, len);
++			goto unmap_bios;
++		}
++
++		uaddr += bio->bi_size;
++		len -= bio->bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq->bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq->data_len = bio->bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&tcmd->xfer_list, bio);
++	}
++
++	cmd->offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq->bio) {
++		bio_unmap_user(rq->bio);
++		while ((bio = bio_list_pop(&tcmd->xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd->result) {
++send_uspace_err:
++		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++		return;
++	}
++
++	dprintk("cmd %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
++
++	cmd->buffer += cmd->request_bufflen;
++	cmd->offset += cmd->request_bufflen;
++
++	if (!tcmd->xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	bio = bio_list_pop(&tcmd->xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
++	cmd->request->data_len = bio->bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd->result = DID_ERROR << 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd->result = DID_NO_CONNECT << 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd->sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR "Could not copy the sense buffer\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
++			 unsigned long uaddr, u8 rw, u8 try_map)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	int err = 0;
++
++	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
++		len, (unsigned long long) offset, uaddr, rw, try_map);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++
++	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
++	if (!rq) {
++		printk(KERN_ERR "Could not find cid %u\n", cid);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq->special;
++
++	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
++		result, len, cmd->request_bufflen);
++
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	cmd->buffer = (void *)uaddr;
++	if (len)
++		cmd->bufflen = len;
++	cmd->result = result;
++
++	if (!cmd->bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
++	if (err) {
++		eprintk("%p %d\n", cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd->result) {
++		if (status_byte(cmd->result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue("scsi_tgtd");
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION("SCSI target core");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..4236e50
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,25 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define dprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define eprintk dprintk
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++};
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
++				u64 offset, unsigned long uaddr, u8 rw,
++				u8 try_map);
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,50 @@
+Subject: [PATCH] scsi-ml: Makefile and Kconfig changes for stgt
+
+---
+
+ drivers/scsi/Kconfig  |    7 +++++++
+ drivers/scsi/Makefile |    3 +++
+ 2 files changed, 10 insertions(+), 0 deletions(-)
+
+22ae7de0990701d140759af4a9b7070bf4409414
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 3c606cf..d09c792 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate "SCSI target support"
++	depends on SCSI && EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool "legacy /proc/scsi/ support"
+ 	depends on SCSI && PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index 320e765..3d81b8d 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -155,6 +156,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
===================================================================
--- branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-10 11:51:29 UTC (rev 290)
+++ branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-13 09:42:19 UTC (rev 291)
@@ -0,0 +1,128 @@
+Subject: [PATCH] scsi-ml: add public stgt include files
+
+---
+
+ include/scsi/scsi_tgt.h    |   11 +++++
+ include/scsi/scsi_tgt_if.h |   92 ++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 103 insertions(+), 0 deletions(-)
+ create mode 100644 include/scsi/scsi_tgt.h
+ create mode 100644 include/scsi/scsi_tgt_if.h
+
+22f986c1620d598163ec3a97eb42972dbf225601
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..91ad6bc
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,11 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..04be52d
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,92 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_TGTD_BIND,
++	TGT_UEVENT_TARGET_SETUP,
++	TGT_UEVENT_CMD_RES,
++
++	/* kernel -> user */
++	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int pk_fd;
++		} tgtd_bind;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint64_t offset;
++			uint8_t rw;
++			uint8_t try_map;
++		} cmd_res;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_res;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint64_t dev_id;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++	} k;
++
++	/*
++	 * I think a pointer is a unsigned long but this struct
++	 * gets passed around from the kernel to userspace and
++	 * back again so to handle some ppc64 setups where userspace is
++	 * 32 bits but the kernel is 64 we do this odd thing
++	 */
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#ifndef __KERNEL__
++#define MAX_COMMAND_SIZE	16
++#endif
++
++struct tgt_cmd {
++	uint8_t scb[MAX_COMMAND_SIZE];
++	uint8_t lun[8];
++	int tags;
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif
+-- 
+1.1.3



From tomo at berlios.de  Mon Feb 13 23:42:35 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Feb 2006 23:42:35 +0100
Subject: [Stgt-svn] r292 - branches/use-scsi-ml/usr
Message-ID: <200602132242.k1DMgZTg015103@sheep.berlios.de>

Author: tomo
Date: 2006-02-13 23:42:34 +0100 (Mon, 13 Feb 2006)
New Revision: 292

Modified:
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtadm.c
   branches/use-scsi-ml/usr/tgtd.c
Log:
Clean up license in user-space code.


Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-02-13 09:42:19 UTC (rev 291)
+++ branches/use-scsi-ml/usr/dl.c	2006-02-13 22:42:34 UTC (rev 292)
@@ -1,12 +1,24 @@
 /*
- * LLD dynamic library
+ * SCSI target dynamic library
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
  *
- * This code is licenced under the GPL.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
 #include <string.h>
 #include <fcntl.h>
 #include <dlfcn.h>

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-02-13 09:42:19 UTC (rev 291)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-02-13 22:42:34 UTC (rev 292)
@@ -1,11 +1,24 @@
 /*
  * SCSI target management functions
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-13 09:42:19 UTC (rev 291)
+++ branches/use-scsi-ml/usr/target.c	2006-02-13 22:42:34 UTC (rev 292)
@@ -1,11 +1,24 @@
 /*
- * SCSI target daemon
+ * SCSI target daemon core functions
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-02-13 09:42:19 UTC (rev 291)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-02-13 22:42:34 UTC (rev 292)
@@ -1,16 +1,24 @@
 /*
- * tgtadm - manage Target Framework software.
+ * SCSI target daemon management interface
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
-/*
- * This is just taken from ietadm. Possibly, we need to redesign the
- * greater part of this to handle every target driver.
- */
-
 #include <ctype.h>
 #include <dirent.h>
 #include <dlfcn.h>

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-02-13 09:42:19 UTC (rev 291)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-02-13 22:42:34 UTC (rev 292)
@@ -1,11 +1,24 @@
 /*
- * SCSI target user-space daemon
+ * SCSI target daemon
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
-
 #include <errno.h>
 #include <fcntl.h>
 #include <getopt.h>



From tomo at berlios.de  Tue Feb 14 07:17:41 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 07:17:41 +0100
Subject: [Stgt-svn] r293 - branches/use-scsi-ml/kernel
Message-ID: <200602140617.k1E6Hf4I024066@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 07:17:30 +0100 (Tue, 14 Feb 2006)
New Revision: 293

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
bio_map_user() and blk_rq_bio_prep() ruined rq->flags. As a result, freed_request() breaks q.rq.count[]. We must set rq->flags by hand before calling scsi_host_put_command().


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-13 22:42:34 UTC (rev 292)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-14 06:17:30 UTC (rev 293)
@@ -69,7 +69,16 @@
 	struct scsi_cmnd *cmd = data;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 
-	dprintk("cmd %p\n", cmd);
+	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
+		rq_data_dir(cmd->request));
+	/*
+	 * We must set rq->flags here because bio_map_user and
+	 * blk_rq_bio_prep ruined ti.
+	 */
+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
+		cmd->request->flags |= 1;
+	else
+		cmd->request->flags &= ~1UL;
 
 	scsi_unmap_user_pages(tcmd);
 	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
@@ -206,6 +215,11 @@
 void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
 			    int noblock)
 {
+	struct request_queue *q = cmd->request->q;
+	struct request_list *rl = &q->rq;
+	dprintk("%d %d %lu\n", rl->count[0], rl->count[1],
+		rq_data_dir(cmd->request));
+
 	/*
 	 * For now this just calls the request_fn from this context.
 	 * For HW llds though we do not want to execute from here so
@@ -225,7 +239,7 @@
 {
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 
-	dprintk("cmd %p\n", cmd);
+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 
 	/* don't we have to call this if result is set or not */
 	if (cmd->result) {
@@ -242,7 +256,7 @@
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	int err;
 
-	dprintk("cmd %p\n", cmd);
+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 
 	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
 	switch (err) {
@@ -280,7 +294,8 @@
 
 	cmd->request_bufflen = rq->data_len;
 
-	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, cmd->buffer, cmd->use_sg,
+		rq_data_dir(rq));
 	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
 	if (likely(count <= cmd->use_sg)) {
 		cmd->use_sg = count;
@@ -454,8 +469,8 @@
 	}
 	cmd = rq->special;
 
-	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
-		result, len, cmd->request_bufflen);
+	dprintk("cmd %p result %d len %d bufflen %u %lu\n", cmd,
+		result, len, cmd->request_bufflen, rq_data_dir(rq));
 
 	/*
 	 * store the userspace values here, the working values are



From tomo at berlios.de  Tue Feb 14 08:26:04 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 08:26:04 +0100
Subject: [Stgt-svn] r294 - branches/use-scsi-ml/usr
Message-ID: <200602140726.k1E7Q44c009749@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 08:25:50 +0100 (Tue, 14 Feb 2006)
New Revision: 294

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Seems that mmap caching code has some bugs. So disable it.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-14 06:17:30 UTC (rev 293)
+++ branches/use-scsi-ml/usr/target.c	2006-02-14 07:25:50 UTC (rev 294)
@@ -96,7 +96,7 @@
 	if (dev_id < target->max_device || dev_id < MAX_NR_DEVICE)
 		return target->devt[dev_id];
 
-	eprintf("Invalid device id %" PRIu64 "%d\n", dev_id, MAX_NR_DEVICE);
+	dprintf("Invalid device id %" PRIu64 "%d\n", dev_id, MAX_NR_DEVICE);
 	return NULL;
 }
 
@@ -123,13 +123,14 @@
 
 static uint64_t try_mmap_device(int fd, uint64_t size)
 {
-	void *p;
+/* 	void *p; */
 
-	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (p == MAP_FAILED)
-		return 0;
-	else
-		return (unsigned long) p;
+/* 	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); */
+/* 	if (p == MAP_FAILED) */
+/* 		return 0; */
+/* 	else */
+/* 		return (unsigned long) p; */
+	return 0;
 }
 
 static int device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size)



From tomo at berlios.de  Tue Feb 14 08:27:59 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 08:27:59 +0100
Subject: [Stgt-svn] r295 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602140727.k1E7Rxg5009916@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 08:27:51 +0100 (Tue, 14 Feb 2006)
New Revision: 295

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Create own workqueue instead of using kblockd.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-14 07:25:50 UTC (rev 294)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-14 07:27:51 UTC (rev 295)
@@ -136,6 +136,7 @@
 };
 
 
+static struct workqueue_struct *vtgtd;
 static kmem_cache_t *iu_cache;
 
 /*
@@ -362,11 +363,17 @@
 	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
 	BUG_ON(!scmd);
 
+	dprintk("%p %x %lx %d %d %d\n",
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
+
 	scmd->SCp.ptr = (char *) iue;
 	memcpy(scmd->data_cmnd, iu->srp.cmd.cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = len;
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
 
+	dprintk("%p %x %lx %d %d %d\n",
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
+
 	return 0;
 }
 
@@ -877,7 +884,7 @@
 	struct server_adapter *adapter = (struct server_adapter *)dev_instance;
 
 	vio_disable_interrupts(adapter->dma_dev);
-	kblockd_schedule_work(&adapter->crq_work);
+	queue_work(vtgtd, &adapter->crq_work);
 
 	return IRQ_HANDLED;
 }
@@ -1195,7 +1202,7 @@
 
 static int ibmvstgt_init(void)
 {
-	int err;
+	int err = -ENOMEM;
 	size_t size = sizeof(struct iu_entry) + sizeof(union viosrp_iu);
 
 	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
@@ -1205,18 +1212,24 @@
 				     SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
 				     NULL, NULL);
 	if (!iu_cache)
-		return -ENOMEM;
+		return err;
 
+	vtgtd = create_workqueue("ibmvtgtd");
+	if (!vtgtd)
+		goto free_iu_cache;
+
 	err = get_system_info();
 	if (err < 0)
-		goto free_iu_cache;
+		goto destroy_wq;
 
 	err = vio_register_driver(&ibmvstgt_driver);
 	if (err)
-		goto free_iu_cache;
+		goto destroy_wq;
 
 	return 0;
 
+destroy_wq:
+	destroy_workqueue(vtgtd);
 free_iu_cache:
 	kmem_cache_destroy(iu_cache);
 
@@ -1227,6 +1240,7 @@
 {
 	printk("Unregister IBM virtual SCSI driver\n");
 
+	destroy_workqueue(vtgtd);
 	vio_unregister_driver(&ibmvstgt_driver);
 	kmem_cache_destroy(iu_cache);
 }



From tomo at berlios.de  Tue Feb 14 09:53:30 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 09:53:30 +0100
Subject: [Stgt-svn] r296 - branches/use-scsi-ml/patchset
Message-ID: <200602140853.k1E8rUAG014048@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 09:53:28 +0100 (Tue, 14 Feb 2006)
New Revision: 296

Modified:
   branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
Log:
Update tgt-core patch.

Modified: branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-14 07:27:51 UTC (rev 295)
+++ branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-14 08:53:28 UTC (rev 296)
@@ -2,15 +2,15 @@
 
 ---
 
- drivers/scsi/scsi_tgt_if.c   |  214 +++++++++++++++++
- drivers/scsi/scsi_tgt_lib.c  |  540 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_if.c   |  214 ++++++++++++++++
+ drivers/scsi/scsi_tgt_lib.c  |  551 ++++++++++++++++++++++++++++++++++++++++++
  drivers/scsi/scsi_tgt_priv.h |   25 ++
- 3 files changed, 779 insertions(+), 0 deletions(-)
+ 3 files changed, 790 insertions(+), 0 deletions(-)
  create mode 100644 drivers/scsi/scsi_tgt_if.c
  create mode 100644 drivers/scsi/scsi_tgt_lib.c
  create mode 100644 drivers/scsi/scsi_tgt_priv.h
 
-78f36da6a49c874dcbde755b98ba128356f69275
+0e2ea12891c6e55ae21b8824ca0488342f083f50
 diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
 new file mode 100644
 index 0000000..38b35da
@@ -233,10 +233,10 @@
 +}
 diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
 new file mode 100644
-index 0000000..64fd3d7
+index 0000000..9f50e4e
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,540 @@
+@@ -0,0 +1,551 @@
 +/*
 + * SCSI target lib functions
 + *
@@ -308,7 +308,16 @@
 +	struct scsi_cmnd *cmd = data;
 +	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 +
-+	dprintk("cmd %p\n", cmd);
++	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
++		rq_data_dir(cmd->request));
++	/*
++	 * We must set rq->flags here because bio_map_user and
++	 * blk_rq_bio_prep ruined ti.
++	 */
++	if (cmd->sc_data_direction == DMA_TO_DEVICE)
++		cmd->request->flags |= 1;
++	else
++		cmd->request->flags &= ~1UL;
 +
 +	scsi_unmap_user_pages(tcmd);
 +	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
@@ -464,7 +473,7 @@
 +{
 +	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 +
-+	dprintk("cmd %p\n", cmd);
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 +
 +	/* don't we have to call this if result is set or not */
 +	if (cmd->result) {
@@ -481,7 +490,7 @@
 +	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 +	int err;
 +
-+	dprintk("cmd %p\n", cmd);
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 +
 +	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
 +	switch (err) {
@@ -519,7 +528,8 @@
 +
 +	cmd->request_bufflen = rq->data_len;
 +
-+	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, cmd->buffer, cmd->use_sg,
++		rq_data_dir(rq));
 +	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
 +	if (likely(count <= cmd->use_sg)) {
 +		cmd->use_sg = count;
@@ -547,8 +557,9 @@
 +		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
 +		if (IS_ERR(bio)) {
 +			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u\n",
-+				(unsigned long) uaddr, len);
++			dprintk("fail to map %lx %u %d %x\n",
++				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
++			BUG();
 +			goto unmap_bios;
 +		}
 +
@@ -693,8 +704,8 @@
 +	}
 +	cmd = rq->special;
 +
-+	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
-+		result, len, cmd->request_bufflen);
++	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
++		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
 +
 +	/*
 +	 * store the userspace values here, the working values are



From tomo at berlios.de  Tue Feb 14 09:59:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 09:59:43 +0100
Subject: [Stgt-svn] r297 - branches/use-scsi-ml/kernel
Message-ID: <200602140859.k1E8xhUx018422@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 09:59:41 +0100 (Tue, 14 Feb 2006)
New Revision: 297

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Remove too verbose debug code.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-14 08:53:28 UTC (rev 296)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-14 08:59:41 UTC (rev 297)
@@ -215,11 +215,6 @@
 void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
 			    int noblock)
 {
-	struct request_queue *q = cmd->request->q;
-	struct request_list *rl = &q->rq;
-	dprintk("%d %d %lu\n", rl->count[0], rl->count[1],
-		rq_data_dir(cmd->request));
-
 	/*
 	 * For now this just calls the request_fn from this context.
 	 * For HW llds though we do not want to execute from here so
@@ -323,8 +318,8 @@
 		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
 		if (IS_ERR(bio)) {
 			err = PTR_ERR(bio);
-			dprintk("fail to map %lx %u\n",
-				(unsigned long) uaddr, len);
+			dprintk("fail to map %lx %u %d %x\n",
+				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
 			goto unmap_bios;
 		}
 
@@ -469,8 +464,8 @@
 	}
 	cmd = rq->special;
 
-	dprintk("cmd %p result %d len %d bufflen %u %lu\n", cmd,
-		result, len, cmd->request_bufflen, rq_data_dir(rq));
+	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
+		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
 
 	/*
 	 * store the userspace values here, the working values are



From tomo at berlios.de  Tue Feb 14 10:13:16 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 10:13:16 +0100
Subject: [Stgt-svn] r298 - in branches/use-scsi-ml: . patchset
Message-ID: <200602140913.k1E9DGGq008351@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 10:13:11 +0100 (Tue, 14 Feb 2006)
New Revision: 298

Modified:
   branches/use-scsi-ml/initd
   branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
Log:
Update tgt-core patch again.

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-02-14 08:59:41 UTC (rev 297)
+++ branches/use-scsi-ml/initd	2006-02-14 09:13:11 UTC (rev 298)
@@ -22,7 +22,7 @@
 		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
 	fi
 
-	${PWD}/usr/tgtd -d1
+	${PWD}/usr/tgtd -d0
 
 	sleep 1
 

Modified: branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-14 08:59:41 UTC (rev 297)
+++ branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-14 09:13:11 UTC (rev 298)
@@ -3,14 +3,14 @@
 ---
 
  drivers/scsi/scsi_tgt_if.c   |  214 ++++++++++++++++
- drivers/scsi/scsi_tgt_lib.c  |  551 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_lib.c  |  550 ++++++++++++++++++++++++++++++++++++++++++
  drivers/scsi/scsi_tgt_priv.h |   25 ++
- 3 files changed, 790 insertions(+), 0 deletions(-)
+ 3 files changed, 789 insertions(+), 0 deletions(-)
  create mode 100644 drivers/scsi/scsi_tgt_if.c
  create mode 100644 drivers/scsi/scsi_tgt_lib.c
  create mode 100644 drivers/scsi/scsi_tgt_priv.h
 
-0e2ea12891c6e55ae21b8824ca0488342f083f50
+de47d09f27130e7847b2012f9c8a7a05f32e90c4
 diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
 new file mode 100644
 index 0000000..38b35da
@@ -233,10 +233,10 @@
 +}
 diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
 new file mode 100644
-index 0000000..9f50e4e
+index 0000000..8746236
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,551 @@
+@@ -0,0 +1,550 @@
 +/*
 + * SCSI target lib functions
 + *
@@ -559,7 +559,6 @@
 +			err = PTR_ERR(bio);
 +			dprintk("fail to map %lx %u %d %x\n",
 +				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-+			BUG();
 +			goto unmap_bios;
 +		}
 +



From tomo at berlios.de  Tue Feb 14 14:44:22 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Feb 2006 14:44:22 +0100
Subject: [Stgt-svn] r299 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602141344.k1EDiMFq031402@sheep.berlios.de>

Author: tomo
Date: 2006-02-14 14:44:19 +0100 (Tue, 14 Feb 2006)
New Revision: 299

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Kill adapter->max_sector.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-14 09:13:11 UTC (rev 298)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-14 13:44:19 UTC (rev 299)
@@ -101,7 +101,6 @@
 	unsigned long liobn;
 	unsigned long riobn;
 
-	int max_sectors;
 	struct Scsi_Host *shost;
 };
 
@@ -363,9 +362,6 @@
 	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
 	BUG_ON(!scmd);
 
-	dprintk("%p %x %lx %d %d %d\n",
-		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
-
 	scmd->SCp.ptr = (char *) iue;
 	memcpy(scmd->data_cmnd, iu->srp.cmd.cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = len;
@@ -668,6 +664,7 @@
 		      dma_addr_t remote_buffer, uint16_t length)
 {
 	struct server_adapter *adapter = iue->adapter;
+	struct Scsi_Host *shost = adapter->shost;
 	dma_addr_t data_token;
 	struct mad_adapter_info_data *info;
 	int err;
@@ -696,7 +693,7 @@
 	info->partition_number = partition_number;
 	info->mad_version = 1;
 	info->os_type = 2;
-	info->port_max_txu[0] = adapter->max_sectors << 9;
+	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
 
 	/* Send our info to remote */
 	err = h_copy_rdma(sizeof(*info), adapter->liobn, data_token,
@@ -1102,7 +1099,6 @@
 	adapter->dev = &dev->dev;
 	adapter->dev->driver_data = adapter;
 	adapter->next_rsp_delta = 0;
-	adapter->max_sectors = DEFAULT_MAX_SECTORS;
 	spin_lock_init(&adapter->lock);
 
 	dma = (unsigned int *)



From tomo at berlios.de  Wed Feb 15 08:06:45 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 15 Feb 2006 08:06:45 +0100
Subject: [Stgt-svn] r300 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602150706.k1F76jhq010372@sheep.berlios.de>

Author: tomo
Date: 2006-02-15 08:06:40 +0100 (Wed, 15 Feb 2006)
New Revision: 300

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Add debug code and BUG in TMF.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-14 13:44:19 UTC (rev 299)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-15 07:06:40 UTC (rev 300)
@@ -356,8 +356,9 @@
 		len = vscsis_data_length(&iu->srp.cmd, 0);
 	}
 
-	dprintk("%p %x %lx %d %d %d\n",
-		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
+	dprintk("%p %x %lx %d %d %d %llx\n",
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags,
+		(unsigned long long) iu->srp.cmd.tag);
 
 	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
 	BUG_ON(!scmd);
@@ -367,8 +368,8 @@
 	scmd->request_bufflen = len;
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
 
-	dprintk("%p %x %lx %d %d %d\n",
-		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
+	dprintk("%p %p %x %lx %d %d %d\n",
+		iue, scmd, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
 
 	return 0;
 }
@@ -752,8 +753,38 @@
 
 static void process_abort(struct iu_entry *iue)
 {
+	union viosrp_iu *iu = vio_iu(iue), *tmp_iu = NULL;
+	struct iu_entry *tmp_iue;
 	unsigned char status = ABORTED_COMMAND;
+	uint64_t tag = iu->srp.tsk_mgmt.managed_task_tag;
+	unsigned long flags;
 
+	eprintk("Not supported yet %p %llx\n", iue, (unsigned long long) tag);
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	list_for_each_entry(tmp_iue, &iue->adapter->cmd_queue, ilist) {
+		tmp_iu = vio_iu(tmp_iue);
+		if (tmp_iu->srp.cmd.tag != tag)
+			continue;
+
+		__set_bit(V_ABORTED, &tmp_iue->req.flags);
+		status = NO_SENSE;
+		break;
+	}
+
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	if (status == NO_SENSE) {
+		int len = vscsis_data_length(&tmp_iu->srp.cmd,
+					     tmp_iu->srp.cmd.data_out_format);
+		dprintk("%p %x %lx %d\n",
+			tmp_iue, tmp_iu->srp.cmd.cdb[0], tmp_iu->srp.cmd.lun, len);
+		dprintk("abort successful\n");
+		BUG();
+	} else
+		dprintk("unable to abort cmd\n");
+
 	send_rsp(iue, status, 0x14);
 }
 
@@ -762,8 +793,6 @@
 	union viosrp_iu *iu = vio_iu(iue);
 	uint8_t flags = iu->srp.tsk_mgmt.task_mgmt_flags;
 
-	eprintk("Not supported yet %p %x\n", iue, flags);
-
 	if (flags == 0x01)
 		process_abort(iue);
 	else if (flags == 0x08)



From mnc at berlios.de  Thu Feb 16 09:55:19 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 16 Feb 2006 09:55:19 +0100
Subject: [Stgt-svn] r301 - branches/use-scsi-ml/patchset
Message-ID: <200602160855.k1G8tJiN001610@sheep.berlios.de>

Author: mnc
Date: 2006-02-16 09:55:08 +0100 (Thu, 16 Feb 2006)
New Revision: 301

Modified:
   branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
   branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
   branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
   branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
Log:
add descriptions to patches for sending to linux-scsi

Modified: branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,11 @@
 Subject: [PATCH] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
 
+This patch contains the needed changes to the scsi-ml to support targets.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
 ---
 
  drivers/scsi/hosts.c     |    5 +++

Modified: branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,24 @@
 Subject: [PATCH] block layer: kill length alignment test in bin_map_user
 
+The tgt project is mapping in bios using bio_map_user. The current targets
+do not need their len to be aligned with a queue limit so this check is
+causing some problems.
+
+The major user, blk_bio_map_user checks for the len before mapping
+and is not affected by this patch.
+
+And the semi-newly added user blk_rq_map_user_iov has been failing
+out when the len is not aligned properly so maybe people have been
+good and not sending misaligned lens or that path is not used very
+often and this change will not be very dangerous. st and sg do not
+check the length and we have not seen any problem reports from those
+wider used paths so this patch should be fairly safe - for mm 
+and wider testing at least.
+
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
 ---
 
  fs/bio.c |    5 ++---

Modified: branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,22 @@
 Subject: [PATCH] block layer: add partial mappings support to bio_map_user
 
+For target mode we could end up with the case where we get very large
+request from the initiator. The request could be so large that we
+cannot transfer all the data in one operation. For example the
+HBA's segment or max_sector limits might limit us to a 1 MB transfer.
+To send a 5 MB command then we need to transfer the command chunk by chunk.
+
+To do this, tgt core will map in as much data as possible into a bio,
+send this off, then when that transfer is completed we send off another
+request/bio. To be able to pack as much data into a bio as possible
+we need bio_map_user to support partially mapped bios. The attached patch
+just adds a new argument to the those functions and if set will not
+return a failure if the bio is partially mapped.
+
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
 ---
 
  block/ll_rw_blk.c   |    5 +++--

Modified: branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,14 @@
 Subject: [PATCH] netlink: add a new netlink number for stgt
 
+Need a netlink number for our interface. Since this stuff is going
+to be cleaned up in tree. I am not ccing netdev. It might some time
+before tgt goes in so might need a new number by then.
+
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
 ---
 
  include/linux/netlink.h |    1 +

Modified: branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,15 @@
 Subject: [PATCH] scsi tgt core functions
 
+Core scsi tgt functionality. We are currently using netlink for
+the interface. We plan on trying to use the packet layer or maybe
+relay fs so we can quickly pipe requests to userspace. We are not
+sure yet though and the packet socket code needs work. So hopefully
+this can be done after merging this but before it goes to mainline.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
 ---
 
  drivers/scsi/scsi_tgt_if.c   |  214 ++++++++++++++++

Modified: branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,12 @@
 Subject: [PATCH] scsi-ml: Makefile and Kconfig changes for stgt
 
+
+Makefile and Kconfig stuff.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
 ---
 
  drivers/scsi/Kconfig  |    7 +++++++

Modified: branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
===================================================================
--- branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-15 07:06:40 UTC (rev 300)
+++ branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-16 08:55:08 UTC (rev 301)
@@ -1,5 +1,12 @@
 Subject: [PATCH] scsi-ml: add public stgt include files
 
+public header files
+
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
 ---
 
  include/scsi/scsi_tgt.h    |   11 +++++



From mnc at berlios.de  Thu Feb 16 10:22:39 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 16 Feb 2006 10:22:39 +0100
Subject: [Stgt-svn] r302 - branches/use-scsi-ml/patchset
Message-ID: <200602160922.k1G9MdRU005850@sheep.berlios.de>

Author: mnc
Date: 2006-02-16 10:22:38 +0100 (Thu, 16 Feb 2006)
New Revision: 302

Modified:
   branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
Log:
fix up comment

Modified: branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-16 08:55:08 UTC (rev 301)
+++ branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-16 09:22:38 UTC (rev 302)
@@ -1,10 +1,13 @@
 Subject: [PATCH] netlink: add a new netlink number for stgt
 
-Need a netlink number for our interface. Since this stuff is going
-to be cleaned up in tree. I am not ccing netdev. It might some time
-before tgt goes in so might need a new number by then.
+Need a netlink number for our interface.
 
+The netlink interface code is the next patch "[PATCH] scsi tgt netlink
+inteface". I am only sending the netlink patch and netlink interface code
+to netdev since you guys probably do not care about the scsi and block layer
+stuff.
 
+
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 



From mnc at berlios.de  Thu Feb 16 20:26:57 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 16 Feb 2006 20:26:57 +0100
Subject: [Stgt-svn] r303 - branches/use-scsi-ml/patchset
Message-ID: <200602161926.k1GJQvUZ026260@sheep.berlios.de>

Author: mnc
Date: 2006-02-16 20:26:55 +0100 (Thu, 16 Feb 2006)
New Revision: 303

Added:
   branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt
Removed:
   branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
   branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
   branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
Modified:
   branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
Log:
update patches

Modified: branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-16 09:22:38 UTC (rev 302)
+++ branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-16 19:26:55 UTC (rev 303)
@@ -2,6 +2,21 @@
 
 This patch contains the needed changes to the scsi-ml to support targets.
 
+Note, per the last review we moved almost all the fields we added
+to the scsi_cmnd to our internal data structure which we are going
+to try and kill off when we can replace it with support from other
+parts of the kernel.
+
+The one field we left on was the offset variable. This is needed to handle
+the case where the target gets request that is so large that it cannot
+execute it in one dma operation. So max_secotors or a segment limit may
+limit the size of the transfer. In this case our tgt core code will
+break up the command into managable transfers and send them to the
+LLD one at a time. The offset is then used to tell the LLD where in
+the command we are at. Is there another field on the scsi_cmd for
+that?
+
+
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 

Added: branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt	2006-02-16 09:22:38 UTC (rev 302)
+++ branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt	2006-02-16 19:26:55 UTC (rev 303)
@@ -0,0 +1,630 @@
+The core scsi target lib functions.
+
+TODO:
+- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
+do that weird include.
+- convert scsi_tgt_cmd's work struct to James's execute code. And try
+to kill our scsi_tgt_cmd.
+- add host state checking. We do refcouting so hotplug is partially
+supported, but we need to add state checking to make it easier on
+the LLD.
+- make it so the request_queue can be used to pass around these target
+messages better (see todo in code), or maybe just remove request_queue
+usage all together and use our own linked_list or something else.
+We currently use the queue for tag numbers so if we remove the request_queue
+we will have to add some sort of host tag list like was suggested for iscsi.
+We also use the queue to store the HBA limits and build proper sized bios
+and reqeusts so we would need a shell queue like what dm uses.
+- eh handling (still in the process of working on proper state
+model in userspace).
+- must remove our request->flags hack
+
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..8746236
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,550 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/elevator.h>
++#include <linux/module.h>
++#include <linux/pagemap.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <../drivers/md/dm-bio-list.h>
++
++#include "scsi_tgt_priv.h"
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++	struct scsi_lun *lun;
++};
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
++		rq_data_dir(cmd->request));
++	/*
++	 * We must set rq->flags here because bio_map_user and
++	 * blk_rq_bio_prep ruined ti.
++	 */
++	if (cmd->sc_data_direction == DMA_TO_DEVICE)
++		cmd->request->flags |= 1;
++	else
++		cmd->request->flags &= ~1UL;
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
++{
++	tcmd->lun = rq->end_io_data;
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++}
++
++static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
++{
++	struct scsi_tgt_cmd *tcmd;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		return BLKPREP_DEFER;
++
++	init_scsi_tgt_cmd(rq, tcmd);
++	rq->end_io_data = tcmd;
++	rq->flags |= REQ_DONTPREP;
++	return BLKPREP_OK;
++}
++
++static void scsi_uspace_request_fn(struct request_queue *q)
++{
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/*
++	 * TODO: just send everthing in the queue to userspace in
++	 * one vector instead of multiple calls
++	 */
++	while ((rq = elv_next_request(q)) != NULL) {
++		cmd = rq->special;
++		tcmd = rq->end_io_data;
++
++		/* the completion code kicks us in case we hit this */
++		if (blk_queue_start_tag(q, rq))
++			break;
++
++		spin_unlock_irq(q->queue_lock);
++		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
++			goto requeue;
++		spin_lock_irq(q->queue_lock);
++	}
++
++	return;
++requeue:
++	spin_lock_irq(q->queue_lock);
++	/* need to track cnts and plug */
++	blk_requeue_request(q, rq);
++	spin_lock_irq(q->queue_lock);
++}
++
++/**
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ **/
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata->shost = shost;
++	q->queuedata = queuedata;
++
++	elevator_exit(q->elevator);
++	err = elevator_init(q, "noop");
++	if (err)
++		goto free_data;
++
++	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q->nr_requests = shost->hostt->can_queue;
++	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost->uspace_req_q = q;
++
++	return 0;
++
++free_data:
++	kfree(queuedata);
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
++	return queue->shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/**
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @noblock:	set to nonzero if the command should be queued
++ **/
++void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			    int noblock)
++{
++	/*
++	 * For now this just calls the request_fn from this context.
++	 * For HW llds though we do not want to execute from here so
++	 * the elevator code needs something like a REQ_TGT_CMD or
++	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
++	 */
++	cmd->request->end_io_data = scsilun;
++	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	/* don't we have to call this if result is set or not */
++	if (cmd->result) {
++		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++		return;
++	}
++
++	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &tcmd->work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd->result = DID_BUS_BUSY << 16;
++	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd->request;
++	int count;
++
++	cmd->use_sg = rq->nr_phys_segments;
++	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd->request_buffer)
++		return -ENOMEM;
++
++	cmd->request_bufflen = rq->data_len;
++
++	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, cmd->buffer, cmd->use_sg,
++		rq_data_dir(rq));
++	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
++	if (likely(count <= cmd->use_sg)) {
++		cmd->use_sg = count;
++		return 0;
++	}
++
++	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd->request->q;
++	struct request *rq = cmd->request;
++	void *uaddr = cmd->buffer;
++	unsigned int len = cmd->bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len > 0) {
++		dprintk("%lx %u\n", (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk("fail to map %lx %u %d %x\n",
++				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
++			goto unmap_bios;
++		}
++
++		uaddr += bio->bi_size;
++		len -= bio->bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq->bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq->data_len = bio->bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&tcmd->xfer_list, bio);
++	}
++
++	cmd->offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq->bio) {
++		bio_unmap_user(rq->bio);
++		while ((bio = bio_list_pop(&tcmd->xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd->result) {
++send_uspace_err:
++		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++		return;
++	}
++
++	dprintk("cmd %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
++
++	cmd->buffer += cmd->request_bufflen;
++	cmd->offset += cmd->request_bufflen;
++
++	if (!tcmd->xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, cmd->bufflen);
++
++	bio = bio_list_pop(&tcmd->xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
++	cmd->request->data_len = bio->bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd->result = DID_ERROR << 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd->result = DID_NO_CONNECT << 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd->sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR "Could not copy the sense buffer\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
++			 unsigned long uaddr, u8 rw, u8 try_map)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	int err = 0;
++
++	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
++		len, (unsigned long long) offset, uaddr, rw, try_map);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++
++	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
++	if (!rq) {
++		printk(KERN_ERR "Could not find cid %u\n", cid);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq->special;
++
++	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
++		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
++
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	cmd->buffer = (void *)uaddr;
++	if (len)
++		cmd->bufflen = len;
++	cmd->result = result;
++
++	if (!cmd->bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
++	if (err) {
++		eprintk("%p %d\n", cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd->result) {
++		if (status_byte(cmd->result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue("scsi_tgtd");
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION("SCSI target core");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..4236e50
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,25 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define dprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define eprintk dprintk
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++};
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
++				u64 offset, unsigned long uaddr, u8 rw,
++				u8 try_map);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..91ad6bc
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,11 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);

Deleted: branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-16 09:22:38 UTC (rev 302)
+++ branches/use-scsi-ml/patchset/0004-netlink-add-a-new-netlink-number-for-stgt.txt	2006-02-16 19:26:55 UTC (rev 303)
@@ -1,34 +0,0 @@
-Subject: [PATCH] netlink: add a new netlink number for stgt
-
-Need a netlink number for our interface.
-
-The netlink interface code is the next patch "[PATCH] scsi tgt netlink
-inteface". I am only sending the netlink patch and netlink interface code
-to netdev since you guys probably do not care about the scsi and block layer
-stuff.
-
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-
-
----
-
- include/linux/netlink.h |    1 +
- 1 files changed, 1 insertions(+), 0 deletions(-)
-
-4ef87917cc44f07d389dfdd189b4f926335fb7ba
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 6a2ccf7..580fb42 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,6 +21,7 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
-+#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-16 09:22:38 UTC (rev 302)
+++ branches/use-scsi-ml/patchset/0005-scsi-tgt-core-functions.txt	2006-02-16 19:26:55 UTC (rev 303)
@@ -1,832 +0,0 @@
-Subject: [PATCH] scsi tgt core functions
-
-Core scsi tgt functionality. We are currently using netlink for
-the interface. We plan on trying to use the packet layer or maybe
-relay fs so we can quickly pipe requests to userspace. We are not
-sure yet though and the packet socket code needs work. So hopefully
-this can be done after merging this but before it goes to mainline.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-
-
----
-
- drivers/scsi/scsi_tgt_if.c   |  214 ++++++++++++++++
- drivers/scsi/scsi_tgt_lib.c  |  550 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   25 ++
- 3 files changed, 789 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/scsi_tgt_if.c
- create mode 100644 drivers/scsi/scsi_tgt_lib.c
- create mode 100644 drivers/scsi/scsi_tgt_priv.h
-
-de47d09f27130e7847b2012f9c8a7a05f32e90c4
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-new file mode 100644
-index 0000000..38b35da
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,214 @@
-+/*
-+ * SCSI target kernel/user interface functions
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/file.h>
-+#include <linux/netlink.h>
-+#include <net/tcp.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/scsi_tgt_if.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static int tgtd_pid;
-+static struct sock *nl_sk;
-+
-+static int send_event_res(uint16_t type, struct tgt_event *p,
-+			  void *data, int dlen, gfp_t flags, pid_t pid)
-+{
-+	struct tgt_event *ev;
-+	struct nlmsghdr *nlh;
-+	struct sk_buff *skb;
-+	uint32_t len;
-+
-+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-+	skb = alloc_skb(len, flags);
-+	if (!skb)
-+		return -ENOMEM;
-+
-+	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+
-+	ev = NLMSG_DATA(nlh);
-+	memcpy(ev, p, sizeof(*ev));
-+	if (dlen)
-+		memcpy(ev->data, data, dlen);
-+
-+	return netlink_unicast(nl_sk, skb, pid, 0);
-+}
-+
-+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct sk_buff *skb;
-+	struct nlmsghdr *nlh;
-+	struct tgt_event *ev;
-+	struct tgt_cmd *tcmd;
-+	int err, len;
-+
-+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
-+	/*
-+	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
-+	 */
-+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-+	if (!skb)
-+		return -ENOMEM;
-+
-+	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
-+			  len - sizeof(*nlh), 0);
-+
-+	ev = NLMSG_DATA(nlh);
-+	ev->k.cmd_req.host_no = shost->host_no;
-+	ev->k.cmd_req.cid = cmd->request->tag;
-+	ev->k.cmd_req.data_len = cmd->request_bufflen;
-+
-+	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
-+		ev->k.cmd_req.data_len);
-+
-+	/* FIXME: we need scsi core to do that. */
-+	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-+
-+	tcmd = (struct tgt_cmd *) ev->data;
-+	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
-+	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
-+
-+	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
-+	if (err < 0)
-+		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
-+		       err);
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	char dummy[sizeof(struct tgt_cmd)];
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_done.host_no = shost->host_no;
-+	ev.k.cmd_done.cid = cmd->request->tag;
-+	ev.k.cmd_done.result = cmd->result;
-+
-+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-+			      gfp_mask, tgtd_pid);
-+}
-+
-+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+{
-+	struct tgt_event *ev = NLMSG_DATA(nlh);
-+	int err = 0;
-+
-+	dprintk("%d %d %d\n", nlh->nlmsg_type,
-+		nlh->nlmsg_pid, current->pid);
-+
-+	switch (nlh->nlmsg_type) {
-+	case TGT_UEVENT_TGTD_BIND:
-+		tgtd_pid = NETLINK_CREDS(skb)->pid;
-+		break;
-+	case TGT_UEVENT_CMD_RES:
-+		/* TODO: handle multiple cmds in one event */
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
-+					   ev->u.cmd_res.cid,
-+					   ev->u.cmd_res.result,
-+					   ev->u.cmd_res.len,
-+					   ev->u.cmd_res.offset,
-+					   ev->u.cmd_res.uaddr,
-+					   ev->u.cmd_res.rw,
-+					   ev->u.cmd_res.try_map);
-+		break;
-+	default:
-+		eprintk("unknown type %d\n", nlh->nlmsg_type);
-+		err = -EINVAL;
-+	}
-+
-+	return err;
-+}
-+
-+static int event_recv_skb(struct sk_buff *skb)
-+{
-+	int err;
-+	uint32_t rlen;
-+	struct nlmsghdr	*nlh;
-+
-+	while (skb->len >= NLMSG_SPACE(0)) {
-+		nlh = (struct nlmsghdr *) skb->data;
-+		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-+			return 0;
-+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-+		if (rlen > skb->len)
-+			rlen = skb->len;
-+		err = event_recv_msg(skb, nlh);
-+
-+		dprintk("%d %d\n", nlh->nlmsg_type, err);
-+		/*
-+		 * TODO for passthru commands the lower level should
-+		 * probably handle the result or we should modify this
-+		 */
-+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
-+			struct tgt_event ev;
-+
-+			memset(&ev, 0, sizeof(ev));
-+			ev.k.event_res.err = err;
-+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-+				       GFP_KERNEL | __GFP_NOFAIL,
-+					nlh->nlmsg_pid);
-+		}
-+		skb_pull(skb, rlen);
-+	}
-+	return 0;
-+}
-+
-+static void event_recv(struct sock *sk, int length)
-+{
-+	struct sk_buff *skb;
-+
-+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-+		if (NETLINK_CREDS(skb)->uid) {
-+			skb_pull(skb, skb->len);
-+			kfree_skb(skb);
-+			continue;
-+		}
-+
-+		if (event_recv_skb(skb) && skb->len)
-+			skb_queue_head(&sk->sk_receive_queue, skb);
-+		else
-+			kfree_skb(skb);
-+	}
-+}
-+
-+void __exit scsi_tgt_if_exit(void)
-+{
-+	sock_release(nl_sk->sk_socket);
-+}
-+
-+int __init scsi_tgt_if_init(void)
-+{
-+	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
-+				    THIS_MODULE);
-+	if (!nl_sk)
-+		return -ENOMEM;
-+
-+	return 0;
-+}
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-new file mode 100644
-index 0000000..8746236
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,550 @@
-+/*
-+ * SCSI target lib functions
-+ *
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/elevator.h>
-+#include <linux/module.h>
-+#include <linux/pagemap.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <../drivers/md/dm-bio-list.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static struct workqueue_struct *scsi_tgtd;
-+static kmem_cache_t *scsi_tgt_cmd_cache;
-+
-+/*
-+ * TODO: this struct will be killed when the block layer supports large bios
-+ * and James's work struct code is in
-+ */
-+struct scsi_tgt_cmd {
-+	/* TODO replace work with James b's code */
-+	struct work_struct work;
-+	/* TODO replace the lists with a large bio */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
-+	struct scsi_lun *lun;
-+};
-+
-+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-+{
-+	struct bio *bio;
-+
-+	/* must call bio_endio in case bio was bounced */
-+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+
-+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+}
-+
-+static void scsi_tgt_cmd_destroy(void *data)
-+{
-+	struct scsi_cmnd *cmd = data;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
-+		rq_data_dir(cmd->request));
-+	/*
-+	 * We must set rq->flags here because bio_map_user and
-+	 * blk_rq_bio_prep ruined ti.
-+	 */
-+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-+		cmd->request->flags |= 1;
-+	else
-+		cmd->request->flags &= ~1UL;
-+
-+	scsi_unmap_user_pages(tcmd);
-+	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-+}
-+
-+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
-+{
-+	tcmd->lun = rq->end_io_data;
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+}
-+
-+static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
-+{
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		return BLKPREP_DEFER;
-+
-+	init_scsi_tgt_cmd(rq, tcmd);
-+	rq->end_io_data = tcmd;
-+	rq->flags |= REQ_DONTPREP;
-+	return BLKPREP_OK;
-+}
-+
-+static void scsi_uspace_request_fn(struct request_queue *q)
-+{
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/*
-+	 * TODO: just send everthing in the queue to userspace in
-+	 * one vector instead of multiple calls
-+	 */
-+	while ((rq = elv_next_request(q)) != NULL) {
-+		cmd = rq->special;
-+		tcmd = rq->end_io_data;
-+
-+		/* the completion code kicks us in case we hit this */
-+		if (blk_queue_start_tag(q, rq))
-+			break;
-+
-+		spin_unlock_irq(q->queue_lock);
-+		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
-+			goto requeue;
-+		spin_lock_irq(q->queue_lock);
-+	}
-+
-+	return;
-+requeue:
-+	spin_lock_irq(q->queue_lock);
-+	/* need to track cnts and plug */
-+	blk_requeue_request(q, rq);
-+	spin_lock_irq(q->queue_lock);
-+}
-+
-+/**
-+ * scsi_tgt_alloc_queue - setup queue used for message passing
-+ * shost: scsi host
-+ *
-+ * This should be called by the LLD after host allocation.
-+ * And will be released when the host is released.
-+ **/
-+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-+{
-+	struct scsi_tgt_queuedata *queuedata;
-+	struct request_queue *q;
-+	int err;
-+
-+	/*
-+	 * Do we need to send a netlink event or should uspace
-+	 * just respond to the hotplug event?
-+	 */
-+	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
-+	if (!q)
-+		return -ENOMEM;
-+
-+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-+	if (!queuedata) {
-+		err = -ENOMEM;
-+		goto cleanup_queue;
-+	}
-+	queuedata->shost = shost;
-+	q->queuedata = queuedata;
-+
-+	elevator_exit(q->elevator);
-+	err = elevator_init(q, "noop");
-+	if (err)
-+		goto free_data;
-+
-+	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
-+	/*
-+	 * this is a silly hack. We should probably just queue as many
-+	 * command as is recvd to userspace. uspace can then make
-+	 * sure we do not overload the HBA
-+	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
-+	/*
-+	 * We currently only support software LLDs so this does
-+	 * not matter for now. Do we need this for the cards we support?
-+	 * If so we should make it a host template value.
-+	 */
-+	blk_queue_dma_alignment(q, 0);
-+	shost->uspace_req_q = q;
-+
-+	return 0;
-+
-+free_data:
-+	kfree(queuedata);
-+cleanup_queue:
-+	blk_cleanup_queue(q);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-+
-+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-+	return queue->shost;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-+
-+/**
-+ * scsi_tgt_queue_command - queue command for userspace processing
-+ * @cmd:	scsi command
-+ * @scsilun:	scsi lun
-+ * @noblock:	set to nonzero if the command should be queued
-+ **/
-+void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			    int noblock)
-+{
-+	/*
-+	 * For now this just calls the request_fn from this context.
-+	 * For HW llds though we do not want to execute from here so
-+	 * the elevator code needs something like a REQ_TGT_CMD or
-+	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
-+	 */
-+	cmd->request->end_io_data = scsilun;
-+	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-+
-+/*
-+ * This is run from a interrpt handler normally and the unmap
-+ * needs process context so we must queue
-+ */
-+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	/* don't we have to call this if result is set or not */
-+	if (cmd->result) {
-+		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+		return;
-+	}
-+
-+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-+	queue_work(scsi_tgtd, &tcmd->work);
-+}
-+
-+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	int err;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-+	switch (err) {
-+	case SCSI_MLQUEUE_HOST_BUSY:
-+	case SCSI_MLQUEUE_DEVICE_BUSY:
-+		return -EAGAIN;
-+	}
-+
-+	return 0;
-+}
-+
-+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = __scsi_tgt_transfer_response(cmd);
-+	if (!err)
-+		return;
-+
-+	cmd->result = DID_BUS_BUSY << 16;
-+	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+		/* the eh will have to pick this up */
-+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+}
-+
-+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct request *rq = cmd->request;
-+	int count;
-+
-+	cmd->use_sg = rq->nr_phys_segments;
-+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-+	if (!cmd->request_buffer)
-+		return -ENOMEM;
-+
-+	cmd->request_bufflen = rq->data_len;
-+
-+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, cmd->buffer, cmd->use_sg,
-+		rq_data_dir(rq));
-+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-+	if (likely(count <= cmd->use_sg)) {
-+		cmd->use_sg = count;
-+		return 0;
-+	}
-+
-+	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	return -EINVAL;
-+}
-+
-+/* TODO: test this crap and replace bio_map_user with new interface maybe */
-+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-+			       int rw)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct request *rq = cmd->request;
-+	void *uaddr = cmd->buffer;
-+	unsigned int len = cmd->bufflen;
-+	struct bio *bio;
-+	int err;
-+
-+	while (len > 0) {
-+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
-+		if (IS_ERR(bio)) {
-+			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u %d %x\n",
-+				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-+			goto unmap_bios;
-+		}
-+
-+		uaddr += bio->bi_size;
-+		len -= bio->bi_size;
-+
-+		/*
-+		 * The first bio is added and merged. We could probably
-+		 * try to add others using scsi_merge_bio() but for now
-+		 * we keep it simple. The first bio should be pretty large
-+		 * (either hitting the 1 MB bio pages limit or a queue limit)
-+		 * already but for really large IO we may want to try and
-+		 * merge these.
-+		 */
-+		if (!rq->bio) {
-+			blk_rq_bio_prep(q, rq, bio);
-+			rq->data_len = bio->bi_size;
-+		} else
-+			/* put list of bios to transfer in next go around */
-+			bio_list_add(&tcmd->xfer_list, bio);
-+	}
-+
-+	cmd->offset = 0;
-+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-+	if (err)
-+		goto unmap_bios;
-+
-+	return 0;
-+
-+unmap_bios:
-+	if (rq->bio) {
-+		bio_unmap_user(rq->bio);
-+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-+			bio_unmap_user(bio);
-+	}
-+
-+	return err;
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-+
-+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	struct bio *bio;
-+	int err;
-+
-+	/* should we free resources here on error ? */
-+	if (cmd->result) {
-+send_uspace_err:
-+		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+			/* the tgt uspace eh will have to pick this up */
-+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, cmd->bufflen);
-+
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-+
-+	cmd->buffer += cmd->request_bufflen;
-+	cmd->offset += cmd->request_bufflen;
-+
-+	if (!tcmd->xfer_list.head) {
-+		scsi_tgt_transfer_response(cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, cmd->bufflen);
-+
-+	bio = bio_list_pop(&tcmd->xfer_list);
-+	BUG_ON(!bio);
-+
-+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-+	cmd->request->data_len = bio->bi_size;
-+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-+	if (err) {
-+		cmd->result = DID_ERROR << 16;
-+		goto send_uspace_err;
-+	}
-+
-+	if (scsi_tgt_transfer_data(cmd)) {
-+		cmd->result = DID_NO_CONNECT << 16;
-+		goto send_uspace_err;
-+	}
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-+
-+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-+	switch (err) {
-+		case SCSI_MLQUEUE_HOST_BUSY:
-+		case SCSI_MLQUEUE_DEVICE_BUSY:
-+			return -EAGAIN;
-+	default:
-+		return 0;
-+	}
-+}
-+
-+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-+				unsigned len)
-+{
-+	char __user *p = (char __user *) uaddr;
-+
-+	if (copy_from_user(cmd->sense_buffer, p,
-+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-+		printk(KERN_ERR "Could not copy the sense buffer\n");
-+		return -EIO;
-+	}
-+	return 0;
-+}
-+
-+int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
-+			 unsigned long uaddr, u8 rw, u8 try_map)
-+{
-+	struct Scsi_Host *shost;
-+	struct scsi_cmnd *cmd;
-+	struct request *rq;
-+	int err = 0;
-+
-+	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
-+		len, (unsigned long long) offset, uaddr, rw, try_map);
-+
-+	/* TODO: replace with a O(1) alg */
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+
-+	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
-+	if (!rq) {
-+		printk(KERN_ERR "Could not find cid %u\n", cid);
-+		err = -EINVAL;
-+		goto done;
-+	}
-+	cmd = rq->special;
-+
-+	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
-+		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
-+
-+	/*
-+	 * store the userspace values here, the working values are
-+	 * in the request_* values
-+	 */
-+	cmd->buffer = (void *)uaddr;
-+	if (len)
-+		cmd->bufflen = len;
-+	cmd->result = result;
-+
-+	if (!cmd->bufflen) {
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+
-+	/*
-+	 * TODO: Do we need to handle case where request does not
-+	 * align with LLD.
-+	 */
-+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-+	if (err) {
-+		eprintk("%p %d\n", cmd, err);
-+		err = -EAGAIN;
-+		goto done;
-+	}
-+
-+	/* userspace failure */
-+	if (cmd->result) {
-+		if (status_byte(cmd->result) == CHECK_CONDITION)
-+			scsi_tgt_copy_sense(cmd, uaddr, len);
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+	/* ask the target LLD to transfer the data to the buffer */
-+	err = scsi_tgt_transfer_data(cmd);
-+
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+static int __init scsi_tgt_init(void)
-+{
-+	int err;
-+
-+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-+					       sizeof(struct scsi_tgt_cmd),
-+					       0, 0, NULL, NULL);
-+	if (!scsi_tgt_cmd_cache)
-+		return -ENOMEM;
-+
-+	scsi_tgtd = create_workqueue("scsi_tgtd");
-+	if (!scsi_tgtd) {
-+		err = -ENOMEM;
-+		goto free_kmemcache;
-+	}
-+
-+	err = scsi_tgt_if_init();
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(scsi_tgtd);
-+free_kmemcache:
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+	return err;
-+}
-+
-+static void __exit scsi_tgt_exit(void)
-+{
-+	destroy_workqueue(scsi_tgtd);
-+	scsi_tgt_if_exit();
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+}
-+
-+module_init(scsi_tgt_init);
-+module_exit(scsi_tgt_exit);
-+
-+MODULE_DESCRIPTION("SCSI target core");
-+MODULE_LICENSE("GPL");
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-new file mode 100644
-index 0000000..4236e50
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,25 @@
-+struct scsi_cmnd;
-+struct scsi_lun;
-+struct Scsi_Host;
-+struct task_struct;
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define dprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+
-+#define eprintk dprintk
-+
-+struct scsi_tgt_queuedata {
-+	struct Scsi_Host *shost;
-+};
-+
-+extern void scsi_tgt_if_exit(void);
-+extern int scsi_tgt_if_init(void);
-+
-+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-+				u64 offset, unsigned long uaddr, u8 rw,
-+				u8 try_map);
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt
===================================================================
--- branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-16 09:22:38 UTC (rev 302)
+++ branches/use-scsi-ml/patchset/0007-scsi-ml-add-public-stgt-include-files.txt	2006-02-16 19:26:55 UTC (rev 303)
@@ -1,135 +0,0 @@
-Subject: [PATCH] scsi-ml: add public stgt include files
-
-public header files
-
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-
-
----
-
- include/scsi/scsi_tgt.h    |   11 +++++
- include/scsi/scsi_tgt_if.h |   92 ++++++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 103 insertions(+), 0 deletions(-)
- create mode 100644 include/scsi/scsi_tgt.h
- create mode 100644 include/scsi/scsi_tgt_if.h
-
-22f986c1620d598163ec3a97eb42972dbf225601
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..91ad6bc
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,11 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..04be52d
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,92 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_TGTD_BIND,
-+	TGT_UEVENT_TARGET_SETUP,
-+	TGT_UEVENT_CMD_RES,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_RESPONSE,
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+};
-+
-+struct tgt_event {
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int pk_fd;
-+		} tgtd_bind;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint64_t offset;
-+			uint8_t rw;
-+			uint8_t try_map;
-+		} cmd_res;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int err;
-+		} event_res;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t data_len;
-+			uint64_t dev_id;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			int result;
-+		} cmd_done;
-+	} k;
-+
-+	/*
-+	 * I think a pointer is a unsigned long but this struct
-+	 * gets passed around from the kernel to userspace and
-+	 * back again so to handle some ppc64 setups where userspace is
-+	 * 32 bits but the kernel is 64 we do this odd thing
-+	 */
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#ifndef __KERNEL__
-+#define MAX_COMMAND_SIZE	16
-+#endif
-+
-+struct tgt_cmd {
-+	uint8_t scb[MAX_COMMAND_SIZE];
-+	uint8_t lun[8];
-+	int tags;
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#endif
--- 
-1.1.3



From mnc at berlios.de  Thu Feb 16 20:27:37 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Thu, 16 Feb 2006 20:27:37 +0100
Subject: [Stgt-svn] r304 - branches/use-scsi-ml/patchset
Message-ID: <200602161927.k1GJRbIj026826@sheep.berlios.de>

Author: mnc
Date: 2006-02-16 20:27:36 +0100 (Thu, 16 Feb 2006)
New Revision: 304

Added:
   branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt
Log:
more update patches work

Added: branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt	2006-02-16 19:26:55 UTC (rev 303)
+++ branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt	2006-02-16 19:27:36 UTC (rev 304)
@@ -0,0 +1,349 @@
+Netlink interface for the scsi tgt framework.
+
+I did not think the netdev people wanted to see the scsi and
+block layer code, so I am just send the netlink interface part
+of this patchset to netdev. I can resend the other parts if
+needed.
+
+The scsi tgt framework, adds support for scsi target mode
+cards. So instead of using the scsi card in your box as a initiator
+you can use it as a target/server.
+
+The reason of the netlink use is becuase the target normally
+recieve a interrupt indicating that command or event is
+ready to be processed. The scsi card's driver will then call
+a scsi lib function which eventually calls scsi_tgt_uspace_send to
+tell userspace to begin to process the request (userspace contains
+the state model). Later userspace will call back into the kernel
+be sending a netlink msg, and instruct the scsi driver what to do next.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+
+
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..38b35da
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,214 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/file.h>
++#include <linux/netlink.h>
++#include <net/tcp.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/scsi_tgt_if.h>
++
++#include "scsi_tgt_priv.h"
++
++static int tgtd_pid;
++static struct sock *nl_sk;
++
++static int send_event_res(uint16_t type, struct tgt_event *p,
++			  void *data, int dlen, gfp_t flags, pid_t pid)
++{
++	struct tgt_event *ev;
++	struct nlmsghdr *nlh;
++	struct sk_buff *skb;
++	uint32_t len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + dlen);
++	skb = alloc_skb(len, flags);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	memcpy(ev, p, sizeof(*ev));
++	if (dlen)
++		memcpy(ev->data, data, dlen);
++
++	return netlink_unicast(nl_sk, skb, pid, 0);
++}
++
++int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct sk_buff *skb;
++	struct nlmsghdr *nlh;
++	struct tgt_event *ev;
++	struct tgt_cmd *tcmd;
++	int err, len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
++	/*
++	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
++	 */
++	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
++			  len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	ev->k.cmd_req.host_no = shost->host_no;
++	ev->k.cmd_req.cid = cmd->request->tag;
++	ev->k.cmd_req.data_len = cmd->request_bufflen;
++
++	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
++		ev->k.cmd_req.data_len);
++
++	/* FIXME: we need scsi core to do that. */
++	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
++
++	tcmd = (struct tgt_cmd *) ev->data;
++	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
++	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
++
++	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
++	if (err < 0)
++		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
++		       err);
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	char dummy[sizeof(struct tgt_cmd)];
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost->host_no;
++	ev.k.cmd_done.cid = cmd->request->tag;
++	ev.k.cmd_done.result = cmd->result;
++
++	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
++			      gfp_mask, tgtd_pid);
++}
++
++static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++{
++	struct tgt_event *ev = NLMSG_DATA(nlh);
++	int err = 0;
++
++	dprintk("%d %d %d\n", nlh->nlmsg_type,
++		nlh->nlmsg_pid, current->pid);
++
++	switch (nlh->nlmsg_type) {
++	case TGT_UEVENT_TGTD_BIND:
++		tgtd_pid = NETLINK_CREDS(skb)->pid;
++		break;
++	case TGT_UEVENT_CMD_RES:
++		/* TODO: handle multiple cmds in one event */
++		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
++					   ev->u.cmd_res.cid,
++					   ev->u.cmd_res.result,
++					   ev->u.cmd_res.len,
++					   ev->u.cmd_res.offset,
++					   ev->u.cmd_res.uaddr,
++					   ev->u.cmd_res.rw,
++					   ev->u.cmd_res.try_map);
++		break;
++	default:
++		eprintk("unknown type %d\n", nlh->nlmsg_type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static int event_recv_skb(struct sk_buff *skb)
++{
++	int err;
++	uint32_t rlen;
++	struct nlmsghdr	*nlh;
++
++	while (skb->len >= NLMSG_SPACE(0)) {
++		nlh = (struct nlmsghdr *) skb->data;
++		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
++			return 0;
++		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
++		if (rlen > skb->len)
++			rlen = skb->len;
++		err = event_recv_msg(skb, nlh);
++
++		dprintk("%d %d\n", nlh->nlmsg_type, err);
++		/*
++		 * TODO for passthru commands the lower level should
++		 * probably handle the result or we should modify this
++		 */
++		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
++			struct tgt_event ev;
++
++			memset(&ev, 0, sizeof(ev));
++			ev.k.event_res.err = err;
++			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
++				       GFP_KERNEL | __GFP_NOFAIL,
++					nlh->nlmsg_pid);
++		}
++		skb_pull(skb, rlen);
++	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
++		if (NETLINK_CREDS(skb)->uid) {
++			skb_pull(skb, skb->len);
++			kfree_skb(skb);
++			continue;
++		}
++
++		if (event_recv_skb(skb) && skb->len)
++			skb_queue_head(&sk->sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
++}
++
++void __exit scsi_tgt_if_exit(void)
++{
++	sock_release(nl_sk->sk_socket);
++}
++
++int __init scsi_tgt_if_init(void)
++{
++	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
++				    THIS_MODULE);
++	if (!nl_sk)
++		return -ENOMEM;
++
++	return 0;
++}
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 6a2ccf7..580fb42 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..da3a808
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,88 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_TGTD_BIND,
++	TGT_UEVENT_TARGET_SETUP,
++	TGT_UEVENT_CMD_RES,
++
++	/* kernel -> user */
++	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int pk_fd;
++		} tgtd_bind;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint64_t offset;
++			uint8_t rw;
++			uint8_t try_map;
++		} cmd_res;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_res;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint64_t dev_id;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++	} k;
++
++	/*
++	 * I think a pointer is a unsigned long but this struct
++	 * gets passed around from the kernel to userspace and
++	 * back again so to handle some ppc64 setups where userspace is
++	 * 32 bits but the kernel is 64 we do this odd thing
++	 */
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++struct tgt_cmd {
++	uint8_t scb[16];
++	uint8_t lun[8];
++	int tags;
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif



From tomo at berlios.de  Sat Feb 18 22:34:58 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 18 Feb 2006 22:34:58 +0100
Subject: [Stgt-svn] r305 - branches/use-scsi-ml/usr
Message-ID: <200602182134.k1ILYw4x001807@sheep.berlios.de>

Author: tomo
Date: 2006-02-18 22:34:57 +0100 (Sat, 18 Feb 2006)
New Revision: 305

Modified:
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/scsi.c
Log:
Fix data corruption bugs. We need to use mmap2 with large devices.


Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-02-16 19:27:36 UTC (rev 304)
+++ branches/use-scsi-ml/usr/Makefile	2006-02-18 21:34:57 UTC (rev 305)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../include
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../include -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
 
 all: $(PROGRAMS)

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-16 19:27:36 UTC (rev 304)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-18 21:34:57 UTC (rev 305)
@@ -18,6 +18,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <syscall.h>
 #include <unistd.h>
 #include <asm/byteorder.h>
 #include <asm/page.h>
@@ -579,18 +580,21 @@
 	off <<= 9;
 
 	if (*uaddr)
-		*uaddr = *uaddr + (off & PAGE_MASK);
+		*uaddr = *uaddr + off;
 	else {
-		p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
-			 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
+		p = mmap64(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
+			   off & ~((1ULL << PAGE_SHIFT) - 1));
 
-		*uaddr = (unsigned long) p;
-		if (p == MAP_FAILED)
+		*uaddr = (unsigned long) p + (off & ~PAGE_MASK);
+		if (p == MAP_FAILED) {
 			err = SAM_STAT_CHECK_CONDITION;
+			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
+		}
 	}
 	*offset = off;
 	*len = datalen;
-	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
+	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
 	return err;
 }
@@ -757,9 +761,13 @@
 
 	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
 
-	if (do_munmap)
+	if (do_munmap) {
+		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
+		uaddr &= PAGE_MASK;
 		err = munmap((void *) (unsigned long) uaddr, len);
-	else if (do_free)
+		if (err)
+			eprintf("%" PRIx64 " %d\n", uaddr, len);
+	} else if (do_free)
 		free((void *) (unsigned long) uaddr);
 
 	return err;



From tomo at berlios.de  Sun Feb 19 05:12:30 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 19 Feb 2006 05:12:30 +0100
Subject: [Stgt-svn] r306 - branches/use-scsi-ml/usr
Message-ID: <200602190412.k1J4CUfA013088@sheep.berlios.de>

Author: tomo
Date: 2006-02-19 05:12:26 +0100 (Sun, 19 Feb 2006)
New Revision: 306

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Kill unnecessary headers and defines.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-18 21:34:57 UTC (rev 305)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-19 04:12:26 UTC (rev 306)
@@ -21,17 +21,12 @@
 #include <syscall.h>
 #include <unistd.h>
 #include <asm/byteorder.h>
-#include <asm/page.h>
-#include <scsi/iscsi_proto.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
-#include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <linux/netlink.h>
-
 #include "tgtd.h"
 #include "tgt_sysfs.h"
 
@@ -53,17 +48,6 @@
 #define READ 0
 #define WRITE 1
 
-#ifndef REPORT_LUNS
-#define REPORT_LUNS           0xa0
-#endif
-
-#ifndef SERVICE_ACTION_IN
-#define SERVICE_ACTION_IN     0x9e
-#endif
-
-#define SAM_STAT_GOOD            0x00
-#define SAM_STAT_CHECK_CONDITION 0x02
-
 static uint32_t blk_shift = 9;
 
 #define min(x,y) ({ \



From tomo at berlios.de  Sun Feb 19 08:38:24 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 19 Feb 2006 08:38:24 +0100
Subject: [Stgt-svn] r307 - branches/use-scsi-ml/usr
Message-ID: <200602190738.k1J7cO5F008660@sheep.berlios.de>

Author: tomo
Date: 2006-02-19 08:38:11 +0100 (Sun, 19 Feb 2006)
New Revision: 307

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Kill READ/WRITE defines.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-19 04:12:26 UTC (rev 306)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-19 07:38:11 UTC (rev 307)
@@ -21,6 +21,7 @@
 #include <syscall.h>
 #include <unistd.h>
 #include <asm/byteorder.h>
+#include <linux/fs.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
@@ -45,9 +46,6 @@
 #define cpu_to_be64 __cpu_to_be64
 #define be64_to_cpu __be64_to_cpu
 
-#define READ 0
-#define WRITE 1
-
 static uint32_t blk_shift = 9;
 
 #define min(x,y) ({ \



From tomo at berlios.de  Sun Feb 19 08:56:13 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 19 Feb 2006 08:56:13 +0100
Subject: [Stgt-svn] r308 - branches/use-scsi-ml/usr
Message-ID: <200602190756.k1J7uDLu017421@sheep.berlios.de>

Author: tomo
Date: 2006-02-19 08:55:48 +0100 (Sun, 19 Feb 2006)
New Revision: 308

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Cleanup blk_shift.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-19 07:38:11 UTC (rev 307)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-19 07:55:48 UTC (rev 308)
@@ -46,7 +46,7 @@
 #define cpu_to_be64 __cpu_to_be64
 #define be64_to_cpu __be64_to_cpu
 
-static uint32_t blk_shift = 9;
+#define BLK_SHIFT	9
 
 #define min(x,y) ({ \
 	typeof(x) _x = (x);	\
@@ -173,7 +173,7 @@
 	}
 
 	*len = 4;
-	size >>= blk_shift;
+	size >>= BLK_SHIFT;
 
 	if ((scb[1] & 0x8))
 		data[3] = 0;
@@ -182,7 +182,7 @@
 		*len += 8;
 		*(uint32_t *)(data + 4) = (size >> 32) ?
 			cpu_to_be32(0xffffffff) : cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = cpu_to_be32(1 << blk_shift);
+		*(uint32_t *)(data + 8) = cpu_to_be32(1 << BLK_SHIFT);
 	}
 
 	switch (pcode) {
@@ -396,11 +396,11 @@
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	size >>= blk_shift;
+	size >>= BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		cpu_to_be32(0xffffffff) : cpu_to_be32(size - 1);
-	data[1] = cpu_to_be32(1U << blk_shift);
+	data[1] = cpu_to_be32(1U << BLK_SHIFT);
 	*len = 8;
 
 	return SAM_STAT_GOOD;
@@ -518,11 +518,11 @@
 					0x25, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	}
-	size >>= blk_shift;
+	size >>= BLK_SHIFT;
 
 	data64 = (uint64_t *) data;
 	data64[0] = cpu_to_be64(size - 1);
-	data[2] = cpu_to_be32(1UL << blk_shift);
+	data[2] = cpu_to_be32(1UL << BLK_SHIFT);
 
 	*len = 32;
 
@@ -559,7 +559,7 @@
 		break;
 	}
 
-	off <<= 9;
+	off <<= BLK_SHIFT;
 
 	if (*uaddr)
 		*uaddr = *uaddr + off;



From tomo at berlios.de  Wed Feb 22 12:19:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 22 Feb 2006 12:19:47 +0100
Subject: [Stgt-svn] r309 - branches/use-scsi-ml/kernel
Message-ID: <200602221119.k1MBJliH030092@sheep.berlios.de>

Author: tomo
Date: 2006-02-22 12:19:46 +0100 (Wed, 22 Feb 2006)
New Revision: 309

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Fix double locking bug.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-19 07:55:48 UTC (rev 308)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-22 11:19:46 UTC (rev 309)
@@ -68,6 +68,7 @@
 {
 	struct scsi_cmnd *cmd = data;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+	struct request_queue *q = cmd->request->q;
 
 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
 		rq_data_dir(cmd->request));
@@ -122,8 +123,10 @@
 		tcmd = rq->end_io_data;
 
 		/* the completion code kicks us in case we hit this */
-		if (blk_queue_start_tag(q, rq))
+		if (blk_queue_start_tag(q, rq)) {
+			eprintk("failed to tag: %p\n", cmd);
 			break;
+		}
 
 		spin_unlock_irq(q->queue_lock);
 		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
@@ -136,7 +139,7 @@
 	spin_lock_irq(q->queue_lock);
 	/* need to track cnts and plug */
 	blk_requeue_request(q, rq);
-	spin_lock_irq(q->queue_lock);
+	spin_unlock_irq(q->queue_lock);
 }
 
 /**



From tomo at berlios.de  Wed Feb 22 12:20:51 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 22 Feb 2006 12:20:51 +0100
Subject: [Stgt-svn] r310 - branches/use-scsi-ml/kernel
Message-ID: <200602221120.k1MBKpkV030209@sheep.berlios.de>

Author: tomo
Date: 2006-02-22 12:20:50 +0100 (Wed, 22 Feb 2006)
New Revision: 310

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
Log:
Elaborate debug code in scsi_tgt_uspace_send().

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-22 11:19:46 UTC (rev 309)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-22 11:20:50 UTC (rev 310)
@@ -83,7 +83,7 @@
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
 
-	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
+	dprintk("%p %d %u %u\n", cmd, ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
 		ev->k.cmd_req.data_len);
 
 	/* FIXME: we need scsi core to do that. */



From tomo at berlios.de  Wed Feb 22 12:27:11 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 22 Feb 2006 12:27:11 +0100
Subject: [Stgt-svn] r311 - branches/use-scsi-ml/kernel
Message-ID: <200602221127.k1MBRBiM031004@sheep.berlios.de>

Author: tomo
Date: 2006-02-22 12:27:11 +0100 (Wed, 22 Feb 2006)
New Revision: 311

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
if blk_queue_start_tag() fails and no more new commands don't come,
nobody call blk_plug_device().


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-22 11:20:50 UTC (rev 310)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-22 11:27:11 UTC (rev 311)
@@ -85,6 +85,7 @@
 	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
+	blk_run_queue(q);
 }
 
 static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)



From tomo at berlios.de  Thu Feb 23 06:27:52 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 23 Feb 2006 06:27:52 +0100
Subject: [Stgt-svn] r312 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602230527.k1N5RqNR031885@sheep.berlios.de>

Author: tomo
Date: 2006-02-23 06:27:50 +0100 (Thu, 23 Feb 2006)
New Revision: 312

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Export system information for user space through SCSI sysfs. They are necessary for building inquiry responses.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-22 11:27:11 UTC (rev 311)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-23 05:27:50 UTC (rev 312)
@@ -1093,6 +1093,39 @@
 	return 0;
 }
 
+#define	host_to_adapter(x)	(((struct server_adapter *) x->hostdata))
+
+static ssize_t
+system_id_show(struct class_device *cdev, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
+}
+
+static ssize_t
+partition_number_show(struct class_device *cdev, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
+}
+
+static ssize_t
+unit_address_show(struct class_device *cdev, char *buf)
+{
+	struct Scsi_Host *shost = class_to_shost(cdev);
+	struct server_adapter *adapter = host_to_adapter(shost);
+	return snprintf(buf, PAGE_SIZE, "%x\n", adapter->dma_dev->unit_address);
+}
+
+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
+
+static struct class_device_attribute *ibmvstgt_attrs[] = {
+	&class_device_attr_system_id,
+	&class_device_attr_partition_number,
+	&class_device_attr_unit_address,
+	NULL,
+};
+
 static struct scsi_host_template ibmvstgt_sht = {
 	.name			= TGT_NAME,
 	.module			= THIS_MODULE,
@@ -1103,6 +1136,7 @@
 	.transfer_response	= ibmvstgt_cmd_done,
 	.transfer_data		= recv_cmd_data,
 	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
+	.shost_attrs		= ibmvstgt_attrs,
 	.proc_name		= TGT_NAME,
 };
 



From tomo at berlios.de  Thu Feb 23 06:56:23 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 23 Feb 2006 06:56:23 +0100
Subject: [Stgt-svn] r313 - branches/use-scsi-ml/usr
Message-ID: <200602230556.k1N5uN2Q018856@sheep.berlios.de>

Author: tomo
Date: 2006-02-23 06:56:15 +0100 (Thu, 23 Feb 2006)
New Revision: 313

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Add another nasty hack for ibmvstgt. I need to separete them from stuff for generic LLDs later on.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-23 05:27:50 UTC (rev 312)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-23 05:56:15 UTC (rev 313)
@@ -65,6 +65,10 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
+#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
+#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
+#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
+
 static int device_info(int tid, uint64_t lun, uint64_t *size)
 {
 	int fd, err;
@@ -166,6 +170,8 @@
 	uint8_t pcode = scb[2] & 0x3f;
 	uint64_t size;
 
+	eprintf("%d %" PRIx64 " %x %x\n", tid, lun, pcode, scb[1]);
+
 	if (device_info(tid, lun, &size) < 0) {
 		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 					0x25, 0);
@@ -229,17 +235,102 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-static int inquiry(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+struct inquiry_data {
+	uint8_t qual_type;
+	uint8_t rmb_reserve;
+	uint8_t version;
+	uint8_t aerc_naca_hisup_format;
+	uint8_t addl_len;
+	uint8_t sccs_reserved;
+	uint8_t bque_encserv_vs_multip_mchngr_reserved;
+	uint8_t reladr_reserved_linked_cmdqueue_vs;
+	char vendor[8];
+	char product[16];
+	char revision[4];
+	char vendor_specific[20];
+	char reserved1[2];
+	char version_descriptor[16];
+	char reserved2[22];
+	char unique[158];
+};
+
+#define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
+
+static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
 {
-	uint64_t size;
+	struct inquiry_data *id = (struct inquiry_data *) data;
+	char system_id[256], path[256], buf[32];
+	int fd, err, partition_number;
+	unsigned int unit_address;
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
+	fd = open(path, O_RDONLY);
+	memset(system_id, 0, sizeof(system_id));
+	err = read(fd, system_id, sizeof(system_id));
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/partition_number",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	partition_number = strtoul(buf, NULL, 10);
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/unit_address",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	unit_address = strtoul(buf, NULL, 0);
+	close(fd);
+
+	eprintf("%d %s %d %x %" PRIx64 "\n",
+		host_no, system_id, partition_number, unit_address, lun);
+
+	id->qual_type = TYPE_DISK;
+	id->rmb_reserve = 0x00;
+	id->version = 0x84;	/* ISO/IE		  */
+	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
+	id->addl_len = sizeof(*id) - 4;
+	id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
+	id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
+	memcpy(id->vendor, "IBM	    ", 8);
+	/* Don't even ask about the next bit.  AIX uses
+	 * hardcoded device naming to recognize device types
+	 * and their client won't  work unless we use VOPTA and
+	 * VDASD.
+	 */
+	memcpy(id->product, "VDASD blkdev    ", 16);
+	memcpy(id->revision, "0001", 4);
+	snprintf(id->unique,sizeof(id->unique),
+		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
+		 system_id,
+		 partition_number,
+		 unit_address,
+		 GETBUS(lun),
+		 GETTARGET(lun),
+		 GETLUN(lun));
+
+	return sizeof(*id);
+}
+
+static int inquiry(int host_no, int tid, uint8_t *lun_buf,
+		   uint8_t *scb, uint8_t *data, int *len)
+{
+	uint64_t size, lun;
 	int err, result = SAM_STAT_CHECK_CONDITION;
 
+	lun = scsi_get_devid(lun_buf);
+
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
 	err = device_info(tid, lun, &size);
 
+	dprintf("%" PRIx64 " %d %x %x\n", lun, err, scb[1], scb[2]);
+
 	if (!(scb[1] & 0x3)) {
+		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
+#if 0
 		data[2] = 4;
 		data[3] = 0x42;
 		data[4] = 59;
@@ -258,6 +349,7 @@
 		data[62] = 0x03;
 		data[63] = 0x00;
 		*len = 64;
+#endif
 		result = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
@@ -316,7 +408,8 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int report_luns(int tid, uint32_t unused, uint8_t *scb, uint8_t *p, int *len)
+static int report_luns(int tid, uint8_t *lun_buf, uint8_t *scb, uint8_t *p,
+		       int *len)
 {
 	uint64_t lun, *data = (uint64_t *) p;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
@@ -344,6 +437,12 @@
 	alen &= ~(8 - 1);
 	oalen = alen;
 
+	if ((*((uint64_t *) lun_buf))) {
+		eprintf("Another sick hack for ibmvstgt\n");
+		nr_luns = 1;
+		goto done;
+	}
+
 	alen -= 8;
 	rbuflen -= 8; /* FIXME */
 	idx = 1;
@@ -372,7 +471,8 @@
 		}
 	}
 
-	*data = (cpu_to_be64(nr_luns * 8) << 32);
+done:
+	*((uint32_t *) data) = cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
 out:
 	closedir(dir);
@@ -605,10 +705,6 @@
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
 
-#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
-#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
-#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
-
 uint64_t scsi_get_devid(uint8_t *p)
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
@@ -638,13 +734,16 @@
 	return lun;
 }
 
-int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
+int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		     uint8_t *try_map, uint64_t *offset, uint64_t lun)
+		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf)
 {
 	int fd, result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;
+	uint64_t lun;
 
+	lun = scsi_get_devid(lun_buf);
+
 	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
 
 	*offset = 0;
@@ -669,10 +768,10 @@
 
 	switch (scb[0]) {
 	case INQUIRY:
-		result = inquiry(tid, lun, scb, data, len);
+		result = inquiry(host_no, tid, lun_buf, scb, data, len);
 		break;
 	case REPORT_LUNS:
-		result = report_luns(tid, lun, scb, data, len);
+		result = report_luns(tid, lun_buf, scb, data, len);
 		break;
 	case READ_CAPACITY:
 		result = read_capacity(tid, lun, scb, data, len);
@@ -725,7 +824,7 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		dprintf("BUG? %u %" PRIu64 "\n", scb[0], lun);
+		eprintf("BUG? %u %" PRIu64 "\n", scb[0], lun);
 		*len = 0;
 		break;
 	}

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-23 05:27:50 UTC (rev 312)
+++ branches/use-scsi-ml/usr/target.c	2006-02-23 05:56:15 UTC (rev 313)
@@ -371,9 +371,9 @@
 	if (device)
 		uaddr = target->devt[dev_id]->addr;
 
-	result = scsi_cmd_process(target->tid, scmd->scb, &len,
+	result = scsi_cmd_process(host_no, target->tid, scmd->scb, &len,
 				  ev_req->k.cmd_req.data_len,
-				  &uaddr, &rw, &try_map, &offset, dev_id);
+				  &uaddr, &rw, &try_map, &offset, scmd->lun);
 
 	dprintf("%u %x %lx %" PRIu64 " %d\n",
 		cid, scmd->scb[0], uaddr, offset, result);

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-23 05:27:50 UTC (rev 312)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-23 05:56:15 UTC (rev 313)
@@ -24,9 +24,9 @@
 extern int tgt_target_bind(int tid, int host_no);
 
 extern uint64_t scsi_get_devid(uint8_t *pdu);
-extern int scsi_cmd_process(int tid, uint8_t *pdu, int *len,
+extern int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-			    uint8_t *try_map, uint64_t *offset, uint64_t lun);
+			    uint8_t *try_map, uint64_t *offset, uint8_t *lun);
 extern int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len);
 
 #endif



From tomo at berlios.de  Thu Feb 23 06:57:38 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 23 Feb 2006 06:57:38 +0100
Subject: [Stgt-svn] r314 - branches/use-scsi-ml/kernel
Message-ID: <200602230557.k1N5vctK019348@sheep.berlios.de>

Author: tomo
Date: 2006-02-23 06:57:37 +0100 (Thu, 23 Feb 2006)
New Revision: 314

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Add workaround to avoid out of request situation. We need to fix it properly later on.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-23 05:56:15 UTC (rev 313)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-23 05:57:37 UTC (rev 314)
@@ -130,8 +130,10 @@
 		}
 
 		spin_unlock_irq(q->queue_lock);
-		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
+		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0) {
+			eprintk("failed to send: %p\n", cmd);
 			goto requeue;
+		}
 		spin_lock_irq(q->queue_lock);
 	}
 
@@ -183,8 +185,8 @@
 	 * command as is recvd to userspace. uspace can then make
 	 * sure we do not overload the HBA
 	 */
-	q->nr_requests = shost->hostt->can_queue;
-	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
+	q->nr_requests = shost->hostt->can_queue * 2;
+	blk_queue_init_tags(q, q->nr_requests, NULL);
 	/*
 	 * We currently only support software LLDs so this does
 	 * not matter for now. Do we need this for the cards we support?



From tomo at berlios.de  Thu Feb 23 08:57:21 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 23 Feb 2006 08:57:21 +0100
Subject: [Stgt-svn] r315 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602230757.k1N7vLXT024241@sheep.berlios.de>

Author: tomo
Date: 2006-02-23 08:56:59 +0100 (Thu, 23 Feb 2006)
New Revision: 315

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Set the task attribute.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-23 05:57:37 UTC (rev 314)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-23 07:56:59 UTC (rev 315)
@@ -36,6 +36,7 @@
 #include <asm/vio.h>
 
 #include "viosrp.h"
+#include "srp.h"
 
 #define DEFAULT_TIMEOUT		30*HZ
 #define	INITIAL_SRP_LIMIT	16
@@ -113,6 +114,13 @@
 	V_DONE,
 };
 
+enum srp_task_attributes {
+	SRP_SIMPLE_TASK = 0,
+	SRP_HEAD_TASK = 1,
+	SRP_ORDERED_TASK = 2,
+	SRP_ACA_TASK = 4
+};
+
 /*
  * This structure tracks our fundamental unit of work.  Whenever
  * an SRP Information Unit (IU) arrives, we track all the good stuff
@@ -314,31 +322,31 @@
 	union viosrp_iu *iu = vio_iu(iue);
 	enum dma_data_direction data_dir;
 	struct scsi_cmnd *scmd;
-	int tags, len;
+	int tag, len;
 
 	dprintk("%p %p\n", iue->adapter, iue);
 
 	if (getlink(iue))
 		__set_bit(V_LINKED, &iue->req.flags);
 
-	tags = MSG_SIMPLE_TAG;
-#if 0
+	tag = MSG_SIMPLE_TAG;
+
 	switch (iu->srp.cmd.task_attribute) {
 	case SRP_SIMPLE_TASK:
-		tags = MSG_SIMPLE_TAG;
+		tag = MSG_SIMPLE_TAG;
 		break;
 	case SRP_ORDERED_TASK:
-		tags = MSG_ORDERED_TAG;
+		tag = MSG_ORDERED_TAG;
 		break;
 	case SRP_HEAD_TASK:
-		tags = MSG_HEAD_TAG;
+		tag = MSG_HEAD_TAG;
 		break;
 	default:
 		eprintk("Task attribute %d not supported, assuming barrier\n",
 			iu->srp.cmd.task_attribute);
-		tags = MSG_ORDERED_TAG;
+		tag = MSG_ORDERED_TAG;
 	}
-#endif
+
 	switch (iu->srp.cmd.cdb[0]) {
 	case WRITE_6:
 	case WRITE_10:
@@ -357,7 +365,7 @@
 	}
 
 	dprintk("%p %x %lx %d %d %d %llx\n",
-		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags,
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tag,
 		(unsigned long long) iu->srp.cmd.tag);
 
 	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
@@ -366,10 +374,11 @@
 	scmd->SCp.ptr = (char *) iue;
 	memcpy(scmd->data_cmnd, iu->srp.cmd.cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = len;
+	scmd->tag= tag;
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
 
 	dprintk("%p %p %x %lx %d %d %d\n",
-		iue, scmd, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
+		iue, scmd, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tag);
 
 	return 0;
 }



From tomo at berlios.de  Thu Feb 23 12:11:39 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 23 Feb 2006 12:11:39 +0100
Subject: [Stgt-svn] r316 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602231111.k1NBBdU1011994@sheep.berlios.de>

Author: tomo
Date: 2006-02-23 12:11:36 +0100 (Thu, 23 Feb 2006)
New Revision: 316

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Stop including an unnecessary header.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-23 07:56:59 UTC (rev 315)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-23 11:11:36 UTC (rev 316)
@@ -36,7 +36,6 @@
 #include <asm/vio.h>
 
 #include "viosrp.h"
-#include "srp.h"
 
 #define DEFAULT_TIMEOUT		30*HZ
 #define	INITIAL_SRP_LIMIT	16



From tomo at berlios.de  Sat Feb 25 18:19:46 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 25 Feb 2006 18:19:46 +0100
Subject: [Stgt-svn] r317 - branches/use-scsi-ml/patchset
Message-ID: <200602251719.k1PHJkoC027923@sheep.berlios.de>

Author: tomo
Date: 2006-02-25 18:19:44 +0100 (Sat, 25 Feb 2006)
New Revision: 317

Modified:
   branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt
   branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt
   branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
Log:
Update the patchset.

Modified: branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0001-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -16,11 +16,9 @@
 the command we are at. Is there another field on the scsi_cmd for
 that?
 
-
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
-
 ---
 
  drivers/scsi/hosts.c     |    5 +++
@@ -30,9 +28,9 @@
  include/scsi/scsi_host.h |   40 ++++++++++++++++++++
  5 files changed, 168 insertions(+), 9 deletions(-)
 
-4ab7d1a25185748e2aaf86b30784c280bbf5de2b
+b7a992fe8af27b25c30fc5e7c36abfe6ebb6fe84
 diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index ef57f25..a122624 100644
+index 5881079..64e687a 100644
 --- a/drivers/scsi/hosts.c
 +++ b/drivers/scsi/hosts.c
 @@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
@@ -48,10 +46,10 @@
  	kfree(shost->shost_data);
  
 diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index d182bad..701973e 100644
+index 245ca99..a2295ed 100644
 --- a/drivers/scsi/scsi.c
 +++ b/drivers/scsi/scsi.c
-@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
+@@ -236,6 +236,58 @@ static struct scsi_cmnd *__scsi_get_comm
  }
  
  /*
@@ -110,7 +108,7 @@
   * Function:	scsi_get_command()
   *
   * Purpose:	Allocate and setup a scsi command block
-@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
+@@ -274,6 +326,45 @@ struct scsi_cmnd *scsi_get_command(struc
  EXPORT_SYMBOL(scsi_get_command);
  
  /*
@@ -157,10 +155,10 @@
   *
   * Purpose:	Free a scsi command block
 diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 5ac8749..2dcc500 100644
+index 4362dcd..7307705 100644
 --- a/drivers/scsi/scsi_lib.c
 +++ b/drivers/scsi/scsi_lib.c
-@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+@@ -804,7 +804,7 @@ static struct scsi_cmnd *scsi_end_reques
  	return NULL;
  }
  
@@ -169,7 +167,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  	struct scatterlist *sgl;
-@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+@@ -845,7 +845,9 @@ static struct scatterlist *scsi_alloc_sg
  	return sgl;
  }
  
@@ -180,7 +178,7 @@
  {
  	struct scsi_host_sg_pool *sgp;
  
-@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+@@ -855,6 +857,8 @@ static void scsi_free_sgtable(struct sca
  	mempool_free(sgl, sgp->pool);
  }
  
@@ -189,7 +187,7 @@
  /*
   * Function:    scsi_release_buffers()
   *
-@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+@@ -1687,29 +1691,40 @@ u64 scsi_calculate_bounce_limit(struct S
  }
  EXPORT_SYMBOL(scsi_calculate_bounce_limit);
  
@@ -238,7 +236,7 @@
  void scsi_free_queue(struct request_queue *q)
  {
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..8f64515 100644
+index 7529f43..51156c7 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
 @@ -8,6 +8,7 @@
@@ -346,4 +344,4 @@
   * These two functions are used to allocate and free a pseudo device
   * which will connect to the host adapter itself rather than any
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0002-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -12,10 +12,9 @@
 good and not sending misaligned lens or that path is not used very
 often and this change will not be very dangerous. st and sg do not
 check the length and we have not seen any problem reports from those
-wider used paths so this patch should be fairly safe - for mm 
+wider used paths so this patch should be fairly safe - for mm
 and wider testing at least.
 
-
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
@@ -24,7 +23,7 @@
  fs/bio.c |    5 ++---
  1 files changed, 2 insertions(+), 3 deletions(-)
 
-8e515bd33c31c8dc5e9727792d2c3cbe08bc28e1
+20ed0ebdd84e1a93550413f487dceaf1ab29a2cd
 diff --git a/fs/bio.c b/fs/bio.c
 index 1f3bb50..d8259d9 100644
 --- a/fs/bio.c
@@ -43,4 +42,4 @@
  	}
  
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0003-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -9,117 +9,140 @@
 To do this, tgt core will map in as much data as possible into a bio,
 send this off, then when that transfer is completed we send off another
 request/bio. To be able to pack as much data into a bio as possible
-we need bio_map_user to support partially mapped bios. The attached patch
-just adds a new argument to the those functions and if set will not
-return a failure if the bio is partially mapped.
+we need bio_map_user to support partially mapped bios.
 
+The attached patch allows bio_map_user to map bios partially. The two
+users (blk_rq_map_user and blk_rq_map_user_iov) will fail if the bio
+is partially mapped.
 
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
 ---
 
- block/ll_rw_blk.c   |    5 +++--
- fs/bio.c            |   11 +++++++----
- include/linux/bio.h |    5 +++--
- 3 files changed, 13 insertions(+), 8 deletions(-)
+ block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
+ block/scsi_ioctl.c     |    3 ++-
+ fs/bio.c               |   14 +-------------
+ include/linux/blkdev.h |    3 ++-
+ 4 files changed, 23 insertions(+), 26 deletions(-)
 
-97fbe8e42375284c82814b95cde3bc18c00721cd
+95e0133e03f75a5edc7ca4eb7ce0c0347cf841bf
 diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index f9fc07e..65c56b6 100644
+index 03d9c82..6849859 100644
 --- a/block/ll_rw_blk.c
 +++ b/block/ll_rw_blk.c
-@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
- 	 */
- 	uaddr = (unsigned long) ubuf;
- 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
--		bio = bio_map_user(q, NULL, uaddr, len, reading);
-+		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
+@@ -2291,19 +2291,20 @@ int blk_rq_map_user(request_queue_t *q, 
  	else
  		bio = bio_copy_user(q, uaddr, len, reading);
  
-@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
- 	/* we don't allow misaligned data like bio_map_user() does.  If the
- 	 * user is using sg, they're expected to know the alignment constraints
- 	 * and respect them accordingly */
--	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
-+	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
-+				0);
+-	if (!IS_ERR(bio)) {
+-		rq->bio = rq->biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq->buffer = rq->data = NULL;
+-		rq->data_len = len;
+-		return 0;
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq->bio = rq->biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq->buffer = rq->data = NULL;
++	rq->data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2329,7 +2330,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2343,6 +2344,12 @@ int blk_rq_map_user_iov(request_queue_t 
  	if (IS_ERR(bio))
  		return PTR_ERR(bio);
  
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq->bio = rq->biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq->buffer = rq->data = NULL;
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index 24f7af9..ef9900d 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
++					  hdr->dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
 diff --git a/fs/bio.c b/fs/bio.c
-index 1f3bb50..fd1e419 100644
+index 1f3bb50..f75c2f4 100644
 --- a/fs/bio.c
 +++ b/fs/bio.c
-@@ -719,19 +719,21 @@ static struct bio *__bio_map_user_iov(re
-  *	@uaddr: start of user address
-  *	@len: length in bytes
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
--			 unsigned long uaddr, unsigned int len, int write_to_vm)
-+			 unsigned long uaddr, unsigned int len, int write_to_vm,
-+			 int support_partial)
+@@ -750,7 +750,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
  {
- 	struct sg_iovec iov;
+ 	struct bio *bio;
+-	int len = 0, i;
  
- 	iov.iov_base = (void __user *)uaddr;
- 	iov.iov_len = len;
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
  
--	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
-+	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
- }
+@@ -765,18 +764,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
  
- /**
-@@ -741,13 +743,14 @@ struct bio *bio_map_user(request_queue_t
-  *	@iov:	the iovec.
-  *	@iov_count: number of elements in the iovec
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
- 			     struct sg_iovec *iov, int iov_count,
--			     int write_to_vm)
-+			     int write_to_vm, int support_partial)
- {
- 	struct bio *bio;
- 	int len = 0, i;
-@@ -768,7 +771,7 @@ struct bio *bio_map_user_iov(request_que
- 	for (i = 0; i < iov_count; i++)
- 		len += iov[i].iov_len;
- 
+-	for (i = 0; i < iov_count; i++)
+-		len += iov[i].iov_len;
+-
 -	if (bio->bi_size == len)
-+	if (bio->bi_size == len || support_partial)
- 		return bio;
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio->bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
  
- 	/*
-diff --git a/include/linux/bio.h b/include/linux/bio.h
-index b60ffe3..fc0906c 100644
---- a/include/linux/bio.h
-+++ b/include/linux/bio.h
-@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
- extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
- 			   unsigned int, unsigned int);
- extern int bio_get_nr_vecs(struct block_device *);
-+extern int __bio_get_nr_vecs(struct request_queue *);
- extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
--				unsigned long, unsigned int, int);
-+				unsigned long, unsigned int, int, int);
- struct sg_iovec;
- extern struct bio *bio_map_user_iov(struct request_queue *,
- 				    struct block_device *,
--				    struct sg_iovec *, int, int);
-+				    struct sg_iovec *, int, int, int);
- extern void bio_unmap_user(struct bio *);
- extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
- 				gfp_t);
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index 860e7a4..619ef1d 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -611,7 +611,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0004-core-scsi-target-fns.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -1,4 +1,4 @@
-The core scsi target lib functions.
+Subject: [PATCH] The core scsi target lib functions.
 
 TODO:
 - mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
@@ -19,17 +19,26 @@
 model in userspace).
 - must remove our request->flags hack
 
-
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
+---
 
+ drivers/scsi/scsi_tgt_lib.c  |  556 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   25 ++
+ include/scsi/scsi_tgt.h      |   11 +
+ 3 files changed, 592 insertions(+), 0 deletions(-)
+ create mode 100644 drivers/scsi/scsi_tgt_lib.c
+ create mode 100644 drivers/scsi/scsi_tgt_priv.h
+ create mode 100644 include/scsi/scsi_tgt.h
+
+ef599065dcacab6ed526d6156a369ed478d595a2
 diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
 new file mode 100644
-index 0000000..8746236
+index 0000000..4665ce4
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,550 @@
+@@ -0,0 +1,556 @@
 +/*
 + * SCSI target lib functions
 + *
@@ -100,6 +109,7 @@
 +{
 +	struct scsi_cmnd *cmd = data;
 +	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct request_queue *q = cmd->request->q;
 +
 +	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
 +		rq_data_dir(cmd->request));
@@ -116,6 +126,7 @@
 +	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
 +	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 +	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++	blk_run_queue(q);
 +}
 +
 +static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
@@ -154,12 +165,16 @@
 +		tcmd = rq->end_io_data;
 +
 +		/* the completion code kicks us in case we hit this */
-+		if (blk_queue_start_tag(q, rq))
++		if (blk_queue_start_tag(q, rq)) {
++			eprintk("failed to tag: %p\n", cmd);
 +			break;
++		}
 +
 +		spin_unlock_irq(q->queue_lock);
-+		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0)
++		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0) {
++			eprintk("failed to send: %p\n", cmd);
 +			goto requeue;
++		}
 +		spin_lock_irq(q->queue_lock);
 +	}
 +
@@ -168,7 +183,7 @@
 +	spin_lock_irq(q->queue_lock);
 +	/* need to track cnts and plug */
 +	blk_requeue_request(q, rq);
-+	spin_lock_irq(q->queue_lock);
++	spin_unlock_irq(q->queue_lock);
 +}
 +
 +/**
@@ -211,8 +226,8 @@
 +	 * command as is recvd to userspace. uspace can then make
 +	 * sure we do not overload the HBA
 +	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
++	q->nr_requests = shost->hostt->can_queue * 2;
++	blk_queue_init_tags(q, q->nr_requests, NULL);
 +	/*
 +	 * We currently only support software LLDs so this does
 +	 * not matter for now. Do we need this for the cards we support?
@@ -347,7 +362,7 @@
 +
 +	while (len > 0) {
 +		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
 +		if (IS_ERR(bio)) {
 +			err = PTR_ERR(bio);
 +			dprintk("fail to map %lx %u %d %x\n",
@@ -470,16 +485,16 @@
 +	return 0;
 +}
 +
-+int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
-+			 unsigned long uaddr, u8 rw, u8 try_map)
++int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
++			 unsigned long uaddr, u8 rw)
 +{
 +	struct Scsi_Host *shost;
 +	struct scsi_cmnd *cmd;
 +	struct request *rq;
 +	int err = 0;
 +
-+	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
-+		len, (unsigned long long) offset, uaddr, rw, try_map);
++	dprintk("%d %u %d %u %lx %u\n", host_no, cid, result,
++		len, uaddr, rw);
 +
 +	/* TODO: replace with a O(1) alg */
 +	shost = scsi_host_lookup(host_no);
@@ -582,7 +597,7 @@
 +MODULE_LICENSE("GPL");
 diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
 new file mode 100644
-index 0000000..4236e50
+index 0000000..fcf2ec6
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_priv.h
 @@ -0,0 +1,25 @@
@@ -609,8 +624,8 @@
 +extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
 +extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 +extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-+				u64 offset, unsigned long uaddr, u8 rw,
-+				u8 try_map);
++				unsigned long uaddr, u8 rw);
++
 diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
 new file mode 100644
 index 0000000..91ad6bc
@@ -628,3 +643,5 @@
 +extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
 +extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
 +extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
+-- 
+1.1.5

Modified: branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt
===================================================================
--- branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0005-scsi-target-netlink-if.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -1,4 +1,4 @@
-Netlink interface for the scsi tgt framework.
+Subject: [PATCH] Netlink interface for the scsi tgt framework.
 
 I did not think the netdev people wanted to see the scsi and
 block layer code, so I am just send the netlink interface part
@@ -20,13 +20,22 @@
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
+---
 
+ drivers/scsi/scsi_tgt_if.c |  205 ++++++++++++++++++++++++++++++++++++++++++++
+ include/linux/netlink.h    |    1 
+ include/scsi/scsi_tgt_if.h |   88 +++++++++++++++++++
+ 3 files changed, 294 insertions(+), 0 deletions(-)
+ create mode 100644 drivers/scsi/scsi_tgt_if.c
+ create mode 100644 include/scsi/scsi_tgt_if.h
+
+5e0ec5395f282e9dd5802940046eb0f3cdfdbec5
 diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
 new file mode 100644
-index 0000000..38b35da
+index 0000000..0780e3c
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,214 @@
+@@ -0,0 +1,205 @@
 +/*
 + * SCSI target kernel/user interface functions
 + *
@@ -64,15 +73,15 @@
 +static int tgtd_pid;
 +static struct sock *nl_sk;
 +
-+static int send_event_res(uint16_t type, struct tgt_event *p,
-+			  void *data, int dlen, gfp_t flags, pid_t pid)
++static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
++			  pid_t pid)
 +{
 +	struct tgt_event *ev;
 +	struct nlmsghdr *nlh;
 +	struct sk_buff *skb;
 +	uint32_t len;
 +
-+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
++	len = NLMSG_SPACE(sizeof(*ev));
 +	skb = alloc_skb(len, flags);
 +	if (!skb)
 +		return -ENOMEM;
@@ -81,8 +90,6 @@
 +
 +	ev = NLMSG_DATA(nlh);
 +	memcpy(ev, p, sizeof(*ev));
-+	if (dlen)
-+		memcpy(ev->data, data, dlen);
 +
 +	return netlink_unicast(nl_sk, skb, pid, 0);
 +}
@@ -93,10 +100,12 @@
 +	struct sk_buff *skb;
 +	struct nlmsghdr *nlh;
 +	struct tgt_event *ev;
-+	struct tgt_cmd *tcmd;
 +	int err, len;
 +
-+	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
++	/* FIXME: we need scsi core to do that. */
++	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
++
++	len = NLMSG_SPACE(sizeof(*ev));
 +	/*
 +	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
 +	 */
@@ -111,21 +120,16 @@
 +	ev->k.cmd_req.host_no = shost->host_no;
 +	ev->k.cmd_req.cid = cmd->request->tag;
 +	ev->k.cmd_req.data_len = cmd->request_bufflen;
++	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
++	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
++	ev->k.cmd_req.attribute = cmd->tag;
 +
-+	dprintk("%d %u %u\n", ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
-+		ev->k.cmd_req.data_len);
++	dprintk("%p %d %u %u %x\n", cmd, shost->host_no, ev->k.cmd_req.cid,
++		ev->k.cmd_req.data_len, cmd->tag);
 +
-+	/* FIXME: we need scsi core to do that. */
-+	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-+
-+	tcmd = (struct tgt_cmd *) ev->data;
-+	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
-+	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
-+
 +	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
 +	if (err < 0)
-+		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
-+		       err);
++		eprintk(KERN_ERR "could not send skb %d\n", err);
 +	return err;
 +}
 +
@@ -133,15 +137,13 @@
 +{
 +	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 +	struct tgt_event ev;
-+	char dummy[sizeof(struct tgt_cmd)];
 +
 +	memset(&ev, 0, sizeof(ev));
 +	ev.k.cmd_done.host_no = shost->host_no;
 +	ev.k.cmd_done.cid = cmd->request->tag;
 +	ev.k.cmd_done.result = cmd->result;
 +
-+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-+			      gfp_mask, tgtd_pid);
++	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
 +}
 +
 +static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -153,19 +155,17 @@
 +		nlh->nlmsg_pid, current->pid);
 +
 +	switch (nlh->nlmsg_type) {
-+	case TGT_UEVENT_TGTD_BIND:
++	case TGT_UEVENT_REQ:
 +		tgtd_pid = NETLINK_CREDS(skb)->pid;
 +		break;
-+	case TGT_UEVENT_CMD_RES:
++	case TGT_UEVENT_CMD_RSP:
 +		/* TODO: handle multiple cmds in one event */
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
-+					   ev->u.cmd_res.cid,
-+					   ev->u.cmd_res.result,
-+					   ev->u.cmd_res.len,
-+					   ev->u.cmd_res.offset,
-+					   ev->u.cmd_res.uaddr,
-+					   ev->u.cmd_res.rw,
-+					   ev->u.cmd_res.try_map);
++		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
++					   ev->u.cmd_rsp.cid,
++					   ev->u.cmd_rsp.result,
++					   ev->u.cmd_rsp.len,
++					   ev->u.cmd_rsp.uaddr,
++					   ev->u.cmd_rsp.rw);
 +		break;
 +	default:
 +		eprintk("unknown type %d\n", nlh->nlmsg_type);
@@ -195,12 +195,12 @@
 +		 * TODO for passthru commands the lower level should
 +		 * probably handle the result or we should modify this
 +		 */
-+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
++		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RSP) {
 +			struct tgt_event ev;
 +
 +			memset(&ev, 0, sizeof(ev));
-+			ev.k.event_res.err = err;
-+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
++			ev.k.event_rsp.err = err;
++			send_event_rsp(TGT_KEVENT_RSP, &ev,
 +				       GFP_KERNEL | __GFP_NOFAIL,
 +					nlh->nlmsg_pid);
 +		}
@@ -242,7 +242,7 @@
 +	return 0;
 +}
 diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 6a2ccf7..580fb42 100644
+index c256ebe..9422ae5 100644
 --- a/include/linux/netlink.h
 +++ b/include/linux/netlink.h
 @@ -21,6 +21,7 @@
@@ -255,7 +255,7 @@
  
 diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
 new file mode 100644
-index 0000000..da3a808
+index 0000000..ebca452
 --- /dev/null
 +++ b/include/scsi/scsi_tgt_if.h
 @@ -0,0 +1,88 @@
@@ -285,65 +285,67 @@
 +
 +enum tgt_event_type {
 +	/* user -> kernel */
-+	TGT_UEVENT_TGTD_BIND,
-+	TGT_UEVENT_TARGET_SETUP,
-+	TGT_UEVENT_CMD_RES,
++	TGT_UEVENT_REQ,
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
 +
 +	/* kernel -> user */
-+	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_RSP,
 +	TGT_KEVENT_CMD_REQ,
 +	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
 +};
 +
 +struct tgt_event {
 +	/* user-> kernel */
 +	union {
 +		struct {
-+			int pk_fd;
-+		} tgtd_bind;
++			int type;
++			int host_no;
++		} event_req;
 +		struct {
 +			int host_no;
 +			uint32_t cid;
 +			uint32_t len;
 +			int result;
 +			uint64_t uaddr;
-+			uint64_t offset;
 +			uint8_t rw;
-+			uint8_t try_map;
-+		} cmd_res;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			int mid;
++			int result;
++		} tsk_mgmt_rsp;
 +	} u;
 +
 +	/* kernel -> user */
 +	union {
 +		struct {
 +			int err;
-+		} event_res;
++		} event_rsp;
 +		struct {
 +			int host_no;
 +			uint32_t cid;
 +			uint32_t data_len;
-+			uint64_t dev_id;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
 +		} cmd_req;
 +		struct {
 +			int host_no;
 +			uint32_t cid;
 +			int result;
 +		} cmd_done;
++		struct {
++			int host_no;
++			int mid;
++			uint64_t tag;
++			uint8_t lun[8];
++			int function;
++		} tsk_mgmt_req;
 +	} k;
 +
-+	/*
-+	 * I think a pointer is a unsigned long but this struct
-+	 * gets passed around from the kernel to userspace and
-+	 * back again so to handle some ppc64 setups where userspace is
-+	 * 32 bits but the kernel is 64 we do this odd thing
-+	 */
-+	uint64_t data[0];
 +} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+struct tgt_cmd {
-+	uint8_t scb[16];
-+	uint8_t lun[8];
-+	int tags;
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
 +#endif
+-- 
+1.1.5

Modified: branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt
===================================================================
--- branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-23 11:11:36 UTC (rev 316)
+++ branches/use-scsi-ml/patchset/0006-scsi-ml-Makefile-and-Kconfig-changes-for-stgt.txt	2006-02-25 17:19:44 UTC (rev 317)
@@ -1,19 +1,17 @@
 Subject: [PATCH] scsi-ml: Makefile and Kconfig changes for stgt
 
-
 Makefile and Kconfig stuff.
 
 Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
 Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 
-
 ---
 
  drivers/scsi/Kconfig  |    7 +++++++
  drivers/scsi/Makefile |    3 +++
  2 files changed, 10 insertions(+), 0 deletions(-)
 
-22ae7de0990701d140759af4a9b7070bf4409414
+f7a32ccf6c93402cf70e29c3ea45aeee15ea64cb
 diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
 index 3c606cf..d09c792 100644
 --- a/drivers/scsi/Kconfig
@@ -54,4 +52,4 @@
  sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
  ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
 -- 
-1.1.3
+1.1.5



From tomo at berlios.de  Sat Feb 25 18:20:31 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 25 Feb 2006 18:20:31 +0100
Subject: [Stgt-svn] r318 - branches/use-scsi-ml/kernel
Message-ID: <200602251720.k1PHKVQQ028071@sheep.berlios.de>

Author: tomo
Date: 2006-02-25 18:20:30 +0100 (Sat, 25 Feb 2006)
New Revision: 318

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Changes the new interface.

Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-25 17:19:44 UTC (rev 317)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-25 17:20:30 UTC (rev 318)
@@ -35,15 +35,15 @@
 static int tgtd_pid;
 static struct sock *nl_sk;
 
-static int send_event_res(uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags, pid_t pid)
+static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
+			  pid_t pid)
 {
 	struct tgt_event *ev;
 	struct nlmsghdr *nlh;
 	struct sk_buff *skb;
 	uint32_t len;
 
-	len = NLMSG_SPACE(sizeof(*ev) + dlen);
+	len = NLMSG_SPACE(sizeof(*ev));
 	skb = alloc_skb(len, flags);
 	if (!skb)
 		return -ENOMEM;
@@ -52,8 +52,6 @@
 
 	ev = NLMSG_DATA(nlh);
 	memcpy(ev, p, sizeof(*ev));
-	if (dlen)
-		memcpy(ev->data, data, dlen);
 
 	return netlink_unicast(nl_sk, skb, pid, 0);
 }
@@ -64,10 +62,12 @@
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
-	struct tgt_cmd *tcmd;
 	int err, len;
 
-	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
+	/* FIXME: we need scsi core to do that. */
+	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
+
+	len = NLMSG_SPACE(sizeof(*ev));
 	/*
 	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
 	 */
@@ -82,21 +82,16 @@
 	ev->k.cmd_req.host_no = shost->host_no;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
+	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
+	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
+	ev->k.cmd_req.attribute = cmd->tag;
 
-	dprintk("%p %d %u %u\n", cmd, ev->k.cmd_req.host_no, ev->k.cmd_req.cid,
-		ev->k.cmd_req.data_len);
+	dprintk("%p %d %u %u %x\n", cmd, shost->host_no, ev->k.cmd_req.cid,
+		ev->k.cmd_req.data_len, cmd->tag);
 
-	/* FIXME: we need scsi core to do that. */
-	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-
-	tcmd = (struct tgt_cmd *) ev->data;
-	memcpy(tcmd->scb, cmd->cmnd, sizeof(tcmd->scb));
-	memcpy(tcmd->lun, lun, sizeof(struct scsi_lun));
-
 	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
 	if (err < 0)
-		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
-		       err);
+		eprintk(KERN_ERR "could not send skb %d\n", err);
 	return err;
 }
 
@@ -104,15 +99,13 @@
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct tgt_event ev;
-	char dummy[sizeof(struct tgt_cmd)];
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.cmd_done.host_no = shost->host_no;
 	ev.k.cmd_done.cid = cmd->request->tag;
 	ev.k.cmd_done.result = cmd->result;
 
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, dummy, sizeof(dummy),
-			      gfp_mask, tgtd_pid);
+	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
 }
 
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
@@ -124,19 +117,17 @@
 		nlh->nlmsg_pid, current->pid);
 
 	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_TGTD_BIND:
+	case TGT_UEVENT_REQ:
 		tgtd_pid = NETLINK_CREDS(skb)->pid;
 		break;
-	case TGT_UEVENT_CMD_RES:
+	case TGT_UEVENT_CMD_RSP:
 		/* TODO: handle multiple cmds in one event */
-		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
-					   ev->u.cmd_res.cid,
-					   ev->u.cmd_res.result,
-					   ev->u.cmd_res.len,
-					   ev->u.cmd_res.offset,
-					   ev->u.cmd_res.uaddr,
-					   ev->u.cmd_res.rw,
-					   ev->u.cmd_res.try_map);
+		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
+					   ev->u.cmd_rsp.cid,
+					   ev->u.cmd_rsp.result,
+					   ev->u.cmd_rsp.len,
+					   ev->u.cmd_rsp.uaddr,
+					   ev->u.cmd_rsp.rw);
 		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);
@@ -166,12 +157,12 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RSP) {
 			struct tgt_event ev;
 
 			memset(&ev, 0, sizeof(ev));
-			ev.k.event_res.err = err;
-			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+			ev.k.event_rsp.err = err;
+			send_event_rsp(TGT_KEVENT_RSP, &ev,
 				       GFP_KERNEL | __GFP_NOFAIL,
 					nlh->nlmsg_pid);
 		}

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-25 17:19:44 UTC (rev 317)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-25 17:20:30 UTC (rev 318)
@@ -321,7 +321,7 @@
 
 	while (len > 0) {
 		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
 		if (IS_ERR(bio)) {
 			err = PTR_ERR(bio);
 			dprintk("fail to map %lx %u %d %x\n",
@@ -444,16 +444,16 @@
 	return 0;
 }
 
-int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
-			 unsigned long uaddr, u8 rw, u8 try_map)
+int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
+			 unsigned long uaddr, u8 rw)
 {
 	struct Scsi_Host *shost;
 	struct scsi_cmnd *cmd;
 	struct request *rq;
 	int err = 0;
 
-	dprintk("%d %u %d %u %llu %lx %u %u\n", host_no, cid, result,
-		len, (unsigned long long) offset, uaddr, rw, try_map);
+	dprintk("%d %u %d %u %lx %u\n", host_no, cid, result,
+		len, uaddr, rw);
 
 	/* TODO: replace with a O(1) alg */
 	shost = scsi_host_lookup(host_no);

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-25 17:19:44 UTC (rev 317)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-25 17:20:30 UTC (rev 318)
@@ -21,5 +21,5 @@
 extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-				u64 offset, unsigned long uaddr, u8 rw,
-				u8 try_map);
+				unsigned long uaddr, u8 rw);
+



From tomo at berlios.de  Sat Feb 25 18:20:55 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 25 Feb 2006 18:20:55 +0100
Subject: [Stgt-svn] r319 - branches/use-scsi-ml/usr
Message-ID: <200602251720.k1PHKtxe028109@sheep.berlios.de>

Author: tomo
Date: 2006-02-25 18:20:54 +0100 (Sat, 25 Feb 2006)
New Revision: 319

Modified:
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/target.c
Log:
User-space changes for the new interface.

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-25 17:20:30 UTC (rev 318)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-25 17:20:54 UTC (rev 319)
@@ -126,13 +126,13 @@
 	char sbuf[NL_BUFSIZE], rbuf[NL_BUFSIZE];
 
 	ev = (struct tgt_event *) NLMSG_DATA(sbuf);
-	err = nl_cmd_call(nl_fd, TGT_UEVENT_TGTD_BIND, sbuf,
+	err = nl_cmd_call(nl_fd, TGT_UEVENT_REQ, sbuf,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
 			  rbuf, NL_BUFSIZE);
 
 	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
-	if (err < 0 || ev->k.event_res.err < 0) {
-		eprintf("%d %d\n", err, ev->k.event_res.err);
+	if (err < 0 || ev->k.event_rsp.err < 0) {
+		eprintf("%d %d\n", err, ev->k.event_rsp.err);
 		return -EINVAL;
 	}
 

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-25 17:20:30 UTC (rev 318)
+++ branches/use-scsi-ml/usr/target.c	2006-02-25 17:20:54 UTC (rev 319)
@@ -349,7 +349,6 @@
 	int result, len = 0;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	struct tgt_cmd *scmd;
 	uint64_t offset, dev_id;
 	uint32_t cid = ev_req->k.cmd_req.cid;
 	uint8_t rw = 0, try_map = 0;
@@ -362,21 +361,21 @@
 		eprintf("%d is not bind to any target\n", host_no);
 		return 0;
 	}
-	scmd = (struct tgt_cmd *) ev_req->data;
 
-	dev_id = scsi_get_devid(scmd->lun);
-	dprintf("%u %x %" PRIx64 "\n", cid, scmd->scb[0], dev_id);
+	dev_id = scsi_get_devid(ev_req->k.cmd_req.lun);
+	dprintf("%u %x %" PRIx64 "\n", cid, ev_req->k.cmd_req.scb[0], dev_id);
 
 	device = device_get(target, dev_id);
 	if (device)
 		uaddr = target->devt[dev_id]->addr;
 
-	result = scsi_cmd_process(host_no, target->tid, scmd->scb, &len,
-				  ev_req->k.cmd_req.data_len,
-				  &uaddr, &rw, &try_map, &offset, scmd->lun);
+	result = scsi_cmd_process(host_no, target->tid, ev_req->k.cmd_req.scb,
+				  &len, ev_req->k.cmd_req.data_len,
+				  &uaddr, &rw, &try_map, &offset,
+				  ev_req->k.cmd_req.lun);
 
 	dprintf("%u %x %lx %" PRIu64 " %d\n",
-		cid, scmd->scb[0], uaddr, offset, result);
+		cid, ev_req->k.cmd_req.scb[0], uaddr, offset, result);
 
 	/* TODO: preallocate cmd */
 	cmd = malloc(sizeof(*cmd));
@@ -388,16 +387,14 @@
 
 	insque(&cmd->clist, &target->cqueue);
 
-	ev_res->u.cmd_res.host_no = host_no;
-	ev_res->u.cmd_res.cid = cid;
-	ev_res->u.cmd_res.len = len;
-	ev_res->u.cmd_res.result = result;
-	ev_res->u.cmd_res.uaddr = uaddr;
-	ev_res->u.cmd_res.rw = rw;
-	ev_res->u.cmd_res.try_map = try_map;
-	ev_res->u.cmd_res.offset = offset;
+	ev_res->u.cmd_rsp.host_no = host_no;
+	ev_res->u.cmd_rsp.cid = cid;
+	ev_res->u.cmd_rsp.len = len;
+	ev_res->u.cmd_rsp.result = result;
+	ev_res->u.cmd_rsp.uaddr = uaddr;
+	ev_res->u.cmd_rsp.rw = rw;
 
-	return __nl_write(nl_fd, TGT_UEVENT_CMD_RES, resbuf,
+	return __nl_write(nl_fd, TGT_UEVENT_CMD_RSP, resbuf,
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 



From tomo at berlios.de  Sat Feb 25 18:21:32 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 25 Feb 2006 18:21:32 +0100
Subject: [Stgt-svn] r320 - branches/use-scsi-ml/kernel
Message-ID: <200602251721.k1PHLWCw028215@sheep.berlios.de>

Author: tomo
Date: 2006-02-25 18:21:32 +0100 (Sat, 25 Feb 2006)
New Revision: 320

Removed:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Remove the old kernel patch.

Deleted: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-25 17:20:54 UTC (rev 319)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-02-25 17:21:32 UTC (rev 320)
@@ -1,550 +0,0 @@
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index f9fc07e..65c56b6 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
- 	 */
- 	uaddr = (unsigned long) ubuf;
- 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
--		bio = bio_map_user(q, NULL, uaddr, len, reading);
-+		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
-@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
- 	/* we don't allow misaligned data like bio_map_user() does.  If the
- 	 * user is using sg, they're expected to know the alignment constraints
- 	 * and respect them accordingly */
--	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
-+	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
-+				0);
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index ef57f25..a122624 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
- 
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
-+
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
- 
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index d182bad..701973e 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
- }
- 
- /*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto put_dev;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-  * Function:	scsi_get_command()
-  *
-  * Purpose:	Allocate and setup a scsi command block
-@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
- EXPORT_SYMBOL(scsi_get_command);
- 
- /*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock(&shost->free_list_lock);
-+
-+	spin_lock(q->queue_lock);
-+	if (blk_rq_tagged(rq))
-+		blk_queue_end_tag(q, rq);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(&shost->shost_gendev);
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+
-+/*
-  * Function:	scsi_put_command()
-  *
-  * Purpose:	Free a scsi command block
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 5ac8749..2dcc500 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/fs/bio.c b/fs/bio.c
-index 1f3bb50..3e940c9 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
-@@ -719,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
-  *	@uaddr: start of user address
-  *	@len: length in bytes
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
--			 unsigned long uaddr, unsigned int len, int write_to_vm)
-+			 unsigned long uaddr, unsigned int len, int write_to_vm,
-+			 int support_partial)
- {
- 	struct sg_iovec iov;
- 
- 	iov.iov_base = (void __user *)uaddr;
- 	iov.iov_len = len;
- 
--	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
-+	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
- }
- 
- /**
-@@ -741,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
-  *	@iov:	the iovec.
-  *	@iov_count: number of elements in the iovec
-  *	@write_to_vm: bool indicating writing to pages or not
-+ *	@support_partial: support partial mappings
-  *
-  *	Map the user space address into a bio suitable for io to a block
-  *	device. Returns an error pointer in case of error.
-  */
- struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
- 			     struct sg_iovec *iov, int iov_count,
--			     int write_to_vm)
-+			     int write_to_vm, int support_partial)
- {
- 	struct bio *bio;
- 	int len = 0, i;
-@@ -768,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
- 	for (i = 0; i < iov_count; i++)
- 		len += iov[i].iov_len;
- 
--	if (bio->bi_size == len)
-+	if (bio->bi_size == len || support_partial)
- 		return bio;
- 
- 	/*
-diff --git a/include/linux/bio.h b/include/linux/bio.h
-index b60ffe3..fc0906c 100644
---- a/include/linux/bio.h
-+++ b/include/linux/bio.h
-@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
- extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
- 			   unsigned int, unsigned int);
- extern int bio_get_nr_vecs(struct block_device *);
-+extern int __bio_get_nr_vecs(struct request_queue *);
- extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
--				unsigned long, unsigned int, int);
-+				unsigned long, unsigned int, int, int);
- struct sg_iovec;
- extern struct bio *bio_map_user_iov(struct request_queue *,
- 				    struct block_device *,
--				    struct sg_iovec *, int, int);
-+				    struct sg_iovec *, int, int, int);
- extern void bio_unmap_user(struct bio *);
- extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
- 				gfp_t);
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 6a2ccf7..580fb42 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,6 +21,7 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
-+#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..8f64515 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- struct scsi_request;
- 
-@@ -84,6 +85,8 @@ struct scsi_cmnd {
- 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
- 	unsigned bufflen;	/* Size of data buffer */
- 	void *buffer;		/* Data buffer */
-+	/* offset in cmd we are at (for multi-transfer tgt cmds) */
-+	unsigned offset;
- 
- 	unsigned underflow;	/* Return error if less than
- 				   this amount is transferred */
-@@ -147,9 +150,14 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
- extern void scsi_put_command(struct scsi_cmnd *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
- 
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index 8279929..8b799db 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -123,6 +124,36 @@ struct scsi_host_template {
- 			     void (*done)(struct scsi_cmnd *));
- 
- 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
- 	 * routine that is present that should work in most cases.  For those
-@@ -572,6 +603,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					     void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..91ad6bc
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,11 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..04be52d
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,92 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_TGTD_BIND,
-+	TGT_UEVENT_TARGET_SETUP,
-+	TGT_UEVENT_CMD_RES,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_RESPONSE,
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+};
-+
-+struct tgt_event {
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int pk_fd;
-+		} tgtd_bind;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint64_t offset;
-+			uint8_t rw;
-+			uint8_t try_map;
-+		} cmd_res;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int err;
-+		} event_res;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t data_len;
-+			uint64_t dev_id;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			int result;
-+		} cmd_done;
-+	} k;
-+
-+	/*
-+	 * I think a pointer is a unsigned long but this struct
-+	 * gets passed around from the kernel to userspace and
-+	 * back again so to handle some ppc64 setups where userspace is
-+	 * 32 bits but the kernel is 64 we do this odd thing
-+	 */
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#ifndef __KERNEL__
-+#define MAX_COMMAND_SIZE	16
-+#endif
-+
-+struct tgt_cmd {
-+	uint8_t scb[MAX_COMMAND_SIZE];
-+	uint8_t lun[8];
-+	int tags;
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#endif



From tomo at berlios.de  Sat Feb 25 18:23:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 25 Feb 2006 18:23:28 +0100
Subject: [Stgt-svn] r321 - branches/use-scsi-ml/kernel
Message-ID: <200602251723.k1PHNSox028436@sheep.berlios.de>

Author: tomo
Date: 2006-02-25 18:23:28 +0100 (Sat, 25 Feb 2006)
New Revision: 321

Removed:
   branches/use-scsi-ml/kernel/README
Log:
Remove obsolete README.

Deleted: branches/use-scsi-ml/kernel/README
===================================================================
--- branches/use-scsi-ml/kernel/README	2006-02-25 17:21:32 UTC (rev 320)
+++ branches/use-scsi-ml/kernel/README	2006-02-25 17:23:28 UTC (rev 321)
@@ -1,2 +0,0 @@
-You must apply tgt-scsi-ml8.patch to your kernel. The patch
-was built against the current scsi-misc-2.6 git tree.



From tomo at berlios.de  Sun Feb 26 05:18:34 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 26 Feb 2006 05:18:34 +0100
Subject: [Stgt-svn] r322 - branches/use-scsi-ml/usr
Message-ID: <200602260418.k1Q4IYpN030295@sheep.berlios.de>

Author: tomo
Date: 2006-02-26 05:18:10 +0100 (Sun, 26 Feb 2006)
New Revision: 322

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Remove unnecessary O_LARGEFILE define.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-25 17:23:28 UTC (rev 321)
+++ branches/use-scsi-ml/usr/target.c	2006-02-26 04:18:10 UTC (rev 322)
@@ -180,10 +180,6 @@
 	return 0;
 }
 
-#ifndef O_LARGEFILE
-#define O_LARGEFILE	0100000
-#endif
-
 int tgt_device_create(int tid, uint64_t dev_id, char *path)
 {
 	struct target *target;



From tomo at berlios.de  Mon Feb 27 00:08:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 00:08:47 +0100
Subject: [Stgt-svn] r323 - branches/use-scsi-ml/usr
Message-ID: <200602262308.k1QN8lYb017149@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 00:08:46 +0100 (Mon, 27 Feb 2006)
New Revision: 323

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
   branches/use-scsi-ml/usr/util.h
Log:
Move scsi_cmd_done to target.c.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-26 04:18:10 UTC (rev 322)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-26 23:08:46 UTC (rev 323)
@@ -27,20 +27,12 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/user.h>
 
 #include "tgtd.h"
 #include "tgt_sysfs.h"
+#include "util.h"
 
-/*
- * FIXME: in some architectures (e.g., powerpc) don't export PAGE_* to
- * user space by asm/page.h. How should we handle this?
- */
-#ifndef PAGE_SHIFT
-#define	PAGE_SHIFT	12
-#define	PAGE_SIZE	(1UL << PAGE_SHIFT)
-#define	PAGE_MASK	(~(PAGE_SIZE-1))
-#endif
-
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
 #define cpu_to_be64 __cpu_to_be64
@@ -629,8 +621,6 @@
 	return SAM_STAT_GOOD;
 }
 
-#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
-
 static int mmap_device(int tid, uint64_t lun, uint8_t *scb,
 		       int *len, int fd, uint32_t datalen, unsigned long *uaddr,
 		       uint64_t *offset)
@@ -835,21 +825,3 @@
 
 	return result;
 }
-
-int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	int err = 0;
-
-	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
-
-	if (do_munmap) {
-		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
-		uaddr &= PAGE_MASK;
-		err = munmap((void *) (unsigned long) uaddr, len);
-		if (err)
-			eprintf("%" PRIx64 " %d\n", uaddr, len);
-	} else if (do_free)
-		free((void *) (unsigned long) uaddr);
-
-	return err;
-}

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-26 04:18:10 UTC (rev 322)
+++ branches/use-scsi-ml/usr/target.c	2006-02-26 23:08:46 UTC (rev 323)
@@ -33,6 +33,7 @@
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/user.h>
 
 #include <linux/fs.h>
 #include <linux/netlink.h>
@@ -394,6 +395,24 @@
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
+static int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	int err = 0;
+
+	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
+
+	if (do_munmap) {
+		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
+		uaddr &= PAGE_MASK;
+		err = munmap((void *) (unsigned long) uaddr, len);
+		if (err)
+			eprintf("%" PRIx64 " %d\n", uaddr, len);
+	} else if (do_free)
+		free((void *) (unsigned long) uaddr);
+
+	return err;
+}
+
 static void cmd_done(struct tgt_event *ev)
 {
 	struct target *target;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-26 04:18:10 UTC (rev 322)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-26 23:08:46 UTC (rev 323)
@@ -27,6 +27,5 @@
 extern int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun);
-extern int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len);
 
 #endif

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-02-26 04:18:10 UTC (rev 322)
+++ branches/use-scsi-ml/usr/util.h	2006-02-26 23:08:46 UTC (rev 323)
@@ -25,6 +25,8 @@
 	     &pos->member != (head); 	\
 	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
 
+#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+
 struct qelem {
 	struct qelem *q_forw;
 	struct qelem *q_back;



From tomo at berlios.de  Mon Feb 27 00:09:46 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 00:09:46 +0100
Subject: [Stgt-svn] r324 - branches/use-scsi-ml/usr
Message-ID: <200602262309.k1QN9k1M017313@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 00:09:46 +0100 (Mon, 27 Feb 2006)
New Revision: 324

Modified:
   branches/use-scsi-ml/usr/tgtd.h
Log:
Kill RINGBUF_SIZE define.

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-26 23:08:46 UTC (rev 323)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-26 23:09:46 UTC (rev 324)
@@ -6,7 +6,6 @@
 
 /* makeshift */
 #define	POLLS_PER_DRV	32
-#define	RINGBUF_SIZE	(4096 * 8)
 
 extern int nl_init(void);
 extern int __nl_write(int fd, int type, char *data, int len);



From tomo at berlios.de  Mon Feb 27 00:40:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 00:40:47 +0100
Subject: [Stgt-svn] r325 - branches/use-scsi-ml/usr
Message-ID: <200602262340.k1QNelh7025894@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 00:40:24 +0100 (Mon, 27 Feb 2006)
New Revision: 325

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Clean up nl_event_handle.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-26 23:09:46 UTC (rev 324)
+++ branches/use-scsi-ml/usr/target.c	2006-02-26 23:40:24 UTC (rev 325)
@@ -33,7 +33,6 @@
 #include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
-#include <sys/user.h>
 
 #include <linux/fs.h>
 #include <linux/netlink.h>
@@ -452,45 +451,21 @@
 	free(cmd);
 }
 
-static int set_pdu_size(int fd)
-{
-	struct nlmsghdr *nlh;
-	char buf[1024];
-	int err;
-
-peek_again:
-	err = __nl_read(fd, buf, sizeof(buf), MSG_PEEK);
-	if (err < 0) {
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-
-	dprintf("%d\n", nlh->nlmsg_len);
-
-	return nlh->nlmsg_len;
-}
-
 void nl_event_handle(int nl_fd)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
-	static int pdu_size;
-	char buf[1024];
+	char buf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	int err;
 
-	if (!pdu_size)
-		pdu_size = set_pdu_size(nl_fd);
+	err = __nl_read(nl_fd, buf, sizeof(buf), MSG_WAITALL);
 
-	err = __nl_read(nl_fd, buf, pdu_size, MSG_WAITALL);
-
 	nlh = (struct nlmsghdr *) buf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	if (nlh->nlmsg_len != pdu_size) {
-		eprintf("unexpected len %d %d\n", nlh->nlmsg_len, pdu_size);
+	if (nlh->nlmsg_len != err) {
+		eprintf("unexpected len %d %d %d %d\n",
+			nlh->nlmsg_len, sizeof(*ev), sizeof(buf), err);
 		exit(1);
 	}
 



From tomo at berlios.de  Mon Feb 27 00:41:13 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 00:41:13 +0100
Subject: [Stgt-svn] r326 - branches/use-scsi-ml/usr
Message-ID: <200602262341.k1QNfDwl025937@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 00:41:11 +0100 (Mon, 27 Feb 2006)
New Revision: 326

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/util.h
Log:
Revert PAGE_* defines.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-26 23:40:24 UTC (rev 325)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-26 23:41:11 UTC (rev 326)
@@ -27,7 +27,6 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 #include <sys/types.h>
-#include <sys/user.h>
 
 #include "tgtd.h"
 #include "tgt_sysfs.h"

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-02-26 23:40:24 UTC (rev 325)
+++ branches/use-scsi-ml/usr/util.h	2006-02-26 23:41:11 UTC (rev 326)
@@ -1,3 +1,5 @@
+#include <sys/user.h>
+
 /* taken from linux kernel */
 
 #undef offsetof
@@ -25,6 +27,12 @@
 	     &pos->member != (head); 	\
 	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
 
+#ifndef PAGE_SHIFT
+#define	PAGE_SHIFT	12
+#define	PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define	PAGE_MASK	(~(PAGE_SIZE-1))
+#endif
+
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 
 struct qelem {



From tomo at berlios.de  Mon Feb 27 11:20:37 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:20:37 +0100
Subject: [Stgt-svn] r327 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602271020.k1RAKb2H003652@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:20:36 +0100 (Mon, 27 Feb 2006)
New Revision: 327

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Add scsi_cmnd structure to iu_entry structure for future abort code.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-26 23:41:11 UTC (rev 326)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:20:36 UTC (rev 327)
@@ -127,9 +127,9 @@
  */
 struct iu_entry {
 	struct server_adapter *adapter;
-
 	struct list_head ilist;
 	dma_addr_t iu_token;
+	struct scsi_cmnd *scmd;
 
 	struct {
 		dma_addr_t remote_token;
@@ -374,6 +374,7 @@
 	memcpy(scmd->data_cmnd, iu->srp.cmd.cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = len;
 	scmd->tag= tag;
+	iue->scmd = scmd;
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
 
 	dprintk("%p %p %x %lx %d %d %d\n",
@@ -786,9 +787,11 @@
 	if (status == NO_SENSE) {
 		int len = vscsis_data_length(&tmp_iu->srp.cmd,
 					     tmp_iu->srp.cmd.data_out_format);
-		dprintk("%p %x %lx %d\n",
-			tmp_iue, tmp_iu->srp.cmd.cdb[0], tmp_iu->srp.cmd.lun, len);
-		dprintk("abort successful\n");
+		dprintk("abort cmd: %p %p %lx %x %lx %d\n",
+			tmp_iue, tmp_iue->scmd,
+			tmp_iue->scmd->request->flags,
+			tmp_iu->srp.cmd.cdb[0],
+			tmp_iu->srp.cmd.lun, len);
 		BUG();
 	} else
 		dprintk("unable to abort cmd\n");



From tomo at berlios.de  Mon Feb 27 11:29:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:29:42 +0100
Subject: [Stgt-svn] r328 - branches/use-scsi-ml/kernel
Message-ID: <200602271029.k1RATgd7005609@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:29:41 +0100 (Mon, 27 Feb 2006)
New Revision: 328

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
Log:
Set the nonblocking argument in netlink_unicast() properly


Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-27 10:20:36 UTC (rev 327)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-02-27 10:29:41 UTC (rev 328)
@@ -35,7 +35,7 @@
 static int tgtd_pid;
 static struct sock *nl_sk;
 
-static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
+static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t gfp_mask,
 			  pid_t pid)
 {
 	struct tgt_event *ev;
@@ -44,7 +44,7 @@
 	uint32_t len;
 
 	len = NLMSG_SPACE(sizeof(*ev));
-	skb = alloc_skb(len, flags);
+	skb = alloc_skb(len, gfp_mask);
 	if (!skb)
 		return -ENOMEM;
 
@@ -53,10 +53,11 @@
 	ev = NLMSG_DATA(nlh);
 	memcpy(ev, p, sizeof(*ev));
 
-	return netlink_unicast(nl_sk, skb, pid, 0);
+	return netlink_unicast(nl_sk, skb, pid, gfp_mask & GFP_ATOMIC);
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
+			 gfp_t gfp_mask)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct sk_buff *skb;
@@ -89,9 +90,9 @@
 	dprintk("%p %d %u %u %x\n", cmd, shost->host_no, ev->k.cmd_req.cid,
 		ev->k.cmd_req.data_len, cmd->tag);
 
-	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
+	err = netlink_unicast(nl_sk, skb, tgtd_pid, gfp_mask & GFP_ATOMIC);
 	if (err < 0)
-		eprintk(KERN_ERR "could not send skb %d\n", err);
+		eprintk("fail to send skb %d\n", err);
 	return err;
 }
 



From tomo at berlios.de  Mon Feb 27 11:35:34 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:35:34 +0100
Subject: [Stgt-svn] r329 - branches/use-scsi-ml/usr
Message-ID: <200602271035.k1RAZYeA006392@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:35:34 +0100 (Mon, 27 Feb 2006)
New Revision: 329

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Disable unimportant debug code for ibmvstgt.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-27 10:29:41 UTC (rev 328)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-27 10:35:34 UTC (rev 329)
@@ -161,8 +161,6 @@
 	uint8_t pcode = scb[2] & 0x3f;
 	uint64_t size;
 
-	eprintf("%d %" PRIx64 " %x %x\n", tid, lun, pcode, scb[1]);
-
 	if (device_info(tid, lun, &size) < 0) {
 		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 					0x25, 0);
@@ -274,7 +272,7 @@
 	unit_address = strtoul(buf, NULL, 0);
 	close(fd);
 
-	eprintf("%d %s %d %x %" PRIx64 "\n",
+	dprintf("%d %s %d %x %" PRIx64 "\n",
 		host_no, system_id, partition_number, unit_address, lun);
 
 	id->qual_type = TYPE_DISK;



From tomo at berlios.de  Mon Feb 27 11:36:08 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:36:08 +0100
Subject: [Stgt-svn] r330 - in branches/use-scsi-ml: ibmvstgt/kernel kernel
Message-ID: <200602271036.k1RAa8vr006523@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:36:08 +0100 (Mon, 27 Feb 2006)
New Revision: 330

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Clean up dprintk and eprintk.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:35:34 UTC (rev 329)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:36:08 UTC (rev 330)
@@ -67,12 +67,12 @@
 MODULE_LICENSE("GPL");
 
 /* tmp - will replace with SCSI logging stuff */
-#define dprintk(fmt, args...)					\
+#define eprintk(fmt, args...)					\
 do {								\
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-#define eprintk dprintk
+#define dprintk eprintk
 
 /*
  * an RPA command/response transport queue.  This is our structure

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:35:34 UTC (rev 329)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:36:08 UTC (rev 330)
@@ -4,12 +4,12 @@
 struct task_struct;
 
 /* tmp - will replace with SCSI logging stuff */
-#define dprintk(fmt, args...)					\
+#define eprintk(fmt, args...)					\
 do {								\
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-#define eprintk dprintk
+#define dprintk eprintk
 
 struct scsi_tgt_queuedata {
 	struct Scsi_Host *shost;



From tomo at berlios.de  Mon Feb 27 11:45:49 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:45:49 +0100
Subject: [Stgt-svn] r331 - in branches/use-scsi-ml: ibmvstgt/kernel kernel
Message-ID: <200602271045.k1RAjnou008750@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:45:49 +0100 (Mon, 27 Feb 2006)
New Revision: 331

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Clean up dprintk and eprintk again.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:36:08 UTC (rev 330)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:45:49 UTC (rev 331)
@@ -72,7 +72,8 @@
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-#define dprintk eprintk
+/* #define dprintk eprintk */
+#define dprintk(fmt, args...)
 
 /*
  * an RPA command/response transport queue.  This is our structure
@@ -785,8 +786,9 @@
 	spin_unlock_irqrestore(&iue->adapter->lock, flags);
 
 	if (status == NO_SENSE) {
-		int len = vscsis_data_length(&tmp_iu->srp.cmd,
-					     tmp_iu->srp.cmd.data_out_format);
+		int len;
+		len = vscsis_data_length(&tmp_iu->srp.cmd,
+					 tmp_iu->srp.cmd.data_out_format);
 		dprintk("abort cmd: %p %p %lx %x %lx %d\n",
 			tmp_iue, tmp_iue->scmd,
 			tmp_iue->scmd->request->flags,

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:36:08 UTC (rev 330)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:45:49 UTC (rev 331)
@@ -9,7 +9,8 @@
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-#define dprintk eprintk
+/* #define dprintk eprintk */
+#define dprintk(fmt, args...)
 
 struct scsi_tgt_queuedata {
 	struct Scsi_Host *shost;



From tomo at berlios.de  Mon Feb 27 11:47:08 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:47:08 +0100
Subject: [Stgt-svn] r332 - branches/use-scsi-ml/kernel
Message-ID: <200602271047.k1RAl8J4009011@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:47:07 +0100 (Mon, 27 Feb 2006)
New Revision: 332

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Seems we can handle out-of-request situtations somehow.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-27 10:45:49 UTC (rev 331)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-27 10:47:07 UTC (rev 332)
@@ -185,7 +185,7 @@
 	 * command as is recvd to userspace. uspace can then make
 	 * sure we do not overload the HBA
 	 */
-	q->nr_requests = shost->hostt->can_queue * 2;
+	q->nr_requests = shost->hostt->can_queue;
 	blk_queue_init_tags(q, q->nr_requests, NULL);
 	/*
 	 * We currently only support software LLDs so this does



From tomo at berlios.de  Mon Feb 27 11:51:36 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 11:51:36 +0100
Subject: [Stgt-svn] r333 - in branches/use-scsi-ml: ibmvstgt/kernel kernel
Message-ID: <200602271051.k1RApam9009627@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 11:51:35 +0100 (Mon, 27 Feb 2006)
New Revision: 333

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Opps, I disabled the debug option somehow.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:47:07 UTC (rev 332)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 10:51:35 UTC (rev 333)
@@ -72,8 +72,8 @@
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-/* #define dprintk eprintk */
-#define dprintk(fmt, args...)
+#define dprintk eprintk
+/* #define dprintk(fmt, args...) */
 
 /*
  * an RPA command/response transport queue.  This is our structure

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:47:07 UTC (rev 332)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 10:51:35 UTC (rev 333)
@@ -9,8 +9,8 @@
 	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
-/* #define dprintk eprintk */
-#define dprintk(fmt, args...)
+#define dprintk eprintk
+/* #define dprintk(fmt, args...) */
 
 struct scsi_tgt_queuedata {
 	struct Scsi_Host *shost;



From tomo at berlios.de  Mon Feb 27 12:09:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 12:09:50 +0100
Subject: [Stgt-svn] r334 - branches/use-scsi-ml/usr
Message-ID: <200602271109.k1RB9o11011440@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 12:09:50 +0100 (Mon, 27 Feb 2006)
New Revision: 334

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Fix try_mmap_device bugs on 32-bit architectures.


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-27 10:51:35 UTC (rev 333)
+++ branches/use-scsi-ml/usr/target.c	2006-02-27 11:09:50 UTC (rev 334)
@@ -123,13 +123,15 @@
 
 static uint64_t try_mmap_device(int fd, uint64_t size)
 {
-/* 	void *p; */
+	void *p;
 
-/* 	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); */
-/* 	if (p == MAP_FAILED) */
-/* 		return 0; */
-/* 	else */
-/* 		return (unsigned long) p; */
+	if (size != (size_t) size)
+		return 0;
+	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (p == MAP_FAILED)
+		return 0;
+	else
+		return (unsigned long) p;
 	return 0;
 }
 



From tomo at berlios.de  Mon Feb 27 12:34:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 12:34:50 +0100
Subject: [Stgt-svn] r335 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200602271134.k1RBYomm019187@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 12:34:48 +0100 (Mon, 27 Feb 2006)
New Revision: 335

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Need to free adapter's stuff before calling scsi_host_put().


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 11:09:50 UTC (rev 334)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-02-27 11:34:48 UTC (rev 335)
@@ -1221,11 +1221,10 @@
 		(struct server_adapter *) dev->dev.driver_data;
 	struct Scsi_Host *shost = adapter->shost;
 
-	scsi_remove_host(shost);
-	scsi_host_put(shost);
 	crq_queue_destroy(adapter);
 	mempool_destroy(adapter->iu_pool);
-
+	scsi_remove_host(shost);
+	scsi_host_put(shost);
 	return 0;
 }
 



From tomo at berlios.de  Mon Feb 27 12:59:11 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 12:59:11 +0100
Subject: [Stgt-svn] r336 - branches/use-scsi-ml/usr
Message-ID: <200602271159.k1RBxBwF003106@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 12:58:30 +0100 (Mon, 27 Feb 2006)
New Revision: 336

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Add the hostno file in tgt_target_bind().


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-27 11:34:48 UTC (rev 335)
+++ branches/use-scsi-ml/usr/target.c	2006-02-27 11:58:30 UTC (rev 336)
@@ -486,6 +486,9 @@
 
 int tgt_target_bind(int tid, int host_no)
 {
+	char path[PATH_MAX], buf[64];
+	int fd, err;
+
 	if (!tgtt[tid]) {
 		eprintf("target is not found %d\n", tid);
 		return -EINVAL;
@@ -496,6 +499,17 @@
 		return -EINVAL;
 	}
 
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/hostno", tid);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0)
+		return -EINVAL;
+
+	snprintf(buf, sizeof(buf), "%d", host_no);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+	if (err < 0)
+		return -EINVAL;
+
 	hostt[host_no] = tgtt[tid];
 	return 0;
 }



From tomo at berlios.de  Mon Feb 27 13:15:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 13:15:50 +0100
Subject: [Stgt-svn] r337 - branches/use-scsi-ml
Message-ID: <200602271215.k1RCFogv008989@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 13:15:48 +0100 (Mon, 27 Feb 2006)
New Revision: 337

Added:
   branches/use-scsi-ml/ibmv
Modified:
   branches/use-scsi-ml/initd
Log:
Split the initd script because host_no increases every time the kernel modules are loaded.


Added: branches/use-scsi-ml/ibmv
===================================================================
--- branches/use-scsi-ml/ibmv	2006-02-27 11:58:30 UTC (rev 336)
+++ branches/use-scsi-ml/ibmv	2006-02-27 12:15:48 UTC (rev 337)
@@ -0,0 +1,10 @@
+#!/bin/bash
+#
+# Temporary script to start ibmvstgt
+#
+
+PATH=/sbin:/bin:/usr/sbin:/usr/bin
+
+${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
+${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --hostno $1
+${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1


Property changes on: branches/use-scsi-ml/ibmv
___________________________________________________________________
Name: svn:executable
   + *

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-02-27 11:58:30 UTC (rev 336)
+++ branches/use-scsi-ml/initd	2006-02-27 12:15:48 UTC (rev 337)
@@ -31,10 +31,6 @@
 #		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 #		${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
 #		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
-	else
-		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
-		${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --hostno 1
-		${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1
 	fi
 }
 	



From tomo at berlios.de  Mon Feb 27 13:19:25 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 13:19:25 +0100
Subject: [Stgt-svn] r338 - branches/use-scsi-ml/kernel
Message-ID: <200602271219.k1RCJPTg012238@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 13:19:23 +0100 (Mon, 27 Feb 2006)
New Revision: 338

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Call scsi_tgt_uspace_send_status in a non-blocking manner. We need to handle the failure later on.--This line, and those below, will be ignored--

M    kernel/scsi_tgt_lib.c


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-27 12:15:48 UTC (rev 337)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-27 12:19:23 UTC (rev 338)
@@ -82,7 +82,7 @@
 		cmd->request->flags &= ~1UL;
 
 	scsi_unmap_user_pages(tcmd);
-	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
+	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
 	blk_run_queue(q);



From tomo at berlios.de  Mon Feb 27 14:43:20 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 14:43:20 +0100
Subject: [Stgt-svn] r339 - branches/use-scsi-ml/usr
Message-ID: <200602271343.k1RDhKBo020848@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 14:43:17 +0100 (Mon, 27 Feb 2006)
New Revision: 339

Modified:
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/target.c
Log:
Add some debug message.

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-02-27 12:19:23 UTC (rev 338)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-02-27 13:43:17 UTC (rev 339)
@@ -124,7 +124,7 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
+	dprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
 		nlh->nlmsg_len,	req->typeid, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
 

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-27 12:19:23 UTC (rev 338)
+++ branches/use-scsi-ml/usr/target.c	2006-02-27 13:43:17 UTC (rev 339)
@@ -234,6 +234,9 @@
 		eprintf("Succeed to mmap the device %" PRIx64 "\n",
 			device->addr);
 
+	eprintf("Succeed to add a logical unit %" PRIu64 " to the target %d\n",
+		dev_id, tid);
+
 	return 0;
 close_dev_fd:
 	close(dev_fd);
@@ -510,6 +513,8 @@
 	if (err < 0)
 		return -EINVAL;
 
+	eprintf("Succeed to bind the target %d to the scsi host %d\n",
+		tid, host_no);
 	hostt[host_no] = tgtt[tid];
 	return 0;
 }
@@ -564,6 +569,7 @@
 	if (err < 0)
 		goto free_device_table;
 
+	eprintf("Succeed to create a new target %d\n", tid);
 	tgtt[tid] = target;
 	return 0;
 



From tomo at berlios.de  Mon Feb 27 14:43:54 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Feb 2006 14:43:54 +0100
Subject: [Stgt-svn] r340 - branches/use-scsi-ml
Message-ID: <200602271343.k1RDhsFD021451@sheep.berlios.de>

Author: tomo
Date: 2006-02-27 14:43:53 +0100 (Mon, 27 Feb 2006)
New Revision: 340

Modified:
   branches/use-scsi-ml/README
Log:
Update README.

Modified: branches/use-scsi-ml/README
===================================================================
--- branches/use-scsi-ml/README	2006-02-27 13:43:17 UTC (rev 339)
+++ branches/use-scsi-ml/README	2006-02-27 13:43:53 UTC (rev 340)
@@ -1,92 +1,80 @@
 Introduction
 -------------
-Note that linux target framework software (tgt) is under active
+Note that linux target framework (tgt) is under active
 development. Don't play with important data.
 
-Currently, tgt supports two SCSI targets, iSCSI software target
-(istgt) and IBM virtual SCSI target (ibmvstgt).
+Currently, tgt supports only one low level driver, IBM VIO server
+(ibmvstgt).
 
 
 Starting
 -------------
 The software consists of kernel modules and user-space tools (daemon,
-management tool, dynamic libraries). The compilation of the kernel
-modules require the path to above kernel sources:
+management tool, dynamic libraries).
 
-host:~/tgt$ make KERNELSRC=<kernel-src>
+First, get kernel sources from James's scsi-rc-fixes-2.6 git tree.
 
-Make sure that everything is built successfully. Now you can start tgt
-by type the followings.
+The kernel itself requires the patches in the patchset
+directory. Apply all the patches except the 6th patch, rebuild the
+kernel, and reboot with the new kernel.
 
-host:~/tgt$ su
-host:~/tgt# ./initd start
+The compilation of the kernel modules require the path to above kernel
+source:
 
-You need to be in the tgt source code directory to execute the script
-correctly.
+host:~/use-scsi-ml$ make KERNELSRC=<kernel-src>
 
-You can see /sys/class/tgt_type directory to make sure kernel modules
-loaded.
+Make sure that everything is built successfully. Now you can load the
+kernel modules by typing the followings.
 
-host:~/tgt# cat /sys/class/tgt_type/driver1/name
-istgt
-host:~/tgt# cat /sys/class/tgt_type/driver1/protocol
-scsi
+host:~/use-scsi-ml$ su
+host:~/use-scsi-ml# ./initd start
 
-The number in the directory path is driver id. The istgt driver id is
-1 in the above example.
+See /var/log/kern.log (your Linux distributions may use the different
+log file name) to make sure that the kernel modules are loaded
+properly. You should see messages like the followings:
 
-By defaults, tgt generates logs of debug messages. Please see
-/var/log/kern.log and /var/log/daemon.log (your Linux distributions
-may use the different log file names).
+Feb 27 19:37:52 lilac kernel: IBM eServer i/pSeries Virtual SCSI Target Driver
+Feb 27 19:37:52 lilac kernel: vio_register_driver: driver ibmvscsi registering
+Feb 27 19:37:52 lilac kernel: scsi1 : ibmvstgt
 
+You need the scsi host number (it is 1 in this example) in the next
+stage (configuration).
 
+
 Configuration
 -------------
+
 Everyting is configured via the tgtadm management tool. Currenlty, tgt
-does not support persistent configurations. The tgtadm alayws requires
-you to specify the driver name like the following examples.
+does not support persistent configurations. You can use a makeshift
+script, 'ibmv' to do the necessary job.
 
-host:~/tgt# ./usr/tgtadm --driver istgt --help
-host:~/tgt# ./usr/tgtadm --driver ibmvstgt --help
+Note that the ibmv script exports /dev/sdb1 to initiators as LUN 0 by
+defaults. You MUST change the device path if your /dev/sdb1 stores
+important data or your box does not have /dev/sdb1.
 
-First, you need to create a target.
+host:~/use-scsi-ml# ./ibmv 1
 
-host:~/tgt# ./usr/tgtadm --driver istgt --op new --tid 0 \
---params Name=iqn.2001-04.com.example:storage.disk1.sys1.xyz
+You need to specify the scsi host number as the first argument.
 
-If you use ibmvstgt, you don't need to create a target because they
-are created automatically. A target is created per virtual bus.
+Please see /var/log/daemon.log (your Linux distributions may use the
+different log file name again) to make sure that everything is
+fine. You should see something like the followings:
 
-You can see /sys/class/tgt_target directory to make sure the target is
-ready.
+Feb 27 22:36:40 lilac tgtd: dl_init(71) istgt library is not loaded.
+Feb 27 22:36:40 lilac tgtd: dl_init(71) ibmvstgt library is not loaded.
+Feb 27 22:37:08 lilac tgtd: tgt_target_create(572) Succeed to create a new target 1
+Feb 27 22:37:08 lilac tgtd: tgt_target_bind(517) Succeed to bind the target 1 to the scsi host 1
+Feb 27 22:37:08 lilac tgtd: tgt_device_create(238) Succeed to add a logical unit 0 to the target 1
 
-host:~/tgt# cat /sys/class/tgt_target/target0/typeid
-1
 
-This number is the driver id. That is, this target (tid 0) belongs to
-the driver id 1.
+Now you are ready. Boot up VIO clients.
 
-The number in the directory path is target id (tid). tid is 0 in the
-above example.
+Note that the tgt kernel modules enable the debug option by
+defaults. We are not ready for improving performance.
 
-Then, you need to add a device to the target (tid 0).
 
-host:~/tgt# ./usr/tgtadm --driver istgt --op new --tid 0 --lun 0 \
---params Path=/dev/sdb1,Type=tgt_vsd
-
-You can see /sys/class/tgt_device directory to make sure the device
-was added successfully.
-
-host:~/tgt# cat /sys/class/tgt_device/device0\:0/size
-9006649344
-
-Note that every target must need a device whose lun is zero. Now the
-target is ready for accepting accesses from initiators.
-
-
 Stopping
 -------------
 Simply execute:
 
-host:~/tgt# ./initd stop
-
+host:~/use-scsi-ml# ./initd stop



From tomo at berlios.de  Tue Feb 28 02:39:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 02:39:03 +0100
Subject: [Stgt-svn] r341 - branches/use-scsi-ml/kernel
Message-ID: <200602280139.k1S1d3uF029775@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 02:38:53 +0100 (Tue, 28 Feb 2006)
New Revision: 341

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Move scsi_tgt_queuedata struct from scsi_tgt_priv.h to scsi_tgt_lib.c


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-27 13:43:53 UTC (rev 340)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-28 01:38:53 UTC (rev 341)
@@ -48,6 +48,10 @@
 	struct scsi_lun *lun;
 };
 
+struct scsi_tgt_queuedata {
+	struct Scsi_Host *shost;
+};
+
 static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
 {
 	struct bio *bio;

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-27 13:43:53 UTC (rev 340)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-02-28 01:38:53 UTC (rev 341)
@@ -12,10 +12,6 @@
 #define dprintk eprintk
 /* #define dprintk(fmt, args...) */
 
-struct scsi_tgt_queuedata {
-	struct Scsi_Host *shost;
-};
-
 extern void scsi_tgt_if_exit(void);
 extern int scsi_tgt_if_init(void);
 



From tomo at berlios.de  Tue Feb 28 03:51:22 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 03:51:22 +0100
Subject: [Stgt-svn] r342 - branches/use-scsi-ml/kernel
Message-ID: <200602280251.k1S2pMGk016085@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 03:51:16 +0100 (Tue, 28 Feb 2006)
New Revision: 342

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Replace blk tagging with a simple hash. I'll remove the elevator code next.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-28 01:38:53 UTC (rev 341)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-28 02:51:16 UTC (rev 342)
@@ -21,6 +21,7 @@
  */
 #include <linux/blkdev.h>
 #include <linux/elevator.h>
+#include <linux/hash.h>
 #include <linux/module.h>
 #include <linux/pagemap.h>
 #include <scsi/scsi.h>
@@ -46,10 +47,18 @@
 	struct bio_list xfer_done_list;
 	struct bio_list xfer_list;
 	struct scsi_lun *lun;
+
+	struct list_head hash_list;
+	struct request *rq;
 };
 
+#define	TGT_HASH_ORDER	4
+#define	cmd_hashfn(cid)	hash_long((cid), TGT_HASH_ORDER)
+
 struct scsi_tgt_queuedata {
 	struct Scsi_Host *shost;
+	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
+	spinlock_t cmd_hash_lock;
 };
 
 static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
@@ -94,9 +103,20 @@
 
 static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
 {
+	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
+	unsigned long flags;
+	struct list_head *head;
+	static u32 tag = 0;
+
 	tcmd->lun = rq->end_io_data;
 	bio_list_init(&tcmd->xfer_list);
 	bio_list_init(&tcmd->xfer_done_list);
+
+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+	rq->tag = tag++;
+	head = &qdata->cmd_hash[cmd_hashfn(rq->tag)];
+	list_add(&tcmd->hash_list, head);
+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
 }
 
 static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
@@ -108,6 +128,7 @@
 		return BLKPREP_DEFER;
 
 	init_scsi_tgt_cmd(rq, tcmd);
+	tcmd->rq = rq;
 	rq->end_io_data = tcmd;
 	rq->flags |= REQ_DONTPREP;
 	return BLKPREP_OK;
@@ -127,11 +148,7 @@
 		cmd = rq->special;
 		tcmd = rq->end_io_data;
 
-		/* the completion code kicks us in case we hit this */
-		if (blk_queue_start_tag(q, rq)) {
-			eprintk("failed to tag: %p\n", cmd);
-			break;
-		}
+		blkdev_dequeue_request(rq);
 
 		spin_unlock_irq(q->queue_lock);
 		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0) {
@@ -160,7 +177,7 @@
 {
 	struct scsi_tgt_queuedata *queuedata;
 	struct request_queue *q;
-	int err;
+	int err, i;
 
 	/*
 	 * Do we need to send a netlink event or should uspace
@@ -190,7 +207,6 @@
 	 * sure we do not overload the HBA
 	 */
 	q->nr_requests = shost->hostt->can_queue;
-	blk_queue_init_tags(q, q->nr_requests, NULL);
 	/*
 	 * We currently only support software LLDs so this does
 	 * not matter for now. Do we need this for the cards we support?
@@ -199,6 +215,10 @@
 	blk_queue_dma_alignment(q, 0);
 	shost->uspace_req_q = q;
 
+	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
+		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
+	spin_lock_init(&queuedata->cmd_hash_lock);
+
 	return 0;
 
 free_data:
@@ -448,6 +468,28 @@
 	return 0;
 }
 
+static struct request *tgt_cmd_hash_end(struct request_queue *q, u32 cid)
+{
+	struct scsi_tgt_queuedata *qdata = q->queuedata;
+	struct request *rq = NULL;
+	struct list_head *head;
+	struct scsi_tgt_cmd *tcmd;
+	unsigned long flags;
+
+	head = &qdata->cmd_hash[cmd_hashfn(cid)];
+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+	list_for_each_entry(tcmd, head, hash_list) {
+		if (tcmd->rq->tag == cid) {
+			rq = tcmd->rq;
+			list_del(&tcmd->hash_list);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+
+	return rq;
+}
+
 int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 			 unsigned long uaddr, u8 rw)
 {
@@ -466,7 +508,7 @@
 		return -EINVAL;
 	}
 
-	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
+	rq = tgt_cmd_hash_end(shost->uspace_req_q, cid);
 	if (!rq) {
 		printk(KERN_ERR "Could not find cid %u\n", cid);
 		err = -EINVAL;



From tomo at berlios.de  Tue Feb 28 04:45:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 04:45:42 +0100
Subject: [Stgt-svn] r343 - branches/use-scsi-ml/usr
Message-ID: <200602280345.k1S3jgi9030492@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 04:45:02 +0100 (Tue, 28 Feb 2006)
New Revision: 343

Modified:
   branches/use-scsi-ml/usr/netlink.c
Log:
Seems that we sometimes hit sk_rcvbuf. So set it larger.


Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-28 02:51:16 UTC (rev 342)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-28 03:45:02 UTC (rev 343)
@@ -141,7 +141,7 @@
 
 int nl_init(void)
 {
-	int err, nl_fd;
+	int err, nl_fd, rsize = 256 * 1024;
 
 	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
 	if (nl_fd < 0) {
@@ -149,6 +149,12 @@
 		exit(1);
 	}
 
+	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
+	if (err) {
+		eprintf("fail to setsockopt %d\n", errno);
+		exit(1);
+	}
+
 	err = tgtd_bind(nl_fd);
 	if (err)
 		exit(1);



From tomo at berlios.de  Tue Feb 28 11:22:11 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 11:22:11 +0100
Subject: [Stgt-svn] r344 - branches/use-scsi-ml/kernel
Message-ID: <200602281022.k1SAMBmg022727@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 11:22:10 +0100 (Tue, 28 Feb 2006)
New Revision: 344

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Kill the elevator code. scsi_tgt_uspace_send_fn(), which sends commands to user space is tricky because of scsi_tgt_cmd structure allocation. If we allocate earlier, the function would be more simple.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-28 03:45:02 UTC (rev 343)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-02-28 10:22:10 UTC (rev 344)
@@ -59,6 +59,12 @@
 	struct Scsi_Host *shost;
 	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
 	spinlock_t cmd_hash_lock;
+
+	struct work_struct uspace_send_work;
+
+	spinlock_t cmd_req_lock;
+	struct mutex cmd_req_mutex;
+	struct list_head cmd_req;
 };
 
 static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
@@ -81,7 +87,6 @@
 {
 	struct scsi_cmnd *cmd = data;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-	struct request_queue *q = cmd->request->q;
 
 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
 		rq_data_dir(cmd->request));
@@ -98,14 +103,13 @@
 	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-	blk_run_queue(q);
 }
 
 static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
 {
 	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
+	struct list_head *head;
 	unsigned long flags;
-	struct list_head *head;
 	static u32 tag = 0;
 
 	tcmd->lun = rq->end_io_data;
@@ -117,53 +121,72 @@
 	head = &qdata->cmd_hash[cmd_hashfn(rq->tag)];
 	list_add(&tcmd->hash_list, head);
 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-}
 
-static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
-{
-	struct scsi_tgt_cmd *tcmd;
-
-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-	if (!tcmd)
-		return BLKPREP_DEFER;
-
-	init_scsi_tgt_cmd(rq, tcmd);
 	tcmd->rq = rq;
 	rq->end_io_data = tcmd;
 	rq->flags |= REQ_DONTPREP;
-	return BLKPREP_OK;
 }
 
-static void scsi_uspace_request_fn(struct request_queue *q)
+static void scsi_tgt_uspace_send_fn(void *data)
 {
+	struct request_queue *q = data;
+	struct scsi_tgt_queuedata *qdata = q->queuedata;
 	struct request *rq;
 	struct scsi_cmnd *cmd;
 	struct scsi_tgt_cmd *tcmd;
+	unsigned long flags;
+	int err;
 
-	/*
-	 * TODO: just send everthing in the queue to userspace in
-	 * one vector instead of multiple calls
-	 */
-	while ((rq = elv_next_request(q)) != NULL) {
-		cmd = rq->special;
+retry:
+	err = 0;
+	if (list_empty(&qdata->cmd_req))
+		return;
+
+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+	if (!tcmd) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	mutex_lock(&qdata->cmd_req_mutex);
+
+	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+	if (list_empty(&qdata->cmd_req)) {
+		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+		mutex_unlock(&qdata->cmd_req_mutex);
+		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+		goto out;
+	}
+	rq = list_entry_rq(qdata->cmd_req.next);
+	list_del_init(&rq->queuelist);
+	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+
+	if ((rq->flags & REQ_DONTPREP)) {
+		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 		tcmd = rq->end_io_data;
+	} else
+		init_scsi_tgt_cmd(rq, tcmd);
 
-		blkdev_dequeue_request(rq);
+	cmd = rq->special;
 
-		spin_unlock_irq(q->queue_lock);
-		if (scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC) < 0) {
-			eprintk("failed to send: %p\n", cmd);
-			goto requeue;
-		}
-		spin_lock_irq(q->queue_lock);
+	err = scsi_tgt_uspace_send(cmd, tcmd->lun, GFP_ATOMIC);
+	if (err < 0) {
+		eprintk("failed to send: %p %d\n", cmd, err);
+
+		spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+		list_add(&rq->queuelist, &qdata->cmd_req);
+		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
 	}
 
-	return;
-requeue:
-	spin_lock_irq(q->queue_lock);
-	/* need to track cnts and plug */
-	blk_requeue_request(q, rq);
-	spin_unlock_irq(q->queue_lock);
+	mutex_unlock(&qdata->cmd_req_mutex);
+
+out:
+	/* TODO: proper error handling */
+	if (err < 0)
+		queue_delayed_work(scsi_tgtd, &qdata->uspace_send_work,
+				   HZ / 10);
+	else
+		goto retry;
 }
 
 /**
@@ -183,7 +206,7 @@
 	 * Do we need to send a netlink event or should uspace
 	 * just respond to the hotplug event?
 	 */
-	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
+	q = __scsi_alloc_queue(shost, NULL);
 	if (!q)
 		return -ENOMEM;
 
@@ -195,12 +218,6 @@
 	queuedata->shost = shost;
 	q->queuedata = queuedata;
 
-	elevator_exit(q->elevator);
-	err = elevator_init(q, "noop");
-	if (err)
-		goto free_data;
-
-	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
 	/*
 	 * this is a silly hack. We should probably just queue as many
 	 * command as is recvd to userspace. uspace can then make
@@ -219,10 +236,13 @@
 		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
 	spin_lock_init(&queuedata->cmd_hash_lock);
 
+	INIT_LIST_HEAD(&queuedata->cmd_req);
+	spin_lock_init(&queuedata->cmd_req_lock);
+	INIT_WORK(&queuedata->uspace_send_work, scsi_tgt_uspace_send_fn, q);
+	mutex_init(&queuedata->cmd_req_mutex);
+
 	return 0;
 
-free_data:
-	kfree(queuedata);
 cleanup_queue:
 	blk_cleanup_queue(q);
 	return err;
@@ -245,14 +265,17 @@
 void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
 			    int noblock)
 {
-	/*
-	 * For now this just calls the request_fn from this context.
-	 * For HW llds though we do not want to execute from here so
-	 * the elevator code needs something like a REQ_TGT_CMD or
-	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
-	 */
+	struct request_queue *q = cmd->request->q;
+	struct scsi_tgt_queuedata *qdata = q->queuedata;
+	unsigned long flags;
+
 	cmd->request->end_io_data = scsilun;
-	elv_add_request(cmd->request->q, cmd->request, ELEVATOR_INSERT_BACK, 1);
+
+	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
+	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+
+	queue_work(scsi_tgtd, &qdata->uspace_send_work);
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
 



From tomo at berlios.de  Tue Feb 28 12:25:08 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 12:25:08 +0100
Subject: [Stgt-svn] r345 - branches/use-scsi-ml/usr
Message-ID: <200602281125.k1SBP88j031872@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 12:25:07 +0100 (Tue, 28 Feb 2006)
New Revision: 345

Modified:
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Rename struct device struct tgt_device.

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-02-28 11:25:07 UTC (rev 345)
@@ -38,7 +38,6 @@
 #include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
-#include "dl.h"
 #include "log.h"
 #include "tgtadm.h"
 

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/netlink.c	2006-02-28 11:25:07 UTC (rev 345)
@@ -16,16 +16,15 @@
 #include <string.h>
 #include <stdint.h>
 #include <unistd.h>
+#include <asm/types.h>
 #include <sys/mman.h>
 #include <sys/poll.h>
 #include <sys/signal.h>
 #include <sys/socket.h>
-#include <asm/types.h>
+#include <scsi/scsi_tgt_if.h>
 #include <linux/netlink.h>
 
-#include <scsi/scsi_tgt_if.h>
 #include "tgtd.h"
-#include "dl.h"
 
 #define	NL_BUFSIZE	1024
 

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-28 11:25:07 UTC (rev 345)
@@ -30,7 +30,6 @@
 
 #include "tgtd.h"
 #include "tgt_sysfs.h"
-#include "util.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/target.c	2006-02-28 11:25:07 UTC (rev 345)
@@ -40,9 +40,7 @@
 
 #include "tgtd.h"
 #include "tgtadm.h"
-#include "dl.h"
 #include "tgt_sysfs.h"
-#include "util.h"
 
 #define	MAX_NR_TARGET		1024
 #define	MAX_NR_HOST		1024
@@ -58,18 +56,9 @@
 	int mmap;
 };
 
-struct device {
-	int fd;
-	uint64_t addr; /* persistent mapped address */
-	uint64_t size;
-	int state;
-
-	/* queue */
-};
-
 struct target {
 	int tid;
-	struct device **devt;
+	struct tgt_device **devt;
 	uint64_t max_device;
 
 	/* TODO: move to device */
@@ -91,7 +80,7 @@
 	return tgtt[tid];
 }
 
-static struct device *device_get(struct target *target, uint64_t dev_id)
+static struct tgt_device *device_get(struct target *target, uint64_t dev_id)
 {
 	if (dev_id < target->max_device || dev_id < MAX_NR_DEVICE)
 		return target->devt[dev_id];
@@ -110,7 +99,7 @@
 
 static void resize_device_table(struct target *target, uint64_t did)
 {
-	struct device *device;
+	struct tgt_device *device;
 	void *p, *q;
 
 	p = calloc(did + 1, sizeof(device));
@@ -185,7 +174,7 @@
 int tgt_device_create(int tid, uint64_t dev_id, char *path)
 {
 	struct target *target;
-	struct device *device;
+	struct tgt_device *device;
 	int err, dev_fd;
 	uint64_t size;
 
@@ -270,7 +259,7 @@
 int tgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct target *target;
-	struct device *device;
+	struct tgt_device *device;
 	char path[PATH_MAX], buf[64];
 	int dev_fd, fd, err;
 
@@ -346,7 +335,7 @@
 static int cmd_queue(struct tgt_event *ev_req, int nl_fd)
 {
 	struct target *target;
-	struct device *device;
+	struct tgt_device *device;
 	int result, len = 0;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
@@ -420,7 +409,7 @@
 static void cmd_done(struct tgt_event *ev)
 {
 	struct target *target;
-	struct device *device;
+	struct tgt_device *device;
 	struct cmd *cmd;
 	int err, do_munmap, host_no = ev->k.cmd_done.host_no;
 	uint32_t cid = ev->k.cmd_done.cid;
@@ -557,7 +546,7 @@
 	target->tid = tid;
 	INIT_LIST_HEAD(&target->cqueue);
 
-	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct device *));
+	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct tgt_device *));
 	if (!target->devt) {
 		eprintf("Out of memoryn\n");
 		err = 0;

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-02-28 11:25:07 UTC (rev 345)
@@ -33,12 +33,11 @@
 #include <sys/poll.h>
 #include <sys/signal.h>
 #include <sys/stat.h>
-#include <dirent.h>
-
 #include <scsi/scsi_tgt_if.h>
+
 #include "tgtd.h"
-#include "dl.h"
 
+
 enum {
 	POLL_NL, /* netlink socket between kernel and user space */
 	POLL_UD, /* unix domain socket for tgtdadm */

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-28 10:22:10 UTC (rev 344)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-28 11:25:07 UTC (rev 345)
@@ -3,7 +3,19 @@
 
 #include "log.h"
 #include "dl.h"
+#include "util.h"
 
+struct tgt_device {
+	int fd;
+	uint64_t addr; /* persistent mapped address */
+	uint64_t size;
+	unsigned long state;
+
+	struct qelem cmd_list;
+
+	struct tgt_device *next_device;
+};
+
 /* makeshift */
 #define	POLLS_PER_DRV	32
 



From tomo at berlios.de  Tue Feb 28 12:57:17 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 12:57:17 +0100
Subject: [Stgt-svn] r346 - branches/use-scsi-ml/usr
Message-ID: <200602281157.k1SBvHJw013152@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 12:57:06 +0100 (Tue, 28 Feb 2006)
New Revision: 346

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Add scsi_id to tgt_device structure.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-28 11:25:07 UTC (rev 345)
+++ branches/use-scsi-ml/usr/target.c	2006-02-28 11:57:06 UTC (rev 346)
@@ -217,6 +217,8 @@
 	device->state = 0;
 	device->addr = try_mmap_device(dev_fd, size);
 	device->size = size;
+	snprintf(device->scsi_id, sizeof(device->scsi_id),
+		 "deadbeaf%d:%" PRIu64, tid, dev_id);
 	target->devt[dev_id] = device;
 
 	if (device->addr)

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-28 11:25:07 UTC (rev 345)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-28 11:57:06 UTC (rev 346)
@@ -5,11 +5,14 @@
 #include "dl.h"
 #include "util.h"
 
+#define	SCSI_ID_LEN	24
+
 struct tgt_device {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
 	uint64_t size;
 	unsigned long state;
+	char scsi_id[SCSI_ID_LEN];
 
 	struct qelem cmd_list;
 



From tomo at berlios.de  Tue Feb 28 13:28:16 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 28 Feb 2006 13:28:16 +0100
Subject: [Stgt-svn] r347 - branches/use-scsi-ml/usr
Message-ID: <200602281228.k1SCSGPm026738@sheep.berlios.de>

Author: tomo
Date: 2006-02-28 13:28:01 +0100 (Tue, 28 Feb 2006)
New Revision: 347

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Remove some of the ancient code in scsi.c for target and device structures in kernel space.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-28 11:57:06 UTC (rev 346)
+++ branches/use-scsi-ml/usr/scsi.c	2006-02-28 12:28:01 UTC (rev 347)
@@ -154,20 +154,14 @@
 	return sizeof(geo_m_pg);
 }
 
-static int mode_sense(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int *len)
+static int mode_sense(struct tgt_device *dev, uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t pcode = scb[2] & 0x3f;
 	uint64_t size;
 
-	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-					0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-
 	*len = 4;
-	size >>= BLK_SHIFT;
+	size = dev->size >> BLK_SHIFT;
 
 	if ((scb[1] & 0x8))
 		data[3] = 0;
@@ -467,7 +461,7 @@
 	return result;
 }
 
-static int read_capacity(int tid, uint64_t lun, uint8_t *scb, uint8_t *p, int *len)
+static int read_capacity(struct tgt_device *dev, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t *data = (uint32_t *) p;
 	uint64_t size;
@@ -478,14 +472,8 @@
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
-					0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
+	size = dev->size >> BLK_SHIFT;
 
-	size >>= BLK_SHIFT;
-
 	data[0] = (size >> 32) ?
 		cpu_to_be32(0xffffffff) : cpu_to_be32(size - 1);
 	data[1] = cpu_to_be32(1U << BLK_SHIFT);
@@ -494,72 +482,13 @@
 	return SAM_STAT_GOOD;
 }
 
-static int getfd(int tid, uint64_t lun)
+static int sync_cache(struct tgt_device *dev, uint8_t *data, int *len)
 {
-	int fd, err;
-	char path[PATH_MAX], buf[PATH_MAX];
+	int err;
 
-	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		tid, lun);
-
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		log_error("scsi sync_cache could not get LU's fd err %d",
-			  errno);
-		goto out;
-	}
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		log_error("scsi sync_cache could not read LUN path err %d",
-			  errno);
-		fd = -EIO;
-		goto out;
-	}
-
-	fd = 0;
-	sscanf(buf, "%d\n", &fd);
-
-out:
-	return fd;
-}
-
-static int sync_cache(int tid, uint64_t lun, uint8_t *scb, uint8_t *data,
-		      int *len)
-{
-	int fd, err;
-	char path[PATH_MAX], buf[PATH_MAX];
-
-	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		tid, lun);
-
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		log_error("scsi sync_cache could not get LU's fd err %d",
-			  errno);
-		err = EINVAL;
-		goto einval;
-	}
-
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		log_error("scsi sync_cache could not read LUN path err %d",
-			  errno);
-		err = EIO;
-		goto eio;
-	}
-	/*
-	 * yuck! wtf should I be using
-	 */
-	fd = 0;
-	sscanf(buf, "%d\n", &fd);
-
-	err = fsync(fd);
+	err = fsync(dev->fd);
 	if (err) {
-		log_error("scsi sync_cache fsync of fd %d failed err %d",
-			   fd, errno);
+		eprintf("fd %d failed err %d", dev->fd, errno);
 		/*
 		 * this is what we should do but for now we lie.
 		 * err = errno;
@@ -571,12 +500,8 @@
 	case EROFS:
 	case EINVAL:
 	case EBADF:
-einval:
-		/* is this the right sense code? */
-		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
-		return SAM_STAT_CHECK_CONDITION;
 	case EIO:
-eio:
+		/* is this the right sense code? */
 		/* what should I put for the asc/ascq? */
 		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
 		return SAM_STAT_CHECK_CONDITION;
@@ -589,24 +514,19 @@
 /*
  * TODO: We always assume autosense.
  */
-static int request_sense(int tid, uint64_t lun, uint8_t *scb, uint8_t *data, int* len)
+static int request_sense(uint8_t *data, int* len)
 {
 	*len = sense_data_build(data, 0x70, NO_SENSE, 0, 0);
 
 	return SAM_STAT_GOOD;
 }
 
-static int sevice_action(int tid, uint64_t lun, uint8_t *scb, uint8_t *p, int *len)
+static int sevice_action(struct tgt_device *dev, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t *data = (uint32_t *) p;
 	uint64_t *data64, size;
 
-	if (device_info(tid, lun, &size) < 0) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
-					0x25, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-	size >>= BLK_SHIFT;
+	size = dev->size >> BLK_SHIFT;
 
 	data64 = (uint64_t *) data;
 	data64[0] = cpu_to_be64(size - 1);
@@ -617,8 +537,7 @@
 	return SAM_STAT_GOOD;
 }
 
-static int mmap_device(int tid, uint64_t lun, uint8_t *scb,
-		       int *len, int fd, uint32_t datalen, unsigned long *uaddr,
+static int mmap_device(uint8_t *scb, int *len, int fd, uint32_t datalen, unsigned long *uaddr,
 		       uint64_t *offset)
 {
 	void *p;
@@ -722,9 +641,10 @@
 
 int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf)
+		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
+		     struct tgt_device *dev)
 {
-	int fd, result = SAM_STAT_GOOD;
+	int result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;
 	uint64_t lun;
 
@@ -736,7 +656,7 @@
 	if (!mmap_cmd_init(scb, rw))
 		data = valloc(PAGE_SIZE);
 
-	if (lun == TGT_INVALID_DEV_ID)
+	if (!dev)
 		switch (scb[0]) {
 		case REQUEST_SENSE:
 		case INQUIRY:
@@ -760,19 +680,19 @@
 		result = report_luns(tid, lun_buf, scb, data, len);
 		break;
 	case READ_CAPACITY:
-		result = read_capacity(tid, lun, scb, data, len);
+		result = read_capacity(dev, scb, data, len);
 		break;
 	case MODE_SENSE:
-		result = mode_sense(tid, lun, scb, data, len);
+		result = mode_sense(dev, scb, data, len);
 		break;
 	case REQUEST_SENSE:
-		result = request_sense(tid, lun, scb, data, len);
+		result = request_sense(data, len);
 		break;
 	case SERVICE_ACTION_IN:
-		result = sevice_action(tid, lun, scb, data, len);
+		result = sevice_action(dev, scb, data, len);
 		break;
 	case SYNCHRONIZE_CACHE:
-		result = sync_cache(tid, lun, scb, data, len);
+		result = sync_cache(dev, data, len);
 		break;
 	case START_STOP:
 	case TEST_UNIT_READY:
@@ -786,18 +706,11 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		if (*uaddr)
-			fd = 0;
-		else
-			fd = getfd(tid, lun);
-		if (fd >= 0) {
-			result = mmap_device(tid, lun, scb, len, fd, datalen,
-					     uaddr, offset);
-			if (result == SAM_STAT_GOOD)
-				*try_map = 1;
-		}
-
-		if (fd < 0 || result != SAM_STAT_GOOD) {
+		result = mmap_device(scb, len, dev->fd, datalen,
+				     uaddr, offset);
+		if (result == SAM_STAT_GOOD)
+			*try_map = 1;
+		else {
 			*offset = 0;
 			if (!data)
 				data = valloc(PAGE_SIZE);

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-28 11:57:06 UTC (rev 346)
+++ branches/use-scsi-ml/usr/target.c	2006-02-28 12:28:01 UTC (rev 347)
@@ -364,7 +364,7 @@
 	result = scsi_cmd_process(host_no, target->tid, ev_req->k.cmd_req.scb,
 				  &len, ev_req->k.cmd_req.data_len,
 				  &uaddr, &rw, &try_map, &offset,
-				  ev_req->k.cmd_req.lun);
+				  ev_req->k.cmd_req.lun, device);
 
 	dprintf("%u %x %lx %" PRIu64 " %d\n",
 		cid, ev_req->k.cmd_req.scb[0], uaddr, offset, result);

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-28 11:57:06 UTC (rev 346)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-02-28 12:28:01 UTC (rev 347)
@@ -40,6 +40,7 @@
 extern uint64_t scsi_get_devid(uint8_t *pdu);
 extern int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-			    uint8_t *try_map, uint64_t *offset, uint8_t *lun);
+			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
+			    struct tgt_device *dev);
 
 #endif



