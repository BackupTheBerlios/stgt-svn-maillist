From tomo at berlios.de  Fri Jan  6 11:25:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 6 Jan 2006 11:25:28 +0100
Subject: [Stgt-svn] r225 - trunk/usr
Message-ID: <200601061025.k06APSIe029449@sheep.berlios.de>

Author: tomo
Date: 2006-01-06 11:25:27 +0100 (Fri, 06 Jan 2006)
New Revision: 225

Modified:
   trunk/usr/netlink.c
Log:
Stop binding a netlink socket.


Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2005-12-30 15:51:50 UTC (rev 224)
+++ trunk/usr/netlink.c	2006-01-06 10:25:27 UTC (rev 225)
@@ -260,12 +260,6 @@
 	src_addr.nl_pid = getpid();
 	src_addr.nl_groups = 0; /* not in mcast groups */
 
-	err = bind(fd, (struct sockaddr *)&src_addr, sizeof(src_addr));
-	if (err < 0) {
-		eprintf("%d\n", fd);
-		goto out;
-	}
-
 	memset(&dest_addr, 0, sizeof(dest_addr));
 	dest_addr.nl_family = AF_NETLINK;
 	dest_addr.nl_pid = 0; /* kernel */



From tomo at berlios.de  Sun Jan 22 05:09:27 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 22 Jan 2006 05:09:27 +0100
Subject: [Stgt-svn] r226 - branches
Message-ID: <200601220409.k0M49RtH024423@sheep.berlios.de>

Author: tomo
Date: 2006-01-22 05:09:21 +0100 (Sun, 22 Jan 2006)
New Revision: 226

Added:
   branches/use-scsi-ml/
Log:
Create a new tree for integration of initiator and target drivers (bring the main trunk 225).

Copied: branches/use-scsi-ml (from rev 225, trunk)



From tomo at berlios.de  Sun Jan 22 05:09:36 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 22 Jan 2006 05:09:36 +0100
Subject: [Stgt-svn] r227 - branches/use-scsi-ml
Message-ID: <200601220409.k0M49avm024531@sheep.berlios.de>

Author: tomo
Date: 2006-01-22 05:09:34 +0100 (Sun, 22 Jan 2006)
New Revision: 227

Added:
   branches/use-scsi-ml/trunk/
Log:
Create a new tree for integration of initiator and target drivers (bring the main trunk r225).

Copied: branches/use-scsi-ml/trunk (from rev 226, trunk)



From tomo at berlios.de  Sun Jan 22 05:32:06 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 22 Jan 2006 05:32:06 +0100
Subject: [Stgt-svn] r228 - branches/use-scsi-ml
Message-ID: <200601220432.k0M4W61I027046@sheep.berlios.de>

Author: tomo
Date: 2006-01-22 05:32:06 +0100 (Sun, 22 Jan 2006)
New Revision: 228

Removed:
   branches/use-scsi-ml/trunk/
Log:
Kill the unnecessary tree.




From tomo at berlios.de  Sun Jan 22 15:42:22 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 22 Jan 2006 15:42:22 +0100
Subject: [Stgt-svn] r229 - in trunk: . include istgt/kernel istgt/usr kernel usr
Message-ID: <200601221442.k0MEgMc6027199@sheep.berlios.de>

Author: tomo
Date: 2006-01-22 15:42:20 +0100 (Sun, 22 Jan 2006)
New Revision: 229

Added:
   trunk/usr/target.c
Modified:
   trunk/include/tgt_if.h
   trunk/initd
   trunk/istgt/kernel/iscsi.c
   trunk/istgt/usr/ctldev.c
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt.h
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/usr/Makefile
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/ipc.c
   trunk/usr/log.c
   trunk/usr/log.h
   trunk/usr/mgmt.c
   trunk/usr/netlink.c
   trunk/usr/scsi.c
   trunk/usr/tgt_device.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
This includes the huge change to tgtd design.

tgtadm <- unix domain socket -> tgtd <- pipe -> target daemon
                                 |                    |
                                 |---------------------
                                 | netlink
                               core

The new design creates one target daemon per tgt_target.

The tgt_core module sends command requests and the completion
notifications to a target daemon and the rest to tgtd. tgtd routes
some of the requests to target daemons if necessary.

The sizes of command requests and the completion notifications are
same so target daemons can read a single request from its netlink
socket once (That is, the completion includes some padding). The other
requests (whose size are various) come through pipe.

This still includes lots of makeshift code. I need to keep cleaning up
for some time.


Modified: trunk/include/tgt_if.h
===================================================================
--- trunk/include/tgt_if.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/include/tgt_if.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -28,6 +28,7 @@
 		struct {
 			char type[32];
 			int nr_cmds;
+			int pid;
 		} c_target;
 		struct {
 			int tid;
@@ -39,6 +40,7 @@
 		struct {
 			int tid;
 			uint64_t cid;
+			uint64_t devid;
 			uint32_t len;
 			int result;
 			/*
@@ -71,6 +73,7 @@
 		struct {
 			int tid;
 			int typeid;
+			uint64_t devid;
 			unsigned long uaddr;
 			uint32_t len;
 			int mmapped;

Modified: trunk/initd
===================================================================
--- trunk/initd	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/initd	2006-01-22 14:42:20 UTC (rev 229)
@@ -24,6 +24,11 @@
 	fi
 
 	${PWD}/usr/tgtd
+
+	sleep 1
+
+	${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+	${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
 }
 	
 stop_server()

Modified: trunk/istgt/kernel/iscsi.c
===================================================================
--- trunk/istgt/kernel/iscsi.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/istgt/kernel/iscsi.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -153,23 +153,22 @@
 {
 	struct iscsi_conn *conn = cmnd->conn;
 	struct istgt_cmd *data_cmnd;
-	struct scatterlist *sg = cmnd->tc->sg;
+	struct scatterlist *sg;
 	struct iscsi_cmd *req = cmd_hdr(cmnd);
 	struct iscsi_data_rsp *rsp;
 	uint32_t pdusize, expsize, scsisize, size, offset, sn;
 	LIST_HEAD(send);
 
-	dprintk("%p\n", cmnd);
+	BUG_ON(!cmnd->tc);
+	sg = cmnd->tc->sg;
+	BUG_ON(!sg);
 	pdusize = conn->session->param.max_xmit_data_length;
 	expsize = cmnd_read_size(cmnd);
-	BUG_ON(!cmnd->tc);
+	dprintk("%p %u %u %u\n", cmnd->tc, pdusize, expsize, cmnd->tc->bufflen);
 	size = min(expsize, cmnd->tc->bufflen);
-	dprintk("%u %u\n", expsize, cmnd->tc->bufflen);
 	offset = 0;
 	sn = 0;
 
-	BUG_ON(!sg);
-
 	while (1) {
 		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
 		data_cmnd->sg = sg;
@@ -746,6 +745,13 @@
 	int err;
 	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
 
+	/*
+	 * Possibly, cmnd->tc is null here because
+	 * tgt_scsi_cmd_create() does not return yet. This would cause
+	 * trouble later. So we need to set it here.
+	 */
+	cmnd->tc = tc;
+
 	INIT_WORK(&cmnd->work, __scsi_cmnd_done, tc);
 	err = schedule_work(&cmnd->work);
 	BUG_ON(!err);
@@ -785,13 +791,6 @@
 		break;
 	}
 
-	req->tc = tgt_cmd_create(conn->session->ts, req, req_hdr->cdb,
-				 be32_to_cpu(req_hdr->data_length),
-				 data_dir, req_hdr->lun,
-				 sizeof(req_hdr->lun),
-				 tags);
-	BUG_ON(!req->tc);
-
 	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {
 		switch (req_hdr->cdb[0]) {
 		case WRITE_6:
@@ -804,6 +803,13 @@
 			break;
 		}
 	}
+
+	req->tc = tgt_cmd_create(conn->session->ts, req, req_hdr->cdb,
+				 be32_to_cpu(req_hdr->data_length),
+				 data_dir, req_hdr->lun,
+				 sizeof(req_hdr->lun),
+				 tags);
+	BUG_ON(!req->tc);
 }
 
 static void scsi_cmnd_exec(struct istgt_cmd *cmnd)

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/istgt/usr/ctldev.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -28,7 +28,6 @@
 #include "tgt_sysfs.h"
 
 extern struct qelem targets_list;
-static int typeid;
 
 static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
 {
@@ -65,14 +64,15 @@
 
 	switch (msg->k.conn_state_change.state) {
 	case E_CONN_CLOSE:
-		if (!(session = session_find_id(msg->k.conn_state_change.tid,
-						msg->k.conn_state_change.sid))) {
+		session = session_find_id(msg->k.conn_state_change.tid,
+					  msg->k.conn_state_change.sid);
+
+		if (session) {
+			if (!--session->conn_cnt)
+				session_remove(session);
+		} else
 			eprintf("session %#" PRIx64 " not found?",
 				msg->k.conn_state_change.sid);
-		}
-
-		if (!--session->conn_cnt)
-			session_remove(session);
 		break;
 	default:
 		eprintf("%u\n", msg->k.conn_state_change.state);
@@ -205,23 +205,6 @@
 	return err;
 }
 
-static int iscsi_param_partial_set(int tid, uint64_t sid, int type, int key,
-				   uint32_t val)
-{
-	struct iscsi_param *param;
-	struct iscsi_param s_param[session_key_last];
-	struct iscsi_param t_param[target_key_last];
-
-	if (type == key_session)
-		param = s_param;
-	else
-		param = t_param;
-
-	param[key].val = val;
-
-	return iscsi_param_set(tid, sid, type, 1 << key, param);
-}
-
 static int trgt_mgmt_params(int tid, uint64_t sid, char *params)
 {
 	char *p, *q;
@@ -411,7 +394,7 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = istgt_ktarget_create(typeid, params);
+		err = istgt_ktarget_create(req->typeid, params);
 		break;
 	case OP_DELETE:
 		err = istgt_ktarget_destroy(tid);
@@ -485,138 +468,6 @@
 	return err;
 }
 
-/* This is temporary. */
-
-#define CONFIG_FILE	"/etc/ietd.conf"
-#define BUFSIZE	8192
-
-/* this is the orignal Ardis code. */
-static char *target_sep_string(char **pp)
-{
-	char *p = *pp;
-	char *q;
-
-	for (p = *pp; isspace(*p); p++)
-		;
-	for (q = p; *q && !isspace(*q); q++)
-		;
-	if (*q)
-		*q++ = 0;
-	else
-		p = NULL;
-	*pp = q;
-	return p;
-}
-
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static int driver_to_typeid(char *name)
-{
-	int i, nr, err, fd, id = -ENOENT;
-	char *p, path[PATH_MAX], buf[PATH_MAX];
-	struct dirent **namelist;
-
-	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TYPE_SYSFSDIR "/%s/name",
-			 namelist[i]->d_name);
-
-		fd = open(path, O_RDONLY);
-		if (fd < 0) {
-			eprintf("%s %d\n", path, errno);
-			continue;
-		}
-
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0) {
-			eprintf("%s %d\n", path, err);
-			continue;
-		}
-
-		if (strncmp(name, buf, strlen(name)))
-			continue;
-
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		id = atoi(p);
-		break;
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return id;
-}
-
-void initial_device_create(int tid, int64_t lun, char *params)
-{
-	char *path, *devtype;
-	char d[] = "tgt_vsd";
-
-	path = devtype = NULL;
-	kdevice_create_parser(params, &path, &devtype);
-	kdevice_create(tid, lun, path, devtype ? : d);
-}
-
-void initial_config_load(void)
-{
-	FILE *config;
-	char buf[BUFSIZE];
-	char *p, *q;
-	int idx, tid;
-	uint32_t val;
-
-	typeid = driver_to_typeid(THIS_NAME);
-
-	dprintf("%d\n", typeid);
-
-	if (!(config = fopen(CONFIG_FILE, "r")))
-		return;
-
-	tid = -1;
-	while (fgets(buf, BUFSIZE, config)) {
-		q = buf;
-		p = target_sep_string(&q);
-		if (!p || *p == '#')
-			continue;
-		if (!strcasecmp(p, "Target")) {
-			tid = 0;
-			if (!(p = target_sep_string(&q)))
-				continue;
-			dprintf("creaing target %s\n", p);
-			tid = istgt_ktarget_create(typeid, p);
-		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
-			;
-		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
-			/* target->max_sessions = strtol(q, &q, 0); */
-		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
-			uint64_t lun = strtoull(q, &q, 10);
-			initial_device_create(tid, lun, q);
-		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
-			val = strtol(q, &q, 0);
-			if (param_check_val(target_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", target_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_target, idx, val);
-		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
-			char *str = target_sep_string(&q);
-			if (param_str_to_val(session_keys, idx, str, &val) < 0)
-				continue;
-			if (param_check_val(session_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", session_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_session, idx, val);
-		}
-	}
-
-	fclose(config);
-
-	return;
-}
-
 struct iscsi_kernel_interface ioctl_ki = {
 	.param_get = iscsi_param_get,
 	.param_set = iscsi_param_set,

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/kernel/Makefile	2006-01-22 14:42:20 UTC (rev 229)
@@ -2,7 +2,7 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20 -DNETLINK_TGT_CMD=21
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= tgt_core.o

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/kernel/tgt.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -26,8 +26,6 @@
 
 MODULE_LICENSE("GPL");
 
-struct task_struct *tgtd_tsk;
-
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
@@ -204,6 +202,8 @@
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
+	dprintk("%s %d\n", target_type, queued_cmds);
+
 	target = kzalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
@@ -536,7 +536,7 @@
 	cmd->done = tgt_cmd_destroy;
 	atomic_set(&cmd->state, TGT_CMD_CREATED);
 
-	dprintk("%p %p\n", session, cmd);
+	dprintk("%p %p %p\n", session, cmd, tgt_priv);
 
 	err = tgt_cmd_hlist_add(cmd);
 	if (err) {
@@ -573,7 +573,7 @@
 	struct tgt_target *target;
 	struct tgt_cmd *cmd;
 
-	dprintk("%d %llu\n", tid, (unsigned long long) tag);
+	dprintk("%d %llx\n", tid, (unsigned long long) tag);
 
 	target = target_find(tid);
 	if (!target) {
@@ -615,6 +615,7 @@
 	up_read(&tgtd_tsk->mm->mmap_sem);
 
 	if (err < cnt) {
+		eprintk("cannot get user pages %d %d\n", err, cnt);
 		err = -EIO;
 		goto free_sg;
 	}
@@ -657,7 +658,7 @@
 	return err;
 }
 
-int uspace_cmd_done(int tid, uint64_t cid,
+int uspace_cmd_done(int tid, uint64_t cid, uint64_t devid,
 		    int result, uint32_t len, uint64_t offset,
 		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
 {
@@ -666,14 +667,15 @@
 
 	cmd = tgt_cmd_find(tid, cid);
 	if (!cmd) {
-		eprintk("Could not find command %llu\n",
+		eprintk("Could not find command %llx\n",
 			(unsigned long long) cid);
 		return -EINVAL;
 	}
 
-	dprintk("cmd %p tag %llu result %d len %d bufflen %u\n", cmd,
+	dprintk("cmd %p tag %llx result %d len %d bufflen %u\n", cmd,
 		(unsigned long long) cmd_tag(cmd), result, len, cmd->bufflen);
 
+	cmd->devid = devid;
 	cmd->uaddr = uaddr;
 	cmd->result = result;
 	cmd->offset = offset;
@@ -688,8 +690,11 @@
 /* 	target->proto->uspace_cmd_complete(cmd); */
 
 	if (cmd->bufflen) {
-		if (tgt_map_user_pages(rw, cmd))
+		int err = tgt_map_user_pages(rw, cmd);
+		if (err) {
+			eprintk("%p %d\n", cmd, err);
 			return -EIO;
+		}
 		if (cmd->data_dir == DMA_TO_DEVICE) {
 			cmd->done = tgt_write_data_transfer_done;
 			/*

Modified: trunk/kernel/tgt.h
===================================================================
--- trunk/kernel/tgt.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/kernel/tgt.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -74,6 +74,7 @@
 	int result;
 
 	unsigned long uaddr;
+	uint64_t devid;
 
 	/*
 	 * target driver private

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/kernel/tgt_nl.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -16,7 +16,7 @@
 #include "tgt_priv.h"
 
 static int tgtd_pid;
-static struct sock *nls;
+static struct sock *nls, *nls_cmd;
 
 int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
@@ -25,7 +25,7 @@
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	char *pdu;
-	int len, proto_pdu_size = proto->uspace_pdu_size;
+	int err, len, proto_pdu_size = proto->uspace_pdu_size;
 
 	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
 	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
@@ -45,12 +45,15 @@
 	ev->k.cmd_req.data_len = cmd->bufflen;
 
 	proto->uspace_pdu_build(cmd, pdu);
+	err = netlink_unicast(nls_cmd, skb, tgtd_pid, 0);
+	if (err < 0)
+		eprintk("%d\n", err);
 
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
+	return err;
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
-static int send_event_res(uint16_t type, struct tgt_event *p,
+static int send_event_res(struct sock *sk, uint16_t type, struct tgt_event *p,
 			  void *data, int dlen, gfp_t flags)
 {
 	struct tgt_event *ev;
@@ -70,7 +73,7 @@
 	if (dlen)
 		memcpy(ev->data, data, dlen);
 
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
+	return netlink_unicast(sk, skb, tgtd_pid, 0);
 }
 
 int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
@@ -82,24 +85,27 @@
 	ev.k.tgt_passthru.typeid = target->typeid;
 	ev.k.tgt_passthru.len = dlen;
 
-	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
+	return send_event_res(nls, TGT_KEVENT_TARGET_PASSTHRU,
 			      &ev, data, dlen, flags);
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
 int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags)
 {
+	struct tgt_protocol *proto = cmd->session->target->proto;
 	struct tgt_event ev;
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.cmd_done.tid = cmd->session->target->tid;
 	ev.k.cmd_done.typeid = cmd->session->target->typeid;
+	ev.k.cmd_done.devid = cmd->devid;
 	ev.k.cmd_done.uaddr = cmd->uaddr;
 	ev.k.cmd_done.len = cmd->bufflen;
 	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
 		ev.k.cmd_done.mmapped = 1;
 
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, flags);
+	return send_event_res(nls_cmd, TGT_KEVENT_CMD_DONE, &ev,
+			      empty_zero_page, proto->uspace_pdu_size, flags);
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
 
@@ -114,9 +120,13 @@
 
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
-		tgtd_pid  = NETLINK_CREDS(skb)->pid;
+		if (tgtd_pid)
+			eprintk("alstart target thread %d\n", NETLINK_CREDS(skb)->pid);
+
+		tgtd_pid = NETLINK_CREDS(skb)->pid;
 		tgtd_tsk = current;
-		eprintk("start target drivers\n");
+		eprintk("start target drivers %d\n", tgtd_pid);
+
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
@@ -148,10 +158,15 @@
 	case TGT_UEVENT_CMD_RES:
 		err = uspace_cmd_done(ev->u.cmd_res.tid,
 				      ev->u.cmd_res.cid,
+				      ev->u.cmd_res.devid,
 				      ev->u.cmd_res.result, ev->u.cmd_res.len,
 				      ev->u.cmd_res.offset,
 				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
 				      ev->u.cmd_res.try_map);
+		if (err)
+			eprintk("%llx %d\n",
+				(unsigned long long) ev->u.cmd_res.cid, err);
+
 		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);
@@ -187,7 +202,7 @@
 
 			memset(&ev, 0, sizeof(ev));
 			ev.k.event_res.err = err;
-			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+			send_event_res(nls, TGT_KEVENT_RESPONSE, &ev, NULL, 0,
 				       GFP_KERNEL | __GFP_NOFAIL);
 		}
 		skb_pull(skb, rlen);
@@ -218,5 +233,11 @@
 	if (!nls)
 		return -ENOMEM;
 
+	nls_cmd = netlink_kernel_create(NETLINK_TGT_CMD, 1, event_recv, THIS_MODULE);
+	if (!nls_cmd) {
+		sock_release(nls->sk_socket);
+		return -ENOMEM;
+	}
+
 	return 0;
 }

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/kernel/tgt_priv.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -5,7 +5,7 @@
 
 /* tgt core */
 extern struct tgt_target *target_find(int tid);
-extern int uspace_cmd_done(int tid, uint64_t cid,
+extern int uspace_cmd_done(int tid, uint64_t cid, uint64_t devid,
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,
 			   uint8_t rw, uint8_t try_map);

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/Makefile	2006-01-22 14:42:20 UTC (rev 229)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o tgt_device.o netlink.o ipc.o dl.o mgmt.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/dl.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -25,16 +25,9 @@
 #include "dl.h"
 #include "tgt_sysfs.h"
 
-struct driver_info {
-	char *name;
-	char *proto;
-	void *dl;
-	void *pdl;
-};
+struct driver_info dlinfo[MAX_DL_HANDLES];
 
-static struct driver_info dinfo[MAX_DL_HANDLES];
-
-char *typeid_to_name(int typeid)
+char *typeid_to_name(struct driver_info *dinfo, int typeid)
 {
 	return dinfo[typeid].name;
 }
@@ -71,7 +64,7 @@
 	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
 }
 
-int dl_init(void)
+int dl_init(struct driver_info *dinfo)
 {
 	int i, nr, idx;
 	char path[PATH_MAX], *p;
@@ -116,38 +109,21 @@
 	return 0;
 }
 
-void dl_config_load(void)
+void *dl_poll_init_fn(struct driver_info *dinfo, int idx)
 {
-	void (* fn)(void);
-	int i;
-
-	for (i = 0; i < MAX_DL_HANDLES; i++) {
-		if (!dinfo[i].dl)
-			continue;
-
-		fn = dlsym(dinfo[i].dl, "initial_config_load");
-		if (!fn)
-			eprintf("%s\n", dlerror());
-		else
-			fn();
-	}
-}
-
-void *dl_poll_init_fn(int idx)
-{
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "poll_init");
 	return NULL;
 }
 
-void *dl_poll_fn(int idx)
+void *dl_poll_fn(struct driver_info *dinfo, int idx)
 {
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "poll_event");
 	return NULL;
 }
 
-void *dl_ipc_fn(int typeid)
+void *dl_ipc_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, "ipc_mgmt");
@@ -155,7 +131,7 @@
 	return NULL;
 }
 
-void *dl_proto_cmd_process(int tid, int typeid)
+void *dl_proto_cmd_process(struct driver_info *dinfo, int tid, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, "cmd_process");
@@ -163,15 +139,23 @@
 	return NULL;
 }
 
-void *dl_event_fn(int tid, int typeid)
+void *dl_proto_get_devid(struct driver_info *dinfo, int tid, int typeid)
 {
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, "get_devid");
+
+	return NULL;
+}
+
+void *dl_event_fn(struct driver_info *dinfo, int tid, int typeid)
+{
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, "async_event");
 
 	return NULL;
 }
 
-void *dl_cmd_done_fn(int typeid)
+void *dl_cmd_done_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, "cmd_done");

Modified: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/dl.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -3,17 +3,25 @@
 
 #define	MAX_DL_HANDLES	16
 
-extern int dl_init(void);
-extern void dl_config_load(void);
-extern struct pollfd * dl_poll_init(int *nr);
+struct driver_info {
+	char *name;
+	char *proto;
+	void *dl;
+	void *pdl;
+};
 
-extern void *dl_poll_init_fn(int idx);
-extern void *dl_poll_fn(int idx);
-extern void *dl_ipc_fn(int typeid);
-extern void *dl_event_fn(int tid, int typeid);
-extern void *dl_proto_cmd_process(int tid, int typeid);
-extern void *dl_cmd_done_fn(int typeid);
+extern struct driver_info dlinfo[MAX_DL_HANDLES];
 
-extern char *typeid_to_name(int typeid);
+extern int dl_init(struct driver_info *);
+extern struct pollfd * dl_poll_init(struct driver_info *, int *nr);
 
+extern void *dl_poll_init_fn(struct driver_info *, int idx);
+extern void *dl_poll_fn(struct driver_info *, int idx);
+extern void *dl_ipc_fn(struct driver_info *, int typeid);
+extern void *dl_event_fn(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_cmd_process(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_get_devid(struct driver_info *, int tid, int typeid);
+extern void *dl_cmd_done_fn(struct driver_info *, int typeid);
+extern char *typeid_to_name(struct driver_info *, int typeid);
+
 #endif

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/ipc.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -22,6 +22,8 @@
 #include "tgtadm.h"
 #include "dl.h"
 
+extern int target_pfd[1024];
+
 static int ipc_accept(int afd)
 {
 	struct sockaddr addr;
@@ -50,7 +52,7 @@
 	return err;
 }
 
-void ipc_event_handle(int accept_fd)
+void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
 {
 	int fd, err;
 	char sbuf[4096], rbuf[4096];
@@ -99,9 +101,20 @@
 
 	req = NLMSG_DATA(nlh);
 
-	dprintf("%d %d %d\n", req->typeid, err, nlh->nlmsg_len);
+	dprintf("%d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len);
 
-	fn = dl_ipc_fn(req->typeid);
+	if (req->mode == MODE_DEVICE) {
+		dprintf("%d %d %d %d\n", req->tid, req->typeid, err, nlh->nlmsg_len);
+		write(target_pfd[req->tid], sbuf, NLMSG_ALIGN(nlh->nlmsg_len));
+		nlh = (struct nlmsghdr *) rbuf;
+		nlh->nlmsg_len = NLMSG_LENGTH(0);
+		res = NLMSG_DATA(nlh);
+		res->err = err;
+
+		goto send;
+	}
+
+	fn = dl_ipc_fn(dinfo, req->typeid);
 	if (fn)
 		err = fn((char *) nlh, rbuf);
 	else

Modified: trunk/usr/log.c
===================================================================
--- trunk/usr/log.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/log.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -45,7 +45,7 @@
 		return 1;
 
 	if (size < MAX_MSG_SIZE)
-		size = DEFAULT_AREA_SIZE;
+		size = LOG_SPACE_SIZE;
 
 	if ((shmid = shmget(IPC_PRIVATE, size,
 			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
@@ -304,13 +304,15 @@
 		openlog(log_name, 0, LOG_DAEMON);
 		setlogmask (LOG_UPTO (LOG_DEBUG));
 
-		if (logarea_init(size))
+		if (logarea_init(size)) {
+			syslog(LOG_ERR, "failed to initialize the logger\n");
 			return 1;
+		}
 
 		pid = fork();
 		if (pid < 0) {
-			syslog(LOG_ERR, "starting logger failed\n");
-			exit(1);
+			syslog(LOG_ERR, "fail to fork the logger\n");
+			return 1;
 		} else if (pid) {
 			syslog(LOG_WARNING,
 			       "Target daemon logger with pid=%d started!\n", pid);

Modified: trunk/usr/log.h
===================================================================
--- trunk/usr/log.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/log.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -35,7 +35,7 @@
 	struct seminfo *__buf;
 };
 
-#define DEFAULT_AREA_SIZE 16384
+#define LOG_SPACE_SIZE 16384
 #define MAX_MSG_SIZE 256
 
 extern int log_daemon;

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/mgmt.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -31,6 +31,8 @@
 #define O_LARGEFILE	0100000
 #endif
 
+int target_pfd[1024];
+
 static void nlmsg_init(struct nlmsghdr *nlh, uint32_t seq,
 		       uint16_t type, uint32_t len, uint16_t flags)
 {
@@ -72,16 +74,25 @@
 
 static void __ktarget_create(struct tgt_event *ev, struct tgtadm_req *req)
 {
-	sprintf(ev->u.c_target.type, "%s", typeid_to_name(req->typeid));
+	sprintf(ev->u.c_target.type, "%s", typeid_to_name(dlinfo, req->typeid));
+	ev->u.c_target.pid = req->pid;
 }
 
 int ktarget_create(int typeid)
 {
 	struct tgtadm_req req;
+	int fd, err;
+
 	req.typeid = typeid;
+	req.pid = target_thread_create(&fd);
+	err = tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
+				__ktarget_create);
+	if (err >= 0) {
+		dprintf("%d %d\n", err, fd);
+		target_pfd[err] = fd;
+	}
 
-	return tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
-				 __ktarget_create);
+	return err;
 }
 
 static void __ktarget_destroy(struct tgt_event *ev, struct tgtadm_req *req)
@@ -98,7 +109,7 @@
 				 __ktarget_destroy);
 }
 
-void kdevice_create_parser(char *args, char **path, char **devtype)
+static void kdevice_create_parser(char *args, char **path, char **devtype)
 {
 	char *p, *q;
 
@@ -122,11 +133,11 @@
 	}
 }
 
-int kdevice_create(int tid, uint64_t devid, char *path, char *devtype)
+static int kdevice_create(int tid, uint64_t devid, char *path)
 {
 	int fd, err;
 
-	dprintf("%d %" PRIu64 " %s %s\n", tid, devid, path, devtype);
+	dprintf("%d %" PRIu64 " %s\n", tid, devid, path);
 
 	fd = open(path, O_RDWR | O_LARGEFILE);
 	if (fd < 0) {
@@ -141,7 +152,7 @@
 	return err;
 }
 
-int kdevice_destroy(int tid, uint64_t devid)
+static int kdevice_destroy(int tid, uint64_t devid)
 {
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
@@ -199,10 +210,10 @@
 	case OP_NEW:
 		path = devtype = NULL;
 		kdevice_create_parser(params, &path, &devtype);
-		if (!path || !devtype)
-			eprintf("Invalid path or device type\n");
+		if (!path)
+			eprintf("Invalid path\n");
 		else
-			err = kdevice_create(req->tid, req->lun, path,devtype);
+			err = kdevice_create(req->tid, req->lun, path);
 		break;
 	case OP_DELETE:
 		err = kdevice_destroy(req->tid, req->lun);
@@ -214,83 +225,6 @@
 	return err;
 }
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static void all_devices_destroy(int tid)
-{
-	struct dirent **namelist;
-	char *p;
-	int i, nr;
-	uint64_t devid;
-
-	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return;
-
-	for (i = 0; i < nr; i++) {
-
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		if (tid != atoi(p))
-			continue;
-		p = strchr(p, ':');
-		if (!p)
-			continue;
-		devid = strtoull(++p, NULL, 10);
-		kdevice_destroy(tid, devid);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-}
-
-static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, i, nr, fd;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], *p;
-
-	if (req->op != OP_DELETE)
-		return err;
-
-	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
-			 namelist[i]->d_name);
-
-		fd = open(path, O_RDONLY);
-		if (fd < 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0)
-			continue;
-
-		if (req->typeid == atoi(buf)) {
-			int tid;
-
-			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-				;
-			tid = atoi(p);
-			all_devices_destroy(tid);
-			ktarget_destroy(tid);
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
-}
-
 int tgt_mgmt(char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
@@ -302,13 +236,11 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n", nlh->nlmsg_len,
+		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun,
+		params, getpid());
 
 	switch (req->mode) {
-	case MODE_SYSTEM:
-		err = system_mgmt(req, params, rbuf, &rlen);
-		break;
 	case MODE_TARGET:
 		err = target_mgmt(req, params, rbuf, &rlen);
 		break;

Modified: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/netlink.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -26,16 +26,12 @@
 #include "tgtd.h"
 #include "dl.h"
 
-#define	NL_BUFSIZE	8192
+#define	NL_BUFSIZE	1024
 
-static struct sockaddr_nl src_addr, dest_addr;
-static char *recvbuf, *sendbuf;
-
-static int __nl_write(int fd, int type, char *data, int len)
+int __nl_write(int fd, int type, char *data, int len)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl daddr;
 
 	memset(nlh, 0, sizeof(*nlh));
 	nlh->nlmsg_len = len;
@@ -43,46 +39,36 @@
 	nlh->nlmsg_flags = 0;
 	nlh->nlmsg_pid = getpid();
 
-	iov.iov_base = data;
-	iov.iov_len = len;
+	memset(&daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
+	daddr.nl_pid = 0;
+	daddr.nl_groups = 0;
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &dest_addr;
-	msg.msg_namelen = sizeof(dest_addr);
-	msg.msg_iov = (void *) &iov;
-	msg.msg_iovlen = 1;
-
-	return sendmsg(fd, &msg, 0);
+	return sendto(fd, data, len, 0, (struct sockaddr *) &daddr,
+		      sizeof(daddr));
 }
 
-static int __nl_read(int fd, void *data, int size, int flags)
+int __nl_read(int fd, void *data, int size, int flags)
 {
-	int rc;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl saddr;
+	socklen_t slen = sizeof(saddr);
 
-	iov.iov_base = data;
-	iov.iov_len = size;
+	memset(&saddr, 0, sizeof(saddr));
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = getpid();
+	saddr.nl_groups = 0; /* not in mcast groups */
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	rc = recvmsg(fd, &msg, flags);
-
-	return rc;
+	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
 }
 
-int nl_read(int fd)
+static int nl_read(int fd, char *buf)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	int err;
 
 peek_again:
-	err = __nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
+	err = __nl_read(fd, buf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
 	if (err < 0) {
 		eprintf("%d\n", err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -90,13 +76,13 @@
 		return err;
 	}
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) buf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	dprintf("nl_event_handle %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
+	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid());
 
 read_again:
-	err = __nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
+	err = __nl_read(fd, buf, nlh->nlmsg_len, 0);
 	if (err < 0) {
 		eprintf("%d\n", err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -107,87 +93,33 @@
 	return err;
 }
 
-static int cmd_queue(int fd, char *reqbuf, char *resbuf)
+void nl_event_handle(struct driver_info *dinfo, int fd)
 {
-	int result, len = 0;
-	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
-	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t offset, cid = ev_req->k.cmd_req.cid;
-	uint8_t *pdu, rw = 0, try_map = 0;
-	unsigned long uaddr;
-	int (*fn) (int, uint8_t *, int *, uint32_t,
-		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
-
-	memset(resbuf, 0, NL_BUFSIZE);
-	pdu = (uint8_t *) ev_req->data;
-	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
-
-	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid,
-				  ev_req->k.cmd_req.typeid);
-
-	if (fn)
-		result = fn(ev_req->k.cmd_req.tid,
-			    pdu,
-			    &len,
-			    ev_req->k.cmd_req.data_len,
-			    &uaddr, &rw, &try_map, &offset);
-	else {
-		result = -EINVAL;
-		eprintf("Cannot process cmd %d %" PRIu64 "\n",
-			ev_req->k.cmd_req.tid, cid);
-	}
-
-	memset(ev_res, 0, (char *) ev_res->data - (char *) ev_res);
-	ev_res->u.cmd_res.tid = ev_req->k.cmd_req.tid;
-	ev_res->u.cmd_res.cid = cid;
-	ev_res->u.cmd_res.len = len;
-	ev_res->u.cmd_res.result = result;
-	ev_res->u.cmd_res.uaddr = uaddr;
-	ev_res->u.cmd_res.rw = rw;
-	ev_res->u.cmd_res.try_map = try_map;
-	ev_res->u.cmd_res.offset = offset;
-
-	log_debug("scsi_cmd_process res %d len %d\n", result, len);
-
-	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
-}
-
-void nl_event_handle(int fd)
-{
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
+	char rbuf[NL_BUFSIZE];
 	int err;
 	void (*fn) (char *);
 
-	err = nl_read(fd);
+	err = nl_read(fd, rbuf);
 	if (err < 0)
 		return;
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) rbuf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
+	dprintf("%d %d\n", getpid(), nlh->nlmsg_type);
+
 	switch (nlh->nlmsg_type) {
-	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
-		break;
 	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dl_event_fn(ev->k.tgt_passthru.tid,
+		fn = dl_event_fn(dinfo, ev->k.tgt_passthru.tid,
 				 ev->k.tgt_passthru.typeid);
 		if (fn)
-			fn(NLMSG_DATA(recvbuf));
+			fn(NLMSG_DATA(rbuf));
 		else
 			eprintf("Cannot handle async event %d\n",
 				ev->k.tgt_passthru.tid);
 		break;
-	case TGT_KEVENT_CMD_DONE:
-		fn = dl_cmd_done_fn(ev->k.cmd_done.typeid);
-		if (fn)
-			fn(NLMSG_DATA(recvbuf));
-		else
-			eprintf("Cannot handle cmd done %d\n",
-				ev->k.cmd_done.tid);
-		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);
@@ -200,15 +132,16 @@
 {
 	int err;
 	struct nlmsghdr *nlh;
+	char buf[NL_BUFSIZE];
 
 	err = __nl_write(fd, type, sbuf, slen);
 	if (err < 0)
 		return err;
 
-	err = nl_read(fd);
+	err = nl_read(fd, buf);
 
 	if (rbuf) {
-		nlh = (struct nlmsghdr *) recvbuf;
+		nlh = (struct nlmsghdr *) buf;
 		if (rlen < nlh->nlmsg_len)
 			eprintf("Too small rbuf %d %d\n", rlen, nlh->nlmsg_len);
 		else
@@ -220,18 +153,18 @@
 	return err;
 }
 
-static int nl_start(int fd)
+int nl_start(int fd)
 {
 	int err;
 	struct tgt_event *ev;
-	char rbuf[4096];
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
+	char buf[NL_BUFSIZE];
 
 	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
-			  rbuf, sizeof(rbuf));
+			  buf, NL_BUFSIZE);
 
-	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
+	ev = (struct tgt_event *) NLMSG_DATA(buf);
 	if (err < 0 || ev->k.event_res.err < 0) {
 		eprintf("%d %d\n", err, ev->k.event_res.err);
 		return -EINVAL;
@@ -240,38 +173,13 @@
 	return 0;
 }
 
-int nl_open(void)
+int nl_init(void)
 {
-	int fd, err;
+	int fd;
 
-	sendbuf = malloc(NL_BUFSIZE * 2);
-	if (!sendbuf)
-		return -ENOMEM;
-	recvbuf = sendbuf + NL_BUFSIZE;
-
 	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd < 0) {
-		eprintf("%d\n", fd);
-		return fd;
-	}
+	if (fd < 0)
+		eprintf("Fail to create the netlink socket %d\n", errno);
 
-	memset(&src_addr, 0, sizeof(src_addr));
-	src_addr.nl_family = AF_NETLINK;
-	src_addr.nl_pid = getpid();
-	src_addr.nl_groups = 0; /* not in mcast groups */
-
-	memset(&dest_addr, 0, sizeof(dest_addr));
-	dest_addr.nl_family = AF_NETLINK;
-	dest_addr.nl_pid = 0; /* kernel */
-	dest_addr.nl_groups = 0; /* unicast */
-
-	err = nl_start(fd);
-	if (err < 0)
-		goto out;
-
 	return fd;
-
-out:
-	close(fd);
-	return err;
 }

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/scsi.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -31,7 +31,6 @@
 #include <linux/netlink.h>
 
 #include "tgtd.h"
-#include "tgt_if.h"
 #include "tgt_scsi_if.h"
 #include "tgt_sysfs.h"
 
@@ -544,6 +543,7 @@
 	void *p;
 	uint64_t off;
 	*len = 0;
+	int err = SAM_STAT_GOOD;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -566,14 +566,20 @@
 
 	off <<= 9;
 
-	p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
-		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
+	if (*uaddr)
+		*uaddr = *uaddr + (off & PAGE_MASK);
+	else {
+		p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+			 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
 
-	*uaddr = (unsigned long) p;
+		*uaddr = (unsigned long) p;
+		if (p == MAP_FAILED)
+			err = SAM_STAT_CHECK_CONDITION;
+	}
 	*offset = off;
 	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
-	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
+	return err;
 }
 
 static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
@@ -598,10 +604,10 @@
 	return result;
 }
 
-#define	TGT_INVALID_DEV_ID	~0ULL
-
-static uint64_t translate_lun(uint8_t *p, int size)
+uint64_t get_devid(uint8_t *pdu)
 {
+	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
+	uint8_t *p = scmd->lun;
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
 	switch (*p >> 6) {
@@ -622,14 +628,12 @@
 
 int cmd_process(int tid, uint8_t *pdu, int *len,
 		uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		uint8_t *try_map, uint64_t *offset)
+		uint8_t *try_map, uint64_t *offset, uint64_t lun)
 {
 	int fd, result = SAM_STAT_GOOD;
 	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
 	uint8_t *data = NULL, *scb = scmd->scb;
-	uint64_t lun;
 
-	lun = translate_lun(scmd->lun, sizeof(scmd->lun));
 	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
 
 	*offset = 0;
@@ -686,7 +690,10 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		fd = getfd(tid, lun);
+		if (*uaddr)
+			fd = 0;
+		else
+			fd = getfd(tid, lun);
 		if (fd >= 0) {
 			result = mmap_device(tid, lun, scb, len, fd, datalen,
 					     uaddr, offset);
@@ -719,17 +726,16 @@
 	return result;
 }
 
-int cmd_done(struct tgt_event *ev)
+int cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 
-	if (ev->k.cmd_done.mmapped)
-		err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
-	else
-		free((void *) ev->k.cmd_done.uaddr);
+	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
 
-	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
-		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+	if (do_munmap)
+		err = munmap((void *) (unsigned long) uaddr, len);
+	else if (do_free)
+		free((void *) (unsigned long) uaddr);
 
 	return err;
 }

Added: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/target.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -0,0 +1,484 @@
+/*
+ * Target framework target daemon
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/poll.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <linux/fs.h>
+#include <linux/netlink.h>
+
+#include <tgt_if.h>
+#include "tgtd.h"
+#include "tgtadm.h"
+#include "dl.h"
+#include "tgt_sysfs.h"
+
+#define	DEFAULT_NR_DEVICE	512
+#define	MAX_NR_DEVICE		(1 << 20)
+
+enum {
+	POLL_IPC_CTRL,
+	POLL_NL_CMD,
+};
+
+struct device {
+	int fd;
+	uint64_t addr; /* persistent mapped address */
+	uint64_t size;
+	int state;
+
+	/* queue */
+};
+
+struct target {
+	struct pollfd pfd[2];
+
+	struct device **devt;
+	uint64_t max_device;
+};
+
+static struct target *target;
+
+static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
+static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+
+static void resize_device_table(struct target *target, uint64_t did)
+{
+	struct device *device;
+	void *p, *q;
+
+	p = calloc(did + 1, sizeof(device));
+	memcpy(p, target->devt, sizeof(device) * target->max_device);
+	q = target->devt;
+	target->devt = p;
+	target->max_device = did + 1;
+	free(q);
+}
+
+static uint64_t try_mmap_device(int fd, uint64_t size)
+{
+	void *p;
+
+	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (p == MAP_FAILED)
+		return 0;
+	else
+		return (unsigned long) p;
+}
+
+int tgt_device_create(int tid, uint64_t did, int dfd)
+{
+	int err, fd;
+	struct stat st;
+	char path[PATH_MAX], buf[32];
+	uint64_t size;
+	struct device *device;
+
+	if (did >= MAX_NR_DEVICE) {
+		eprintf("Too big device id %" PRIu64 "%d\n",
+			did, MAX_NR_DEVICE);
+		return -EINVAL;
+	}
+
+	err = ioctl(dfd, BLKGETSIZE64, &size);
+	if (err < 0) {
+		eprintf("Cannot get size %d\n", dfd);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
+	err = stat(path, &st);
+	if (err < 0) {
+		eprintf("Cannot find target %d\n", tid);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
+		 tid, did);
+
+	err = mkdir(path, dmode);
+	if (err < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
+		 tid, did);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+	snprintf(buf, sizeof(buf), "%d", dfd);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot write %s\n", path);
+		return err;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
+		 tid, did);
+	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+	if (fd < 0) {
+		eprintf("Cannot create %s\n", path);
+		return err;
+	}
+	snprintf(buf, sizeof(buf), "%" PRIu64, size);
+	err = write(fd, buf, strlen(buf));
+	close(fd);
+	if (err < 0) {
+		eprintf("Cannot write %s\n", path);
+		return err;
+	}
+
+	if (did >= target->max_device)
+		resize_device_table(target, did);
+
+	device = malloc(sizeof(*device));
+	device->fd = dfd;
+	device->state = 0;
+	device->addr = try_mmap_device(dfd, size);
+	device->size = size;
+	target->devt[did] = device;
+
+	if (device->addr)
+		eprintf("Succeed to mmap the device %" PRIx64 "\n",
+			device->addr);
+
+	return 0;
+}
+
+int tgt_device_destroy(int tid, uint64_t did)
+{
+	char path[PATH_MAX];
+	int err;
+	struct device *device;
+
+	if (target->max_device <= did)
+		return -ENOENT;
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
+		 tid, did);
+	err = unlink(path);
+	if (err < 0) {
+		eprintf("Cannot unlink %s\n", path);
+		goto out;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
+		 tid, did);
+	err = unlink(path);
+	if (err < 0) {
+		eprintf("Cannot unlink %s\n", path);
+		goto out;
+	}
+
+	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
+		 tid, did);
+	err = rmdir(path);
+	if (err < 0)
+		eprintf("Cannot unlink %s\n", path);
+
+	device = target->devt[did];
+	target->devt[did] = NULL;
+	if (device->addr)
+		munmap((void *) (unsigned long) device->addr, device->size);
+
+	free(device);
+out:
+	return err;
+}
+
+int tgt_device_init(void)
+{
+	int err;
+
+	system("rm -rf " TGT_DEVICE_SYSFSDIR);
+
+	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
+	if (err < 0)
+		perror("Cannot create" TGT_DEVICE_SYSFSDIR);
+
+	return err;
+}
+
+static void ipc_ctrl(int fd)
+{
+	struct iovec iov;
+	struct msghdr msg;
+	struct nlmsghdr *nlh;
+	struct tgtadm_req *req;
+	char rbuf[2048], buf[2048];
+	int err;
+
+	nlh = (struct nlmsghdr *) rbuf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+
+	req = NLMSG_DATA(nlh);
+	dprintf("%d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len);
+
+	tgt_mgmt(rbuf, buf);
+}
+
+
+static int set_pdu_size(int fd)
+{
+	struct nlmsghdr *nlh;
+	char buf[1024];
+	int err;
+
+peek_again:
+	err = __nl_read(fd, buf, sizeof(buf), MSG_PEEK);
+	if (err < 0) {
+		if (errno == EAGAIN || errno == EINTR)
+			goto peek_again;
+		return err;
+	}
+
+	nlh = (struct nlmsghdr *) buf;
+
+	dprintf("%d\n", nlh->nlmsg_len);
+
+	return nlh->nlmsg_len;
+}
+
+static int cmd_queue(struct driver_info *dinfo, int fd, char *reqbuf)
+{
+	int result, len = 0;
+	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
+	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
+	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+	uint64_t offset, cid = ev_req->k.cmd_req.cid, devid;
+	uint8_t *pdu, rw = 0, try_map = 0;
+	unsigned long uaddr = 0;
+	static int (*fn) (int, uint8_t *, int *, uint32_t,
+			  unsigned long *, uint8_t *, uint8_t *, uint64_t *, uint64_t);
+	static uint64_t (*get_devid) (uint8_t *pdu);
+	int tid = ev_req->k.cmd_req.tid;
+	int typeid = ev_req->k.cmd_req.typeid;
+
+	memset(resbuf, 0, sizeof(resbuf));
+	pdu = (uint8_t *) ev_req->data;
+	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
+
+	if (!get_devid)
+		get_devid = dl_proto_get_devid(dinfo, tid, typeid);
+
+	if (get_devid)
+		devid = get_devid(pdu);
+	else {
+		eprintf("Cannot find get_devid\n");
+		devid = TGT_INVALID_DEV_ID;
+	}
+
+	if (target->max_device > devid && target->devt[devid])
+		uaddr = target->devt[devid]->addr;
+
+	if (!fn)
+		fn = dl_proto_cmd_process(dinfo, tid, typeid);
+	if (fn)
+		result = fn(tid,
+			    pdu,
+			    &len,
+			    ev_req->k.cmd_req.data_len,
+			    &uaddr, &rw, &try_map, &offset, devid);
+	else {
+		result = -EINVAL;
+		eprintf("Cannot process cmd %d %" PRIu64 "\n",
+			tid, cid);
+	}
+
+	ev_res->u.cmd_res.tid = tid;
+	ev_res->u.cmd_res.cid = cid;
+	ev_res->u.cmd_res.devid = devid;
+	ev_res->u.cmd_res.len = len;
+	ev_res->u.cmd_res.result = result;
+	ev_res->u.cmd_res.uaddr = uaddr;
+	ev_res->u.cmd_res.rw = rw;
+	ev_res->u.cmd_res.try_map = try_map;
+	ev_res->u.cmd_res.offset = offset;
+
+	log_debug("scsi_cmd_process res %d len %d\n", result, len);
+
+	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
+			  NLMSG_SPACE(sizeof(*ev_res)));
+}
+
+static void cmd_done(struct driver_info *dinfo, char *buf)
+{
+	static int (*done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+	struct tgt_event *ev = (struct tgt_event *) buf;
+	int err = 0;
+	int do_munmap = ev->k.cmd_done.mmapped;
+
+	if (!done)
+		done = dl_cmd_done_fn(dinfo, ev->k.cmd_done.typeid);
+
+	if (done) {
+		if (do_munmap) {
+			uint64_t devid = ev->k.cmd_done.devid;
+
+			if (devid >= target->max_device) {
+				eprintf("%" PRIu64 " %" PRIu64 "\n",
+					devid, target->max_device);
+				exit(1);
+			}
+
+			if (target->devt[devid]) {
+				if (target->devt[devid]->addr)
+					do_munmap = 0;
+			} else {
+				eprintf("%" PRIu64 " is null\n", devid);
+				exit(1);
+			}
+		}
+		err = done(do_munmap, !ev->k.cmd_done.mmapped,
+			 ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
+	} else
+		eprintf("Cannot handle cmd done\n");
+
+	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
+		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+}
+
+void nl_cmd(struct driver_info *dinfo, int fd)
+{
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+	static int pdu_size;
+	char buf[1024];
+	int err;
+
+	if (!pdu_size)
+		pdu_size = set_pdu_size(fd);
+
+	err = __nl_read(fd, buf, pdu_size, MSG_WAITALL);
+
+	nlh = (struct nlmsghdr *) buf;
+	ev = (struct tgt_event *) NLMSG_DATA(nlh);
+
+	if (nlh->nlmsg_len != pdu_size) {
+		eprintf("unexpected len %d %d\n", nlh->nlmsg_len, pdu_size);
+		exit(1);
+	}
+
+	switch (nlh->nlmsg_type) {
+	case TGT_KEVENT_CMD_REQ:
+		cmd_queue(dinfo, fd, NLMSG_DATA(buf));
+		break;
+	case TGT_KEVENT_CMD_DONE:
+		cmd_done(dinfo, NLMSG_DATA(buf));
+		break;
+	default:
+		eprintf("unknown event %u\n", nlh->nlmsg_type);
+		exit(1);
+	}
+
+}
+
+static void tthread_event_loop(struct target *target)
+{
+	struct driver_info d[MAX_DL_HANDLES];
+	struct pollfd *pfd = target->pfd;
+	int fd, err;
+
+	fd = nl_init();
+	dprintf("%d\n", fd);
+	err = nl_start(fd);
+	dprintf("%d %d\n", fd, err);
+
+	target->pfd[POLL_NL_CMD].fd = fd;
+	target->pfd[POLL_NL_CMD].events = POLLIN;
+
+	err = dl_init(d);
+	dprintf("%d\n", err);
+
+	dprintf("Target thread started %u %d\n", getpid(), fd);
+
+	while (1) {
+		err = poll(pfd, 2, -1);
+		dprintf("target thread event %d\n", err);
+
+		if (err < 0) {
+			if (errno != EINTR)
+				exit(1);
+			else
+				continue;
+		}
+
+		if (pfd[POLL_IPC_CTRL].revents)
+			ipc_ctrl(pfd[POLL_IPC_CTRL].fd);
+
+		if (pfd[POLL_NL_CMD].revents)
+			nl_cmd(d, pfd[POLL_NL_CMD].fd);
+	}
+
+	free(target);
+}
+
+int target_thread_create(int *sfd)
+{
+	pid_t pid;
+	int fd[2];
+
+	if (socketpair(AF_UNIX, SOCK_STREAM, 0, fd) < 0) {
+		eprintf("Cannot create socketpair %d\n", errno);
+		return -1;
+	}
+
+	pid = fork();
+	if (pid < 0)
+		return -ENOMEM;
+	else if (pid) {
+		*sfd = fd[0];
+		close(fd[1]);
+		return pid;
+	}
+
+	target = malloc(sizeof(*target));
+	if (!target) {
+		eprintf("Out of memoryn\n");
+		exit(1);
+	}
+
+	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct device *));
+	target->max_device = DEFAULT_NR_DEVICE;
+
+	close(fd[0]);
+	target->pfd[POLL_IPC_CTRL].fd = fd[1];
+	target->pfd[POLL_IPC_CTRL].events = POLLIN;
+
+	tthread_event_loop(target);
+
+	return 0;
+}

Modified: trunk/usr/tgt_device.c
===================================================================
--- trunk/usr/tgt_device.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/tgt_device.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -1,140 +0,0 @@
-/*
- * target framework Device
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-/*
- * This is just makeshift for removing device stuff in kernel space
- * and should be replaced soon.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#include <inttypes.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <errno.h>
-#include <asm/byteorder.h>
-#include <asm/page.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <linux/fs.h>
-
-#include "tgtd.h"
-#include "tgt_sysfs.h"
-
-static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
-static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
-
-int tgt_device_create(int tid, uint64_t lun, int dfd)
-{
-	int err, fd;
-	struct stat st;
-	char path[PATH_MAX], buf[32];
-	uint64_t size;
-
-	err = ioctl(dfd, BLKGETSIZE64, &size);
-	if (err < 0) {
-		eprintf("Cannot get size %d\n", dfd);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
-	err = stat(path, &st);
-	if (err < 0) {
-		eprintf("Cannot find target %d\n", tid);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, lun);
-
-	err = mkdir(path, dmode);
-	if (err < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%d", dfd);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%" PRIu64, size);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	return 0;
-}
-
-int tgt_device_destroy(int tid, uint64_t lun)
-{
-	char path[PATH_MAX];
-	int err;
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, lun);
-	err = unlink(path);
-	if (err < 0) {
-		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, lun);
-	err = unlink(path);
-	if (err < 0) {
-		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, lun);
-	err = rmdir(path);
-	if (err < 0)
-		eprintf("Cannot unlink %s\n", path);
-
-out:
-	return err;
-}
-
-int tgt_device_init(void)
-{
-	int err;
-
-	rmdir(TGT_DEVICE_SYSFSDIR);
-	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
-	if (err < 0)
-		perror("Cannot create");
-
-	return err;
-}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/tgtadm.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -41,6 +41,7 @@
 #define dprintf eprintf
 
 static char program_name[] = "tgtadm";
+static char *driver;
 
 static struct option const long_options[] =
 {
@@ -113,6 +114,85 @@
 	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
 }
 
+static void all_devices_destroy(int tid)
+{
+	struct dirent **namelist;
+	char *p, cmd[1024];
+	int i, nr, err;
+	uint64_t devid;
+
+	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return;
+
+	for (i = 0; i < nr; i++) {
+
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		if (tid != atoi(p))
+			continue;
+		p = strchr(p, ':');
+		if (!p)
+			continue;
+		devid = strtoull(++p, NULL, 10);
+		snprintf(cmd, sizeof(cmd),
+			 "./usr/tgtadm --driver %s --op delete --tid %d --lun %" PRIu64,
+			 driver, tid, devid);
+		err = system(cmd);
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+}
+
+static int system_mgmt(struct tgtadm_req *req)
+{
+	int err = -EINVAL, i, nr, fd;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], cmd[PATH_MAX], *p;
+
+	if (req->op != OP_DELETE)
+		return err;
+
+	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
+			 namelist[i]->d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd < 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0)
+			continue;
+
+		if (req->typeid == atoi(buf)) {
+			int tid;
+
+			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+				;
+			tid = atoi(p);
+			all_devices_destroy(tid);
+
+			snprintf(cmd, sizeof(cmd),
+				 "./usr/tgtadm --driver %s --op delete --tid %d",
+				 driver, tid);
+			err = system(cmd);
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return 0;
+}
+
 static int driver_to_typeid(char *name)
 {
 	int i, nr, err, fd, id = -ENOENT;
@@ -178,6 +258,8 @@
 		goto out;
 	}
 
+	driver = name;
+
 	return id;
 out:
 	exit(0);
@@ -388,8 +470,12 @@
 		len += strlen(params);
 	}
 
-	err = ipc_mgmt_call(sbuf, len, rbuf);
-	ipc_mgmt_result(rbuf);
+	if (req->mode == MODE_SYSTEM)
+		err = system_mgmt(req);
+	else {
+		err = ipc_mgmt_call(sbuf, len, rbuf);
+		ipc_mgmt_result(rbuf);
+	}
 out:
 	return err;
 }

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/tgtadm.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -30,6 +30,7 @@
 	uint64_t sid;
 	int cid;
 	uint64_t lun;
+	int pid;
 };
 
 struct tgtadm_res {
@@ -39,8 +40,5 @@
 extern int tgt_mgmt(char *sbuf, char *rbuf);
 extern int ktarget_destroy(int tid);
 extern int ktarget_create(int typeid);
-extern int kdevice_destroy(int tid, uint64_t devid);
-extern int kdevice_create(int tid, uint64_t devid, char *path, char *devtype);
-extern void kdevice_create_parser(char *args, char **path, char **devtype);
 
 #endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/tgtd.c	2006-01-22 14:42:20 UTC (rev 229)
@@ -1,5 +1,5 @@
 /*
- * Core target framework user-space daemon
+ * Target framework user-space main daemon
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -46,6 +46,26 @@
 
 static char program_name[] = "tgtd";
 
+static int daemon_init(void)
+{
+	pid_t pid;
+
+	pid = fork();
+	if (pid < 0)
+		return -ENOMEM;
+	else if (pid)
+		exit(0);
+
+	setsid();
+	chdir("/");
+	close(0);
+	open("/dev/null", O_RDWR);
+	dup2(0, 1);
+	dup2(0, 2);
+
+	return 0;
+}
+
 static void usage(int status)
 {
 	if (status != 0)
@@ -65,7 +85,7 @@
 static void signal_catch(int signo) {
 }
 
-static void init(int daemon, int debug)
+static void tgtd_init(void)
 {
 	int fd;
 	char path[64];
@@ -92,11 +112,6 @@
 	}
 	write(fd, "-17\n", 4);
 	close(fd);
-
-	if (log_init(program_name, DEFAULT_AREA_SIZE, daemon, debug) < 0) {
-		fprintf(stderr, "can not start the logger daemon\n");
-		exit(-1);
-	}
 }
 
 static void event_loop(int nr_dls, struct pollfd *poll_array)
@@ -114,13 +129,13 @@
 		}
 
 		if (poll_array[POLL_NL].revents)
-			nl_event_handle(nl_fd);
+			nl_event_handle(dlinfo, nl_fd);
 
 		if (poll_array[POLL_IPC].revents)
-			ipc_event_handle(ipc_fd);
+			ipc_event_handle(dlinfo, ipc_fd);
 
 		for (i = 0; i < nr_dls; i++) {
-			fn = dl_poll_fn(i);
+			fn = dl_poll_fn(dlinfo, i);
 			if (fn)
 				fn(poll_array + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
@@ -144,7 +159,7 @@
 	array[POLL_IPC].events = POLLIN;
 
 	for (i = 0; i < nr; i++) {
-		fn = dl_poll_init_fn(i);
+		fn = dl_poll_init_fn(dlinfo, i);
 		if (fn)
 			fn(array + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}
@@ -156,10 +171,10 @@
 {
 	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	pid_t pid;
 	struct pollfd *poll_array;
 
-	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
+	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
+				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':
 			is_daemon = 0;
@@ -179,42 +194,32 @@
 		}
 	}
 
-	init(is_daemon, is_debug);
+	if (is_daemon && daemon_init())
+		exit(1);
 
-	if (is_daemon) {
-		pid = fork();
-		if (pid < 0)
-			exit(-1);
-		else if (pid)
-			exit(0);
+	tgtd_init();
 
-		chdir("/");
+	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
+		exit(1);
 
-		close(0);
-		open("/dev/null", O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
+	if (tgt_device_init())
+		exit(1);
 
-	if (tgt_device_init() < 0)
-		exit(0);
-
-	nl_fd = nl_open();
+	nl_fd = nl_init();
 	if (nl_fd < 0)
-		exit(nl_fd);
+		exit(1);
+	if (nl_start(nl_fd))
+		exit(1);
 
 	ipc_fd = ipc_open();
 	if (ipc_fd < 0)
 		exit(ipc_fd);
 
-	dl_init();
+	dl_init(dlinfo);
 
 	nr = MAX_DL_HANDLES;
 	poll_array = poll_init(nr);
 
-	dl_config_load();
-
 	event_loop(nr, poll_array);
 
 	return 0;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-01-22 04:32:06 UTC (rev 228)
+++ trunk/usr/tgtd.h	2006-01-22 14:42:20 UTC (rev 229)
@@ -2,15 +2,23 @@
 #define __TARGET_DAEMON_H
 
 #include "log.h"
+#include "dl.h"
 
+#define	TGT_INVALID_DEV_ID	~0ULL
+
 extern int nl_fd;
 
-extern int nl_open(void);
-extern void nl_event_handle(int fd);
+extern int target_thread_create(int *fd);
+
+extern int nl_init(void);
+extern void nl_event_handle(struct driver_info *, int fd);
 extern int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen);
+extern int nl_start(int fd);
+extern int __nl_write(int fd, int type, char *data, int len);
+extern int __nl_read(int fd, void *data, int size, int flags);
 
 extern int ipc_open(void);
-extern void ipc_event_handle(int fd);
+extern void ipc_event_handle(struct driver_info *, int fd);
 
 extern int tgt_device_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, int dfd);



From tomo at berlios.de  Thu Jan 26 06:29:14 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 26 Jan 2006 06:29:14 +0100
Subject: [Stgt-svn] r230 - in trunk: . istgt/usr kernel usr
Message-ID: <200601260529.k0Q5TE4o010913@sheep.berlios.de>

Author: tomo
Date: 2006-01-26 06:29:12 +0100 (Thu, 26 Jan 2006)
New Revision: 230

Modified:
   trunk/initd
   trunk/istgt/usr/ctldev.c
   trunk/kernel/Makefile
   trunk/kernel/tgt.c
   trunk/kernel/tgt_nl.c
   trunk/kernel/tgt_priv.h
   trunk/kernel/tgt_target.h
   trunk/usr/ipc.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Fix the previous commit.

Modified: trunk/initd
===================================================================
--- trunk/initd	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/initd	2006-01-26 05:29:12 UTC (rev 230)
@@ -41,6 +41,8 @@
 
 	killall -9 tgtd
 
+	sleep 1
+
 	if [ $TARGET = "istgt" ] ; then
 		rmmod istgt
 	else

Modified: trunk/istgt/usr/ctldev.c
===================================================================
--- trunk/istgt/usr/ctldev.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/istgt/usr/ctldev.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -409,21 +409,6 @@
 	return err;
 }
 
-static int user_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int conn_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int session_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
 int ipc_mgmt(char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
@@ -439,21 +424,13 @@
 		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
 
 	switch (req->mode) {
-	case MODE_DEVICE:
-	case MODE_SYSTEM:
-		err = tgt_mgmt(sbuf, rbuf);
-		break;
 	case MODE_TARGET:
 		err = istgt_target_mgmt(req, params, rbuf, &rlen);
 		break;
 	case MODE_SESSION:
-		err = session_mgmt(req, params, rbuf, &rlen);
-		break;
 	case MODE_CONNECTION:
-		err = conn_mgmt(req, params, rbuf, &rlen);
-		break;
 	case MODE_USER:
-		err = user_mgmt(req, params, rbuf, &rlen);
+		err = 0;
 		break;
 	default:
 		eprintf("Unknown mode %d\n", req->mode);

Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/kernel/Makefile	2006-01-26 05:29:12 UTC (rev 230)
@@ -2,7 +2,7 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20 -DNETLINK_TGT_CMD=21
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= tgt_core.o

Modified: trunk/kernel/tgt.c
===================================================================
--- trunk/kernel/tgt.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/kernel/tgt.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -26,6 +26,8 @@
 
 MODULE_LICENSE("GPL");
 
+struct task_struct *tgtd_tsk;
+
 static spinlock_t all_targets_lock;
 static LIST_HEAD(all_targets);
 
@@ -195,19 +197,22 @@
 	return target;
 }
 
-struct tgt_target *tgt_target_create(char *target_type, int queued_cmds)
+struct tgt_target *tgt_target_create(char *target_type, int queued_cmds, int pid)
 {
 	char name[16];
 	static int i, target_id;
 	struct tgt_target *target;
 	struct target_type_internal *ti;
 
-	dprintk("%s %d\n", target_type, queued_cmds);
+	dprintk("%s %d %d\n", target_type, queued_cmds, pid);
 
 	target = kzalloc(sizeof(*target), GFP_KERNEL);
 	if (!target)
 		return NULL;
 
+	target->tsk = find_task_by_pid(pid);
+	if (!target->tsk)
+		goto free_target;
 	ti = target_template_get(target_type);
 	if (!ti)
 		goto free_target;
@@ -595,6 +600,7 @@
 	struct page *page, **pages;
 	uint64_t poffset = cmd->offset & ~PAGE_MASK;
 	uint32_t size, rest = cmd->bufflen;
+	struct task_struct *tsk = cmd->session->target->tsk;
 
 	cnt = pgcnt(cmd->bufflen, cmd->offset);
 	pages = kzalloc(cnt * sizeof(struct page *), GFP_KERNEL);
@@ -609,10 +615,10 @@
 
 	dprintk("cmd %p addr %lx cnt %d\n", cmd, cmd->uaddr, cnt);
 
-	down_read(&tgtd_tsk->mm->mmap_sem);
-	err = get_user_pages(tgtd_tsk, tgtd_tsk->mm, cmd->uaddr, cnt,
+	down_read(&tsk->mm->mmap_sem);
+	err = get_user_pages(tsk, tsk->mm, cmd->uaddr, cnt,
 			     rw == WRITE, 0, pages, NULL);
-	up_read(&tgtd_tsk->mm->mmap_sem);
+	up_read(&tsk->mm->mmap_sem);
 
 	if (err < cnt) {
 		eprintk("cannot get user pages %d %d\n", err, cnt);

Modified: trunk/kernel/tgt_nl.c
===================================================================
--- trunk/kernel/tgt_nl.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/kernel/tgt_nl.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -16,7 +16,8 @@
 #include "tgt_priv.h"
 
 static int tgtd_pid;
-static struct sock *nls, *nls_cmd;
+static struct sock *nls;
+static void *zero_page;
 
 int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
 {
@@ -24,6 +25,7 @@
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
+	pid_t pid = cmd->session->target->tsk->pid;
 	char *pdu;
 	int err, len, proto_pdu_size = proto->uspace_pdu_size;
 
@@ -33,7 +35,7 @@
 		return -ENOMEM;
 
 	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
+	nlh = __nlmsg_put(skb, pid, 0, TGT_KEVENT_CMD_REQ,
 			  len - sizeof(*nlh), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
@@ -45,16 +47,17 @@
 	ev->k.cmd_req.data_len = cmd->bufflen;
 
 	proto->uspace_pdu_build(cmd, pdu);
-	err = netlink_unicast(nls_cmd, skb, tgtd_pid, 0);
-	if (err < 0)
-		eprintk("%d\n", err);
-
+	err = netlink_unicast(nls, skb, pid, 0);
+	if (err < 0) {
+		eprintk("%d %d\n", pid, err);
+		BUG();
+	}
 	return err;
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
 
-static int send_event_res(struct sock *sk, uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags)
+static int send_event_res(uint16_t type, struct tgt_event *p,
+			  void *data, int dlen, gfp_t flags, uint32_t pid)
 {
 	struct tgt_event *ev;
 	struct nlmsghdr *nlh;
@@ -66,14 +69,14 @@
 	if (!skb)
 		return -ENOMEM;
 
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, type, len - sizeof(*nlh), 0);
+	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
 
 	ev = NLMSG_DATA(nlh);
 	memcpy(ev, p, sizeof(*ev));
 	if (dlen)
 		memcpy(ev->data, data, dlen);
 
-	return netlink_unicast(sk, skb, tgtd_pid, 0);
+	return netlink_unicast(nls, skb, pid, 0);
 }
 
 int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
@@ -85,8 +88,8 @@
 	ev.k.tgt_passthru.typeid = target->typeid;
 	ev.k.tgt_passthru.len = dlen;
 
-	return send_event_res(nls, TGT_KEVENT_TARGET_PASSTHRU,
-			      &ev, data, dlen, flags);
+	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
+			      &ev, data, dlen, flags, tgtd_pid);
 }
 EXPORT_SYMBOL_GPL(tgt_msg_send);
 
@@ -94,6 +97,7 @@
 {
 	struct tgt_protocol *proto = cmd->session->target->proto;
 	struct tgt_event ev;
+	pid_t pid = cmd->session->target->tsk->pid;
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.cmd_done.tid = cmd->session->target->tid;
@@ -104,8 +108,9 @@
 	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
 		ev.k.cmd_done.mmapped = 1;
 
-	return send_event_res(nls_cmd, TGT_KEVENT_CMD_DONE, &ev,
-			      empty_zero_page, proto->uspace_pdu_size, flags);
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev,
+			      zero_page,
+			      proto->uspace_pdu_size, flags, pid);
 }
 EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
 
@@ -120,20 +125,23 @@
 
 	switch (nlh->nlmsg_type) {
 	case TGT_UEVENT_START:
-		if (tgtd_pid)
-			eprintk("alstart target thread %d\n", NETLINK_CREDS(skb)->pid);
+		if (!tgtd_pid) {
+			tgtd_pid = NETLINK_CREDS(skb)->pid;
+			eprintk("target core start %d\n", tgtd_pid);
+		} else
+			eprintk("target core already started %d\n",
+				NETLINK_CREDS(skb)->pid);
 
-		tgtd_pid = NETLINK_CREDS(skb)->pid;
-		tgtd_tsk = current;
-		eprintk("start target drivers %d\n", tgtd_pid);
-
 		break;
 	case TGT_UEVENT_TARGET_CREATE:
 		target = tgt_target_create(ev->u.c_target.type,
-					   ev->u.c_target.nr_cmds);
-		if (target)
+					   ev->u.c_target.nr_cmds,
+					   ev->u.c_target.pid);
+		if (target) {
 			err = target->tid;
-		else
+			dprintk("%d %d %d\n", target->tid,
+				target->tsk->pid, err);
+		} else
 			err = -EINVAL;
 		break;
 	case TGT_UEVENT_TARGET_DESTROY:
@@ -163,9 +171,11 @@
 				      ev->u.cmd_res.offset,
 				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
 				      ev->u.cmd_res.try_map);
-		if (err)
+		if (err) {
 			eprintk("%llx %d\n",
 				(unsigned long long) ev->u.cmd_res.cid, err);
+			BUG();
+		}
 
 		break;
 	default:
@@ -202,8 +212,9 @@
 
 			memset(&ev, 0, sizeof(ev));
 			ev.k.event_res.err = err;
-			send_event_res(nls, TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-				       GFP_KERNEL | __GFP_NOFAIL);
+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+				       GFP_KERNEL | __GFP_NOFAIL,
+				       nlh->nlmsg_pid);
 		}
 		skb_pull(skb, rlen);
 	}
@@ -224,18 +235,20 @@
 
 void __exit tgt_nl_exit(void)
 {
+	free_page((unsigned long) zero_page);
 	sock_release(nls->sk_socket);
 }
 
 int __init tgt_nl_init(void)
 {
-	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
-	if (!nls)
+	zero_page = (void *) get_zeroed_page(GFP_KERNEL);
+	if (!zero_page)
 		return -ENOMEM;
 
-	nls_cmd = netlink_kernel_create(NETLINK_TGT_CMD, 1, event_recv, THIS_MODULE);
-	if (!nls_cmd) {
-		sock_release(nls->sk_socket);
+	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
+	if (!nls) {
+		eprintk("Cannot create netlink socket %d\n", NETLINK_TGT);
+		free_page((unsigned long) zero_page);
 		return -ENOMEM;
 	}
 

Modified: trunk/kernel/tgt_priv.h
===================================================================
--- trunk/kernel/tgt_priv.h	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/kernel/tgt_priv.h	2006-01-26 05:29:12 UTC (rev 230)
@@ -9,7 +9,6 @@
 			   int result, uint32_t len, uint64_t offset,
 			   unsigned long addr,
 			   uint8_t rw, uint8_t try_map);
-extern struct task_struct *tgtd_tsk;
 
 /* netlink */
 extern void tgt_nl_exit(void);

Modified: trunk/kernel/tgt_target.h
===================================================================
--- trunk/kernel/tgt_target.h	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/kernel/tgt_target.h	2006-01-26 05:29:12 UTC (rev 230)
@@ -123,12 +123,13 @@
 	struct work_struct send_work;
 
 	struct workqueue_struct *twq;
+	struct task_struct *tsk;
 };
 
 #define cdev_to_tgt_target(cdev) \
 	container_of(cdev, struct tgt_target, cdev)
 
-extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds);
+extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds, int pid);
 extern int tgt_target_destroy(struct tgt_target *target);
 
 extern int tgt_target_template_register(struct tgt_target_template *tt);

Modified: trunk/usr/ipc.c
===================================================================
--- trunk/usr/ipc.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/ipc.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -8,9 +8,11 @@
 
 #include <errno.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
 #include <inttypes.h>
+#include <poll.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/un.h>
@@ -22,7 +24,9 @@
 #include "tgtadm.h"
 #include "dl.h"
 
-extern int target_pfd[1024];
+struct tgt_task {
+	int fd;
+};
 
 static int ipc_accept(int afd)
 {
@@ -52,15 +56,61 @@
 	return err;
 }
 
+void pipe_event_handle(int fd)
+{
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	char buf[1024];
+	struct tgtadm_res *res;
+	struct tgt_task *task;
+	int err;
+
+	nlh = (struct nlmsghdr *) buf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+		return;
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		return;
+
+	res = NLMSG_DATA(nlh);
+	dprintf("%d %d %lx\n", err, nlh->nlmsg_len, res->addr);
+
+	task = (struct tgt_task *) res->addr;
+	if (!task)
+		return;
+
+	dprintf("%d\n", task->fd);
+
+	err = write(task->fd, nlh, nlh->nlmsg_len);
+	close(task->fd);
+	free(task);
+}
+
 void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
 {
-	int fd, err;
+	int fd, err, done = 0;
 	char sbuf[4096], rbuf[4096];
 	struct nlmsghdr *nlh;
 	struct iovec iov;
 	struct msghdr msg;
 	struct tgtadm_res *res;
 	struct tgtadm_req *req;
+	struct tgt_task *task;
 	int (*fn) (char *, char *);
 
 	fd = ipc_accept(accept_fd);
@@ -99,26 +149,36 @@
 	if (err < 0)
 		goto fail;
 
+	task = calloc(1, sizeof(*task));
+	if (!task) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	task->fd = fd;
+
 	req = NLMSG_DATA(nlh);
+	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
 
-	dprintf("%d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len);
-
-	if (req->mode == MODE_DEVICE) {
-		dprintf("%d %d %d %d\n", req->tid, req->typeid, err, nlh->nlmsg_len);
-		write(target_pfd[req->tid], sbuf, NLMSG_ALIGN(nlh->nlmsg_len));
-		nlh = (struct nlmsghdr *) rbuf;
-		nlh->nlmsg_len = NLMSG_LENGTH(0);
-		res = NLMSG_DATA(nlh);
-		res->err = err;
-
-		goto send;
+	switch (req->mode) {
+	case MODE_DEVICE:
+		dprintf("%d %d %d %d %lx\n",
+			req->tid, req->typeid, err, nlh->nlmsg_len,
+			(unsigned long) task);
+		req->addr = (unsigned long) task;
+		write(poll_array[POLLS_PER_DRV + req->tid].fd,
+		      sbuf, NLMSG_ALIGN(nlh->nlmsg_len));
+		break;
+	default:
+		fn = dl_ipc_fn(dinfo, req->typeid);
+		if (fn)
+			err = fn((char *) nlh, rbuf);
+		else
+			err = tgt_mgmt((char *) nlh, rbuf);
+		done = 1;
 	}
 
-	fn = dl_ipc_fn(dinfo, req->typeid);
-	if (fn)
-		err = fn((char *) nlh, rbuf);
-	else
-		err = tgt_mgmt((char *) nlh, rbuf);
+	if (!done)
+		return;
 
 send:
 	err = write(fd, nlh, nlh->nlmsg_len);

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/mgmt.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <poll.h>
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
@@ -31,8 +32,6 @@
 #define O_LARGEFILE	0100000
 #endif
 
-int target_pfd[1024];
-
 static void nlmsg_init(struct nlmsghdr *nlh, uint32_t seq,
 		       uint16_t type, uint32_t len, uint16_t flags)
 {
@@ -89,7 +88,14 @@
 				__ktarget_create);
 	if (err >= 0) {
 		dprintf("%d %d\n", err, fd);
-		target_pfd[err] = fd;
+
+		/* FIXME */
+		if (err > POLLS_PER_DRV)
+			eprintf("too large tid %d\n", err);
+		else {
+			poll_array[POLLS_PER_DRV + err].fd = fd;
+			poll_array[POLLS_PER_DRV + err].events = POLLIN;
+		}
 	}
 
 	return err;
@@ -252,7 +258,7 @@
 	}
 
 	nlh = (struct nlmsghdr *) rbuf;
-	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
+	nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*res) + rlen);
 	res = NLMSG_DATA(nlh);
 	res->err = err;
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/target.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -224,6 +224,7 @@
 	struct msghdr msg;
 	struct nlmsghdr *nlh;
 	struct tgtadm_req *req;
+	struct tgtadm_res *res;
 	char rbuf[2048], buf[2048];
 	int err;
 
@@ -248,6 +249,12 @@
 	dprintf("%d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len);
 
 	tgt_mgmt(rbuf, buf);
+
+	nlh = (struct nlmsghdr *) buf;
+	res = NLMSG_DATA(nlh);
+	res->addr = req->addr;
+	dprintf("%d %lx\n", nlh->nlmsg_len, res->addr);
+	err = write(fd, nlh, nlh->nlmsg_len);
 }
 
 
@@ -371,7 +378,7 @@
 		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
 }
 
-void nl_cmd(struct driver_info *dinfo, int fd)
+static void nl_cmd(struct driver_info *dinfo, int fd)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
@@ -406,6 +413,18 @@
 
 }
 
+static int bind_nls(int fd)
+{
+	struct sockaddr_nl addr;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.nl_family = AF_NETLINK;
+	addr.nl_pid = getpid();
+	addr.nl_groups = 0;
+
+	return bind(fd, (struct sockaddr *)&addr, sizeof(addr));
+}
+
 static void tthread_event_loop(struct target *target)
 {
 	struct driver_info d[MAX_DL_HANDLES];
@@ -414,8 +433,8 @@
 
 	fd = nl_init();
 	dprintf("%d\n", fd);
-	err = nl_start(fd);
-	dprintf("%d %d\n", fd, err);
+	err = bind_nls(fd);
+	dprintf("%d\n", err);
 
 	target->pfd[POLL_NL_CMD].fd = fd;
 	target->pfd[POLL_NL_CMD].events = POLLIN;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/tgtadm.h	2006-01-26 05:29:12 UTC (rev 230)
@@ -31,14 +31,17 @@
 	int cid;
 	uint64_t lun;
 	int pid;
+
+	unsigned long addr;
 };
 
 struct tgtadm_res {
 	int err;
+	unsigned long addr;
 };
 
-extern int tgt_mgmt(char *sbuf, char *rbuf);
 extern int ktarget_destroy(int tid);
 extern int ktarget_create(int typeid);
+extern int tgt_mgmt(char *sbuf, char *rbuf);
 
 #endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/tgtd.c	2006-01-26 05:29:12 UTC (rev 230)
@@ -26,9 +26,8 @@
 #include "tgtd.h"
 #include "dl.h"
 
-#define	POLLS_PER_DRV	32
-
 int nl_fd, ipc_fd;
+struct pollfd *poll_array;
 
 enum {
 	POLL_NL,
@@ -114,9 +113,11 @@
 	close(fd);
 }
 
+/* TODO: rewrite makeshift poll code */
+
 static void event_loop(int nr_dls, struct pollfd *poll_array)
 {
-	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
+	int err, i, poll_max = (nr_dls + 2) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
 
 	while (1) {
@@ -128,16 +129,29 @@
 			continue;
 		}
 
-		if (poll_array[POLL_NL].revents)
+		if (poll_array[POLL_NL].revents) {
 			nl_event_handle(dlinfo, nl_fd);
+			err--;
+		}
 
-		if (poll_array[POLL_IPC].revents)
+		if (poll_array[POLL_IPC].revents) {
 			ipc_event_handle(dlinfo, ipc_fd);
+			err--;
+		}
 
+		if (!err)
+			continue;
+
+		for (i = POLLS_PER_DRV; i < POLLS_PER_DRV * 2; i++)
+			if (poll_array[i].revents) {
+				dprintf("target process event %d\n", i);
+				pipe_event_handle(poll_array[i].fd);
+			}
+
 		for (i = 0; i < nr_dls; i++) {
 			fn = dl_poll_fn(dlinfo, i);
 			if (fn)
-				fn(poll_array + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
+				fn(poll_array + ((i + 2) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
 	}
 }
@@ -148,8 +162,7 @@
 	void (* fn)(struct pollfd *, int);
 	int i;
 
-	array = calloc((nr + 1) * POLLS_PER_DRV,
-		       sizeof(struct pollfd));
+	array = calloc((nr + 2) * POLLS_PER_DRV, sizeof(struct pollfd));
 	if (!array)
 		exit(-ENOMEM);
 
@@ -161,7 +174,7 @@
 	for (i = 0; i < nr; i++) {
 		fn = dl_poll_init_fn(dlinfo, i);
 		if (fn)
-			fn(array + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
+			fn(array + (i + 2) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}
 
 	return array;
@@ -171,7 +184,6 @@
 {
 	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	struct pollfd *poll_array;
 
 	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
 				 &longindex)) >= 0) {

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-01-22 14:42:20 UTC (rev 229)
+++ trunk/usr/tgtd.h	2006-01-26 05:29:12 UTC (rev 230)
@@ -6,7 +6,10 @@
 
 #define	TGT_INVALID_DEV_ID	~0ULL
 
+/* temporarily */
+#define	POLLS_PER_DRV	32
 extern int nl_fd;
+extern struct pollfd *poll_array;
 
 extern int target_thread_create(int *fd);
 
@@ -19,6 +22,7 @@
 
 extern int ipc_open(void);
 extern void ipc_event_handle(struct driver_info *, int fd);
+extern void pipe_event_handle(int fd);
 
 extern int tgt_device_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, int dfd);



From mnc at berlios.de  Fri Jan 27 23:01:11 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:01:11 +0100
Subject: [Stgt-svn] r231 - branches/use-scsi-ml/kernel
Message-ID: <200601272201.k0RM1BIC032116@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:01:10 +0100 (Fri, 27 Jan 2006)
New Revision: 231

Removed:
   branches/use-scsi-ml/kernel/Makefile
   branches/use-scsi-ml/kernel/tgt.c
   branches/use-scsi-ml/kernel/tgt.h
   branches/use-scsi-ml/kernel/tgt_nl.c
   branches/use-scsi-ml/kernel/tgt_priv.h
   branches/use-scsi-ml/kernel/tgt_protocol.c
   branches/use-scsi-ml/kernel/tgt_protocol.h
   branches/use-scsi-ml/kernel/tgt_scsi.c
   branches/use-scsi-ml/kernel/tgt_scsi.h
   branches/use-scsi-ml/kernel/tgt_sysfs.c
   branches/use-scsi-ml/kernel/tgt_target.h
   branches/use-scsi-ml/kernel/tgt_types.h
Log:
remove old files

Deleted: branches/use-scsi-ml/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/kernel/Makefile	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/Makefile	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,25 +0,0 @@
-#
-# Makefile for the Linux kernel device drivers.
-#
-
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=20
-
-ifneq ($(KERNELRELEASE),)
-obj-m		+= tgt_core.o
-tgt_core-objs	:= tgt.o tgt_nl.o tgt_sysfs.o tgt_protocol.o
-
-obj-m		+= tgt_scsi.o
-else
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-PWD := $(shell pwd)
-
-default:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) modules
-
-clean:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) clean
-endif

Deleted: branches/use-scsi-ml/kernel/tgt.c
===================================================================
--- branches/use-scsi-ml/kernel/tgt.c	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt.c	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,738 +0,0 @@
-/*
- * Core Target Framework code
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/list.h>
-#include <linux/pagemap.h>
-#include <linux/slab.h>
-#include <linux/mempool.h>
-#include <linux/blkdev.h>
-#include <linux/file.h>
-#include <linux/hash.h>
-#include <asm/scatterlist.h>
-
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_if.h>
-#include <tgt_protocol.h>
-
-#include "tgt_priv.h"
-
-MODULE_LICENSE("GPL");
-
-struct task_struct *tgtd_tsk;
-
-static spinlock_t all_targets_lock;
-static LIST_HEAD(all_targets);
-
-static spinlock_t target_tmpl_lock;
-static LIST_HEAD(target_tmpl_list);
-
-static struct target_type_internal *target_template_get(const char *name)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &target_tmpl_list, list)
-		if (!strcmp(name, ti->tt->name)) {
-			if (!try_module_get(ti->tt->module))
-				ti = NULL;
-			spin_unlock_irqrestore(&target_tmpl_lock, flags);
-			return ti;
-		}
-
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	return NULL;
-}
-
-static void target_template_put(struct tgt_target_template *tt)
-{
-	module_put(tt->module);
-}
-
-int tgt_target_template_register(struct tgt_target_template *tt)
-{
-	static atomic_t target_type_id = ATOMIC_INIT(0);
-	unsigned long flags;
-	struct target_type_internal *ti;
-	int err;
-
-	ti = kzalloc(sizeof(*ti), GFP_KERNEL);
-	if (!ti)
-		return -ENOMEM;
-
-	INIT_LIST_HEAD(&ti->list);
-	ti->tt = tt;
-
-	ti->proto = tgt_protocol_get(tt->protocol);
-	if (!ti->proto) {
-		eprintk("Could not find %s protocol\n", tt->protocol);
-		kfree(ti);
-		return -EINVAL;
-	}
-
-	ti->typeid = atomic_add_return(1, &target_type_id);
-
-	err = tgt_sysfs_register_type(ti);
-	if (err)
-		goto proto_put;
-
-	/* set some defaults if not set */
-
-	/*
-	 * If the driver imposes no hard sector transfer limit, start at
-	 * machine infinity initially.
-	 */
-	if (!tt->max_sectors)
-		tt->max_sectors = TGT_DEFAULT_MAX_SECTORS;
-	/*
-	 * assume a 4GB boundary, if not set
-	 */
-	if (!tt->seg_boundary_mask)
-		tt->seg_boundary_mask = 0xffffffff;
-
-	if (!tt->max_segment_size)
-		tt->max_segment_size = MAX_SEGMENT_SIZE;
-
-	if (!tt->max_hw_segments)
-		tt->max_hw_segments = MAX_HW_SEGMENTS;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-	list_add_tail(&ti->list, &target_tmpl_list);
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	return 0;
-
-proto_put:
-	tgt_protocol_put(ti->proto);
-	kfree(ti);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(tgt_target_template_register);
-
-void tgt_target_template_unregister(struct tgt_target_template *tt)
-{
-	unsigned long flags;
-	struct target_type_internal *ti;
-
-	spin_lock_irqsave(&target_tmpl_lock, flags);
-
-	list_for_each_entry(ti, &target_tmpl_list, list)
-		if (ti->tt == tt) {
-			list_del(&ti->list);
-			goto found;
-		}
-	ti = NULL;
-found:
-	spin_unlock_irqrestore(&target_tmpl_lock, flags);
-
-	if (ti) {
-		tgt_protocol_put(ti->proto);
-		tgt_sysfs_unregister_type(ti);
-	}
-}
-EXPORT_SYMBOL_GPL(tgt_target_template_unregister);
-
-static void tgt_cmd_uspace_queue(struct tgt_target *target, gfp_t gfp_mask)
-{
-	unsigned long flags;
-	struct tgt_cmd *cmd;
-	int err = 0;
-
-retry:
-	spin_lock_irqsave(&target->lock, flags);
-	if (!list_empty(&target->uspace_cmd_queue)) {
-		cmd = list_entry(target->uspace_cmd_queue.next,
-				 struct tgt_cmd, cqueue);
-		list_del(&cmd->cqueue);
-		spin_unlock_irqrestore(&target->lock, flags);
-
-		err = tgt_uspace_cmd_send(cmd, gfp_mask);
-		if (err < 0) {
-			spin_lock_irqsave(&target->lock, flags);
-			list_add(&cmd->cqueue, &target->uspace_cmd_queue);
-			goto out;
-		}
-		goto retry;
-	}
-out:
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	if (err < 0)
-		queue_work(target->twq, &target->send_work);
-}
-
-static void tgt_cmd_uspace_queue_worker(void *data)
-{
-	struct tgt_target *target = data;
-
-	down(&target->uspace_sem);
-	tgt_cmd_uspace_queue(target, GFP_KERNEL);
-	up(&target->uspace_sem);
-}
-
-struct tgt_target *target_find(int tid)
-{
-	struct tgt_target *target;
-
-	spin_lock(&all_targets_lock);
-	list_for_each_entry(target, &all_targets, tlist) {
-		if (target->tid == tid)
-			goto found;
-	}
-	target = NULL;
-found:
-	spin_unlock(&all_targets_lock);
-
-	return target;
-}
-
-struct tgt_target *tgt_target_create(char *target_type, int queued_cmds)
-{
-	char name[16];
-	static int i, target_id;
-	struct tgt_target *target;
-	struct target_type_internal *ti;
-
-	target = kzalloc(sizeof(*target), GFP_KERNEL);
-	if (!target)
-		return NULL;
-
-	ti = target_template_get(target_type);
-	if (!ti)
-		goto free_target;
-
-	target->state = TGT_CREATED;
-	target->tt = ti->tt;
-	target->proto = ti->proto;
-	target->typeid = ti->typeid;
-	target->tid = target_id++;
-	spin_lock_init(&target->lock);
-	init_MUTEX(&target->uspace_sem);
-
-	INIT_LIST_HEAD(&target->session_list);
-	for (i = 0; i < ARRAY_SIZE(target->cmd_hlist); i++)
-		INIT_LIST_HEAD(&target->cmd_hlist[i]);
-	INIT_LIST_HEAD(&target->uspace_cmd_queue);
-
-	target->queued_cmds = queued_cmds ? : TGT_QUEUE_DEPTH;
-
-	snprintf(name, sizeof(name), "tgtd%d", target->tid);
-	target->twq = create_workqueue(name);
-	if (!target->twq)
-		goto put_template;
-
-	target->tt_data = kzalloc(target->tt->priv_data_size, GFP_KERNEL);
-	if (!target->tt_data)
-		goto free_workqueue;
-
-	if (target->tt->target_create)
-		if (target->tt->target_create(target))
-			goto free_priv_tt_data;
-
-	if (tgt_sysfs_register_target(target))
-		goto tt_destroy;
-
-	INIT_WORK(&target->send_work, tgt_cmd_uspace_queue_worker, target);
-
-	spin_lock(&all_targets_lock);
-	list_add(&target->tlist, &all_targets);
-	spin_unlock(&all_targets_lock);
-	return target;
-
-tt_destroy:
-	if (target->tt->target_destroy)
-		target->tt->target_destroy(target);
-free_priv_tt_data:
-	kfree(target->tt_data);
-free_workqueue:
-	destroy_workqueue(target->twq);
-put_template:
-	target_template_put(target->tt);
-free_target:
-	kfree(target);
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(tgt_target_create);
-
-int tgt_target_destroy(struct tgt_target *target)
-{
-	unsigned long flags;
-
-	dprintk("%p\n", target);
-
-	spin_lock_irqsave(&target->lock, flags);
-	/* userspace and maybe a hotunplug are racing (TODO refcounts) */
-	if (target->state == TGT_DESTROYED)
-		return -ENODEV;
-	target->state = TGT_DESTROYED;
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	spin_lock(&all_targets_lock);
-	list_del(&target->tlist);
-	spin_unlock(&all_targets_lock);
-
-	if (target->tt->target_destroy)
-		target->tt->target_destroy(target);
-
-	destroy_workqueue(target->twq);
-	target_template_put(target->tt);
-	tgt_sysfs_unregister_target(target);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_target_destroy);
-
-static void tgt_session_op_init(struct tgt_session *session,
-				void (*func)(void *),
-				tgt_session_done_t *done, void *arg)
-{
-	session->done = done;
-	session->arg = arg;
-	INIT_WORK(&session->work, func, session);
-	queue_work(session->target->twq, &session->work);
-}
-
-static void tgt_session_async_create(void *data)
-{
-	struct tgt_session *session = (struct tgt_session *) data;
-	struct tgt_target *target = session->target;
-	struct tgt_protocol *proto = session->target->proto;
-	unsigned long flags;
-	int err = 0;
-
-	session->cmd_pool = mempool_create(TGT_MAX_CMD, mempool_alloc_slab,
-					   mempool_free_slab, proto->cmd_cache);
-	if (!session->cmd_pool)
-		err = -ENOMEM;
-
-	if (!err) {
-		spin_lock_irqsave(&target->lock, flags);
-		list_add(&session->slist, &target->session_list);
-		spin_unlock_irqrestore(&target->lock, flags);
-	}
-
-	session->done(session->arg, err ? NULL : session);
-	if (err)
-		kfree(session);
-}
-
-int tgt_session_create(struct tgt_target *target, tgt_session_done_t *done,
-		       void *arg)
-{
-	struct tgt_session *session;
-
-	BUG_ON(!done);
-	session = kzalloc(sizeof(*session), GFP_ATOMIC);
-	if (!session)
-		return -ENOMEM;
-	session->target = target;
-	INIT_LIST_HEAD(&session->slist);
-
-	tgt_session_op_init(session, tgt_session_async_create, done, arg);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_session_create);
-
-static void tgt_session_async_destroy(void *data)
-{
-	struct tgt_session *session = (struct tgt_session *) data;
-	struct tgt_target *target = session->target;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_del(&session->slist);
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	if (session->done)
-		session->done(session->arg, NULL);
-
-	mempool_destroy(session->cmd_pool);
-	kfree(session);
-}
-
-int tgt_session_destroy(struct tgt_session *session,
-			tgt_session_done_t *done, void *arg)
-{
-	tgt_session_op_init(session, tgt_session_async_destroy,
-			    done, arg);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_session_destroy);
-
-static void tgt_unmap_user_pages(struct tgt_cmd *cmd)
-{
-	struct page *page;
-	int i;
-
-	for (i = 0; i < cmd->sg_count; i++) {
-		page = cmd->pages[i];
-		if(!page)
-			break;
-		if (test_bit(TGT_CMD_RW, &cmd->flags))
-			set_page_dirty_lock(page);
-		page_cache_release(page);
-	}
-	kfree(cmd->pages);
-}
-
-static struct tgt_cmd *__tgt_cmd_hlist_find(struct tgt_target *target,
-					    uint64_t tag)
-{
-	struct tgt_cmd *cmd;
-	struct list_head *head = &target->cmd_hlist[cmd_hashfn(tag)];
-
-	list_for_each_entry(cmd, head, hash_list) {
-		if (cmd_tag(cmd) == tag)
-			return cmd;
-	}
-	return NULL;
-}
-
-static struct tgt_cmd *tgt_cmd_hlist_find(struct tgt_target *target, uint64_t tag)
-{
-	unsigned long flags;
-	struct tgt_cmd *cmd;
-
-	spin_lock_irqsave(&target->lock, flags);
-	cmd = __tgt_cmd_hlist_find(target, tag);
-	spin_unlock_irqrestore(&target->lock, flags);
-	return cmd;
-}
-
-static int tgt_cmd_hlist_add(struct tgt_cmd *cmd)
-{
-	struct tgt_target *target = cmd->session->target;
-	struct list_head *head;
-	unsigned long flags;
-	uint64_t tag = cmd_tag(cmd);
-	int err = 0;
-
-	spin_lock_irqsave(&target->lock, flags);
-
-	if (__tgt_cmd_hlist_find(target, tag)) {
-		err = -EINVAL;
-		eprintk("%p is already on the hash list.\n", cmd);
-	} else {
-		head = &target->cmd_hlist[cmd_hashfn(tag)];
-		list_add_tail(&cmd->hash_list, head);
-	}
-	spin_unlock_irqrestore(&target->lock, flags);
-
-	return err;
-}
-
-static void tgt_cmd_hlist_del(struct tgt_cmd *cmd)
-{
-	struct tgt_target *target = cmd->session->target;
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-
-	cmd = __tgt_cmd_hlist_find(target, cmd_tag(cmd));
-	if (cmd)
-		list_del(&cmd->hash_list);
-	else
-		eprintk("%p is not on the hash list.\n", cmd);
-
-	spin_unlock_irqrestore(&target->lock, flags);
-}
-
-static void __tgt_cmd_destroy(void *data)
-{
-	struct tgt_cmd *cmd = data;
-
-	dprintk("cmd %p\n", cmd);
-
-	tgt_unmap_user_pages(cmd);
-	kfree(cmd->sg);
-	tgt_uspace_cmd_done_send(cmd, GFP_KERNEL);
-
-	tgt_cmd_hlist_del(cmd);
-
-	mempool_free(cmd, cmd->session->cmd_pool);
-}
-
-static void tgt_cmd_destroy(struct tgt_cmd *cmd)
-{
-	dprintk("cmd %p\n", cmd);
-
-	/*
-	 * Goose the queue incase we are blocked on a queue depth
-	 * limit or resource problem.
-	 *
-	 * This is run from a interrpt handler normally so we queue
-	 * the work
-	 */
-	INIT_WORK(&cmd->work, __tgt_cmd_destroy, cmd);
-	queue_work(cmd->session->target->twq, &cmd->work);
-}
-
-void tgt_transfer_response(void *data)
-{
-	struct tgt_cmd *cmd = data;
-	struct tgt_target *target = cmd->session->target;
-	int err;
-
-	dprintk("cmd %p\n", cmd);
-
-	cmd->done = tgt_cmd_destroy;
-	err = target->tt->transfer_response(cmd);
-	switch (err) {
-	case TGT_CMD_XMIT_FAILED:
-	case TGT_CMD_XMIT_REQUEUE:
-		/*
-		 * TODO add a real queue to avoid re-orders and starvation
-		 * for now just reschedule.
-		 */
-		INIT_WORK(&cmd->work, tgt_transfer_response, cmd);
-		queue_delayed_work(cmd->session->target->twq, &cmd->work,
-				   10 * HZ);
-		break;
-	}
-}
-EXPORT_SYMBOL_GPL(tgt_transfer_response);
-
-static inline void tgt_cmd_queue(struct tgt_target *target, struct tgt_cmd *cmd)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&target->lock, flags);
-	list_add_tail(&cmd->cqueue, &target->uspace_cmd_queue);
-	spin_unlock_irqrestore(&target->lock, flags);
-}
-
-struct tgt_cmd *
-tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
-	       uint32_t data_len, enum dma_data_direction data_dir,
-	       uint8_t *dev_buf, int dev_buf_size, int flags)
-{
-	struct tgt_cmd *cmd;
-	struct tgt_target *target = session->target;
-	int err;
-
-	cmd = mempool_alloc(session->cmd_pool, GFP_ATOMIC);
-	if (!cmd) {
-		eprintk("Could not allocate tgt_cmd for %p\n", session);
-		return NULL;
-	}
-	memset(cmd, 0, sizeof(*cmd));
-	target->proto->cmd_create(cmd, cb, data_len, data_dir,
-				  dev_buf, dev_buf_size, flags);
-
-	cmd->session = session;
-	cmd->private = tgt_priv;
-	cmd->done = tgt_cmd_destroy;
-	atomic_set(&cmd->state, TGT_CMD_CREATED);
-
-	dprintk("%p %p\n", session, cmd);
-
-	err = tgt_cmd_hlist_add(cmd);
-	if (err) {
-		mempool_free(cmd, cmd->session->cmd_pool);
-		return NULL;
-	}
-
-	tgt_cmd_queue(target, cmd);
-        if (!in_interrupt() && !down_trylock(&target->uspace_sem)) {
-		tgt_cmd_uspace_queue(target, GFP_ATOMIC);
-		up(&target->uspace_sem);
-	} else
-		queue_work(target->twq, &target->send_work);
-
-	return cmd;
-}
-EXPORT_SYMBOL_GPL(tgt_cmd_create);
-
-static void tgt_write_data_transfer_done(struct tgt_cmd *cmd)
-{
-	/*
-	 * TODO check for errors and add state checking. we may have
-	 * to internally queue for the target driver
-	 */
-	tgt_transfer_response(cmd);
-}
-
-/*
- * we should jsut pass the cmd pointer between userspace and the kernel
- * as a handle like open-iscsi
- */
-static struct tgt_cmd *tgt_cmd_find(int tid, uint64_t tag)
-{
-	struct tgt_target *target;
-	struct tgt_cmd *cmd;
-
-	dprintk("%d %llu\n", tid, (unsigned long long) tag);
-
-	target = target_find(tid);
-	if (!target) {
-		eprintk("Could not find target %d\n", tid);
-		return NULL;
-	}
-
-	cmd = tgt_cmd_hlist_find(target, tag);
-	if (!cmd)
-		eprintk("Could not find rq for cid %llu\n", (unsigned long long) tag);
-	return cmd;
-}
-
-#define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
-
-static int tgt_map_user_pages(int rw, struct tgt_cmd *cmd)
-{
-	int i, err = -EIO, cnt;
-	struct page *page, **pages;
-	uint64_t poffset = cmd->offset & ~PAGE_MASK;
-	uint32_t size, rest = cmd->bufflen;
-
-	cnt = pgcnt(cmd->bufflen, cmd->offset);
-	pages = kzalloc(cnt * sizeof(struct page *), GFP_KERNEL);
-	if (!pages)
-		return -ENOMEM;
-	cmd->pages = pages;
-
-	cmd->sg = kmalloc(cnt * sizeof(struct scatterlist), GFP_KERNEL);
-	if (!cmd->sg)
-		goto release_pages;
-	cmd->sg_count = cnt;
-
-	dprintk("cmd %p addr %lx cnt %d\n", cmd, cmd->uaddr, cnt);
-
-	down_read(&tgtd_tsk->mm->mmap_sem);
-	err = get_user_pages(tgtd_tsk, tgtd_tsk->mm, cmd->uaddr, cnt,
-			     rw == WRITE, 0, pages, NULL);
-	up_read(&tgtd_tsk->mm->mmap_sem);
-
-	if (err < cnt) {
-		err = -EIO;
-		goto free_sg;
-	}
-
-	/*
-	 * We have a request_queue and we have a the SGIO scatterlist stuff in
-	 * scsi-misc so we can use those functions to make us a request with
-	 * a proper scatterlist by using block layer funciotns ?????
-	 *
-	 * do a:
-	 * scsi_req_map_sg(cmd->rq, tmp_sg, cnt, orig_size, GFP_KERNEL);
-	 * blk_rq_map_sg(cmd->device->q or cmd->target->q, cmd->rq, cmd->sg);
-	 */
-	for (i = 0; i < cnt; i++) {
-		size = min_t(uint32_t, rest, PAGE_SIZE - poffset);
-
-		cmd->sg[i].page = pages[i];
-		cmd->sg[i].offset = poffset;
-		cmd->sg[i].length = size;
-
-		poffset = 0;
-		rest -= size;
-	}
-
-	return 0;
-
-free_sg:
-	kfree(cmd->sg);
-release_pages:
-	for (i = 0; i < cnt; i++) {
-		page = pages[i];
-		if(!page)
-			break;
-		if (!err && rw == WRITE)
-			set_page_dirty_lock(page);
-		page_cache_release(page);
-	}
-	kfree(pages);
-
-	return err;
-}
-
-int uspace_cmd_done(int tid, uint64_t cid,
-		    int result, uint32_t len, uint64_t offset,
-		    unsigned long uaddr, uint8_t rw, uint8_t try_map)
-{
-	struct tgt_target *target;
-	struct tgt_cmd *cmd;
-
-	cmd = tgt_cmd_find(tid, cid);
-	if (!cmd) {
-		eprintk("Could not find command %llu\n",
-			(unsigned long long) cid);
-		return -EINVAL;
-	}
-
-	dprintk("cmd %p tag %llu result %d len %d bufflen %u\n", cmd,
-		(unsigned long long) cmd_tag(cmd), result, len, cmd->bufflen);
-
-	cmd->uaddr = uaddr;
-	cmd->result = result;
-	cmd->offset = offset;
-	if (len)
-		cmd->bufflen = len;
-	if (rw == WRITE)
-		__set_bit(TGT_CMD_RW, &cmd->flags);
-	if (try_map)
-		__set_bit(TGT_CMD_MAPPED, &cmd->flags);
-
-	target = cmd->session->target;
-/* 	target->proto->uspace_cmd_complete(cmd); */
-
-	if (cmd->bufflen) {
-		if (tgt_map_user_pages(rw, cmd))
-			return -EIO;
-		if (cmd->data_dir == DMA_TO_DEVICE) {
-			cmd->done = tgt_write_data_transfer_done;
-			/*
-			 * TODO handle errors and possibly requeue for the
-			 * target driver
-			 */
-			target->tt->transfer_write_data(cmd);
-			return 0;
-		}
-	}
-
-	tgt_transfer_response(cmd);
-	return 0;
-}
-
-static void __exit tgt_exit(void)
-{
-	tgt_nl_exit();
-	tgt_sysfs_exit();
-}
-
-static int __init tgt_init(void)
-{
-	int err = -ENOMEM;
-
-	spin_lock_init(&all_targets_lock);
-	spin_lock_init(&target_tmpl_lock);
-
-	tgt_protocol_init();
-
-	err = tgt_sysfs_init();
-	if (err)
-		return err;
-
-	err = tgt_nl_init();
-	if (err)
-		goto out;
-
-	return 0;
-out:
-	tgt_sysfs_exit();
-	return err;
-}
-
-module_init(tgt_init);
-module_exit(tgt_exit);

Deleted: branches/use-scsi-ml/kernel/tgt.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,116 +0,0 @@
-/*
- * Core Target Framework definitions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __TGT_H
-#define __TGT_H
-
-#include <linux/mempool.h>
-#include <linux/bio.h>
-#include <linux/dma-mapping.h>
-
-#include <tgt_types.h>
-
-struct tgt_device;
-struct tgt_protocol;
-struct tgt_session;
-
-/*
- * this should be in a tgt_target_template
- */
-#define	TGT_MAX_CMD	64
-
-typedef void (tgt_session_done_t) (void *, struct tgt_session *);
-
-struct tgt_session {
-	struct tgt_target *target;
-	struct list_head slist;
-
-	mempool_t *cmd_pool;
-
-	struct work_struct work;
-	tgt_session_done_t *done;
-	void *arg;
-};
-
-enum {
-	TGT_CMD_CREATED,
-	TGT_CMD_BUF_ALLOCATED,
-	TGT_CMD_STARTED,
-	TGT_CMD_READY,
-	TGT_CMD_RECV,
-	TGT_CMD_XMIT,
-	TGT_CMD_DONE,
-};
-
-enum {
-	TGT_CMD_MAPPED,
-	TGT_CMD_RW,		/* not set == read, set == write */
-};
-
-struct tgt_cmd {
-	struct tgt_session *session;
-	struct tgt_protocol *proto;
-
-	struct list_head hash_list;
-	struct list_head cqueue;
-
-	atomic_t state;
-	unsigned long flags;
-
-	struct work_struct work;
-	void (*done) (struct tgt_cmd *);
-
-	enum dma_data_direction data_dir;
-	int sg_count;
-	struct scatterlist *sg;
-	struct page **pages;
-	uint32_t bufflen;
-	uint64_t offset;
-	int result;
-
-	unsigned long uaddr;
-
-	/*
-	 * target driver private
-	 */
-	void *private;
-
-	/*
-	 * is the alignment still needed?  See scsi_host.h
-	 */
-	unsigned long proto_priv[0] __attribute__ ((aligned (sizeof(unsigned long))));
-};
-
-extern int tgt_session_create(struct tgt_target *target,
-			      tgt_session_done_t *done, void *arg);
-extern int tgt_session_destroy(struct tgt_session *session,
-			       tgt_session_done_t *done, void *arg);
-extern int tgt_msg_send(struct tgt_target *target, void *data, int dlen,
-			gfp_t flags);
-extern int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask);
-extern struct tgt_cmd *
-tgt_cmd_create(struct tgt_session *session, void *tgt_priv, uint8_t *cb,
-	       uint32_t data_len, enum dma_data_direction data_dir,
-	       uint8_t *dev_buf, int dev_buf_size, int flags);
-extern void tgt_transfer_response(void *cmd);
-extern int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags);
-
-#define DEBUG_TGT 1
-
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#ifdef DEBUG_TGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
-#endif
-
-#endif

Deleted: branches/use-scsi-ml/kernel/tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/tgt_nl.c	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_nl.c	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,222 +0,0 @@
-/*
- * Target Netlink Framework code
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/netlink.h>
-#include <net/tcp.h>
-
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_if.h>
-#include <tgt_protocol.h>
-#include "tgt_priv.h"
-
-static int tgtd_pid;
-static struct sock *nls;
-
-int tgt_uspace_cmd_send(struct tgt_cmd *cmd, gfp_t gfp_mask)
-{
-	struct tgt_protocol *proto = cmd->session->target->proto;
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	char *pdu;
-	int len, proto_pdu_size = proto->uspace_pdu_size;
-
-	len = NLMSG_SPACE(sizeof(*ev) + proto_pdu_size);
-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-	if (!skb)
-		return -ENOMEM;
-
-	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), proto_pdu_size);
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
-	ev = NLMSG_DATA(nlh);
-	memset(ev, 0, sizeof(*ev));
-
-	pdu = (char *) ev->data;
-	ev->k.cmd_req.tid = cmd->session->target->tid;
-	ev->k.cmd_req.cid = cmd_tag(cmd);
-	ev->k.cmd_req.typeid = cmd->session->target->typeid;
-	ev->k.cmd_req.data_len = cmd->bufflen;
-
-	proto->uspace_pdu_build(cmd, pdu);
-
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
-}
-EXPORT_SYMBOL_GPL(tgt_uspace_cmd_send);
-
-static int send_event_res(uint16_t type, struct tgt_event *p,
-			  void *data, int dlen, gfp_t flags)
-{
-	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len;
-
-	len = NLMSG_SPACE(sizeof(*ev) + dlen);
-	skb = alloc_skb(len, flags);
-	if (!skb)
-		return -ENOMEM;
-
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, type, len - sizeof(*nlh), 0);
-
-	ev = NLMSG_DATA(nlh);
-	memcpy(ev, p, sizeof(*ev));
-	if (dlen)
-		memcpy(ev->data, data, dlen);
-
-	return netlink_unicast(nls, skb, tgtd_pid, 0);
-}
-
-int tgt_msg_send(struct tgt_target *target, void *data, int dlen, gfp_t flags)
-{
-	struct tgt_event ev;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.tgt_passthru.tid = target->tid;
-	ev.k.tgt_passthru.typeid = target->typeid;
-	ev.k.tgt_passthru.len = dlen;
-
-	return send_event_res(TGT_KEVENT_TARGET_PASSTHRU,
-			      &ev, data, dlen, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_msg_send);
-
-int tgt_uspace_cmd_done_send(struct tgt_cmd *cmd, gfp_t flags)
-{
-	struct tgt_event ev;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.tid = cmd->session->target->tid;
-	ev.k.cmd_done.typeid = cmd->session->target->typeid;
-	ev.k.cmd_done.uaddr = cmd->uaddr;
-	ev.k.cmd_done.len = cmd->bufflen;
-	if (test_bit(TGT_CMD_MAPPED, &cmd->flags))
-		ev.k.cmd_done.mmapped = 1;
-
-	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_uspace_cmd_done_send);
-
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-{
-	int err = 0;
-	struct tgt_event *ev = NLMSG_DATA(nlh);
-	struct tgt_target *target;
-
-	dprintk("%d %d %d\n", nlh->nlmsg_type,
-		nlh->nlmsg_pid, current->pid);
-
-	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_START:
-		tgtd_pid  = NETLINK_CREDS(skb)->pid;
-		tgtd_tsk = current;
-		eprintk("start target drivers\n");
-		break;
-	case TGT_UEVENT_TARGET_CREATE:
-		target = tgt_target_create(ev->u.c_target.type,
-					   ev->u.c_target.nr_cmds);
-		if (target)
-			err = target->tid;
-		else
-			err = -EINVAL;
-		break;
-	case TGT_UEVENT_TARGET_DESTROY:
-		target = target_find(ev->u.d_target.tid);
-		if (target)
-			err = tgt_target_destroy(target);
-		else
-			err = -EINVAL;
-		break;
-	case TGT_UEVENT_TARGET_PASSTHRU:
-		target = target_find(ev->u.tgt_passthru.tid);
-		if (!target || !target->tt->msg_recv) {
-			dprintk("Could not find target %d for passthru\n",
-				ev->u.tgt_passthru.tid);
-			err = -EINVAL;
-			break;
-		}
-
-		err = target->tt->msg_recv(target, ev->u.tgt_passthru.len,
-					   ev->data);
-		break;
-	case TGT_UEVENT_CMD_RES:
-		err = uspace_cmd_done(ev->u.cmd_res.tid,
-				      ev->u.cmd_res.cid,
-				      ev->u.cmd_res.result, ev->u.cmd_res.len,
-				      ev->u.cmd_res.offset,
-				      ev->u.cmd_res.uaddr, ev->u.cmd_res.rw,
-				      ev->u.cmd_res.try_map);
-		break;
-	default:
-		eprintk("unknown type %d\n", nlh->nlmsg_type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int event_recv_skb(struct sk_buff *skb)
-{
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		err = event_recv_msg(skb, nlh);
-
-		dprintk("%d %d\n", nlh->nlmsg_type, err);
-		/*
-		 * TODO for passthru commands the lower level should
-		 * probably handle the result or we should modify this
-		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES &&
-		    nlh->nlmsg_type != TGT_UEVENT_TARGET_PASSTHRU) {
-			struct tgt_event ev;
-
-			memset(&ev, 0, sizeof(ev));
-			ev.k.event_res.err = err;
-			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
-				       GFP_KERNEL | __GFP_NOFAIL);
-		}
-		skb_pull(skb, rlen);
-	}
-	return 0;
-}
-
-static void event_recv(struct sock *sk, int length)
-{
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
-}
-
-void __exit tgt_nl_exit(void)
-{
-	sock_release(nls->sk_socket);
-}
-
-int __init tgt_nl_init(void)
-{
-	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv, THIS_MODULE);
-	if (!nls)
-		return -ENOMEM;
-
-	return 0;
-}

Deleted: branches/use-scsi-ml/kernel/tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt_priv.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_priv.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,34 +0,0 @@
-#ifndef _TGT_PRIV_H
-#define _TGT_PRIV_H
-
-struct tgt_target;
-
-/* tgt core */
-extern struct tgt_target *target_find(int tid);
-extern int uspace_cmd_done(int tid, uint64_t cid,
-			   int result, uint32_t len, uint64_t offset,
-			   unsigned long addr,
-			   uint8_t rw, uint8_t try_map);
-extern struct task_struct *tgtd_tsk;
-
-/* netlink */
-extern void tgt_nl_exit(void);
-extern int tgt_nl_init(void);
-
-/* Sysfs */
-struct target_type_internal {
-	int typeid;
-	struct list_head list;
-	struct tgt_target_template *tt;
-	struct tgt_protocol *proto;
-	struct class_device cdev;
-};
-
-extern int tgt_sysfs_init(void);
-extern void tgt_sysfs_exit(void);
-extern int tgt_sysfs_register_type(struct target_type_internal *ti);
-extern void tgt_sysfs_unregister_type(struct target_type_internal *ti);
-extern int tgt_sysfs_register_target(struct tgt_target *target);
-extern void tgt_sysfs_unregister_target(struct tgt_target *target);
-
-#endif

Deleted: branches/use-scsi-ml/kernel/tgt_protocol.c
===================================================================
--- branches/use-scsi-ml/kernel/tgt_protocol.c	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_protocol.c	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,83 +0,0 @@
-/*
- * Target protocol registration functions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#include <linux/list.h>
-#include <linux/module.h>
-#include <tgt_protocol.h>
-
-static spinlock_t protocol_lock;
-static LIST_HEAD(protocol_list);
-
-struct tgt_proto_internal {
-	struct list_head list;
-	struct tgt_protocol *proto;
-};
-
-struct tgt_protocol *tgt_protocol_get(const char *name)
-{
-	unsigned long flags;
-	struct tgt_proto_internal *tp;
-
-	spin_lock_irqsave(&protocol_lock, flags);
-	list_for_each_entry(tp, &protocol_list, list)
-		if (!strcmp(name, tp->proto->name)) {
-			if (!try_module_get(tp->proto->module))
-				tp = NULL;
-			spin_unlock_irqrestore(&protocol_lock, flags);
-			return tp ? tp->proto : NULL;
-		}
-
-	spin_unlock_irqrestore(&protocol_lock, flags);
-
-	return NULL;
-}
-
-void tgt_protocol_put(struct tgt_protocol *proto)
-{
-	module_put(proto->module);
-}
-
-int tgt_protocol_register(struct tgt_protocol *proto)
-{
-	unsigned long flags;
-	struct tgt_proto_internal *tp;
-
-	tp = kzalloc(sizeof(*tp), GFP_KERNEL);
-	if (!tp)
-		return -ENOMEM;
-	INIT_LIST_HEAD(&tp->list);
-	tp->proto = proto;
-
-	spin_lock_irqsave(&protocol_lock, flags);
-	list_add_tail(&tp->list, &protocol_list);
-	spin_unlock_irqrestore(&protocol_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(tgt_protocol_register);
-
-void tgt_protocol_unregister(struct tgt_protocol *proto)
-{
-	unsigned long flags;
-	struct tgt_proto_internal *tp;
-
-	spin_lock_irqsave(&protocol_lock, flags);
-	list_for_each_entry(tp, &protocol_list, list)
-		if (tp->proto == proto) {
-			list_del(&tp->list);
-			kfree(tp);
-			break;
-		}
-
-	spin_unlock_irqrestore(&protocol_lock, flags);
-}
-EXPORT_SYMBOL_GPL(tgt_protocol_unregister);
-
-void __init tgt_protocol_init(void)
-{
-	spin_lock_init(&protocol_lock);
-}

Deleted: branches/use-scsi-ml/kernel/tgt_protocol.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt_protocol.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_protocol.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,56 +0,0 @@
-/*
- * Target Framework Protocol definitions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#ifndef __TGT_PROTOCOL_H
-#define __TGT_PROTOCOL_H
-
-#include <linux/slab.h>
-#include <linux/dma-mapping.h>
-
-struct module;
-struct tgt_cmd;
-struct tgt_session;
-
-/*
- * The target driver will interact with tgt core through the protocol
- * handler. The protocol handler can then use the default tgt_core functions
- * or build wrappers around them.
- */
-struct tgt_protocol {
-	const char *name;
-	struct module *module;
-
-	kmem_cache_t *cmd_cache;
-	unsigned uspace_pdu_size;
-
- 	/*
-	 * Create a command and allocate a buffer of size data_len for
-	 * for transfer. The buffer will be allocated with GFP_KERNEL
-	 * and preprocesed by tgt/scsi_proto so the next time
-	 * the target driver is notified about the cmd is when
-	 * the transfer* is called.
-	 */
-	void (* cmd_create)(struct tgt_cmd *cmd, uint8_t *cb,
-			    uint32_t data_len, enum dma_data_direction data_dir,
-			    uint8_t *dev_id_buff, int id_buff_size,
-			    int flags);
-
-	/*
-	 * Build userspace packet
-	 */
-	void (* uspace_pdu_build)(struct tgt_cmd *cmd, void *data);
-
-	void (* uspace_cmd_complete)(struct tgt_cmd *cmd);
-};
-
-extern void tgt_protocol_init(void);
-extern int tgt_protocol_register(struct tgt_protocol *proto);
-extern void tgt_protocol_unregister(struct tgt_protocol *proto);
-extern struct tgt_protocol *tgt_protocol_get(const char *name);
-extern void tgt_protocol_put(struct tgt_protocol *proto);
-
-#endif

Deleted: branches/use-scsi-ml/kernel/tgt_scsi.c
===================================================================
--- branches/use-scsi-ml/kernel/tgt_scsi.c	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_scsi.c	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,90 +0,0 @@
-/*
- * SCSI target protocol
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#include <linux/module.h>
-#include <scsi/scsi_cmnd.h>
-
-#include <tgt.h>
-#include <tgt_protocol.h>
-#include <tgt_target.h>
-#include <tgt_scsi_if.h>
-
-static kmem_cache_t *tgt_scsi_cmd_cache;
-
-static inline struct tgt_scsi_cmd *tgt_cmd_to_scsi(struct tgt_cmd *cmd)
-{
-	return (struct tgt_scsi_cmd *) cmd->proto_priv;
-}
-
-static void
-tgt_scsi_cmd_create(struct tgt_cmd *cmd, uint8_t *scb,
-		    uint32_t data_len, enum dma_data_direction data_dir,
-		    uint8_t *lun, int lun_size, int tags)
-{
-	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	memcpy(scmd->scb, scb, sizeof(scmd->scb));
-	memcpy(scmd->lun, lun, sizeof(scmd->lun));
-	scmd->tags = tags;
-
-	cmd->data_dir = data_dir;
-	/*
-	 * set bufflen based on data_len for now, but let device specific
-	 * handler overide just in case
-	 */
-	cmd->bufflen = data_len;
-}
-
-static void tgt_scsi_pdu_build(struct tgt_cmd *cmd, void *data)
-{
-	struct tgt_scsi_cmd *scmd = tgt_cmd_to_scsi(cmd);
-
-	memcpy(data, scmd, sizeof(struct tgt_scsi_cmd));
-}
-
-static struct tgt_protocol tgt_scsi_proto = {
-	.name = "scsi",
-	.module = THIS_MODULE,
-	.cmd_create = tgt_scsi_cmd_create,
-	.uspace_pdu_build = tgt_scsi_pdu_build,
-	.uspace_pdu_size = sizeof(struct tgt_scsi_cmd),
-};
-
-static int __init tgt_scsi_init(void)
-{
-	int err;
-	size_t size = sizeof(struct tgt_cmd) + sizeof(struct tgt_scsi_cmd);
-
-	tgt_scsi_cmd_cache = kmem_cache_create("tgt_scsi_cmd",
-					       size, 0,
-					       SLAB_HWCACHE_ALIGN | SLAB_NO_REAP,
-					       NULL, NULL);
-	if (!tgt_scsi_cmd_cache)
-		return -ENOMEM;
-	tgt_scsi_proto.cmd_cache = tgt_scsi_cmd_cache;
-
-	err = tgt_protocol_register(&tgt_scsi_proto);
-	if (err)
-		goto cache_destroy;
-
-	return 0;
-cache_destroy:
-	kmem_cache_destroy(tgt_scsi_cmd_cache);
-
-	return err;
-}
-
-static void __exit tgt_scsi_exit(void)
-{
-	kmem_cache_destroy(tgt_scsi_cmd_cache);
-	tgt_protocol_unregister(&tgt_scsi_proto);
-}
-
-module_init(tgt_scsi_init);
-module_exit(tgt_scsi_exit);
-MODULE_LICENSE("GPL");

Deleted: branches/use-scsi-ml/kernel/tgt_scsi.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt_scsi.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_scsi.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,16 +0,0 @@
-/*
- * SCSI target helpers
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __TGT_SCSI_H
-#define __TGT_SCSI_H
-
-#include <tgt.h>
-
-#define	tgt_scsi_sense_length(cmd)	(cmd)->bufflen
-
-#endif

Deleted: branches/use-scsi-ml/kernel/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/kernel/tgt_sysfs.c	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_sysfs.c	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,225 +0,0 @@
-/*
- * Target framework core sysfs files
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#include <tgt_types.h>
-#include <tgt_target.h>
-
-#include "tgt_priv.h"
-
-static struct class_device_attribute *class_attr_overridden(
-				struct class_device_attribute **attrs,
-				struct class_device_attribute *attr)
-{
-	int i;
-
-	if (!attrs)
-		return NULL;
-
-	for (i = 0; attrs[i]; i++)
-		if (!strcmp(attrs[i]->attr.name, attr->attr.name))
-			return attrs[i];
-	return NULL;
-}
-
-static int class_attr_add(struct class_device *classdev,
-			  struct class_device_attribute **attrs,
-			  struct class_device_attribute *attr)
-{
-	struct class_device_attribute *base_attr;
-
-	/*
-	 * Spare the caller from having to copy things it's not interested in.
-	*/
-	base_attr = class_attr_overridden(attrs, attr);
-	if (base_attr) {
-		/* extend permissions */
-		attr->attr.mode |= base_attr->attr.mode;
-
-		/* override null show/store with default */
-		if (!attr->show)
-			attr->show = base_attr->show;
-		if (!attr->store)
-			attr->store = base_attr->store;
-	}
-
-	return class_device_create_file(classdev, attr);
-}
-
-#define cdev_to_tgt_type(cdev) \
-	container_of(cdev, struct target_type_internal, cdev)
-
-#define tgt_target_template_show_fn(field, format_string)		\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct target_type_internal *ti = cdev_to_tgt_type(cdev);	\
-	return snprintf (buf, 20, format_string, ti->tt->field);	\
-}
-
-#define tgt_target_template_rd_attr(field, format_string)		\
-	tgt_target_template_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-tgt_target_template_rd_attr(name, "%s\n");
-tgt_target_template_rd_attr(protocol, "%s\n");
-tgt_target_template_rd_attr(subprotocol, "%s\n");
-
-static struct class_device_attribute *tgt_type_attrs[] = {
-	&class_device_attr_name,
-	&class_device_attr_protocol,
-	&class_device_attr_subprotocol,
-	NULL,
-};
-
-static void tgt_type_class_release(struct class_device *cdev)
-{
-	struct target_type_internal *ti = cdev_to_tgt_type(cdev);
-	kfree(ti);
-}
-
-static struct class tgt_type_class = {
-	.name = "tgt_type",
-	.release = tgt_type_class_release,
-};
-
-int tgt_sysfs_register_type(struct target_type_internal *ti)
-{
-	struct class_device *cdev = &ti->cdev;
-	int i, err;
-
-	cdev->class = &tgt_type_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "driver%d", ti->typeid);
-
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	for (i = 0; tgt_type_attrs[i]; i++) {
-		err = class_device_create_file(&ti->cdev,
-					       tgt_type_attrs[i]);
-		if (err)
-			goto cleanup;
-	}
-
-	return 0;
-
-cleanup:
-	class_device_unregister(cdev);
-
-	return err;
-}
-
-void tgt_sysfs_unregister_type(struct target_type_internal *ti)
-{
-	class_device_unregister(&ti->cdev);
-}
-
-/*
- * Target files
- */
-#define tgt_target_show_fn(field, format_string)			\
-static ssize_t								\
-show_##field (struct class_device *cdev, char *buf)			\
-{									\
-	struct tgt_target *target = cdev_to_tgt_target(cdev);		\
-	return snprintf (buf, 20, format_string, target->field);	\
-}
-
-#define tgt_target_rd_attr(field, format_string)		\
-	tgt_target_show_fn(field, format_string)		\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
-
-tgt_target_rd_attr(queued_cmds, "%u\n");
-tgt_target_rd_attr(typeid, "%d\n");
-
-static struct class_device_attribute *tgt_target_attrs[] = {
-	&class_device_attr_queued_cmds,
-	&class_device_attr_typeid,
-	NULL
-};
-
-static void tgt_target_class_release(struct class_device *cdev)
-{
-	struct tgt_target *target = cdev_to_tgt_target(cdev);
-	kfree(target->tt_data);
-	kfree(target);
-}
-
-static struct class tgt_target_class = {
-	.name = "tgt_target",
-	.release = tgt_target_class_release,
-};
-
-int tgt_sysfs_register_target(struct tgt_target *target)
-{
-	struct class_device *cdev = &target->cdev;
-	int err, i;
-
-	cdev->class = &tgt_target_class;
-	snprintf(cdev->class_id, BUS_ID_SIZE, "target%d", target->tid);
-
-	err = class_device_register(cdev);
-	if (err)
-		return err;
-
-	if (target->tt->target_attrs) {
-		for (i = 0; target->tt->target_attrs[i]; i++) {
-			err = class_attr_add(&target->cdev,
-					     tgt_target_attrs,
-					     target->tt->target_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	for (i = 0; tgt_target_attrs[i]; i++) {
-		if (!class_attr_overridden(target->tt->target_attrs,
-					   tgt_target_attrs[i])) {
-			err = class_device_create_file(&target->cdev,
-						       tgt_target_attrs[i]);
-			if (err)
-				goto cleanup;
-		}
-	}
-
-	return 0;
-
-cleanup:
-	class_device_unregister(cdev);
-	return err;
-}
-
-void tgt_sysfs_unregister_target(struct tgt_target *target)
-{
-	class_device_unregister(&target->cdev);
-}
-
-int tgt_sysfs_init(void)
-{
-	int err;
-
-	err = class_register(&tgt_type_class);
-	if (err)
-		return err;
-
-	err = class_register(&tgt_target_class);
-	if (err)
-		goto unregister_type;
-
-	return 0;
-
-unregister_type:
-	class_unregister(&tgt_type_class);
-
-	return err;
-}
-
-void tgt_sysfs_exit(void)
-{
-	class_unregister(&tgt_type_class);
-	class_unregister(&tgt_target_class);
-}

Deleted: branches/use-scsi-ml/kernel/tgt_target.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt_target.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_target.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,137 +0,0 @@
-/*
- * Target Framework Target definitions
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-#ifndef __TGT_TARGET_H
-#define __TGT_TARGET_H
-
-#include <linux/device.h>
-#include <linux/list.h>
-
-struct tgt_protocol;
-struct tgt_target;
-struct tgt_cmd;
-
-enum {
-	TGT_CMD_XMIT_OK,
-	TGT_CMD_XMIT_FAILED,
-	TGT_CMD_XMIT_REQUEUE,
-};
-
-#define TGT_DEFAULT_MAX_SECTORS 1024
-#define TGT_MAX_PHYS_SEGMENTS 255
-/*
- * this should be a template and device limit probably
- */
-#define TGT_QUEUE_DEPTH 64
-
-struct tgt_target_template {
-	const char *name;
-	struct module *module;
-	unsigned priv_data_size;
-
-	unsigned short max_hw_segments;
-	unsigned int max_segment_size;
-	unsigned long seg_boundary_mask;
-	unsigned short max_sectors;
-	unsigned use_clustering;
-
-	/*
-	 * Target creation/destroy callbacks useful when userspace
-	 * initiates these operations
-	 */
-	int (* target_create) (struct tgt_target *);
-	void (* target_destroy) (struct tgt_target *);
-	/*
-	 * Called when userspace sends the target a driver specific
-	 * message. To send a response the target driver should call
-	 * tgt_msg_send.
-	 */
-	int (* msg_recv) (struct tgt_target *, uint32_t, void *);
-	/*
-	 * Transfer command response and/or data. If the target driver
-	 * cannot queue the request and would like it requeued then it
-	 * should return an appropriate TGT_CMD_XMIT_*. When the
-	 * the transfer is complete and the target driver is finished with
-	 * the command the cmd->done() callback must be called. After the
-	 * the cmd->done callback has been called tgt_core owns the cmd and
-	 * may free it.
-	 *
-	 * TODO rename this
-	 */
-	int (* transfer_response) (struct tgt_cmd *);
-	/*
-	 * Transfer write data to the sg buffer.
-	 *
-	 * TODO rename
-	 */
-	int (* transfer_write_data) (struct tgt_cmd *);
-
-	void (* task_mgmt_done) (uint64_t, int);
-
-	/*
-	 * name of protocol to use
-	 */
-	const char *protocol;
-
-	/*
-	 * name of sub-protocol to use
-	 */
-	const char *subprotocol;
-
-	/*
-	 * Pointer to the sysfs class properties for this host, NULL terminated.
-	 */
-	struct class_device_attribute **target_attrs;
-};
-
-#define TGT_CMD_HASH_ORDER		4
-#define	cmd_tag(p)	((uint64_t)(unsigned long) p)
-#define	cmd_hashfn(tag)	hash_long((tag), TGT_CMD_HASH_ORDER)
-
-enum {
-	TGT_CREATED,
-	TGT_DESTROYED,
-};
-
-struct tgt_target {
-	int typeid;
-	int tid;
-	struct tgt_target_template *tt;
-	void *tt_data;
-	struct tgt_protocol *proto;
-
-	struct class_device cdev;
-
-	int queued_cmds;
-	int state;
-
-	/* Protects session_list, cmd_hlist, and state */
-	spinlock_t lock;
-
-	/* Serializes commands going to user space */
-	struct semaphore uspace_sem;
-	struct list_head tlist;
-
-	struct list_head session_list;
-	struct list_head cmd_hlist[1 << TGT_CMD_HASH_ORDER];
-
-	struct list_head uspace_cmd_queue;
-	struct work_struct send_work;
-
-	struct workqueue_struct *twq;
-};
-
-#define cdev_to_tgt_target(cdev) \
-	container_of(cdev, struct tgt_target, cdev)
-
-extern struct tgt_target *tgt_target_create(char *target_type, int nr_cmds);
-extern int tgt_target_destroy(struct tgt_target *target);
-
-extern int tgt_target_template_register(struct tgt_target_template *tt);
-extern void tgt_target_template_unregister(struct tgt_target_template *tt);
-
-#endif

Deleted: branches/use-scsi-ml/kernel/tgt_types.h
===================================================================
--- branches/use-scsi-ml/kernel/tgt_types.h	2006-01-26 05:29:12 UTC (rev 230)
+++ branches/use-scsi-ml/kernel/tgt_types.h	2006-01-27 22:01:10 UTC (rev 231)
@@ -1,18 +0,0 @@
-#ifndef __TGT_TYPES_H
-#define __TGT_TYPES_H
-
-#include <linux/types.h>
-
-/* Is there a smart way? */
-
-#if defined(CONFIG_ALPAH) || defined(CONFIG_IA64) || defined(CONFIG_PPC64) || (defined(CONFIG_S390) && defined(__x390x__)) || defined(CONFIG_SPARC64)
-#  define __PRI64_PREFIX	"l"
-# else
-#  define __PRI64_PREFIX	"ll"
-# endif
-
-# define PRId64		__PRI64_PREFIX "d"
-# define PRIu64		__PRI64_PREFIX "u"
-# define PRIx64		__PRI64_PREFIX "x"
-
-#endif



From mnc at berlios.de  Fri Jan 27 23:09:51 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:09:51 +0100
Subject: [Stgt-svn] r232 - branches/use-scsi-ml/kernel
Message-ID: <200601272209.k0RM9pQB000047@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:09:50 +0100 (Fri, 27 Jan 2006)
New Revision: 232

Added:
   branches/use-scsi-ml/kernel/scsi_tgt.h
   branches/use-scsi-ml/kernel/scsi_tgt_if.h
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
add files I was working on when Jeff suggested packet socket interface. These files use the blk and scsi-ml layer functions to map in the data, allocate scatterlists and built the scatterlists. It also hanldes partial requests when we cannot build one large request that the LLD can DMA in one shot due to HW limits like scatterlist limits. It is completely untested. I am just handing it off to Tomo. One note with the blk layer mapping code. For SG_IO, it makes sure the buffer and len are aligned to the sector size. For virtual dirvers we do not need that, but for lpfc and qla2xxx we might and in that case we would have to do a copy. So we must figure out if that is needed as the copy looks to be a performance hit (although in SG_IO testing it is not much because for the copy path we get larger requests). And we have to rip out all the interface code for jeffg's suggestion anyways.

Added: branches/use-scsi-ml/kernel/scsi_tgt.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt.h	2006-01-27 22:01:10 UTC (rev 231)
+++ branches/use-scsi-ml/kernel/scsi_tgt.h	2006-01-27 22:09:50 UTC (rev 232)
@@ -0,0 +1,10 @@
+/*
+ * SCSI target definitions
+ */
+
+struct Scsi_Host;
+struct scsi_cmnd;
+struct scsi_lun;
+
+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
+extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);

Added: branches/use-scsi-ml/kernel/scsi_tgt_if.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.h	2006-01-27 22:01:10 UTC (rev 231)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.h	2006-01-27 22:09:50 UTC (rev 232)
@@ -0,0 +1,71 @@
+/*
+ * SCSI target netlink interface
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#ifndef SCSI_TARGET_FRAMEWORK_IF_H
+#define SCSI_TARGET_FRAMEWORK_IF_H
+
+enum tgt_event_type {
+	/* user -> kernel */
+	TGT_UEVENT_START,
+	TGT_UEVENT_TARGET_SETUP,
+	TGT_UEVENT_CMD_RES,
+	TGT_UEVENT_TARGET_BIND,
+
+	/* kernel -> user */
+	TGT_KEVENT_RESPONSE,
+	TGT_KEVENT_CMD_REQ,
+	TGT_KEVENT_CMD_DONE,
+};
+
+struct tgt_event {
+	/* user-> kernel */
+	union {
+		struct {
+			int host_no;
+			int pid;
+		} target_bind;
+		struct {
+			int host_no;
+			uint32_t cid;
+			uint32_t len;
+			int result;
+			uint64_t uaddr;
+			uint64_t offset;
+			uint8_t rw;
+			uint8_t try_map;
+		} cmd_res;
+	} u;
+
+	/* kernel -> user */
+	union {
+		struct {
+			int err;
+		} event_res;
+		struct {
+			int host_no;
+			uint32_t cid;
+			uint32_t data_len;
+			uint64_t dev_id;
+		} cmd_req;
+		struct {
+			int host_no;
+			uint32_t cid;
+			int result;
+		} cmd_done;
+	} k;
+
+	/*
+	 * I think a pointer is a unsigned long but this struct
+	 * gets passed around from the kernel to userspace and
+	 * back again so to handle some ppc64 setups where userspace is
+	 * 32 bits but the kernel is 64 we do this odd thing
+	 */
+	uint64_t data[0];
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+#endif

Added: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-27 22:01:10 UTC (rev 231)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-27 22:09:50 UTC (rev 232)
@@ -0,0 +1,452 @@
+/*
+ * SCSI target lib functions
+ *
+ * Copyright 2005 Mike Christie
+ * Copyright 2005 FUJITA Tomonori
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; see the file COPYING.  If not, write to
+ * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio-list.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+#include "scsi_tgt_priv.h"
+
+static struct workqueue_struct *scsi_tgtd;
+
+static void scsi_uspace_request_fn(struct request_queue *q)
+{
+	struct request *rq;
+	struct scsi_cmnd *cmd;
+
+	/*
+	 * TODO: just send everthing in the queue to userspace in
+	 * one vector instead of multiple calls
+	 */
+	while ((rq = elv_next_request(q)) != NULL) {
+		cmd = rq->special;
+
+		/* the completion code kicks us in case we hit this */
+		if (blk_queue_start_tag(q, rq))
+			break;
+
+		spin_unlock_irq(q->queue_lock);
+		/* rm scsilun_to_int and pass raw data up */
+		if (scsi_tgt_uspace_send(cmd, scsilun_to_int(rq->end_io_data),
+					GFP_ATOMIC) < 0)
+			goto requeue;
+		spin_lock_irq(q->queue_lock);
+	}
+
+	return;
+requeue:
+	spin_lock_irq(q->queue_lock);
+	/* need to track cnts and plug */
+	blk_requeue_request(q, rq);
+	spin_lock_irq(q->queue_lock);
+}
+
+/**
+ * scsi_tgt_alloc_queue - setup queue used for message passing
+ * shost: scsi host
+ *
+ * This should be called by the LLD after host allocation.
+ * And will be released when the host is released.
+ **/
+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
+{
+	struct scsi_tgt_queuedata *queuedata;
+	struct request_queue *q;
+	int err;
+
+	/*
+	 * Do we need to send a netlink event or should uspace
+	 * just respond to the hotplug event?
+	 */
+	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
+	if (!q)
+		return -ENOMEM;
+
+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
+	if (!queuedata) {
+		err = -ENOMEM;
+		goto cleanup_queue;
+	}
+	q->queuedata = queuedata;
+
+	elevator_exit(q->elevator);
+	err = elevator_init(q, "noop");
+	if (err)
+		goto free_data;
+	/*
+	 * this is a silly hack. We should probably just queue as many
+	 * command as is recvd to userspace. uspace can then make
+	 * sure we do not overload the HBA
+	 */
+	q->nr_requests = shost->hostt->can_queue;
+	blk_queue_init_tags(q, shost->hostt->can_queue, NULL);
+	/*
+	 * We currently only support software LLDs so this does
+	 * not matter for now. Do we need this for the cards we support?
+	 * If so we should make it a host template value.
+	 */
+	blk_queue_dma_alignment(q, 0);
+	shost->uspace_req_q = q;
+
+	return 0;
+
+free_data:
+	kfree(queuedata);
+cleanup_queue:
+	blk_cleanup_queue(q);
+	return err;
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
+
+/**
+ * scsi_tgt_queue_command - queue command for userspace processing
+ * @cmd:	scsi command
+ * @scsilun:	scsi lun
+ * @noblock:	set to nonzero if the command should be queued
+ **/
+void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+			    int noblock)
+{
+	/*
+	 * For now this just calls the request_fn from this context.
+	 * For HW llds though we do not want to execute from here so
+	 * the elevator code needs something like a REQ_TGT_CMD or
+	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
+	 */
+	cmd->request->end_io_data = scsilun;
+	elv_add_request(cmd->shost->uspace_req_q, cmd->request,
+			ELEVATOR_INSERT_BACK, 1);
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
+
+static void scsi_unmap_user_pages(struct scsi_cmnd *cmd)
+{
+	struct bio *bio;
+
+	while ((bio = bio_list_pop(&cmd->xfer_done_list)))
+		bio_unmap_user(bio);
+
+	while ((bio = bio_list_pop(&cmd->xfer_list)))
+		bio_unmap_user(bio);
+}
+
+static void scsi_tgt_cmd_destroy(void *data)
+{
+	struct scsi_cmnd *cmd = data;
+
+	dprintk("cmd %p\n", cmd);
+
+	scsi_unmap_user_pages(cmd);
+	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
+	scsi_host_put_command(cmd);
+}
+
+/*
+ * This is run from a interrpt handler normally and the unmap
+ * needs process context so we must queue
+ */
+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
+{
+	dprintk("cmd %p\n", cmd);
+
+	if (cmd->result) {
+		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
+		return;
+	}
+
+	INIT_WORK(&cmd->work, scsi_tgt_cmd_destroy, cmd);
+	queue_work(scsi_tgtd, &cmd->work);
+}
+
+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
+{
+	struct Scsi_Host *shost = cmd->shost;
+	int err;
+
+	dprintk("cmd %p\n", cmd);
+
+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
+	switch (err) {
+	case SCSI_MLQUEUE_HOST_BUSY:
+	case SCSI_MLQUEUE_DEVICE_BUSY:
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
+{
+	int err;
+
+	err = __scsi_tgt_transfer_response(cmd);
+	if (!err)
+		return;
+
+	cmd->result = DID_BUS_BUSY << 16;
+	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
+		/* the eh will have to pick this up */
+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
+}
+
+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+{
+	struct request *rq = cmd->request;
+	int count;
+
+	cmd->use_sg = rq->nr_phys_segments;
+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
+	if (!cmd->request_buffer)
+		return -ENOMEM;
+
+	cmd->request_bufflen = rq->nr_sectors << 9;
+
+	dprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
+	if (likely(count <= cmd->use_sg)) {
+		cmd->use_sg = count;
+		return 0;
+	}
+
+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
+	return -EINVAL;
+}
+
+/* TODO: test this crap and replace bio_map_user with new interface maybe */
+static int scsi_map_user_pages(struct scsi_cmnd *cmd, int rw)
+{
+	struct request_queue *q = cmd->shost->uspace_req_q;
+	struct request *rq = cmd->request;
+	void *uaddr = cmd->buffer;
+	unsigned int len = cmd->bufflen;
+	struct bio *bio;
+	int err;
+
+	bio_list_init(&cmd->xfer_list);
+	bio_list_init(&cmd->xfer_done_list);
+
+	while (len > 0) {
+		bio = bio_map_user(q, NULL, (unsigned long)uaddr, len, rw, 1);
+		if (IS_ERR(bio)) {
+			err = PTR_ERR(bio);
+			goto unmap_bios;
+		}
+
+		uaddr += bio->bi_size;
+		len -= bio->bi_size;
+
+		/*
+		 * The first bio is added and merged. We could probably
+		 * try to add others but for now we keep it simple.
+		 */
+		if (!rq->bio)
+			blk_rq_bio_prep(q, rq, bio);
+		else
+			/* put list of bios to transfer in next go around */
+			bio_list_add(&cmd->xfer_list, bio);
+	}
+
+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
+	if (err)
+		goto unmap_bios;
+
+	return 0;
+
+unmap_bios:
+	bio_unmap_user(rq->bio);
+	while ((bio = bio_list_pop(&cmd->xfer_list)))
+		bio_unmap_user(bio);
+
+	return err;
+}
+
+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
+
+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
+{
+	struct bio *bio;
+	int err;
+
+	/* should we free resources here on error ? */
+	if (cmd->result) {
+send_uspace_err:
+		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
+			/* the tgt uspace eh will have to pick this up */
+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
+		return;
+	}
+
+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
+		cmd, cmd->request_bufflen, cmd->bufflen);
+
+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
+	bio_list_add(&cmd->xfer_done_list, cmd->request->bio);
+
+	cmd->bufflen -= cmd->request_bufflen;
+	cmd->buffer += cmd->request_bufflen;
+
+	if (!cmd->bufflen) {
+		scsi_tgt_transfer_response(cmd);
+		return;
+	}
+
+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
+		cmd, cmd->request_bufflen, cmd->bufflen);
+
+	bio = bio_list_pop(&cmd->xfer_list);
+	BUG_ON(!bio);
+
+	blk_rq_bio_prep(cmd->shost->uspace_req_q, cmd->request, bio);
+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
+	if (err) {
+		cmd->result = DID_ERROR << 16;
+		goto send_uspace_err;
+	}
+
+	if (scsi_tgt_transfer_data(cmd)) {
+		cmd->result = DID_NO_CONNECT << 16;
+		goto send_uspace_err;
+	}
+}
+
+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
+{
+	int err;
+
+	err = cmd->shost->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
+	switch (err) {
+		case SCSI_MLQUEUE_HOST_BUSY:
+		case SCSI_MLQUEUE_DEVICE_BUSY:
+			return -EAGAIN;
+	default:
+		return 0;
+	}
+}
+
+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
+				unsigned len)
+{
+	char __user *p = (char __user *) uaddr;
+
+	if (copy_from_user(cmd->sense_buffer, p,
+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
+		printk(KERN_ERR "Could not copy the sense buffer\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
+			 unsigned long uaddr, u8 rw, u8 try_map)
+{
+	struct Scsi_Host *shost;
+	struct scsi_cmnd *cmd;
+	struct request *rq;
+	int err = 0;
+
+	/* TODO: replace with a O(1) alg */
+	shost = scsi_host_lookup(host_no);
+	if (IS_ERR(shost)) {
+		printk(KERN_ERR "Could not find host no %d\n", host_no);
+		return -EINVAL;
+	}
+
+	rq = blk_queue_find_tag(shost->uspace_req_q, cid);
+	if (!rq) {
+		printk(KERN_ERR "Could not find cid %u\n", cid);
+		err = -EINVAL;
+		goto done;
+	}
+	cmd = rq->special;
+
+	dprintk("cmd %p result %d len %d bufflen %u\n", cmd,
+		result, len, cmd->request_bufflen);
+
+	/*
+	 * store the userspace values here, the working values are
+	 * in the request_* values
+	 */
+	cmd->buffer = (void *)uaddr;
+	if (len)
+		cmd->bufflen = len;
+	cmd->result = result;
+
+	if (!cmd->bufflen) {
+		err = __scsi_tgt_transfer_response(cmd);
+		goto done;
+	}
+
+	/*
+	 * TODO: Do we need to handle case where request does not
+	 * align with LLD.
+	 */
+	err = scsi_map_user_pages(cmd, rw);
+	if (err) {
+		eprintk("%p %d\n", cmd, err);
+		err = -EAGAIN;
+		goto done;
+	}
+
+	/* userspace failure */
+	if (cmd->result) {
+		if (status_byte(cmd->result) == CHECK_CONDITION)
+			scsi_tgt_copy_sense(cmd, uaddr, len);
+		err = __scsi_tgt_transfer_response(cmd);
+		goto done;
+	}
+	/* ask the target LLD to transfer the data to the buffer */
+	err = scsi_tgt_transfer_data(cmd);
+
+done:
+	scsi_host_put(shost);
+	return err;
+}
+
+static int __init scsi_tgt_init(void)
+{
+	int err;
+
+	scsi_tgtd = create_workqueue("scsi_tgtd");
+	if (!scsi_tgtd)
+		return -ENOMEM;
+
+	err = scsi_tgt_nl_init();
+	if (err)
+		destroy_workqueue(scsi_tgtd);
+	return err;
+}
+
+static void __exit scsi_tgt_exit(void)
+{
+	destroy_workqueue(scsi_tgtd);
+	scsi_tgt_nl_exit();
+}
+
+module_init(scsi_tgt_init);
+module_exit(scsi_tgt_exit);
+
+MODULE_DESCRIPTION("SCSI target core");
+MODULE_LICENSE("GPL");

Added: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-27 22:01:10 UTC (rev 231)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-27 22:09:50 UTC (rev 232)
@@ -0,0 +1,237 @@
+/*
+ * Target Netlink Framework code
+ *
+ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ * This code is licenced under the GPL.
+ */
+
+#include <linux/netlink.h>
+#include <linux/blkdev.h>
+#include <net/tcp.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tgt_if.h>
+
+#include "scsi_tgt_priv.h"
+
+/* default task when host is not setup in userspace yet */
+static int tgtd_pid;
+static struct sock *nls;
+
+static int scsi_tgt_get_pid(struct Scsi_Host *shost)
+{
+	struct scsi_tgt_queuedata *queue = shost->uspace_req_q->queuedata;
+
+	if (likely(queue->task))
+		return queue->task->pid;
+	else {
+		printk(KERN_INFO "Sending cmd to tgtd. Host%d is unbound\n",
+		       shost->host_no);
+		return tgtd_pid;
+	}
+}
+
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, u64 lun, gfp_t gfp_mask)
+{
+	struct sk_buff *skb;
+	struct nlmsghdr *nlh;
+	struct tgt_event *ev;
+	char *pdu;
+	int len, err;
+	pid_t pid;
+
+	pid = scsi_tgt_get_pid(cmd->shost);
+	len = NLMSG_SPACE(sizeof(*ev) + MAX_COMMAND_SIZE);
+	/*
+	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
+	 */
+	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
+	if (!skb)
+		return -ENOMEM;
+
+	dprintk("%p %d %Zd %d\n", cmd, len, sizeof(*ev), MAX_COMMAND_SIZE);
+	nlh = __nlmsg_put(skb, pid, 0, TGT_KEVENT_CMD_REQ,
+			  len - sizeof(*nlh), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+
+	pdu = (char *) ev->data;
+	ev->k.cmd_req.host_no = cmd->shost->host_no;
+	ev->k.cmd_req.dev_id = lun;
+	ev->k.cmd_req.cid = cmd->request->tag;
+	ev->k.cmd_req.data_len = cmd->request_bufflen;
+	memcpy(ev->data, cmd->cmnd, MAX_COMMAND_SIZE);
+
+	err = netlink_unicast(nls, skb, pid, 0);
+	if (err < 0)
+		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb "
+		      "to pid %d err %d\n", pid, err);
+	return err;
+}
+
+static int send_event_res(uint16_t type, struct tgt_event *p,
+			  void *data, int dlen, gfp_t flags, pid_t pid)
+{
+	struct tgt_event *ev;
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	uint32_t len;
+
+	len = NLMSG_SPACE(sizeof(*ev) + dlen);
+	skb = alloc_skb(len, flags);
+	if (!skb)
+		return -ENOMEM;
+
+	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
+
+	ev = NLMSG_DATA(nlh);
+	memcpy(ev, p, sizeof(*ev));
+	if (dlen)
+		memcpy(ev->data, data, dlen);
+
+	return netlink_unicast(nls, skb, pid, 0);
+}
+
+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.cmd_done.host_no = cmd->shost->host_no;
+	ev.k.cmd_done.cid = (unsigned long)cmd;
+	ev.k.cmd_done.result = cmd->result;
+
+	return send_event_res(TGT_KEVENT_CMD_DONE, &ev, NULL, 0, gfp_mask,
+			     scsi_tgt_get_pid(cmd->shost));
+}
+
+static int scsi_tgt_bind_host(struct tgt_event *ev)
+{
+	struct Scsi_Host *shost;
+	struct task_struct *tsk;
+	int err = 0;
+
+	shost = scsi_host_lookup(ev->u.target_bind.host_no);
+	if (IS_ERR(shost)) {
+		eprintk("Could not find host no %d\n",
+			ev->u.target_bind.host_no);
+			return -EINVAL;
+	}
+
+	tsk = find_task_by_pid(ev->u.target_bind.pid);
+	if (tsk) {
+		struct scsi_tgt_queuedata *queue;
+
+		queue = shost->uspace_req_q->queuedata;
+		queue->task = tsk;
+	} else {
+		eprintk("Could not find process %d\n",
+			ev->u.target_bind.pid);
+		err = EINVAL;
+	}
+
+	scsi_host_put(shost);
+	return 0;
+}
+
+static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+{
+	struct tgt_event *ev = NLMSG_DATA(nlh);
+	int err = 0;
+
+	dprintk("%d %d %d\n", nlh->nlmsg_type,
+		nlh->nlmsg_pid, current->pid);
+
+	switch (nlh->nlmsg_type) {
+	case TGT_UEVENT_START:
+		tgtd_pid = NETLINK_CREDS(skb)->pid;
+		break;
+	case TGT_UEVENT_TARGET_BIND:
+		err = scsi_tgt_bind_host(ev);
+		break;
+	case TGT_UEVENT_CMD_RES:
+		/* TODO: handle multiple cmds in one event */
+		err = scsi_tgt_kspace_exec(ev->u.cmd_res.host_no,
+					   ev->u.cmd_res.cid,
+					   ev->u.cmd_res.result,
+					   ev->u.cmd_res.len,
+					   ev->u.cmd_res.offset,
+					   ev->u.cmd_res.uaddr,
+					   ev->u.cmd_res.rw,
+					   ev->u.cmd_res.try_map);
+		break;
+	default:
+		eprintk("unknown type %d\n", nlh->nlmsg_type);
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int event_recv_skb(struct sk_buff *skb)
+{
+	int err;
+	uint32_t rlen;
+	struct nlmsghdr	*nlh;
+
+	while (skb->len >= NLMSG_SPACE(0)) {
+		nlh = (struct nlmsghdr *) skb->data;
+		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+			return 0;
+		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+		if (rlen > skb->len)
+			rlen = skb->len;
+		err = event_recv_msg(skb, nlh);
+
+		dprintk("%d %d\n", nlh->nlmsg_type, err);
+		/*
+		 * TODO for passthru commands the lower level should
+		 * probably handle the result or we should modify this
+		 */
+		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RES) {
+			struct tgt_event ev;
+
+			memset(&ev, 0, sizeof(ev));
+			ev.k.event_res.err = err;
+			send_event_res(TGT_KEVENT_RESPONSE, &ev, NULL, 0,
+				       GFP_KERNEL | __GFP_NOFAIL,
+					nlh->nlmsg_pid);
+		}
+		skb_pull(skb, rlen);
+	}
+	return 0;
+}
+
+static void event_recv(struct sock *sk, int length)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+		if (NETLINK_CREDS(skb)->uid) {
+			skb_pull(skb, skb->len);
+			kfree_skb(skb);
+			continue;
+		}
+
+		if (event_recv_skb(skb) && skb->len)
+			skb_queue_head(&sk->sk_receive_queue, skb);
+		else
+			kfree_skb(skb);
+	}
+}
+
+void __exit scsi_tgt_nl_exit(void)
+{
+	sock_release(nls->sk_socket);
+}
+
+int __init scsi_tgt_nl_init(void)
+{
+	nls = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
+				    THIS_MODULE);
+	if (!nls)
+		return -ENOMEM;
+
+	return 0;
+}

Added: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-01-27 22:01:10 UTC (rev 231)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-01-27 22:09:50 UTC (rev 232)
@@ -0,0 +1,23 @@
+struct scsi_cmnd;
+struct task_struct;
+
+/* tmp - will replace with SCSI logging stuff */
+#define dprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+} while (0)
+
+#define eprintk dprintk
+
+struct scsi_tgt_queuedata {
+	struct task_struct *task;
+};
+
+extern void scsi_tgt_nl_exit(void);
+extern int scsi_tgt_nl_init(void);
+
+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, u64 lun, gfp_t gfp_mask);
+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
+extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
+				u64 offset, unsigned long uaddr, u8 rw,
+				u8 try_map);



From mnc at berlios.de  Fri Jan 27 23:12:44 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:12:44 +0100
Subject: [Stgt-svn] r233 - branches/use-scsi-ml/kernel
Message-ID: <200601272212.k0RMCiCB000349@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:12:44 +0100 (Fri, 27 Jan 2006)
New Revision: 233

Added:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
this patch needs to be applied to your kernel. it is the scsi-ml, block layer etc changes

Added: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-27 22:09:50 UTC (rev 232)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-27 22:12:44 UTC (rev 233)
@@ -0,0 +1,700 @@
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 8e27d0a..9e7375f 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2291,7 +2291,7 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	 */
+ 	uaddr = (unsigned long) ubuf;
+ 	if (!(uaddr & queue_dma_alignment(q)) && !(len & queue_dma_alignment(q)))
+-		bio = bio_map_user(q, NULL, uaddr, len, reading);
++		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+@@ -2343,7 +2343,8 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	/* we don't allow misaligned data like bio_map_user() does.  If the
+ 	 * user is using sg, they're expected to know the alignment constraints
+ 	 * and respect them accordingly */
+-	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
++	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
++				0);
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
+diff --git a/drivers/md/dm-bio-list.h b/drivers/md/dm-bio-list.h
+deleted file mode 100644
+index bbf4615..0000000
+--- a/drivers/md/dm-bio-list.h
++++ /dev/null
+@@ -1,71 +0,0 @@
+-/*
+- * Copyright (C) 2004 Red Hat UK Ltd.
+- *
+- * This file is released under the GPL.
+- */
+-
+-#ifndef DM_BIO_LIST_H
+-#define DM_BIO_LIST_H
+-
+-#include <linux/bio.h>
+-
+-struct bio_list {
+-	struct bio *head;
+-	struct bio *tail;
+-};
+-
+-static inline void bio_list_init(struct bio_list *bl)
+-{
+-	bl->head = bl->tail = NULL;
+-}
+-
+-static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
+-{
+-	bio->bi_next = NULL;
+-
+-	if (bl->tail)
+-		bl->tail->bi_next = bio;
+-	else
+-		bl->head = bio;
+-
+-	bl->tail = bio;
+-}
+-
+-static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
+-{
+-	if (!bl2->head)
+-		return;
+-
+-	if (bl->tail)
+-		bl->tail->bi_next = bl2->head;
+-	else
+-		bl->head = bl2->head;
+-
+-	bl->tail = bl2->tail;
+-}
+-
+-static inline struct bio *bio_list_pop(struct bio_list *bl)
+-{
+-	struct bio *bio = bl->head;
+-
+-	if (bio) {
+-		bl->head = bl->head->bi_next;
+-		if (!bl->head)
+-			bl->tail = NULL;
+-
+-		bio->bi_next = NULL;
+-	}
+-
+-	return bio;
+-}
+-
+-static inline struct bio *bio_list_get(struct bio_list *bl)
+-{
+-	struct bio *bio = bl->head;
+-
+-	bl->head = bl->tail = NULL;
+-
+-	return bio;
+-}
+-
+-#endif
+diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
+index f72a82f..c6e206f 100644
+--- a/drivers/md/dm-mpath.c
++++ b/drivers/md/dm-mpath.c
+@@ -8,9 +8,9 @@
+ #include "dm.h"
+ #include "dm-path-selector.h"
+ #include "dm-hw-handler.h"
+-#include "dm-bio-list.h"
+ #include "dm-bio-record.h"
+ 
++#include <linux/bio-list.h>
+ #include <linux/ctype.h>
+ #include <linux/init.h>
+ #include <linux/mempool.h>
+diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
+index 6cfa8d4..53f589b 100644
+--- a/drivers/md/dm-raid1.c
++++ b/drivers/md/dm-raid1.c
+@@ -5,11 +5,11 @@
+  */
+ 
+ #include "dm.h"
+-#include "dm-bio-list.h"
+ #include "dm-io.h"
+ #include "dm-log.h"
+ #include "kcopyd.h"
+ 
++#include <linux/bio-list.h>
+ #include <linux/ctype.h>
+ #include <linux/init.h>
+ #include <linux/mempool.h>
+diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c
+index 4b9dd8f..f6d44e9 100644
+--- a/drivers/md/dm-snap.c
++++ b/drivers/md/dm-snap.c
+@@ -18,9 +18,9 @@
+ #include <linux/module.h>
+ #include <linux/slab.h>
+ #include <linux/vmalloc.h>
++#include <linux/bio-list.h>
+ 
+ #include "dm-snap.h"
+-#include "dm-bio-list.h"
+ #include "kcopyd.h"
+ 
+ /*
+diff --git a/drivers/md/dm.c b/drivers/md/dm.c
+index 097d1e5..f51568a 100644
+--- a/drivers/md/dm.c
++++ b/drivers/md/dm.c
+@@ -6,8 +6,8 @@
+  */
+ 
+ #include "dm.h"
+-#include "dm-bio-list.h"
+ 
++#include <linux/bio-list.h>
+ #include <linux/init.h>
+ #include <linux/module.h>
+ #include <linux/moduleparam.h>
+diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
+index a06ff91..76798dc 100644
+--- a/drivers/md/raid1.c
++++ b/drivers/md/raid1.c
+@@ -31,7 +31,7 @@
+  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+-#include "dm-bio-list.h"
++#include <linux/bio-list.h>
+ #include <linux/raid/raid1.h>
+ #include <linux/raid/bitmap.h>
+ 
+diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
+index 9e658e5..c480fe6 100644
+--- a/drivers/md/raid10.c
++++ b/drivers/md/raid10.c
+@@ -18,7 +18,7 @@
+  * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+-#include "dm-bio-list.h"
++#include <linux/bio-list.h>
+ #include <linux/raid/raid10.h>
+ #include <linux/raid/bitmap.h>
+ 
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index 5881079..64e687a 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
+ 
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index 245ca99..48cfdf2 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -236,6 +236,59 @@ static struct scsi_cmnd *__scsi_get_comm
+ }
+ 
+ /*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		return NULL;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		goto release_rq;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto put_dev;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->shost = shost;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++
++	return cmd;
++
++put_dev:
++	put_device(&shost->shost_gendev);
++release_rq:
++	blk_put_request(rq);
++	return NULL;
++
++}				
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
+  * Function:	scsi_get_command()
+  *
+  * Purpose:	Allocate and setup a scsi command block
+@@ -274,6 +327,45 @@ struct scsi_cmnd *scsi_get_command(struc
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+ /*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = cmd->shost;
++	struct request_queue *q = cmd->shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	unsigned long flags;
++	
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock(&shost->free_list_lock);
++
++	spin_lock(q->queue_lock);
++	if (blk_rq_tagged(rq))
++		blk_queue_end_tag(q, rq);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(&shost->shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++/*
+  * Function:	scsi_put_command()
+  *
+  * Purpose:	Free a scsi command block
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 3574ba9..ab66ca4 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
+index 752fb5d..0fdd11a 100644
+--- a/drivers/scsi/scsi_scan.c
++++ b/drivers/scsi/scsi_scan.c
+@@ -1013,7 +1013,7 @@ static void scsi_sequential_lun_scan(str
+  *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns
+  *     the integer: 0x0b030a04
+  **/
+-static int scsilun_to_int(struct scsi_lun *scsilun)
++int scsilun_to_int(struct scsi_lun *scsilun)
+ {
+ 	int i;
+ 	unsigned int lun;
+@@ -1024,6 +1024,7 @@ static int scsilun_to_int(struct scsi_lu
+ 			      scsilun->scsi_lun[i + 1]) << (i * 8));
+ 	return lun;
+ }
++EXPORT_SYMBOL(scsilun_to_int);
+ 
+ /**
+  * int_to_scsilun: reverts an int into a scsi_lun
+diff --git a/fs/bio.c b/fs/bio.c
+index 7b30695..aba3ce9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -718,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
+  *	@uaddr: start of user address
+  *	@len: length in bytes
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
+-			 unsigned long uaddr, unsigned int len, int write_to_vm)
++			 unsigned long uaddr, unsigned int len, int write_to_vm,
++			 int support_partial)
+ {
+ 	struct sg_iovec iov;
+ 
+ 	iov.iov_base = (void __user *)uaddr;
+ 	iov.iov_len = len;
+ 
+-	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm);
++	return bio_map_user_iov(q, bdev, &iov, 1, write_to_vm, support_partial);
+ }
+ 
+ /**
+@@ -740,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
+  *	@iov:	the iovec.
+  *	@iov_count: number of elements in the iovec
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
+ 			     struct sg_iovec *iov, int iov_count,
+-			     int write_to_vm)
++			     int write_to_vm, int support_partial)
+ {
+ 	struct bio *bio;
+ 	int len = 0, i;
+@@ -767,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
+ 	for (i = 0; i < iov_count; i++)
+ 		len += iov[i].iov_len;
+ 
+-	if (bio->bi_size == len)
++	if (bio->bi_size == len || support_partial)
+ 		return bio;
+ 
+ 	/*
+diff --git a/include/linux/bio-list.h b/include/linux/bio-list.h
+new file mode 100644
+index 0000000..4653516
+--- /dev/null
++++ b/include/linux/bio-list.h
+@@ -0,0 +1,71 @@
++/*
++ * Copyright (C) 2004 Red Hat UK Ltd.
++ *
++ * This file is released under the GPL.
++ */
++
++#ifndef _BIO_LIST_H
++#define _BIO_LIST_H
++
++#include <linux/bio.h>
++
++struct bio_list {
++	struct bio *head;
++	struct bio *tail;
++};
++
++static inline void bio_list_init(struct bio_list *bl)
++{
++	bl->head = bl->tail = NULL;
++}
++
++static inline void bio_list_add(struct bio_list *bl, struct bio *bio)
++{
++	bio->bi_next = NULL;
++
++	if (bl->tail)
++		bl->tail->bi_next = bio;
++	else
++		bl->head = bio;
++
++	bl->tail = bio;
++}
++
++static inline void bio_list_merge(struct bio_list *bl, struct bio_list *bl2)
++{
++	if (!bl2->head)
++		return;
++
++	if (bl->tail)
++		bl->tail->bi_next = bl2->head;
++	else
++		bl->head = bl2->head;
++
++	bl->tail = bl2->tail;
++}
++
++static inline struct bio *bio_list_pop(struct bio_list *bl)
++{
++	struct bio *bio = bl->head;
++
++	if (bio) {
++		bl->head = bl->head->bi_next;
++		if (!bl->head)
++			bl->tail = NULL;
++
++		bio->bi_next = NULL;
++	}
++
++	return bio;
++}
++
++static inline struct bio *bio_list_get(struct bio_list *bl)
++{
++	struct bio *bio = bl->head;
++
++	bl->head = bl->tail = NULL;
++
++	return bio;
++}
++
++#endif
+diff --git a/include/linux/bio.h b/include/linux/bio.h
+index b60ffe3..fc0906c 100644
+--- a/include/linux/bio.h
++++ b/include/linux/bio.h
+@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
+ extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
+ 			   unsigned int, unsigned int);
+ extern int bio_get_nr_vecs(struct block_device *);
++extern int __bio_get_nr_vecs(struct request_queue *);
+ extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
+-				unsigned long, unsigned int, int);
++				unsigned long, unsigned int, int, int);
+ struct sg_iovec;
+ extern struct bio *bio_map_user_iov(struct request_queue *,
+ 				    struct block_device *,
+-				    struct sg_iovec *, int, int);
++				    struct sg_iovec *, int, int, int);
+ extern void bio_unmap_user(struct bio *);
+ extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
+ 				gfp_t);
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 6a2ccf7..580fb42 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 7529f43..452d652 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -5,9 +5,11 @@
+ #include <linux/list.h>
+ #include <linux/types.h>
+ #include <linux/timer.h>
++#include <linux/bio-list.h>
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -31,6 +33,7 @@ struct scsi_pointer {
+ struct scsi_cmnd {
+ 	int     sc_magic;
+ 
++	struct Scsi_Host *shost;
+ 	struct scsi_device *device;
+ 	struct scsi_request *sc_request;
+ 
+@@ -131,6 +134,14 @@ struct scsi_cmnd {
+ 
+ 	unsigned char tag;	/* SCSI-II queued command tag */
+ 	unsigned long pid;	/* Process ID, starts at 0. Unique per host. */
++	/*
++	 * Work struct to process completion of scsi commands in process
++	 * context. (this should be ifdefd since the work struct is large)
++	 */
++	struct work_struct work;
++	/* list of bios to be unmapped in work struct */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
+ };
+ 
+ /*
+@@ -147,9 +158,14 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern void scsi_host_put_command(struct scsi_cmnd *);
+ extern void scsi_put_command(struct scsi_cmnd *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
+index e94ca4d..1b09f4f 100644
+--- a/include/scsi/scsi_device.h
++++ b/include/scsi/scsi_device.h
+@@ -264,6 +264,7 @@ extern void scsi_target_block(struct dev
+ extern void scsi_target_unblock(struct device *);
+ extern void scsi_remove_target(struct device *);
+ extern void int_to_scsilun(unsigned int, struct scsi_lun *);
++extern int scsilun_to_int(struct scsi_lun *);
+ extern const char *scsi_device_state_name(enum scsi_device_state);
+ extern int scsi_is_sdev_device(const struct device *);
+ extern int scsi_is_target_device(const struct device *);
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 467274a..fbab68c 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,21 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -573,6 +589,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -675,6 +697,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any



From mnc at berlios.de  Fri Jan 27 23:13:31 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:13:31 +0100
Subject: [Stgt-svn] r234 - branches/use-scsi-ml/kernel
Message-ID: <200601272213.k0RMDV2H000477@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:13:31 +0100 (Fri, 27 Jan 2006)
New Revision: 234

Added:
   branches/use-scsi-ml/kernel/README
Log:
add readme

Added: branches/use-scsi-ml/kernel/README
===================================================================
--- branches/use-scsi-ml/kernel/README	2006-01-27 22:12:44 UTC (rev 233)
+++ branches/use-scsi-ml/kernel/README	2006-01-27 22:13:31 UTC (rev 234)
@@ -0,0 +1 @@
+You must apply tgt-scsi-ml8.patch to your kernel



From mnc at berlios.de  Fri Jan 27 23:16:37 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:16:37 +0100
Subject: [Stgt-svn] r235 - branches/use-scsi-ml/kernel
Message-ID: <200601272216.k0RMGbGS000683@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:16:32 +0100 (Fri, 27 Jan 2006)
New Revision: 235

Added:
   branches/use-scsi-ml/kernel/Makefile
Log:
Add Makefile. Must figure how the heck to fixup the include crap, or must get a git tree.

Added: branches/use-scsi-ml/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/kernel/Makefile	2006-01-27 22:13:31 UTC (rev 234)
+++ branches/use-scsi-ml/kernel/Makefile	2006-01-27 22:16:32 UTC (rev 235)
@@ -0,0 +1,24 @@
+#
+# Makefile for the Linux kernel device drivers.
+#
+
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17 -DNETLINK_TGT_CMD=21
+
+ifneq ($(KERNELRELEASE),)
+obj-m			+= scsi_tgt_lib.o
+scsi_tgt_lib-objs	:= scsi_tgt_lib.o scsi_tgt_nl.o
+
+else
+
+ifeq ($(KERNELSRC),)
+	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
+endif
+
+PWD := $(shell pwd)
+
+default:
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) clean
+endif



From mnc at berlios.de  Fri Jan 27 23:28:17 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Fri, 27 Jan 2006 23:28:17 +0100
Subject: [Stgt-svn] r236 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200601272228.k0RMSHZX001938@sheep.berlios.de>

Author: mnc
Date: 2006-01-27 23:28:16 +0100 (Fri, 27 Jan 2006)
New Revision: 236

Modified:
   branches/use-scsi-ml/istgt/kernel/Makefile
   branches/use-scsi-ml/istgt/kernel/conn.c
   branches/use-scsi-ml/istgt/kernel/digest.c
   branches/use-scsi-ml/istgt/kernel/iscsi.c
   branches/use-scsi-ml/istgt/kernel/iscsi.h
   branches/use-scsi-ml/istgt/kernel/nthread.c
Log:
begin to convert istgt. I think this is similar to the version posted in linux-scsi so the transfer_data/trasnfer_response fns need to be updated. It also does not compile becuase of various changes like the includes are messed up - have to finsih the svn merged process. I am just checking in to sync me and Tomo. Userspace is also not converted

Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-01-27 22:28:16 UTC (rev 236)
@@ -11,8 +11,8 @@
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= istgt.o
-istgt-objs	:= iscsi.o nthread.o config.o digest.o\
-			conn.o session.o param.o
+istgt-objs	:= iscsi_tcp_tgt.o nthread.o digest.o \
+			conn.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: branches/use-scsi-ml/istgt/kernel/conn.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/conn.c	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/conn.c	2006-01-27 22:28:16 UTC (rev 236)
@@ -3,65 +3,67 @@
  *
  * Released under the terms of the GNU GPL v2.0.
  */
-
 #include <linux/file.h>
 #include <linux/ip.h>
 #include <net/tcp.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_transport_iscsi.h>
 
 #include <iscsi.h>
 #include <digest.h>
 
-static struct iscsi_conn *conn_lookup(struct iscsi_session *session,
-				      uint16_t cid)
+int conn_close(struct iscsi_conn *conn)
 {
-	struct iscsi_conn *conn;
-
-	list_for_each_entry(conn, &session->conn_list, list) {
-		if (conn->cid == cid)
-			return conn;
-	}
-	return NULL;
+	/* TODO: pass in error */
+	iscsi_conn_error(conn->cls_conn, ISCSI_ERR_CONN_FAILED);
+	return 0;
 }
 
 static void state_change(struct sock *sk)
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
-	struct iscsi_target *target = conn->session->target;
+	struct iscsi_session *session = conn->session;
 
 	if (sk->sk_state != TCP_ESTABLISHED)
 		conn_close(conn);
 	else
-		nthread_wakeup(target);
+		nthread_wakeup(session);
 
-	target->nthread_info.old_state_change(sk);
+	session->nthread_info.old_state_change(sk);
 }
 
 static void data_ready(struct sock *sk, int len)
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
-	struct iscsi_target *target = conn->session->target;
+	struct iscsi_session *session = conn->session;
 
-	nthread_wakeup(target);
-	target->nthread_info.old_data_ready(sk, len);
+	nthread_wakeup(session);
+	session->nthread_info.old_data_ready(sk, len);
 }
 
-static void socket_bind(struct iscsi_conn *conn)
+int
+istgt_conn_bind(struct iscsi_cls_session *cls_session,
+		struct iscsi_cls_conn *cls_conn, uint32_t transport_fd,
+		int is_leading)
 {
-	int opt = 1;
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	int opt = 1, err;
 	mm_segment_t oldfs;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_target *target = session->target;
 
 	dprintk("%llu\n", (unsigned long long) session->sid);
 
-	conn->sock = SOCKET_I(conn->file->f_dentry->d_inode);
+	conn->file = fget(transport_fd);
+
+	conn->sock = sockfd_lookup(transport_fd, &err);
 	conn->sock->sk->sk_user_data = conn;
 
 	write_lock(&conn->sock->sk->sk_callback_lock);
-	target->nthread_info.old_state_change = conn->sock->sk->sk_state_change;
+	session->nthread_info.old_state_change = conn->sock->sk->sk_state_change;
 	conn->sock->sk->sk_state_change = state_change;
 
-	target->nthread_info.old_data_ready = conn->sock->sk->sk_data_ready;
+	session->nthread_info.old_data_ready = conn->sock->sk->sk_data_ready;
 	conn->sock->sk->sk_data_ready = data_ready;
 	write_unlock(&conn->sock->sk->sk_callback_lock);
 
@@ -70,10 +72,13 @@
 	conn->sock->ops->setsockopt(conn->sock, SOL_TCP, TCP_NODELAY,
 				    (void *)&opt, sizeof(opt));
 	set_fs(oldfs);
+	return 0;
 }
 
 int conn_free(struct iscsi_conn *conn)
 {
+	struct completion *wait = conn->free_done;
+
 	dprintk("%p %#Lx %u\n", conn->session,
 		(unsigned long long) conn->session->sid, conn->cid);
 
@@ -85,44 +90,59 @@
 	list_del(&conn->poll_list);
 
 	digest_cleanup(conn);
-	kfree(conn);
 
+	sock_release(conn->sock);
+
+	if (wait)
+		complete(wait);
+
 	return 0;
 }
 
-void conn_close(struct iscsi_conn *conn)
+void istgt_conn_destroy(struct iscsi_cls_conn *cls_conn)
 {
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_session *session = conn->session;
+	DECLARE_COMPLETION(wait);
+
+	conn->free_done = &wait;
+
 	if (test_and_clear_bit(CONN_ACTIVE, &conn->state))
 		set_bit(CONN_CLOSING, &conn->state);
 
-	nthread_wakeup(conn->session->target);
+	nthread_wakeup(session);
+	wait_for_completion(&wait);
 }
 
-int conn_add(struct iscsi_session *session, struct conn_info *info)
+struct iscsi_cls_conn *istgt_conn_create(struct iscsi_cls_session *cls_session,
+					 uint32_t cid)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
+	struct iscsi_cls_conn *cls_conn;
 	struct iscsi_conn *conn;
 
-	dprintk("%#Lx:%u\n", (unsigned long long) session->sid, info->cid);
+	dprintk("%#Lx:%u\n", (unsigned long long) session->sid, cid);
 
-	conn = conn_lookup(session, info->cid);
-	if (conn)
-		return -EEXIST;
+        cls_conn = iscsi_create_conn(cls_session, cid);
+	if (!cls_conn)
+		return NULL;
 
-	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
-	if (!conn)
-		return -ENOMEM;
+	conn = cls_conn->dd_data;
+	memset(conn, 0, sizeof(*conn));
 
+	conn->cls_conn = cls_conn;
 	conn->session = session;
-	conn->cid = info->cid;
-	conn->stat_sn = info->stat_sn;
-	conn->exp_stat_sn = info->exp_stat_sn;
+	conn->cid = cid;
+//	conn->stat_sn = info->stat_sn;
+// mnc	conn->exp_stat_sn = info->exp_stat_sn;
 
-	conn->hdigest_type = info->header_digest;
-	conn->ddigest_type = info->data_digest;
-	if (digest_init(conn) < 0) {
-		kfree(conn);
-		return -ENOMEM;
-	}
+//	conn->hdigest_type = info->header_digest;
+//	conn->ddigest_type = info->data_digest;
+//	if (digest_init(conn) < 0) {
+//		iscsi_destroy_conn(cls_conn);
+//		return NULL;
+//	}
 
 	spin_lock_init(&conn->list_lock);
 	atomic_set(&conn->nr_cmnds, 0);
@@ -132,28 +152,16 @@
 	INIT_LIST_HEAD(&conn->poll_list);
 
 	list_add(&conn->list, &session->conn_list);
-
-	set_bit(CONN_ACTIVE, &conn->state);
-
-	conn->file = fget(info->fd);
-	socket_bind(conn);
-
-	list_add(&conn->poll_list, &session->target->nthread_info.active_conns);
-
-	nthread_wakeup(conn->session->target);
-
-	return 0;
+	return cls_conn;
 }
 
-int conn_del(struct iscsi_session *session, struct conn_info *info)
+int istgt_conn_start(struct iscsi_cls_conn *cls_conn)
 {
-	struct iscsi_conn *conn;
-	int err = -EEXIST;
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_session *session = conn->session;
 
-	if (!(conn = conn_lookup(session, info->cid)))
-		return err;
-
-	conn_close(conn);
-
+	set_bit(CONN_ACTIVE, &conn->state);
+	list_add(&conn->poll_list, &session->nthread_info.active_conns);
+	nthread_wakeup(conn->session);
 	return 0;
 }

Modified: branches/use-scsi-ml/istgt/kernel/digest.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/digest.c	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/digest.c	2006-01-27 22:28:16 UTC (rev 236)
@@ -139,10 +139,10 @@
 		struct istgt_cmd *scsi_cmnd = cmnd->req;
 		struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
 
-		sg = scsi_cmnd->tc->sg;
+		sg = scsi_cmnd->scmd->request_buffer;
 		offset = be32_to_cpu(req->offset);
 	} else {
-		sg = cmnd->tc->sg;
+		sg = cmnd->scmd->request_buffer;
 		offset = 0;
 	}
 

Modified: branches/use-scsi-ml/istgt/kernel/iscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi.c	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/iscsi.c	2006-01-27 22:28:16 UTC (rev 236)
@@ -1,1732 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <linux/module.h>
-#include <linux/hash.h>
-#include <net/tcp.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_tcq.h>
-#include <linux/mempool.h>
-
-#include <iscsi.h>
-
-static kmem_cache_t *istgt_cmd_cache;
-static char dummy_data[1024];
-
-static uint32_t cmnd_write_size(struct istgt_cmd *cmnd)
-{
-	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
-
-	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
-		return be32_to_cpu(hdr->data_length);
-	return 0;
-}
-
-static uint32_t cmnd_read_size(struct istgt_cmd *cmnd)
-{
-	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
-
-	if (hdr->flags & ISCSI_FLAG_CMD_READ) {
-		if (!(hdr->flags & ISCSI_FLAG_CMD_WRITE))
-			return be32_to_cpu(hdr->data_length);
-		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
-			struct iscsi_rlength_ahdr *ahdr =
-				(struct iscsi_rlength_ahdr *)cmnd->pdu.ahs;
-			if (ahdr && ahdr->ahstype == ISCSI_AHSTYPE_RLENGTH)
-				return be32_to_cpu(ahdr->read_length);
-		}
-	}
-	return 0;
-}
-
-/**
- * create a new command.
- *
- * iscsi_cmnd_create - 
- * @conn: ptr to connection (for i/o)
- *
- * @return    ptr to command or NULL
- */
-
-struct istgt_cmd *cmnd_alloc(struct iscsi_conn *conn, int req)
-{
-	struct istgt_cmd *cmnd;
-
-	/* TODO: async interface is necessary ? */
-	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
-
-	memset(cmnd, 0, sizeof(*cmnd));
-	INIT_LIST_HEAD(&cmnd->list);
-	INIT_LIST_HEAD(&cmnd->pdu_list);
-	INIT_LIST_HEAD(&cmnd->conn_list);
-	INIT_LIST_HEAD(&cmnd->hash_list);
-	cmnd->conn = conn;
-	spin_lock(&conn->list_lock);
-	atomic_inc(&conn->nr_cmnds);
-	init_completion(&cmnd->event);
-	if (req)
-		list_add_tail(&cmnd->conn_list, &conn->pdu_list);
-	spin_unlock(&conn->list_lock);
-	cmnd->sg = NULL;
-
-	if (req) {
-		BUG_ON(!conn->session);
-		BUG_ON(!conn->session->ts);
-	}
-
-	dprintk("%p:%p\n", conn, cmnd);
-
-	return cmnd;
-}
-
-/**
- * create a new command used as response.
- *
- * iscsi_cmnd_create_rsp_cmnd - 
- * @cmnd: ptr to request command
- *
- * @return    ptr to response command or NULL
- */
-
-static struct istgt_cmd *iscsi_cmnd_create_rsp_cmnd(struct istgt_cmd *cmnd, int final)
-{
-	struct istgt_cmd *rsp = cmnd_alloc(cmnd->conn, 0);
-
-	if (final)
-		set_cmd_final(rsp);
-	list_add_tail(&rsp->pdu_list, &cmnd->pdu_list);
-	rsp->req = cmnd;
-	return rsp;
-}
-
-static struct istgt_cmd *get_rsp_cmnd(struct istgt_cmd *req)
-{
-	return list_entry(req->pdu_list.prev, struct istgt_cmd, pdu_list);
-}
-
-static void iscsi_cmnds_init_write(struct list_head *send)
-{
-	struct istgt_cmd *cmnd = list_entry(send->next, struct istgt_cmd, list);
-	struct iscsi_conn *conn = cmnd->conn;
-	struct list_head *pos, *next;
-
-	spin_lock(&conn->list_lock);
-
-	list_for_each_safe(pos, next, send) {
-		cmnd = list_entry(pos, struct istgt_cmd, list);
-
-		dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
-
-		list_del_init(&cmnd->list);
-		BUG_ON(conn != cmnd->conn);
-		list_add_tail(&cmnd->list, &conn->write_list);
-	}
-
-	spin_unlock(&conn->list_lock);
-
-	nthread_wakeup(conn->session->target);
-}
-
-static void iscsi_cmnd_init_write(struct istgt_cmd *cmnd)
-{
-	LIST_HEAD(head);
-
-	if (!list_empty(&cmnd->list)) {
-		eprintk("%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n",
-			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
-			cmd_scsicode(cmnd), cmnd->flags,
-			cmnd->r2t_sn, cmnd->r2t_length, cmnd->is_unsolicited_data,
-			cmnd->target_task_tag, cmnd->outstanding_r2t,
-			cmnd->hdigest, cmnd->ddigest,
-			list_empty(&cmnd->pdu_list), list_empty(&cmnd->hash_list));
-
-		BUG_ON(!list_empty(&cmnd->list));
-	}
-	list_add(&cmnd->list, &head);
-	iscsi_cmnds_init_write(&head);
-}
-
-static void do_send_data_rsp(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	struct istgt_cmd *data_cmnd;
-	struct scatterlist *sg = cmnd->tc->sg;
-	struct iscsi_cmd *req = cmd_hdr(cmnd);
-	struct iscsi_data_rsp *rsp;
-	uint32_t pdusize, expsize, scsisize, size, offset, sn;
-	LIST_HEAD(send);
-
-	dprintk("%p\n", cmnd);
-	pdusize = conn->session->param.max_xmit_data_length;
-	expsize = cmnd_read_size(cmnd);
-	BUG_ON(!cmnd->tc);
-	size = min(expsize, cmnd->tc->bufflen);
-	dprintk("%u %u\n", expsize, cmnd->tc->bufflen);
-	offset = 0;
-	sn = 0;
-
-	BUG_ON(!sg);
-
-	while (1) {
-		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
-		data_cmnd->sg = sg;
-		rsp = (struct iscsi_data_rsp *)&data_cmnd->pdu.bhs;
-
-		rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
-		rsp->itt = req->itt;
-		rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-		rsp->offset = offset;
-		rsp->datasn = cpu_to_be32(sn);
-
-		if (size <= pdusize) {
-			data_cmnd->pdu.datasize = size;
-			rsp->flags = ISCSI_FLAG_CMD_FINAL |
-				     ISCSI_FLAG_DATA_STATUS;
-
-			scsisize = cmnd->tc->bufflen;
-			if (scsisize < expsize) {
-				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-				size = expsize - scsisize;
-			} else if (scsisize > expsize) {
-				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-				size = scsisize - expsize;
-			} else
-				size = 0;
-			rsp->residual_count = cpu_to_be32(size);
-			list_add_tail(&data_cmnd->list, &send);
-
-			break;
-		}
-
-		data_cmnd->pdu.datasize = pdusize;
-
-		size -= pdusize;
-		offset += pdusize;
-		sn++;
-
-		list_add_tail(&data_cmnd->list, &send);
-	}
-
-	iscsi_cmnds_init_write(&send);
-}
-
-static struct istgt_cmd *create_scsi_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-	struct iscsi_cmd_rsp *rsp_hdr;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr->cmd_status = SAM_STAT_GOOD;
-	rsp_hdr->itt = req_hdr->itt;
-
-	return rsp;
-}
-
-static void send_scsi_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	uint32_t size;
-
-	rsp = create_scsi_rsp(req);
-	rsp_hdr = (struct iscsi_cmd_rsp *) &rsp->pdu.bhs;
-	if ((size = cmnd_read_size(req)) != 0) {
-		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-		rsp_hdr->residual_count = cpu_to_be32(size);
-	}
-
-	iscsi_cmnd_init_write(rsp);
-}
-
-static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	struct iscsi_sense_data *sense = &req->sense;
-	struct scatterlist *sg = &req->sense_sg;
-	struct page *page = req->tc->sg[0].page;
-	char *p;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr->itt = cmd_hdr(req)->itt;
-
-	p = kmap(page);
-	memcpy(sense->sense_buff, p, sizeof(sense->sense_buff));
-	kunmap(page);
-
-	/*
-	 * this looks broken for ppc
-	 */
-	sense->length = cpu_to_be16(tgt_scsi_sense_length(req->tc));
-
-	sg->page = virt_to_page(sense);
-	sg->offset = offset_in_page(sense);
-	sg->length = tgt_scsi_sense_length(req->tc) + sizeof(uint16_t);
-	rsp->pdu.datasize = sg->length;
-	rsp->sg = sg;
-
-	return rsp;
-}
-
-static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
-					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	struct scatterlist *sg = &req->sense_sg;
-	struct iscsi_sense_data *sense = &req->sense;
-	uint8_t *data = sense->sense_buff;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr->itt = cmd_hdr(req)->itt;
-
-	sg->page = virt_to_page(sense);
-	sg->offset = offset_in_page(sense);
-
-	sense->length = cpu_to_be16(14);
-	data[0] = 0xf0;
-	data[2] = sense_key;
-	data[7] = 6;	// Additional sense length
-	data[12] = asc;
-	data[13] = ascq;
-
-	rsp->pdu.datasize = sizeof(uint16_t) + 14;
-	rsp->sg = sg;
-
-	sg->length = (rsp->pdu.datasize + 3) & -4;
-
-	return rsp;
-}
-
-/**
- * Free a command.
- * Also frees the additional header.
- *
- * iscsi_cmnd_remove - 
- * @cmnd: ptr to command
- */
-
-void iscsi_cmnd_remove(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn;
-
-	if (!cmnd)
-		return;
-	dprintk("%p\n", cmnd);
-	conn = cmnd->conn;
-	kfree(cmnd->pdu.ahs);
-
-	if (!list_empty(&cmnd->list)) {
-		struct iscsi_cmd *req = cmd_hdr(cmnd);
-
-		eprintk("cmnd %p still on some list?, %x %x %x %x %x %x %x %lx\n",
-			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
-			be32_to_cpu(req->data_length), req->cmdsn,
-			be32_to_cpu(cmnd->pdu.datasize), conn->state);
-
-		if (cmnd->req) {
-			struct iscsi_cmd *req = cmd_hdr(cmnd->req);
-			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
-		}
-		BUG();
-	}
-	list_del(&cmnd->list);
-	spin_lock(&conn->list_lock);
-	atomic_dec(&conn->nr_cmnds);
-	list_del(&cmnd->conn_list);
-	spin_unlock(&conn->list_lock);
-
-	if (cmnd->tc)
-		cmnd->tc->done(cmnd->tc);
-	kmem_cache_free(istgt_cmd_cache, cmnd);
-}
-
-static void cmnd_skip_pdu(struct istgt_cmd *cmnd)
-{
-/* 	struct iscsi_conn *conn = cmnd->conn; */
-/* 	struct tio *tio = cmnd->tio; */
-/* 	char *addr; */
-/* 	u32 size; */
-/* 	int i; */
-
-	BUG_ON(1);
-
-/* 	eprintk("%x %x %x %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
-/* 		cmd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
-
-/* 	if (!(size = cmnd->pdu.datasize)) */
-/* 		return; */
-
-/* 	if (tio) */
-/* 		assert(tio->pg_cnt > 0); */
-/* 	else */
-/* 		tio = cmnd->tio = tio_alloc(1); */
-
-/* 	addr = page_address(tio->pvec[0]); */
-/* 	assert(addr); */
-/* 	size = (size + 3) & -4; */
-/* 	conn->read_size = size; */
-/* 	for (i = 0; size > PAGE_CACHE_SIZE; i++, size -= PAGE_CACHE_SIZE) { */
-/* 		assert(i < ISCSI_CONN_IOV_MAX); */
-/* 		conn->read_iov[i].iov_base = addr; */
-/* 		conn->read_iov[i].iov_len = PAGE_CACHE_SIZE; */
-/* 	} */
-/* 	conn->read_iov[i].iov_base = addr; */
-/* 	conn->read_iov[i].iov_len = size; */
-/* 	conn->read_msg.msg_iov = conn->read_iov; */
-/* 	conn->read_msg.msg_iovlen = ++i; */
-}
-
-static void iscsi_cmnd_reject(struct istgt_cmd *req, int reason)
-{
-/* 	struct istgt_cmd *rsp; */
-/* 	struct iscsi_reject_hdr *rsp_hdr; */
-/* 	struct tio *tio; */
-/* 	char *addr; */
-
-	BUG_ON(1);
-
-/* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
-/* 	rsp_hdr = (struct iscsi_reject_hdr *)&rsp->pdu.bhs; */
-
-/* 	rsp_hdr->opcode = ISCSI_OP_REJECT; */
-/* 	rsp_hdr->ffffffff = ISCSI_RESERVED_TAG; */
-/* 	rsp_hdr->reason = reason; */
-
-/* 	rsp->tio = tio = tio_alloc(1); */
-/* 	addr = page_address(tio->pvec[0]); */
-/* 	clear_page(addr); */
-/* 	memcpy(addr, &req->pdu.bhs, sizeof(struct iscsi_hdr)); */
-/* 	tio->size = rsp->pdu.datasize = sizeof(struct iscsi_hdr); */
-/* 	cmnd_skip_pdu(req); */
-
-/* 	req->pdu.bhs.opcode = ISCSI_OP_PDU_REJECT; */
-}
-
-static void cmnd_set_sn(struct istgt_cmd *cmnd, int set_stat_sn)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	struct iscsi_session *sess = conn->session;
-
-	if (set_stat_sn)
-		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn++);
-	cmnd->pdu.bhs.exp_statsn = cpu_to_be32(sess->exp_cmd_sn);
-	cmnd->pdu.bhs.max_statsn = cpu_to_be32(sess->exp_cmd_sn +
-						sess->max_queued_cmnds);
-}
-
-static void update_stat_sn(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	uint32_t exp_stat_sn;
-
-	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
-	dprintk("%x,%x\n", cmd_opcode(cmnd), exp_stat_sn);
-	if ((int32_t) (exp_stat_sn - conn->exp_stat_sn) > 0 &&
-	    (int32_t) (exp_stat_sn - conn->stat_sn) <= 0) {
-		// free pdu resources
-		cmnd->conn->exp_stat_sn = exp_stat_sn;
-	}
-}
-
-static int check_cmd_sn(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd->conn->session;
-	uint32_t cmd_sn;
-
-	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
-	dprintk("%d(%d)\n", cmd_sn, session->exp_cmd_sn);
-	if ((int32_t) (cmd_sn - session->exp_cmd_sn) >= 0)
-		return 0;
-	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
-	return -ISCSI_REASON_PROTOCOL_ERROR;
-}
-
-static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
-					   uint32_t itt, uint32_t ttt)
-{
-	struct list_head *head;
-	struct istgt_cmd *cmnd;
-
-	head = &session->cmnd_hash[cmnd_hashfn(itt)];
-
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd->pdu.bhs.itt == itt) {
-			if ((ttt != ISCSI_RESERVED_TAG) && (ttt != cmnd->target_task_tag))
-				continue;
-			return cmnd;
-		}
-	}
-
-	return NULL;
-}
-
-static struct istgt_cmd *cmnd_find_hash(struct iscsi_session *session,
-					 uint32_t itt, uint32_t ttt)
-{
-	struct istgt_cmd *cmnd;
-
-	spin_lock(&session->cmnd_hash_lock);
-
-	cmnd = __cmnd_find_hash(session, itt, ttt);
-
-	spin_unlock(&session->cmnd_hash_lock);
-
-	return cmnd;
-}
-
-static int cmnd_insert_hash(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd->conn->session;
-	struct istgt_cmd *tmp;
-	struct list_head *head;
-	int err = 0;
-	uint32_t itt = cmnd->pdu.bhs.itt;
-
-	dprintk("%p:%x\n", cmnd, itt);
-	if (itt == ISCSI_RESERVED_TAG) {
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
-		goto out;
-	}
-
-	head = &session->cmnd_hash[cmnd_hashfn(cmnd->pdu.bhs.itt)];
-
-	spin_lock(&session->cmnd_hash_lock);
-
-	tmp = __cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG);
-	if (!tmp) {
-		list_add_tail(&cmnd->hash_list, head);
-		set_cmd_hashed(cmnd);
-	} else
-		err = -ISCSI_REASON_TASK_IN_PROGRESS;
-
-	spin_unlock(&session->cmnd_hash_lock);
-
-	if (!err) {
-		update_stat_sn(cmnd);
-		err = check_cmd_sn(cmnd);
-	}
-
-out:
-	return err;
-}
-
-static void __cmnd_remove_hash(struct istgt_cmd *cmnd)
-{
-	list_del(&cmnd->hash_list);
-}
-
-static void cmnd_remove_hash(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd->conn->session;
-	struct istgt_cmd *tmp;
-
-	spin_lock(&session->cmnd_hash_lock);
-
-	tmp = __cmnd_find_hash(session, cmnd->pdu.bhs.itt, ISCSI_RESERVED_TAG);
-
-	if (tmp && tmp == cmnd)
-		__cmnd_remove_hash(tmp);
-	else
-		eprintk("%p:%x not found\n", cmnd, cmd_itt(cmnd));
-
-	spin_unlock(&session->cmnd_hash_lock);
-}
-
-static void cmnd_skip_data(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	uint32_t size;
-
-	rsp = get_rsp_cmnd(req);
-	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
-	if (cmd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
-		eprintk("unexpected response command %u\n", cmd_opcode(rsp));
-		return;
-	}
-
-	size = cmnd_write_size(req);
-	if (size) {
-		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-		rsp_hdr->residual_count = cpu_to_be32(size);
-	}
-	size = cmnd_read_size(req);
-	if (size) {
-		if (cmd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
-			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
-			rsp_hdr->bi_residual_count = cpu_to_be32(size);
-		} else {
-			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
-			rsp_hdr->residual_count = cpu_to_be32(size);
-		}
-	}
-	req->pdu.bhs.opcode =
-		(req->pdu.bhs.opcode & ~ISCSI_OPCODE_MASK) | ISCSI_OP_SCSI_REJECT;
-
-	cmnd_skip_pdu(req);
-}
-
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct tgt_cmd *tc,
-			 uint32_t offset, uint32_t size)
-{
-	int idx, i;
-	char *addr;
-	struct scatterlist *sg;
-
-	dprintk("%u,%u\n", offset, size);
-
-	BUG_ON(!tc);
-	BUG_ON(!tc->sg);
-	sg = tc->sg;
-	offset += sg->offset;
-
-	if (!(offset < sg->offset + tc->bufflen) ||
-	    !(offset + size <= sg->offset + tc->bufflen)) {
-		eprintk("%u %u %u %u", offset, size, sg->offset, tc->bufflen);
-		return -EIO;
-	}
-	BUG_ON(!(offset < sg->offset + tc->bufflen));
-	BUG_ON(!(offset + size <= sg->offset + tc->bufflen));
-
-	idx = offset >> PAGE_CACHE_SHIFT;
-	offset &= ~PAGE_CACHE_MASK;
-
-	conn->read_msg.msg_iov = conn->read_iov;
-	conn->read_size = (size + 3) & -4;
-	conn->read_overflow = 0;
-
-	i = 0;
-	while (1) {
-		sg = tc->sg + idx;
-		BUG_ON(!sg);
-		BUG_ON(!sg->page);
-		addr = page_address(sg->page);
-		BUG_ON(!addr);
-
-		conn->read_iov[i].iov_base =  addr + offset;
-		if (offset + size <= PAGE_CACHE_SIZE) {
-			conn->read_iov[i].iov_len = size;
-			conn->read_msg.msg_iovlen = ++i;
-			break;
-		}
-		conn->read_iov[i].iov_len = PAGE_CACHE_SIZE - offset;
-		size -= conn->read_iov[i].iov_len;
-		offset = 0;
-		if (++i >= ISCSI_CONN_IOV_MAX) {
-			conn->read_msg.msg_iovlen = i;
-			conn->read_overflow = size;
-			conn->read_size -= size;
-			break;
-		}
-
-		idx++;
-	}
-
-	return 0;
-}
-
-static void send_r2t(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_r2t_rsp *rsp_hdr;
-	uint32_t length, offset, burst;
-	LIST_HEAD(send);
-
-	length = req->r2t_length;
-	burst = req->conn->session->param.max_burst_length;
-	offset = be32_to_cpu(cmd_hdr(req)->data_length) - length;
-
-	do {
-		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
-		rsp->pdu.bhs.ttt = req->target_task_tag;
-
-		rsp_hdr = (struct iscsi_r2t_rsp *)&rsp->pdu.bhs;
-		rsp_hdr->opcode = ISCSI_OP_R2T;
-		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		memcpy(rsp_hdr->lun, cmd_hdr(req)->lun, 8);
-		rsp_hdr->itt = cmd_hdr(req)->itt;
-		rsp_hdr->r2tsn = cpu_to_be32(req->r2t_sn++);
-		rsp_hdr->data_offset = cpu_to_be32(offset);
-		if (length > burst) {
-			rsp_hdr->data_length = cpu_to_be32(burst);
-			length -= burst;
-			offset += burst;
-		} else {
-			rsp_hdr->data_length = cpu_to_be32(length);
-			length = 0;
-		}
-
-		dprintk("%x %u %u %u %u\n", cmd_itt(req),
-			be32_to_cpu(rsp_hdr->data_length),
-			be32_to_cpu(rsp_hdr->data_offset),
-			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
-
-		list_add_tail(&rsp->list, &send);
-
-		if (++req->outstanding_r2t >= req->conn->session->param.max_outstanding_r2t)
-			break;
-
-	} while (length);
-
-	iscsi_cmnds_init_write(&send);
-}
-
-static void __scsi_cmnd_done(void *data)
-{
-	struct tgt_cmd *tc = (struct tgt_cmd *) data;
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
-	struct iscsi_cmd *req = cmd_hdr(cmnd);
-
-	if (tc->result != SAM_STAT_GOOD) {
-		struct istgt_cmd *rsp;
-
-		rsp = do_create_sense_rsp(cmnd);
-		iscsi_cmnd_init_write(rsp);
-		return;
-	}
-
-	switch (req->cdb[0]) {
-	case INQUIRY:
-	case REPORT_LUNS:
-	case READ_CAPACITY:
-	case MODE_SENSE:
-	case REQUEST_SENSE:
-	case SERVICE_ACTION_IN:
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		do_send_data_rsp(cmnd);
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	case START_STOP:
-	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
-	case VERIFY:
-	case VERIFY_16:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-		send_scsi_rsp(cmnd);
-		break;
-	default:
-		BUG_ON(1);
-		break;
-	}
-}
-
-/* TODO : merge this with nthread. */
-static int scsi_cmnd_done(struct tgt_cmd *tc)
-{
-	int err;
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
-
-	INIT_WORK(&cmnd->work, __scsi_cmnd_done, tc);
-	err = schedule_work(&cmnd->work);
-	BUG_ON(!err);
-
-	return TGT_CMD_XMIT_OK;
-}
-
-static void tgt_scsi_cmd_create(struct istgt_cmd *req)
-{
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-	struct iscsi_conn *conn = req->conn;
-	enum dma_data_direction data_dir;
-	int tags = MSG_SIMPLE_TAG;;
-
-	/*
-	 * handle bidi later
-	 */
-	if (req_hdr->flags & ISCSI_FLAG_CMD_WRITE)
-		data_dir = DMA_TO_DEVICE;
-	else if (req_hdr->flags & ISCSI_FLAG_CMD_READ)
-		data_dir = DMA_FROM_DEVICE;
-	else
-		data_dir = DMA_NONE;
-
-	switch (req->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) {
-	case ISCSI_ATTR_UNTAGGED:
-	case ISCSI_ATTR_SIMPLE:
-		tags = MSG_SIMPLE_TAG;
-		break;
-	case ISCSI_ATTR_ORDERED:
-		tags = MSG_ORDERED_TAG;
-		break;
-	case ISCSI_ATTR_HEAD_OF_QUEUE:
-		tags = MSG_HEAD_TAG;
-		break;
-	case ISCSI_ATTR_ACA:
-		break;
-	}
-
-	req->tc = tgt_cmd_create(conn->session->ts, req, req_hdr->cdb,
-				 be32_to_cpu(req_hdr->data_length),
-				 data_dir, req_hdr->lun,
-				 sizeof(req_hdr->lun),
-				 tags);
-	BUG_ON(!req->tc);
-
-	if (data_dir == DMA_TO_DEVICE && be32_to_cpu(req_hdr->data_length)) {
-		switch (req_hdr->cdb[0]) {
-		case WRITE_6:
-		case WRITE_10:
-		case WRITE_16:
-		case WRITE_VERIFY:
-			break;
-		default:
-			eprintk("%x\n", req_hdr->cdb[0]);
-			break;
-		}
-	}
-}
-
-static void scsi_cmnd_exec(struct istgt_cmd *cmnd)
-{
-	struct tgt_cmd *cmd = cmnd->tc;
-
-	if (cmnd->r2t_length) {
-		if (!cmnd->is_unsolicited_data)
-			send_r2t(cmnd);
-	} else {
-		set_cmd_waitio(cmnd);
-		if (cmnd->tc)
-			cmd->done(cmd);
-		else
-			tgt_scsi_cmd_create(cmnd);
-	}
-}
-
-static int noop_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	uint32_t size, tmp;
-	int i = 0, err = 0;
-
-	if (cmd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		/*
-		 * We don't request a NOP-Out by sending a NOP-In.
-		 * See 10.18.2 in the draft 20.
-		 */
-		eprintk("initiator bug %x\n", cmd_itt(cmnd));
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
-		goto out;
-	}
-
-	if (cmd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (!(cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE))
-			eprintk("%s\n","initiator bug!");
-		update_stat_sn(cmnd);
-		err = check_cmd_sn(cmnd);
-		goto out;
-	} else if ((err = cmnd_insert_hash(cmnd)) < 0) {
-		eprintk("ignore this request %x\n", cmd_itt(cmnd));
-		goto out;
-	}
-
-	if ((size = cmnd->pdu.datasize)) {
-		size = (size + 3) & -4;
-		conn->read_msg.msg_iov = conn->read_iov;
-		if (cmnd->pdu.bhs.itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-/* 			struct tio *tio; */
-			int pg_cnt = get_pgcnt(size, 0);
-
-			BUG_ON(pg_cnt >= ISCSI_CONN_IOV_MAX);
-			BUG_ON(1);
-/* 			cmnd->tio = tio = tio_alloc(pg_cnt); */
-/* 			tio_set(tio, size, 0); */
-
-/* 			for (i = 0; i < pg_cnt; i++) { */
-/* 				conn->read_iov[i].iov_base */
-/* 					= page_address(tio->pvec[i]); */
-/* 				tmp = min_t(u32, size, PAGE_CACHE_SIZE); */
-/* 				conn->read_iov[i].iov_len = tmp; */
-/* 				conn->read_size += tmp; */
-/* 				size -= tmp; */
-/* 			} */
-		} else {
-			for (i = 0; i < ISCSI_CONN_IOV_MAX; i++) {
-				conn->read_iov[i].iov_base = dummy_data;
-				tmp = min_t(uint32_t, size, sizeof(dummy_data));
-				conn->read_iov[i].iov_len = tmp;
-				conn->read_size += tmp;
-				size -= tmp;
-			}
-		}
-		BUG_ON(size);
-		conn->read_overflow = size;
-		conn->read_msg.msg_iovlen = i;
-	}
-
-out:
-	return err;
-}
-
-static uint32_t get_next_ttt(struct iscsi_session *session)
-{
-	uint32_t ttt;
-
-	if (session->next_ttt == ISCSI_RESERVED_TAG)
-		session->next_ttt++;
-	ttt = session->next_ttt++;
-
-	return cpu_to_be32(ttt);
-}
-
-static void scsi_cmnd_start(struct iscsi_conn *conn, struct istgt_cmd *req)
-{
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-
-	dprintk("scsi command: %02x\n", req_hdr->cdb[0]);
-
-	switch (req_hdr->cdb[0]) {
-	case SERVICE_ACTION_IN:
-		if ((req_hdr->cdb[1] & 0x1f) != 0x10)
-			goto error;
-
-	case INQUIRY:
-	case REPORT_LUNS:
-	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
-	case VERIFY:
-	case VERIFY_16:
-	case START_STOP:
-	case READ_CAPACITY:
-	case MODE_SENSE:
-	case REQUEST_SENSE:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-	case READ_6:
-	case READ_10:
-	case READ_16:
-	{
-		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
-		      req->pdu.datasize) {
-			/* unexpected unsolicited data */
-			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
-			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
-			cmnd_skip_data(req);
-		}
-		break;
-	}
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	{
-		struct iscsi_sess_param *param = &conn->session->param;
-
-		/*
-		 * We don't know this command arrives in order,
-		 * however we need to allocate buffer for immediate
-		 * and unsolicited data. tgt will not start to perform
-		 * this command until we call cmd->done so we don't
-		 * need to worry about the order of the command.
-		 */
-		tgt_scsi_cmd_create(req);
-		wait_for_completion(&req->event);
-
-		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
-		req->is_unsolicited_data = !(req_hdr->flags &
-						ISCSI_FLAG_CMD_FINAL);
-		req->target_task_tag = get_next_ttt(conn->session);
-
-		if (!param->immediate_data && req->pdu.datasize)
-			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
-
-		if (param->initial_r2t &&
-		    !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL))
-			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
-
-		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
-			eprintk("Verification is ignored %x\n", cmd_itt(req));
-
-		if (req->pdu.datasize) {
-			if (cmnd_recv_pdu(conn, req->tc, 0, req->pdu.datasize) < 0)
-				BUG_ON(1);
-		}
-		break;
-	}
-	error:
-	default:
-		eprintk("Unsupported %x\n", req_hdr->cdb[0]);
-		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
-		cmnd_skip_data(req);
-		break;
-	}
-
-	return;
-}
-
-static void data_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
-	struct istgt_cmd *scsi_cmnd = NULL;
-	uint32_t offset = be32_to_cpu(req->offset);
-
-	update_stat_sn(cmnd);
-
-	cmnd->req = scsi_cmnd = cmnd_find_hash(conn->session, req->itt, req->ttt);
-	if (!scsi_cmnd) {
-		eprintk("unable to find scsi task %x %x\n",
-			cmd_itt(cmnd), cmd_ttt(cmnd));
-		goto skip_data;
-	}
-
-	if (scsi_cmnd->r2t_length < cmnd->pdu.datasize) {
-		eprintk("invalid data len %x %u %u\n",
-			cmd_itt(scsi_cmnd), cmnd->pdu.datasize, scsi_cmnd->r2t_length);
-		goto skip_data;
-	}
-
-	if (scsi_cmnd->r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
-		eprintk("%x %u %u %u\n", cmd_itt(scsi_cmnd), scsi_cmnd->r2t_length,
-			offset,	cmnd_write_size(scsi_cmnd));
-		goto skip_data;
-	}
-
-	scsi_cmnd->r2t_length -= cmnd->pdu.datasize;
-
-	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		/* unsolicited burst data */
-		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_FINAL) {
-			eprintk("unexpected data from %x %x\n",
-				cmd_itt(cmnd), cmd_ttt(cmnd));
-			goto skip_data;
-		}
-	}
-
-	dprintk("%u %p %p %u %u\n", req->ttt, cmnd, scsi_cmnd,
-		offset, cmnd->pdu.datasize);
-
-	if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, cmnd->pdu.datasize) < 0)
-		goto skip_data;
-	return;
-
-skip_data:
-	cmnd->pdu.bhs.opcode = ISCSI_OP_DATA_REJECT;
-	cmnd_skip_pdu(cmnd);
-	return;
-}
-
-static void data_out_end(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
-	struct istgt_cmd *scsi_cmnd;
-	uint32_t offset;
-
-	BUG_ON(!cmnd);
-	scsi_cmnd = cmnd->req;
-	BUG_ON(!scsi_cmnd);
-
-	if (conn->read_overflow) {
-		eprintk("%x %u\n", cmd_itt(cmnd), conn->read_overflow);
-		offset = be32_to_cpu(req->offset);
-		offset += cmnd->pdu.datasize - conn->read_overflow;
-		if (cmnd_recv_pdu(conn, scsi_cmnd->tc, offset, conn->read_overflow) < 0)
-			BUG_ON(1);
-		return;
-	}
-
-	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req->flags & ISCSI_FLAG_CMD_FINAL) {
-			scsi_cmnd->is_unsolicited_data = 0;
-			if (!cmd_pending(scsi_cmnd))
-				scsi_cmnd_exec(scsi_cmnd);
-		}
-	} else {
-		/* TODO : proper error handling */
-		if (!(req->flags & ISCSI_FLAG_CMD_FINAL) &&
-		    scsi_cmnd->r2t_length == 0)
-			eprintk("initiator error %x\n", cmd_itt(scsi_cmnd));
-
-		if (!(req->flags & ISCSI_FLAG_CMD_FINAL))
-			goto out;
-
-		scsi_cmnd->outstanding_r2t--;
-
-		if (scsi_cmnd->r2t_length == 0)
-			BUG_ON(!list_empty(&scsi_cmnd->pdu_list));
-
-		scsi_cmnd_exec(scsi_cmnd);
-	}
-
-out:
-	iscsi_cmnd_remove(cmnd);
-	return;
-}
-
-/* static int __cmnd_abort(struct istgt_cmd *cmnd) */
-/* { */
-/* 	if (!cmnd_waitio(cmnd)) { */
-/* 		cmnd_release(cmnd, 1); */
-/* 		return 0; */
-/* 	} else */
-/* 		return -ISCSI_RESPONSE_UNKNOWN_TASK; */
-/* } */
-
-/* static int cmnd_abort(struct iscsi_session *session, u32 itt) */
-/* { */
-/* 	struct istgt_cmd *cmnd; */
-/* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
-
-/* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
-/* 		eprintk("%x %x %x %u %u %u %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
-/* 			cmnd->r2t_length, cmnd_scsicode(cmnd), */
-/* 			cmnd_write_size(cmnd), cmnd->is_unsolicited_data, */
-/* 			cmnd->outstanding_r2t); */
-/* 		err = __cmnd_abort(cmnd); */
-/* 	} */
-
-/* 	return err; */
-/* } */
-
-/* static int target_reset(struct istgt_cmd *req, u32 lun, int all) */
-/* { */
-/* 	struct iscsi_target *target = req->conn->session->target; */
-/* 	struct iscsi_session *session; */
-/* 	struct iscsi_conn *conn; */
-/* 	struct istgt_cmd *cmnd, *tmp; */
-
-/* 	list_for_each_entry(session, &target->session_list, list) { */
-/* 		list_for_each_entry(conn, &session->conn_list, list) { */
-/* 			list_for_each_entry_safe(cmnd, tmp, &conn->pdu_list, conn_list) { */
-/* 				if (cmnd == req) */
-/* 					continue; */
-
-/* 				if (all) */
-/* 					__cmnd_abort(cmnd); */
-/* 				else if (translate_lun(cmd_hdr(cmnd)->lun) == lun) */
-/* 					__cmnd_abort(cmnd); */
-/* 			} */
-/* 		} */
-/* 	} */
-
-/* 	return 0; */
-/* } */
-
-/* static void task_set_abort(struct istgt_cmd *req) */
-/* { */
-/* 	struct iscsi_session *session = req->conn->session; */
-/* 	struct iscsi_conn *conn; */
-/* 	struct istgt_cmd *cmnd, *tmp; */
-
-/* 	list_for_each_entry(conn, &session->conn_list, list) { */
-/* 		list_for_each_entry_safe(cmnd, tmp, &conn->pdu_list, conn_list) { */
-/* 			if (cmnd != req) */
-/* 				__cmnd_abort(cmnd); */
-/* 		} */
-/* 	} */
-/* } */
-
-static void execute_task_management(struct istgt_cmd *req)
-{
-/* 	struct iscsi_conn *conn = req->conn; */
-/* 	struct iscsi_target *target = conn->session->target; */
-	struct istgt_cmd *rsp;
-	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
-	struct iscsi_tm_rsp *rsp_hdr;
-	int function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_tm_rsp *)&rsp->pdu.bhs;
-
-	rsp_hdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
-	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr->itt = req_hdr->itt;
-/* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
-	rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
-
-	eprintk("%x %d %x\n", cmd_itt(req), function, req_hdr->rtt);
-
-/* 	switch (function) { */
-/* 	case ISCSI_FUNCTION_ABORT_TASK: */
-/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
-/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
-/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
-/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
-/* 		lun = translate_lun(req_hdr->lun); */
-/* 		if (!volume_lookup(target, lun)) { */
-/* 			rsp_hdr->response = ISCSI_RESPONSE_UNKNOWN_LUN; */
-/* 			goto out; */
-/* 		} */
-/* 	} */
-
-/* 	switch (function) { */
-/* 	case ISCSI_FUNCTION_ABORT_TASK: */
-/* 		if ((err = cmnd_abort(conn->session, req_hdr->rtt)) < 0) */
-/* 			rsp_hdr->response = -err; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
-/* 		task_set_abort(req); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
-/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
-/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
-/* 		target_reset(req, translate_lun(req_hdr->lun), 0); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_TARGET_WARM_RESET: */
-/* 	case ISCSI_FUNCTION_TARGET_COLD_RESET: */
-/* 		target_reset(req, 0, 1); */
-/* 		if (function == ISCSI_FUNCTION_TARGET_COLD_RESET) */
-/* 			set_cmnd_close(rsp); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_TASK_REASSIGN: */
-/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	default: */
-/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_REJECTED; */
-/* 		break; */
-/* 	} */
-/* out: */
-	iscsi_cmnd_init_write(rsp);
-}
-
-static void noop_out_exec(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_nopin *rsp_hdr;
-
-	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-		rsp_hdr = (struct iscsi_nopin *)&rsp->pdu.bhs;
-		rsp_hdr->opcode = ISCSI_OP_NOOP_IN;
-		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		rsp_hdr->itt = req->pdu.bhs.itt;
-		rsp_hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-
-/* 		if (req->pdu.datasize) */
-/* 			assert(req->tio); */
-/* 		else */
-/* 			assert(!req->tio); */
-
-/* 		if (req->tio) { */
-/* 			tio_get(req->tio); */
-/* 			rsp->tio = req->tio; */
-/* 		} */
-
-		BUG_ON(get_pgcnt(req->pdu.datasize, 0) >= ISCSI_CONN_IOV_MAX);
-		rsp->pdu.datasize = req->pdu.datasize;
-		iscsi_cmnd_init_write(rsp);
-	} else
-		iscsi_cmnd_remove(req);
-}
-
-static void logout_exec(struct istgt_cmd *req)
-{
-	struct iscsi_logout *req_hdr;
-	struct istgt_cmd *rsp;
-	struct iscsi_logout_rsp *rsp_hdr;
-
-	req_hdr = (struct iscsi_logout *)&req->pdu.bhs;
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_logout_rsp *)&rsp->pdu.bhs;
-	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr->itt = req_hdr->itt;
-	set_cmd_close(rsp);
-	iscsi_cmnd_init_write(rsp);
-}
-
-static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
-{
-	dprintk("%p,%x,%u\n", cmnd, cmd_opcode(cmnd),
-		cmnd->pdu.bhs.statsn);
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_OUT:
-		noop_out_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD:
-		scsi_cmnd_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC:
-		execute_task_management(cmnd);
-		break;
-	case ISCSI_OP_LOGOUT:
-		logout_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_REJECT:
-		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-		break;
-	default:
-		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
-		break;
-	}
-}
-
-static void __cmnd_send_pdu(struct iscsi_conn *conn, struct scatterlist *sg,
-			    uint32_t offset, uint32_t size)
-{
-/* 	dprintk(D_GENERIC, "%p %u,%u\n", tio, offset, size); */
-	offset += sg->offset;
-
-/* 	assert(offset <= sg->offset + tio->size); */
-/* 	assert(offset + size <= tio->offset + tio->size); */
-
-	conn->write_sg = sg;
-	conn->write_offset = offset;
-	conn->write_size += size;
-}
-
-static void cmnd_send_pdu(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	uint32_t size;
-
-	if (!cmnd->pdu.datasize)
-		return;
-
-	size = (cmnd->pdu.datasize + 3) & -4;
-	BUG_ON(!cmnd->sg);
-	__cmnd_send_pdu(conn, cmnd->sg, 0, size);
-}
-
-static void set_cork(struct socket *sock, int on)
-{
-	int opt = on;
-	mm_segment_t oldfs;
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	sock->ops->setsockopt(sock, SOL_TCP, TCP_CORK, (void *)&opt, sizeof(opt));
-	set_fs(oldfs);
-}
-
-void cmnd_release(struct istgt_cmd *cmnd, int force)
-{
-	struct istgt_cmd *req, *rsp;
-	int is_last = 0;
-
-	if (!cmnd)
-		return;
-
-	req = cmnd->req;
-	is_last = cmd_final(cmnd);
-
-	if (force) {
-		while (!list_empty(&cmnd->pdu_list)) {
-			rsp = list_entry(cmnd->pdu_list.next, struct istgt_cmd, pdu_list);
-			list_del_init(&rsp->list);
-			list_del(&rsp->pdu_list);
-			iscsi_cmnd_remove(rsp);
-		}
-		list_del_init(&cmnd->list);
-	}
-
-	if (cmd_hashed(cmnd))
-		cmnd_remove_hash(cmnd);
-
-	list_del_init(&cmnd->pdu_list);
-	iscsi_cmnd_remove(cmnd);
-
-	if (is_last) {
-		BUG_ON(force);
-		BUG_ON(!req);
-		cmnd_release(req, 0);
-	}
-
-	return;
-}
-
-void cmnd_tx_start(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	struct iovec *iop;
-
-	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
-	BUG_ON(!cmnd);
-	iscsi_cmnd_set_length(&cmnd->pdu);
-
-	set_cork(conn->sock, 1);
-
-	conn->write_iop = iop = conn->write_iov;
-	iop->iov_base = &cmnd->pdu.bhs;
-	iop->iov_len = sizeof(cmnd->pdu.bhs);
-	iop++;
-	conn->write_size = sizeof(cmnd->pdu.bhs);
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_IN:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD_RSP:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_TEXT_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_SCSI_DATA_IN:
-	{
-		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&cmnd->pdu.bhs;
-		uint32_t offset;
-
-		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
-		offset = rsp->offset;
-		rsp->offset = cpu_to_be32(offset);
-		BUG_ON(!cmnd->sg);
-		__cmnd_send_pdu(conn, cmnd->sg, offset, cmnd->pdu.datasize);
-		break;
-	}
-	case ISCSI_OP_LOGOUT_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_R2T:
-		cmnd_set_sn(cmnd, 0);
-		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn);
-		break;
-	case ISCSI_OP_ASYNC_EVENT:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_REJECT:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	default:
-		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
-		break;
-	}
-
-	iop->iov_len = 0;
-	// move this?
-	conn->write_size = (conn->write_size + 3) & -4;
-}
-
-void cmnd_tx_end(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-
-	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_SCSI_CMD_RSP:
-	case ISCSI_OP_SCSI_TMFUNC_RSP:
-	case ISCSI_OP_TEXT_RSP:
-	case ISCSI_OP_R2T:
-	case ISCSI_OP_ASYNC_EVENT:
-	case ISCSI_OP_REJECT:
-	case ISCSI_OP_SCSI_DATA_IN:
-	case ISCSI_OP_LOGOUT_RSP:
-		break;
-	default:
-		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
-		BUG_ON(1);
-		break;
-	}
-
-	if (cmd_close(cmnd))
-		conn_close(conn);
-
-	list_del_init(&cmnd->list);
-	set_cork(cmnd->conn->sock, 0);
-}
-
-/**
- * Push the command for execution.
- * This functions reorders the commands.
- * Called from the read thread.
- *
- * iscsi_session_push_cmnd - 
- * @cmnd: ptr to command
- */
-
-static void iscsi_session_push_cmnd(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd->conn->session;
-	struct list_head *entry;
-	uint32_t cmd_sn;
-
-	dprintk("%p:%x %u,%u\n",
-		cmnd, cmd_opcode(cmnd), cmnd->pdu.bhs.statsn,
-		session->exp_cmd_sn);
-
-	if (cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE) {
-		iscsi_cmnd_exec(cmnd);
-		return;
-	}
-
-	cmd_sn = cmnd->pdu.bhs.statsn;
-	if (cmd_sn == session->exp_cmd_sn) {
-		while (1) {
-			session->exp_cmd_sn = ++cmd_sn;
-			iscsi_cmnd_exec(cmnd);
-
-			if (list_empty(&session->pending_list))
-				break;
-			cmnd = list_entry(session->pending_list.next, struct istgt_cmd, list);
-			if (cmnd->pdu.bhs.statsn != cmd_sn)
-				break;
-/* 			eprintk("find out-of-order %x %u %u\n", */
-/* 				cmd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
-			list_del_init(&cmnd->list);
-			clear_cmd_pending(cmnd);
-		}
-	} else {
-/* 		eprintk("out-of-order %x %u %u\n", */
-/* 			cmd_itt(cmnd), cmd_sn, session->exp_cmd_sn); */
-
-		set_cmd_pending(cmnd);
-		if (before(cmd_sn, session->exp_cmd_sn)) /* close the conn */
-			eprintk("unexpected cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
-
-		if (after(cmd_sn, session->exp_cmd_sn + session->max_queued_cmnds))
-			eprintk("too large cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
-
-		list_for_each(entry, &session->pending_list) {
-			struct istgt_cmd *tmp = list_entry(entry, struct istgt_cmd, list);
-			if (before(cmd_sn, tmp->pdu.bhs.statsn))
-				break;
-		}
-
-		BUG_ON(!list_empty(&cmnd->list));
-
-		list_add_tail(&cmnd->list, entry);
-	}
-}
-
-static int check_segment_length(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	struct iscsi_sess_param *param = &conn->session->param;
-
-	if (cmnd->pdu.datasize > param->max_recv_data_length) {
-		eprintk("too lond data %x %u %u\n", cmd_itt(cmnd),
-			cmnd->pdu.datasize, param->max_recv_data_length);
-
-		if (get_pgcnt(cmnd->pdu.datasize, 0) > ISCSI_CONN_IOV_MAX) {
-			conn_close(conn);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-void cmnd_rx_start(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-	int err = 0;
-
-	if (check_segment_length(cmnd) < 0)
-		return;
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_OUT:
-		err = noop_out_start(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD:
-		if (!(err = cmnd_insert_hash(cmnd)))
-			scsi_cmnd_start(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC:
-		err = cmnd_insert_hash(cmnd);
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		data_out_start(conn, cmnd);
-		break;
-	case ISCSI_OP_LOGOUT:
-		err = cmnd_insert_hash(cmnd);
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
-		break;
-	default:
-		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
-		break;
-	}
-
-	if (err < 0) {
-		eprintk("%x %x %d\n", cmd_opcode(cmnd), cmd_itt(cmnd), err);
-		iscsi_cmnd_reject(cmnd, -err);
-	}
-}
-
-void cmnd_rx_end(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd->conn;
-
-	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_SCSI_REJECT:
-	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TMFUNC:
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_LOGOUT:
-		iscsi_session_push_cmnd(cmnd);
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		data_out_end(conn, cmnd);
-		break;
-	case ISCSI_OP_SNACK:
-		break;
-	case ISCSI_OP_PDU_REJECT:
-		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
-		break;
-	case ISCSI_OP_DATA_REJECT:
-		cmnd_release(cmnd, 0);
-		break;
-	default:
-		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
-		BUG();
-		break;
-	}
-}
-
-static int buffer_ready(struct tgt_cmd *tc)
-{
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) tc->private;
-
-	complete(&cmnd->event);
-
-	return 0;
-}
-
-
-static struct iscsi_sess_param default_session_param = {
-	.initial_r2t = 1,
-	.immediate_data = 1,
-	.max_connections = 1,
-	.max_recv_data_length = 8192,
-	.max_xmit_data_length = 8192,
-	.max_burst_length = 262144,
-	.first_burst_length = 65536,
-	.default_wait_time = 2,
-	.default_retain_time = 20,
-	.max_outstanding_r2t = 1,
-	.data_pdu_inorder = 1,
-	.data_sequence_inorder = 1,
-	.error_recovery_level = 0,
-	.header_digest = DIGEST_NONE,
-	.data_digest = DIGEST_NONE,
-	.ofmarker = 0,
-	.ifmarker = 0,
-	.ofmarkint = 2048,
-	.ifmarkint = 2048,
-};
-
-static struct iscsi_trgt_param default_target_param = {
-	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
-};
-
-static int istgt_target_create(struct tgt_target *tt)
-{
-	int err = -EINVAL;
-	struct iscsi_target *target = tt->tt_data;
-
-	target->tt = tt;
-
-	memcpy(&target->sess_param, &default_session_param, sizeof(default_session_param));
-	memcpy(&target->trgt_param, &default_target_param, sizeof(default_target_param));
-
-	init_MUTEX(&target->target_sem);
-	INIT_LIST_HEAD(&target->session_list);
-
-	nthread_init(target);
-	err = nthread_start(target);
-
-	return err;
-}
-
-static void istgt_target_destroy(struct tgt_target *tt)
-{
-	struct iscsi_target *target =
-		(struct iscsi_target *) tt->tt_data;
-
-	down(&target->target_sem);
-
-	/* kernel may crash until tgt supports lifetime management. */
-	BUG_ON(!list_empty(&target->session_list));
-
-	up(&target->target_sem);
-
-	nthread_stop(target);
-}
-
-static struct tgt_target_template istgt_template = {
-	.name = THIS_NAME,
-	.module = THIS_MODULE,
-	.protocol = "scsi",
-	.subprotocol = "iscsi",
-	.target_create = istgt_target_create,
-	.target_destroy = istgt_target_destroy,
-	.msg_recv = iet_msg_recv,
-	.transfer_response = scsi_cmnd_done,
-	.transfer_write_data = buffer_ready,
-	.priv_data_size = sizeof(struct iscsi_target),
-};
-
-static void istgt_exit(void)
-{
-	kmem_cache_destroy(istgt_cmd_cache);
-	tgt_target_template_unregister(&istgt_template);
-}
-
-static int istgt_init(void)
-{
-	int err;
-
-	printk("iSCSI Target Software for Linux Target Framework %s\n",
-	       VERSION_STRING);
-
-	istgt_cmd_cache = kmem_cache_create("istgt_cmd",
-					    sizeof(struct istgt_cmd),
-					    0, 0, NULL, NULL);
-	if (!istgt_cmd_cache)
-		return -ENOMEM;
-
-	err = tgt_target_template_register(&istgt_template);
-	if (err < 0)
-		goto free_cmd_cache;
-
-	return 0;
-
-free_cmd_cache:
-	kmem_cache_destroy(istgt_cmd_cache);
-
-	return err;
-}
-
-module_init(istgt_init);
-module_exit(istgt_exit);
-
-MODULE_LICENSE("GPL");

Modified: branches/use-scsi-ml/istgt/kernel/iscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi.h	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/iscsi.h	2006-01-27 22:28:16 UTC (rev 236)
@@ -62,23 +62,11 @@
 
 struct istgt_cmd;
 
-struct iscsi_target {
-	struct iscsi_sess_param sess_param;
-	struct iscsi_trgt_param trgt_param;
-
-	struct list_head session_list;
-	struct network_thread_info nthread_info;
-	struct semaphore target_sem;
-
-	struct tgt_target *tt;
-};
-
 #define IET_HASH_ORDER		8
 #define	cmnd_hashfn(itt)	hash_long((itt), IET_HASH_ORDER)
 
 struct iscsi_session {
 	struct list_head list;
-	struct iscsi_target *target;
 
 	uint64_t sid;
 
@@ -96,7 +84,13 @@
 
 	uint32_t next_ttt;
 
-	struct tgt_session *ts;
+	struct iscsi_trgt_param trgt_param;
+
+	struct list_head session_list;
+	struct network_thread_info nthread_info;
+	struct semaphore target_sem;
+
+	struct Scsi_Host *shost;
 };
 
 enum connection_state_bit {
@@ -106,9 +100,15 @@
 
 #define ISCSI_CONN_IOV_MAX	(((256 << 10) >> PAGE_SHIFT) + 1)
 
+struct iscsi_cls_session;
+struct iscsi_cls_conn;
+struct completion;
+
 struct iscsi_conn {
 	struct list_head list;			/* list entry in session list */
 	struct iscsi_session *session;		/* owning session */
+	struct iscsi_cls_conn *cls_conn;
+	struct completion *free_done;
 
 	uint16_t cid;
 	unsigned long state;
@@ -190,7 +190,9 @@
 	struct iscsi_sense_data sense;
 
 	struct istgt_cmd *req;
-	struct tgt_cmd *tc;
+
+	struct scsi_cmnd *scmd;
+	void (*done)(struct scsi_cmnd *);
 };
 
 #define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD
@@ -207,30 +209,21 @@
 extern void cmnd_release(struct istgt_cmd *, int);
 
 /* conn.c */
-extern int conn_add(struct iscsi_session *, struct conn_info *);
-extern int conn_del(struct iscsi_session *, struct conn_info *);
+extern struct iscsi_cls_conn *istgt_conn_create(struct iscsi_cls_session *,
+						uint32_t cid);
+extern void istgt_conn_destroy(struct iscsi_cls_conn *);
+extern int istgt_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
+			   uint32_t, int);
+extern int istgt_conn_start(struct iscsi_cls_conn *);
 extern int conn_free(struct iscsi_conn *);
-extern void conn_close(struct iscsi_conn *);
+extern int conn_close(struct iscsi_conn *conn);
 
 /* nthread.c */
-extern int nthread_init(struct iscsi_target *);
-extern int nthread_start(struct iscsi_target *);
-extern int nthread_stop(struct iscsi_target *);
-extern void nthread_wakeup(struct iscsi_target *);
+extern int nthread_init(struct iscsi_session *);
+extern int nthread_start(struct iscsi_session *);
+extern int nthread_stop(struct iscsi_session *);
+extern void nthread_wakeup(struct iscsi_session *);
 
-/* config.c */
-extern int iet_msg_recv(struct tgt_target *, uint32_t, void *);
-extern int event_send(struct tgt_target *tgt, uint64_t sid,
-		      uint32_t cid, uint32_t state);
-
-/* session.c */
-extern struct iscsi_session *session_lookup(struct iscsi_target *, uint64_t);
-extern int session_add(struct iscsi_target *, struct session_info *);
-extern int session_del(struct iscsi_target *, uint64_t);
-
-/* params.c */
-extern int iscsi_param_set(struct iscsi_target *, struct iscsi_param_info *, int);
-
 #define get_pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT)
 
 static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)

Modified: branches/use-scsi-ml/istgt/kernel/nthread.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/nthread.c	2006-01-27 22:16:32 UTC (rev 235)
+++ branches/use-scsi-ml/istgt/kernel/nthread.c	2006-01-27 22:28:16 UTC (rev 236)
@@ -20,9 +20,9 @@
 	D_DATA_READY,
 };
 
-void nthread_wakeup(struct iscsi_target *target)
+void nthread_wakeup(struct iscsi_session *session)
 {
-	struct network_thread_info *info = &target->nthread_info;
+	struct network_thread_info *info = &session->nthread_info;
 
 	spin_lock_bh(&info->nthread_lock);
 	set_bit(D_DATA_READY, &info->flags);
@@ -547,7 +547,6 @@
 
 static void process_io(struct iscsi_conn *conn)
 {
-	struct iscsi_target *target = conn->session->target;
 	int res, wakeup = 0;
 
 	res = recv(conn);
@@ -567,7 +566,7 @@
 
 out:
 	if (wakeup)
-		nthread_wakeup(target);
+		nthread_wakeup(conn->session);
 
 	return;
 }
@@ -580,8 +579,8 @@
 	conn->sock->ops->shutdown(conn->sock, 2);
 
 	write_lock(&conn->sock->sk->sk_callback_lock);
-	conn->sock->sk->sk_state_change = session->target->nthread_info.old_state_change;
-	conn->sock->sk->sk_data_ready = session->target->nthread_info.old_data_ready;
+	conn->sock->sk->sk_state_change = session->nthread_info.old_state_change;
+	conn->sock->sk->sk_data_ready = session->nthread_info.old_data_ready;
 	write_unlock(&conn->sock->sk->sk_callback_lock);
 
 	fput(conn->file);
@@ -605,20 +604,14 @@
 		BUG_ON(1);
 	}
 
-	eprintk("%d %" PRIu64 " %u\n",
-		session->target->tt->tid, session->sid, conn->cid);
-
-	event_send(session->target->tt, session->sid, conn->cid, E_CONN_CLOSE);
+	eprintk("%llu %d\n", session->sid, conn->cid);
 	conn_free(conn);
-
-	if (list_empty(&session->conn_list))
-		session_del(session->target, session->sid);
 }
 
 static int istd(void *arg)
 {
-	struct iscsi_target *target = arg;
-	struct network_thread_info *info = &target->nthread_info;
+	struct iscsi_session *session = arg;
+	struct network_thread_info *info = &session->nthread_info;
 	struct iscsi_conn *conn, *tmp;
 
 	__set_current_state(TASK_RUNNING);
@@ -635,23 +628,23 @@
 		clear_bit(D_DATA_READY, &info->flags);
 		spin_unlock_bh(&info->nthread_lock);
 
-		down(&target->target_sem);
+		down(&session->target_sem);
 		list_for_each_entry_safe(conn, tmp, &info->active_conns, poll_list) {
 			if (test_bit(CONN_ACTIVE, &conn->state))
 				process_io(conn);
 			else
 				close_conn(conn);
 		}
-		up(&target->target_sem);
+		up(&session->target_sem);
 
 	} while (!kthread_should_stop());
 
 	return 0;
 }
 
-int nthread_init(struct iscsi_target *target)
+int nthread_init(struct iscsi_session *session)
 {
-	struct network_thread_info *info = &target->nthread_info;
+	struct network_thread_info *info = &session->nthread_info;
 
 	info->flags = 0;
 	info->task = NULL;
@@ -666,18 +659,18 @@
 	return 0;
 }
 
-int nthread_start(struct iscsi_target *target)
+int nthread_start(struct iscsi_session *session)
 {
 	int err = 0;
-	struct network_thread_info *info = &target->nthread_info;
+	struct network_thread_info *info = &session->nthread_info;
 	struct task_struct *task;
 
 	if (info->task) {
-		eprintk("Target (%u) already runs\n", target->tt->tid);
+		eprintk("Target (%llu) already runs\n", session->sid);
 		return -EALREADY;
 	}
 
-	task = kthread_run(istd, target, "istd%d", target->tt->tid);
+	task = kthread_run(istd, session, "istd%llu", session->sid);
 
 	if (IS_ERR(task))
 		err = PTR_ERR(task);
@@ -687,10 +680,10 @@
 	return err;
 }
 
-int nthread_stop(struct iscsi_target *target)
+int nthread_stop(struct iscsi_session *session)
 {
 	int err;
-	struct network_thread_info *info = &target->nthread_info;
+	struct network_thread_info *info = &session->nthread_info;
 
 	if (!info->task)
 		return -ESRCH;



From mnc at berlios.de  Sat Jan 28 00:56:12 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 00:56:12 +0100
Subject: [Stgt-svn] r237 - branches/use-scsi-ml/kernel
Message-ID: <200601272356.k0RNuCNr026525@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 00:56:10 +0100 (Sat, 28 Jan 2006)
New Revision: 237

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
add some comments and cmd->offset for multi-transfer requests

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-27 22:28:16 UTC (rev 236)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-27 23:56:10 UTC (rev 237)
@@ -269,6 +269,7 @@
 			bio_list_add(&cmd->xfer_list, bio);
 	}
 
+	cmd->offset = 0;
 	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
 	if (err)
 		goto unmap_bios;
@@ -307,6 +308,7 @@
 
 	cmd->bufflen -= cmd->request_bufflen;
 	cmd->buffer += cmd->request_bufflen;
+	cmd->offset += cmd->request_bufflen;
 
 	if (!cmd->bufflen) {
 		scsi_tgt_transfer_response(cmd);



From mnc at berlios.de  Sat Jan 28 00:56:46 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 00:56:46 +0100
Subject: [Stgt-svn] r238 - branches/use-scsi-ml/kernel
Message-ID: <200601272356.k0RNukXp026743@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 00:56:43 +0100 (Sat, 28 Jan 2006)
New Revision: 238

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
update patch

Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-27 23:56:10 UTC (rev 237)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-27 23:56:43 UTC (rev 238)
@@ -576,7 +576,7 @@
  #define MAX_LINKS 32		
  
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 7529f43..452d652 100644
+index 7529f43..ce97272 100644
 --- a/include/scsi/scsi_cmnd.h
 +++ b/include/scsi/scsi_cmnd.h
 @@ -5,9 +5,11 @@
@@ -599,8 +599,17 @@
  	struct scsi_device *device;
  	struct scsi_request *sc_request;
  
-@@ -131,6 +134,14 @@ struct scsi_cmnd {
+@@ -84,6 +87,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
  
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -131,6 +136,14 @@ struct scsi_cmnd {
+ 
  	unsigned char tag;	/* SCSI-II queued command tag */
  	unsigned long pid;	/* Process ID, starts at 0. Unique per host. */
 +	/*
@@ -614,7 +623,7 @@
  };
  
  /*
-@@ -147,9 +158,14 @@ struct scsi_cmnd {
+@@ -147,9 +160,14 @@ struct scsi_cmnd {
  #define SCSI_STATE_MLQUEUE         0x100b
  
  
@@ -642,7 +651,7 @@
  extern int scsi_is_sdev_device(const struct device *);
  extern int scsi_is_target_device(const struct device *);
 diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index 467274a..fbab68c 100644
+index 467274a..6b06850 100644
 --- a/include/scsi/scsi_host.h
 +++ b/include/scsi/scsi_host.h
 @@ -7,6 +7,7 @@
@@ -653,7 +662,7 @@
  struct block_device;
  struct completion;
  struct module;
-@@ -123,6 +124,21 @@ struct scsi_host_template {
+@@ -123,6 +124,36 @@ struct scsi_host_template {
  			     void (*done)(struct scsi_cmnd *));
  
  	/*
@@ -663,11 +672,26 @@
 +	 *
 +	 * return values: see queuecommand
 +	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
 +	 * STATUS: REQUIRED FOR TARGET DRIVERS
 +	 */
 +	/* TODO: rename */
 +	int (* transfer_response)(struct scsi_cmnd *,
 +				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
 +	int (* transfer_data)(struct scsi_cmnd *,
 +			      void (*done)(struct scsi_cmnd *));
 +
@@ -675,7 +699,7 @@
  	 * This is an error handling strategy routine.  You don't need to
  	 * define one of these if you don't want to - there is a default
  	 * routine that is present that should work in most cases.  For those
-@@ -573,6 +589,12 @@ struct Scsi_Host {
+@@ -573,6 +604,12 @@ struct Scsi_Host {
  	 */
  	unsigned int max_host_blocked;
  
@@ -688,7 +712,7 @@
  	/* legacy crap */
  	unsigned long base;
  	unsigned long io_port;
-@@ -675,6 +697,9 @@ extern void scsi_unblock_requests(struct
+@@ -675,6 +712,9 @@ extern void scsi_unblock_requests(struct
  extern void scsi_block_requests(struct Scsi_Host *);
  
  struct class_container;
@@ -698,3 +722,96 @@
  /*
   * These two functions are used to allocate and free a pseudo device
   * which will connect to the host adapter itself rather than any
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..c1dc0d2
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,10 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..f7961d6
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,71 @@
++/*
++ * SCSI target netlink interface
++ *
++ * (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * This code is licenced under the GPL.
++ */
++
++#ifndef SCSI_TARGET_FRAMEWORK_IF_H
++#define SCSI_TARGET_FRAMEWORK_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_START,
++	TGT_UEVENT_TARGET_SETUP,
++	TGT_UEVENT_CMD_RES,
++	TGT_UEVENT_TARGET_BIND,
++
++	/* kernel -> user */
++	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int host_no;
++			int pid;
++		} target_bind;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint64_t offset;
++			uint8_t rw;
++			uint8_t try_map;
++		} cmd_res;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_res;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint64_t dev_id;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++	} k;
++
++	/*
++	 * I think a pointer is a unsigned long but this struct
++	 * gets passed around from the kernel to userspace and
++	 * back again so to handle some ppc64 setups where userspace is
++	 * 32 bits but the kernel is 64 we do this odd thing
++	 */
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif



From mnc at berlios.de  Sat Jan 28 01:04:47 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 01:04:47 +0100
Subject: [Stgt-svn] r239 - branches/use-scsi-ml/kernel
Message-ID: <200601280004.k0S04lXs027380@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 01:04:04 +0100 (Sat, 28 Jan 2006)
New Revision: 239

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
must call bio_endio in destruction path incase it was bounced

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-27 23:56:43 UTC (rev 238)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-28 00:04:04 UTC (rev 239)
@@ -146,11 +146,16 @@
 {
 	struct bio *bio;
 
-	while ((bio = bio_list_pop(&cmd->xfer_done_list)))
+	/* must call bio_endio in case bio was bounced */
+	while ((bio = bio_list_pop(&cmd->xfer_done_list))) {
+		bio_endio(bio, bio->bi_size, 0);
 		bio_unmap_user(bio);
+	}
 
-	while ((bio = bio_list_pop(&cmd->xfer_list)))
+	while ((bio = bio_list_pop(&cmd->xfer_list))) {
+		bio_endio(bio, bio->bi_size, 0);
 		bio_unmap_user(bio);
+	}
 }
 
 static void scsi_tgt_cmd_destroy(void *data)
@@ -260,7 +265,11 @@
 
 		/*
 		 * The first bio is added and merged. We could probably
-		 * try to add others but for now we keep it simple.
+		 * try to add others using scsi_merge_bio() but for now
+		 * we keep it simple. The first bio should be pretty large
+		 * (either hitting the 1 MB bio pages limit or a queue limit)
+		 * already but for really large IO we may want to try and
+		 * merge these.
 		 */
 		if (!rq->bio)
 			blk_rq_bio_prep(q, rq, bio);



From mnc at berlios.de  Sat Jan 28 01:11:48 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 01:11:48 +0100
Subject: [Stgt-svn] r240 - branches/use-scsi-ml/include
Message-ID: <200601280011.k0S0Bmhu028340@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 01:11:43 +0100 (Sat, 28 Jan 2006)
New Revision: 240

Removed:
   branches/use-scsi-ml/include/tgt_if.h
   branches/use-scsi-ml/include/tgt_scsi_if.h
Log:
rm old headers

Deleted: branches/use-scsi-ml/include/tgt_if.h
===================================================================
--- branches/use-scsi-ml/include/tgt_if.h	2006-01-28 00:04:04 UTC (rev 239)
+++ branches/use-scsi-ml/include/tgt_if.h	2006-01-28 00:11:43 UTC (rev 240)
@@ -1,89 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef TARGET_FRAMEWORK_IF_H
-#define TARGET_FRAMEWORK_IF_H
-
-enum tgt_event_type {
-	/* user -> kernel */
-	TGT_UEVENT_START,
-	TGT_UEVENT_TARGET_CREATE,
-	TGT_UEVENT_TARGET_DESTROY,
-	TGT_UEVENT_TARGET_PASSTHRU,
-	TGT_UEVENT_CMD_RES,
-
-	/* kernel -> user */
-	TGT_KEVENT_RESPONSE,
-	TGT_KEVENT_CMD_REQ,
-	TGT_KEVENT_TARGET_PASSTHRU,
-	TGT_KEVENT_CMD_DONE,
-};
-
-struct tgt_event {
-	/* user-> kernel */
-	union {
-		struct {
-			char type[32];
-			int nr_cmds;
-		} c_target;
-		struct {
-			int tid;
-		} d_target;
-		struct {
-			int tid;
-			uint32_t len;
-		} tgt_passthru;
-		struct {
-			int tid;
-			uint64_t cid;
-			uint32_t len;
-			int result;
-			/*
-			 * this is screwed for setups with 64 bit kernel
-			 * and 32 bit userspace
-			 */
-			unsigned long uaddr;
-			uint64_t offset;
-			uint8_t rw;
-			uint8_t try_map;
-		} cmd_res;
-	} u;
-
-	/* kernel -> user */
-	union {
-		struct {
-			int err;
-		} event_res;
-		struct {
-			int tid;
-			uint64_t cid;
-			int typeid;
-			uint32_t data_len;
-		} cmd_req;
-		struct {
-			int tid;
-			uint32_t len;
-			int typeid;
-		} tgt_passthru;
-		struct {
-			int tid;
-			int typeid;
-			unsigned long uaddr;
-			uint32_t len;
-			int mmapped;
-		} cmd_done;
-	} k;
-
-	/*
-	 * I think a pointer is a unsigned long but this struct
-	 * gets passed around from the kernel to userspace and
-	 * back again so to handle some ppc64 setups where userspace is
-	 * 32 bits but the kernel is 64 we do this odd thing
-	 */
-	uint64_t data[0];
-} __attribute__ ((aligned (sizeof(uint64_t))));
-
-#endif

Deleted: branches/use-scsi-ml/include/tgt_scsi_if.h
===================================================================
--- branches/use-scsi-ml/include/tgt_scsi_if.h	2006-01-28 00:04:04 UTC (rev 239)
+++ branches/use-scsi-ml/include/tgt_scsi_if.h	2006-01-28 00:11:43 UTC (rev 240)
@@ -1,20 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef __TGT_SCSI_IF_H
-#define __TGT_SCSI_IF_H
-
-#ifndef __KERNEL__
-#define MAX_COMMAND_SIZE	16
-#endif
-
-struct tgt_scsi_cmd {
-	uint8_t scb[MAX_COMMAND_SIZE];
-	uint8_t lun[8];
-	int tags;
-} __attribute__ ((aligned (sizeof(uint64_t))));
-
-#endif



From mnc at berlios.de  Sat Jan 28 01:15:15 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 01:15:15 +0100
Subject: [Stgt-svn] r241 - branches/use-scsi-ml/kernel
Message-ID: <200601280015.k0S0FFnc030064@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 01:15:13 +0100 (Sat, 28 Jan 2006)
New Revision: 241

Removed:
   branches/use-scsi-ml/kernel/scsi_tgt.h
   branches/use-scsi-ml/kernel/scsi_tgt_if.h
Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
Log:
fix compile problems with hack to scsi_tgt_nl.c

Deleted: branches/use-scsi-ml/kernel/scsi_tgt.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt.h	2006-01-28 00:11:43 UTC (rev 240)
+++ branches/use-scsi-ml/kernel/scsi_tgt.h	2006-01-28 00:15:13 UTC (rev 241)
@@ -1,10 +0,0 @@
-/*
- * SCSI target definitions
- */
-
-struct Scsi_Host;
-struct scsi_cmnd;
-struct scsi_lun;
-
-extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);

Deleted: branches/use-scsi-ml/kernel/scsi_tgt_if.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.h	2006-01-28 00:11:43 UTC (rev 240)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.h	2006-01-28 00:15:13 UTC (rev 241)
@@ -1,71 +0,0 @@
-/*
- * SCSI target netlink interface
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-#ifndef SCSI_TARGET_FRAMEWORK_IF_H
-#define SCSI_TARGET_FRAMEWORK_IF_H
-
-enum tgt_event_type {
-	/* user -> kernel */
-	TGT_UEVENT_START,
-	TGT_UEVENT_TARGET_SETUP,
-	TGT_UEVENT_CMD_RES,
-	TGT_UEVENT_TARGET_BIND,
-
-	/* kernel -> user */
-	TGT_KEVENT_RESPONSE,
-	TGT_KEVENT_CMD_REQ,
-	TGT_KEVENT_CMD_DONE,
-};
-
-struct tgt_event {
-	/* user-> kernel */
-	union {
-		struct {
-			int host_no;
-			int pid;
-		} target_bind;
-		struct {
-			int host_no;
-			uint32_t cid;
-			uint32_t len;
-			int result;
-			uint64_t uaddr;
-			uint64_t offset;
-			uint8_t rw;
-			uint8_t try_map;
-		} cmd_res;
-	} u;
-
-	/* kernel -> user */
-	union {
-		struct {
-			int err;
-		} event_res;
-		struct {
-			int host_no;
-			uint32_t cid;
-			uint32_t data_len;
-			uint64_t dev_id;
-		} cmd_req;
-		struct {
-			int host_no;
-			uint32_t cid;
-			int result;
-		} cmd_done;
-	} k;
-
-	/*
-	 * I think a pointer is a unsigned long but this struct
-	 * gets passed around from the kernel to userspace and
-	 * back again so to handle some ppc64 setups where userspace is
-	 * 32 bits but the kernel is 64 we do this odd thing
-	 */
-	uint64_t data[0];
-} __attribute__ ((aligned (sizeof(uint64_t))));
-
-#endif

Modified: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-28 00:11:43 UTC (rev 240)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-28 00:15:13 UTC (rev 241)
@@ -11,8 +11,8 @@
 #include <net/tcp.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
-#include <scsi/scsi_tgt_if.h>
 
+#include "scsi_tgt_if.h" /* this needs to be changed when sending to linux-scsi */
 #include "scsi_tgt_priv.h"
 
 /* default task when host is not setup in userspace yet */



From mnc at berlios.de  Sat Jan 28 01:16:55 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 01:16:55 +0100
Subject: [Stgt-svn] r242 - branches/use-scsi-ml/kernel
Message-ID: <200601280016.k0S0Gt0J030805@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 01:16:51 +0100 (Sat, 28 Jan 2006)
New Revision: 242

Modified:
   branches/use-scsi-ml/kernel/Makefile
Log:
rename module to fix build problem

Modified: branches/use-scsi-ml/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/kernel/Makefile	2006-01-28 00:15:13 UTC (rev 241)
+++ branches/use-scsi-ml/kernel/Makefile	2006-01-28 00:16:51 UTC (rev 242)
@@ -5,8 +5,8 @@
 EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17 -DNETLINK_TGT_CMD=21
 
 ifneq ($(KERNELRELEASE),)
-obj-m			+= scsi_tgt_lib.o
-scsi_tgt_lib-objs	:= scsi_tgt_lib.o scsi_tgt_nl.o
+obj-m			+= scsi_tgt_core.o
+scsi_tgt_core-objs	:= scsi_tgt_lib.o scsi_tgt_nl.o
 
 else
 



From mnc at berlios.de  Sat Jan 28 01:19:06 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Sat, 28 Jan 2006 01:19:06 +0100
Subject: [Stgt-svn] r243 - branches/use-scsi-ml/kernel
Message-ID: <200601280019.k0S0J6lh031998@sheep.berlios.de>

Author: mnc
Date: 2006-01-28 01:18:50 +0100 (Sat, 28 Jan 2006)
New Revision: 243

Modified:
   branches/use-scsi-ml/kernel/README
Log:
readme update

Modified: branches/use-scsi-ml/kernel/README
===================================================================
--- branches/use-scsi-ml/kernel/README	2006-01-28 00:16:51 UTC (rev 242)
+++ branches/use-scsi-ml/kernel/README	2006-01-28 00:18:50 UTC (rev 243)
@@ -1 +1,2 @@
-You must apply tgt-scsi-ml8.patch to your kernel
+You must apply tgt-scsi-ml8.patch to your kernel. The patch
+was built against the current scsi-misc-2.6 git tree.



From tomo at berlios.de  Sat Jan 28 09:51:39 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 28 Jan 2006 09:51:39 +0100
Subject: [Stgt-svn] r244 - branches/use-scsi-ml/kernel
Message-ID: <200601280851.k0S8pdEb015053@sheep.berlios.de>

Author: tomo
Date: 2006-01-28 09:51:38 +0100 (Sat, 28 Jan 2006)
New Revision: 244

Modified:
   branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
Log:
Revert scsilun_to_int and one more fix for the bio-list change.


Modified: branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch
===================================================================
--- branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-28 00:18:50 UTC (rev 243)
+++ branches/use-scsi-ml/kernel/tgt-scsi-ml8.patch	2006-01-28 08:51:38 UTC (rev 244)
@@ -392,27 +392,6 @@
  
  void scsi_free_queue(struct request_queue *q)
  {
-diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
-index 752fb5d..0fdd11a 100644
---- a/drivers/scsi/scsi_scan.c
-+++ b/drivers/scsi/scsi_scan.c
-@@ -1013,7 +1013,7 @@ static void scsi_sequential_lun_scan(str
-  *     Given a struct scsi_lun of: 0a 04 0b 03 00 00 00 00, this function returns
-  *     the integer: 0x0b030a04
-  **/
--static int scsilun_to_int(struct scsi_lun *scsilun)
-+int scsilun_to_int(struct scsi_lun *scsilun)
- {
- 	int i;
- 	unsigned int lun;
-@@ -1024,6 +1024,7 @@ static int scsilun_to_int(struct scsi_lu
- 			      scsilun->scsi_lun[i + 1]) << (i * 8));
- 	return lun;
- }
-+EXPORT_SYMBOL(scsilun_to_int);
- 
- /**
-  * int_to_scsilun: reverts an int into a scsi_lun
 diff --git a/fs/bio.c b/fs/bio.c
 index 7b30695..aba3ce9 100644
 --- a/fs/bio.c
@@ -575,6 +554,20 @@
  
  #define MAX_LINKS 32		
  
+diff --git a/include/linux/raid/md_k.h b/include/linux/raid/md_k.h
+index 617b950..2323360 100644
+--- a/include/linux/raid/md_k.h
++++ b/include/linux/raid/md_k.h
+@@ -15,8 +15,7 @@
+ #ifndef _MD_K_H
+ #define _MD_K_H
+ 
+-/* and dm-bio-list.h is not under include/linux because.... ??? */
+-#include "../../../drivers/md/dm-bio-list.h"
++#include <linux/bio-list.h>
+ 
+ #define	LEVEL_MULTIPATH		(-4)
+ #define	LEVEL_LINEAR		(-1)
 diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
 index 7529f43..ce97272 100644
 --- a/include/scsi/scsi_cmnd.h
@@ -638,18 +631,6 @@
 +extern void scsi_free_sgtable(struct scatterlist *, int);
  
  #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
-index e94ca4d..1b09f4f 100644
---- a/include/scsi/scsi_device.h
-+++ b/include/scsi/scsi_device.h
-@@ -264,6 +264,7 @@ extern void scsi_target_block(struct dev
- extern void scsi_target_unblock(struct device *);
- extern void scsi_remove_target(struct device *);
- extern void int_to_scsilun(unsigned int, struct scsi_lun *);
-+extern int scsilun_to_int(struct scsi_lun *);
- extern const char *scsi_device_state_name(enum scsi_device_state);
- extern int scsi_is_sdev_device(const struct device *);
- extern int scsi_is_target_device(const struct device *);
 diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
 index 467274a..6b06850 100644
 --- a/include/scsi/scsi_host.h



From tomo at berlios.de  Sat Jan 28 10:21:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 28 Jan 2006 10:21:48 +0100
Subject: [Stgt-svn] r245 - branches/use-scsi-ml/kernel
Message-ID: <200601280921.k0S9LmeO016912@sheep.berlios.de>

Author: tomo
Date: 2006-01-28 10:21:48 +0100 (Sat, 28 Jan 2006)
New Revision: 245

Modified:
   branches/use-scsi-ml/kernel/Makefile
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_nl.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Kill translating lun in kernel space.

Modified: branches/use-scsi-ml/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/kernel/Makefile	2006-01-28 08:51:38 UTC (rev 244)
+++ branches/use-scsi-ml/kernel/Makefile	2006-01-28 09:21:48 UTC (rev 245)
@@ -2,7 +2,7 @@
 # Makefile for the Linux kernel device drivers.
 #
 
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17 -DNETLINK_TGT_CMD=21
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17
 
 ifneq ($(KERNELRELEASE),)
 obj-m			+= scsi_tgt_core.o

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-28 08:51:38 UTC (rev 244)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-01-28 09:21:48 UTC (rev 245)
@@ -49,9 +49,7 @@
 			break;
 
 		spin_unlock_irq(q->queue_lock);
-		/* rm scsilun_to_int and pass raw data up */
-		if (scsi_tgt_uspace_send(cmd, scsilun_to_int(rq->end_io_data),
-					GFP_ATOMIC) < 0)
+		if (scsi_tgt_uspace_send(cmd, GFP_ATOMIC) < 0)
 			goto requeue;
 		spin_lock_irq(q->queue_lock);
 	}

Modified: branches/use-scsi-ml/kernel/scsi_tgt_nl.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-28 08:51:38 UTC (rev 244)
+++ branches/use-scsi-ml/kernel/scsi_tgt_nl.c	2006-01-28 09:21:48 UTC (rev 245)
@@ -11,8 +11,8 @@
 #include <net/tcp.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_tgt_if.h>
 
-#include "scsi_tgt_if.h" /* this needs to be changed when sending to linux-scsi */
 #include "scsi_tgt_priv.h"
 
 /* default task when host is not setup in userspace yet */
@@ -32,7 +32,7 @@
 	}
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, u64 lun, gfp_t gfp_mask)
+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, gfp_t gfp_mask)
 {
 	struct sk_buff *skb;
 	struct nlmsghdr *nlh;
@@ -58,7 +58,6 @@
 
 	pdu = (char *) ev->data;
 	ev->k.cmd_req.host_no = cmd->shost->host_no;
-	ev->k.cmd_req.dev_id = lun;
 	ev->k.cmd_req.cid = cmd->request->tag;
 	ev->k.cmd_req.data_len = cmd->request_bufflen;
 	memcpy(ev->data, cmd->cmnd, MAX_COMMAND_SIZE);

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-01-28 08:51:38 UTC (rev 244)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-01-28 09:21:48 UTC (rev 245)
@@ -16,7 +16,7 @@
 extern void scsi_tgt_nl_exit(void);
 extern int scsi_tgt_nl_init(void);
 
-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, u64 lun, gfp_t gfp_mask);
+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, gfp_t gfp_mask);
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				u64 offset, unsigned long uaddr, u8 rw,



From tomo at berlios.de  Sat Jan 28 11:56:41 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 28 Jan 2006 11:56:41 +0100
Subject: [Stgt-svn] r246 - branches/use-scsi-ml/usr
Message-ID: <200601281056.k0SAufJF024296@sheep.berlios.de>

Author: tomo
Date: 2006-01-28 11:56:32 +0100 (Sat, 28 Jan 2006)
New Revision: 246

Added:
   branches/use-scsi-ml/usr/target.c
Modified:
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/dl.h
   branches/use-scsi-ml/usr/ipc.c
   branches/use-scsi-ml/usr/log.c
   branches/use-scsi-ml/usr/log.h
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/netlink.c
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/tgt_device.c
   branches/use-scsi-ml/usr/tgtadm.c
   branches/use-scsi-ml/usr/tgtadm.h
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Just sync with the main trunk.

Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/Makefile	2006-01-28 10:56:32 UTC (rev 246)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o tgt_device.o netlink.o ipc.o dl.o mgmt.o log.o
+tgtd: tgtd.o netlink.o ipc.o dl.o mgmt.o target.o log.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/dl.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -25,16 +25,9 @@
 #include "dl.h"
 #include "tgt_sysfs.h"
 
-struct driver_info {
-	char *name;
-	char *proto;
-	void *dl;
-	void *pdl;
-};
+struct driver_info dlinfo[MAX_DL_HANDLES];
 
-static struct driver_info dinfo[MAX_DL_HANDLES];
-
-char *typeid_to_name(int typeid)
+char *typeid_to_name(struct driver_info *dinfo, int typeid)
 {
 	return dinfo[typeid].name;
 }
@@ -71,7 +64,7 @@
 	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
 }
 
-int dl_init(void)
+int dl_init(struct driver_info *dinfo)
 {
 	int i, nr, idx;
 	char path[PATH_MAX], *p;
@@ -116,38 +109,21 @@
 	return 0;
 }
 
-void dl_config_load(void)
+void *dl_poll_init_fn(struct driver_info *dinfo, int idx)
 {
-	void (* fn)(void);
-	int i;
-
-	for (i = 0; i < MAX_DL_HANDLES; i++) {
-		if (!dinfo[i].dl)
-			continue;
-
-		fn = dlsym(dinfo[i].dl, "initial_config_load");
-		if (!fn)
-			eprintf("%s\n", dlerror());
-		else
-			fn();
-	}
-}
-
-void *dl_poll_init_fn(int idx)
-{
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "poll_init");
 	return NULL;
 }
 
-void *dl_poll_fn(int idx)
+void *dl_poll_fn(struct driver_info *dinfo, int idx)
 {
 	if (dinfo[idx].dl)
 		return dlsym(dinfo[idx].dl, "poll_event");
 	return NULL;
 }
 
-void *dl_ipc_fn(int typeid)
+void *dl_ipc_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, "ipc_mgmt");
@@ -155,7 +131,7 @@
 	return NULL;
 }
 
-void *dl_proto_cmd_process(int tid, int typeid)
+void *dl_proto_cmd_process(struct driver_info *dinfo, int tid, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, "cmd_process");
@@ -163,15 +139,23 @@
 	return NULL;
 }
 
-void *dl_event_fn(int tid, int typeid)
+void *dl_proto_get_devid(struct driver_info *dinfo, int tid, int typeid)
 {
+	if (dinfo[typeid].pdl)
+		return dlsym(dinfo[typeid].pdl, "get_devid");
+
+	return NULL;
+}
+
+void *dl_event_fn(struct driver_info *dinfo, int tid, int typeid)
+{
 	if (dinfo[typeid].dl)
 		return dlsym(dinfo[typeid].dl, "async_event");
 
 	return NULL;
 }
 
-void *dl_cmd_done_fn(int typeid)
+void *dl_cmd_done_fn(struct driver_info *dinfo, int typeid)
 {
 	if (dinfo[typeid].pdl)
 		return dlsym(dinfo[typeid].pdl, "cmd_done");

Modified: branches/use-scsi-ml/usr/dl.h
===================================================================
--- branches/use-scsi-ml/usr/dl.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/dl.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -3,17 +3,25 @@
 
 #define	MAX_DL_HANDLES	16
 
-extern int dl_init(void);
-extern void dl_config_load(void);
-extern struct pollfd * dl_poll_init(int *nr);
+struct driver_info {
+	char *name;
+	char *proto;
+	void *dl;
+	void *pdl;
+};
 
-extern void *dl_poll_init_fn(int idx);
-extern void *dl_poll_fn(int idx);
-extern void *dl_ipc_fn(int typeid);
-extern void *dl_event_fn(int tid, int typeid);
-extern void *dl_proto_cmd_process(int tid, int typeid);
-extern void *dl_cmd_done_fn(int typeid);
+extern struct driver_info dlinfo[MAX_DL_HANDLES];
 
-extern char *typeid_to_name(int typeid);
+extern int dl_init(struct driver_info *);
+extern struct pollfd * dl_poll_init(struct driver_info *, int *nr);
 
+extern void *dl_poll_init_fn(struct driver_info *, int idx);
+extern void *dl_poll_fn(struct driver_info *, int idx);
+extern void *dl_ipc_fn(struct driver_info *, int typeid);
+extern void *dl_event_fn(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_cmd_process(struct driver_info *, int tid, int typeid);
+extern void *dl_proto_get_devid(struct driver_info *, int tid, int typeid);
+extern void *dl_cmd_done_fn(struct driver_info *, int typeid);
+extern char *typeid_to_name(struct driver_info *, int typeid);
+
 #endif

Modified: branches/use-scsi-ml/usr/ipc.c
===================================================================
--- branches/use-scsi-ml/usr/ipc.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/ipc.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -8,9 +8,11 @@
 
 #include <errno.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <unistd.h>
 #include <errno.h>
 #include <inttypes.h>
+#include <poll.h>
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/un.h>
@@ -22,6 +24,10 @@
 #include "tgtadm.h"
 #include "dl.h"
 
+struct tgt_task {
+	int fd;
+};
+
 static int ipc_accept(int afd)
 {
 	struct sockaddr addr;
@@ -50,15 +56,61 @@
 	return err;
 }
 
-void ipc_event_handle(int accept_fd)
+void pipe_event_handle(int fd)
 {
-	int fd, err;
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	char buf[1024];
+	struct tgtadm_res *res;
+	struct tgt_task *task;
+	int err;
+
+	nlh = (struct nlmsghdr *) buf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr)))
+		return;
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		return;
+
+	res = NLMSG_DATA(nlh);
+	dprintf("%d %d %lx\n", err, nlh->nlmsg_len, res->addr);
+
+	task = (struct tgt_task *) res->addr;
+	if (!task)
+		return;
+
+	dprintf("%d\n", task->fd);
+
+	err = write(task->fd, nlh, nlh->nlmsg_len);
+	close(task->fd);
+	free(task);
+}
+
+void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
+{
+	int fd, err, done = 0;
 	char sbuf[4096], rbuf[4096];
 	struct nlmsghdr *nlh;
 	struct iovec iov;
 	struct msghdr msg;
 	struct tgtadm_res *res;
 	struct tgtadm_req *req;
+	struct tgt_task *task;
 	int (*fn) (char *, char *);
 
 	fd = ipc_accept(accept_fd);
@@ -97,15 +149,36 @@
 	if (err < 0)
 		goto fail;
 
+	task = calloc(1, sizeof(*task));
+	if (!task) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	task->fd = fd;
+
 	req = NLMSG_DATA(nlh);
+	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
 
-	dprintf("%d %d %d\n", req->typeid, err, nlh->nlmsg_len);
+	switch (req->mode) {
+	case MODE_DEVICE:
+		dprintf("%d %d %d %d %lx\n",
+			req->tid, req->typeid, err, nlh->nlmsg_len,
+			(unsigned long) task);
+		req->addr = (unsigned long) task;
+		write(poll_array[POLLS_PER_DRV + req->tid].fd,
+		      sbuf, NLMSG_ALIGN(nlh->nlmsg_len));
+		break;
+	default:
+		fn = dl_ipc_fn(dinfo, req->typeid);
+		if (fn)
+			err = fn((char *) nlh, rbuf);
+		else
+			err = tgt_mgmt((char *) nlh, rbuf);
+		done = 1;
+	}
 
-	fn = dl_ipc_fn(req->typeid);
-	if (fn)
-		err = fn((char *) nlh, rbuf);
-	else
-		err = tgt_mgmt((char *) nlh, rbuf);
+	if (!done)
+		return;
 
 send:
 	err = write(fd, nlh, nlh->nlmsg_len);

Modified: branches/use-scsi-ml/usr/log.c
===================================================================
--- branches/use-scsi-ml/usr/log.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/log.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -45,7 +45,7 @@
 		return 1;
 
 	if (size < MAX_MSG_SIZE)
-		size = DEFAULT_AREA_SIZE;
+		size = LOG_SPACE_SIZE;
 
 	if ((shmid = shmget(IPC_PRIVATE, size,
 			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
@@ -304,13 +304,15 @@
 		openlog(log_name, 0, LOG_DAEMON);
 		setlogmask (LOG_UPTO (LOG_DEBUG));
 
-		if (logarea_init(size))
+		if (logarea_init(size)) {
+			syslog(LOG_ERR, "failed to initialize the logger\n");
 			return 1;
+		}
 
 		pid = fork();
 		if (pid < 0) {
-			syslog(LOG_ERR, "starting logger failed\n");
-			exit(1);
+			syslog(LOG_ERR, "fail to fork the logger\n");
+			return 1;
 		} else if (pid) {
 			syslog(LOG_WARNING,
 			       "Target daemon logger with pid=%d started!\n", pid);

Modified: branches/use-scsi-ml/usr/log.h
===================================================================
--- branches/use-scsi-ml/usr/log.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/log.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -35,7 +35,7 @@
 	struct seminfo *__buf;
 };
 
-#define DEFAULT_AREA_SIZE 16384
+#define LOG_SPACE_SIZE 16384
 #define MAX_MSG_SIZE 256
 
 extern int log_daemon;

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <poll.h>
 #include <unistd.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
@@ -72,16 +73,32 @@
 
 static void __ktarget_create(struct tgt_event *ev, struct tgtadm_req *req)
 {
-	sprintf(ev->u.c_target.type, "%s", typeid_to_name(req->typeid));
+	sprintf(ev->u.c_target.type, "%s", typeid_to_name(dlinfo, req->typeid));
+	ev->u.c_target.pid = req->pid;
 }
 
 int ktarget_create(int typeid)
 {
 	struct tgtadm_req req;
+	int fd, err;
+
 	req.typeid = typeid;
+	req.pid = target_thread_create(&fd);
+	err = tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
+				__ktarget_create);
+	if (err >= 0) {
+		dprintf("%d %d\n", err, fd);
 
-	return tgt_event_execute(&req, TGT_UEVENT_TARGET_CREATE,
-				 __ktarget_create);
+		/* FIXME */
+		if (err > POLLS_PER_DRV)
+			eprintf("too large tid %d\n", err);
+		else {
+			poll_array[POLLS_PER_DRV + err].fd = fd;
+			poll_array[POLLS_PER_DRV + err].events = POLLIN;
+		}
+	}
+
+	return err;
 }
 
 static void __ktarget_destroy(struct tgt_event *ev, struct tgtadm_req *req)
@@ -98,7 +115,7 @@
 				 __ktarget_destroy);
 }
 
-void kdevice_create_parser(char *args, char **path, char **devtype)
+static void kdevice_create_parser(char *args, char **path, char **devtype)
 {
 	char *p, *q;
 
@@ -122,11 +139,11 @@
 	}
 }
 
-int kdevice_create(int tid, uint64_t devid, char *path, char *devtype)
+static int kdevice_create(int tid, uint64_t devid, char *path)
 {
 	int fd, err;
 
-	dprintf("%d %" PRIu64 " %s %s\n", tid, devid, path, devtype);
+	dprintf("%d %" PRIu64 " %s\n", tid, devid, path);
 
 	fd = open(path, O_RDWR | O_LARGEFILE);
 	if (fd < 0) {
@@ -141,7 +158,7 @@
 	return err;
 }
 
-int kdevice_destroy(int tid, uint64_t devid)
+static int kdevice_destroy(int tid, uint64_t devid)
 {
 	int fd, err;
 	char path[PATH_MAX], buf[PATH_MAX];
@@ -199,10 +216,10 @@
 	case OP_NEW:
 		path = devtype = NULL;
 		kdevice_create_parser(params, &path, &devtype);
-		if (!path || !devtype)
-			eprintf("Invalid path or device type\n");
+		if (!path)
+			eprintf("Invalid path\n");
 		else
-			err = kdevice_create(req->tid, req->lun, path,devtype);
+			err = kdevice_create(req->tid, req->lun, path);
 		break;
 	case OP_DELETE:
 		err = kdevice_destroy(req->tid, req->lun);
@@ -214,83 +231,6 @@
 	return err;
 }
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static void all_devices_destroy(int tid)
-{
-	struct dirent **namelist;
-	char *p;
-	int i, nr;
-	uint64_t devid;
-
-	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return;
-
-	for (i = 0; i < nr; i++) {
-
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		if (tid != atoi(p))
-			continue;
-		p = strchr(p, ':');
-		if (!p)
-			continue;
-		devid = strtoull(++p, NULL, 10);
-		kdevice_destroy(tid, devid);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-}
-
-static int system_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, i, nr, fd;
-	struct dirent **namelist;
-	char path[PATH_MAX], buf[PATH_MAX], *p;
-
-	if (req->op != OP_DELETE)
-		return err;
-
-	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
-			 namelist[i]->d_name);
-
-		fd = open(path, O_RDONLY);
-		if (fd < 0)
-			continue;
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0)
-			continue;
-
-		if (req->typeid == atoi(buf)) {
-			int tid;
-
-			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-				;
-			tid = atoi(p);
-			all_devices_destroy(tid);
-			ktarget_destroy(tid);
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
-}
-
 int tgt_mgmt(char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
@@ -302,13 +242,11 @@
 	req = NLMSG_DATA(nlh);
 	params = (char *) req + sizeof(*req);
 
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n", nlh->nlmsg_len,
+		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun,
+		params, getpid());
 
 	switch (req->mode) {
-	case MODE_SYSTEM:
-		err = system_mgmt(req, params, rbuf, &rlen);
-		break;
 	case MODE_TARGET:
 		err = target_mgmt(req, params, rbuf, &rlen);
 		break;
@@ -320,7 +258,7 @@
 	}
 
 	nlh = (struct nlmsghdr *) rbuf;
-	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
+	nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*res) + rlen);
 	res = NLMSG_DATA(nlh);
 	res->err = err;
 

Modified: branches/use-scsi-ml/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/usr/netlink.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/netlink.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -26,16 +26,12 @@
 #include "tgtd.h"
 #include "dl.h"
 
-#define	NL_BUFSIZE	8192
+#define	NL_BUFSIZE	1024
 
-static struct sockaddr_nl src_addr, dest_addr;
-static char *recvbuf, *sendbuf;
-
-static int __nl_write(int fd, int type, char *data, int len)
+int __nl_write(int fd, int type, char *data, int len)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl daddr;
 
 	memset(nlh, 0, sizeof(*nlh));
 	nlh->nlmsg_len = len;
@@ -43,46 +39,36 @@
 	nlh->nlmsg_flags = 0;
 	nlh->nlmsg_pid = getpid();
 
-	iov.iov_base = data;
-	iov.iov_len = len;
+	memset(&daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
+	daddr.nl_pid = 0;
+	daddr.nl_groups = 0;
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &dest_addr;
-	msg.msg_namelen = sizeof(dest_addr);
-	msg.msg_iov = (void *) &iov;
-	msg.msg_iovlen = 1;
-
-	return sendmsg(fd, &msg, 0);
+	return sendto(fd, data, len, 0, (struct sockaddr *) &daddr,
+		      sizeof(daddr));
 }
 
-static int __nl_read(int fd, void *data, int size, int flags)
+int __nl_read(int fd, void *data, int size, int flags)
 {
-	int rc;
-	struct iovec iov;
-	struct msghdr msg;
+	struct sockaddr_nl saddr;
+	socklen_t slen = sizeof(saddr);
 
-	iov.iov_base = data;
-	iov.iov_len = size;
+	memset(&saddr, 0, sizeof(saddr));
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = getpid();
+	saddr.nl_groups = 0; /* not in mcast groups */
 
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_name= (void*) &src_addr;
-	msg.msg_namelen = sizeof(src_addr);
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	rc = recvmsg(fd, &msg, flags);
-
-	return rc;
+	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
 }
 
-int nl_read(int fd)
+static int nl_read(int fd, char *buf)
 {
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
 	int err;
 
 peek_again:
-	err = __nl_read(fd, recvbuf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
+	err = __nl_read(fd, buf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
 	if (err < 0) {
 		eprintf("%d\n", err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -90,13 +76,13 @@
 		return err;
 	}
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) buf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
-	dprintf("nl_event_handle %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len);
+	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid());
 
 read_again:
-	err = __nl_read(fd, recvbuf, nlh->nlmsg_len, 0);
+	err = __nl_read(fd, buf, nlh->nlmsg_len, 0);
 	if (err < 0) {
 		eprintf("%d\n", err);
 		if (errno == EAGAIN || errno == EINTR)
@@ -107,87 +93,33 @@
 	return err;
 }
 
-static int cmd_queue(int fd, char *reqbuf, char *resbuf)
+void nl_event_handle(struct driver_info *dinfo, int fd)
 {
-	int result, len = 0;
-	struct tgt_event *ev_req = (struct tgt_event *) reqbuf;
-	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
-	uint64_t offset, cid = ev_req->k.cmd_req.cid;
-	uint8_t *pdu, rw = 0, try_map = 0;
-	unsigned long uaddr;
-	int (*fn) (int, uint8_t *, int *, uint32_t,
-		   unsigned long *, uint8_t *, uint8_t *, uint64_t *);
-
-	memset(resbuf, 0, NL_BUFSIZE);
-	pdu = (uint8_t *) ev_req->data;
-	dprintf("%" PRIu64 " %x\n", cid, pdu[0]);
-
-	fn = dl_proto_cmd_process(ev_req->k.cmd_req.tid,
-				  ev_req->k.cmd_req.typeid);
-
-	if (fn)
-		result = fn(ev_req->k.cmd_req.tid,
-			    pdu,
-			    &len,
-			    ev_req->k.cmd_req.data_len,
-			    &uaddr, &rw, &try_map, &offset);
-	else {
-		result = -EINVAL;
-		eprintf("Cannot process cmd %d %" PRIu64 "\n",
-			ev_req->k.cmd_req.tid, cid);
-	}
-
-	memset(ev_res, 0, (char *) ev_res->data - (char *) ev_res);
-	ev_res->u.cmd_res.tid = ev_req->k.cmd_req.tid;
-	ev_res->u.cmd_res.cid = cid;
-	ev_res->u.cmd_res.len = len;
-	ev_res->u.cmd_res.result = result;
-	ev_res->u.cmd_res.uaddr = uaddr;
-	ev_res->u.cmd_res.rw = rw;
-	ev_res->u.cmd_res.try_map = try_map;
-	ev_res->u.cmd_res.offset = offset;
-
-	log_debug("scsi_cmd_process res %d len %d\n", result, len);
-
-	return __nl_write(fd, TGT_UEVENT_CMD_RES, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
-}
-
-void nl_event_handle(int fd)
-{
 	struct nlmsghdr *nlh;
 	struct tgt_event *ev;
+	char rbuf[NL_BUFSIZE];
 	int err;
 	void (*fn) (char *);
 
-	err = nl_read(fd);
+	err = nl_read(fd, rbuf);
 	if (err < 0)
 		return;
 
-	nlh = (struct nlmsghdr *) recvbuf;
+	nlh = (struct nlmsghdr *) rbuf;
 	ev = (struct tgt_event *) NLMSG_DATA(nlh);
 
+	dprintf("%d %d\n", getpid(), nlh->nlmsg_type);
+
 	switch (nlh->nlmsg_type) {
-	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(fd, NLMSG_DATA(recvbuf), sendbuf);
-		break;
 	case TGT_KEVENT_TARGET_PASSTHRU:
-		fn = dl_event_fn(ev->k.tgt_passthru.tid,
+		fn = dl_event_fn(dinfo, ev->k.tgt_passthru.tid,
 				 ev->k.tgt_passthru.typeid);
 		if (fn)
-			fn(NLMSG_DATA(recvbuf));
+			fn(NLMSG_DATA(rbuf));
 		else
 			eprintf("Cannot handle async event %d\n",
 				ev->k.tgt_passthru.tid);
 		break;
-	case TGT_KEVENT_CMD_DONE:
-		fn = dl_cmd_done_fn(ev->k.cmd_done.typeid);
-		if (fn)
-			fn(NLMSG_DATA(recvbuf));
-		else
-			eprintf("Cannot handle cmd done %d\n",
-				ev->k.cmd_done.tid);
-		break;
 	default:
 		/* kernel module bug */
 		eprintf("unknown event %u\n", nlh->nlmsg_type);
@@ -200,15 +132,16 @@
 {
 	int err;
 	struct nlmsghdr *nlh;
+	char buf[NL_BUFSIZE];
 
 	err = __nl_write(fd, type, sbuf, slen);
 	if (err < 0)
 		return err;
 
-	err = nl_read(fd);
+	err = nl_read(fd, buf);
 
 	if (rbuf) {
-		nlh = (struct nlmsghdr *) recvbuf;
+		nlh = (struct nlmsghdr *) buf;
 		if (rlen < nlh->nlmsg_len)
 			eprintf("Too small rbuf %d %d\n", rlen, nlh->nlmsg_len);
 		else
@@ -220,18 +153,18 @@
 	return err;
 }
 
-static int nl_start(int fd)
+int nl_start(int fd)
 {
 	int err;
 	struct tgt_event *ev;
-	char rbuf[4096];
 	char nlmsg[NLMSG_SPACE(sizeof(struct tgt_event))];
+	char buf[NL_BUFSIZE];
 
 	err = nl_cmd_call(fd, TGT_UEVENT_START, nlmsg,
 			  NLMSG_SPACE(sizeof(struct tgt_event)),
-			  rbuf, sizeof(rbuf));
+			  buf, NL_BUFSIZE);
 
-	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
+	ev = (struct tgt_event *) NLMSG_DATA(buf);
 	if (err < 0 || ev->k.event_res.err < 0) {
 		eprintf("%d %d\n", err, ev->k.event_res.err);
 		return -EINVAL;
@@ -240,38 +173,13 @@
 	return 0;
 }
 
-int nl_open(void)
+int nl_init(void)
 {
-	int fd, err;
+	int fd;
 
-	sendbuf = malloc(NL_BUFSIZE * 2);
-	if (!sendbuf)
-		return -ENOMEM;
-	recvbuf = sendbuf + NL_BUFSIZE;
-
 	fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (fd < 0) {
-		eprintf("%d\n", fd);
-		return fd;
-	}
+	if (fd < 0)
+		eprintf("Fail to create the netlink socket %d\n", errno);
 
-	memset(&src_addr, 0, sizeof(src_addr));
-	src_addr.nl_family = AF_NETLINK;
-	src_addr.nl_pid = getpid();
-	src_addr.nl_groups = 0; /* not in mcast groups */
-
-	memset(&dest_addr, 0, sizeof(dest_addr));
-	dest_addr.nl_family = AF_NETLINK;
-	dest_addr.nl_pid = 0; /* kernel */
-	dest_addr.nl_groups = 0; /* unicast */
-
-	err = nl_start(fd);
-	if (err < 0)
-		goto out;
-
 	return fd;
-
-out:
-	close(fd);
-	return err;
 }

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/scsi.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -31,7 +31,6 @@
 #include <linux/netlink.h>
 
 #include "tgtd.h"
-#include "tgt_if.h"
 #include "tgt_scsi_if.h"
 #include "tgt_sysfs.h"
 
@@ -544,6 +543,7 @@
 	void *p;
 	uint64_t off;
 	*len = 0;
+	int err = SAM_STAT_GOOD;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -566,14 +566,20 @@
 
 	off <<= 9;
 
-	p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
-		 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
+	if (*uaddr)
+		*uaddr = *uaddr + (off & PAGE_MASK);
+	else {
+		p = mmap(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+			 PROT_READ | PROT_WRITE, MAP_SHARED, fd, off & PAGE_MASK);
 
-	*uaddr = (unsigned long) p;
+		*uaddr = (unsigned long) p;
+		if (p == MAP_FAILED)
+			err = SAM_STAT_CHECK_CONDITION;
+	}
 	*offset = off;
 	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
-	return (p == MAP_FAILED) ? SAM_STAT_CHECK_CONDITION : SAM_STAT_GOOD;
+	return err;
 }
 
 static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
@@ -598,10 +604,10 @@
 	return result;
 }
 
-#define	TGT_INVALID_DEV_ID	~0ULL
-
-static uint64_t translate_lun(uint8_t *p, int size)
+uint64_t get_devid(uint8_t *pdu)
 {
+	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
+	uint8_t *p = scmd->lun;
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
 	switch (*p >> 6) {
@@ -622,14 +628,12 @@
 
 int cmd_process(int tid, uint8_t *pdu, int *len,
 		uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
-		uint8_t *try_map, uint64_t *offset)
+		uint8_t *try_map, uint64_t *offset, uint64_t lun)
 {
 	int fd, result = SAM_STAT_GOOD;
 	struct tgt_scsi_cmd *scmd = (struct tgt_scsi_cmd *) pdu;
 	uint8_t *data = NULL, *scb = scmd->scb;
-	uint64_t lun;
 
-	lun = translate_lun(scmd->lun, sizeof(scmd->lun));
 	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
 
 	*offset = 0;
@@ -686,7 +690,10 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		fd = getfd(tid, lun);
+		if (*uaddr)
+			fd = 0;
+		else
+			fd = getfd(tid, lun);
 		if (fd >= 0) {
 			result = mmap_device(tid, lun, scb, len, fd, datalen,
 					     uaddr, offset);
@@ -719,17 +726,16 @@
 	return result;
 }
 
-int cmd_done(struct tgt_event *ev)
+int cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 
-	if (ev->k.cmd_done.mmapped)
-		err = munmap((void *) ev->k.cmd_done.uaddr, ev->k.cmd_done.len);
-	else
-		free((void *) ev->k.cmd_done.uaddr);
+	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
 
-	dprintf("%d %lx %u %d\n", ev->k.cmd_done.mmapped,
-		ev->k.cmd_done.uaddr, ev->k.cmd_done.len, err);
+	if (do_munmap)
+		err = munmap((void *) (unsigned long) uaddr, len);
+	else if (do_free)
+		free((void *) (unsigned long) uaddr);
 
 	return err;
 }

Copied: branches/use-scsi-ml/usr/target.c (from rev 230, trunk/usr/target.c)

Modified: branches/use-scsi-ml/usr/tgt_device.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_device.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgt_device.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -1,140 +0,0 @@
-/*
- * target framework Device
- *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
- */
-
-/*
- * This is just makeshift for removing device stuff in kernel space
- * and should be replaced soon.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#include <inttypes.h>
-#include <sys/stat.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <errno.h>
-#include <asm/byteorder.h>
-#include <asm/page.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <linux/fs.h>
-
-#include "tgtd.h"
-#include "tgt_sysfs.h"
-
-static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
-static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
-
-int tgt_device_create(int tid, uint64_t lun, int dfd)
-{
-	int err, fd;
-	struct stat st;
-	char path[PATH_MAX], buf[32];
-	uint64_t size;
-
-	err = ioctl(dfd, BLKGETSIZE64, &size);
-	if (err < 0) {
-		eprintf("Cannot get size %d\n", dfd);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
-	err = stat(path, &st);
-	if (err < 0) {
-		eprintf("Cannot find target %d\n", tid);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, lun);
-
-	err = mkdir(path, dmode);
-	if (err < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%d", dfd);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, lun);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%" PRIu64, size);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	return 0;
-}
-
-int tgt_device_destroy(int tid, uint64_t lun)
-{
-	char path[PATH_MAX];
-	int err;
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/fd",
-		 tid, lun);
-	err = unlink(path);
-	if (err < 0) {
-		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		 tid, lun);
-	err = unlink(path);
-	if (err < 0) {
-		eprintf("Cannot unlink %s\n", path);
-		goto out;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64,
-		 tid, lun);
-	err = rmdir(path);
-	if (err < 0)
-		eprintf("Cannot unlink %s\n", path);
-
-out:
-	return err;
-}
-
-int tgt_device_init(void)
-{
-	int err;
-
-	rmdir(TGT_DEVICE_SYSFSDIR);
-	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
-	if (err < 0)
-		perror("Cannot create");
-
-	return err;
-}

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -41,6 +41,7 @@
 #define dprintf eprintf
 
 static char program_name[] = "tgtadm";
+static char *driver;
 
 static struct option const long_options[] =
 {
@@ -113,6 +114,85 @@
 	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
 }
 
+static void all_devices_destroy(int tid)
+{
+	struct dirent **namelist;
+	char *p, cmd[1024];
+	int i, nr, err;
+	uint64_t devid;
+
+	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return;
+
+	for (i = 0; i < nr; i++) {
+
+		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+			;
+		if (tid != atoi(p))
+			continue;
+		p = strchr(p, ':');
+		if (!p)
+			continue;
+		devid = strtoull(++p, NULL, 10);
+		snprintf(cmd, sizeof(cmd),
+			 "./usr/tgtadm --driver %s --op delete --tid %d --lun %" PRIu64,
+			 driver, tid, devid);
+		err = system(cmd);
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+}
+
+static int system_mgmt(struct tgtadm_req *req)
+{
+	int err = -EINVAL, i, nr, fd;
+	struct dirent **namelist;
+	char path[PATH_MAX], buf[PATH_MAX], cmd[PATH_MAX], *p;
+
+	if (req->op != OP_DELETE)
+		return err;
+
+	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/%s/typeid",
+			 namelist[i]->d_name);
+
+		fd = open(path, O_RDONLY);
+		if (fd < 0)
+			continue;
+		err = read(fd, buf, sizeof(buf));
+		close(fd);
+		if (err < 0)
+			continue;
+
+		if (req->typeid == atoi(buf)) {
+			int tid;
+
+			for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
+				;
+			tid = atoi(p);
+			all_devices_destroy(tid);
+
+			snprintf(cmd, sizeof(cmd),
+				 "./usr/tgtadm --driver %s --op delete --tid %d",
+				 driver, tid);
+			err = system(cmd);
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return 0;
+}
+
 static int driver_to_typeid(char *name)
 {
 	int i, nr, err, fd, id = -ENOENT;
@@ -178,6 +258,8 @@
 		goto out;
 	}
 
+	driver = name;
+
 	return id;
 out:
 	exit(0);
@@ -388,8 +470,12 @@
 		len += strlen(params);
 	}
 
-	err = ipc_mgmt_call(sbuf, len, rbuf);
-	ipc_mgmt_result(rbuf);
+	if (req->mode == MODE_SYSTEM)
+		err = system_mgmt(req);
+	else {
+		err = ipc_mgmt_call(sbuf, len, rbuf);
+		ipc_mgmt_result(rbuf);
+	}
 out:
 	return err;
 }

Modified: branches/use-scsi-ml/usr/tgtadm.h
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtadm.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -30,17 +30,18 @@
 	uint64_t sid;
 	int cid;
 	uint64_t lun;
+	int pid;
+
+	unsigned long addr;
 };
 
 struct tgtadm_res {
 	int err;
+	unsigned long addr;
 };
 
-extern int tgt_mgmt(char *sbuf, char *rbuf);
 extern int ktarget_destroy(int tid);
 extern int ktarget_create(int typeid);
-extern int kdevice_destroy(int tid, uint64_t devid);
-extern int kdevice_create(int tid, uint64_t devid, char *path, char *devtype);
-extern void kdevice_create_parser(char *args, char **path, char **devtype);
+extern int tgt_mgmt(char *sbuf, char *rbuf);
 
 #endif

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-01-28 10:56:32 UTC (rev 246)
@@ -1,5 +1,5 @@
 /*
- * Core target framework user-space daemon
+ * Target framework user-space main daemon
  *
  * (C) 2005 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
@@ -26,9 +26,8 @@
 #include "tgtd.h"
 #include "dl.h"
 
-#define	POLLS_PER_DRV	32
-
 int nl_fd, ipc_fd;
+struct pollfd *poll_array;
 
 enum {
 	POLL_NL,
@@ -46,6 +45,26 @@
 
 static char program_name[] = "tgtd";
 
+static int daemon_init(void)
+{
+	pid_t pid;
+
+	pid = fork();
+	if (pid < 0)
+		return -ENOMEM;
+	else if (pid)
+		exit(0);
+
+	setsid();
+	chdir("/");
+	close(0);
+	open("/dev/null", O_RDWR);
+	dup2(0, 1);
+	dup2(0, 2);
+
+	return 0;
+}
+
 static void usage(int status)
 {
 	if (status != 0)
@@ -65,7 +84,7 @@
 static void signal_catch(int signo) {
 }
 
-static void init(int daemon, int debug)
+static void tgtd_init(void)
 {
 	int fd;
 	char path[64];
@@ -92,16 +111,13 @@
 	}
 	write(fd, "-17\n", 4);
 	close(fd);
-
-	if (log_init(program_name, DEFAULT_AREA_SIZE, daemon, debug) < 0) {
-		fprintf(stderr, "can not start the logger daemon\n");
-		exit(-1);
-	}
 }
 
+/* TODO: rewrite makeshift poll code */
+
 static void event_loop(int nr_dls, struct pollfd *poll_array)
 {
-	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
+	int err, i, poll_max = (nr_dls + 2) * POLLS_PER_DRV;
 	void (* fn)(struct pollfd *, int);
 
 	while (1) {
@@ -113,16 +129,29 @@
 			continue;
 		}
 
-		if (poll_array[POLL_NL].revents)
-			nl_event_handle(nl_fd);
+		if (poll_array[POLL_NL].revents) {
+			nl_event_handle(dlinfo, nl_fd);
+			err--;
+		}
 
-		if (poll_array[POLL_IPC].revents)
-			ipc_event_handle(ipc_fd);
+		if (poll_array[POLL_IPC].revents) {
+			ipc_event_handle(dlinfo, ipc_fd);
+			err--;
+		}
 
+		if (!err)
+			continue;
+
+		for (i = POLLS_PER_DRV; i < POLLS_PER_DRV * 2; i++)
+			if (poll_array[i].revents) {
+				dprintf("target process event %d\n", i);
+				pipe_event_handle(poll_array[i].fd);
+			}
+
 		for (i = 0; i < nr_dls; i++) {
-			fn = dl_poll_fn(i);
+			fn = dl_poll_fn(dlinfo, i);
 			if (fn)
-				fn(poll_array + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
+				fn(poll_array + ((i + 2) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
 	}
 }
@@ -133,8 +162,7 @@
 	void (* fn)(struct pollfd *, int);
 	int i;
 
-	array = calloc((nr + 1) * POLLS_PER_DRV,
-		       sizeof(struct pollfd));
+	array = calloc((nr + 2) * POLLS_PER_DRV, sizeof(struct pollfd));
 	if (!array)
 		exit(-ENOMEM);
 
@@ -144,9 +172,9 @@
 	array[POLL_IPC].events = POLLIN;
 
 	for (i = 0; i < nr; i++) {
-		fn = dl_poll_init_fn(i);
+		fn = dl_poll_init_fn(dlinfo, i);
 		if (fn)
-			fn(array + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
+			fn(array + (i + 2) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}
 
 	return array;
@@ -156,10 +184,9 @@
 {
 	int ch, longindex, nr;
 	int is_daemon = 1, is_debug = 1;
-	pid_t pid;
-	struct pollfd *poll_array;
 
-	while ((ch = getopt_long(argc, argv, "fd:vh", long_options, &longindex)) >= 0) {
+	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
+				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':
 			is_daemon = 0;
@@ -179,42 +206,32 @@
 		}
 	}
 
-	init(is_daemon, is_debug);
+	if (is_daemon && daemon_init())
+		exit(1);
 
-	if (is_daemon) {
-		pid = fork();
-		if (pid < 0)
-			exit(-1);
-		else if (pid)
-			exit(0);
+	tgtd_init();
 
-		chdir("/");
+	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
+		exit(1);
 
-		close(0);
-		open("/dev/null", O_RDWR);
-		dup2(0, 1);
-		dup2(0, 2);
-		setsid();
-	}
+	if (tgt_device_init())
+		exit(1);
 
-	if (tgt_device_init() < 0)
-		exit(0);
-
-	nl_fd = nl_open();
+	nl_fd = nl_init();
 	if (nl_fd < 0)
-		exit(nl_fd);
+		exit(1);
+	if (nl_start(nl_fd))
+		exit(1);
 
 	ipc_fd = ipc_open();
 	if (ipc_fd < 0)
 		exit(ipc_fd);
 
-	dl_init();
+	dl_init(dlinfo);
 
 	nr = MAX_DL_HANDLES;
 	poll_array = poll_init(nr);
 
-	dl_config_load();
-
 	event_loop(nr, poll_array);
 
 	return 0;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-01-28 09:21:48 UTC (rev 245)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-01-28 10:56:32 UTC (rev 246)
@@ -2,15 +2,27 @@
 #define __TARGET_DAEMON_H
 
 #include "log.h"
+#include "dl.h"
 
+#define	TGT_INVALID_DEV_ID	~0ULL
+
+/* temporarily */
+#define	POLLS_PER_DRV	32
 extern int nl_fd;
+extern struct pollfd *poll_array;
 
-extern int nl_open(void);
-extern void nl_event_handle(int fd);
+extern int target_thread_create(int *fd);
+
+extern int nl_init(void);
+extern void nl_event_handle(struct driver_info *, int fd);
 extern int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen);
+extern int nl_start(int fd);
+extern int __nl_write(int fd, int type, char *data, int len);
+extern int __nl_read(int fd, void *data, int size, int flags);
 
 extern int ipc_open(void);
-extern void ipc_event_handle(int fd);
+extern void ipc_event_handle(struct driver_info *, int fd);
+extern void pipe_event_handle(int fd);
 
 extern int tgt_device_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, int dfd);



From mnc at berlios.de  Mon Jan 30 00:32:03 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Mon, 30 Jan 2006 00:32:03 +0100
Subject: [Stgt-svn] r247 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200601292332.k0TNW3G6007208@sheep.berlios.de>

Author: mnc
Date: 2006-01-30 00:32:01 +0100 (Mon, 30 Jan 2006)
New Revision: 247

Added:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Removed:
   branches/use-scsi-ml/istgt/kernel/iscsi.c
Log:
check in iscsi_tcp_tgt.c: it does not compile. It needs to be converted to new headers and the transfer_data fn needs to be update  to account for the change in that it can be called multiple times (it needs to check the cmd->offset).

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi.c
===================================================================

Added: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-01-28 10:56:32 UTC (rev 246)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-01-29 23:32:01 UTC (rev 247)
@@ -0,0 +1,1935 @@
+/*
+ * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2002 - 2003 Ardis Technolgies <roman at ardistech.com>
+ * Copyright (C) 2005 - 2006 Mike Christie
+ *
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <linux/module.h>
+#include <linux/hash.h>
+#include <linux/mempool.h>
+#include <net/tcp.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tgt.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_transport_iscsi.h>
+#include <iscsi.h>
+
+static kmem_cache_t *istgt_cmd_cache;
+static char dummy_data[1024];
+
+static uint32_t cmnd_write_size(struct istgt_cmd *cmnd)
+{
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
+
+	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
+		return be32_to_cpu(hdr->data_length);
+	return 0;
+}
+
+static uint32_t cmnd_read_size(struct istgt_cmd *cmnd)
+{
+	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
+
+	if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+		if (!(hdr->flags & ISCSI_FLAG_CMD_WRITE))
+			return be32_to_cpu(hdr->data_length);
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+			struct iscsi_rlength_ahdr *ahdr =
+				(struct iscsi_rlength_ahdr *)cmnd->pdu.ahs;
+			if (ahdr && ahdr->ahstype == ISCSI_AHSTYPE_RLENGTH)
+				return be32_to_cpu(ahdr->read_length);
+		}
+	}
+	return 0;
+}
+
+/*
+ * create a new command.
+ *
+ * iscsi_cmnd_create - 
+ * @conn: ptr to connection (for i/o)
+ *
+ * @return    ptr to command or NULL
+ */
+
+struct istgt_cmd *cmnd_alloc(struct iscsi_conn *conn, int req)
+{
+	struct istgt_cmd *cmnd;
+
+	/* TODO: async interface is necessary ? */
+	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
+
+	memset(cmnd, 0, sizeof(*cmnd));
+	INIT_LIST_HEAD(&cmnd->list);
+	INIT_LIST_HEAD(&cmnd->pdu_list);
+	INIT_LIST_HEAD(&cmnd->conn_list);
+	INIT_LIST_HEAD(&cmnd->hash_list);
+	cmnd->conn = conn;
+	spin_lock(&conn->list_lock);
+	atomic_inc(&conn->nr_cmnds);
+	init_completion(&cmnd->event);
+	if (req)
+		list_add_tail(&cmnd->conn_list, &conn->pdu_list);
+	spin_unlock(&conn->list_lock);
+	cmnd->sg = NULL;
+
+	if (req)
+		BUG_ON(!conn->session);
+
+	dprintk("%p:%p\n", conn, cmnd);
+
+	return cmnd;
+}
+
+/**
+ * create a new command used as response.
+ *
+ * iscsi_cmnd_create_rsp_cmnd - 
+ * @cmnd: ptr to request command
+ *
+ * @return    ptr to response command or NULL
+ */
+
+static struct istgt_cmd *iscsi_cmnd_create_rsp_cmnd(struct istgt_cmd *cmnd, int final)
+{
+	struct istgt_cmd *rsp = cmnd_alloc(cmnd->conn, 0);
+
+	if (final)
+		set_cmd_final(rsp);
+	list_add_tail(&rsp->pdu_list, &cmnd->pdu_list);
+	rsp->req = cmnd;
+	return rsp;
+}
+
+static struct istgt_cmd *get_rsp_cmnd(struct istgt_cmd *req)
+{
+	return list_entry(req->pdu_list.prev, struct istgt_cmd, pdu_list);
+}
+
+static void iscsi_cmnds_init_write(struct list_head *send)
+{
+	struct istgt_cmd *cmnd = list_entry(send->next, struct istgt_cmd, list);
+	struct iscsi_conn *conn = cmnd->conn;
+	struct list_head *pos, *next;
+
+	spin_lock(&conn->list_lock);
+
+	list_for_each_safe(pos, next, send) {
+		cmnd = list_entry(pos, struct istgt_cmd, list);
+
+		dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+
+		list_del_init(&cmnd->list);
+		BUG_ON(conn != cmnd->conn);
+		list_add_tail(&cmnd->list, &conn->write_list);
+	}
+
+	spin_unlock(&conn->list_lock);
+
+	nthread_wakeup(conn->session);
+}
+
+static void iscsi_cmnd_init_write(struct istgt_cmd *cmnd)
+{
+	LIST_HEAD(head);
+
+	if (!list_empty(&cmnd->list)) {
+		eprintk("%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n",
+			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
+			cmd_scsicode(cmnd), cmnd->flags,
+			cmnd->r2t_sn, cmnd->r2t_length, cmnd->is_unsolicited_data,
+			cmnd->target_task_tag, cmnd->outstanding_r2t,
+			cmnd->hdigest, cmnd->ddigest,
+			list_empty(&cmnd->pdu_list), list_empty(&cmnd->hash_list));
+
+		BUG_ON(!list_empty(&cmnd->list));
+	}
+	list_add(&cmnd->list, &head);
+	iscsi_cmnds_init_write(&head);
+}
+
+static void do_send_data_rsp(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	struct istgt_cmd *data_cmnd;
+	struct scatterlist *sg = cmnd->scmd->request_buffer;
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
+	struct iscsi_data_rsp *rsp;
+	uint32_t pdusize, expsize, scsisize, size, offset, sn;
+	LIST_HEAD(send);
+
+	dprintk("%p\n", cmnd);
+	pdusize = conn->session->param.max_xmit_data_length;
+	expsize = cmnd_read_size(cmnd);
+	size = min(expsize, cmnd->scmd->request_bufflen);
+	dprintk("%u %u\n", expsize, cmnd->scmd->request_bufflen);
+	offset = 0;
+	sn = 0;
+
+	BUG_ON(!sg);
+
+	while (1) {
+		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size <= pdusize);
+		data_cmnd->sg = sg;
+		rsp = (struct iscsi_data_rsp *)&data_cmnd->pdu.bhs;
+
+		rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
+		rsp->itt = req->itt;
+		rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+		rsp->offset = offset;
+		rsp->datasn = cpu_to_be32(sn);
+
+		if (size <= pdusize) {
+			data_cmnd->pdu.datasize = size;
+			rsp->flags = ISCSI_FLAG_CMD_FINAL |
+				     ISCSI_FLAG_DATA_STATUS;
+
+			scsisize = cmnd->scmd->request_bufflen;
+			if (scsisize < expsize) {
+				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				size = expsize - scsisize;
+			} else if (scsisize > expsize) {
+				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				size = scsisize - expsize;
+			} else
+				size = 0;
+			rsp->residual_count = cpu_to_be32(size);
+			list_add_tail(&data_cmnd->list, &send);
+
+			break;
+		}
+
+		data_cmnd->pdu.datasize = pdusize;
+
+		size -= pdusize;
+		offset += pdusize;
+		sn++;
+
+		list_add_tail(&data_cmnd->list, &send);
+	}
+
+	iscsi_cmnds_init_write(&send);
+}
+
+static struct istgt_cmd *create_scsi_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+	struct iscsi_cmd_rsp *rsp_hdr;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr->cmd_status = SAM_STAT_GOOD;
+	rsp_hdr->itt = req_hdr->itt;
+
+	return rsp;
+}
+
+static void send_scsi_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	uint32_t size;
+
+	rsp = create_scsi_rsp(req);
+	rsp_hdr = (struct iscsi_cmd_rsp *) &rsp->pdu.bhs;
+	if ((size = cmnd_read_size(req)) != 0) {
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		rsp_hdr->residual_count = cpu_to_be32(size);
+	}
+
+	iscsi_cmnd_init_write(rsp);
+}
+
+static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct iscsi_sense_data *sense = &req->sense;
+	struct scatterlist *sg = &req->sense_sg;
+	struct scatterlist *sg_data = req->scmd->request_buffer;
+	struct page *page;
+
+	page = sg_data[0].page;
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr->itt = cmd_hdr(req)->itt;
+
+	memcpy(sense->sense_buff, req->scmd->sense_buffer,
+		sizeof(sense->sense_buff));
+	/*
+	 * this looks broken for ppc
+	 */
+	sense->length = cpu_to_be16(req->scmd->request_bufflen);
+
+	sg->page = virt_to_page(sense);
+	sg->offset = offset_in_page(sense);
+	sg->length = req->scmd->request_bufflen + sizeof(uint16_t);
+	rsp->pdu.datasize = sg->length;
+	rsp->sg = sg;
+
+	return rsp;
+}
+
+static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
+					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	struct scatterlist *sg = &req->sense_sg;
+	struct iscsi_sense_data *sense = &req->sense;
+	uint8_t *data = sense->sense_buff;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp_hdr->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp_hdr->itt = cmd_hdr(req)->itt;
+
+	sg->page = virt_to_page(sense);
+	sg->offset = offset_in_page(sense);
+
+	sense->length = cpu_to_be16(14);
+	data[0] = 0xf0;
+	data[2] = sense_key;
+	data[7] = 6;	// Additional sense length
+	data[12] = asc;
+	data[13] = ascq;
+
+	rsp->pdu.datasize = sizeof(uint16_t) + 14;
+	rsp->sg = sg;
+
+	sg->length = (rsp->pdu.datasize + 3) & -4;
+
+	return rsp;
+}
+
+/**
+ * Free a command.
+ * Also frees the additional header.
+ *
+ * iscsi_cmnd_remove - 
+ * @cmnd: ptr to command
+ */
+
+void iscsi_cmnd_remove(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn;
+
+	if (!cmnd)
+		return;
+	dprintk("%p\n", cmnd);
+	conn = cmnd->conn;
+	kfree(cmnd->pdu.ahs);
+
+	if (!list_empty(&cmnd->list)) {
+		struct iscsi_cmd *req = cmd_hdr(cmnd);
+
+		eprintk("cmnd %p still on some list?, %x %x %x %x %x %x %x %lx\n",
+			cmnd, req->opcode, req->cdb[0], req->flags, req->itt,
+			be32_to_cpu(req->data_length), req->cmdsn,
+			be32_to_cpu(cmnd->pdu.datasize), conn->state);
+
+		if (cmnd->req) {
+			struct iscsi_cmd *req = cmd_hdr(cmnd->req);
+			eprintk("%p %x %u\n", req, req->opcode, req->cdb[0]);
+		}
+		BUG();
+	}
+	list_del(&cmnd->list);
+	spin_lock(&conn->list_lock);
+	atomic_dec(&conn->nr_cmnds);
+	list_del(&cmnd->conn_list);
+	spin_unlock(&conn->list_lock);
+
+	if (cmnd->scmd)
+		cmnd->done(cmnd->scmd);
+	kmem_cache_free(istgt_cmd_cache, cmnd);
+}
+
+static void cmnd_skip_pdu(struct istgt_cmd *cmnd)
+{
+/* 	struct iscsi_conn *conn = cmnd->conn; */
+/* 	struct tio *tio = cmnd->tio; */
+/* 	char *addr; */
+/* 	u32 size; */
+/* 	int i; */
+
+	BUG_ON(1);
+
+/* 	eprintk("%x %x %x %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
+/* 		cmd_hdr(cmnd)->cdb[0], cmnd->pdu.datasize); */
+
+/* 	if (!(size = cmnd->pdu.datasize)) */
+/* 		return; */
+
+/* 	if (tio) */
+/* 		assert(tio->pg_cnt > 0); */
+/* 	else */
+/* 		tio = cmnd->tio = tio_alloc(1); */
+
+/* 	addr = page_address(tio->pvec[0]); */
+/* 	assert(addr); */
+/* 	size = (size + 3) & -4; */
+/* 	conn->read_size = size; */
+/* 	for (i = 0; size > PAGE_CACHE_SIZE; i++, size -= PAGE_CACHE_SIZE) { */
+/* 		assert(i < ISCSI_CONN_IOV_MAX); */
+/* 		conn->read_iov[i].iov_base = addr; */
+/* 		conn->read_iov[i].iov_len = PAGE_CACHE_SIZE; */
+/* 	} */
+/* 	conn->read_iov[i].iov_base = addr; */
+/* 	conn->read_iov[i].iov_len = size; */
+/* 	conn->read_msg.msg_iov = conn->read_iov; */
+/* 	conn->read_msg.msg_iovlen = ++i; */
+}
+
+static void iscsi_cmnd_reject(struct istgt_cmd *req, int reason)
+{
+/* 	struct istgt_cmd *rsp; */
+/* 	struct iscsi_reject_hdr *rsp_hdr; */
+/* 	struct tio *tio; */
+/* 	char *addr; */
+
+	BUG_ON(1);
+
+/* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
+/* 	rsp_hdr = (struct iscsi_reject_hdr *)&rsp->pdu.bhs; */
+
+/* 	rsp_hdr->opcode = ISCSI_OP_REJECT; */
+/* 	rsp_hdr->ffffffff = ISCSI_RESERVED_TAG; */
+/* 	rsp_hdr->reason = reason; */
+
+/* 	rsp->tio = tio = tio_alloc(1); */
+/* 	addr = page_address(tio->pvec[0]); */
+/* 	clear_page(addr); */
+/* 	memcpy(addr, &req->pdu.bhs, sizeof(struct iscsi_hdr)); */
+/* 	tio->size = rsp->pdu.datasize = sizeof(struct iscsi_hdr); */
+/* 	cmnd_skip_pdu(req); */
+
+/* 	req->pdu.bhs.opcode = ISCSI_OP_PDU_REJECT; */
+}
+
+static void cmnd_set_sn(struct istgt_cmd *cmnd, int set_stat_sn)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	struct iscsi_session *sess = conn->session;
+
+	if (set_stat_sn)
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn++);
+	cmnd->pdu.bhs.exp_statsn = cpu_to_be32(sess->exp_cmd_sn);
+	cmnd->pdu.bhs.max_statsn = cpu_to_be32(sess->exp_cmd_sn +
+						sess->max_queued_cmnds);
+}
+
+static void update_stat_sn(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	uint32_t exp_stat_sn;
+
+	cmnd->pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd->pdu.bhs.exp_statsn);
+	dprintk("%x,%x\n", cmd_opcode(cmnd), exp_stat_sn);
+	if ((int32_t) (exp_stat_sn - conn->exp_stat_sn) > 0 &&
+	    (int32_t) (exp_stat_sn - conn->stat_sn) <= 0) {
+		// free pdu resources
+		cmnd->conn->exp_stat_sn = exp_stat_sn;
+	}
+}
+
+static int check_cmd_sn(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd->conn->session;
+	uint32_t cmd_sn;
+
+	cmnd->pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd->pdu.bhs.statsn);
+	dprintk("%d(%d)\n", cmd_sn, session->exp_cmd_sn);
+	if ((int32_t) (cmd_sn - session->exp_cmd_sn) >= 0)
+		return 0;
+	eprintk("sequence error (%x,%x)\n", cmd_sn, session->exp_cmd_sn);
+	return -ISCSI_REASON_PROTOCOL_ERROR;
+}
+
+static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
+					   uint32_t itt, uint32_t ttt)
+{
+	struct list_head *head;
+	struct istgt_cmd *cmnd;
+
+	head = &session->cmnd_hash[cmnd_hashfn(itt)];
+
+	list_for_each_entry(cmnd, head, hash_list) {
+		if (cmnd->pdu.bhs.itt == itt) {
+			if ((ttt != ISCSI_RESERVED_TAG) && (ttt != cmnd->target_task_tag))
+				continue;
+			return cmnd;
+		}
+	}
+
+	return NULL;
+}
+
+static struct istgt_cmd *cmnd_find_hash(struct iscsi_session *session,
+					 uint32_t itt, uint32_t ttt)
+{
+	struct istgt_cmd *cmnd;
+
+	spin_lock(&session->cmnd_hash_lock);
+
+	cmnd = __cmnd_find_hash(session, itt, ttt);
+
+	spin_unlock(&session->cmnd_hash_lock);
+
+	return cmnd;
+}
+
+static int cmnd_insert_hash(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd->conn->session;
+	struct istgt_cmd *tmp;
+	struct list_head *head;
+	int err = 0;
+	uint32_t itt = cmnd->pdu.bhs.itt;
+
+	dprintk("%p:%x\n", cmnd, itt);
+	if (itt == ISCSI_RESERVED_TAG) {
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		goto out;
+	}
+
+	head = &session->cmnd_hash[cmnd_hashfn(cmnd->pdu.bhs.itt)];
+
+	spin_lock(&session->cmnd_hash_lock);
+
+	tmp = __cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG);
+	if (!tmp) {
+		list_add_tail(&cmnd->hash_list, head);
+		set_cmd_hashed(cmnd);
+	} else
+		err = -ISCSI_REASON_TASK_IN_PROGRESS;
+
+	spin_unlock(&session->cmnd_hash_lock);
+
+	if (!err) {
+		update_stat_sn(cmnd);
+		err = check_cmd_sn(cmnd);
+	}
+
+out:
+	return err;
+}
+
+static void __cmnd_remove_hash(struct istgt_cmd *cmnd)
+{
+	list_del(&cmnd->hash_list);
+}
+
+static void cmnd_remove_hash(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd->conn->session;
+	struct istgt_cmd *tmp;
+
+	spin_lock(&session->cmnd_hash_lock);
+
+	tmp = __cmnd_find_hash(session, cmnd->pdu.bhs.itt, ISCSI_RESERVED_TAG);
+
+	if (tmp && tmp == cmnd)
+		__cmnd_remove_hash(tmp);
+	else
+		eprintk("%p:%x not found\n", cmnd, cmd_itt(cmnd));
+
+	spin_unlock(&session->cmnd_hash_lock);
+}
+
+static void cmnd_skip_data(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_cmd_rsp *rsp_hdr;
+	uint32_t size;
+
+	rsp = get_rsp_cmnd(req);
+	rsp_hdr = (struct iscsi_cmd_rsp *)&rsp->pdu.bhs;
+	if (cmd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
+		eprintk("unexpected response command %u\n", cmd_opcode(rsp));
+		return;
+	}
+
+	size = cmnd_write_size(req);
+	if (size) {
+		rsp_hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		rsp_hdr->residual_count = cpu_to_be32(size);
+	}
+	size = cmnd_read_size(req);
+	if (size) {
+		if (cmd_hdr(req)->flags & ISCSI_FLAG_CMD_WRITE) {
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			rsp_hdr->bi_residual_count = cpu_to_be32(size);
+		} else {
+			rsp_hdr->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			rsp_hdr->residual_count = cpu_to_be32(size);
+		}
+	}
+	req->pdu.bhs.opcode =
+		(req->pdu.bhs.opcode & ~ISCSI_OPCODE_MASK) | ISCSI_OP_SCSI_REJECT;
+
+	cmnd_skip_pdu(req);
+}
+
+static int cmnd_recv_pdu(struct iscsi_conn *conn, struct scsi_cmnd *scmd,
+			 uint32_t offset, uint32_t size)
+{
+	int idx, i;
+	char *addr;
+	struct scatterlist *sg;
+
+	dprintk("%u,%u\n", offset, size);
+
+	BUG_ON(!scmd);
+	BUG_ON(!scmd->request_buffer);
+	sg = scmd->request_buffer;
+	offset += sg->offset;
+
+	if (!(offset < sg->offset + scmd->request_bufflen) ||
+	    !(offset + size <= sg->offset + scmd->request_bufflen)) {
+		eprintk("%u %u %u %u", offset, size, sg->offset,
+			scmd->request_bufflen);
+		return -EIO;
+	}
+	BUG_ON(!(offset < sg->offset + scmd->request_bufflen));
+	BUG_ON(!(offset + size <= sg->offset + scmd->request_bufflen));
+
+	idx = offset >> PAGE_CACHE_SHIFT;
+	offset &= ~PAGE_CACHE_MASK;
+
+	conn->read_msg.msg_iov = conn->read_iov;
+	conn->read_size = (size + 3) & -4;
+	conn->read_overflow = 0;
+
+	i = 0;
+	while (1) {
+		sg = scmd->request_buffer + idx;
+		BUG_ON(!sg);
+		BUG_ON(!sg->page);
+		addr = page_address(sg->page);
+		BUG_ON(!addr);
+
+		conn->read_iov[i].iov_base =  addr + offset;
+		if (offset + size <= PAGE_CACHE_SIZE) {
+			conn->read_iov[i].iov_len = size;
+			conn->read_msg.msg_iovlen = ++i;
+			break;
+		}
+		conn->read_iov[i].iov_len = PAGE_CACHE_SIZE - offset;
+		size -= conn->read_iov[i].iov_len;
+		offset = 0;
+		if (++i >= ISCSI_CONN_IOV_MAX) {
+			conn->read_msg.msg_iovlen = i;
+			conn->read_overflow = size;
+			conn->read_size -= size;
+			break;
+		}
+
+		idx++;
+	}
+
+	return 0;
+}
+
+static void send_r2t(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_r2t_rsp *rsp_hdr;
+	uint32_t length, offset, burst;
+	LIST_HEAD(send);
+
+	length = req->r2t_length;
+	burst = req->conn->session->param.max_burst_length;
+	offset = be32_to_cpu(cmd_hdr(req)->data_length) - length;
+
+	do {
+		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
+		rsp->pdu.bhs.ttt = req->target_task_tag;
+
+		rsp_hdr = (struct iscsi_r2t_rsp *)&rsp->pdu.bhs;
+		rsp_hdr->opcode = ISCSI_OP_R2T;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+		memcpy(rsp_hdr->lun, cmd_hdr(req)->lun, 8);
+		rsp_hdr->itt = cmd_hdr(req)->itt;
+		rsp_hdr->r2tsn = cpu_to_be32(req->r2t_sn++);
+		rsp_hdr->data_offset = cpu_to_be32(offset);
+		if (length > burst) {
+			rsp_hdr->data_length = cpu_to_be32(burst);
+			length -= burst;
+			offset += burst;
+		} else {
+			rsp_hdr->data_length = cpu_to_be32(length);
+			length = 0;
+		}
+
+		dprintk("%x %u %u %u %u\n", cmd_itt(req),
+			be32_to_cpu(rsp_hdr->data_length),
+			be32_to_cpu(rsp_hdr->data_offset),
+			be32_to_cpu(rsp_hdr->r2tsn), req->outstanding_r2t);
+
+		list_add_tail(&rsp->list, &send);
+
+		if (++req->outstanding_r2t >= req->conn->session->param.max_outstanding_r2t)
+			break;
+
+	} while (length);
+
+	iscsi_cmnds_init_write(&send);
+}
+
+static void __scsi_cmnd_done(void *data)
+{
+	struct scsi_cmnd *scmd = data;
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd->SCp.ptr;
+	struct iscsi_cmd *req = cmd_hdr(cmnd);
+
+	if (scmd->result) {
+		struct istgt_cmd *rsp;
+
+		rsp = do_create_sense_rsp(cmnd);
+		iscsi_cmnd_init_write(rsp);
+		return;
+	}
+
+	switch (req->cdb[0]) {
+	case INQUIRY:
+	case REPORT_LUNS:
+	case READ_CAPACITY:
+	case MODE_SENSE:
+	case REQUEST_SENSE:
+	case SERVICE_ACTION_IN:
+	case READ_6:
+	case READ_10:
+	case READ_16:
+		do_send_data_rsp(cmnd);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	case START_STOP:
+	case TEST_UNIT_READY:
+	case SYNCHRONIZE_CACHE:
+	case VERIFY:
+	case VERIFY_16:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+		send_scsi_rsp(cmnd);
+		break;
+	default:
+		BUG_ON(1);
+		break;
+	}
+}
+
+/* TODO : merge this with nthread. */
+static int scsi_cmnd_done(struct scsi_cmnd *scmd,
+			  void (*done)(struct scsi_cmnd *))
+{
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd->SCp.ptr;
+	int err;
+
+	cmnd->done = done;
+	INIT_WORK(&cmnd->work, __scsi_cmnd_done, scmd);
+	err = schedule_work(&cmnd->work);
+	BUG_ON(!err);
+
+	return TGT_CMD_XMIT_OK;
+}
+
+static void tgt_scsi_cmd_create(struct istgt_cmd *req)
+{
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+	struct scsi_cmnd *scmd;
+
+	scmd = scsi_host_get_command(req->conn->session->shost, GFP_KERNEL);
+	BUG_ON(!scmd);
+	req->scmd = scmd;
+
+	memcpy(scmd->data_cmnd, req_hdr->cdb, MAX_COMMAND_SIZE);
+	scmd->request_bufflen = be32_to_cpu(req_hdr->data_length);
+	scmd->SCp.ptr = (char *) req;
+
+	/*
+	 * handle bidi later
+	 */
+	if (req_hdr->flags & ISCSI_FLAG_CMD_WRITE)
+		scmd->sc_data_direction = DMA_TO_DEVICE;
+	else if (req_hdr->flags & ISCSI_FLAG_CMD_READ)
+		scmd->sc_data_direction = DMA_FROM_DEVICE;
+	else
+		scmd->sc_data_direction = DMA_NONE;
+
+	switch (req->pdu.bhs.flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		scmd->tag = MSG_SIMPLE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+		scmd->tag = MSG_ORDERED_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		scmd->tag = MSG_HEAD_TAG;
+		break;
+	case ISCSI_ATTR_ACA:
+		scmd->tag = MSG_SIMPLE_TAG;
+		break;
+	default:
+		scmd->tag = MSG_SIMPLE_TAG;
+	}
+
+	if (scmd->sc_data_direction == DMA_TO_DEVICE &&
+	    be32_to_cpu(req_hdr->data_length)) {
+		switch (req_hdr->cdb[0]) {
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_16:
+		case WRITE_VERIFY:
+			break;
+		default:
+			eprintk("%x\n", req_hdr->cdb[0]);
+			break;
+		}
+	}
+
+	scsi_tgt_queue_command(scmd, (struct scsi_lun *)req_hdr->lun, 0);
+}
+
+static void scsi_cmnd_exec(struct istgt_cmd *cmnd)
+{
+	struct scsi_cmnd *scmd = cmnd->scmd;
+
+	if (cmnd->r2t_length) {
+		if (!cmnd->is_unsolicited_data)
+			send_r2t(cmnd);
+	} else {
+		set_cmd_waitio(cmnd);
+		if (scmd) {
+			if (!cmnd->done)
+				BUG();
+			else
+				cmnd->done(scmd);
+		} else
+			tgt_scsi_cmd_create(cmnd);
+	}
+}
+
+static int noop_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	uint32_t size, tmp;
+	int i = 0, err = 0;
+
+	if (cmd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/*
+		 * We don't request a NOP-Out by sending a NOP-In.
+		 * See 10.18.2 in the draft 20.
+		 */
+		eprintk("initiator bug %x\n", cmd_itt(cmnd));
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		goto out;
+	}
+
+	if (cmd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (!(cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE))
+			eprintk("%s\n","initiator bug!");
+		update_stat_sn(cmnd);
+		err = check_cmd_sn(cmnd);
+		goto out;
+	} else if ((err = cmnd_insert_hash(cmnd)) < 0) {
+		eprintk("ignore this request %x\n", cmd_itt(cmnd));
+		goto out;
+	}
+
+	if ((size = cmnd->pdu.datasize)) {
+		size = (size + 3) & -4;
+		conn->read_msg.msg_iov = conn->read_iov;
+		if (cmnd->pdu.bhs.itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+/* 			struct tio *tio; */
+			int pg_cnt = get_pgcnt(size, 0);
+
+			BUG_ON(pg_cnt >= ISCSI_CONN_IOV_MAX);
+			BUG_ON(1);
+/* 			cmnd->tio = tio = tio_alloc(pg_cnt); */
+/* 			tio_set(tio, size, 0); */
+
+/* 			for (i = 0; i < pg_cnt; i++) { */
+/* 				conn->read_iov[i].iov_base */
+/* 					= page_address(tio->pvec[i]); */
+/* 				tmp = min_t(u32, size, PAGE_CACHE_SIZE); */
+/* 				conn->read_iov[i].iov_len = tmp; */
+/* 				conn->read_size += tmp; */
+/* 				size -= tmp; */
+/* 			} */
+		} else {
+			for (i = 0; i < ISCSI_CONN_IOV_MAX; i++) {
+				conn->read_iov[i].iov_base = dummy_data;
+				tmp = min_t(uint32_t, size, sizeof(dummy_data));
+				conn->read_iov[i].iov_len = tmp;
+				conn->read_size += tmp;
+				size -= tmp;
+			}
+		}
+		BUG_ON(size);
+		conn->read_overflow = size;
+		conn->read_msg.msg_iovlen = i;
+	}
+
+out:
+	return err;
+}
+
+static uint32_t get_next_ttt(struct iscsi_session *session)
+{
+	uint32_t ttt;
+
+	if (session->next_ttt == ISCSI_RESERVED_TAG)
+		session->next_ttt++;
+	ttt = session->next_ttt++;
+
+	return cpu_to_be32(ttt);
+}
+
+static void scsi_cmnd_start(struct iscsi_conn *conn, struct istgt_cmd *req)
+{
+	struct iscsi_cmd *req_hdr = cmd_hdr(req);
+
+	dprintk("scsi command: %02x\n", req_hdr->cdb[0]);
+
+	switch (req_hdr->cdb[0]) {
+	case SERVICE_ACTION_IN:
+		if ((req_hdr->cdb[1] & 0x1f) != 0x10)
+			goto error;
+
+	case INQUIRY:
+	case REPORT_LUNS:
+	case TEST_UNIT_READY:
+	case SYNCHRONIZE_CACHE:
+	case VERIFY:
+	case VERIFY_16:
+	case START_STOP:
+	case READ_CAPACITY:
+	case MODE_SENSE:
+	case REQUEST_SENSE:
+	case RESERVE:
+	case RELEASE:
+	case RESERVE_10:
+	case RELEASE_10:
+	case READ_6:
+	case READ_10:
+	case READ_16:
+	{
+		if (!(req_hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
+		      req->pdu.datasize) {
+			/* unexpected unsolicited data */
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
+			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
+			cmnd_skip_data(req);
+		}
+		break;
+	}
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+	case WRITE_VERIFY:
+	{
+		struct iscsi_sess_param *param = &conn->session->param;
+
+		/*
+		 * We don't know this command arrives in order,
+		 * however we need to allocate buffer for immediate
+		 * and unsolicited data. tgt will not start to perform
+		 * this command until we call cmd->done so we don't
+		 * need to worry about the order of the command.
+		 */
+		tgt_scsi_cmd_create(req);
+		wait_for_completion(&req->event);
+
+		req->r2t_length = be32_to_cpu(req_hdr->data_length) - req->pdu.datasize;
+		req->is_unsolicited_data = !(req_hdr->flags &
+						ISCSI_FLAG_CMD_FINAL);
+		req->target_task_tag = get_next_ttt(conn->session);
+
+		if (!param->immediate_data && req->pdu.datasize)
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
+
+		if (param->initial_r2t &&
+		    !(req_hdr->flags & ISCSI_FLAG_CMD_FINAL))
+			eprintk("%x %x\n", cmd_itt(req), req_hdr->cdb[0]);
+
+		if (req_hdr->cdb[0] == WRITE_VERIFY && req_hdr->cdb[1] & 0x02)
+			eprintk("Verification is ignored %x\n", cmd_itt(req));
+
+		if (req->pdu.datasize) {
+			if (cmnd_recv_pdu(conn, req->scmd, 0,
+					  req->pdu.datasize) < 0)
+				BUG_ON(1);
+		}
+		break;
+	}
+	error:
+	default:
+		eprintk("Unsupported %x\n", req_hdr->cdb[0]);
+		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
+		cmnd_skip_data(req);
+		break;
+	}
+
+	return;
+}
+
+static void data_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	struct iscsi_data *req = (struct iscsi_data *)&cmnd->pdu.bhs;
+	struct istgt_cmd *scsi_cmnd = NULL;
+	uint32_t offset = be32_to_cpu(req->offset);
+
+	update_stat_sn(cmnd);
+
+	cmnd->req = scsi_cmnd = cmnd_find_hash(conn->session, req->itt, req->ttt);
+	if (!scsi_cmnd) {
+		eprintk("unable to find scsi task %x %x\n",
+			cmd_itt(cmnd), cmd_ttt(cmnd));
+		goto skip_data;
+	}
+
+	if (scsi_cmnd->r2t_length < cmnd->pdu.datasize) {
+		eprintk("invalid data len %x %u %u\n",
+			cmd_itt(scsi_cmnd), cmnd->pdu.datasize, scsi_cmnd->r2t_length);
+		goto skip_data;
+	}
+
+	if (scsi_cmnd->r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
+		eprintk("%x %u %u %u\n", cmd_itt(scsi_cmnd), scsi_cmnd->r2t_length,
+			offset,	cmnd_write_size(scsi_cmnd));
+		goto skip_data;
+	}
+
+	scsi_cmnd->r2t_length -= cmnd->pdu.datasize;
+
+	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/* unsolicited burst data */
+		if (scsi_cmnd->pdu.bhs.flags & ISCSI_FLAG_CMD_FINAL) {
+			eprintk("unexpected data from %x %x\n",
+				cmd_itt(cmnd), cmd_ttt(cmnd));
+			goto skip_data;
+		}
+	}
+
+	dprintk("%u %p %p %u %u\n", req->ttt, cmnd, scsi_cmnd,
+		offset, cmnd->pdu.datasize);
+
+	if (cmnd_recv_pdu(conn, scsi_cmnd->scmd, offset, cmnd->pdu.datasize) < 0)
+		goto skip_data;
+	return;
+
+skip_data:
+	cmnd->pdu.bhs.opcode = ISCSI_OP_DATA_REJECT;
+	cmnd_skip_pdu(cmnd);
+	return;
+}
+
+static void data_out_end(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	struct iscsi_data *req = (struct iscsi_data *) &cmnd->pdu.bhs;
+	struct istgt_cmd *scsi_cmnd;
+	uint32_t offset;
+
+	BUG_ON(!cmnd);
+	scsi_cmnd = cmnd->req;
+	BUG_ON(!scsi_cmnd);
+
+	if (conn->read_overflow) {
+		eprintk("%x %u\n", cmd_itt(cmnd), conn->read_overflow);
+		offset = be32_to_cpu(req->offset);
+		offset += cmnd->pdu.datasize - conn->read_overflow;
+		if (cmnd_recv_pdu(conn, scsi_cmnd->scmd, offset,
+				  conn->read_overflow) < 0)
+			BUG_ON(1);
+		return;
+	}
+
+	if (req->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (req->flags & ISCSI_FLAG_CMD_FINAL) {
+			scsi_cmnd->is_unsolicited_data = 0;
+			if (!cmd_pending(scsi_cmnd))
+				scsi_cmnd_exec(scsi_cmnd);
+		}
+	} else {
+		/* TODO : proper error handling */
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL) &&
+		    scsi_cmnd->r2t_length == 0)
+			eprintk("initiator error %x\n", cmd_itt(scsi_cmnd));
+
+		if (!(req->flags & ISCSI_FLAG_CMD_FINAL))
+			goto out;
+
+		scsi_cmnd->outstanding_r2t--;
+
+		if (scsi_cmnd->r2t_length == 0)
+			BUG_ON(!list_empty(&scsi_cmnd->pdu_list));
+
+		scsi_cmnd_exec(scsi_cmnd);
+	}
+
+out:
+	iscsi_cmnd_remove(cmnd);
+	return;
+}
+
+/* static int __cmnd_abort(struct istgt_cmd *cmnd) */
+/* { */
+/* 	if (!cmnd_waitio(cmnd)) { */
+/* 		cmnd_release(cmnd, 1); */
+/* 		return 0; */
+/* 	} else */
+/* 		return -ISCSI_RESPONSE_UNKNOWN_TASK; */
+/* } */
+
+/* static int cmnd_abort(struct iscsi_session *session, u32 itt) */
+/* { */
+/* 	struct istgt_cmd *cmnd; */
+/* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
+
+/* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
+/* 		eprintk("%x %x %x %u %u %u %u\n", cmd_itt(cmnd), cmd_opcode(cmnd), */
+/* 			cmnd->r2t_length, cmnd_scsicode(cmnd), */
+/* 			cmnd_write_size(cmnd), cmnd->is_unsolicited_data, */
+/* 			cmnd->outstanding_r2t); */
+/* 		err = __cmnd_abort(cmnd); */
+/* 	} */
+
+/* 	return err; */
+/* } */
+
+/* static int target_reset(struct istgt_cmd *req, u32 lun, int all) */
+/* { */
+/* 	struct iscsi_target *target = req->conn->session->target; */
+/* 	struct iscsi_session *session; */
+/* 	struct iscsi_conn *conn; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
+
+/* 	list_for_each_entry(session, &target->session_list, list) { */
+/* 		list_for_each_entry(conn, &session->conn_list, list) { */
+/* 			list_for_each_entry_safe(cmnd, tmp, &conn->pdu_list, conn_list) { */
+/* 				if (cmnd == req) */
+/* 					continue; */
+
+/* 				if (all) */
+/* 					__cmnd_abort(cmnd); */
+/* 				else if (translate_lun(cmd_hdr(cmnd)->lun) == lun) */
+/* 					__cmnd_abort(cmnd); */
+/* 			} */
+/* 		} */
+/* 	} */
+
+/* 	return 0; */
+/* } */
+
+/* static void task_set_abort(struct istgt_cmd *req) */
+/* { */
+/* 	struct iscsi_session *session = req->conn->session; */
+/* 	struct iscsi_conn *conn; */
+/* 	struct istgt_cmd *cmnd, *tmp; */
+
+/* 	list_for_each_entry(conn, &session->conn_list, list) { */
+/* 		list_for_each_entry_safe(cmnd, tmp, &conn->pdu_list, conn_list) { */
+/* 			if (cmnd != req) */
+/* 				__cmnd_abort(cmnd); */
+/* 		} */
+/* 	} */
+/* } */
+
+static void execute_task_management(struct istgt_cmd *req)
+{
+/* 	struct iscsi_conn *conn = req->conn; */
+/* 	struct iscsi_target *target = conn->session->target; */
+	struct istgt_cmd *rsp;
+	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&req->pdu.bhs;
+	struct iscsi_tm_rsp *rsp_hdr;
+	int function = req_hdr->flags & ISCSI_FLAG_TM_FUNC_MASK;
+
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+	rsp_hdr = (struct iscsi_tm_rsp *)&rsp->pdu.bhs;
+
+	rsp_hdr->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->itt = req_hdr->itt;
+/* 	rsp_hdr->response = ISCSI_TMF_RSP_COMPLETE; */
+	rsp_hdr->response = ISCSI_TMF_RSP_REJECTED;
+
+	eprintk("%x %d %x\n", cmd_itt(req), function, req_hdr->rtt);
+
+/* 	switch (function) { */
+/* 	case ISCSI_FUNCTION_ABORT_TASK: */
+/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
+/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
+/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
+/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
+/* 		lun = translate_lun(req_hdr->lun); */
+/* 		if (!volume_lookup(target, lun)) { */
+/* 			rsp_hdr->response = ISCSI_RESPONSE_UNKNOWN_LUN; */
+/* 			goto out; */
+/* 		} */
+/* 	} */
+
+/* 	switch (function) { */
+/* 	case ISCSI_FUNCTION_ABORT_TASK: */
+/* 		if ((err = cmnd_abort(conn->session, req_hdr->rtt)) < 0) */
+/* 			rsp_hdr->response = -err; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
+/* 		task_set_abort(req); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
+/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
+/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
+/* 		target_reset(req, translate_lun(req_hdr->lun), 0); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_TARGET_WARM_RESET: */
+/* 	case ISCSI_FUNCTION_TARGET_COLD_RESET: */
+/* 		target_reset(req, 0, 1); */
+/* 		if (function == ISCSI_FUNCTION_TARGET_COLD_RESET) */
+/* 			set_cmnd_close(rsp); */
+/* 		break; */
+/* 	case ISCSI_FUNCTION_TASK_REASSIGN: */
+/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
+/* 		break; */
+/* 	default: */
+/* 		rsp_hdr->response = ISCSI_RESPONSE_FUNCTION_REJECTED; */
+/* 		break; */
+/* 	} */
+/* out: */
+	iscsi_cmnd_init_write(rsp);
+}
+
+static void noop_out_exec(struct istgt_cmd *req)
+{
+	struct istgt_cmd *rsp;
+	struct iscsi_nopin *rsp_hdr;
+
+	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+
+		rsp_hdr = (struct iscsi_nopin *)&rsp->pdu.bhs;
+		rsp_hdr->opcode = ISCSI_OP_NOOP_IN;
+		rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+		rsp_hdr->itt = req->pdu.bhs.itt;
+		rsp_hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+
+/* 		if (req->pdu.datasize) */
+/* 			assert(req->tio); */
+/* 		else */
+/* 			assert(!req->tio); */
+
+/* 		if (req->tio) { */
+/* 			tio_get(req->tio); */
+/* 			rsp->tio = req->tio; */
+/* 		} */
+
+		BUG_ON(get_pgcnt(req->pdu.datasize, 0) >= ISCSI_CONN_IOV_MAX);
+		rsp->pdu.datasize = req->pdu.datasize;
+		iscsi_cmnd_init_write(rsp);
+	} else
+		iscsi_cmnd_remove(req);
+}
+
+static void logout_exec(struct istgt_cmd *req)
+{
+	struct iscsi_logout *req_hdr;
+	struct istgt_cmd *rsp;
+	struct iscsi_logout_rsp *rsp_hdr;
+
+	req_hdr = (struct iscsi_logout *)&req->pdu.bhs;
+	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
+	rsp_hdr = (struct iscsi_logout_rsp *)&rsp->pdu.bhs;
+	rsp_hdr->opcode = ISCSI_OP_LOGOUT_RSP;
+	rsp_hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp_hdr->itt = req_hdr->itt;
+	set_cmd_close(rsp);
+	iscsi_cmnd_init_write(rsp);
+}
+
+static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
+{
+	dprintk("%p,%x,%u\n", cmnd, cmd_opcode(cmnd),
+		cmnd->pdu.bhs.statsn);
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_OUT:
+		noop_out_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD:
+		scsi_cmnd_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+		execute_task_management(cmnd);
+		break;
+	case ISCSI_OP_LOGOUT:
+		logout_exec(cmnd);
+		break;
+	case ISCSI_OP_SCSI_REJECT:
+		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
+		break;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		break;
+	default:
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
+		break;
+	}
+}
+
+static void __cmnd_send_pdu(struct iscsi_conn *conn, struct scatterlist *sg,
+			    uint32_t offset, uint32_t size)
+{
+/* 	dprintk(D_GENERIC, "%p %u,%u\n", tio, offset, size); */
+	offset += sg->offset;
+
+/* 	assert(offset <= sg->offset + tio->size); */
+/* 	assert(offset + size <= tio->offset + tio->size); */
+
+	conn->write_sg = sg;
+	conn->write_offset = offset;
+	conn->write_size += size;
+}
+
+static void cmnd_send_pdu(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
+{
+	uint32_t size;
+
+	if (!cmnd->pdu.datasize)
+		return;
+
+	size = (cmnd->pdu.datasize + 3) & -4;
+	BUG_ON(!cmnd->sg);
+	__cmnd_send_pdu(conn, cmnd->sg, 0, size);
+}
+
+static void set_cork(struct socket *sock, int on)
+{
+	int opt = on;
+	mm_segment_t oldfs;
+
+	oldfs = get_fs();
+	set_fs(get_ds());
+	sock->ops->setsockopt(sock, SOL_TCP, TCP_CORK, (void *)&opt, sizeof(opt));
+	set_fs(oldfs);
+}
+
+void cmnd_release(struct istgt_cmd *cmnd, int force)
+{
+	struct istgt_cmd *req, *rsp;
+	int is_last = 0;
+
+	if (!cmnd)
+		return;
+
+	req = cmnd->req;
+	is_last = cmd_final(cmnd);
+
+	if (force) {
+		while (!list_empty(&cmnd->pdu_list)) {
+			rsp = list_entry(cmnd->pdu_list.next, struct istgt_cmd, pdu_list);
+			list_del_init(&rsp->list);
+			list_del(&rsp->pdu_list);
+			iscsi_cmnd_remove(rsp);
+		}
+		list_del_init(&cmnd->list);
+	}
+
+	if (cmd_hashed(cmnd))
+		cmnd_remove_hash(cmnd);
+
+	list_del_init(&cmnd->pdu_list);
+	iscsi_cmnd_remove(cmnd);
+
+	if (is_last) {
+		BUG_ON(force);
+		BUG_ON(!req);
+		cmnd_release(req, 0);
+	}
+
+	return;
+}
+
+void cmnd_tx_start(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	struct iovec *iop;
+
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+	BUG_ON(!cmnd);
+	iscsi_cmnd_set_length(&cmnd->pdu);
+
+	set_cork(conn->sock, 1);
+
+	conn->write_iop = iop = conn->write_iov;
+	iop->iov_base = &cmnd->pdu.bhs;
+	iop->iov_len = sizeof(cmnd->pdu.bhs);
+	iop++;
+	conn->write_size = sizeof(cmnd->pdu.bhs);
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_IN:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD_RSP:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_TEXT_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_SCSI_DATA_IN:
+	{
+		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&cmnd->pdu.bhs;
+		uint32_t offset;
+
+		cmnd_set_sn(cmnd, (rsp->flags & ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
+		offset = rsp->offset;
+		rsp->offset = cpu_to_be32(offset);
+		BUG_ON(!cmnd->sg);
+		__cmnd_send_pdu(conn, cmnd->sg, offset, cmnd->pdu.datasize);
+		break;
+	}
+	case ISCSI_OP_LOGOUT_RSP:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_R2T:
+		cmnd_set_sn(cmnd, 0);
+		cmnd->pdu.bhs.statsn = cpu_to_be32(conn->stat_sn);
+		break;
+	case ISCSI_OP_ASYNC_EVENT:
+		cmnd_set_sn(cmnd, 1);
+		break;
+	case ISCSI_OP_REJECT:
+		cmnd_set_sn(cmnd, 1);
+		cmnd_send_pdu(conn, cmnd);
+		break;
+	default:
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
+		break;
+	}
+
+	iop->iov_len = 0;
+	// move this?
+	conn->write_size = (conn->write_size + 3) & -4;
+}
+
+void cmnd_tx_end(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_SCSI_CMD_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_R2T:
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
+	case ISCSI_OP_SCSI_DATA_IN:
+	case ISCSI_OP_LOGOUT_RSP:
+		break;
+	default:
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
+		BUG_ON(1);
+		break;
+	}
+
+	if (cmd_close(cmnd))
+		conn_close(conn);
+
+	list_del_init(&cmnd->list);
+	set_cork(cmnd->conn->sock, 0);
+}
+
+/**
+ * Push the command for execution.
+ * This functions reorders the commands.
+ * Called from the read thread.
+ *
+ * iscsi_session_push_cmnd - 
+ * @cmnd: ptr to command
+ */
+
+static void iscsi_session_push_cmnd(struct istgt_cmd *cmnd)
+{
+	struct iscsi_session *session = cmnd->conn->session;
+	struct list_head *entry;
+	uint32_t cmd_sn;
+
+	dprintk("%p:%x %u,%u\n",
+		cmnd, cmd_opcode(cmnd), cmnd->pdu.bhs.statsn,
+		session->exp_cmd_sn);
+
+	if (cmnd->pdu.bhs.opcode & ISCSI_OP_IMMEDIATE) {
+		iscsi_cmnd_exec(cmnd);
+		return;
+	}
+
+	cmd_sn = cmnd->pdu.bhs.statsn;
+	if (cmd_sn == session->exp_cmd_sn) {
+		while (1) {
+			session->exp_cmd_sn = ++cmd_sn;
+			iscsi_cmnd_exec(cmnd);
+
+			if (list_empty(&session->pending_list))
+				break;
+			cmnd = list_entry(session->pending_list.next, struct istgt_cmd, list);
+			if (cmnd->pdu.bhs.statsn != cmd_sn)
+				break;
+/* 			eprintk("find out-of-order %x %u %u\n", */
+/* 				cmd_itt(cmnd), cmd_sn, cmnd->pdu.bhs.statsn); */
+			list_del_init(&cmnd->list);
+			clear_cmd_pending(cmnd);
+		}
+	} else {
+/* 		eprintk("out-of-order %x %u %u\n", */
+/* 			cmd_itt(cmnd), cmd_sn, session->exp_cmd_sn); */
+
+		set_cmd_pending(cmnd);
+		if (before(cmd_sn, session->exp_cmd_sn)) /* close the conn */
+			eprintk("unexpected cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
+
+		if (after(cmd_sn, session->exp_cmd_sn + session->max_queued_cmnds))
+			eprintk("too large cmd_sn (%u,%u)\n", cmd_sn, session->exp_cmd_sn);
+
+		list_for_each(entry, &session->pending_list) {
+			struct istgt_cmd *tmp = list_entry(entry, struct istgt_cmd, list);
+			if (before(cmd_sn, tmp->pdu.bhs.statsn))
+				break;
+		}
+
+		BUG_ON(!list_empty(&cmnd->list));
+
+		list_add_tail(&cmnd->list, entry);
+	}
+}
+
+static int check_segment_length(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	struct iscsi_sess_param *param = &conn->session->param;
+
+	if (cmnd->pdu.datasize > param->max_recv_data_length) {
+		eprintk("too lond data %x %u %u\n", cmd_itt(cmnd),
+			cmnd->pdu.datasize, param->max_recv_data_length);
+
+		if (get_pgcnt(cmnd->pdu.datasize, 0) > ISCSI_CONN_IOV_MAX) {
+			conn_close(conn);
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+void cmnd_rx_start(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+	int err = 0;
+
+	if (check_segment_length(cmnd) < 0)
+		return;
+
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_NOOP_OUT:
+		err = noop_out_start(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_CMD:
+		if (!(err = cmnd_insert_hash(cmnd)))
+			scsi_cmnd_start(conn, cmnd);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+		err = cmnd_insert_hash(cmnd);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		data_out_start(conn, cmnd);
+		break;
+	case ISCSI_OP_LOGOUT:
+		err = cmnd_insert_hash(cmnd);
+		break;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
+		break;
+	default:
+		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
+		break;
+	}
+
+	if (err < 0) {
+		eprintk("%x %x %d\n", cmd_opcode(cmnd), cmd_itt(cmnd), err);
+		iscsi_cmnd_reject(cmnd, -err);
+	}
+}
+
+void cmnd_rx_end(struct istgt_cmd *cmnd)
+{
+	struct iscsi_conn *conn = cmnd->conn;
+
+	dprintk("%p:%x\n", cmnd, cmd_opcode(cmnd));
+	switch (cmd_opcode(cmnd)) {
+	case ISCSI_OP_SCSI_REJECT:
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_CMD:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_LOGOUT:
+		iscsi_session_push_cmnd(cmnd);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		data_out_end(conn, cmnd);
+		break;
+	case ISCSI_OP_SNACK:
+		break;
+	case ISCSI_OP_PDU_REJECT:
+		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
+		break;
+	case ISCSI_OP_DATA_REJECT:
+		cmnd_release(cmnd, 0);
+		break;
+	default:
+		eprintk("unexpected cmnd op %x\n", cmd_opcode(cmnd));
+		BUG();
+		break;
+	}
+}
+
+static int buffer_ready(struct scsi_cmnd *scmd,
+			void (*done)(struct scsi_cmnd *))
+{
+	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd->SCp.ptr;
+
+	cmnd->done = done;
+	complete(&cmnd->event);
+	return 0;
+}
+
+
+static struct iscsi_sess_param default_session_param = {
+	.initial_r2t = 1,
+	.immediate_data = 1,
+	.max_connections = 1,
+	.max_recv_data_length = 8192,
+	.max_xmit_data_length = 8192,
+	.max_burst_length = 262144,
+	.first_burst_length = 65536,
+	.default_wait_time = 2,
+	.default_retain_time = 20,
+	.max_outstanding_r2t = 1,
+	.data_pdu_inorder = 1,
+	.data_sequence_inorder = 1,
+	.error_recovery_level = 0,
+	.header_digest = DIGEST_NONE,
+	.data_digest = DIGEST_NONE,
+	.ofmarker = 0,
+	.ifmarker = 0,
+	.ofmarkint = 2048,
+	.ifmarkint = 2048,
+};
+
+static struct iscsi_trgt_param default_target_param = {
+	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
+};
+
+static struct iscsi_transport istgt_transport;
+
+static struct iscsi_cls_session *
+istgt_session_create(struct scsi_transport_template *scsit,
+		     uint32_t initial_cmdsn, uint32_t *sid)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_session *session;
+	nt err, i;
+
+	shost = iscsi_transport_create_session(scsit, &istgt_transport);
+	if (!shost)
+		return NULL;
+
+	session = iscsi_hostdata(shost->hostdata);
+	memset(session, 0, sizeof(*session));
+
+	dprintk("%p %u %" PRIx64 "\n", session, session->shost->host_no);
+
+	session->shost = shost;
+	*sid = session->sid = shost->host_no;
+	memcpy(&session->param, &default_session_param,
+	       sizeof(default_session_param));
+	memcpy(&session->trgt_param, &default_target_param,
+	       sizeof(default_target_param));
+	init_MUTEX(&session->target_sem);
+	INIT_LIST_HEAD(&session->session_list);
+
+	session->max_queued_cmnds = session->trgt_param.queued_cmnds;
+	session->exp_cmd_sn = initial_cmdsn + 1;
+	session->max_cmd_sn = initial_cmdsn + 1;
+
+	INIT_LIST_HEAD(&session->conn_list);
+	INIT_LIST_HEAD(&session->pending_list);
+
+	spin_lock_init(&session->cmnd_hash_lock);
+	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++)
+		INIT_LIST_HEAD(&session->cmnd_hash[i]);
+
+	session->next_ttt = 1;
+
+	nthread_init(session);
+	err = nthread_start(session);
+	if (err)
+		goto destroy_session;
+
+	return hostdata_session(shost->hostdata);
+
+destroy_session:
+	iscsi_transport_destroy_session(shost);
+	return NULL;
+}
+
+static void istgt_session_destroy(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
+	int i;
+
+	dprintk("%" PRIx64 "\n", session->sid);
+
+	if (!list_empty(&session->conn_list)) {
+		eprintk("%" PRIx64 " still have connections\n", session->sid);
+		BUG();
+	}
+
+	BUG_ON(!list_empty(&session->conn_list));
+
+	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++)
+		BUG_ON(!list_empty(&session->cmnd_hash[i]));
+
+	down(&session->target_sem);
+	up(&session->target_sem);
+
+	nthread_stop(session);
+	iscsi_transport_destroy_session(shost);
+}
+
+static int
+istgt_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param key, uint32_t *value)
+{
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_sess_param *param = &conn->session->param;
+
+	switch(key) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		*value = param->max_recv_data_length;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		*value = param->max_xmit_data_length;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		*value = param->header_digest;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		*value = param->data_digest;
+		break;
+	default:
+		return ISCSI_ERR_PARAM_NOT_FOUND;
+	}
+
+	return 0;
+}
+
+static int
+istgt_session_get_param(struct iscsi_cls_session *cls_session,
+			enum iscsi_param key, uint32_t *value)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
+	struct iscsi_sess_param *param = &session->param;
+
+	switch(key) {
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		*value = param->initial_r2t;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		*value = param->max_outstanding_r2t;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		*value = param->immediate_data;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		*value = param->first_burst_length;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		*value = param->max_burst_length;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		*value = param->data_pdu_inorder;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		*value = param->data_sequence_inorder;
+		break;
+	case ISCSI_PARAM_ERL:
+		*value = param->error_recovery_level;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		*value = param->ifmarker;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		*value = param->ofmarker;
+		break;
+	default:
+		return ISCSI_ERR_PARAM_NOT_FOUND;
+	}
+
+	return 0;
+}
+
+static int
+istgt_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param key,
+		uint32_t value)
+{
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_sess_param *param = &session->param;
+
+	switch(key) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		param->max_recv_data_length = value;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		param->max_xmit_data_length = value;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		param->header_digest = value;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		param->data_digest = value;
+		break;
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		param->initial_r2t = value;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		param->max_outstanding_r2t = value;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		param->immediate_data = value;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		param->first_burst_length = value;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		param->max_burst_length = value;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		param->data_pdu_inorder = value;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		param->data_sequence_inorder = value;
+		break;
+	case ISCSI_PARAM_ERL:
+		param->error_recovery_level = value;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		param->ifmarker = value;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		param->ofmarker = value;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static struct scsi_host_template istgt_sht = {
+	.name			= THIS_NAME,
+	.module			= THIS_MODULE,
+	.can_queue		= DEFAULT_NR_QUEUED_CMNDS,
+	.sg_tablesize		= SG_ALL,
+	.max_sectors		= 65536,	/* really no limit */
+	.use_clustering		= DISABLE_CLUSTERING, /* do we support this,  ihave to double check */
+	.transfer_response	= scsi_cmnd_done,
+	.transfer_data		= buffer_ready,
+};
+
+static struct iscsi_transport istgt_transport = {
+	.owner			= THIS_MODULE,
+	.name			= "tcp_tgt",
+	.host_template		= &istgt_sht,
+	.hostdata_size		= sizeof(struct iscsi_session),
+	.max_conn		= 1,
+	.max_cmd_len		= 16,
+	.create_session		= istgt_session_create,
+	.destroy_session	= istgt_session_destroy, 
+	.create_conn		= istgt_conn_create,
+	.destroy_conn		= istgt_conn_destroy,
+	.bind_conn		= istgt_conn_bind,
+	.start_conn		= istgt_conn_start,
+	.set_param		= istgt_set_param,
+	.get_session_param	= istgt_session_get_param,
+	.get_conn_param		= istgt_conn_get_param,
+
+};
+
+static void istgt_exit(void)
+{
+	kmem_cache_destroy(istgt_cmd_cache);
+	iscsi_unregister_transport(&istgt_transport);
+}
+
+static int istgt_init(void)
+{
+	printk("iSCSI Target Software for Linux Target Framework %s\n",
+	       VERSION_STRING);
+
+	istgt_cmd_cache = kmem_cache_create("istgt_cmd",
+					    sizeof(struct istgt_cmd),
+					    0, 0, NULL, NULL);
+	if (!istgt_cmd_cache)
+		return -ENOMEM;
+
+	if (!iscsi_register_transport(&istgt_transport))
+		goto free_cmd_cache;
+
+	return 0;
+
+free_cmd_cache:
+	kmem_cache_destroy(istgt_cmd_cache);
+	return -ENOMEM;
+
+}
+
+module_init(istgt_init);
+module_exit(istgt_exit);
+
+MODULE_LICENSE("GPL");



From mnc at berlios.de  Mon Jan 30 00:33:11 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Mon, 30 Jan 2006 00:33:11 +0100
Subject: [Stgt-svn] r248 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200601292333.k0TNXBVQ007880@sheep.berlios.de>

Author: mnc
Date: 2006-01-30 00:33:11 +0100 (Mon, 30 Jan 2006)
New Revision: 248

Removed:
   branches/use-scsi-ml/istgt/kernel/session.c
Log:
rm session.c

Deleted: branches/use-scsi-ml/istgt/kernel/session.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/session.c	2006-01-29 23:32:01 UTC (rev 247)
+++ branches/use-scsi-ml/istgt/kernel/session.c	2006-01-29 23:33:11 UTC (rev 248)
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <linux/mempool.h>
-
-#include <iscsi.h>
-
-struct iscsi_session *session_lookup(struct iscsi_target *target, uint64_t sid)
-{
-	struct iscsi_session *session;
-
-	list_for_each_entry(session, &target->session_list, list) {
-		if (session->sid == sid)
-			return session;
-	}
-	return NULL;
-}
-
-struct session_wait {
-	struct completion event;
-	struct tgt_session *ts;
-};
-
-static void session_done(void *arg, struct tgt_session *session)
-{
-	struct session_wait *w = (struct session_wait *) arg;
-
-	w->ts = session;
-	complete(&w->event);
-}
-
-int session_add(struct iscsi_target *target, struct session_info *info)
-{
-	struct iscsi_session *session;
-	struct session_wait w;
-	int i;
-
-	dprintk("%p %u %" PRIx64 "\n", target, target->tid, info->sid);
-
-	session = session_lookup(target, info->sid);
-	if (session)
-		return -EEXIST;
-
-	session = kzalloc(sizeof(*session), GFP_KERNEL);
-	if (!session)
-		return -ENOMEM;
-
-	init_completion(&w.event);
-	if (tgt_session_create(target->tt, session_done, &w))
-		goto kfree_session;
-	wait_for_completion(&w.event);
-	if (!w.ts)
-		goto kfree_session;
-
-	session->ts = w.ts;
-	session->target = target;
-	session->sid = info->sid;
-	memcpy(&session->param, &target->sess_param, sizeof(session->param));
-	session->max_queued_cmnds = target->trgt_param.queued_cmnds;
-
-	session->exp_cmd_sn = info->exp_cmd_sn;
-	session->max_cmd_sn = info->max_cmd_sn;
-
-	INIT_LIST_HEAD(&session->conn_list);
-	INIT_LIST_HEAD(&session->pending_list);
-
-	spin_lock_init(&session->cmnd_hash_lock);
-	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++)
-		INIT_LIST_HEAD(&session->cmnd_hash[i]);
-
-	session->next_ttt = 1;
-
-	list_add(&session->list, &target->session_list);
-
-	return 0;
-kfree_session:
-	kfree(session);
-	return -ENOMEM;
-}
-
-int session_del(struct iscsi_target *target, uint64_t sid)
-{
-	int i;
-	struct iscsi_session *session;
-
-	session = session_lookup(target, sid);
-	if (!session)
-		return -ENOENT;
-
-	dprintk("%" PRIx64 "\n", session->sid);
-
-	if (!list_empty(&session->conn_list)) {
-		eprintk("%" PRIx64 " still have connections\n", session->sid);
-		return -EBUSY;
-	}
-
-	BUG_ON(!list_empty(&session->conn_list));
-
-	for (i = 0; i < ARRAY_SIZE(session->cmnd_hash); i++)
-		BUG_ON(!list_empty(&session->cmnd_hash[i]));
-
-	list_del(&session->list);
-
-	tgt_session_destroy(session->ts, NULL, NULL);
-	kfree(session);
-
-	return 0;
-}



From mnc at berlios.de  Mon Jan 30 00:33:36 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Mon, 30 Jan 2006 00:33:36 +0100
Subject: [Stgt-svn] r249 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200601292333.k0TNXaF5008115@sheep.berlios.de>

Author: mnc
Date: 2006-01-30 00:33:35 +0100 (Mon, 30 Jan 2006)
New Revision: 249

Removed:
   branches/use-scsi-ml/istgt/kernel/config.c
Log:
rm config.c

Deleted: branches/use-scsi-ml/istgt/kernel/config.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/config.c	2006-01-29 23:33:11 UTC (rev 248)
+++ branches/use-scsi-ml/istgt/kernel/config.c	2006-01-29 23:33:35 UTC (rev 249)
@@ -1,91 +0,0 @@
-/*
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This code is licenced under the GPL.
- */
-
-#include <iscsi.h>
-
-static int add_conn(struct iscsi_target *target, struct conn_info *info)
-{
-	struct iscsi_session *session;
-
-	session = session_lookup(target, info->sid);
-	if (!session)
-		return -ENOENT;
-
-	return conn_add(session, info);
-}
-
-static int del_conn(struct iscsi_target *target, struct conn_info *info)
-{
-	struct iscsi_session *session;
-
-	session = session_lookup(target, info->sid);
-	if (!session)
-		return -ENOENT;
-
-	return conn_del(session, info);
-}
-
-int iet_msg_recv(struct tgt_target *tgt, uint32_t len, void *data)
-{
-	struct iscsi_target *target = tgt->tt_data;
-	struct iet_msg *msg = data;
-	int err;
-
-	err = down_interruptible(&target->target_sem);
-	if (err < 0) {
-		eprintk("interrupted %u %d\n", err, msg->msg_type);
-		goto done;
-	}
-
-	eprintk("msg_type %d\n", msg->msg_type);
-
-	switch (msg->msg_type) {
-	case IET_ADD_SESSION:
-		err = session_add(target, &msg->u.sess_info);
-		break;
-
-	case IET_DEL_SESSION:
-		err = session_del(target, msg->u.sess_info.sid);
-		break;
-
-	case IET_ISCSI_PARAM_SET:
-		err = iscsi_param_set(target, &msg->u.param_info, 1);
-		break;
-
-	case IET_ISCSI_PARAM_GET:
-		err = iscsi_param_set(target, &msg->u.param_info, 0);
-		break;
-
-	case IET_ADD_CONN:
-		err = add_conn(target, &msg->u.conn_info);
-		break;
-
-	case IET_DEL_CONN:
-		err = del_conn(target, &msg->u.conn_info);
-		break;
-	default:
-		err = -EINVAL;
-	}
-
-	up(&target->target_sem);
-done:
-	msg->result = err;
-	tgt_msg_send(tgt, msg, sizeof(*msg), GFP_KERNEL);
-	return err;
-}
-
-int event_send(struct tgt_target *tgt, uint64_t sid, uint32_t cid,
-	       uint32_t state)
-{
-	struct iet_msg msg;
-
-	msg.k.conn_state_change.tid = tgt->tid;
-	msg.k.conn_state_change.sid = sid;
-	msg.k.conn_state_change.cid = cid;
-	msg.k.conn_state_change.state = state;
-
-	return tgt_msg_send(tgt, &msg, sizeof(msg), GFP_ATOMIC);
-}



From mnc at berlios.de  Mon Jan 30 00:34:04 2006
From: mnc at berlios.de (mnc at BerliOS)
Date: Mon, 30 Jan 2006 00:34:04 +0100
Subject: [Stgt-svn] r250 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200601292334.k0TNY4cd008285@sheep.berlios.de>

Author: mnc
Date: 2006-01-30 00:33:56 +0100 (Mon, 30 Jan 2006)
New Revision: 250

Removed:
   branches/use-scsi-ml/istgt/kernel/param.c
Log:
rm param.c

Deleted: branches/use-scsi-ml/istgt/kernel/param.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/param.c	2006-01-29 23:33:35 UTC (rev 249)
+++ branches/use-scsi-ml/istgt/kernel/param.c	2006-01-29 23:33:56 UTC (rev 250)
@@ -1,181 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This code is licenced under the GPL.
- */
-
-#include <iscsi.h>
-#include <digest.h>
-
-#define	CHECK_PARAM(info, iparam, word, min, max)			\
-do {									\
-	if (!info->partial || (info->partial & 1 << key_##word))	\
-		if (iparam[key_##word] < min ||				\
-			iparam[key_##word] > max) {			\
-			eprintk("%s: %u is out of range (%u %u)\n",	\
-				#word, iparam[key_##word], min, max);	\
-			iparam[key_##word] = min;			\
-		}							\
-} while (0)
-
-#define	SET_PARAM(param, info, iparam, word)				\
-({									\
-	int changed = 0;						\
-	if (!info->partial || (info->partial & 1 << key_##word)) {	\
-		if (param->word != iparam[key_##word])			\
-			changed = 1;					\
-		param->word = iparam[key_##word];			\
-	}								\
-	changed;							\
-})
-
-#define	GET_PARAM(param, info, iparam, word)				\
-do {									\
-	iparam[key_##word] = param->word;				\
-} while (0)
-
-static void sess_param_check(struct iscsi_param_info *info)
-{
-	uint32_t *iparam = info->session_param;
-
-	CHECK_PARAM(info, iparam, max_connections, 1, 65535);
-	CHECK_PARAM(info, iparam, max_recv_data_length, 512,
-		    (uint32_t) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
-	CHECK_PARAM(info, iparam, max_xmit_data_length, 512,
-		    (uint32_t) ((ISCSI_CONN_IOV_MAX - 1) * PAGE_CACHE_SIZE));
-	CHECK_PARAM(info, iparam, error_recovery_level, 0, 0);
-	CHECK_PARAM(info, iparam, data_pdu_inorder, 1, 1);
-	CHECK_PARAM(info, iparam, data_sequence_inorder, 1, 1);
-
-	digest_alg_available(&iparam[key_header_digest]);
-	digest_alg_available(&iparam[key_data_digest]);
-
-	CHECK_PARAM(info, iparam, ofmarker, 0, 0);
-	CHECK_PARAM(info, iparam, ifmarker, 0, 0);
-}
-
-static void sess_param_set(struct iscsi_sess_param *param, struct iscsi_param_info *info)
-{
-	uint32_t *iparam = info->session_param;
-
-	SET_PARAM(param, info, iparam, initial_r2t);
-	SET_PARAM(param, info, iparam, immediate_data);
-	SET_PARAM(param, info, iparam, max_connections);
-	SET_PARAM(param, info, iparam, max_recv_data_length);
-	SET_PARAM(param, info, iparam, max_xmit_data_length);
-	SET_PARAM(param, info, iparam, max_burst_length);
-	SET_PARAM(param, info, iparam, first_burst_length);
-	SET_PARAM(param, info, iparam, default_wait_time);
-	SET_PARAM(param, info, iparam, default_retain_time);
-	SET_PARAM(param, info, iparam, max_outstanding_r2t);
-	SET_PARAM(param, info, iparam, data_pdu_inorder);
-	SET_PARAM(param, info, iparam, data_sequence_inorder);
-	SET_PARAM(param, info, iparam, error_recovery_level);
-	SET_PARAM(param, info, iparam, header_digest);
-	SET_PARAM(param, info, iparam, data_digest);
-	SET_PARAM(param, info, iparam, ofmarker);
-	SET_PARAM(param, info, iparam, ifmarker);
-	SET_PARAM(param, info, iparam, ofmarkint);
-	SET_PARAM(param, info, iparam, ifmarkint);
-}
-
-static void sess_param_get(struct iscsi_sess_param *param, struct iscsi_param_info *info)
-{
-	uint32_t *iparam = info->session_param;
-
-	GET_PARAM(param, info, iparam, initial_r2t);
-	GET_PARAM(param, info, iparam, immediate_data);
-	GET_PARAM(param, info, iparam, max_connections);
-	GET_PARAM(param, info, iparam, max_recv_data_length);
-	GET_PARAM(param, info, iparam, max_xmit_data_length);
-	GET_PARAM(param, info, iparam, max_burst_length);
-	GET_PARAM(param, info, iparam, first_burst_length);
-	GET_PARAM(param, info, iparam, default_wait_time);
-	GET_PARAM(param, info, iparam, default_retain_time);
-	GET_PARAM(param, info, iparam, max_outstanding_r2t);
-	GET_PARAM(param, info, iparam, data_pdu_inorder);
-	GET_PARAM(param, info, iparam, data_sequence_inorder);
-	GET_PARAM(param, info, iparam, error_recovery_level);
-	GET_PARAM(param, info, iparam, header_digest);
-	GET_PARAM(param, info, iparam, data_digest);
-	GET_PARAM(param, info, iparam, ofmarker);
-	GET_PARAM(param, info, iparam, ifmarker);
-	GET_PARAM(param, info, iparam, ofmarkint);
-	GET_PARAM(param, info, iparam, ifmarkint);
-}
-
-static void trgt_param_check(struct iscsi_param_info *info)
-{
-	uint32_t *iparam = info->target_param;
-
-	CHECK_PARAM(info, iparam, queued_cmnds, MIN_NR_QUEUED_CMNDS, MAX_NR_QUEUED_CMNDS);
-}
-
-static void trgt_param_set(struct iscsi_target *target, struct iscsi_param_info *info)
-{
-	struct iscsi_trgt_param *param = &target->trgt_param;
-	uint32_t *iparam = info->target_param;
-
-	SET_PARAM(param, info, iparam, queued_cmnds);
-}
-
-static void trgt_param_get(struct iscsi_trgt_param *param, struct iscsi_param_info *info)
-{
-	uint32_t *iparam = info->target_param;
-
-	GET_PARAM(param, info, iparam, queued_cmnds);
-}
-
-static int trgt_param(struct iscsi_target *target, struct iscsi_param_info *info, int set)
-{
-
-	if (set) {
-		trgt_param_check(info);
-		trgt_param_set(target, info);
-	} else
-		trgt_param_get(&target->trgt_param, info);
-
-	return 0;
-}
-
-static int sess_param(struct iscsi_target *target, struct iscsi_param_info *info, int set)
-{
-	struct iscsi_session *session = NULL;
-	struct iscsi_sess_param *param;
-	int err = -ENOENT;
-
-	if (set)
-		sess_param_check(info);
-
-	if (info->sid) {
-		if (!(session = session_lookup(target, info->sid)))
-			goto out;
-		param = &session->param;
-	} else {
-		param = &target->sess_param;
-	}
-
-	if (set) {
-		sess_param_set(param, info);
-		show_param(param);
-	} else
-		sess_param_get(param, info);
-
-	err = 0;
-out:
-	return err;
-}
-
-int iscsi_param_set(struct iscsi_target *target, struct iscsi_param_info *info, int set)
-{
-	int err;
-
-	if (info->param_type == key_session)
-		err = sess_param(target, info, set);
-	else if (info->param_type == key_target)
-		err = trgt_param(target, info, set);
-	else
-		err = -EINVAL;
-
-	return err;
-}



From tomo at berlios.de  Tue Jan 31 00:50:30 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 31 Jan 2006 00:50:30 +0100
Subject: [Stgt-svn] r251 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200601302350.k0UNoUqE009854@sheep.berlios.de>

Author: tomo
Date: 2006-01-31 00:50:28 +0100 (Tue, 31 Jan 2006)
New Revision: 251

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Update ibmvstgt for the scsi-ml model.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-01-29 23:33:56 UTC (rev 250)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-01-30 23:50:28 UTC (rev 251)
@@ -4,25 +4,37 @@
  *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
  *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
  *
- * Rewritten for Linux target framework by FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 - 2006 FUJITA Tomonori <tomof at acm.org>
  *
- * This code is licenced under the GPL2.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
  */
 
+#include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/mempool.h>
 #include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
-#include <linux/mempool.h>
+#include <scsi/scsi_tgt.h>
 
 #include <asm/hvcall.h>
-#include <asm/vio.h>
 #include <asm/iommu.h>
 #include <asm/prom.h>
+#include <asm/vio.h>
 
-#include <tgt.h>
-#include <tgt_target.h>
-#include <tgt_scsi.h>
-
 #include "viosrp.h"
 
 #define DEFAULT_TIMEOUT		30*HZ
@@ -54,7 +66,14 @@
 MODULE_AUTHOR("Dave Boutcher");
 MODULE_LICENSE("GPL");
 
+/* tmp - will replace with SCSI logging stuff */
+#define dprintk(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+} while (0)
 
+#define eprintk dprintk
+
 /*
  * an RPA command/response transport queue.  This is our structure
  * that points to the actual queue (not architected by firmware)
@@ -83,9 +102,7 @@
 	unsigned long riobn;
 
 	int max_sectors;
-
-	struct tgt_target *tt;
-	struct tgt_session *ts;
+	struct Scsi_Host *shost;
 };
 
 enum iue_flags {
@@ -116,8 +133,6 @@
 		int data_in_residual_count;
 		int timeout;
 	} req;
-
-	struct tgt_cmd *tc;
 };
 
 
@@ -295,17 +310,19 @@
 
 static int process_cmd(struct iu_entry *iue)
 {
-	struct tgt_target *tt = iue->adapter->tt;
+	struct Scsi_host *shost = iue->adapter->shost;
 	union viosrp_iu *iu = vio_iu(iue);
 	enum dma_data_direction data_dir;
+	struct scsi_cmnd *scmd;
 	int tags, len;
-	uint8_t lun[8];
 
-	dprintk("%p %p %p\n", tt, iue->adapter, iue);
+	dprintk("%p %p\n", iue->adapter, iue);
 
 	if (getlink(iue))
 		__set_bit(V_LINKED, &iue->req.flags);
 
+	tags = MSG_SIMPLE_TAG;
+#if 0
 	switch (iu->srp.cmd.task_attribute) {
 	case SRP_SIMPLE_TASK:
 		tags = MSG_SIMPLE_TAG;
@@ -321,7 +338,7 @@
 			iu->srp.cmd.task_attribute);
 		tags = MSG_ORDERED_TAG;
 	}
-
+#endif
 	switch (iu->srp.cmd.cdb[0]) {
 	case WRITE_6:
 	case WRITE_10:
@@ -331,12 +348,6 @@
 		__set_bit(V_WRITE, &iue->req.flags);
 	}
 
-	memset(lun, 0, sizeof(lun));
-	/* FIXME */
-	lun[1] = GETLUN(iu->srp.cmd.lun);
-	if (GETBUS(iu->srp.cmd.lun) || GETTARGET(iu->srp.cmd.lun))
-		lun[0] = 3 << 6;
-
 	if (iu->srp.cmd.data_out_format) {
 		data_dir = DMA_TO_DEVICE;
 		len = vscsis_data_length(&iu->srp.cmd, 1);
@@ -345,15 +356,15 @@
 		len = vscsis_data_length(&iu->srp.cmd, 0);
 	}
 
-	dprintk("%p %x %lx %d %d %x %d\n",
-		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, lun[1], tags);
+	dprintk("%p %x %lx %d %d %d\n",
+		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tags);
 
-	BUG_ON(!iue->adapter->ts);
-	iue->tc = tgt_cmd_create(iue->adapter->ts, iue, iu->srp.cmd.cdb,
-				 len, data_dir, lun, sizeof(lun), tags);
-	BUG_ON(!iue->tc);
-	dprintk("%p\n", iue->tc);
+	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
+	BUG_ON(!scmd);
 
+	scmd->SCp.ptr = (char *) iue;
+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) iu->srp.cmd.lun, 0);
+
 	return 0;
 }
 
@@ -379,25 +390,27 @@
 #define SEND	0
 #define RECV	1
 
-static int direct_data(struct tgt_cmd *tc, struct memory_descriptor *md, int op)
+static int direct_data(struct scsi_cmnd *scmd, struct memory_descriptor *md,
+		       int op)
 {
-	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
-	struct scatterlist *sg = tc->sg;
+	struct scatterlist *sg = scmd->request_buffer;
 	unsigned int rest, len;
 	int i, done, nsg;
 	long err;
 	dma_addr_t token;
 
-	dprintk("%p %u %u %d\n", iue, tc->bufflen, md->length, tc->sg_count);
+	dprintk("%p %u %u %d\n", iue, scmd->request_bufflen,
+		md->length, scmd->use_sg);
 
-	nsg = dma_map_sg(adapter->dev, sg, tc->sg_count, DMA_BIDIRECTIONAL);
+	nsg = dma_map_sg(adapter->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
 	if (!nsg) {
-		eprintk("fail to map %p %d\n", iue, tc->sg_count);
+		eprintk("fail to map %p %d\n", iue, scmd->use_sg);
 		return 0;
 	}
 
-	rest = min(tc->bufflen, md->length);
+	rest = min(scmd->request_bufflen, md->length);
 
 	for (i = 0, done = 0; i < nsg && rest; i++) {
 		token = sg_dma_address(sg + i);
@@ -428,14 +441,14 @@
 	return done;
 }
 
-static int indirect_data(struct tgt_cmd *tc, struct indirect_descriptor *id,
+static int indirect_data(struct scsi_cmnd *scmd, struct indirect_descriptor *id,
 			 int op)
 {
-	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
 	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
 	struct memory_descriptor *mds;
-	struct scatterlist *sg = tc->sg;
+	struct scatterlist *sg = scmd->request_buffer;
 	dma_addr_t token, itoken = 0;
 	long err;
 	unsigned int rest, done = 0;
@@ -443,8 +456,8 @@
 
 	nmd = id->head.length / sizeof(struct memory_descriptor);
 
-	dprintk("%p %u %u %lu %d %d %d\n",
-		iue, tc->bufflen, id->total_length, tc->offset, nmd,
+	dprintk("%p %u %u %u %d %d %d\n",
+		iue, scmd->request_bufflen, id->total_length, scmd->offset, nmd,
 		cmd->data_in_count, cmd->data_out_count);
 
 	if ((op == SEND && nmd == cmd->data_in_count) ||
@@ -468,15 +481,15 @@
 	}
 
 rdma:
-	nsg = dma_map_sg(adapter->dev, sg, tc->sg_count, DMA_BIDIRECTIONAL);
+	nsg = dma_map_sg(adapter->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
 	if (!nsg) {
-		eprintk("fail to map %p %d\n", iue, tc->sg_count);
+		eprintk("fail to map %p %d\n", iue, scmd->use_sg);
 		goto free_mem;
 	}
 
 	sidx = soff = 0;
 	token = sg_dma_address(sg + sidx);
-	rest = min(tc->bufflen, id->total_length);
+	rest = min(scmd->request_bufflen, id->total_length);
 	for (i = 0; i < nmd && rest; i++) {
 		unsigned int mdone, mlen;
 
@@ -514,7 +527,7 @@
 
 				if (sidx > nsg) {
 					eprintk("out of sg %p %d %d %d\n",
-						iue, sidx, nsg, tc->sg_count);
+						iue, sidx, nsg, scmd->use_sg);
 					goto unmap_sg;
 				}
 			}
@@ -533,9 +546,9 @@
 	return done;
 }
 
-static int handle_cmd_data(struct tgt_cmd *tc, int op)
+static int handle_cmd_data(struct scsi_cmnd *scmd, int op)
 {
-	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
 	struct memory_descriptor *md;
 	struct indirect_descriptor *id;
@@ -554,12 +567,12 @@
 	case SRP_DIRECT_BUFFER:
 		md = (struct memory_descriptor *)
 			(cmd->additional_data + offset);
-		err = direct_data(tc, md, op);
+		err = direct_data(scmd, md, op);
 		break;
 	case SRP_INDIRECT_BUFFER:
 		id = (struct indirect_descriptor *)
 			(cmd->additional_data + offset);
-		err = indirect_data(tc, id, op);
+		err = indirect_data(scmd, id, op);
 		break;
 	default:
 		eprintk("Unknown format %d %d\n", op, format);
@@ -569,13 +582,12 @@
 	return err;
 }
 
-static int recv_cmd_data(struct tgt_cmd *tc)
+static int recv_cmd_data(struct scsi_cmnd *scmd,
+			 void (*done)(struct scsi_cmnd *))
 {
-	dprintk("%p\n", tc);
-
-	handle_cmd_data(tc, RECV);
-	tc->done(tc);
-
+	/* TODO: this can be called multiple times for a single command. */
+	handle_cmd_data(scmd, RECV);
+	done(scmd);
 	return 0;
 }
 
@@ -590,7 +602,6 @@
 	memset(&iue->req, 0, sizeof(iue->req));
 	iue->adapter = adapter;
 	INIT_LIST_HEAD(&iue->ilist);
-	iue->tc = NULL;
 
 	iue->iu_token = dma_map_single(adapter->dev, vio_iu(iue),
 				       sizeof(union viosrp_iu),
@@ -609,31 +620,28 @@
 
 	dprintk("%p %p\n", adapter, iue);
 
-	if (iue->tc)
-		iue->tc->done(iue->tc);
-
 	dma_unmap_single(adapter->dev, iue->iu_token,
 			 sizeof(union viosrp_iu), DMA_BIDIRECTIONAL);
-
 	mempool_free(iue, adapter->iu_pool);
 }
 
-static int ibmvstgt_cmd_done(struct tgt_cmd *tc)
+static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
+			     void (*done)(struct scsi_cmnd *))
 {
 	int sent = 0;
 	unsigned long flags;
-	struct iu_entry *iue = (struct iu_entry *) tc->private;
+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
 
-	dprintk("%p %p %p %x\n", tc, iue, adapter, vio_iu(iue)->srp.cmd.cdb[0]);
+	dprintk("%p %p %x\n", iue, adapter, vio_iu(iue)->srp.cmd.cdb[0]);
 
 	spin_lock_irqsave(&adapter->lock, flags);
 	list_del(&iue->ilist);
 	spin_unlock_irqrestore(&adapter->lock, flags);
 
-	if (tc->result != SAM_STAT_GOOD) {
+	if (scmd->result != SAM_STAT_GOOD) {
 		eprintk("operation failed %p %d %x\n",
-			iue, tc->result, vio_iu(iue)->srp.cmd.cdb[0]);
+			iue, scmd->result, vio_iu(iue)->srp.cmd.cdb[0]);
 		send_rsp(iue, HARDWARE_ERROR, 0x00);
 		goto out;
 	}
@@ -661,18 +669,19 @@
 		break;
 	}
 
-	sent = handle_cmd_data(tc, SEND);
-	if (sent != tc->bufflen) {
+	sent = handle_cmd_data(scmd, SEND);
+	if (sent != scmd->request_bufflen) {
 		eprintk("sending data on response %p (tried %u, sent %d\n",
-			iue, tc->bufflen, sent);
+			iue, scmd->request_bufflen, sent);
 		send_rsp(iue, ABORTED_COMMAND, 0x00);
 	} else
 		send_rsp(iue, NO_SENSE, 0x00);
 
 out:
+	done(scmd);
 	put_iu(iue);
 
-	return TGT_CMD_XMIT_OK;
+	return 0;
 }
 
 int send_adapter_info(struct iu_entry *iue,
@@ -1069,23 +1078,20 @@
 	handle_cmd_queue(adapter);
 }
 
-struct session_wait {
-	struct completion event;
-	struct tgt_session *ts;
+static struct scsi_host_template ibmvstgt_sht = {
+	.name			= TGT_NAME,
+	.module			= THIS_MODULE,
+	.can_queue		= INITIAL_SRP_LIMIT,
+	.sg_tablesize		= SG_ALL,
+	.use_clustering		= DISABLE_CLUSTERING,
+	.max_sectors		= DEFAULT_MAX_SECTORS,
+	.transfer_response	= ibmvstgt_cmd_done,
+	.transfer_data		= recv_cmd_data,
 };
 
-static void session_done(void *arg, struct tgt_session *session)
-{
-	struct session_wait *w = (struct session_wait *) arg;
-
-	w->ts = session;
-	complete(&w->event);
-}
-
 static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
 {
-	struct tgt_target *tt;
-	struct session_wait w;
+	struct Scsi_Host *shost;
 	struct server_adapter *adapter;
 	unsigned int *dma, dma_size;
 	int err = -ENOMEM;
@@ -1093,15 +1099,14 @@
 	dprintk("%s %s %x %u\n", dev->name, dev->type,
 		dev->unit_address, dev->irq);
 
-	tt = tgt_target_create(TGT_NAME, INITIAL_SRP_LIMIT);
-	if (!tt)
+	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct server_adapter));
+	if (!shost)
 		return err;
+	if (scsi_tgt_alloc_queue(shost))
+		goto put_host;
 
-	adapter = tt->tt_data;
-
-	dprintk("%p %p\n", tt, adapter);
-
-	adapter->tt = tt;
+	adapter = (struct server_adapter *) shost->hostdata;
+	adapter->shost = shost;
 	adapter->dma_dev = dev;
 	adapter->dev = &dev->dev;
 	adapter->dev->driver_data = adapter;
@@ -1114,7 +1119,7 @@
 	if (!dma || dma_size != 40) {
 		eprintk("Couldn't get window property %d\n", dma_size);
 		err = -EIO;
-		goto free_tt;
+		goto put_host;
 	}
 
 	adapter->liobn = dma[0];
@@ -1123,31 +1128,26 @@
 	INIT_WORK(&adapter->crq_work, handle_crq, adapter);
 	INIT_LIST_HEAD(&adapter->cmd_queue);
 
-	init_completion(&w.event);
-	if (tgt_session_create(tt, session_done, &w))
-		goto free_tt;
-	wait_for_completion(&w.event);
-	if (!w.ts)
-		goto free_tt;
-	adapter->ts = w.ts;
 	adapter->iu_pool = mempool_create(INITIAL_SRP_LIMIT,
 					  mempool_alloc_slab,
 					  mempool_free_slab, iu_cache);
 	if (!adapter->iu_pool)
-		goto free_ts;
+		goto put_host;
 
 	err = crq_queue_create(&adapter->crq_queue, adapter);
 	if (err)
 		goto free_pool;
 
+	if (scsi_add_host(shost, adapter->dev))
+		goto destroy_queue;
 	return 0;
 
+destroy_queue:
+	crq_queue_destroy(adapter);
 free_pool:
 	mempool_destroy(adapter->iu_pool);
-free_ts:
-	tgt_session_destroy(adapter->ts, NULL, NULL);
-free_tt:
-	tgt_target_destroy(tt);
+put_host:
+	scsi_host_put(shost);
 
 	return err;
 }
@@ -1156,27 +1156,16 @@
 {
 	struct server_adapter *adapter =
 		(struct server_adapter *) dev->dev.driver_data;
-	struct tgt_target *tt = adapter->tt;
+	struct Scsi_Host *shost = adapter->shost;
 
+	scsi_remove_host(shost);
+	scsi_host_put(shost);
 	crq_queue_destroy(adapter);
 	mempool_destroy(adapter->iu_pool);
-	tgt_session_destroy(adapter->ts, NULL, NULL);
 
-	tgt_target_destroy(tt);
-
 	return 0;
 }
 
-static struct tgt_target_template ibmvstgt_template = {
-	.name = TGT_NAME,
-	.module = THIS_MODULE,
-	.protocol = "scsi",
-	.subprotocol = "rdma",
-	.transfer_response = ibmvstgt_cmd_done,
-	.transfer_write_data = recv_cmd_data,
-	.priv_data_size = sizeof(struct server_adapter),
-};
-
 static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
 	{"v-scsi-host", "IBM,v-scsi-host"},
 	{"",""}
@@ -1185,10 +1174,13 @@
 MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
 
 static struct vio_driver ibmvstgt_driver = {
-	.name = "ibmvscsi",
 	.id_table = ibmvstgt_device_table,
 	.probe = ibmvstgt_probe,
 	.remove = ibmvstgt_remove,
+	.driver = {
+		.name = "ibmvscsi",
+		.owner = THIS_MODULE,
+	}
 };
 
 static int get_system_info(void)
@@ -1231,23 +1223,17 @@
 	if (!iu_cache)
 		return -ENOMEM;
 
-	err = tgt_target_template_register(&ibmvstgt_template);
-	if (err < 0)
-		goto iu_cache;
-
 	err = get_system_info();
 	if (err < 0)
-		goto unregister_template;
+		goto free_iu_cache;
 
 	err = vio_register_driver(&ibmvstgt_driver);
 	if (err)
-		goto unregister_template;
+		goto free_iu_cache;
 
 	return 0;
 
-unregister_template:
-	tgt_target_template_unregister(&ibmvstgt_template);
-iu_cache:
+free_iu_cache:
 	kmem_cache_destroy(iu_cache);
 
 	return err;
@@ -1258,7 +1244,6 @@
 	printk("Unregister IBM virtual SCSI driver\n");
 
 	vio_unregister_driver(&ibmvstgt_driver);
-	tgt_target_template_unregister(&ibmvstgt_template);
 	kmem_cache_destroy(iu_cache);
 }
 



