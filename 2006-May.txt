From tomo at berlios.de  Tue May  2 13:35:36 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 2 May 2006 13:35:36 +0200
Subject: [Stgt-svn] r444 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605021135.k42BZaqI022394@sheep.berlios.de>

Author: tomo
Date: 2006-05-02 13:35:33 +0200 (Tue, 02 May 2006)
New Revision: 444

Modified:
   branches/use-scsi-ml/istgt/kernel/Makefile
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Update, still broken.


Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-04-29 16:45:06 UTC (rev 443)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-05-02 11:35:33 UTC (rev 444)
@@ -10,8 +10,8 @@
 EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include
 
 ifneq ($(KERNELRELEASE),)
-obj-m			+= iscsi_tcp_tgt.o
-iscsi_tcp_tgt-objs	:= iscsi_tcp.o
+obj-m			+= istgt_tcp.o
+istgt_tcp-objs		:= iscsi_tcp_tgt.o iscsi_tcp.o
 obj-m			+= scsi_transport_iscsi.o
 obj-m			+= libiscsi.o
 else

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-04-29 16:45:06 UTC (rev 443)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-02 11:35:33 UTC (rev 444)
@@ -70,7 +70,7 @@
 /* global data */
 static kmem_cache_t *taskcache;
 
-static inline void
+inline void
 iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
 	sg_init_one(&ibuf->sg, (u8 *)vbuf, size);
@@ -88,7 +88,7 @@
 	ibuf->use_sendmsg = 1;
 }
 
-static inline void
+inline void
 iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
 {
 	ibuf->sg.page = sg->page;
@@ -659,7 +659,7 @@
  *	The function calls skb_copy_bits() and updates per-connection
  *	byte counters.
  **/
-inline int
+static inline int
 iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn)
 {
 	void *buf = tcp_conn->data;
@@ -911,9 +911,6 @@
 		}
 	}
 
-	if (conn->suspend_rx)
-		goto nomore;
-
 	if (tcp_conn->in_progress == IN_PROGRESS_DDIGEST_RECV) {
 		uint32_t recv_digest;
 
@@ -976,9 +973,6 @@
 	       tcp_conn->in.offset - offset, (int)len, tcp_conn->in.padding);
 	BUG_ON(tcp_conn->in.offset - offset > len);
 
-	if (d->finish)
-		d->finish(conn);
-
 	if (tcp_conn->in.offset - offset != len) {
 		debug_tcp("continue to process %d bytes\n",
 		       (int)len - (tcp_conn->in.offset - offset));
@@ -1138,7 +1132,7 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-static inline int
+inline int
 iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 {
 	struct iscsi_tcp_conn *tcp_conn;
@@ -1178,7 +1172,7 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-static inline int
+inline int
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent)
 {

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-04-29 16:45:06 UTC (rev 443)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-02 11:35:33 UTC (rev 444)
@@ -181,7 +181,6 @@
 	struct iscsi_conn *conn;
 	int (* hdr_recv)(struct iscsi_conn *conn);
 	int (* data_recv)(struct iscsi_conn *conn);
-	int (* finish)(struct iscsi_conn *conn);
 };
 
 #endif /* ISCSI_H */

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-04-29 16:45:06 UTC (rev 443)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-02 11:35:33 UTC (rev 444)
@@ -4,8 +4,7 @@
 
 extern struct iscsi_cls_conn *
 iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx);
-extern static void
-iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn);
+extern void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn);
 extern int iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 			       struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
 			       int is_leading);
@@ -17,13 +16,23 @@
 			 uint32_t initial_cmdsn, uint32_t *hostno);
 extern void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session);
 
-extern inline int iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn);
+extern int iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn);
 extern int iscsi_scsi_data_in(struct iscsi_conn *conn);
-extern inline int iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn);
 
 extern int iscsi_tcp_hdr_recv_pre(struct iscsi_conn *conn);
 extern int iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 			       unsigned int offset, size_t len);
 
+extern void
+iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size);
+extern void
+iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg);
+
+extern int
+iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen);
+extern int
+iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
+	       int *count, int *sent);
+
 extern int iscsi_tcp_init(void);
 extern void iscsi_tcp_exit(void);

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-04-29 16:45:06 UTC (rev 443)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-02 11:35:33 UTC (rev 444)
@@ -27,10 +27,10 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi.h>
-#include <iscsi_tcp.h>
-#include <scsi/libiscsi.h>
 #include <scsi/scsi_tgt.h>
 #include <scsi/scsi_tcq.h>
+#include "iscsi_tcp.h"
+#include "libiscsi.h"
 #include "scsi_transport_iscsi.h"
 #include "iscsi_tcp_priv.h"
 
@@ -181,7 +181,7 @@
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
 }
 
-static void istgt_scsi_cmnd_exec(struct iscsi_cmd_task *ctask)
+static void istgt_scsi_cmd_exec(struct iscsi_cmd_task *ctask)
 {
 	struct scsi_cmnd *scmd = ctask->sc;
 
@@ -201,6 +201,7 @@
 
 static void istgt_cmd_exec(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_conn *conn = ctask->conn;
 	u8 opcode;
 
 	opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
@@ -208,23 +209,16 @@
 	dprintk("%p,%x,%u\n", ctask, opcode, ctask->hdr->cmdsn);
 
 	switch (opcode) {
-	case ISCSI_OP_NOOP_OUT:
-/* 		noop_out_exec(cmnd); */
-		break;
 	case ISCSI_OP_SCSI_CMD:
-		istgt_scsi_cmnd_exec(ctask);
+		istgt_scsi_cmd_exec(ctask);
+	case ISCSI_OP_LOGOUT:
+		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 		break;
+	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
-/* 		execute_task_management(cmnd); */
-		break;
-	case ISCSI_OP_LOGOUT:
-/* 		logout_exec(cmnd); */
-		break;
-/* 	case ISCSI_OP_SCSI_REJECT: */
-/* 		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd)); */
-/* 		break; */
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
+		BUG_ON(1);
 		break;
 	default:
 		eprintk("unexpected cmnd op %x\n", ctask->hdr->opcode);
@@ -289,12 +283,6 @@
 	spin_unlock_bh(&istgt_session->slock);
 }
 
-static int
-istgt_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
-{
-	return 0;
-}
-
 static void istgt_unsolicited_data(struct iscsi_cmd_task *ctask)
 {
 /* 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data; */
@@ -306,23 +294,29 @@
 
 static int istgt_tcp_hdr_recv(struct iscsi_conn *conn)
 {
-	int rc, opcode, ahslen;
+	int rc, opcode;
 	struct iscsi_hdr *hdr;
 	struct iscsi_session *session = conn->session;
 	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	uint32_t cdgst, rdgst = 0;
 	struct iscsi_cmd_task *ctask = NULL;
+	struct iscsi_tcp_cmd_task *tcp_ctask;
+	struct istgt_session *istgt_session =
+		(struct istgt_session *) cls_session->dd_data;
 
 	rc = iscsi_tcp_hdr_recv_pre(conn);
 	if (rc)
 		return rc;
 
+	hdr = tcp_conn->in.hdr;
 	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
 	dprintk("opcode 0x%x offset %d copy %d ahslen %d datalen %d\n",
 		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
-		ahslen, tcp_conn->in.datalen);
+		hdr->hlength << 2, tcp_conn->in.datalen);
 
+	/* FIXME */
+	BUG_ON(tcp_conn->in.datalen);
+
 	switch (opcode) {
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
@@ -330,7 +324,20 @@
 	case ISCSI_OP_LOGOUT:
 		__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
 		ctask->conn = conn;
+		ctask->data_count = 0;
 		memcpy(ctask->hdr, hdr, sizeof(*hdr));
+
+		tcp_ctask = ctask->dd_data;
+		tcp_ctask->sg = NULL;
+		tcp_ctask->sent = 0;
+		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
+
+		if (!tcp_conn->in.datalen) {
+			istgt_ctask_recvlist_add(tcp_conn->in.ctask);
+			tcp_conn->in.ctask = NULL;
+			schedule_work(&istgt_session->recvwork);
+		}
+
 		if (opcode == ISCSI_OP_SCSI_CMD)
 			switch (ctask->hdr->cdb[0]) {
 			case WRITE_6:
@@ -342,6 +349,7 @@
 			}
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
+		BUG_ON(1);
 		/* Find a command in the hash list */
 		/* data_out_start(conn, cmnd); */
 		break;
@@ -362,6 +370,10 @@
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int rc = 0, opcode;
 
+	/* We need to return -EAGAIN if the buffer is not ready. */
+
+	BUG_ON(1);
+
 	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
@@ -376,10 +388,10 @@
 		 * Collect data segment to the connection's data
 		 * placeholder
 		 */
-		if (iscsi_tcp_copy(tcp_conn)) {
-			rc = -EAGAIN;
-			goto exit;
-		}
+/* 		if (iscsi_tcp_copy(tcp_conn)) { */
+/* 			rc = -EAGAIN; */
+/* 			goto exit; */
+/* 		} */
 
 /* 		rc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, tcp_conn->data, */
 /* 					tcp_conn->in.datalen); */
@@ -390,29 +402,10 @@
 	default:
 		BUG_ON(1);
 	}
-exit:
+
 	return rc;
 }
 
-static int stgt_pdu_recv_finish(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-
-	if (tcp_conn->in_progress == IN_PROGRESS_WAIT_HEADER)
-		if (tcp_conn->in.ctask) {
-			struct iscsi_cls_session *cls_session =
-				session_to_cls(conn->session);
-			struct istgt_session *istgt_session =
-				cls_session->dd_data;
-
-			istgt_ctask_recvlist_add(tcp_conn->in.ctask);
-			tcp_conn->in.ctask = NULL;
-			schedule_work(&istgt_session->recvwork);
-		}
-
-	return 0;
-}
-
 static void
 istgt_tcp_data_ready(struct sock *sk, int flag)
 {
@@ -423,7 +416,6 @@
 	d.conn = conn;
 	d.hdr_recv = istgt_tcp_hdr_recv;
 	d.data_recv = istgt_data_recv;
-	d.finish = istgt_pdu_recv_finish;
 
 	read_lock(&sk->sk_callback_lock);
 
@@ -455,7 +447,7 @@
 
 	write_lock_bh(&sock->sk->sk_callback_lock);
 
-	sk->sk_data_ready = istgt_tcp_data_ready;
+	sock->sk->sk_data_ready = istgt_tcp_data_ready;
 
 	write_unlock_bh(&sock->sk->sk_callback_lock);
 out:
@@ -514,7 +506,6 @@
 
 	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 	scsi_queue_work(shost, &conn->xmitwork);
-
 	return 0;
 }
 
@@ -522,7 +513,12 @@
 				  void (*done)(struct scsi_cmnd *))
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
+	tcp_ctask->sg = scmd->request_buffer;
+	tcp_ctask->sg_count = 0;
+	ctask->data_count = scmd->request_bufflen;
+
 	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
 		struct sock *sk = tcp_conn->sock->sk;
@@ -537,17 +533,138 @@
 
 		bh_unlock_sock(sk);
 	}
+
 	done(scmd);
+	return 0;
+}
 
+static void istgt_response_build(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_data_task *dtask;
+	struct scsi_cmnd *sc = ctask->sc;
+	struct scatterlist *sg = sc->request_buffer;
+
+	tcp_ctask->xmstate = XMSTATE_UNS_HDR;
+
+	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
+	BUG_ON(!dtask);
+	memset(&dtask->hdr, 0, sizeof(struct iscsi_data));
+	list_add(&dtask->item, &tcp_ctask->dataqueue);
+	tcp_ctask->dtask = dtask;
+
+	iscsi_buf_init_virt(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+			   sizeof(struct iscsi_hdr));
+
+	if (ctask->data_count) {
+		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
+				  &sg[tcp_ctask->sg_count++]);
+		tcp_ctask->xmstate = XMSTATE_UNS_DATA;
+	}
+
+	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_SCSI_CMD:
+	{
+		if (ctask->data_count) {
+			struct iscsi_data_rsp *hdr =
+				(struct iscsi_data_rsp *) &dtask->hdr;
+
+			hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
+			hdr->itt = ctask->hdr->itt;
+			hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+			hdr->offset = 0;
+			hdr->datasn = cpu_to_be32(ctask->datasn);
+
+			/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
+			hton24(hdr->dlength, ctask->data_count);
+			hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+		} else {
+			struct iscsi_cmd_rsp *hdr =
+				(struct iscsi_cmd_rsp *) &dtask->hdr;
+
+			hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+			hdr->flags = ISCSI_FLAG_CMD_FINAL;
+			hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+			hdr->cmd_status = SAM_STAT_GOOD;
+			hdr->itt = ctask->hdr->itt;
+		}
+	}
+	case ISCSI_OP_LOGOUT:
+	{
+		struct iscsi_logout_rsp *hdr =
+			(struct iscsi_logout_rsp *) &dtask->hdr;
+
+		hdr->opcode = ISCSI_OP_LOGOUT_RSP;
+		hdr->flags = ISCSI_FLAG_CMD_FINAL;
+		hdr->itt = tcp_ctask->hdr.itt;
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+static int
+istgt_tcp_ctask_data_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	int err;
+
+	while (1) {
+		err = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
+				     &ctask->data_count, &tcp_ctask->sent);
+		if (err)
+			return -EAGAIN;
+
+		if (!ctask->data_count)
+			break;
+
+		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
+				  &tcp_ctask->sg[tcp_ctask->sg_count++]);
+	}
+
 	return 0;
 }
 
+
+static int
+istgt_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	int err;
+
+	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
+		istgt_response_build(ctask);
+		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
+	}
+
+	if (tcp_ctask->xmstate & XMSTATE_UNS_HDR) {
+		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf,
+				    ctask->sc->request_bufflen);
+		if (err)
+			return -EAGAIN;
+		else
+			tcp_ctask->xmstate &= ~XMSTATE_UNS_HDR;
+	}
+
+	if (tcp_ctask->xmstate & XMSTATE_UNS_DATA) {
+		err = istgt_tcp_ctask_data_xmit(conn, ctask);
+		if (err)
+			return -EAGAIN;
+		else
+			tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
+	}
+
+	return 0;
+}
+
 static int istgt_tcp_eh_abort_handler(struct scsi_cmnd *scmd)
 {
 	BUG();
 	return 0;
 }
 
+
 #define	DEFAULT_NR_QUEUED_CMNDS	32
 #define TGT_NAME "istgt_tcp"
 



From tomo at berlios.de  Thu May  4 05:05:12 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 4 May 2006 05:05:12 +0200
Subject: [Stgt-svn] r445 - branches/use-scsi-ml/usr
Message-ID: <200605040305.k4435CCQ002696@sheep.berlios.de>

Author: tomo
Date: 2006-05-04 05:05:11 +0200 (Thu, 04 May 2006)
New Revision: 445

Modified:
   branches/use-scsi-ml/usr/tgtadm.h
Log:
Kill obsolete code.


Modified: branches/use-scsi-ml/usr/tgtadm.h
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.h	2006-05-02 11:35:33 UTC (rev 444)
+++ branches/use-scsi-ml/usr/tgtadm.h	2006-05-04 03:05:11 UTC (rev 445)
@@ -38,8 +38,6 @@
 	unsigned long addr;
 };
 
-extern int ktarget_destroy(int tid);
-extern int ktarget_create(int typeid);
 extern int tgt_mgmt(char *sbuf, char *rbuf);
 
 #endif



From tomo at berlios.de  Thu May  4 09:14:29 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 4 May 2006 09:14:29 +0200
Subject: [Stgt-svn] r446 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605040714.k447ETun017663@sheep.berlios.de>

Author: tomo
Date: 2006-05-04 09:13:26 +0200 (Thu, 04 May 2006)
New Revision: 446

Added:
   branches/use-scsi-ml/istgt/usr/log.c
   branches/use-scsi-ml/istgt/usr/log.h
Modified:
   branches/use-scsi-ml/istgt/usr/Makefile
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/istgt.c
Log:
Daemonize istgtd.


Modified: branches/use-scsi-ml/istgt/usr/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 03:05:11 UTC (rev 445)
+++ branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 07:13:26 UTC (rev 446)
@@ -1,8 +1,12 @@
 CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../include -I../../include -I../../usr
 #LIBS = -lcrypto
-OBJS = istgt.o conn.o param.o iscsid.o session.o target.o chap.o ctldev.o
+OBJS = conn.o param.o iscsid.o session.o target.o chap.o ctldev.o
 SHAREDLIB = istgt.so
+DAEMON = istgtd
 
+$(DAEMON): istgt.o log.c
+	$(CC) $^ -o $@
+
 $(SHAREDLIB): $(OBJS)
 	$(CC) -shared -o $@ $(OBJS)
 

Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 03:05:11 UTC (rev 445)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 07:13:26 UTC (rev 446)
@@ -12,13 +12,14 @@
 #include <linux/types.h>
 
 #include "types.h"
-#include "istgt_u.h"
 #include "param.h"
 #include "misc.h"
 #include "log.h"
 
 #include <scsi/iscsi_proto.h>
 
+#define ISCSI_NAME_LEN 255
+
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
@@ -60,7 +61,7 @@
 	struct session *session;
 
 	int tid;
-	struct iscsi_param session_param[session_key_last];
+/* 	struct iscsi_param session_param[session_key_last]; */
 
 	char *initiator;
 	uint8_t isid[6];

Modified: branches/use-scsi-ml/istgt/usr/istgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 03:05:11 UTC (rev 445)
+++ branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 07:13:26 UTC (rev 446)
@@ -32,6 +32,7 @@
 #include <netinet/ip.h>
 #include <arpa/inet.h>
 
+#include "log.h"
 #include "iscsid.h"
 
 #define ISCSI_LISTEN_PORT	3260
@@ -41,11 +42,14 @@
 
 enum {
 	POLL_LISTEN,
-	POLL_INCOMING = POLL_LISTEN + LISTEN_MAX,
+	POLL_NL = POLL_LISTEN + LISTEN_MAX,
+	POLL_INCOMING,
 	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
 };
 
+static struct pollfd pfd[POLL_MAX];
 static struct connection *incoming[INCOMING_MAX];
+static char program_name[] = "istgt";
 
 static void set_non_blocking(int fd)
 {
@@ -54,9 +58,9 @@
 	if (res != -1) {
 		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
 		if (res)
-			log_warning("unable to set fd flags (%s)!", strerror(errno));
+			dprintf("unable to set fd flags (%s)!", strerror(errno));
 	} else
-		log_warning("unable to get fd flags (%s)!", strerror(errno));
+		dprintf("unable to get fd flags (%s)!", strerror(errno));
 }
 
 static void listen_socket_create(struct pollfd *pfds)
@@ -73,14 +77,14 @@
 	hints.ai_flags = AI_PASSIVE;
 
 	if (getaddrinfo(NULL, servname, &hints, &res0)) {
-		log_error("unable to get address info (%s)!", strerror(errno));
+		eprintf("unable to get address info (%s)!", strerror(errno));
 		exit(1);
 	}
 
 	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
 		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (sock < 0) {
-			log_error("unable to create server socket (%s) %d %d %d!",
+			eprintf("unable to create server socket (%s) %d %d %d!",
 				  strerror(errno), res->ai_family,
 				  res->ai_socktype, res->ai_protocol);
 			continue;
@@ -88,7 +92,7 @@
 
 		opt = 1;
 		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
-			log_warning("unable to set SO_REUSEADDR on server socket (%s)!",
+			dprintf("unable to set SO_REUSEADDR on server socket (%s)!",
 				    strerror(errno));
 		opt = 1;
 		if (res->ai_family == AF_INET6 &&
@@ -96,12 +100,12 @@
 			continue;
 
 		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
-			log_error("unable to bind server socket (%s)!", strerror(errno));
+			eprintf("unable to bind server socket (%s)!", strerror(errno));
 			continue;
 		}
 
 		if (listen(sock, INCOMING_MAX)) {
-			log_error("unable to listen to server socket (%s)!", strerror(errno));
+			eprintf("unable to listen to server socket (%s)!", strerror(errno));
 			continue;
 		}
 
@@ -114,11 +118,6 @@
 	freeaddrinfo(res0);
 }
 
-void poll_init(struct pollfd *pfds)
-{
-	listen_socket_create(pfds + POLL_LISTEN);
-}
-
 static void accept_connection(struct pollfd *pfds, int afd)
 {
 	struct sockaddr_storage from;
@@ -132,7 +131,7 @@
 	namesize = sizeof(from);
 	if ((fd = accept(afd, (struct sockaddr *) &from, &namesize)) < 0) {
 		if (errno != EINTR && errno != EAGAIN) {
-			log_error("accept(incoming_socket)");
+			eprintf("accept(incoming_socket)");
 			exit(1);
 		}
 		return;
@@ -143,13 +142,13 @@
 			break;
 	}
 	if (i >= INCOMING_MAX) {
-		log_error("unable to find incoming slot? %d\n", i);
+		eprintf("unable to find incoming slot? %d\n", i);
 		goto out;
 	}
 
 	conn = conn_alloc();
 	if (!conn) {
-		log_error("fail to allocate %s", "conn\n");
+		eprintf("fail to allocate %s", "conn\n");
 		goto out;
 	}
 	conn->fd = fd;
@@ -168,7 +167,7 @@
 	return;
 }
 
-void poll_event(struct pollfd *pfds, int nr)
+static void poll_event(struct pollfd *pfds)
 {
 	struct connection *conn;
 	struct pollfd *pfd;
@@ -296,7 +295,7 @@
 
 			break;
 		default:
-			log_error("illegal iostate %d for port %d!\n", conn->iostate, i);
+			eprintf("illegal iostate %d for port %d!\n", conn->iostate, i);
 			exit(1);
 		}
 
@@ -310,3 +309,66 @@
 		}
 	}
 }
+
+static void event_loop(void)
+{
+	int i, err;
+
+	listen_socket_create(pfd + POLL_LISTEN);
+
+	for (i = 0; i < INCOMING_MAX; i++) {
+		pfd[POLL_INCOMING + i].fd = -1;
+		pfd[POLL_INCOMING + i].events = 0;
+		incoming[i] = NULL;
+	}
+
+retry:
+	err = poll(pfd, POLL_MAX, -1);
+	if (err < 0) {
+		if (errno != EINTR) {
+			eprintf("%d %d\n", err, errno);
+			exit(1);
+		} else
+			goto retry;
+	}
+
+	poll_event(pfd);
+	goto retry;
+}
+
+static int daemon_init(void)
+{
+	pid_t pid;
+
+	pid = fork();
+	if (pid < 0)
+		return -ENOMEM;
+	else if (pid)
+		exit(0);
+
+	setsid();
+	chdir("/");
+	close(0);
+	open("/dev/null", O_RDWR);
+	dup2(0, 1);
+	dup2(0, 2);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	int is_daemon = 1, is_debug = 1;
+
+	if (is_daemon && daemon_init())
+		exit(1);
+
+	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
+		exit(1);
+
+	/* init nl socket here. */
+
+	event_loop();
+
+	return 0;
+}

Copied: branches/use-scsi-ml/istgt/usr/log.c (from rev 445, branches/use-scsi-ml/usr/log.c)

Copied: branches/use-scsi-ml/istgt/usr/log.h (from rev 445, branches/use-scsi-ml/usr/log.h)



From tomo at berlios.de  Thu May  4 14:27:37 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 4 May 2006 14:27:37 +0200
Subject: [Stgt-svn] r447 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605041227.k44CRbd9013443@sheep.berlios.de>

Author: tomo
Date: 2006-05-04 14:27:34 +0200 (Thu, 04 May 2006)
New Revision: 447

Modified:
   branches/use-scsi-ml/istgt/usr/Makefile
   branches/use-scsi-ml/istgt/usr/conn.c
   branches/use-scsi-ml/istgt/usr/ctldev.c
   branches/use-scsi-ml/istgt/usr/iscsid.c
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/istgt.c
   branches/use-scsi-ml/istgt/usr/param.c
   branches/use-scsi-ml/istgt/usr/param.h
   branches/use-scsi-ml/istgt/usr/session.c
Log:
overhaul the user-space code. Compliable, though not finished at all.


Modified: branches/use-scsi-ml/istgt/usr/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 12:27:34 UTC (rev 447)
@@ -1,14 +1,14 @@
 CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../include -I../../include -I../../usr
-#LIBS = -lcrypto
-OBJS = conn.o param.o iscsid.o session.o target.o chap.o ctldev.o
+LIBS = -lcrypto
+OBJS = param.o iscsid.o session.o target.o chap.o ctldev.o
 SHAREDLIB = istgt.so
 DAEMON = istgtd
 
-$(DAEMON): istgt.o log.c
-	$(CC) $^ -o $@
+$(DAEMON): log.o istgt.o conn.o param.o session.o iscsid.o target.o chap.o ctldev.o
+	$(CC) $^ -o $@ $(LIBS)
 
 $(SHAREDLIB): $(OBJS)
 	$(CC) -shared -o $@ $(OBJS)
 
 clean:
-	rm -f *.o $(PROGRAMS) $(SHAREDLIB)
+	rm -f *.o istgtd $(SHAREDLIB)

Modified: branches/use-scsi-ml/istgt/usr/conn.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/conn.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/conn.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -68,17 +68,38 @@
 {
 	int err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
+	uint32_t cid = conn->cid;
 
 	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
 		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;
 
-	err = ki->conn_create(conn->tid, sid, conn->cid,
-			      conn->stat_sn, conn->exp_stat_sn, fd,
-			      conn->session_param[key_header_digest].val,
-			      conn->session_param[key_data_digest].val);
+	err = ki->create_conn(thandle, sid, cid, &cid);
+	if (err) {
+		eprintf("%d %d %u %u %u %" PRIx64,
+			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
+		goto out;
+	}
+	conn->cid = cid;
 
+	if (ki->bind_conn(thandle, sid, conn->cid, fd, 1, &err) || err) {
+		eprintf("%d %d %u %u %u %" PRIx64,
+			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
+		goto out;
+	}
+
+/* 	if (ki->set_param(thandle, sid, conn->cid, ISCSI_PARAM_EXP_STATSN, */
+/* 			  conn->exp_stat_sn, &err, || err) { */
+/* 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid); */
+/* 		goto out; */
+/* 	} */
+
+/* 	conn->stat_sn */
+/* 		conn->session_param[key_header_digest].val, */
+/* 		conn->session_param[key_data_digest].val); */
+
+out:
 	return;
 }
 

Modified: branches/use-scsi-ml/istgt/usr/ctldev.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/ctldev.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/ctldev.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -22,11 +22,8 @@
 #include <linux/netlink.h>
 
 #include "iscsid.h"
-#include "tgtd.h"
-#include "tgt_if.h"
-#include "tgtadm.h"
-#include "tgt_sysfs.h"
 
+#if 0
 extern struct qelem targets_list;
 static int typeid;
 
@@ -485,145 +482,15 @@
 	return err;
 }
 
-/* This is temporary. */
+#endif
 
-#define CONFIG_FILE	"/etc/ietd.conf"
-#define BUFSIZE	8192
-
-/* this is the orignal Ardis code. */
-static char *target_sep_string(char **pp)
-{
-	char *p = *pp;
-	char *q;
-
-	for (p = *pp; isspace(*p); p++)
-		;
-	for (q = p; *q && !isspace(*q); q++)
-		;
-	if (*q)
-		*q++ = 0;
-	else
-		p = NULL;
-	*pp = q;
-	return p;
-}
-
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static int driver_to_typeid(char *name)
-{
-	int i, nr, err, fd, id = -ENOENT;
-	char *p, path[PATH_MAX], buf[PATH_MAX];
-	struct dirent **namelist;
-
-	nr = scandir(TGT_TYPE_SYSFSDIR, &namelist, filter, alphasort);
-	for (i = 0; i < nr; i++) {
-		snprintf(path, sizeof(path), TGT_TYPE_SYSFSDIR "/%s/name",
-			 namelist[i]->d_name);
-
-		fd = open(path, O_RDONLY);
-		if (fd < 0) {
-			eprintf("%s %d\n", path, errno);
-			continue;
-		}
-
-		err = read(fd, buf, sizeof(buf));
-		close(fd);
-		if (err < 0) {
-			eprintf("%s %d\n", path, err);
-			continue;
-		}
-
-		if (strncmp(name, buf, strlen(name)))
-			continue;
-
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		id = atoi(p);
-		break;
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return id;
-}
-
-void initial_device_create(int tid, int64_t lun, char *params)
-{
-	char *path, *devtype;
-	char d[] = "tgt_vsd";
-
-	path = devtype = NULL;
-	kdevice_create_parser(params, &path, &devtype);
-	kdevice_create(tid, lun, path, devtype ? : d);
-}
-
-void initial_config_load(void)
-{
-	FILE *config;
-	char buf[BUFSIZE];
-	char *p, *q;
-	int idx, tid;
-	uint32_t val;
-
-	typeid = driver_to_typeid(THIS_NAME);
-
-	dprintf("%d\n", typeid);
-
-	if (!(config = fopen(CONFIG_FILE, "r")))
-		return;
-
-	tid = -1;
-	while (fgets(buf, BUFSIZE, config)) {
-		q = buf;
-		p = target_sep_string(&q);
-		if (!p || *p == '#')
-			continue;
-		if (!strcasecmp(p, "Target")) {
-			tid = 0;
-			if (!(p = target_sep_string(&q)))
-				continue;
-			dprintf("creaing target %s\n", p);
-			tid = istgt_ktarget_create(typeid, p);
-		} else if (!strcasecmp(p, "Alias") && tid >= 0) {
-			;
-		} else if (!strcasecmp(p, "MaxSessions") && tid >= 0) {
-			/* target->max_sessions = strtol(q, &q, 0); */
-		} else if (!strcasecmp(p, "Lun") && tid >= 0) {
-			uint64_t lun = strtoull(q, &q, 10);
-			initial_device_create(tid, lun, q);
-		} else if (!((idx = param_index_by_name(p, target_keys)) < 0) && tid >= 0) {
-			val = strtol(q, &q, 0);
-			if (param_check_val(target_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", target_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_target, idx, val);
-		} else if (!((idx = param_index_by_name(p, session_keys)) < 0) && tid >= 0) {
-			char *str = target_sep_string(&q);
-			if (param_str_to_val(session_keys, idx, str, &val) < 0)
-				continue;
-			if (param_check_val(session_keys, idx, &val) < 0)
-				log_warning("%s, %u\n", session_keys[idx].name, val);
-			iscsi_param_partial_set(tid, 0, key_session, idx, val);
-		}
-	}
-
-	fclose(config);
-
-	return;
-}
-
-struct iscsi_kernel_interface ioctl_ki = {
-	.param_get = iscsi_param_get,
-	.param_set = iscsi_param_set,
-	.session_create = iscsi_session_create,
-	.session_destroy = iscsi_session_destroy,
-	.conn_create = iscsi_conn_create,
-	.conn_destroy = iscsi_conn_destroy,
+struct iscsi_kernel_interface nl_ki = {
+/* 	.param_get = iscsi_param_get, */
+/* 	.param_set = iscsi_param_set, */
+/* 	.session_create = iscsi_session_create, */
+/* 	.session_destroy = iscsi_session_destroy, */
+/* 	.conn_create = iscsi_conn_create, */
+/* 	.conn_destroy = iscsi_conn_destroy, */
 };
 
-struct iscsi_kernel_interface *ki = &ioctl_ki;
+struct iscsi_kernel_interface *ki = &nl_ki;

Modified: branches/use-scsi-ml/istgt/usr/iscsid.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/iscsid.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -228,8 +228,8 @@
 			unsigned int val;
 			char buf[32];
 
-			if (idx == key_max_recv_data_length)
-				idx = key_max_xmit_data_length;
+			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
+				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
 
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
@@ -251,7 +251,7 @@
 
 			switch (conn->session_param[idx].state) {
 			case KEY_STATE_START:
-				if (idx == key_max_xmit_data_length)
+				if (idx == ISCSI_PARAM_MAX_XMIT_DLENGTH)
 					break;
 				memset(buf, 0, sizeof(buf));
 				param_val_to_str(session_keys, idx, val, buf);
@@ -283,14 +283,14 @@
 
 static int text_check_param(struct connection *conn)
 {
-	struct iscsi_param *p = conn->session_param;
+	struct param *p = conn->session_param;
 	char buf[32];
 	int i, cnt;
 
 	for (i = 0, cnt = 0; session_keys[i].name; i++) {
 		if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
 			if (conn->state == STATE_LOGIN) {
-				if (i == key_max_xmit_data_length) {
+				if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
 					if (p[i].val > session_keys[i].def)
 						p[i].val = session_keys[i].def;
 					p[i].state = KEY_STATE_DONE;
@@ -378,7 +378,7 @@
 /* 			return; */
 /* 		} */
 
-		ki->param_get(conn->tid, 0, conn->session_param);
+/* 		ki->param_get(conn->tid, 0, conn->session_param); */
 		conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
 		log_debug("exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmdsn);
 		conn->max_cmd_sn = conn->exp_cmd_sn;

Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 12:27:34 UTC (rev 447)
@@ -12,14 +12,21 @@
 #include <linux/types.h>
 
 #include "types.h"
+#include "iscsi_if.h"
+#include "misc.h"
 #include "param.h"
-#include "misc.h"
 #include "log.h"
 
 #include <scsi/iscsi_proto.h>
 
 #define ISCSI_NAME_LEN 255
 
+#define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
+#define DIGEST_NONE		(1 << 0)
+#define DIGEST_CRC32C           (1 << 1)
+
+extern uint64_t thandle;
+
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
@@ -48,6 +55,10 @@
 	uint8_t isid[6];
 	uint16_t tsih;
 
+	/* workaroud */
+	uint32_t ksid;
+	uint32_t hostno;
+
 	struct qelem conn_list;
 	int conn_cnt;
 };
@@ -61,7 +72,7 @@
 	struct session *session;
 
 	int tid;
-/* 	struct iscsi_param session_param[session_key_last]; */
+	struct param session_param[ISCSI_PARAM_MAX];
 
 	char *initiator;
 	uint8_t isid[6];
@@ -181,15 +192,23 @@
 
 /* ctldev.c */
 struct iscsi_kernel_interface {
-	int (*param_get) (int tid, uint64_t sid, struct iscsi_param *);
-	int (*param_set) (int tid, uint64_t sid, int type, uint32_t flags,
-			  struct iscsi_param *);
-	int (*session_create) (int tid, uint64_t sid, uint32_t exp,
-			       uint32_t max);
-	int (*session_destroy) (int tid, uint64_t sid);
-	int (*conn_create) (int tid, uint64_t sid, uint32_t cid, uint32_t sn,
-			    uint32_t exp_sn, int fd, uint32_t hd, uint32_t dd);
-	int (*conn_destroy) (int tid, uint64_t sid, uint32_t cid);
+	int (*set_param) (uint64_t transport_handle, uint32_t sid,
+			  uint32_t cid, enum iscsi_param param,
+			  void *value, int len, int *retcode);
+
+	int (*create_session) (uint64_t transport_handle,
+			       uint32_t initial_cmdsn,
+			       uint32_t *out_sid, uint32_t *out_hostno);
+
+	int (*destroy_session) (uint64_t transport_handle, uint32_t sid);
+
+	int (*create_conn) (uint64_t transport_handle,
+			    uint32_t sid, uint32_t cid, uint32_t *out_cid);
+	int (*destroy_conn) (uint64_t transport_handle, uint32_t sid,
+			     uint32_t cid);
+	int (*bind_conn) (uint64_t transport_handle, uint32_t sid,
+			  uint32_t cid, uint64_t transport_eph,
+			  int is_leading, int *retcode);
 };
 
 extern struct iscsi_kernel_interface *ki;

Modified: branches/use-scsi-ml/istgt/usr/istgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -32,7 +32,6 @@
 #include <netinet/ip.h>
 #include <arpa/inet.h>
 
-#include "log.h"
 #include "iscsid.h"
 
 #define ISCSI_LISTEN_PORT	3260
@@ -50,6 +49,7 @@
 static struct pollfd pfd[POLL_MAX];
 static struct connection *incoming[INCOMING_MAX];
 static char program_name[] = "istgt";
+uint64_t thandle;
 
 static void set_non_blocking(int fd)
 {

Modified: branches/use-scsi-ml/istgt/usr/param.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/param.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/param.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -26,7 +26,7 @@
 	return err;
 }
 
-void param_set_defaults(struct iscsi_param *params, struct iscsi_key *keys)
+void param_set_defaults(struct param *params, struct iscsi_key *keys)
 {
 	int i;
 
@@ -78,7 +78,7 @@
 	return err;
 }
 
-static int or_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int or_set_val(struct param *param, int idx, unsigned int *val)
 {
 	*val |= param[idx].val;
 	param[idx].val = *val;
@@ -86,7 +86,7 @@
 	return 0;
 }
 
-static int and_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int and_set_val(struct param *param, int idx, unsigned int *val)
 {
 	*val &= param[idx].val;
 	param[idx].val = *val;
@@ -118,7 +118,7 @@
 	return 0;
 }
 
-static int minimum_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int minimum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (*val > param[idx].val)
 		*val = param[idx].val;
@@ -128,7 +128,7 @@
 	return 0;
 }
 
-static int maximum_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int maximum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (param[idx].val > *val)
 		*val = param[idx].val;
@@ -176,7 +176,7 @@
 	return err;
 }
 
-static int digest_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int digest_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (*val & DIGEST_CRC32C && param[idx].val & DIGEST_CRC32C)
 		*val = DIGEST_CRC32C;
@@ -198,10 +198,12 @@
 	return 0;
 }
 
-static int marker_set_val(struct iscsi_param *param, int idx, unsigned int *val)
+static int marker_set_val(struct param *param, int idx, unsigned int *val)
 {
-	if ((idx == key_ofmarkint && param[key_ofmarker].state == KEY_STATE_DONE) ||
-	    (idx == key_ifmarkint && param[key_ifmarker].state == KEY_STATE_DONE))
+	if ((idx == ISCSI_OFMARKER_EN &&
+	     param[ISCSI_OFMARKER_EN].state == KEY_STATE_DONE) ||
+	    (idx == ISCSI_IFMARKER_EN &&
+	     param[ISCSI_IFMARKER_EN].state == KEY_STATE_DONE))
 		*val = 0;
 	else
 		*val = 1;
@@ -235,7 +237,7 @@
 		return 0;
 }
 
-int param_set_val(struct iscsi_key *keys, struct iscsi_param *param,
+int param_set_val(struct iscsi_key *keys, struct param *param,
 		  int idx, unsigned int *val2)
 {
 	if (keys[idx].ops->set_val)
@@ -283,30 +285,25 @@
 
 #define	SET_KEY_VALUES(x)	DEFAULT_NR_##x,MIN_NR_##x, MAX_NR_##x
 
-struct iscsi_key target_keys[] = {
-	{"QueuedCommands", SET_KEY_VALUES(QUEUED_CMNDS), &minimum_ops},
-	{NULL,},
-};
-
 struct iscsi_key session_keys[] = {
-	{"InitialR2T", 1, 0, 1, &or_ops},
-	{"ImmediateData", 1, 0, 1, &and_ops},
-	{"MaxConnections", 1, 1, 65535, &minimum_ops},
 	{"MaxRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
 	{"MaxXmitDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
-	{"MaxBurstLength", 262144, 512, 16777215, &minimum_ops},
-	{"FirstBurstLength", 65536, 512, 16777215, &minimum_ops},
-	{"DefaultTime2Wait", 2, 0, 3600, &maximum_ops},
-	{"DefaultTime2Retain", 20, 0, 3600, &minimum_ops},
+	{"HeaderDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
+	{"DataDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
+	{"InitialR2T", 1, 0, 1, &or_ops},
 	{"MaxOutstandingR2T", 1, 1, 65535, &minimum_ops},
+	{"ImmediateData", 1, 0, 1, &and_ops},
+	{"FirstBurstLength", 65536, 512, 16777215, &minimum_ops},
+	{"MaxBurstLength", 262144, 512, 16777215, &minimum_ops},
 	{"DataPDUInOrder", 1, 0, 1, &or_ops},
 	{"DataSequenceInOrder", 1, 0, 1, &or_ops},
 	{"ErrorRecoveryLevel", 0, 0, 2, &minimum_ops},
-	{"HeaderDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
-	{"DataDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
-	{"OFMarker", 0, 0, 1, &and_ops},
 	{"IFMarker", 0, 0, 1, &and_ops},
+	{"OFMarker", 0, 0, 1, &and_ops},
+	{"DefaultTime2Wait", 2, 0, 3600, &maximum_ops},
+	{"DefaultTime2Retain", 20, 0, 3600, &minimum_ops},
 	{"OFMarkInt", 2048, 1, 65535, &marker_ops},
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
+	{"MaxConnections", 1, 1, 65535, &minimum_ops},
 	{NULL,},
 };

Modified: branches/use-scsi-ml/istgt/usr/param.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/param.h	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/param.h	2006-05-04 12:27:34 UTC (rev 447)
@@ -9,7 +9,7 @@
 
 struct iscsi_key;
 
-struct iscsi_param {
+struct param {
 	int state;
 	unsigned int val;
 };
@@ -18,7 +18,7 @@
 	int (*val_to_str)(unsigned int, char *);
 	int (*str_to_val)(char *, unsigned int *);
 	int (*check_val)(struct iscsi_key *, unsigned int *);
-	int (*set_val)(struct iscsi_param *, int, unsigned int *);
+	int (*set_val)(struct param *, int, unsigned int *);
 };
 
 struct iscsi_key {
@@ -32,11 +32,11 @@
 extern struct iscsi_key session_keys[];
 extern struct iscsi_key target_keys[];
 
-extern void param_set_defaults(struct iscsi_param *, struct iscsi_key *);
+extern void param_set_defaults(struct param *, struct iscsi_key *);
 extern int param_index_by_name(char *, struct iscsi_key *);
 extern int param_val_to_str(struct iscsi_key *, int, unsigned int, char *);
 extern int param_str_to_val(struct iscsi_key *, int, char *, unsigned int *);
 extern int param_check_val(struct iscsi_key *, int, unsigned int *);
-extern int param_set_val(struct iscsi_key *, struct iscsi_param *, int, unsigned int *);
+extern int param_set_val(struct iscsi_key *, struct param *, int, unsigned int *);
 
 #endif

Modified: branches/use-scsi-ml/istgt/usr/session.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/session.c	2006-05-04 07:13:26 UTC (rev 446)
+++ branches/use-scsi-ml/istgt/usr/session.c	2006-05-04 12:27:34 UTC (rev 447)
@@ -98,9 +98,10 @@
 
 	log_debug("session_create: %#" PRIx64, sid);
 
-	ki->session_create(conn->tid, sid, conn->exp_cmd_sn,
-			   conn->max_cmd_sn);
-	ki->param_set(conn->tid, sid, key_session, 0, conn->session_param);
+	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
+			   &session->hostno);
+
+	/* FIXME: we need to bind host to target here */
 }
 
 void session_remove(struct session *session)
@@ -113,7 +114,7 @@
 		eprintf("%" PRIx64 " conn_list is not null\n", sid);
 
 	if (!session->tsih)
-		ki->session_destroy(session->target->tid, sid);
+		ki->destroy_session(thandle, session->ksid);
 
 	if (session->target) {
 		remque(&session->slist);



From tomo at berlios.de  Thu May  4 14:58:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 4 May 2006 14:58:50 +0200
Subject: [Stgt-svn] r448 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605041258.k44CwoSJ024259@sheep.berlios.de>

Author: tomo
Date: 2006-05-04 14:58:47 +0200 (Thu, 04 May 2006)
New Revision: 448

Added:
   branches/use-scsi-ml/istgt/usr/netlink.c
Removed:
   branches/use-scsi-ml/istgt/usr/ctldev.c
Modified:
   branches/use-scsi-ml/istgt/usr/Makefile
Log:
Rename ctldev.c netlink.c

Modified: branches/use-scsi-ml/istgt/usr/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 12:27:34 UTC (rev 447)
+++ branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 12:58:47 UTC (rev 448)
@@ -4,7 +4,7 @@
 SHAREDLIB = istgt.so
 DAEMON = istgtd
 
-$(DAEMON): log.o istgt.o conn.o param.o session.o iscsid.o target.o chap.o ctldev.o
+$(DAEMON): log.o istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
 	$(CC) $^ -o $@ $(LIBS)
 
 $(SHAREDLIB): $(OBJS)

Deleted: branches/use-scsi-ml/istgt/usr/ctldev.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/ctldev.c	2006-05-04 12:27:34 UTC (rev 447)
+++ branches/use-scsi-ml/istgt/usr/ctldev.c	2006-05-04 12:58:47 UTC (rev 448)
@@ -1,496 +0,0 @@
-/*
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This code is licenced under the GPL.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-
-#if 0
-extern struct qelem targets_list;
-static int typeid;
-
-static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
-{
-	int err;
-	char rbuf[8192];
-	struct nlmsghdr *nlm_recv;
-	struct tgt_event *ev;
-	struct iet_msg *msg;
-
-	err = nl_cmd_call(nl_fd, nlm_send->nlmsg_type,
-			  (char *) nlm_send, len, rbuf, sizeof(rbuf));
-
-	nlm_recv = (struct nlmsghdr *) rbuf;
-	ev = NLMSG_DATA(nlm_recv);
-	switch (nlm_recv->nlmsg_type) {
-		case TGT_KEVENT_TARGET_PASSTHRU:
-			msg = (struct iet_msg *)ev->data;
-			memcpy(nlm_send, nlm_recv, len);
-			err = msg->result;
-		default:
-			err = ev->k.event_res.err;
-	}
-
-	return err;
-}
-
-void async_event(char *data)
-{
-	struct tgt_event *ev = (struct tgt_event *) data;
-	struct iet_msg *msg = (struct iet_msg *) ev->data;
-	struct session *session;
-
-	eprintf("%u %u\n", msg->msg_type, msg->result);
-
-	switch (msg->k.conn_state_change.state) {
-	case E_CONN_CLOSE:
-		if (!(session = session_find_id(msg->k.conn_state_change.tid,
-						msg->k.conn_state_change.sid))) {
-			eprintf("session %#" PRIx64 " not found?",
-				msg->k.conn_state_change.sid);
-		}
-
-		if (!--session->conn_cnt)
-			session_remove(session);
-		break;
-	default:
-		eprintf("%u\n", msg->k.conn_state_change.state);
-		break;
-	}
-}
-
-static void nlmsg_init(struct nlmsghdr *nlh, uint32_t pid, uint32_t seq,
-		       uint16_t type, uint32_t len, uint16_t flags)
-{
-	nlh->nlmsg_pid = pid;
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_seq = seq;
-}
-
-/*
- * this will have to be redone and made generic when we move it
- */
-static struct nlmsghdr *get_iet_msg(int tid, struct iet_msg **msg)
-{
-	int len;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-
-	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iet_msg));
-	nlh = calloc(1, len);
-	if (!nlh)
-		return NULL;
-
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_PASSTHRU, len, 0);
-	ev = NLMSG_DATA(nlh);
-	ev->u.tgt_passthru.tid = tid;
-	ev->u.tgt_passthru.len = sizeof(struct iet_msg);
-	*msg = (struct iet_msg *)ev->data;
-
-	return nlh;
-}
-
-
-static int iscsi_conn_destroy(int tid, uint64_t sid, uint32_t cid)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct conn_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.conn_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->cid = cid;
-	msg->msg_type = IET_DEL_CONN;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_param_get(int tid, uint64_t sid, struct iscsi_param *param)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct iscsi_param_info *info;
-	int err, i;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.param_info;
-	info->tid = tid;
-	info->sid = sid;
-
-	msg->msg_type = IET_ISCSI_PARAM_GET;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	if (err < 0)
-		log_error("Can't get session param %d %d\n", info->tid, err);
-	else {
-		struct tgt_event *ev;
-
-		ev = NLMSG_DATA(nlh);
-		msg = (struct iet_msg *)ev->data;
-		info = &msg->u.param_info;
-
-		for (i = 0; i < session_key_last; i++)
-			param[i].val = info->session_param[i];
-	}
-
-	free(nlh);
-	return err;
-}
-
-static int iscsi_param_set(int tid, uint64_t sid, int type, uint32_t partial,
-			   struct iscsi_param *param)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct iscsi_param_info *info;
-	int err, i;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.param_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->param_type = type;
-	info->partial = partial;
-
-	if (type == key_session)
-		for (i = 0; i < session_key_last; i++)
-			info->session_param[i] = param[i].val;
-	else
-		for (i = 0; i < target_key_last; i++)
-			info->target_param[i] = param[i].val;
-	msg->msg_type = IET_ISCSI_PARAM_SET;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	if (err)
-		eprintf("%d %d %u %" PRIx64 "%d %u\n",
-			err, errno, tid, sid, type, partial);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_param_partial_set(int tid, uint64_t sid, int type, int key,
-				   uint32_t val)
-{
-	struct iscsi_param *param;
-	struct iscsi_param s_param[session_key_last];
-	struct iscsi_param t_param[target_key_last];
-
-	if (type == key_session)
-		param = s_param;
-	else
-		param = t_param;
-
-	param[key].val = val;
-
-	return iscsi_param_set(tid, sid, type, 1 << key, param);
-}
-
-static int trgt_mgmt_params(int tid, uint64_t sid, char *params)
-{
-	char *p, *q;
-	uint32_t s_partial = 0, t_partial = 0;
-	struct iscsi_param s_param[session_key_last];
-	struct iscsi_param t_param[target_key_last];
-
-	while ((p = strsep(&params, ",")) != NULL) {
-		int idx;
-		uint32_t val;
-		if (!*p)
-			continue;
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-		val = strtol(q, NULL, 0);
-
-		if (!((idx = param_index_by_name(p, target_keys)) < 0)) {
-			if (!param_check_val(target_keys, idx, &val))
-				t_partial |= (1 << idx);
-			else
-				eprintf("invalid val %s, %u\n",
-					target_keys[idx].name, val);
-			t_param[idx].val = val;
-
-			continue;
-		}
-
-		if (!((idx = param_index_by_name(p, session_keys)) < 0)) {
-			if (!param_check_val(session_keys, idx, &val))
-				s_partial |= (1 << idx);
-			else
-				eprintf("invalid val %s, %u\n",
-					session_keys[idx].name, val);
-			s_param[idx].val = val;
-		}
-	}
-
-	if (t_partial && s_partial) {
-		eprintf("%s", "Cannot change both at the same time\n");
-		return -EINVAL;
-	} else if (t_partial)
-		return iscsi_param_set(tid, sid, key_target, t_partial, t_param);
-	else if (s_partial)
-		return iscsi_param_set(tid, sid, key_session, s_partial, s_param);
-	else
-		eprintf("%s", "Nothing to do\n");
-
-	return 0;
-}
-
-static int iscsi_session_create(int tid, uint64_t sid,
-				uint32_t exp_cmd_sn, uint32_t max_cmd_sn)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct session_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.sess_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->exp_cmd_sn = exp_cmd_sn;
-	info->max_cmd_sn = max_cmd_sn;
-	msg->msg_type = IET_ADD_SESSION;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_session_destroy(int tid, uint64_t sid)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct session_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.sess_info;
-	info->tid = tid;
-	info->sid = sid;
-	msg->msg_type = IET_DEL_SESSION;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_conn_create(int tid, uint64_t sid, uint32_t cid,
-			     uint32_t stat_sn, uint32_t exp_stat_sn,
-			     int fd, uint32_t hdigest, uint32_t ddigest)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct conn_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.conn_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->cid = cid;
-	info->stat_sn = stat_sn;
-	info->exp_stat_sn = exp_stat_sn;
-	info->fd = fd;
-	info->header_digest = hdigest;
-	info->data_digest = ddigest;
-	msg->msg_type = IET_ADD_CONN;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int istgt_ktarget_destroy(int tid)
-{
-	int err;
-	struct target* target;
-
-	if (!(target = target_find_by_id(tid)))
-		return -ENOENT;
-
-	if (target->nr_sessions)
-		return -EBUSY;
-
-	if (!list_empty(&target->sessions_list)) {
-		eprintf("bug still have sessions %d\n", tid);
-		exit(-1);
-	}
-
-	err = ktarget_destroy(tid);
-	if (err < 0)
-		return err;
-
-	remque(&target->tlist);
-
-	free(target);
-
-	return 0;
-}
-
-static int istgt_ktarget_create(int typeid, char *name)
-{
-	struct target *target;
-	int err;
-
-	if (!name)
-		return -EINVAL;
-
-	if (!(target = malloc(sizeof(*target))))
-		return -ENOMEM;
-
-	memset(target, 0, sizeof(*target));
-	memcpy(target->name, name, sizeof(target->name) - 1);
-
-	err = ktarget_create(typeid);
-	if (err < 0) {
-		eprintf("can't create a target %d\n", err);
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&target->tlist);
-	INIT_LIST_HEAD(&target->sessions_list);
-	target->tid = err;
-	insque(&target->tlist, &targets_list);
-
-	return err;
-out:
-	free(target);
-	return err;
-}
-
-static int istgt_target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, tid = req->tid;
-
-	switch (req->op) {
-	case OP_NEW:
-		err = istgt_ktarget_create(typeid, params);
-		break;
-	case OP_DELETE:
-		err = istgt_ktarget_destroy(tid);
-		break;
-	case OP_UPDATE:
-		err = trgt_mgmt_params(tid, req->sid, params);
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
-static int user_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int conn_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int session_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-int ipc_mgmt(char *sbuf, char *rbuf)
-{
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct tgtadm_req *req;
-	struct tgtadm_res *res;
-	int err = -EINVAL, rlen = 0;
-	char *params;
-
-	req = NLMSG_DATA(nlh);
-	params = (char *) req + sizeof(*req);
-
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
-
-	switch (req->mode) {
-	case MODE_DEVICE:
-	case MODE_SYSTEM:
-		err = tgt_mgmt(sbuf, rbuf);
-		break;
-	case MODE_TARGET:
-		err = istgt_target_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_SESSION:
-		err = session_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_CONNECTION:
-		err = conn_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_USER:
-		err = user_mgmt(req, params, rbuf, &rlen);
-		break;
-	default:
-		eprintf("Unknown mode %d\n", req->mode);
-		break;
-	}
-
-	nlh = (struct nlmsghdr *) rbuf;
-	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
-	res = NLMSG_DATA(nlh);
-	res->err = err;
-
-	return err;
-}
-
-#endif
-
-struct iscsi_kernel_interface nl_ki = {
-/* 	.param_get = iscsi_param_get, */
-/* 	.param_set = iscsi_param_set, */
-/* 	.session_create = iscsi_session_create, */
-/* 	.session_destroy = iscsi_session_destroy, */
-/* 	.conn_create = iscsi_conn_create, */
-/* 	.conn_destroy = iscsi_conn_destroy, */
-};
-
-struct iscsi_kernel_interface *ki = &nl_ki;

Copied: branches/use-scsi-ml/istgt/usr/netlink.c (from rev 447, branches/use-scsi-ml/istgt/usr/ctldev.c)



From tomo at berlios.de  Thu May  4 19:53:12 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 4 May 2006 19:53:12 +0200
Subject: [Stgt-svn] r449 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605041753.k44HrCtK000689@sheep.berlios.de>

Author: tomo
Date: 2006-05-04 19:53:08 +0200 (Thu, 04 May 2006)
New Revision: 449

Modified:
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/istgt.c
   branches/use-scsi-ml/istgt/usr/netlink.c
Log:
Took netlink code from open-iscsi.


Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 12:58:47 UTC (rev 448)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 17:53:08 UTC (rev 449)
@@ -26,6 +26,7 @@
 #define DIGEST_CRC32C           (1 << 1)
 
 extern uint64_t thandle;
+extern int nl_fd;
 
 #define sid64(isid, tsih)					\
 ({								\
@@ -190,7 +191,7 @@
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 
-/* ctldev.c */
+/* netlink.c */
 struct iscsi_kernel_interface {
 	int (*set_param) (uint64_t transport_handle, uint32_t sid,
 			  uint32_t cid, enum iscsi_param param,
@@ -209,8 +210,15 @@
 	int (*bind_conn) (uint64_t transport_handle, uint32_t sid,
 			  uint32_t cid, uint64_t transport_eph,
 			  int is_leading, int *retcode);
+	int (*start_conn) (uint64_t transport_handle, uint32_t sid,
+			   uint32_t cid, int *retcode);
+
+	int (*stop_conn) (uint64_t transport_handle, uint32_t sid,
+			  uint32_t cid, int flag);
 };
 
+extern int nl_init(void);
+
 extern struct iscsi_kernel_interface *ki;
 
 /* param.c */

Modified: branches/use-scsi-ml/istgt/usr/istgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 12:58:47 UTC (rev 448)
+++ branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 17:53:08 UTC (rev 449)
@@ -50,6 +50,7 @@
 static struct connection *incoming[INCOMING_MAX];
 static char program_name[] = "istgt";
 uint64_t thandle;
+int nl_fd;
 
 static void set_non_blocking(int fd)
 {
@@ -358,7 +359,7 @@
 
 int main(int argc, char **argv)
 {
-	int is_daemon = 1, is_debug = 1;
+	int err, is_daemon = 1, is_debug = 1;
 
 	if (is_daemon && daemon_init())
 		exit(1);
@@ -366,7 +367,9 @@
 	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
 		exit(1);
 
-	/* init nl socket here. */
+	err = nl_init();
+	if (err)
+		exit(1);
 
 	event_loop();
 

Modified: branches/use-scsi-ml/istgt/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-04 12:58:47 UTC (rev 448)
+++ branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-04 17:53:08 UTC (rev 449)
@@ -1,7 +1,20 @@
 /*
- * (C) 2004 - 2005 FUJITA Tomonori <tomof at acm.org>
+ * iSCSI Netlink/Linux Interface
  *
- * This code is licenced under the GPL.
+ * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
  */
 
 #include <ctype.h>
@@ -23,35 +36,14 @@
 
 #include "iscsid.h"
 
+#define NL_BUFSIZE 4096
+
+static struct sockaddr_nl saddr, daddr;
+
 #if 0
 extern struct qelem targets_list;
 static int typeid;
 
-static int ipc_cmnd_execute(struct nlmsghdr *nlm_send, int len)
-{
-	int err;
-	char rbuf[8192];
-	struct nlmsghdr *nlm_recv;
-	struct tgt_event *ev;
-	struct iet_msg *msg;
-
-	err = nl_cmd_call(nl_fd, nlm_send->nlmsg_type,
-			  (char *) nlm_send, len, rbuf, sizeof(rbuf));
-
-	nlm_recv = (struct nlmsghdr *) rbuf;
-	ev = NLMSG_DATA(nlm_recv);
-	switch (nlm_recv->nlmsg_type) {
-		case TGT_KEVENT_TARGET_PASSTHRU:
-			msg = (struct iet_msg *)ev->data;
-			memcpy(nlm_send, nlm_recv, len);
-			err = msg->result;
-		default:
-			err = ev->k.event_res.err;
-	}
-
-	return err;
-}
-
 void async_event(char *data)
 {
 	struct tgt_event *ev = (struct tgt_event *) data;
@@ -77,97 +69,6 @@
 	}
 }
 
-static void nlmsg_init(struct nlmsghdr *nlh, uint32_t pid, uint32_t seq,
-		       uint16_t type, uint32_t len, uint16_t flags)
-{
-	nlh->nlmsg_pid = pid;
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_seq = seq;
-}
-
-/*
- * this will have to be redone and made generic when we move it
- */
-static struct nlmsghdr *get_iet_msg(int tid, struct iet_msg **msg)
-{
-	int len;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-
-	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iet_msg));
-	nlh = calloc(1, len);
-	if (!nlh)
-		return NULL;
-
-	nlmsg_init(nlh, getpid(), 0, TGT_UEVENT_TARGET_PASSTHRU, len, 0);
-	ev = NLMSG_DATA(nlh);
-	ev->u.tgt_passthru.tid = tid;
-	ev->u.tgt_passthru.len = sizeof(struct iet_msg);
-	*msg = (struct iet_msg *)ev->data;
-
-	return nlh;
-}
-
-
-static int iscsi_conn_destroy(int tid, uint64_t sid, uint32_t cid)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct conn_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.conn_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->cid = cid;
-	msg->msg_type = IET_DEL_CONN;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_param_get(int tid, uint64_t sid, struct iscsi_param *param)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct iscsi_param_info *info;
-	int err, i;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.param_info;
-	info->tid = tid;
-	info->sid = sid;
-
-	msg->msg_type = IET_ISCSI_PARAM_GET;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	if (err < 0)
-		log_error("Can't get session param %d %d\n", info->tid, err);
-	else {
-		struct tgt_event *ev;
-
-		ev = NLMSG_DATA(nlh);
-		msg = (struct iet_msg *)ev->data;
-		info = &msg->u.param_info;
-
-		for (i = 0; i < session_key_last; i++)
-			param[i].val = info->session_param[i];
-	}
-
-	free(nlh);
-	return err;
-}
-
 static int iscsi_param_set(int tid, uint64_t sid, int type, uint32_t partial,
 			   struct iscsi_param *param)
 {
@@ -270,80 +171,6 @@
 	return 0;
 }
 
-static int iscsi_session_create(int tid, uint64_t sid,
-				uint32_t exp_cmd_sn, uint32_t max_cmd_sn)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct session_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.sess_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->exp_cmd_sn = exp_cmd_sn;
-	info->max_cmd_sn = max_cmd_sn;
-	msg->msg_type = IET_ADD_SESSION;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_session_destroy(int tid, uint64_t sid)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct session_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.sess_info;
-	info->tid = tid;
-	info->sid = sid;
-	msg->msg_type = IET_DEL_SESSION;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_conn_create(int tid, uint64_t sid, uint32_t cid,
-			     uint32_t stat_sn, uint32_t exp_stat_sn,
-			     int fd, uint32_t hdigest, uint32_t ddigest)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct conn_info *info;
-	int err;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.conn_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->cid = cid;
-	info->stat_sn = stat_sn;
-	info->exp_stat_sn = exp_stat_sn;
-	info->fd = fd;
-	info->header_digest = hdigest;
-	info->data_digest = ddigest;
-	msg->msg_type = IET_ADD_CONN;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	free(nlh);
-	return err;
-}
-
 static int istgt_ktarget_destroy(int tid)
 {
 	int err;
@@ -484,13 +311,309 @@
 
 #endif
 
+static int __nl_read(int fd, void *data, int size, int flags)
+{
+	struct sockaddr_nl saddr;
+	socklen_t slen = sizeof(saddr);
+
+	memset(&saddr, 0, sizeof(saddr));
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = getpid();
+	saddr.nl_groups = 0; /* not in mcast groups */
+
+	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
+}
+
+static int nl_read(char *buf)
+{
+	struct nlmsghdr *nlh;
+	int err;
+
+peek_again:
+	err = __nl_read(nl_fd, buf, NLMSG_LENGTH(0), MSG_PEEK);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN || errno == EINTR)
+			goto peek_again;
+		return err;
+	}
+
+	nlh = (struct nlmsghdr *) buf;
+
+	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid());
+
+read_again:
+	err = __nl_read(nl_fd, buf, nlh->nlmsg_len, 0);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		if (errno == EAGAIN || errno == EINTR)
+			goto read_again;
+		return err;
+	}
+
+	return err;
+}
+
+static void nlmsg_init(struct nlmsghdr *nlh, uint32_t pid, uint16_t type,
+		       uint32_t len)
+{
+	nlh->nlmsg_pid = pid;
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_type = type;
+}
+
+static int __kipc_call(struct iscsi_uevent *ev, int len)
+{
+	struct nlmsghdr *nlh;
+	char sbuf[NL_BUFSIZE];
+	int err;
+
+	len = NLMSG_SPACE(len);
+	memset(sbuf, 0, NL_BUFSIZE);
+	nlh = (struct nlmsghdr *) sbuf;
+	nlmsg_init(nlh, getpid(), ev->type, len);
+	memcpy(NLMSG_DATA(sbuf), ev, len);
+
+	err = sendto(nl_fd, ev, len, 0, (struct sockaddr *) &daddr,
+		     sizeof(daddr));
+	if (err < 0) {
+		eprintf("%d\n", err);
+		return err;
+	}
+
+	memset(sbuf, 0, NL_BUFSIZE);
+	err = nl_read(sbuf);
+	if (err < 0) {
+		eprintf("%d\n", err);
+		return err;
+	}
+
+	memcpy(ev, NLMSG_DATA(sbuf), sizeof(*ev));
+
+	return err;
+}
+
+static int kcreate_session(uint64_t transport_handle, uint32_t initial_cmdsn,
+		uint32_t *out_sid, uint32_t *out_hostno)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_CREATE_SESSION;
+	ev.transport_handle = transport_handle;
+	ev.u.c_session.initial_cmdsn = initial_cmdsn;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		return rc;
+	}
+
+	*out_hostno = ev.r.c_session_ret.host_no;
+	*out_sid = ev.r.c_session_ret.sid;
+
+	return 0;
+}
+
+static int kdestroy_session(uint64_t transport_handle, uint32_t sid)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_DESTROY_SESSION;
+	ev.transport_handle = transport_handle;
+	ev.u.d_session.sid = sid;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		return rc;
+	}
+
+	return 0;
+}
+
+static int kcreate_conn(uint64_t transport_handle, uint32_t sid,
+		       uint32_t cid, uint32_t *out_cid)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_CREATE_CONN;
+	ev.transport_handle = transport_handle;
+	ev.u.c_conn.cid = cid;
+	ev.u.c_conn.sid = sid;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		eprintf("%d\n", rc);
+		return rc;
+	}
+
+	if ((int)ev.r.c_conn_ret.cid == -1)
+		return -EIO;
+
+	*out_cid = ev.r.c_conn_ret.cid;
+	return 0;
+}
+
+static int kdestroy_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_DESTROY_CONN;
+	ev.transport_handle = transport_handle;
+	ev.u.d_conn.sid = sid;
+	ev.u.d_conn.cid = cid;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		eprintf("%d\n", rc);
+	}
+
+	return 0;
+}
+
+static int
+kbind_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
+	   uint64_t transport_eph, int is_leading, int *retcode)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	ev.type = ISCSI_UEVENT_BIND_CONN;
+	ev.transport_handle = transport_handle;
+	ev.u.b_conn.sid = sid;
+	ev.u.b_conn.cid = cid;
+	ev.u.b_conn.transport_eph = transport_eph;
+	ev.u.b_conn.is_leading = is_leading;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		return rc;
+	}
+
+	*retcode = ev.r.retcode;
+
+	return 0;
+}
+
+static int
+kstop_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid, int flag)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_STOP_CONN;
+	ev.transport_handle = transport_handle;
+	ev.u.stop_conn.sid = sid;
+	ev.u.stop_conn.cid = cid;
+	ev.u.stop_conn.flag = flag;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		return rc;
+	}
+
+	return 0;
+}
+
+static int
+kstart_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
+	    int *retcode)
+{
+	int rc;
+	struct iscsi_uevent ev;
+
+	memset(&ev, 0, sizeof(struct iscsi_uevent));
+
+	ev.type = ISCSI_UEVENT_START_CONN;
+	ev.transport_handle = transport_handle;
+	ev.u.start_conn.sid = sid;
+	ev.u.start_conn.cid = cid;
+
+	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
+		return rc;
+	}
+
+	*retcode = ev.r.retcode;
+	return 0;
+}
+
+static int
+kset_param(uint64_t transport_handle, uint32_t sid, uint32_t cid,
+	   enum iscsi_param param, void *value, int len, int *retcode)
+{
+	struct iscsi_uevent *ev;
+	char setparam_buf[NL_BUFSIZE];
+	int rc;
+
+	memset(setparam_buf, 0, sizeof(setparam_buf));
+	ev = (struct iscsi_uevent *) setparam_buf;
+	ev->type = ISCSI_UEVENT_SET_PARAM;
+	ev->transport_handle = transport_handle;
+	ev->u.set_param.sid = sid;
+	ev->u.set_param.cid = cid;
+	ev->u.set_param.param = param;
+	ev->u.set_param.len = len;
+	memcpy(setparam_buf + sizeof(*ev), value, len);
+
+	if ((rc = __kipc_call(ev, sizeof(*ev) + len)) < 0) {
+		return rc;
+	}
+
+	*retcode = ev->r.retcode;
+
+	return 0;
+}
+
+int nl_init(void)
+{
+	int err = 0, rsize = 256 * 1024;
+
+	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
+	if (nl_fd < 0) {
+		eprintf("Fail to create the netlink socket %d\n", errno);
+		return err;
+	}
+
+	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
+	if (err) {
+		eprintf("fail to setsockopt %d\n", errno);
+		return err;
+	}
+
+	memset(&saddr, 0, sizeof(saddr));
+	saddr.nl_family = AF_NETLINK;
+	saddr.nl_pid = getpid();
+	saddr.nl_groups = 0; /* not in mcast groups */
+	err = bind(nl_fd, (struct sockaddr *) &saddr, sizeof(saddr));
+	if (err) {
+		eprintf("can not bind NETLINK_ISCSI socket %d\n", errno);
+		close(nl_fd);
+		return err;
+	}
+
+	memset(&daddr, 0, sizeof(daddr));
+	daddr.nl_family = AF_NETLINK;
+	daddr.nl_pid = 0; /* kernel */
+	daddr.nl_groups = 0; /* unicast */
+
+	return err;
+}
+
 struct iscsi_kernel_interface nl_ki = {
-/* 	.param_get = iscsi_param_get, */
-/* 	.param_set = iscsi_param_set, */
-/* 	.session_create = iscsi_session_create, */
-/* 	.session_destroy = iscsi_session_destroy, */
-/* 	.conn_create = iscsi_conn_create, */
-/* 	.conn_destroy = iscsi_conn_destroy, */
+	.create_session		= kcreate_session,
+	.destroy_session	= kdestroy_session,
+	.create_conn		= kcreate_conn,
+	.destroy_conn		= kdestroy_conn,
+	.bind_conn		= kbind_conn,
+	.set_param              = kset_param,
+	.start_conn             = kstart_conn,
+	.stop_conn              = kstop_conn,
 };
 
 struct iscsi_kernel_interface *ki = &nl_ki;



From tomo at berlios.de  Fri May  5 11:14:53 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 11:14:53 +0200
Subject: [Stgt-svn] r450 - in branches/use-scsi-ml: . istgt/usr usr
Message-ID: <200605050914.k459ErKp001511@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 11:14:39 +0200 (Fri, 05 May 2006)
New Revision: 450

Added:
   branches/use-scsi-ml/istgt/usr/libistgt.c
Modified:
   branches/use-scsi-ml/initd
   branches/use-scsi-ml/istgt/usr/Makefile
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/istgt.c
   branches/use-scsi-ml/istgt/usr/netlink.c
   branches/use-scsi-ml/istgt/usr/target.c
   branches/use-scsi-ml/usr/mgmt.c
Log:
tgtadm requests go to istgtd through tgtd by using ipc. We need to
find a better way later on.


Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/initd	2006-05-05 09:14:39 UTC (rev 450)
@@ -7,7 +7,7 @@
 MEM_SIZE=1048576
 export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${PWD}/ibmvstgt/usr:${LD_LIBRARY_PATH}
 
-if [ -f ${PWD}/istgt/kernel/istgt.ko ] ; then
+if [ -f ${PWD}/istgt/kernel/istgt_tcp.ko ] ; then
 	TARGET=istgt
 fi
 
@@ -17,7 +17,10 @@
 
 	if [ "$TARGET" = "istgt" ] ; then
 		modprobe -q crc32c
-		insmod ${PWD}/istgt/kernel/istgt.ko
+		insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
+		insmod ${PWD}/istgt/kernel/libiscsi.ko
+		insmod ${PWD}/istgt/kernel/istgt_tcp.ko
+		${PWD}/istgt/usr/istgtd
 	else
 		insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
 		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
@@ -26,19 +29,13 @@
 	${PWD}/usr/tgtd -d0
 
 	sleep 1
-
-	if [ "$TARGET" = "istgt" ] ; then
-		echo "Start istgt"    
-#		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-#		${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
-#		${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
-	fi
 }
 	
 stop_server()
 {
 	if [ "$TARGET" = "istgt" ] ; then
 		${PWD}/usr/tgtadm --driver istgt --op delete
+		killall -9 istgtd
 	else
 		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
 	fi
@@ -48,7 +45,9 @@
 	sleep 1
 
 	if [ "$TARGET" = "istgt" ] ; then
-		rmmod istgt
+		rmmod istgt_tcp
+		rmmod libiscsi
+		rmmod scsi_transport_iscsi
 	else
 		rmmod libsrp
 		rmmod ibmvstgt

Modified: branches/use-scsi-ml/istgt/usr/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/usr/Makefile	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/Makefile	2006-05-05 09:14:39 UTC (rev 450)
@@ -1,9 +1,11 @@
 CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../include -I../../include -I../../usr
 LIBS = -lcrypto
-OBJS = param.o iscsid.o session.o target.o chap.o ctldev.o
-SHAREDLIB = istgt.so
+OBJS = libistgt.o
+SHAREDLIB = libistgt.so
 DAEMON = istgtd
 
+all: $(DAEMON) $(SHAREDLIB)
+
 $(DAEMON): log.o istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
 	$(CC) $^ -o $@ $(LIBS)
 

Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-05 09:14:39 UTC (rev 450)
@@ -20,13 +20,14 @@
 #include <scsi/iscsi_proto.h>
 
 #define ISCSI_NAME_LEN 255
+#define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
 
 #define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
 #define DIGEST_NONE		(1 << 0)
 #define DIGEST_CRC32C           (1 << 1)
 
 extern uint64_t thandle;
-extern int nl_fd;
+extern int nl_fd, ipc_fd;
 
 #define sid64(isid, tsih)					\
 ({								\
@@ -191,6 +192,9 @@
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 
+extern void ipc_event(void);
+extern int ipc_init(void);
+
 /* netlink.c */
 struct iscsi_kernel_interface {
 	int (*set_param) (uint64_t transport_handle, uint32_t sid,

Modified: branches/use-scsi-ml/istgt/usr/istgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-05 09:14:39 UTC (rev 450)
@@ -41,7 +41,8 @@
 
 enum {
 	POLL_LISTEN,
-	POLL_NL = POLL_LISTEN + LISTEN_MAX,
+	POLL_IPC = POLL_LISTEN + LISTEN_MAX,
+	POLL_NL,
 	POLL_INCOMING,
 	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
 };
@@ -50,7 +51,7 @@
 static struct connection *incoming[INCOMING_MAX];
 static char program_name[] = "istgt";
 uint64_t thandle;
-int nl_fd;
+int nl_fd, ipc_fd;
 
 static void set_non_blocking(int fd)
 {
@@ -59,9 +60,9 @@
 	if (res != -1) {
 		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
 		if (res)
-			dprintf("unable to set fd flags (%s)!", strerror(errno));
+			dprintf("unable to set fd flags (%s)!\n", strerror(errno));
 	} else
-		dprintf("unable to get fd flags (%s)!", strerror(errno));
+		dprintf("unable to get fd flags (%s)!\n", strerror(errno));
 }
 
 static void listen_socket_create(struct pollfd *pfds)
@@ -78,14 +79,14 @@
 	hints.ai_flags = AI_PASSIVE;
 
 	if (getaddrinfo(NULL, servname, &hints, &res0)) {
-		eprintf("unable to get address info (%s)!", strerror(errno));
+		eprintf("unable to get address info (%s)!\n", strerror(errno));
 		exit(1);
 	}
 
 	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
 		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (sock < 0) {
-			eprintf("unable to create server socket (%s) %d %d %d!",
+			eprintf("unable to create server socket (%s) %d %d %d!\n",
 				  strerror(errno), res->ai_family,
 				  res->ai_socktype, res->ai_protocol);
 			continue;
@@ -93,7 +94,7 @@
 
 		opt = 1;
 		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
-			dprintf("unable to set SO_REUSEADDR on server socket (%s)!",
+			dprintf("unable to set SO_REUSEADDR on server socket (%s)!\n",
 				    strerror(errno));
 		opt = 1;
 		if (res->ai_family == AF_INET6 &&
@@ -101,12 +102,12 @@
 			continue;
 
 		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
-			eprintf("unable to bind server socket (%s)!", strerror(errno));
+			eprintf("unable to bind server socket (%s)!\n", strerror(errno));
 			continue;
 		}
 
 		if (listen(sock, INCOMING_MAX)) {
-			eprintf("unable to listen to server socket (%s)!", strerror(errno));
+			eprintf("unable to listen to server socket (%s)!\n", strerror(errno));
 			continue;
 		}
 
@@ -132,7 +133,7 @@
 	namesize = sizeof(from);
 	if ((fd = accept(afd, (struct sockaddr *) &from, &namesize)) < 0) {
 		if (errno != EINTR && errno != EAGAIN) {
-			eprintf("accept(incoming_socket)");
+			eprintf("accept(incoming_socket)\n");
 			exit(1);
 		}
 		return;
@@ -149,7 +150,7 @@
 
 	conn = conn_alloc();
 	if (!conn) {
-		eprintf("fail to allocate %s", "conn\n");
+		eprintf("fail to allocate conn\n");
 		goto out;
 	}
 	conn->fd = fd;
@@ -179,6 +180,12 @@
 			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
 	}
 
+/* 	if (pfd[POLL_NL].revents) */
+/* 		handle_iscsi_events(nl_fd); */
+
+	if (pfds[POLL_IPC].revents)
+		ipc_event();
+
 	for (i = 0; i < INCOMING_MAX; i++) {
 		conn = incoming[i];
 		pfd = &pfds[POLL_INCOMING + i];
@@ -301,7 +308,7 @@
 		}
 
 		if (conn->state == STATE_CLOSE) {
-			log_debug("connection closed");
+			dprintf("connection closed\n");
 			conn_free_pdu(conn);
 			conn_free(conn);
 			close(pfd->fd);
@@ -315,6 +322,11 @@
 {
 	int i, err;
 
+	pfd[POLL_NL].fd = nl_fd;
+	pfd[POLL_NL].events = POLLIN;
+	pfd[POLL_IPC].fd = ipc_fd;
+	pfd[POLL_IPC].events = POLLIN;
+
 	listen_socket_create(pfd + POLL_LISTEN);
 
 	for (i = 0; i < INCOMING_MAX; i++) {
@@ -371,6 +383,10 @@
 	if (err)
 		exit(1);
 
+	err = ipc_init();
+	if (err)
+		exit(1);
+
 	event_loop();
 
 	return 0;

Added: branches/use-scsi-ml/istgt/usr/libistgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/libistgt.c	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/libistgt.c	2006-05-05 09:14:39 UTC (rev 450)
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <dirent.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <fcntl.h>
+#include <linux/types.h>
+#include <linux/netlink.h>
+
+#include "iscsid.h"
+#include "tgtadm.h"
+
+static int ipc_connect(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, ISTGT_NAMESPACE, strlen(ISTGT_NAMESPACE));
+
+	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		fd = err;
+
+	return fd;
+}
+
+int ipc_mgmt(char *sbuf, char *rbuf)
+{
+	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
+	struct tgtadm_req *req;
+	int err = -EINVAL, fd;
+	char *params;
+
+	req = NLMSG_DATA(nlh);
+	params = (char *) req + sizeof(*req);
+
+	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
+		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
+
+	fd = ipc_connect();
+	if (fd < 0) {
+		eprintf("cannot connect istgtd\n");
+		return fd;
+	}
+
+	err = write(fd, sbuf, nlh->nlmsg_len);
+	if (err < 0) {
+		eprintf("cannot connect istgtd\n");
+		goto out;
+	}
+
+out:
+	close(fd);
+
+	return err;
+}

Modified: branches/use-scsi-ml/istgt/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-05 09:14:39 UTC (rev 450)
@@ -35,15 +35,13 @@
 #include <linux/netlink.h>
 
 #include "iscsid.h"
+#include "tgtadm.h"
 
 #define NL_BUFSIZE 4096
 
 static struct sockaddr_nl saddr, daddr;
 
 #if 0
-extern struct qelem targets_list;
-static int typeid;
-
 void async_event(char *data)
 {
 	struct tgt_event *ev = (struct tgt_event *) data;
@@ -68,247 +66,6 @@
 		break;
 	}
 }
-
-static int iscsi_param_set(int tid, uint64_t sid, int type, uint32_t partial,
-			   struct iscsi_param *param)
-{
-	struct iet_msg *msg;
-	struct nlmsghdr *nlh;
-	struct iscsi_param_info *info;
-	int err, i;
-
-	nlh = get_iet_msg(tid, &msg);
-	if (!nlh)
-		return -ENOMEM;
-
-	info = &msg->u.param_info;
-	info->tid = tid;
-	info->sid = sid;
-	info->param_type = type;
-	info->partial = partial;
-
-	if (type == key_session)
-		for (i = 0; i < session_key_last; i++)
-			info->session_param[i] = param[i].val;
-	else
-		for (i = 0; i < target_key_last; i++)
-			info->target_param[i] = param[i].val;
-	msg->msg_type = IET_ISCSI_PARAM_SET;
-
-	err = ipc_cmnd_execute(nlh, nlh->nlmsg_len);
-	if (err)
-		eprintf("%d %d %u %" PRIx64 "%d %u\n",
-			err, errno, tid, sid, type, partial);
-	free(nlh);
-	return err;
-}
-
-static int iscsi_param_partial_set(int tid, uint64_t sid, int type, int key,
-				   uint32_t val)
-{
-	struct iscsi_param *param;
-	struct iscsi_param s_param[session_key_last];
-	struct iscsi_param t_param[target_key_last];
-
-	if (type == key_session)
-		param = s_param;
-	else
-		param = t_param;
-
-	param[key].val = val;
-
-	return iscsi_param_set(tid, sid, type, 1 << key, param);
-}
-
-static int trgt_mgmt_params(int tid, uint64_t sid, char *params)
-{
-	char *p, *q;
-	uint32_t s_partial = 0, t_partial = 0;
-	struct iscsi_param s_param[session_key_last];
-	struct iscsi_param t_param[target_key_last];
-
-	while ((p = strsep(&params, ",")) != NULL) {
-		int idx;
-		uint32_t val;
-		if (!*p)
-			continue;
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-		val = strtol(q, NULL, 0);
-
-		if (!((idx = param_index_by_name(p, target_keys)) < 0)) {
-			if (!param_check_val(target_keys, idx, &val))
-				t_partial |= (1 << idx);
-			else
-				eprintf("invalid val %s, %u\n",
-					target_keys[idx].name, val);
-			t_param[idx].val = val;
-
-			continue;
-		}
-
-		if (!((idx = param_index_by_name(p, session_keys)) < 0)) {
-			if (!param_check_val(session_keys, idx, &val))
-				s_partial |= (1 << idx);
-			else
-				eprintf("invalid val %s, %u\n",
-					session_keys[idx].name, val);
-			s_param[idx].val = val;
-		}
-	}
-
-	if (t_partial && s_partial) {
-		eprintf("%s", "Cannot change both at the same time\n");
-		return -EINVAL;
-	} else if (t_partial)
-		return iscsi_param_set(tid, sid, key_target, t_partial, t_param);
-	else if (s_partial)
-		return iscsi_param_set(tid, sid, key_session, s_partial, s_param);
-	else
-		eprintf("%s", "Nothing to do\n");
-
-	return 0;
-}
-
-static int istgt_ktarget_destroy(int tid)
-{
-	int err;
-	struct target* target;
-
-	if (!(target = target_find_by_id(tid)))
-		return -ENOENT;
-
-	if (target->nr_sessions)
-		return -EBUSY;
-
-	if (!list_empty(&target->sessions_list)) {
-		eprintf("bug still have sessions %d\n", tid);
-		exit(-1);
-	}
-
-	err = ktarget_destroy(tid);
-	if (err < 0)
-		return err;
-
-	remque(&target->tlist);
-
-	free(target);
-
-	return 0;
-}
-
-static int istgt_ktarget_create(int typeid, char *name)
-{
-	struct target *target;
-	int err;
-
-	if (!name)
-		return -EINVAL;
-
-	if (!(target = malloc(sizeof(*target))))
-		return -ENOMEM;
-
-	memset(target, 0, sizeof(*target));
-	memcpy(target->name, name, sizeof(target->name) - 1);
-
-	err = ktarget_create(typeid);
-	if (err < 0) {
-		eprintf("can't create a target %d\n", err);
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&target->tlist);
-	INIT_LIST_HEAD(&target->sessions_list);
-	target->tid = err;
-	insque(&target->tlist, &targets_list);
-
-	return err;
-out:
-	free(target);
-	return err;
-}
-
-static int istgt_target_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	int err = -EINVAL, tid = req->tid;
-
-	switch (req->op) {
-	case OP_NEW:
-		err = istgt_ktarget_create(typeid, params);
-		break;
-	case OP_DELETE:
-		err = istgt_ktarget_destroy(tid);
-		break;
-	case OP_UPDATE:
-		err = trgt_mgmt_params(tid, req->sid, params);
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
-static int user_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int conn_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-static int session_mgmt(struct tgtadm_req *req, char *params, char *rbuf, int *rlen)
-{
-	return 0;
-}
-
-int ipc_mgmt(char *sbuf, char *rbuf)
-{
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct tgtadm_req *req;
-	struct tgtadm_res *res;
-	int err = -EINVAL, rlen = 0;
-	char *params;
-
-	req = NLMSG_DATA(nlh);
-	params = (char *) req + sizeof(*req);
-
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
-
-	switch (req->mode) {
-	case MODE_DEVICE:
-	case MODE_SYSTEM:
-		err = tgt_mgmt(sbuf, rbuf);
-		break;
-	case MODE_TARGET:
-		err = istgt_target_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_SESSION:
-		err = session_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_CONNECTION:
-		err = conn_mgmt(req, params, rbuf, &rlen);
-		break;
-	case MODE_USER:
-		err = user_mgmt(req, params, rbuf, &rlen);
-		break;
-	default:
-		eprintf("Unknown mode %d\n", req->mode);
-		break;
-	}
-
-	nlh = (struct nlmsghdr *) rbuf;
-	nlh->nlmsg_len = NLMSG_LENGTH(rlen);
-	res = NLMSG_DATA(nlh);
-	res->err = err;
-
-	return err;
-}
-
 #endif
 
 static int __nl_read(int fd, void *data, int size, int flags)

Modified: branches/use-scsi-ml/istgt/usr/target.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/target.c	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/istgt/usr/target.c	2006-05-05 09:14:39 UTC (rev 450)
@@ -10,7 +10,11 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 #include <sys/stat.h>
+#include <sys/un.h>
+#include <linux/netlink.h>
+#include <sys/socket.h>
 
 #include "iscsid.h"
 #include "tgtadm.h"
@@ -57,3 +61,180 @@
 
 	return NULL;
 }
+
+static int destroy_target(int tid)
+{
+	struct target* target;
+
+	if (!(target = target_find_by_id(tid)))
+		return -ENOENT;
+
+	if (target->nr_sessions)
+		return -EBUSY;
+
+	if (!list_empty(&target->sessions_list)) {
+		eprintf("bug still have sessions %d\n", tid);
+		exit(-1);
+	}
+
+	remque(&target->tlist);
+
+	free(target);
+
+	return 0;
+}
+
+static int create_target(int tid, char *name)
+{
+	struct target *target;
+
+	if (!name)
+		return -EINVAL;
+
+	dprintf("%d %s\n", tid, name);
+
+	if (!(target = malloc(sizeof(*target))))
+		return -ENOMEM;
+
+	memset(target, 0, sizeof(*target));
+	memcpy(target->name, name, sizeof(target->name) - 1);
+
+	INIT_LIST_HEAD(&target->tlist);
+	INIT_LIST_HEAD(&target->sessions_list);
+	target->tid = tid;
+	insque(&target->tlist, &targets_list);
+
+	return 0;
+}
+
+static int istgt_target_mgmt(struct tgtadm_req *req, char *params)
+{
+	int err = -EINVAL, tid = req->tid;
+
+	switch (req->op) {
+	case OP_NEW:
+		err = create_target(tid, params);
+		break;
+	case OP_DELETE:
+		err = destroy_target(tid);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int ipc_accept(int afd)
+{
+	struct sockaddr addr;
+	socklen_t len;
+
+	len = sizeof(addr);
+	return accept(afd, (struct sockaddr *) &addr, &len);
+}
+
+static int ipc_perm(int fd)
+{
+	struct ucred cred;
+	socklen_t len;
+	int err;
+
+	len = sizeof(cred);
+	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
+	if (err < 0)
+		goto out;
+
+	if (cred.uid || cred.gid) {
+		err = -EPERM;
+		goto out;
+	}
+out:
+	return err;
+}
+
+void ipc_event(void)
+{
+	int fd, err;
+	char sbuf[4096], rbuf[4096];
+	struct nlmsghdr *nlh;
+	struct iovec iov;
+	struct msghdr msg;
+	struct tgtadm_req *req;
+
+	dprintf("ipc\n");
+
+	fd = ipc_accept(ipc_fd);
+	if (fd < 0) {
+		eprintf("%d\n", fd);
+		return;
+	}
+
+	err = ipc_perm(fd);
+	if (err < 0)
+		goto fail;
+
+	memset(sbuf, 0, sizeof(sbuf));
+	memset(rbuf, 0, sizeof(rbuf));
+
+	nlh = (struct nlmsghdr *) sbuf;
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_PEEK);
+	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
+		err = -EIO;
+		goto fail;
+	}
+
+	iov.iov_base = nlh;
+	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = recvmsg(fd, &msg, MSG_DONTWAIT);
+	if (err < 0)
+		goto fail;
+
+	req = NLMSG_DATA(nlh);
+	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
+
+	if (req->mode == MODE_TARGET)
+		err = istgt_target_mgmt(req, (char *) req + sizeof(*req));
+
+fail:
+	if (fd > 0)
+		close(fd);
+
+	return;
+}
+
+/* should be moved somewhere */
+int ipc_init(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, ISTGT_NAMESPACE,
+	       strlen(ISTGT_NAMESPACE));
+
+	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
+		return err;
+
+	if ((err = listen(fd, 32)) < 0)
+		return err;
+
+	ipc_fd = fd;
+
+	return 0;
+}

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-05-04 17:53:08 UTC (rev 449)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-05-05 09:14:39 UTC (rev 450)
@@ -224,11 +224,13 @@
 	req = NLMSG_DATA(nlh);
 	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
 
+	err = tgt_mgmt((char *) nlh, rbuf);
+	if (err)
+		eprintf("%d %d %d %d %d\n",
+			req->mode, req->typeid, err, nlh->nlmsg_len, fd);
 	fn = dl_fn(dinfo, req->typeid, DL_FN_IPC_MGMT);
 	if (fn)
 		err = fn((char *) nlh, rbuf);
-	else
-		err = tgt_mgmt((char *) nlh, rbuf);
 
 send:
 	err = write(fd, nlh, nlh->nlmsg_len);



From tomo at berlios.de  Fri May  5 11:56:54 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 11:56:54 +0200
Subject: [Stgt-svn] r451 - branches/use-scsi-ml
Message-ID: <200605050956.k459us73006699@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 11:56:51 +0200 (Fri, 05 May 2006)
New Revision: 451

Added:
   branches/use-scsi-ml/iscsi
Log:
Add a makeshift script to start istgt.


Added: branches/use-scsi-ml/iscsi
===================================================================
--- branches/use-scsi-ml/iscsi	2006-05-05 09:14:39 UTC (rev 450)
+++ branches/use-scsi-ml/iscsi	2006-05-05 09:56:51 UTC (rev 451)
@@ -0,0 +1,11 @@
+#!/bin/bash
+#
+# Temporary script to start istgt
+#
+
+PATH=/sbin:/bin:/usr/sbin:/usr/bin
+
+${PWD}/usr/tgtadm --driver istgt --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+
+#${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
+#${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1


Property changes on: branches/use-scsi-ml/iscsi
___________________________________________________________________
Name: svn:executable
   + *



From tomo at berlios.de  Fri May  5 15:58:15 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 15:58:15 +0200
Subject: [Stgt-svn] r452 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605051358.k45DwFY1006511@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 15:58:01 +0200 (Fri, 05 May 2006)
New Revision: 452

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Change TGT_NAME.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-05 09:56:51 UTC (rev 451)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-05 13:58:01 UTC (rev 452)
@@ -435,6 +435,8 @@
 	struct socket *sock;
 	int err;
 
+	dprintk("%llu %u\n", (unsigned long long) transport_eph, is_leading);
+
 	sock = sockfd_lookup((int)transport_eph, &err);
 	if (!sock) {
 		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
@@ -466,6 +468,8 @@
 	struct istgt_session *istgt_session;
 	int i, err;
 
+	dprintk("%u %u\n", initial_cmdsn, *hostno);
+
 	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn,
 					       hostno);
 	if (!cls_session)
@@ -666,7 +670,7 @@
 
 
 #define	DEFAULT_NR_QUEUED_CMNDS	32
-#define TGT_NAME "istgt_tcp"
+#define TGT_NAME "iscsi_tgt_tcp"
 
 static struct scsi_host_template istgt_tcp_sht = {
 	.name			= TGT_NAME,



From tomo at berlios.de  Fri May  5 16:00:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 16:00:03 +0200
Subject: [Stgt-svn] r453 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605051400.k45E03WH014741@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 15:59:59 +0200 (Fri, 05 May 2006)
New Revision: 453

Modified:
   branches/use-scsi-ml/istgt/usr/conn.c
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/istgt.c
   branches/use-scsi-ml/istgt/usr/netlink.c
Log:
Fix netlink code.

Modified: branches/use-scsi-ml/istgt/usr/conn.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/conn.c	2006-05-05 13:58:01 UTC (rev 452)
+++ branches/use-scsi-ml/istgt/usr/conn.c	2006-05-05 13:59:59 UTC (rev 453)
@@ -68,22 +68,21 @@
 {
 	int err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
-	uint32_t cid = conn->cid;
 
 	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
 		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;
 
-	err = ki->create_conn(thandle, sid, cid, &cid);
+	err = ki->create_conn(thandle, conn->session->ksid, conn->kcid,
+			      &conn->kcid);
 	if (err) {
 		eprintf("%d %d %u %u %u %" PRIx64,
 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 		goto out;
 	}
-	conn->cid = cid;
 
-	if (ki->bind_conn(thandle, sid, conn->cid, fd, 1, &err) || err) {
+	if (ki->bind_conn(thandle, conn->session->ksid, conn->kcid, fd, 1, &err) || err) {
 		eprintf("%d %d %u %u %u %" PRIx64,
 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 		goto out;
@@ -95,6 +94,12 @@
 /* 		goto out; */
 /* 	} */
 
+	if (ki->start_conn(thandle, conn->session->ksid, conn->kcid, &err) || err) {
+		eprintf("%d %d %u %u %u %" PRIx64,
+			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
+		goto out;
+	}
+
 /* 	conn->stat_sn */
 /* 		conn->session_param[key_header_digest].val, */
 /* 		conn->session_param[key_data_digest].val); */

Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-05 13:58:01 UTC (rev 452)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-05 13:59:59 UTC (rev 453)
@@ -84,6 +84,9 @@
 	int session_type;
 	int auth_method;
 
+	/* workaroud */
+	uint32_t kcid;
+
 	uint32_t stat_sn;
 	uint32_t exp_stat_sn;
 

Modified: branches/use-scsi-ml/istgt/usr/istgt.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-05 13:58:01 UTC (rev 452)
+++ branches/use-scsi-ml/istgt/usr/istgt.c	2006-05-05 13:59:59 UTC (rev 453)
@@ -311,7 +311,7 @@
 			dprintf("connection closed\n");
 			conn_free_pdu(conn);
 			conn_free(conn);
-			close(pfd->fd);
+/* 			close(pfd->fd); */
 			pfd->fd = -1;
 			incoming[i] = NULL;
 		}

Modified: branches/use-scsi-ml/istgt/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-05 13:58:01 UTC (rev 452)
+++ branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-05 13:59:59 UTC (rev 453)
@@ -97,8 +97,7 @@
 
 	nlh = (struct nlmsghdr *) buf;
 
-	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid());
-
+/* 	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid()); */
 read_again:
 	err = __nl_read(nl_fd, buf, nlh->nlmsg_len, 0);
 	if (err < 0) {
@@ -111,28 +110,22 @@
 	return err;
 }
 
-static void nlmsg_init(struct nlmsghdr *nlh, uint32_t pid, uint16_t type,
-		       uint32_t len)
-{
-	nlh->nlmsg_pid = pid;
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_type = type;
-}
-
 static int __kipc_call(struct iscsi_uevent *ev, int len)
 {
 	struct nlmsghdr *nlh;
 	char sbuf[NL_BUFSIZE];
 	int err;
 
-	len = NLMSG_SPACE(len);
+	nlh = (struct nlmsghdr *) sbuf;
 	memset(sbuf, 0, NL_BUFSIZE);
-	nlh = (struct nlmsghdr *) sbuf;
-	nlmsg_init(nlh, getpid(), ev->type, len);
-	memcpy(NLMSG_DATA(sbuf), ev, len);
+	memcpy(NLMSG_DATA(nlh), ev, len);
 
-	err = sendto(nl_fd, ev, len, 0, (struct sockaddr *) &daddr,
-		     sizeof(daddr));
+	len = NLMSG_SPACE(len);
+	nlh->nlmsg_pid = getpid();
+	nlh->nlmsg_len = len;
+	nlh->nlmsg_type = ev->type;
+
+	err = sendto(nl_fd, nlh, len, 0, (struct sockaddr *) &daddr, sizeof(daddr));
 	if (err < 0) {
 		eprintf("%d\n", err);
 		return err;
@@ -156,6 +149,9 @@
 	int rc;
 	struct iscsi_uevent ev;
 
+	dprintf("%"PRIx64 " %u %u %u\n",
+		transport_handle, initial_cmdsn, *out_sid, *out_hostno);
+
 	memset(&ev, 0, sizeof(struct iscsi_uevent));
 
 	ev.type = ISCSI_UEVENT_CREATE_SESSION;
@@ -196,6 +192,8 @@
 	int rc;
 	struct iscsi_uevent ev;
 
+	dprintf("%"PRIx64 " %u %u\n", transport_handle, sid, cid);
+
 	memset(&ev, 0, sizeof(struct iscsi_uevent));
 
 	ev.type = ISCSI_UEVENT_CREATE_CONN;
@@ -327,10 +325,33 @@
 	return 0;
 }
 
+static int transport_handle_init(void)
+{
+	int fd, err;
+	char buf[64];
+
+	fd = open("/sys/class/iscsi_transport/iscsi_tgt_tcp/handle", O_RDONLY);
+	if (fd < 0)
+		return fd;
+	err = read(fd, buf, sizeof(buf));
+	if (err < 0)
+		goto out;
+	thandle = strtoull(buf, NULL, 10);
+	dprintf("%" PRIx64 "\n", thandle);
+	err = 0;
+out:
+	close(fd);
+	return err;
+}
+
 int nl_init(void)
 {
-	int err = 0, rsize = 256 * 1024;
+	int err, rsize = 256 * 1024;
 
+	err = transport_handle_init();
+	if (err)
+		return err;
+
 	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
 	if (nl_fd < 0) {
 		eprintf("Fail to create the netlink socket %d\n", errno);



From tomo at berlios.de  Fri May  5 17:03:58 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 17:03:58 +0200
Subject: [Stgt-svn] r454 - branches/use-scsi-ml/istgt/usr
Message-ID: <200605051503.k45F3wik031817@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 17:03:57 +0200 (Fri, 05 May 2006)
New Revision: 454

Modified:
   branches/use-scsi-ml/istgt/usr/iscsid.h
   branches/use-scsi-ml/istgt/usr/session.c
   branches/use-scsi-ml/istgt/usr/target.c
Log:
When istgt creates a session, it tries to bind it to a target.


Modified: branches/use-scsi-ml/istgt/usr/iscsid.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-05 13:59:59 UTC (rev 453)
+++ branches/use-scsi-ml/istgt/usr/iscsid.h	2006-05-05 15:03:57 UTC (rev 454)
@@ -194,6 +194,7 @@
 extern int target_find_by_name(const char *name, int *tid);
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
+extern int target_bind(int tid, int hostno);
 
 extern void ipc_event(void);
 extern int ipc_init(void);

Modified: branches/use-scsi-ml/istgt/usr/session.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/session.c	2006-05-05 13:59:59 UTC (rev 453)
+++ branches/use-scsi-ml/istgt/usr/session.c	2006-05-05 15:03:57 UTC (rev 454)
@@ -101,7 +101,7 @@
 	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
 			   &session->hostno);
 
-	/* FIXME: we need to bind host to target here */
+	target_bind(session->target->tid, session->hostno);
 }
 
 void session_remove(struct session *session)

Modified: branches/use-scsi-ml/istgt/usr/target.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/target.c	2006-05-05 13:59:59 UTC (rev 453)
+++ branches/use-scsi-ml/istgt/usr/target.c	2006-05-05 15:03:57 UTC (rev 454)
@@ -18,6 +18,7 @@
 
 #include "iscsid.h"
 #include "tgtadm.h"
+#include "tgt_sysfs.h"
 
 struct qelem targets_list = LIST_HEAD_INIT(targets_list);
 
@@ -238,3 +239,91 @@
 
 	return 0;
 }
+
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static int lldname_to_id(char *name)
+{
+	struct dirent **namelist;
+	int i, nr, id = -EINVAL;
+	char *p;
+
+	nr = scandir(TGT_LLD_SYSFSDIR, &namelist, filter, alphasort);
+	if (!nr)
+		return -EINVAL;
+
+	for (i = 0; i < nr; i++) {
+		p = strchr(namelist[i]->d_name, '-');
+		if (p && !strcmp(name, p + 1)) {
+			*p='\0';
+			id = atoi(namelist[i]->d_name);
+			break;
+		}
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return id;
+}
+
+static int ipc_mgmt_connect(void)
+{
+	int fd, err;
+	struct sockaddr_un addr;
+
+	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (fd < 0)
+		return fd;
+
+	memset(&addr, 0, sizeof(addr));
+	addr.sun_family = AF_LOCAL;
+	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE, strlen(TGT_IPC_NAMESPACE));
+
+	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0)
+		return err;
+
+	return fd;
+}
+
+int target_bind(int tid, int hostno)
+{
+	struct tgtadm_req *req;
+	struct nlmsghdr *nlh;
+	char buf[1024];
+	int fd, err;
+
+	nlh = (struct nlmsghdr *) buf;
+	req = NLMSG_DATA(nlh);
+
+	req->mode = MODE_TARGET;
+	req->op = OP_BIND;
+	req->tid = tid;
+	req->host_no = hostno;
+	req->typeid = lldname_to_id("istgt");
+
+	nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*req));
+	nlh->nlmsg_type = 0;
+	nlh->nlmsg_flags = 0;
+	nlh->nlmsg_pid = getpid();
+
+	fd = ipc_mgmt_connect();
+	if (fd < 0) {
+		eprintf("Cannot connect tgtd\n");
+		return fd;
+	}
+
+	err = write(fd, buf, nlh->nlmsg_len);
+	if (err < 0)
+		eprintf("Cannot send to tgtd %d\n", err);
+
+	err = read(fd, buf, sizeof(buf));
+
+	close(fd);
+	return 0;
+}



From tomo at berlios.de  Fri May  5 18:03:21 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 5 May 2006 18:03:21 +0200
Subject: [Stgt-svn] r455 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605051603.k45G3LpT004586@sheep.berlios.de>

Author: tomo
Date: 2006-05-05 18:03:20 +0200 (Fri, 05 May 2006)
New Revision: 455

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Simplify istgt_tcp_conn_bind().

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-05 15:03:57 UTC (rev 454)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-05 16:03:20 UTC (rev 455)
@@ -48,11 +48,14 @@
 MODULE_DESCRIPTION("iSCSI/TCP data-path");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0:4.445");
-/* #define DEBUG_TCP */
+#define DEBUG_TCP
 #define DEBUG_ASSERT
 
 #ifdef DEBUG_TCP
-#define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt)
+#define debug_tcp(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+} while (0)
 #else
 #define debug_tcp(fmt...)
 #endif

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-05 15:03:57 UTC (rev 454)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-05 16:03:20 UTC (rev 455)
@@ -433,28 +433,25 @@
 		    int is_leading)
 {
 	struct socket *sock;
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int err;
 
 	dprintk("%llu %u\n", (unsigned long long) transport_eph, is_leading);
 
-	sock = sockfd_lookup((int)transport_eph, &err);
-	if (!sock) {
-		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
-		return -EEXIST;
+	err = iscsi_tcp_conn_bind(cls_session, cls_conn, transport_eph, is_leading);
+	if (err) {
+		eprintk("fail to bind %d\n", err);
+		return err;
 	}
 
-	err = iscsi_tcp_conn_bind(cls_session, cls_conn, transport_eph, is_leading);
-	if (err)
-		goto out;
+	sock = tcp_conn->sock;
 
 	write_lock_bh(&sock->sk->sk_callback_lock);
-
 	sock->sk->sk_data_ready = istgt_tcp_data_ready;
-
 	write_unlock_bh(&sock->sk->sk_callback_lock);
-out:
-	sock_release(sock);
-	return err;
+
+	return 0;
 }
 
 static struct iscsi_cls_session *
@@ -668,7 +665,6 @@
 	return 0;
 }
 
-
 #define	DEFAULT_NR_QUEUED_CMNDS	32
 #define TGT_NAME "iscsi_tgt_tcp"
 



From tomo at berlios.de  Sat May  6 02:09:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 02:09:43 +0200
Subject: [Stgt-svn] r456 - trunk
Message-ID: <200605060009.k4609hbs026445@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 02:09:38 +0200 (Sat, 06 May 2006)
New Revision: 456

Modified:
   trunk/README
Log:
Update README.


Modified: trunk/README
===================================================================
--- trunk/README	2006-05-05 16:03:20 UTC (rev 455)
+++ trunk/README	2006-05-06 00:09:38 UTC (rev 456)
@@ -1,3 +1,9 @@
+This tree is obsolete. If you are not interested in the history,
+please use:
+
+svn+ssh://svn.berlios.de/svnroot/repos/stgt/branches/use-scsi-ml
+
+
 Introduction
 -------------
 Note that linux target framework software (tgt) is under active



From tomo at berlios.de  Sat May  6 03:21:09 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 03:21:09 +0200
Subject: [Stgt-svn] r457 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605060121.k461L9H4015728@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 03:21:03 +0200 (Sat, 06 May 2006)
New Revision: 457

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
Log:
For easy debug, use kthread instead of bottom half. We'll revert it later on.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 00:09:38 UTC (rev 456)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 01:21:03 UTC (rev 457)
@@ -315,7 +315,11 @@
 		hdr->hlength << 2, tcp_conn->in.datalen);
 
 	/* FIXME */
-	BUG_ON(tcp_conn->in.datalen);
+	if (tcp_conn->in.datalen) {
+		iscsi_conn_failure(conn, rc);
+		eprintk("Cannot handle this now\n");
+		return 1;
+	}
 
 	switch (opcode) {
 	case ISCSI_OP_NOOP_OUT:
@@ -323,30 +327,36 @@
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
 		__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+		BUG_ON(!ctask);
+
 		ctask->conn = conn;
 		ctask->data_count = 0;
+		BUG_ON(!ctask->hdr);
 		memcpy(ctask->hdr, hdr, sizeof(*hdr));
 
 		tcp_ctask = ctask->dd_data;
+		BUG_ON(!tcp_ctask);
+
 		tcp_ctask->sg = NULL;
 		tcp_ctask->sent = 0;
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 
 		if (!tcp_conn->in.datalen) {
-			istgt_ctask_recvlist_add(tcp_conn->in.ctask);
-			tcp_conn->in.ctask = NULL;
-			schedule_work(&istgt_session->recvwork);
+/* 			istgt_ctask_recvlist_add(tcp_conn->in.ctask); */
+			ctask = NULL;
+/* 			schedule_work(&istgt_session->recvwork); */
 		}
 
-		if (opcode == ISCSI_OP_SCSI_CMD)
-			switch (ctask->hdr->cdb[0]) {
-			case WRITE_6:
-			case WRITE_10:
-			case WRITE_16:
-			case WRITE_VERIFY:
-				istgt_unsolicited_data(ctask);
-				set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
-			}
+/* 		if (opcode == ISCSI_OP_SCSI_CMD) */
+/* 			switch (ctask->hdr->cdb[0]) { */
+/* 			case WRITE_6: */
+/* 			case WRITE_10: */
+/* 			case WRITE_16: */
+/* 			case WRITE_VERIFY: */
+/* 				istgt_unsolicited_data(ctask); */
+/* 				set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx); */
+/* 			} */
+
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		BUG_ON(1);
@@ -361,6 +371,7 @@
 
 	if (ctask)
 		tcp_conn->in.ctask = ctask;
+
 	return rc;
 }
 
@@ -372,9 +383,13 @@
 
 	/* We need to return -EAGAIN if the buffer is not ready. */
 
-	BUG_ON(1);
+	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
 
-	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
+	dprintk("opcode 0x%x offset %d copy %d datalen %d\n",
+		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
+		tcp_conn->in.datalen);
+	return 1;
+
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_SCSI_DATA_OUT:
@@ -410,6 +425,16 @@
 istgt_tcp_data_ready(struct sock *sk, int flag)
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
+
+	schedule_work(&conn->tcpwork);
+}
+
+static void __istgt_tcp_data_ready(void *data)
+{
+	struct iscsi_cls_conn *cls_conn = data;
+	struct iscsi_conn *conn = cls_conn->dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct sock *sk = tcp_conn->sock->sk;
 	read_descriptor_t rd_desc;
 	struct data_ready_desc d;
 
@@ -451,6 +476,8 @@
 	sock->sk->sk_data_ready = istgt_tcp_data_ready;
 	write_unlock_bh(&sock->sk->sk_callback_lock);
 
+	INIT_WORK(&conn->tcpwork, __istgt_tcp_data_ready, cls_conn);
+
 	return 0;
 }
 

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-06 00:09:38 UTC (rev 456)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-06 01:21:03 UTC (rev 457)
@@ -171,6 +171,7 @@
 
 	/* custom statistics */
 	uint32_t		eh_abort_cnt;
+	struct work_struct	tcpwork;
 };
 
 struct iscsi_queue {



From tomo at berlios.de  Sat May  6 04:01:13 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 04:01:13 +0200
Subject: [Stgt-svn] r458 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605060201.k4621DZS029478@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 04:00:56 +0200 (Sat, 06 May 2006)
New Revision: 458

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
Log:
Kill istgt_task. Put some to iscsi_cmd_task structure.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 01:21:03 UTC (rev 457)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 02:00:56 UTC (rev 458)
@@ -50,23 +50,6 @@
 	struct work_struct recvwork;
 };
 
-struct istgt_task {
-	struct list_head hash;
-	struct list_head tlist;
-};
-
-static inline struct istgt_task *ctask_to_ttask(struct iscsi_cmd_task *ctask)
-{
-	return (struct istgt_task *) ((void *) ctask->dd_data +
-				      sizeof(struct iscsi_tcp_cmd_task));
-}
-
-static inline struct iscsi_cmd_task *ttask_to_ctask(struct istgt_task *ttask)
-{
-	return (struct iscsi_cmd_task *)
-		((void *) ttask - sizeof(struct iscsi_tcp_cmd_task));
-}
-
 static void build_r2t(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_r2t_rsp *hdr;
@@ -231,22 +214,19 @@
 	struct iscsi_cls_session *cls_session = data;
 	struct iscsi_session *session =
 		class_to_transport_session(cls_session);
-	struct istgt_session *istgt_session =
-		(struct istgt_session *) cls_session->dd_data;
+	struct istgt_session *istgt_session = cls_session->dd_data;
 	struct iscsi_cmd_task *ctask;
-	struct istgt_task *pos;
 
 retry:
 	spin_lock_bh(&istgt_session->slock);
 
 	while (istgt_session->recvlist.next) {
-		pos = list_entry(istgt_session->recvlist.next,
-				 struct istgt_task, tlist);
-		ctask = ttask_to_ctask(pos);
+		ctask = list_entry(istgt_session->recvlist.next,
+				   struct iscsi_cmd_task, tgtlist);
 		if (ctask->hdr->cmdsn != session->exp_cmdsn)
 			break;
 
-		list_del(&pos->tlist);
+		list_del(&ctask->tgtlist);
 		session->exp_cmdsn++;
 
 		spin_unlock_bh(&istgt_session->slock);
@@ -261,24 +241,21 @@
 {
 	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_cls_session *cls_session = session_to_cls(session);
-	struct istgt_session *istgt_session;
-	struct istgt_task *pos;
+	struct istgt_session *istgt_session = cls_session->dd_data;
+	struct iscsi_cmd_task *pos;
 
-	istgt_session = (struct istgt_session *) cls_session->dd_data;
-
 	spin_lock_bh(&istgt_session->slock);
 
 	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
-		list_add(&ctask_to_ttask(ctask)->tlist,
-			 &istgt_session->recvlist);
+		list_add(&ctask->tgtlist, &istgt_session->recvlist);
 		goto out;
 	}
 
-	list_for_each_entry(pos, &istgt_session->recvlist, tlist)
-		if (before(ctask->hdr->cmdsn, ttask_to_ctask(pos)->hdr->cmdsn))
+	list_for_each_entry(pos, &istgt_session->recvlist, tgtlist)
+		if (before(ctask->hdr->cmdsn, pos->hdr->cmdsn))
 			break;
 
-	list_add_tail(&ctask_to_ttask(ctask)->tlist, &pos->tlist);
+	list_add_tail(&ctask->tgtlist, &pos->tgtlist);
 out:
 	spin_unlock_bh(&istgt_session->slock);
 }
@@ -342,7 +319,7 @@
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 
 		if (!tcp_conn->in.datalen) {
-/* 			istgt_ctask_recvlist_add(tcp_conn->in.ctask); */
+/* 			istgt_ctask_recvlist_add(ctask); */
 			ctask = NULL;
 /* 			schedule_work(&istgt_session->recvwork); */
 		}
@@ -506,8 +483,8 @@
 	session = class_to_transport_session(cls_session);
 	for (i = 0; i < initial_cmdsn; i++) {
 		struct iscsi_cmd_task *ctask = session->cmds[i];
-		INIT_LIST_HEAD(&ctask_to_ttask(ctask)->hash);
-		INIT_LIST_HEAD(&ctask_to_ttask(ctask)->tlist);
+		INIT_LIST_HEAD(&ctask->hash);
+		INIT_LIST_HEAD(&ctask->tgtlist);
 	}
 
 	istgt_session =	(struct istgt_session *) cls_session->dd_data;

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-06 01:21:03 UTC (rev 457)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-06 02:00:56 UTC (rev 458)
@@ -103,6 +103,9 @@
 
 	struct list_head	running;	/* running cmd list */
 	void			*dd_data;	/* driver/transport data */
+
+	struct list_head	hash;
+	struct list_head	tgtlist;
 };
 
 struct iscsi_conn {



From tomo at berlios.de  Sat May  6 07:54:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 07:54:43 +0200
Subject: [Stgt-svn] r459 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605060554.k465shXB026247@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 07:53:55 +0200 (Sat, 06 May 2006)
New Revision: 459

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix recvworker bugs.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-06 02:00:56 UTC (rev 458)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-06 05:53:55 UTC (rev 459)
@@ -2051,7 +2051,7 @@
 	return 0;
 }
 
-static void
+void
 iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-06 02:00:56 UTC (rev 458)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-06 05:53:55 UTC (rev 459)
@@ -34,5 +34,7 @@
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent);
 
+extern void iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask);
+
 extern int iscsi_tcp_init(void);
 extern void iscsi_tcp_exit(void);

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 02:00:56 UTC (rev 458)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 05:53:55 UTC (rev 459)
@@ -50,6 +50,7 @@
 	struct work_struct recvwork;
 };
 
+#if 0
 static void build_r2t(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_r2t_rsp *hdr;
@@ -104,6 +105,7 @@
 /* 	if (length) */
 /* 		goto more; */
 }
+#endif
 
 static void istgt_scsi_tgt_queue_command(struct iscsi_cmd_task *ctask)
 {
@@ -185,6 +187,9 @@
 static void istgt_cmd_exec(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_conn *conn = ctask->conn;
+	struct iscsi_cls_session *cls_session =
+		session_to_cls(ctask->conn->session);
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	u8 opcode;
 
 	opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
@@ -194,8 +199,10 @@
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
 		istgt_scsi_cmd_exec(ctask);
+		break;
 	case ISCSI_OP_LOGOUT:
 		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+		scsi_queue_work(shost, &conn->xmitwork);
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -212,17 +219,20 @@
 static void istgt_recvworker(void *data)
 {
 	struct iscsi_cls_session *cls_session = data;
-	struct iscsi_session *session =
-		class_to_transport_session(cls_session);
+	struct iscsi_session *session = class_to_transport_session(cls_session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
 	struct iscsi_cmd_task *ctask;
 
+	dprintk("%x\n", session->exp_cmdsn);
 retry:
 	spin_lock_bh(&istgt_session->slock);
 
-	while (istgt_session->recvlist.next) {
+	while (!list_empty(&istgt_session->recvlist)) {
 		ctask = list_entry(istgt_session->recvlist.next,
 				   struct iscsi_cmd_task, tgtlist);
+
+		dprintk("%p %x %x\n", ctask, ctask->hdr->cmdsn, session->exp_cmdsn);
+
 		if (ctask->hdr->cmdsn != session->exp_cmdsn)
 			break;
 
@@ -237,13 +247,16 @@
 	spin_unlock_bh(&istgt_session->slock);
 }
 
-static void istgt_ctask_recvlist_add(struct iscsi_cmd_task *ctask)
+static void istgt_ctask_add(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
 	struct iscsi_cmd_task *pos;
 
+	dprintk("%p %x %x %x\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], ctask->hdr->cmdsn);
+
 	spin_lock_bh(&istgt_session->slock);
 
 	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
@@ -260,6 +273,7 @@
 	spin_unlock_bh(&istgt_session->slock);
 }
 
+#if 0
 static void istgt_unsolicited_data(struct iscsi_cmd_task *ctask)
 {
 /* 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data; */
@@ -268,6 +282,7 @@
 /* 	tcp_ctask->r2t_data_count; */
 /* 	ctask->r2t_data_count; */
 }
+#endif
 
 static int istgt_tcp_hdr_recv(struct iscsi_conn *conn)
 {
@@ -278,8 +293,7 @@
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = NULL;
 	struct iscsi_tcp_cmd_task *tcp_ctask;
-	struct istgt_session *istgt_session =
-		(struct istgt_session *) cls_session->dd_data;
+	struct istgt_session *istgt_session = cls_session->dd_data;
 
 	rc = iscsi_tcp_hdr_recv_pre(conn);
 	if (rc)
@@ -303,11 +317,14 @@
 	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
+		spin_lock(&session->lock);
 		__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+		spin_unlock(&session->lock);
 		BUG_ON(!ctask);
 
 		ctask->conn = conn;
 		ctask->data_count = 0;
+		ctask->sc = NULL;
 		BUG_ON(!ctask->hdr);
 		memcpy(ctask->hdr, hdr, sizeof(*hdr));
 
@@ -319,9 +336,9 @@
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 
 		if (!tcp_conn->in.datalen) {
-/* 			istgt_ctask_recvlist_add(ctask); */
+			istgt_ctask_add(ctask);
 			ctask = NULL;
-/* 			schedule_work(&istgt_session->recvwork); */
+			schedule_work(&istgt_session->recvwork);
 		}
 
 /* 		if (opcode == ISCSI_OP_SCSI_CMD) */
@@ -486,6 +503,8 @@
 		INIT_LIST_HEAD(&ctask->hash);
 		INIT_LIST_HEAD(&ctask->tgtlist);
 	}
+	session->exp_cmdsn = initial_cmdsn;
+	session->max_cmdsn = initial_cmdsn + session->cmds_max / 2;
 
 	istgt_session =	(struct istgt_session *) cls_session->dd_data;
 
@@ -509,6 +528,11 @@
 	struct iscsi_cls_session *cls_session = session_to_cls(conn->session);
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 
+	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
+
+	scmd->done = done;
+
 	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 	scsi_queue_work(shost, &conn->xmitwork);
 	return 0;
@@ -520,6 +544,9 @@
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
+	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
+
 	tcp_ctask->sg = scmd->request_buffer;
 	tcp_ctask->sg_count = 0;
 	ctask->data_count = scmd->request_bufflen;
@@ -636,8 +663,12 @@
 istgt_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct scsi_cmnd *sc = ctask->sc;
 	int err;
 
+	dprintk("%p %x %x %u %x\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], ctask->data_count, tcp_ctask->xmstate);
+
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
 		istgt_response_build(ctask);
 		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
@@ -660,6 +691,16 @@
 			tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
 	}
 
+	sc->done(sc);
+
+	spin_lock_bh(&conn->session->lock);
+	__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+	/* fool iscsi_tcp_cleanup_ctask */
+	if (sc)
+		sc->sc_data_direction = DMA_TO_DEVICE;
+	iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
+	spin_unlock_bh(&conn->session->lock);
+
 	return 0;
 }
 



From tomo at berlios.de  Sat May  6 14:21:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 14:21:43 +0200
Subject: [Stgt-svn] r460 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605061221.k46CLh6L011398@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 14:21:26 +0200 (Sat, 06 May 2006)
New Revision: 460

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix transfer_data.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 05:53:55 UTC (rev 459)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 12:21:26 UTC (rev 460)
@@ -531,10 +531,18 @@
 	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
 		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
 
-	scmd->done = done;
-
-	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-	scsi_queue_work(shost, &conn->xmitwork);
+	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
+		scmd->done = done;
+		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+		scsi_queue_work(shost, &conn->xmitwork);
+	} else {
+		done(scmd);
+		spin_lock_bh(&conn->session->lock);
+		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+		scmd->sc_data_direction = DMA_TO_DEVICE;
+		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
+		spin_unlock_bh(&conn->session->lock);
+	}
 	return 0;
 }
 
@@ -543,6 +551,8 @@
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_cls_session *cls_session = session_to_cls(ctask->conn->session);
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 
 	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
 		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
@@ -564,9 +574,12 @@
 		}
 
 		bh_unlock_sock(sk);
+	} else {
+		scmd->done = done;
+		__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
+		scsi_queue_work(shost, &ctask->conn->xmitwork);
 	}
 
-	done(scmd);
 	return 0;
 }
 
@@ -577,7 +590,7 @@
 	struct scsi_cmnd *sc = ctask->sc;
 	struct scatterlist *sg = sc->request_buffer;
 
-	tcp_ctask->xmstate = XMSTATE_UNS_HDR;
+	tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
 
 	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
@@ -589,9 +602,13 @@
 			   sizeof(struct iscsi_hdr));
 
 	if (ctask->data_count) {
+		struct iscsi_buf *ibuf = &tcp_ctask->sendbuf;
 		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
 				  &sg[tcp_ctask->sg_count++]);
-		tcp_ctask->xmstate = XMSTATE_UNS_DATA;
+		tcp_ctask->sg = sg;
+		dprintk("%p %u %u %u\n", ibuf->sg.page, ibuf->sg.offset,
+			ibuf->sg.length, ibuf->use_sendmsg);
+		tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
 	}
 
 	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
@@ -643,10 +660,17 @@
 	int err;
 
 	while (1) {
+		struct iscsi_buf *ibuf = &tcp_ctask->sendbuf;
+		dprintk("%p %u %u %u\n", ibuf->sg.page, ibuf->sg.offset,
+			ibuf->sg.length, ibuf->use_sendmsg);
+
 		err = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
 				     &ctask->data_count, &tcp_ctask->sent);
-		if (err)
+		if (err) {
+			dprintk("%u %u\n", ctask->data_count, tcp_ctask->sent);
+			BUG_ON(1);
 			return -EAGAIN;
+		}
 
 		if (!ctask->data_count)
 			break;
@@ -671,15 +695,15 @@
 
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
 		istgt_response_build(ctask);
-		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
 	}
 
 	if (tcp_ctask->xmstate & XMSTATE_UNS_HDR) {
-		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf,
-				    ctask->sc->request_bufflen);
-		if (err)
+		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
+		if (err) {
+			BUG_ON(1);
+			eprintk("%d\n", err);
 			return -EAGAIN;
-		else
+		} else
 			tcp_ctask->xmstate &= ~XMSTATE_UNS_HDR;
 	}
 
@@ -693,13 +717,15 @@
 
 	sc->done(sc);
 
-	spin_lock_bh(&conn->session->lock);
-	__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-	/* fool iscsi_tcp_cleanup_ctask */
-	if (sc)
-		sc->sc_data_direction = DMA_TO_DEVICE;
-	iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
-	spin_unlock_bh(&conn->session->lock);
+	if (sc->sc_data_direction == DMA_TO_DEVICE) {
+		spin_lock_bh(&conn->session->lock);
+		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+		/* fool iscsi_tcp_cleanup_ctask */
+		if (sc)
+			sc->sc_data_direction = DMA_TO_DEVICE;
+		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
+		spin_unlock_bh(&conn->session->lock);
+	}
 
 	return 0;
 }



From tomo at berlios.de  Sat May  6 16:59:50 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 16:59:50 +0200
Subject: [Stgt-svn] r461 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605061459.k46ExoeL024041@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 16:59:49 +0200 (Sat, 06 May 2006)
New Revision: 461

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix functions to build responses.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-06 12:21:26 UTC (rev 460)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-06 14:59:49 UTC (rev 461)
@@ -73,7 +73,7 @@
 /* global data */
 static kmem_cache_t *taskcache;
 
-inline void
+static inline void
 iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
 	sg_init_one(&ibuf->sg, (u8 *)vbuf, size);
@@ -81,7 +81,7 @@
 	ibuf->use_sendmsg = 0;
 }
 
-static inline void
+inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
 	ibuf->sg.page = virt_to_page(vbuf);

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-06 12:21:26 UTC (rev 460)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-06 14:59:49 UTC (rev 461)
@@ -24,7 +24,7 @@
 			       unsigned int offset, size_t len);
 
 extern void
-iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size);
+iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size);
 extern void
 iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg);
 

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 12:21:26 UTC (rev 460)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 14:59:49 UTC (rev 461)
@@ -325,6 +325,7 @@
 		ctask->conn = conn;
 		ctask->data_count = 0;
 		ctask->sc = NULL;
+		ctask->datasn = 0;
 		BUG_ON(!ctask->hdr);
 		memcpy(ctask->hdr, hdr, sizeof(*hdr));
 
@@ -504,7 +505,6 @@
 		INIT_LIST_HEAD(&ctask->tgtlist);
 	}
 	session->exp_cmdsn = initial_cmdsn;
-	session->max_cmdsn = initial_cmdsn + session->cmds_max / 2;
 
 	istgt_session =	(struct istgt_session *) cls_session->dd_data;
 
@@ -589,6 +589,7 @@
 	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask->sc;
 	struct scatterlist *sg = sc->request_buffer;
+	struct iscsi_session *session = ctask->conn->session;
 
 	tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
 
@@ -598,7 +599,7 @@
 	list_add(&dtask->item, &tcp_ctask->dataqueue);
 	tcp_ctask->dtask = dtask;
 
-	iscsi_buf_init_virt(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
 			   sizeof(struct iscsi_hdr));
 
 	if (ctask->data_count) {
@@ -615,28 +616,45 @@
 	case ISCSI_OP_SCSI_CMD:
 	{
 		if (ctask->data_count) {
+			char *buf = page_address(tcp_ctask->headbuf.sg.page) +
+				tcp_ctask->headbuf.sg.offset;
 			struct iscsi_data_rsp *hdr =
 				(struct iscsi_data_rsp *) &dtask->hdr;
 
+			memset(hdr, 0, sizeof(*hdr));
 			hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
 			hdr->itt = ctask->hdr->itt;
 			hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
 			hdr->offset = 0;
-			hdr->datasn = cpu_to_be32(ctask->datasn);
+			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
+			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
+			hdr->max_cmdsn =
+				cpu_to_be32(session->exp_cmdsn + session->max_cmdsn / 2);
+			hdr->datasn = cpu_to_be32(ctask->datasn++);
 
 			/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
 			hton24(hdr->dlength, ctask->data_count);
+			hdr->residual_count = 0;
 			hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+
+			dprintk("%p %p %x %x %x %x\n",
+				buf, hdr, buf[0], buf[1], buf[2], buf[3]);
 		} else {
 			struct iscsi_cmd_rsp *hdr =
 				(struct iscsi_cmd_rsp *) &dtask->hdr;
 
+			memset(hdr, 0, sizeof(*hdr));
 			hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+			hdr->itt = ctask->hdr->itt;
 			hdr->flags = ISCSI_FLAG_CMD_FINAL;
 			hdr->response = ISCSI_STATUS_CMD_COMPLETED;
 			hdr->cmd_status = SAM_STAT_GOOD;
-			hdr->itt = ctask->hdr->itt;
+			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
+			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
+			hdr->max_cmdsn =
+				cpu_to_be32(session->exp_cmdsn + session->max_cmdsn / 2);
 		}
+		break;
 	}
 	case ISCSI_OP_LOGOUT:
 	{
@@ -698,6 +716,9 @@
 	}
 
 	if (tcp_ctask->xmstate & XMSTATE_UNS_HDR) {
+		char *buf = page_address(tcp_ctask->headbuf.sg.page) +
+			tcp_ctask->headbuf.sg.offset;
+		dprintk("%x %x %x %x\n", buf[0], buf[1], buf[2], buf[3]);
 		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
 		if (err) {
 			BUG_ON(1);



From tomo at berlios.de  Sat May  6 17:20:39 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 17:20:39 +0200
Subject: [Stgt-svn] r462 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605061520.k46FKdDU026279@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 17:20:39 +0200 (Sat, 06 May 2006)
New Revision: 462

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix recvworker.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 14:59:49 UTC (rev 461)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 15:20:39 UTC (rev 462)
@@ -233,7 +233,7 @@
 
 		dprintk("%p %x %x\n", ctask, ctask->hdr->cmdsn, session->exp_cmdsn);
 
-		if (ctask->hdr->cmdsn != session->exp_cmdsn)
+		if (be32_to_cpu(ctask->hdr->cmdsn) != session->exp_cmdsn)
 			break;
 
 		list_del(&ctask->tgtlist);



From tomo at berlios.de  Sat May  6 17:47:34 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 17:47:34 +0200
Subject: [Stgt-svn] r463 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605061547.k46FlYYK029028@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 17:47:33 +0200 (Sat, 06 May 2006)
New Revision: 463

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix responses without data.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 15:20:39 UTC (rev 462)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 15:47:33 UTC (rev 463)
@@ -536,12 +536,18 @@
 		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 		scsi_queue_work(shost, &conn->xmitwork);
 	} else {
-		done(scmd);
-		spin_lock_bh(&conn->session->lock);
-		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-		scmd->sc_data_direction = DMA_TO_DEVICE;
-		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
-		spin_unlock_bh(&conn->session->lock);
+		if (scmd->request_bufflen) {
+			done(scmd);
+			spin_lock_bh(&conn->session->lock);
+			__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+			scmd->sc_data_direction = DMA_TO_DEVICE;
+			iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
+			spin_unlock_bh(&conn->session->lock);
+		} else {
+			scmd->done = done;
+			__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
+			scsi_queue_work(shost, &ctask->conn->xmitwork);
+		}
 	}
 	return 0;
 }
@@ -629,7 +635,7 @@
 			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
 			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
 			hdr->max_cmdsn =
-				cpu_to_be32(session->exp_cmdsn + session->max_cmdsn / 2);
+				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
 			hdr->datasn = cpu_to_be32(ctask->datasn++);
 
 			/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
@@ -652,7 +658,7 @@
 			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
 			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
 			hdr->max_cmdsn =
-				cpu_to_be32(session->exp_cmdsn + session->max_cmdsn / 2);
+				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
 		}
 		break;
 	}
@@ -738,7 +744,7 @@
 
 	sc->done(sc);
 
-	if (sc->sc_data_direction == DMA_TO_DEVICE) {
+	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->request_bufflen) {
 		spin_lock_bh(&conn->session->lock);
 		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
 		/* fool iscsi_tcp_cleanup_ctask */



From tomo at berlios.de  Sat May  6 19:01:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 19:01:42 +0200
Subject: [Stgt-svn] r464 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605061701.k46H1gYY021235@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 19:01:35 +0200 (Sat, 06 May 2006)
New Revision: 464

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix residual stuff. Seems that I can log in and see devices now.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 15:47:33 UTC (rev 463)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 17:01:35 UTC (rev 464)
@@ -621,11 +621,13 @@
 	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_SCSI_CMD:
 	{
+		/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
 		if (ctask->data_count) {
+			struct iscsi_data_rsp *hdr =
+				(struct iscsi_data_rsp *) &dtask->hdr;
 			char *buf = page_address(tcp_ctask->headbuf.sg.page) +
 				tcp_ctask->headbuf.sg.offset;
-			struct iscsi_data_rsp *hdr =
-				(struct iscsi_data_rsp *) &dtask->hdr;
+			u32 residual, exp_datalen = be32_to_cpu(ctask->hdr->data_length);
 
 			memset(hdr, 0, sizeof(*hdr));
 			hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
@@ -637,11 +639,20 @@
 			hdr->max_cmdsn =
 				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
 			hdr->datasn = cpu_to_be32(ctask->datasn++);
+			hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
-			/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
+			if (ctask->data_count < exp_datalen) {
+				hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				residual = exp_datalen - ctask->data_count;
+			} else if (ctask->data_count > exp_datalen) {
+				hdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				residual =  ctask->data_count - exp_datalen;
+				ctask->data_count = exp_datalen;
+			} else
+				residual = 0;
+
+			hdr->residual_count = cpu_to_be32(residual);
 			hton24(hdr->dlength, ctask->data_count);
-			hdr->residual_count = 0;
-			hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
 			dprintk("%p %p %x %x %x %x\n",
 				buf, hdr, buf[0], buf[1], buf[2], buf[3]);



From tomo at berlios.de  Sat May  6 19:02:27 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 6 May 2006 19:02:27 +0200
Subject: [Stgt-svn] r465 - branches/use-scsi-ml
Message-ID: <200605061702.k46H2Rjj021427@sheep.berlios.de>

Author: tomo
Date: 2006-05-06 19:02:24 +0200 (Sat, 06 May 2006)
New Revision: 465

Modified:
   branches/use-scsi-ml/iscsi
Log:
Update the makeshift iscsi script.


Modified: branches/use-scsi-ml/iscsi
===================================================================
--- branches/use-scsi-ml/iscsi	2006-05-06 17:01:35 UTC (rev 464)
+++ branches/use-scsi-ml/iscsi	2006-05-06 17:02:24 UTC (rev 465)
@@ -6,6 +6,4 @@
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
 ${PWD}/usr/tgtadm --driver istgt --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-
-#${PWD}/usr/tgtadm --driver istgt --op bind --tid 1 --hostno 1
-#${PWD}/usr/tgtadm --driver istgt --op new --tid 0 --lun 0 --params Path=/dev/sdb1
+${PWD}/usr/tgtadm --driver istgt --op new --tid 1 --lun 0 --params Path=/dev/hdc1



From tomo at berlios.de  Sun May  7 02:27:24 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 02:27:24 +0200
Subject: [Stgt-svn] r466 - in branches/use-scsi-ml/istgt: kernel usr
Message-ID: <200605070027.k470ROYM019997@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 02:27:10 +0200 (Sun, 07 May 2006)
New Revision: 466

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
   branches/use-scsi-ml/istgt/usr/conn.c
   branches/use-scsi-ml/istgt/usr/param.h
Log:
Set parameters properly.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-06 17:02:24 UTC (rev 465)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-07 00:27:10 UTC (rev 466)
@@ -2195,7 +2195,7 @@
 	}
 }
 
-static int
+int
 iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		     uint32_t value)
 {

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-06 17:02:24 UTC (rev 465)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-07 00:27:10 UTC (rev 466)
@@ -36,5 +36,9 @@
 
 extern void iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask);
 
+extern int
+iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
+		     uint32_t value);
+
 extern int iscsi_tcp_init(void);
 extern void iscsi_tcp_exit(void);

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-06 17:02:24 UTC (rev 465)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 00:27:10 UTC (rev 466)
@@ -456,6 +456,7 @@
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int err;
+	struct iscsi_session *session = class_to_transport_session(cls_session);
 
 	dprintk("%llu %u\n", (unsigned long long) transport_eph, is_leading);
 
@@ -473,6 +474,13 @@
 
 	INIT_WORK(&conn->tcpwork, __istgt_tcp_data_ready, cls_conn);
 
+	dprintk("%u %u %u %u %u %u %u %u %u %u %u %u\n",
+		conn->max_recv_dlength, conn->max_xmit_dlength,
+		conn->hdrdgst_en, conn->datadgst_en, session->initial_r2t_en,
+		session->max_r2t, session->imm_data_en,
+		session->first_burst, session->max_burst,
+		session->pdu_inorder_en, session->dataseq_inorder_en, session->erl);
+
 	return 0;
 }
 
@@ -803,6 +811,7 @@
 	.destroy_conn		= iscsi_tcp_conn_destroy,
 	.bind_conn		= istgt_tcp_conn_bind,
 	.start_conn		= iscsi_conn_start,
+	.set_param		= iscsi_conn_set_param,
 	.terminate_conn		= iscsi_tcp_terminate_conn,
 	.xmit_cmd_task		= istgt_tcp_ctask_xmit,
 };

Modified: branches/use-scsi-ml/istgt/usr/conn.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/conn.c	2006-05-06 17:02:24 UTC (rev 465)
+++ branches/use-scsi-ml/istgt/usr/conn.c	2006-05-07 00:27:10 UTC (rev 466)
@@ -66,7 +66,7 @@
 
 void conn_take_fd(struct connection *conn, int fd)
 {
-	int err;
+	int i, err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
 	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
@@ -82,28 +82,29 @@
 		goto out;
 	}
 
+	for (i = 0; i < ISCSI_PARAM_ERL + 1; i++) {
+		/* FIXME */
+		if (i == ISCSI_PARAM_DATADGST_EN || i == ISCSI_PARAM_HDRDGST_EN)
+			continue;
+		if (ki->set_param(thandle, conn->session->ksid, conn->kcid, i,
+				  &conn->session_param[i].val,
+				  sizeof(uint32_t), &err) || err) {
+			break;
+		}
+	}
+
 	if (ki->bind_conn(thandle, conn->session->ksid, conn->kcid, fd, 1, &err) || err) {
 		eprintf("%d %d %u %u %u %" PRIx64,
 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 		goto out;
 	}
 
-/* 	if (ki->set_param(thandle, sid, conn->cid, ISCSI_PARAM_EXP_STATSN, */
-/* 			  conn->exp_stat_sn, &err, || err) { */
-/* 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid); */
-/* 		goto out; */
-/* 	} */
-
 	if (ki->start_conn(thandle, conn->session->ksid, conn->kcid, &err) || err) {
 		eprintf("%d %d %u %u %u %" PRIx64,
 			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 		goto out;
 	}
 
-/* 	conn->stat_sn */
-/* 		conn->session_param[key_header_digest].val, */
-/* 		conn->session_param[key_data_digest].val); */
-
 out:
 	return;
 }

Modified: branches/use-scsi-ml/istgt/usr/param.h
===================================================================
--- branches/use-scsi-ml/istgt/usr/param.h	2006-05-06 17:02:24 UTC (rev 465)
+++ branches/use-scsi-ml/istgt/usr/param.h	2006-05-07 00:27:10 UTC (rev 466)
@@ -30,7 +30,6 @@
 };
 
 extern struct iscsi_key session_keys[];
-extern struct iscsi_key target_keys[];
 
 extern void param_set_defaults(struct param *, struct iscsi_key *);
 extern int param_index_by_name(char *, struct iscsi_key *);



From tomo at berlios.de  Sun May  7 03:12:40 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 03:12:40 +0200
Subject: [Stgt-svn] r467 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605070112.k471CeCn006009@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 03:12:31 +0200 (Sun, 07 May 2006)
New Revision: 467

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Clean up  istgt_scsi_tgt_queue_command().

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 00:27:10 UTC (rev 466)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 01:12:31 UTC (rev 467)
@@ -116,17 +116,12 @@
 	struct scsi_cmnd *scmd;
 	enum dma_data_direction dir;
 
-	if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
-		dir = DMA_TO_DEVICE;
-	else if (hdr->flags & ISCSI_FLAG_CMD_READ)
-		dir = DMA_FROM_DEVICE;
-	else
-		dir = DMA_NONE;
+	dir = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ?
+		DMA_TO_DEVICE : DMA_FROM_DEVICE;
 
 	scmd = scsi_host_get_command(shost, dir, GFP_KERNEL);
 	BUG_ON(!scmd);
 	ctask->sc = scmd;
-
 	memcpy(scmd->data_cmnd, hdr->cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = be32_to_cpu(hdr->data_length);
 	scmd->SCp.ptr = (void *) ctask;
@@ -136,33 +131,14 @@
 	case ISCSI_ATTR_SIMPLE:
 		scmd->tag = MSG_SIMPLE_TAG;
 		break;
-	case ISCSI_ATTR_ORDERED:
-		scmd->tag = MSG_ORDERED_TAG;
-		break;
 	case ISCSI_ATTR_HEAD_OF_QUEUE:
 		scmd->tag = MSG_HEAD_TAG;
 		break;
-	case ISCSI_ATTR_ACA:
-		scmd->tag = MSG_SIMPLE_TAG;
-		break;
+	case ISCSI_ATTR_ORDERED:
 	default:
-		scmd->tag = MSG_SIMPLE_TAG;
+		scmd->tag = MSG_ORDERED_TAG;
 	}
 
-	if (scmd->sc_data_direction == DMA_TO_DEVICE &&
-	    be32_to_cpu(hdr->data_length)) {
-		switch (hdr->cdb[0]) {
-		case WRITE_6:
-		case WRITE_10:
-		case WRITE_16:
-		case WRITE_VERIFY:
-			break;
-		default:
-			eprintk("%x\n", hdr->cdb[0]);
-			break;
-		}
-	}
-
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
 }
 



From tomo at berlios.de  Sun May  7 03:16:49 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 03:16:49 +0200
Subject: [Stgt-svn] r468 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605070116.k471Gn9i007096@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 03:16:41 +0200 (Sun, 07 May 2006)
New Revision: 468

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Clean up  istgt_scsi_tgt_queue_command() again.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 01:12:31 UTC (rev 467)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 01:16:41 UTC (rev 468)
@@ -114,9 +114,7 @@
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_cmd *hdr = ctask->hdr;
 	struct scsi_cmnd *scmd;
-	enum dma_data_direction dir;
-
-	dir = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ?
+	enum dma_data_direction dir = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ?
 		DMA_TO_DEVICE : DMA_FROM_DEVICE;
 
 	scmd = scsi_host_get_command(shost, dir, GFP_KERNEL);



From tomo at berlios.de  Sun May  7 13:28:56 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 13:28:56 +0200
Subject: [Stgt-svn] r469 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605071128.k47BSuLh023283@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 13:28:53 +0200 (Sun, 07 May 2006)
New Revision: 469

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
DMA_FROM_DEVICE commands should work.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-07 01:16:41 UTC (rev 468)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-07 11:28:53 UTC (rev 469)
@@ -175,6 +175,7 @@
 	struct iscsi_buf	immbuf;			/* for imm data digest */
 	struct iscsi_data_task   *dtask;		/* data task in progress*/
 	int			digest_offset;		/* for partial buff digest */
+	struct iscsi_cmd	rhdr;
 };
 
 struct data_ready_desc {

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 01:16:41 UTC (rev 468)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 11:28:53 UTC (rev 469)
@@ -300,12 +300,10 @@
 		ctask->data_count = 0;
 		ctask->sc = NULL;
 		ctask->datasn = 0;
-		BUG_ON(!ctask->hdr);
+		ctask->total_length = 0;
 		memcpy(ctask->hdr, hdr, sizeof(*hdr));
 
 		tcp_ctask = ctask->dd_data;
-		BUG_ON(!tcp_ctask);
-
 		tcp_ctask->sg = NULL;
 		tcp_ctask->sent = 0;
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
@@ -518,7 +516,7 @@
 		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 		scsi_queue_work(shost, &conn->xmitwork);
 	} else {
-		if (scmd->request_bufflen) {
+		if (scmd->bufflen) {
 			done(scmd);
 			spin_lock_bh(&conn->session->lock);
 			__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
@@ -545,10 +543,6 @@
 	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
 		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
 
-	tcp_ctask->sg = scmd->request_buffer;
-	tcp_ctask->sg_count = 0;
-	ctask->data_count = scmd->request_bufflen;
-
 	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
 		struct sock *sk = tcp_conn->sock->sk;
@@ -563,6 +557,13 @@
 
 		bh_unlock_sock(sk);
 	} else {
+		tcp_ctask->sg_count = 0;
+		tcp_ctask->data_offset = 0;
+		tcp_ctask->sg = scmd->request_buffer;
+
+		ctask->total_length = min(be32_to_cpu(ctask->hdr->data_length),
+					  scmd->request_bufflen);
+
 		scmd->done = done;
 		__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
 		scsi_queue_work(shost, &ctask->conn->xmitwork);
@@ -571,78 +572,75 @@
 	return 0;
 }
 
-static void istgt_response_build(struct iscsi_cmd_task *ctask)
+static void data_cmd_rsp_build(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask->sc;
-	struct scatterlist *sg = sc->request_buffer;
 	struct iscsi_session *session = ctask->conn->session;
+	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *) &tcp_ctask->rhdr;
+	u32 left, residual, exp_datalen, size;
 
-	tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
+	if (!tcp_ctask->data_offset)
+		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
+				  &tcp_ctask->sg[tcp_ctask->sg_count++]);
 
-	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	memset(&dtask->hdr, 0, sizeof(struct iscsi_data));
-	list_add(&dtask->item, &tcp_ctask->dataqueue);
-	tcp_ctask->dtask = dtask;
+	exp_datalen = be32_to_cpu(ctask->hdr->data_length);
+	left = ctask->total_length;
 
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
-			   sizeof(struct iscsi_hdr));
+	dprintk("%p %u %u %u %u %u %u\n", ctask, exp_datalen, left,
+		ctask->total_length,
+		tcp_ctask->sg_count, ctask->conn->max_xmit_dlength, sc->bufflen);
 
-	if (ctask->data_count) {
-		struct iscsi_buf *ibuf = &tcp_ctask->sendbuf;
-		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
-				  &sg[tcp_ctask->sg_count++]);
-		tcp_ctask->sg = sg;
-		dprintk("%p %u %u %u\n", ibuf->sg.page, ibuf->sg.offset,
-			ibuf->sg.length, ibuf->use_sendmsg);
-		tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
-	}
+	rhdr->opcode = ISCSI_OP_SCSI_DATA_IN;
+	rhdr->itt = ctask->hdr->itt;
+	rhdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	rhdr->offset = cpu_to_be32(sc->offset + tcp_ctask->data_offset);
+	rhdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
+	rhdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
+	rhdr->max_cmdsn =
+		cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
+	rhdr->datasn = cpu_to_be32(ctask->datasn++);
 
-	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
-	case ISCSI_OP_SCSI_CMD:
-	{
-		/* FIXME: multiple data rsp (conn->max_xmit_dlength) */
-		if (ctask->data_count) {
-			struct iscsi_data_rsp *hdr =
-				(struct iscsi_data_rsp *) &dtask->hdr;
-			char *buf = page_address(tcp_ctask->headbuf.sg.page) +
-				tcp_ctask->headbuf.sg.offset;
-			u32 residual, exp_datalen = be32_to_cpu(ctask->hdr->data_length);
+	if (ctask->total_length <= ctask->conn->max_xmit_dlength) {
+		size = ctask->total_length;
+		if (ctask->total_length + tcp_ctask->sent ==
+		    min(exp_datalen, sc->bufflen)) {
+			rhdr->flags =
+				ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
-			memset(hdr, 0, sizeof(*hdr));
-			hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
-			hdr->itt = ctask->hdr->itt;
-			hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-			hdr->offset = 0;
-			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
-			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
-			hdr->max_cmdsn =
-				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
-			hdr->datasn = cpu_to_be32(ctask->datasn++);
-			hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-
-			if (ctask->data_count < exp_datalen) {
-				hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-				residual = exp_datalen - ctask->data_count;
-			} else if (ctask->data_count > exp_datalen) {
-				hdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-				residual =  ctask->data_count - exp_datalen;
-				ctask->data_count = exp_datalen;
+			if (sc->bufflen < exp_datalen) {
+				rhdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				residual = exp_datalen - sc->bufflen;
+			} else if (sc->bufflen > exp_datalen) {
+				rhdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				residual = sc->bufflen - exp_datalen;
 			} else
 				residual = 0;
+			rhdr->residual_count = cpu_to_be32(residual);
+		}
+	} else
+		size = ctask->conn->max_xmit_dlength;
 
-			hdr->residual_count = cpu_to_be32(residual);
-			hton24(hdr->dlength, ctask->data_count);
+	hton24(rhdr->dlength, size);
+	ctask->data_count = size;
+	tcp_ctask->data_offset += size;
+	ctask->total_length -= size;
+}
 
-			dprintk("%p %p %x %x %x %x\n",
-				buf, hdr, buf[0], buf[1], buf[2], buf[3]);
-		} else {
+static void rsp_build(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_session *session = ctask->conn->session;
+
+	ctask->data_count = 0;
+
+	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_SCSI_CMD:
+		if (ctask->total_length)
+			data_cmd_rsp_build(ctask);
+		else {
 			struct iscsi_cmd_rsp *hdr =
-				(struct iscsi_cmd_rsp *) &dtask->hdr;
-
-			memset(hdr, 0, sizeof(*hdr));
+				(struct iscsi_cmd_rsp *) &tcp_ctask->rhdr;
 			hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
 			hdr->itt = ctask->hdr->itt;
 			hdr->flags = ISCSI_FLAG_CMD_FINAL;
@@ -654,12 +652,10 @@
 				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
 		}
 		break;
-	}
 	case ISCSI_OP_LOGOUT:
 	{
 		struct iscsi_logout_rsp *hdr =
-			(struct iscsi_logout_rsp *) &dtask->hdr;
-
+			(struct iscsi_logout_rsp *) &tcp_ctask->rhdr;
 		hdr->opcode = ISCSI_OP_LOGOUT_RSP;
 		hdr->flags = ISCSI_FLAG_CMD_FINAL;
 		hdr->itt = tcp_ctask->hdr.itt;
@@ -668,6 +664,9 @@
 	default:
 		break;
 	}
+
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
+			   sizeof(struct iscsi_hdr));
 }
 
 static int
@@ -678,14 +677,15 @@
 
 	while (1) {
 		struct iscsi_buf *ibuf = &tcp_ctask->sendbuf;
-		dprintk("%p %u %u %u\n", ibuf->sg.page, ibuf->sg.offset,
-			ibuf->sg.length, ibuf->use_sendmsg);
+		dprintk("%p %p %u %u %u %u\n", ctask, ibuf->sg.page,
+			ibuf->sg.offset,
+			ibuf->sg.length, ctask->data_count, tcp_ctask->sg_count);
 
 		err = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
 				     &ctask->data_count, &tcp_ctask->sent);
 		if (err) {
 			dprintk("%u %u\n", ctask->data_count, tcp_ctask->sent);
-			BUG_ON(1);
+			BUG_ON(err != -EAGAIN);
 			return -EAGAIN;
 		}
 
@@ -707,24 +707,27 @@
 	struct scsi_cmnd *sc = ctask->sc;
 	int err;
 
-	dprintk("%p %x %x %u %x\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], ctask->data_count, tcp_ctask->xmstate);
-
+	dprintk("%p %x %x %u %u %x\n", ctask,
+		ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], sc->bufflen, sc->request_bufflen,
+		tcp_ctask->xmstate);
+again:
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
-		istgt_response_build(ctask);
+		rsp_build(ctask);
+		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
+		tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
 	}
 
 	if (tcp_ctask->xmstate & XMSTATE_UNS_HDR) {
-		char *buf = page_address(tcp_ctask->headbuf.sg.page) +
-			tcp_ctask->headbuf.sg.offset;
-		dprintk("%x %x %x %x\n", buf[0], buf[1], buf[2], buf[3]);
 		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
-		if (err) {
-			BUG_ON(1);
-			eprintk("%d\n", err);
+		if (err)
 			return -EAGAIN;
-		} else
+		else {
 			tcp_ctask->xmstate &= ~XMSTATE_UNS_HDR;
+
+			if (ctask->data_count)
+				tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
+		}
 	}
 
 	if (tcp_ctask->xmstate & XMSTATE_UNS_DATA) {
@@ -733,11 +736,16 @@
 			return -EAGAIN;
 		else
 			tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
+
+		if (ctask->total_length) {
+			tcp_ctask->xmstate |= XMSTATE_UNS_INIT;
+			goto again;
+		}
 	}
 
 	sc->done(sc);
 
-	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->request_bufflen) {
+	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->bufflen) {
 		spin_lock_bh(&conn->session->lock);
 		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
 		/* fool iscsi_tcp_cleanup_ctask */



From tomo at berlios.de  Sun May  7 13:36:06 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 13:36:06 +0200
Subject: [Stgt-svn] r470 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605071136.k47Ba6pn025774@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 13:36:05 +0200 (Sun, 07 May 2006)
New Revision: 470

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
We don't use r2t queue so kill a hack for iscsi_tcp_cleanup_ctask().


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 11:28:53 UTC (rev 469)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 11:36:05 UTC (rev 470)
@@ -748,9 +748,6 @@
 	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->bufflen) {
 		spin_lock_bh(&conn->session->lock);
 		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-		/* fool iscsi_tcp_cleanup_ctask */
-		if (sc)
-			sc->sc_data_direction = DMA_TO_DEVICE;
 		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
 		spin_unlock_bh(&conn->session->lock);
 	}



From tomo at berlios.de  Sun May  7 14:28:30 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 14:28:30 +0200
Subject: [Stgt-svn] r471 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605071228.k47CSU1C017034@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 14:28:06 +0200 (Sun, 07 May 2006)
New Revision: 471

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Use session->lock instead of own lock.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 11:36:05 UTC (rev 470)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-07 12:28:06 UTC (rev 471)
@@ -46,7 +46,6 @@
 	struct list_head recvlist;
 	/* replace with array later on */
 	struct list_head cmd_hash;
-	spinlock_t slock;
 	struct work_struct recvwork;
 };
 
@@ -199,7 +198,7 @@
 
 	dprintk("%x\n", session->exp_cmdsn);
 retry:
-	spin_lock_bh(&istgt_session->slock);
+	spin_lock_bh(&session->lock);
 
 	while (!list_empty(&istgt_session->recvlist)) {
 		ctask = list_entry(istgt_session->recvlist.next,
@@ -213,12 +212,12 @@
 		list_del(&ctask->tgtlist);
 		session->exp_cmdsn++;
 
-		spin_unlock_bh(&istgt_session->slock);
+		spin_unlock_bh(&session->lock);
 		istgt_cmd_exec(ctask);
 		goto retry;
 	}
 
-	spin_unlock_bh(&istgt_session->slock);
+	spin_unlock_bh(&session->lock);
 }
 
 static void istgt_ctask_add(struct iscsi_cmd_task *ctask)
@@ -231,7 +230,7 @@
 	dprintk("%p %x %x %x\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
 		ctask->hdr->cdb[0], ctask->hdr->cmdsn);
 
-	spin_lock_bh(&istgt_session->slock);
+	spin_lock_bh(&session->lock);
 
 	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
 		list_add(&ctask->tgtlist, &istgt_session->recvlist);
@@ -244,7 +243,7 @@
 
 	list_add_tail(&ctask->tgtlist, &pos->tgtlist);
 out:
-	spin_unlock_bh(&istgt_session->slock);
+	spin_unlock_bh(&session->lock);
 }
 
 #if 0
@@ -287,13 +286,11 @@
 	}
 
 	switch (opcode) {
-	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
-		spin_lock(&session->lock);
+		spin_lock_bh(&session->lock);
 		__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-		spin_unlock(&session->lock);
+		spin_unlock_bh(&session->lock);
 		BUG_ON(!ctask);
 
 		ctask->conn = conn;
@@ -325,7 +322,9 @@
 /* 			} */
 
 		break;
+	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_DATA_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
 		BUG_ON(1);
 		/* Find a command in the hash list */
 		/* data_out_start(conn, cmnd); */
@@ -490,7 +489,6 @@
 
 	INIT_LIST_HEAD(&istgt_session->recvlist);
 	INIT_LIST_HEAD(&istgt_session->cmd_hash);
-	spin_lock_init(&istgt_session->slock);
 
 	INIT_WORK(&istgt_session->recvwork, istgt_recvworker, cls_session);
 
@@ -533,7 +531,7 @@
 }
 
 static int istgt_transfer_data(struct scsi_cmnd *scmd,
-				  void (*done)(struct scsi_cmnd *))
+			       void (*done)(struct scsi_cmnd *))
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;



From tomo at berlios.de  Sun May  7 16:41:13 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 7 May 2006 16:41:13 +0200
Subject: [Stgt-svn] r472 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605071441.k47EfDRi028519@sheep.berlios.de>

Author: tomo
Date: 2006-05-07 16:41:12 +0200 (Sun, 07 May 2006)
New Revision: 472

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
Log:
Add suspend_rx check before IN_PROGESS_DATA_RECV because we need to wait for WRITE command buffer.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-07 12:28:06 UTC (rev 471)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-07 14:41:12 UTC (rev 472)
@@ -937,6 +937,11 @@
 		}
 	}
 
+	if (unlikely(conn->suspend_rx)) {
+		debug_tcp("conn %d Rx suspended!\n", conn->id);
+		return 0;
+	}
+
 	if (tcp_conn->in_progress == IN_PROGRESS_DATA_RECV &&
 	   tcp_conn->in.copy) {
 



From tomo at berlios.de  Mon May  8 16:06:23 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 8 May 2006 16:06:23 +0200
Subject: [Stgt-svn] r473 - branches/use-scsi-ml/usr
Message-ID: <200605081406.k48E6Nku015090@sheep.berlios.de>

Author: tomo
Date: 2006-05-08 16:06:23 +0200 (Mon, 08 May 2006)
New Revision: 473

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Fix uninitialized data.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-05-07 14:41:12 UTC (rev 472)
+++ branches/use-scsi-ml/usr/scsi.c	2006-05-08 14:06:23 UTC (rev 473)
@@ -493,8 +493,10 @@
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*offset = 0;
-	if (!mmap_cmd_init(scb, rw))
+	if (!mmap_cmd_init(scb, rw)) {
 		data = valloc(PAGE_SIZE);
+		memset(data, 0, PAGE_SIZE);
+	}
 
 	if (!dev)
 		switch (scb[0]) {
@@ -504,8 +506,10 @@
 			break;
 		default:
 			*offset = 0;
-			if (!data)
+			if (!data) {
 				data = valloc(PAGE_SIZE);
+				memset(data, 0, PAGE_SIZE);
+			}
 			*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
 						0x25, 0);
 			result = SAM_STAT_CHECK_CONDITION;



From tomo at berlios.de  Mon May  8 16:45:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 8 May 2006 16:45:33 +0200
Subject: [Stgt-svn] r474 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605081445.k48EjXJc018500@sheep.berlios.de>

Author: tomo
Date: 2006-05-08 16:45:32 +0200 (Mon, 08 May 2006)
New Revision: 474

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Initial DMA_TO_DEVICE support, though it does not work yet.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-08 14:06:23 UTC (rev 473)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-08 14:45:32 UTC (rev 474)
@@ -711,7 +711,7 @@
 	crypto_digest_update(tcp_conn->data_rx_tfm, &tmp, 1);
 }
 
-int iscsi_scsi_data_in(struct iscsi_conn *conn)
+int __iscsi_scsi_data_in(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
@@ -790,19 +790,27 @@
 			return -EAGAIN;
 	}
 	BUG_ON(ctask->data_count);
+done:
+	return rc;
+}
 
-done:
-	/* check for non-exceptional status */
-	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
+static int iscsi_scsi_data_in(struct iscsi_conn *conn)
+{
+	int rc;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+
+	rc = __iscsi_scsi_data_in(conn);
+	if (!rc && tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
 		debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-			   (long)sc, sc->result, ctask->itt);
+			   (long) ctask->sc, ctask->sc->result, ctask->itt);
 		spin_lock(&conn->session->lock);
 		__iscsi_ctask_cleanup(conn, ctask);
 		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);
 		spin_unlock(&conn->session->lock);
 	}
 
-	return rc;
+	return 0;
 }
 
 static int

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-08 14:06:23 UTC (rev 473)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-08 14:45:32 UTC (rev 474)
@@ -40,5 +40,7 @@
 iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		     uint32_t value);
 
+extern int __iscsi_scsi_data_in(struct iscsi_conn *conn);
+
 extern int iscsi_tcp_init(void);
 extern void iscsi_tcp_exit(void);

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-08 14:06:23 UTC (rev 473)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-08 14:45:32 UTC (rev 474)
@@ -44,6 +44,7 @@
 
 struct istgt_session {
 	struct list_head recvlist;
+	struct list_head wtasklist;
 	/* replace with array later on */
 	struct list_head cmd_hash;
 	struct work_struct recvwork;
@@ -106,6 +107,32 @@
 }
 #endif
 
+static void hashlist_add(struct iscsi_cls_session *cls_session,
+			 struct iscsi_cmd_task *ctask)
+{
+	struct istgt_session *istgt_session = cls_session->dd_data;
+
+	spin_lock_bh(&ctask->conn->session->lock);
+	list_add(&ctask->hash, &istgt_session->cmd_hash);
+	spin_unlock_bh(&ctask->conn->session->lock);
+}
+
+static struct iscsi_cmd_task *hashlist_find(struct iscsi_cls_session *cls_session, u32 itt)
+{
+	struct iscsi_cmd_task *ctask = NULL;
+	struct istgt_session *istgt_session = cls_session->dd_data;
+
+	spin_lock_bh(&ctask->conn->session->lock);
+	list_for_each_entry(ctask, &istgt_session->cmd_hash, hash) {
+		if (ctask->hdr->itt == itt)
+			goto found;
+	}
+	ctask = NULL;
+found:
+	spin_unlock_bh(&ctask->conn->session->lock);
+	return ctask;
+}
+
 static void istgt_scsi_tgt_queue_command(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_session *session = ctask->conn->session;
@@ -137,6 +164,7 @@
 	}
 
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
+	dprintk("%p %x\n", scmd, scmd->data_cmnd[0]);
 }
 
 static void istgt_scsi_cmd_exec(struct iscsi_cmd_task *ctask)
@@ -200,6 +228,16 @@
 retry:
 	spin_lock_bh(&session->lock);
 
+	while (!list_empty(&istgt_session->wtasklist)) {
+		ctask = list_entry(istgt_session->wtasklist.next,
+				   struct iscsi_cmd_task, tgtlist);
+		list_del(&ctask->tgtlist);
+		spin_unlock_bh(&session->lock);
+		dprintk("found wtask %p\n", ctask);
+		istgt_scsi_tgt_queue_command(ctask);
+		goto retry;
+	}
+
 	while (!list_empty(&istgt_session->recvlist)) {
 		ctask = list_entry(istgt_session->recvlist.next,
 				   struct iscsi_cmd_task, tgtlist);
@@ -246,17 +284,6 @@
 	spin_unlock_bh(&session->lock);
 }
 
-#if 0
-static void istgt_unsolicited_data(struct iscsi_cmd_task *ctask)
-{
-/* 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data; */
-
-	istgt_scsi_tgt_queue_command(ctask);
-/* 	tcp_ctask->r2t_data_count; */
-/* 	ctask->r2t_data_count; */
-}
-#endif
-
 static int istgt_tcp_hdr_recv(struct iscsi_conn *conn)
 {
 	int rc, opcode;
@@ -278,13 +305,6 @@
 		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
 		hdr->hlength << 2, tcp_conn->in.datalen);
 
-	/* FIXME */
-	if (tcp_conn->in.datalen) {
-		iscsi_conn_failure(conn, rc);
-		eprintk("Cannot handle this now\n");
-		return 1;
-	}
-
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_LOGOUT:
@@ -304,26 +324,52 @@
 		tcp_ctask->sg = NULL;
 		tcp_ctask->sent = 0;
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
+		tcp_ctask->data_offset = 0;
+		if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+			tcp_ctask->r2t_data_count = be32_to_cpu(ctask->hdr->data_length)
+				- tcp_conn->in.datalen;
+			if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
+				ctask->unsol_count = 0;
+			else
+				ctask->unsol_count = 1;
+			ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
+			ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
 
-		if (!tcp_conn->in.datalen) {
+			dprintk("%p %x %u %u %u %u\n", ctask, hdr->flags,
+				tcp_ctask->r2t_data_count,
+				ctask->unsol_count,
+				ctask->total_length,
+				ctask->imm_count);
+			BUG_ON(ctask->total_length != ctask->imm_count);
+
+			hashlist_add(cls_session, ctask);
+			spin_lock_bh(&session->lock);
+			list_add(&ctask->tgtlist, &istgt_session->wtasklist);
+			spin_unlock_bh(&session->lock);
+			schedule_work(&istgt_session->recvwork);
+
+			/* we stop reading here. */
+			set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
+			if (!tcp_conn->in.datalen)
+				ctask = NULL;
+		} else {
 			istgt_ctask_add(ctask);
 			ctask = NULL;
 			schedule_work(&istgt_session->recvwork);
 		}
-
-/* 		if (opcode == ISCSI_OP_SCSI_CMD) */
-/* 			switch (ctask->hdr->cdb[0]) { */
-/* 			case WRITE_6: */
-/* 			case WRITE_10: */
-/* 			case WRITE_16: */
-/* 			case WRITE_VERIFY: */
-/* 				istgt_unsolicited_data(ctask); */
-/* 				set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx); */
-/* 			} */
-
 		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		BUG_ON(1);
+		ctask = hashlist_find(cls_session, hdr->itt);
+		if (!ctask) {
+			eprintk("Cannot find %x\n", ctask->hdr->itt);
+			rc = ISCSI_ERR_NO_SCSI_CMD;
+		} else {
+/* 			if (tcp_ctask->data_offset != be32_to_cpu(hdr->offset)) */
+/* 				eprintk("Cannot find %x\n", ctask->hdr->itt); */
+		}
+		break;
 	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_SCSI_DATA_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
 		BUG_ON(1);
 		/* Find a command in the hash list */
@@ -345,6 +391,10 @@
 istgt_data_recv(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+	struct iscsi_session *session = ctask->conn->session;
+	struct iscsi_cls_session *cls_session = session_to_cls(session);
+	struct istgt_session *istgt_session = cls_session->dd_data;
 	int rc = 0, opcode;
 
 	/* We need to return -EAGAIN if the buffer is not ready. */
@@ -354,32 +404,22 @@
 	dprintk("opcode 0x%x offset %d copy %d datalen %d\n",
 		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
 		tcp_conn->in.datalen);
-	return 1;
 
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
+		/* read immediate data */
+		rc = __iscsi_scsi_data_in(conn);
+		if (!rc) {
+			BUG_ON(ctask->data_count);
+			istgt_ctask_add(ctask);
+			schedule_work(&istgt_session->recvwork);
+		}
+		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
-		iscsi_scsi_data_in(conn);
-		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_LOGOUT:
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_ASYNC_EVENT:
-		/*
-		 * Collect data segment to the connection's data
-		 * placeholder
-		 */
-/* 		if (iscsi_tcp_copy(tcp_conn)) { */
-/* 			rc = -EAGAIN; */
-/* 			goto exit; */
-/* 		} */
-
-/* 		rc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, tcp_conn->data, */
-/* 					tcp_conn->in.datalen); */
-/* 		if (!rc && conn->datadgst_en && opcode != ISCSI_OP_LOGIN_RSP) */
-/* 			iscsi_recv_digest_update(tcp_conn, tcp_conn->data, */
-/* 			  			tcp_conn->in.datalen); */
-		break;
 	default:
 		BUG_ON(1);
 	}
@@ -467,9 +507,7 @@
 	int i, err;
 
 	dprintk("%u %u\n", initial_cmdsn, *hostno);
-
-	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn,
-					       hostno);
+	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn, hostno);
 	if (!cls_session)
 		return NULL;
 	shost = iscsi_session_to_shost(cls_session);
@@ -486,10 +524,9 @@
 	session->exp_cmdsn = initial_cmdsn;
 
 	istgt_session =	(struct istgt_session *) cls_session->dd_data;
-
 	INIT_LIST_HEAD(&istgt_session->recvlist);
+	INIT_LIST_HEAD(&istgt_session->wtasklist);
 	INIT_LIST_HEAD(&istgt_session->cmd_hash);
-
 	INIT_WORK(&istgt_session->recvwork, istgt_recvworker, cls_session);
 
 	return cls_session;
@@ -510,6 +547,7 @@
 		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
 
 	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
+		ctask->total_length = 0;
 		scmd->done = done;
 		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
 		scsi_queue_work(shost, &conn->xmitwork);
@@ -741,15 +779,17 @@
 		}
 	}
 
-	sc->done(sc);
-
 	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->bufflen) {
 		spin_lock_bh(&conn->session->lock);
+		if (sc->sc_data_direction == DMA_TO_DEVICE)
+			list_del(&ctask->hash);
 		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
 		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
 		spin_unlock_bh(&conn->session->lock);
 	}
 
+	sc->done(sc);
+
 	return 0;
 }
 



From tomo at berlios.de  Tue May  9 03:19:00 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 9 May 2006 03:19:00 +0200
Subject: [Stgt-svn] r475 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605090119.k491J0uk001004@sheep.berlios.de>

Author: tomo
Date: 2006-05-09 03:18:56 +0200 (Tue, 09 May 2006)
New Revision: 475

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Immediate write data works.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-08 14:45:32 UTC (rev 474)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-09 01:18:56 UTC (rev 475)
@@ -947,7 +947,7 @@
 
 	if (unlikely(conn->suspend_rx)) {
 		debug_tcp("conn %d Rx suspended!\n", conn->id);
-		return 0;
+		goto nomore;
 	}
 
 	if (tcp_conn->in_progress == IN_PROGRESS_DATA_RECV &&
@@ -958,11 +958,8 @@
 
 		rc = d->data_recv(conn);
 		if (rc) {
-			if (rc == -EAGAIN) {
-				rd_desc->count = tcp_conn->in.datalen -
-						tcp_conn->in.ctask->data_count;
+			if (rc == -EAGAIN)
 				goto again;
-			}
 			iscsi_conn_failure(conn, rc);
 			return 0;
 		}

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-08 14:45:32 UTC (rev 474)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-09 01:18:56 UTC (rev 475)
@@ -143,7 +143,7 @@
 	enum dma_data_direction dir = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ?
 		DMA_TO_DEVICE : DMA_FROM_DEVICE;
 
-	scmd = scsi_host_get_command(shost, dir, GFP_KERNEL);
+	scmd = scsi_host_get_command(shost, dir, GFP_ATOMIC);
 	BUG_ON(!scmd);
 	ctask->sc = scmd;
 	memcpy(scmd->data_cmnd, hdr->cdb, MAX_COMMAND_SIZE);
@@ -164,22 +164,18 @@
 	}
 
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
-	dprintk("%p %x\n", scmd, scmd->data_cmnd[0]);
 }
 
 static void istgt_scsi_cmd_exec(struct iscsi_cmd_task *ctask)
 {
-	struct scsi_cmnd *scmd = ctask->sc;
-
 	if (ctask->data_count) {
 		if (!ctask->unsol_count)
 			;
 /* 			send_r2t(ctask); */
 	} else {
-/* 		set_cmd_waitio(cmnd); */
-		if (scmd) {
-/* 			BUG_ON(!ctask->done); */
-/* 			cmnd->done(scmd); */
+		if (ctask->sc) {
+			BUG_ON(!ctask->sc->done);
+			ctask->sc->done(ctask->sc);
 		} else
 			istgt_scsi_tgt_queue_command(ctask);
 	}
@@ -556,7 +552,6 @@
 			done(scmd);
 			spin_lock_bh(&conn->session->lock);
 			__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-			scmd->sc_data_direction = DMA_TO_DEVICE;
 			iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
 			spin_unlock_bh(&conn->session->lock);
 		} else {
@@ -583,6 +578,7 @@
 		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
 		struct sock *sk = tcp_conn->sock->sk;
 
+		scmd->done = done;
 		/* FIXME: too hacky */
 		bh_lock_sock(sk);
 



From tomo at berlios.de  Thu May 11 03:47:53 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 11 May 2006 03:47:53 +0200
Subject: [Stgt-svn] r476 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605110147.k4B1lrh2017825@sheep.berlios.de>

Author: tomo
Date: 2006-05-11 03:47:45 +0200 (Thu, 11 May 2006)
New Revision: 476

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
DMA_TO_DEVICE commands work (only solicited data).


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-09 01:18:56 UTC (rev 475)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-11 01:47:45 UTC (rev 476)
@@ -50,62 +50,30 @@
 	struct work_struct recvwork;
 };
 
-#if 0
-static void build_r2t(struct iscsi_cmd_task *ctask)
+static void r2t_build(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_r2t_rsp *hdr;
-	struct iscsi_data_task *dtask;
-	struct iscsi_r2t_info *r2t;
-/* 	struct iscsi_session *session = ctask->conn->session; */
+	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-/* 	struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data; */
-	int rc;
+	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *) &tcp_ctask->rhdr;
+	int length;
 
-/* 	length = req->r2t_length; */
-/* 	burst = req->conn->session->param.max_burst_length; */
-/* 	offset = be32_to_cpu(cmd_hdr(req)->data_length) - length; */
-/* more: */
-	rc = __kfifo_get(tcp_ctask->r2tpool.queue, (void*)&r2t, sizeof(void*));
-	BUG_ON(!rc);
+	rhdr->opcode = ISCSI_OP_R2T;
+	rhdr->flags = ISCSI_FLAG_CMD_FINAL;
+	memcpy(rhdr->lun, ctask->hdr->lun, 8);
+	rhdr->itt = ctask->hdr->itt;
+	rhdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
+	rhdr->data_offset = cpu_to_be32(tcp_ctask->data_offset);
+	rhdr->ttt = 0; /* FIXME */
 
-	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
+	length = min(tcp_ctask->r2t_data_count, session->max_burst);
+	rhdr->data_length = cpu_to_be32(length);
 
-	INIT_LIST_HEAD(&dtask->item);
-	r2t->dtask = dtask;
-	hdr = (struct iscsi_r2t_rsp *) &dtask->hdr;
+	tcp_ctask->r2t_data_count -= length;
 
-/* 	rsp->pdu.bhs.ttt = req->target_task_tag; */
-
-	hdr->opcode = ISCSI_OP_R2T;
-	hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	memcpy(hdr->lun, ctask->hdr->lun, 8);
-	hdr->itt = ctask->hdr->itt;
-	hdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
-/* 	hdr->data_offset = cpu_to_be32(offset); */
-/* 	if (length > burst) { */
-/* 		rsp_hdr->data_length = cpu_to_be32(burst); */
-/* 		length -= burst; */
-/* 		offset += burst; */
-/* 	} else { */
-/* 		rsp_hdr->data_length = cpu_to_be32(length); */
-/* 		length = 0; */
-/* 	} */
-
-	dprintk("%x %u %u %u\n", ctask->hdr->itt,
-		be32_to_cpu(hdr->data_length),
-		be32_to_cpu(hdr->data_offset),
-		be32_to_cpu(hdr->r2tsn));
-
-/* 	if (++req->outstanding_r2t >= req->conn->session->param.max_outstanding_r2t) */
-/* 		break; */
-
-	__kfifo_put(tcp_ctask->r2tpool.queue, (void*)&r2t, sizeof(void*));
-
-/* 	if (length) */
-/* 		goto more; */
+	dprintk("%p %u %u %u %u\n",
+		ctask, length, tcp_ctask->r2t_data_count, tcp_ctask->data_offset,
+		session->max_burst);
 }
-#endif
 
 static void hashlist_add(struct iscsi_cls_session *cls_session,
 			 struct iscsi_cmd_task *ctask)
@@ -120,16 +88,17 @@
 static struct iscsi_cmd_task *hashlist_find(struct iscsi_cls_session *cls_session, u32 itt)
 {
 	struct iscsi_cmd_task *ctask = NULL;
+	struct iscsi_session *session = class_to_transport_session(cls_session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
 
-	spin_lock_bh(&ctask->conn->session->lock);
+	spin_lock_bh(&session->lock);
 	list_for_each_entry(ctask, &istgt_session->cmd_hash, hash) {
 		if (ctask->hdr->itt == itt)
 			goto found;
 	}
 	ctask = NULL;
 found:
-	spin_unlock_bh(&ctask->conn->session->lock);
+	spin_unlock_bh(&session->lock);
 	return ctask;
 }
 
@@ -168,10 +137,15 @@
 
 static void istgt_scsi_cmd_exec(struct iscsi_cmd_task *ctask)
 {
-	if (ctask->data_count) {
-		if (!ctask->unsol_count)
-			;
-/* 			send_r2t(ctask); */
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_cls_session *cls_session = session_to_cls(ctask->conn->session);
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+
+	if (tcp_ctask->r2t_data_count) {
+		if (!ctask->unsol_count) {
+			__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
+			scsi_queue_work(shost, &ctask->conn->xmitwork);
+		}
 	} else {
 		if (ctask->sc) {
 			BUG_ON(!ctask->sc->done);
@@ -319,15 +293,18 @@
 		tcp_ctask = ctask->dd_data;
 		tcp_ctask->sg = NULL;
 		tcp_ctask->sent = 0;
-		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 		tcp_ctask->data_offset = 0;
 		if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+			tcp_ctask->xmstate = XMSTATE_W_HDR;
+			tcp_ctask->exp_r2tsn = 0;
 			tcp_ctask->r2t_data_count = be32_to_cpu(ctask->hdr->data_length)
 				- tcp_conn->in.datalen;
 			if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
 				ctask->unsol_count = 0;
 			else
 				ctask->unsol_count = 1;
+			/* FIXME */
+			BUG_ON(ctask->unsol_count);
 			ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
 			ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
 
@@ -336,7 +313,6 @@
 				ctask->unsol_count,
 				ctask->total_length,
 				ctask->imm_count);
-			BUG_ON(ctask->total_length != ctask->imm_count);
 
 			hashlist_add(cls_session, ctask);
 			spin_lock_bh(&session->lock);
@@ -349,21 +325,31 @@
 			if (!tcp_conn->in.datalen)
 				ctask = NULL;
 		} else {
+			tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 			istgt_ctask_add(ctask);
 			ctask = NULL;
 			schedule_work(&istgt_session->recvwork);
 		}
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
-		BUG_ON(1);
 		ctask = hashlist_find(cls_session, hdr->itt);
 		if (!ctask) {
 			eprintk("Cannot find %x\n", ctask->hdr->itt);
 			rc = ISCSI_ERR_NO_SCSI_CMD;
-		} else {
-/* 			if (tcp_ctask->data_offset != be32_to_cpu(hdr->offset)) */
-/* 				eprintk("Cannot find %x\n", ctask->hdr->itt); */
+			break;
 		}
+		ctask->data_count = tcp_conn->in.datalen;
+		tcp_ctask = ctask->dd_data;
+		{
+			struct iscsi_data *dhdr =
+				(struct iscsi_data *) hdr;
+			dprintk("%p %u %u %u %u %u %x\n", ctask,
+				ctask->total_length,
+				be32_to_cpu(dhdr->offset),
+				tcp_ctask->data_offset,
+				tcp_ctask->r2t_data_count, ctask->data_count,
+				tcp_conn->in.hdr->flags);
+		}
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -391,6 +377,7 @@
 	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	int rc = 0, opcode;
 
 	/* We need to return -EAGAIN if the buffer is not ready. */
@@ -406,12 +393,40 @@
 		/* read immediate data */
 		rc = __iscsi_scsi_data_in(conn);
 		if (!rc) {
+			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+
+			dprintk("%p %x %u %u %u %u %u\n", ctask,
+				tcp_conn->in.hdr->flags,
+				tcp_ctask->r2t_data_count,
+				ctask->unsol_count,
+				ctask->total_length,
+				ctask->imm_count, tcp_ctask->data_offset);
+
 			BUG_ON(ctask->data_count);
+			tcp_ctask->data_offset += ctask->imm_count;
 			istgt_ctask_add(ctask);
 			schedule_work(&istgt_session->recvwork);
 		}
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
+		rc = __iscsi_scsi_data_in(conn);
+		if (!rc) {
+			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+
+			BUG_ON(ctask->data_count);
+			tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
+
+			if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+				BUG_ON(tcp_ctask->r2t_data_count);
+				BUG_ON(!ctask->sc->done);
+				ctask->sc->done(ctask->sc);
+			} else if (tcp_ctask->r2t_data_count) {
+				tcp_ctask->xmstate = XMSTATE_W_HDR;
+				__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+				scsi_queue_work(shost, &conn->xmitwork);
+			}
+		}
+		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_LOGOUT:
 	case ISCSI_OP_NOOP_OUT:
@@ -535,6 +550,7 @@
 				   void (*done)(struct scsi_cmnd *))
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_conn *conn = ctask->conn;
 	struct iscsi_cls_session *cls_session = session_to_cls(conn->session);
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
@@ -543,6 +559,7 @@
 		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
 
 	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
+		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
 		ctask->total_length = 0;
 		scmd->done = done;
 		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
@@ -696,9 +713,6 @@
 	default:
 		break;
 	}
-
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
-			   sizeof(struct iscsi_hdr));
 }
 
 static int
@@ -731,7 +745,6 @@
 	return 0;
 }
 
-
 static int
 istgt_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
@@ -746,6 +759,8 @@
 again:
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
 		rsp_build(ctask);
+		iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
+				   sizeof(struct iscsi_hdr));
 		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
 		tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
 	}
@@ -775,7 +790,25 @@
 		}
 	}
 
-	if (sc->sc_data_direction == DMA_TO_DEVICE || !sc->bufflen) {
+	if (tcp_ctask->xmstate & XMSTATE_W_HDR) {
+		r2t_build(ctask);
+		iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
+				   sizeof(struct iscsi_hdr));
+		tcp_ctask->xmstate &= ~XMSTATE_W_HDR;
+		tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
+	}
+
+	if (tcp_ctask->xmstate |= XMSTATE_SOL_HDR) {
+		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
+		if (err)
+			return -EAGAIN;
+		else
+			tcp_ctask->xmstate &= ~XMSTATE_SOL_HDR;
+	}
+
+	if (tcp_ctask->rhdr.opcode == ISCSI_OP_SCSI_CMD_RSP ||
+	    (tcp_ctask->rhdr.opcode == ISCSI_OP_SCSI_DATA_IN &&
+	     tcp_ctask->rhdr.flags & ISCSI_FLAG_CMD_FINAL)) {
 		spin_lock_bh(&conn->session->lock);
 		if (sc->sc_data_direction == DMA_TO_DEVICE)
 			list_del(&ctask->hash);
@@ -784,7 +817,8 @@
 		spin_unlock_bh(&conn->session->lock);
 	}
 
-	sc->done(sc);
+	if (tcp_ctask->rhdr.opcode != ISCSI_OP_R2T)
+		sc->done(sc);
 
 	return 0;
 }



From tomo at berlios.de  Thu May 11 11:37:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 11 May 2006 11:37:33 +0200
Subject: [Stgt-svn] r477 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605110937.k4B9bXc8005619@sheep.berlios.de>

Author: tomo
Date: 2006-05-11 11:37:33 +0200 (Thu, 11 May 2006)
New Revision: 477

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Add unsolicited write support.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-11 01:47:45 UTC (rev 476)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-11 09:37:33 UTC (rev 477)
@@ -304,7 +304,6 @@
 			else
 				ctask->unsol_count = 1;
 			/* FIXME */
-			BUG_ON(ctask->unsol_count);
 			ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
 			ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
 
@@ -354,8 +353,6 @@
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
 		BUG_ON(1);
-		/* Find a command in the hash list */
-		/* data_out_start(conn, cmnd); */
 		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
@@ -416,14 +413,29 @@
 			BUG_ON(ctask->data_count);
 			tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
 
-			if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-				BUG_ON(tcp_ctask->r2t_data_count);
-				BUG_ON(!ctask->sc->done);
-				ctask->sc->done(ctask->sc);
-			} else if (tcp_ctask->r2t_data_count) {
-				tcp_ctask->xmstate = XMSTATE_W_HDR;
-				__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-				scsi_queue_work(shost, &conn->xmitwork);
+			if (tcp_conn->in.hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+				dprintk("%p %x %u %u %u %u %u\n", ctask,
+					tcp_conn->in.hdr->flags,
+					tcp_ctask->r2t_data_count,
+					ctask->unsol_count,
+					ctask->total_length,
+					ctask->imm_count, tcp_ctask->data_offset);
+
+				tcp_ctask->r2t_data_count -= ntoh24(tcp_conn->in.hdr->dlength);
+				if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+					ctask->unsol_count = 0;
+					istgt_scsi_cmd_exec(ctask);
+				}
+			} else {
+				if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+					BUG_ON(tcp_ctask->r2t_data_count);
+					BUG_ON(!ctask->sc->done);
+					ctask->sc->done(ctask->sc);
+				} else if (tcp_ctask->r2t_data_count) {
+					tcp_ctask->xmstate = XMSTATE_W_HDR;
+					__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+					scsi_queue_work(shost, &conn->xmitwork);
+				}
 			}
 		}
 		break;



From tomo at berlios.de  Sat May 20 16:24:10 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 20 May 2006 16:24:10 +0200
Subject: [Stgt-svn] r478 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200605201424.k4KEOAjx028451@sheep.berlios.de>

Author: tomo
Date: 2006-05-20 16:24:08 +0200 (Sat, 20 May 2006)
New Revision: 478

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
   branches/use-scsi-ml/ibmvstgt/kernel/libsrp.c
Log:
Just clean up.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-05-11 09:37:33 UTC (rev 477)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-05-20 14:24:08 UTC (rev 478)
@@ -4,7 +4,7 @@
  *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
  *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
  *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -89,14 +89,14 @@
 	return (union viosrp_iu *) (iue->sbuf->buf);
 }
 
-static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
+static int send_iu(struct iu_entry *iue, u64 length, u8 format)
 {
 	struct srp_target *target = iue->target;
 	struct vio_port *vport = target_to_port(target);
 	long rc, rc1;
 	union {
 		struct viosrp_crq cooked;
-		uint64_t raw[2];
+		u64 raw[2];
 	} crq;
 
 	/* First copy the SRP */
@@ -134,7 +134,7 @@
 		    unsigned char asc)
 {
 	union viosrp_iu *iu = vio_iu(iue);
-	uint64_t tag = iu->srp.rsp.tag;
+	u64 tag = iu->srp.rsp.tag;
 
 	/* If the linked bit is on and status is good */
 	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
@@ -156,7 +156,7 @@
 	iu->srp.rsp.resp_data_len = 0;
 	iu->srp.rsp.status = status;
 	if (status) {
-		uint8_t *sense = iu->srp.rsp.data;
+		u8 *sense = iu->srp.rsp.data;
 
 		if (iue->scmd) {
 			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
@@ -306,7 +306,7 @@
 }
 
 int send_adapter_info(struct iu_entry *iue,
-		      dma_addr_t remote_buffer, uint16_t length)
+		      dma_addr_t remote_buffer, u16 length)
 {
 	struct srp_target *target = iue->target;
 	struct vio_port *vport = target_to_port(target);
@@ -358,7 +358,7 @@
 {
 	union viosrp_iu *iu = vio_iu(iue);
 	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
-	uint64_t tag = iu->srp.rsp.tag;
+	u64 tag = iu->srp.rsp.tag;
 
 	/* TODO handle case that requested size is wrong and
 	 * buffer format is wrong

Modified: branches/use-scsi-ml/ibmvstgt/kernel/libsrp.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/libsrp.c	2006-05-11 09:37:33 UTC (rev 477)
+++ branches/use-scsi-ml/ibmvstgt/kernel/libsrp.c	2006-05-20 14:24:08 UTC (rev 478)
@@ -375,19 +375,19 @@
 	return len;
 }
 
-static uint8_t getcontrolbyte(u8 *cdb)
+static u8 getcontrolbyte(u8 *cdb)
 {
 	return cdb[COMMAND_SIZE(cdb[0]) - 1];
 }
 
-static inline uint8_t getlink(struct srp_cmd *cmd)
+static inline u8 getlink(struct srp_cmd *cmd)
 {
 	return (getcontrolbyte(cmd->cdb) & 0x01);
 }
 
 int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
 {
-	struct Scsi_host *shost = iue->target->shost;
+	struct Scsi_Host *shost = iue->target->shost;
 	enum dma_data_direction data_dir;
 	struct scsi_cmnd *scmd;
 	int tag, len;



From tomo at berlios.de  Mon May 22 18:03:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 22 May 2006 18:03:48 +0200
Subject: [Stgt-svn] r479 - in branches/use-scsi-ml: . istgt/kernel istgt/usr
Message-ID: <200605221603.k4MG3muA018243@sheep.berlios.de>

Author: tomo
Date: 2006-05-22 18:03:36 +0200 (Mon, 22 May 2006)
New Revision: 479

Modified:
   branches/use-scsi-ml/initd
   branches/use-scsi-ml/istgt/kernel/Makefile
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
   branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c
   branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
   branches/use-scsi-ml/istgt/usr/netlink.c
Log:
Try to integrate iscsi_tcp_tgt.c with iscsi_tcp.c. Probably, we might need to split iscsi_tcp.c to iscsi_tcp.c and something like libiscsi_tcp.c. Only immediate write commands were tested.


Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/initd	2006-05-22 16:03:36 UTC (rev 479)
@@ -7,7 +7,7 @@
 MEM_SIZE=1048576
 export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${PWD}/ibmvstgt/usr:${LD_LIBRARY_PATH}
 
-if [ -f ${PWD}/istgt/kernel/istgt_tcp.ko ] ; then
+if [ -f ${PWD}/istgt/kernel/iscsi_tcp_tgt.ko ] ; then
 	TARGET=istgt
 fi
 
@@ -19,7 +19,8 @@
 		modprobe -q crc32c
 		insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
 		insmod ${PWD}/istgt/kernel/libiscsi.ko
-		insmod ${PWD}/istgt/kernel/istgt_tcp.ko
+		insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
+		insmod ${PWD}/istgt/kernel/iscsi_tcp_tgt.ko
 		${PWD}/istgt/usr/istgtd
 	else
 		insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
@@ -45,7 +46,8 @@
 	sleep 1
 
 	if [ "$TARGET" = "istgt" ] ; then
-		rmmod istgt_tcp
+		rmmod iscsi_tcp_tgt
+		rmmod iscsi_tcp
 		rmmod libiscsi
 		rmmod scsi_transport_iscsi
 	else

Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-05-22 16:03:36 UTC (rev 479)
@@ -10,10 +10,10 @@
 EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include
 
 ifneq ($(KERNELRELEASE),)
-obj-m			+= istgt_tcp.o
-istgt_tcp-objs		:= iscsi_tcp_tgt.o iscsi_tcp.o
-obj-m			+= scsi_transport_iscsi.o
-obj-m			+= libiscsi.o
+obj-m				+= scsi_transport_iscsi.o
+obj-m				+= libiscsi.o
+obj-m				+= iscsi_tcp.o
+obj-m				+= iscsi_tcp_tgt.o
 else
 
 ifeq ($(KERNELSRC),)

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:03:36 UTC (rev 479)
@@ -52,10 +52,7 @@
 #define DEBUG_ASSERT
 
 #ifdef DEBUG_TCP
-#define debug_tcp(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
+#define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt)
 #else
 #define debug_tcp(fmt...)
 #endif
@@ -70,17 +67,6 @@
 static unsigned int iscsi_max_lun = 512;
 module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 
-/* global data */
-static kmem_cache_t *taskcache;
-
-static inline void
-iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
-{
-	sg_init_one(&ibuf->sg, (u8 *)vbuf, size);
-	ibuf->sent = 0;
-	ibuf->use_sendmsg = 0;
-}
-
 inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -90,8 +76,9 @@
 	ibuf->sent = 0;
 	ibuf->use_sendmsg = 1;
 }
+EXPORT_SYMBOL_GPL(iscsi_buf_init_iov);
 
-inline void
+static inline void
 iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
 {
 	ibuf->sg.page = sg->page;
@@ -127,7 +114,7 @@
 	buf->sg.length += sizeof(uint32_t);
 }
 
-inline int
+static inline int
 iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn)
 {
 	struct sk_buff *skb = tcp_conn->in.skb;
@@ -206,16 +193,6 @@
 	if (unlikely(!sc))
 		return;
 
-	if (sc->sc_data_direction == DMA_TO_DEVICE) {
-		struct iscsi_data_task *dtask, *n;
-
-		/* WRITE: cleanup Data-Out's if any */
-		list_for_each_entry_safe(dtask, n, &tcp_ctask->dataqueue,
-					 item) {
-			list_del(&dtask->item);
-			mempool_free(dtask, tcp_ctask->datapool);
-		}
-	}
 	tcp_ctask->xmstate = XMSTATE_IDLE;
 	tcp_ctask->r2t = NULL;
 }
@@ -297,14 +274,10 @@
 			struct iscsi_r2t_info *r2t)
 {
 	struct iscsi_data *hdr;
-	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask->sc;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
-	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&dtask->item);
-	hdr = &dtask->hdr;
+	hdr = &r2t->dtask.hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr->ttt = r2t->ttt;
 	hdr->datasn = cpu_to_be32(r2t->solicit_datasn);
@@ -327,11 +300,9 @@
 
 	r2t->sent = 0;
 
-	iscsi_buf_init_virt(&r2t->headbuf, (char*)hdr,
+	iscsi_buf_init_iov(&r2t->headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
-	r2t->dtask = dtask;
-
 	if (sc->use_sg) {
 		int i, sg_count = 0;
 		struct scatterlist *sg = sc->request_buffer;
@@ -363,8 +334,6 @@
 		iscsi_buf_init_iov(&tcp_ctask->sendbuf,
 			    (char*)sc->request_buffer + r2t->data_offset,
 			    r2t->data_count);
-
-	list_add(&dtask->item, &tcp_ctask->dataqueue);
 }
 
 /**
@@ -438,14 +407,72 @@
 	return 0;
 }
 
-static int iscsi_tcp_hdr_recv_post(struct iscsi_conn *conn)
+int iscsi_tcp_hdr_recv(struct iscsi_conn *conn)
 {
+	int ahslen;
+	struct iscsi_hdr *hdr;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	uint32_t cdgst, rdgst = 0;
+
+	hdr = tcp_conn->in.hdr;
+
+	/* verify PDU length */
+	tcp_conn->in.datalen = ntoh24(hdr->dlength);
+	if (tcp_conn->in.datalen > conn->max_recv_dlength) {
+		printk(KERN_ERR "iscsi_tcp: datalen %d > %d\n",
+		       tcp_conn->in.datalen, conn->max_recv_dlength);
+		return ISCSI_ERR_DATALEN;
+	}
+	tcp_conn->data_copied = 0;
+
+	/* read AHS */
+	ahslen = hdr->hlength << 2;
+	tcp_conn->in.offset += ahslen;
+	tcp_conn->in.copy -= ahslen;
+	if (tcp_conn->in.copy < 0) {
+		printk(KERN_ERR "iscsi_tcp: can't handle AHS with length "
+		       "%d bytes\n", ahslen);
+		return ISCSI_ERR_AHSLEN;
+	}
+
+	/* calculate read padding */
+	tcp_conn->in.padding = tcp_conn->in.datalen & (ISCSI_PAD_LEN-1);
+	if (tcp_conn->in.padding) {
+		tcp_conn->in.padding = ISCSI_PAD_LEN - tcp_conn->in.padding;
+		debug_scsi("read padding %d bytes\n", tcp_conn->in.padding);
+	}
+
+	if (conn->hdrdgst_en) {
+		struct scatterlist sg;
+
+		sg_init_one(&sg, (u8 *)hdr,
+			    sizeof(struct iscsi_hdr) + ahslen);
+		crypto_digest_digest(tcp_conn->rx_tfm, &sg, 1, (u8 *)&cdgst);
+		rdgst = *(uint32_t*)((char*)hdr + sizeof(struct iscsi_hdr) +
+				     ahslen);
+		if (cdgst != rdgst) {
+			printk(KERN_ERR "iscsi_tcp: hdrdgst error "
+			       "recv 0x%x calc 0x%x\n", rdgst, cdgst);
+			return ISCSI_ERR_HDR_DGST;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_tcp_hdr_recv);
+
+static int iscsi_tcp_initiator_hdr_recv(struct iscsi_conn *conn)
+{
 	struct iscsi_session *session = conn->session;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_hdr *hdr = tcp_conn->in.hdr;
 	int rc, opcode, ahslen = hdr->hlength << 2;
 	uint32_t itt;
 
+	rc = iscsi_tcp_hdr_recv(conn);
+	if (rc)
+		return rc;
+
 	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
 	/* verify itt (itt encoding: age+cid+itt) */
 	rc = iscsi_verify_itt(conn, hdr, &itt);
@@ -522,69 +549,6 @@
 	return 0;
 }
 
-int iscsi_tcp_hdr_recv_pre(struct iscsi_conn *conn)
-{
-	int ahslen;
-	struct iscsi_hdr *hdr;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	uint32_t cdgst, rdgst = 0;
-
-	hdr = tcp_conn->in.hdr;
-
-	/* verify PDU length */
-	tcp_conn->in.datalen = ntoh24(hdr->dlength);
-	if (tcp_conn->in.datalen > conn->max_recv_dlength) {
-		printk(KERN_ERR "iscsi_tcp: datalen %d > %d\n",
-		       tcp_conn->in.datalen, conn->max_recv_dlength);
-		return ISCSI_ERR_DATALEN;
-	}
-	tcp_conn->data_copied = 0;
-
-	/* read AHS */
-	ahslen = hdr->hlength << 2;
-	tcp_conn->in.offset += ahslen;
-	tcp_conn->in.copy -= ahslen;
-	if (tcp_conn->in.copy < 0) {
-		printk(KERN_ERR "iscsi_tcp: can't handle AHS with length "
-		       "%d bytes\n", ahslen);
-		return ISCSI_ERR_AHSLEN;
-	}
-
-	/* calculate read padding */
-	tcp_conn->in.padding = tcp_conn->in.datalen & (ISCSI_PAD_LEN-1);
-	if (tcp_conn->in.padding) {
-		tcp_conn->in.padding = ISCSI_PAD_LEN - tcp_conn->in.padding;
-		debug_scsi("read padding %d bytes\n", tcp_conn->in.padding);
-	}
-
-	if (conn->hdrdgst_en) {
-		struct scatterlist sg;
-
-		sg_init_one(&sg, (u8 *)hdr,
-			    sizeof(struct iscsi_hdr) + ahslen);
-		crypto_digest_digest(tcp_conn->rx_tfm, &sg, 1, (u8 *)&cdgst);
-		rdgst = *(uint32_t*)((char*)hdr + sizeof(struct iscsi_hdr) +
-				     ahslen);
-		if (cdgst != rdgst) {
-			printk(KERN_ERR "iscsi_tcp: hdrdgst error "
-			       "recv 0x%x calc 0x%x\n", rdgst, cdgst);
-			return ISCSI_ERR_HDR_DGST;
-		}
-	}
-
-	return 0;
-}
-
-static int iscsi_tcp_hdr_recv(struct iscsi_conn *conn)
-{
-	int rc;
-
-	rc = iscsi_tcp_hdr_recv_pre(conn);
-	if (rc)
-		return rc;
-	return iscsi_tcp_hdr_recv_post(conn);
-}
-
 /**
  * iscsi_ctask_copy - copy skb bits to the destanation cmd task
  * @conn: iscsi tcp connection
@@ -711,7 +675,7 @@
 	crypto_digest_update(tcp_conn->data_rx_tfm, &tmp, 1);
 }
 
-int __iscsi_scsi_data_in(struct iscsi_conn *conn)
+int iscsi_scsi_data_in(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
@@ -735,8 +699,7 @@
 		if (conn->datadgst_en)
 			iscsi_recv_digest_update(tcp_conn, sc->request_buffer,
 						 i);
-		rc = 0;
-		goto done;
+		return 0;
 	}
 
 	offset = tcp_ctask->data_offset;
@@ -790,31 +753,29 @@
 			return -EAGAIN;
 	}
 	BUG_ON(ctask->data_count);
-done:
+
 	return rc;
 }
+EXPORT_SYMBOL_GPL(iscsi_scsi_data_in);
 
-static int iscsi_scsi_data_in(struct iscsi_conn *conn)
+static void iscsi_scsi_data_in_done(struct iscsi_conn *conn)
 {
-	int rc;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+	struct scsi_cmnd *sc = ctask->sc;
 
-	rc = __iscsi_scsi_data_in(conn);
-	if (!rc && tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
+	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
 		debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-			   (long) ctask->sc, ctask->sc->result, ctask->itt);
+			   (long)sc, sc->result, ctask->itt);
 		spin_lock(&conn->session->lock);
 		__iscsi_ctask_cleanup(conn, ctask);
 		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);
 		spin_unlock(&conn->session->lock);
 	}
-
-	return 0;
 }
 
 static int
-iscsi_data_recv(struct iscsi_conn *conn)
+iscsi_tcp_initiator_data_recv(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int rc = 0, opcode;
@@ -823,6 +784,8 @@
 	switch (opcode) {
 	case ISCSI_OP_SCSI_DATA_IN:
 		rc = iscsi_scsi_data_in(conn);
+		if (!rc)
+			iscsi_scsi_data_in_done(conn);
 		break;
 	case ISCSI_OP_SCSI_CMD_RSP:
 		spin_lock(&conn->session->lock);
@@ -862,13 +825,12 @@
  * @offset: offset in skb
  * @len: skb->len - offset
  **/
-int
+static int
 iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 		    unsigned int offset, size_t len)
 {
 	int rc;
-	struct data_ready_desc *d = rd_desc->arg.data;
-	struct iscsi_conn *conn = d->conn;
+	struct iscsi_conn *conn = rd_desc->arg.data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int processed;
 	char pad[ISCSI_PAD_LEN];
@@ -909,7 +871,8 @@
 		/*
 		 * Verify and process incoming PDU header.
 		 */
-		rc = d->hdr_recv(conn);
+
+		rc = tcp_conn->ops->hdr_recv(conn);
 		if (!rc && tcp_conn->in.datalen) {
 			if (conn->datadgst_en) {
 				BUG_ON(!tcp_conn->data_rx_tfm);
@@ -956,7 +919,7 @@
 		debug_tcp("data_recv offset %d copy %d\n",
 		       tcp_conn->in.offset, tcp_conn->in.copy);
 
-		rc = d->data_recv(conn);
+		rc = tcp_conn->ops->data_recv(conn);
 		if (rc) {
 			if (rc == -EAGAIN)
 				goto again;
@@ -1013,17 +976,17 @@
 {
 	struct iscsi_conn *conn = sk->sk_user_data;
 	read_descriptor_t rd_desc;
-	struct data_ready_desc d;
 
-	d.conn = conn;
-	d.hdr_recv = iscsi_tcp_hdr_recv;
-	d.data_recv = iscsi_data_recv;
-
 	read_lock(&sk->sk_callback_lock);
 
-	/* use rd_desc to pass 'conn' to iscsi_tcp_data_recv */
-	rd_desc.arg.data = &d;
-	rd_desc.count = 0;
+	/*
+	 * Use rd_desc to pass 'conn' to iscsi_tcp_data_recv.
+	 * We set count to 1 because we want the network layer to
+	 * hand us all the skbs that are available. iscsi_tcp_data_recv
+	 * handled pdus that cross buffers or pdus that still need data.
+	 */
+	rd_desc.arg.data = conn;
+	rd_desc.count = 1;
 	tcp_read_sock(sk, &rd_desc, iscsi_tcp_data_recv);
 
 	read_unlock(&sk->sk_callback_lock);
@@ -1145,7 +1108,7 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-inline int
+static inline int
 iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 {
 	struct iscsi_tcp_conn *tcp_conn;
@@ -1185,7 +1148,7 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-inline int
+static inline int
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent)
 {
@@ -1244,7 +1207,7 @@
 	if (final)
 		crypto_digest_final(tcp_conn->data_tx_tfm, (u8*)digest);
 
-	iscsi_buf_init_virt(buf, (char*)digest, 4);
+	iscsi_buf_init_iov(buf, (char*)digest, 4);
 	rc = iscsi_sendpage(conn, buf, &tcp_ctask->digest_count, &sent);
 	if (rc) {
 		tcp_ctask->datadigest = *digest;
@@ -1273,14 +1236,10 @@
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_data *hdr;
-	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask->sc;
 	int new_offset;
 
-	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&dtask->item);
-	hdr = &dtask->hdr;
+	hdr = &r2t->dtask.hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr->ttt = r2t->ttt;
 	hdr->datasn = cpu_to_be32(r2t->solicit_datasn);
@@ -1301,11 +1260,9 @@
 	}
 	conn->dataout_pdus_cnt++;
 
-	iscsi_buf_init_virt(&r2t->headbuf, (char*)hdr,
+	iscsi_buf_init_iov(&r2t->headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
-	r2t->dtask = dtask;
-
 	if (sc->use_sg && !iscsi_buf_left(&r2t->sendbuf)) {
 		BUG_ON(tcp_ctask->bad_sg == r2t->sg);
 		iscsi_buf_init_sg(&r2t->sendbuf, r2t->sg);
@@ -1314,8 +1271,6 @@
 		iscsi_buf_init_iov(&tcp_ctask->sendbuf,
 			    (char*)sc->request_buffer + new_offset,
 			    r2t->data_count);
-
-	list_add(&dtask->item, &tcp_ctask->dataqueue);
 }
 
 static void
@@ -1324,17 +1279,11 @@
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_data_task *dtask;
 
-	dtask = mempool_alloc(tcp_ctask->datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&dtask->item);
-
+	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
 	iscsi_prep_unsolicit_data_pdu(ctask, &dtask->hdr,
 				      tcp_ctask->r2t_data_count);
-	iscsi_buf_init_virt(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
 			   sizeof(struct iscsi_hdr));
-
-	list_add(&dtask->item, &tcp_ctask->dataqueue);
-	tcp_ctask->dtask = dtask;
 }
 
 /**
@@ -1397,7 +1346,7 @@
 	} else
 		tcp_ctask->xmstate = XMSTATE_R_HDR;
 
-	iscsi_buf_init_virt(&tcp_ctask->headbuf, (char*)ctask->hdr,
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)ctask->hdr,
 			    sizeof(struct iscsi_hdr));
 }
 
@@ -1573,12 +1522,12 @@
 handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_data_task *dtask;
 
 	tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
-		iscsi_unsolicit_data_init(conn, ctask);
-		BUG_ON(!tcp_ctask->dtask);
+		tcp_conn->ops->unsolicit_data_init(conn, ctask);
 		dtask = tcp_ctask->dtask;
 		if (conn->hdrdgst_en)
 			iscsi_hdr_digest(conn, &tcp_ctask->headbuf,
@@ -1687,7 +1636,7 @@
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_r2t_info *r2t = tcp_ctask->r2t;
-	struct iscsi_data_task *dtask = r2t->dtask;
+	struct iscsi_data_task *dtask = &r2t->dtask;
 	int left;
 
 	tcp_ctask->xmstate &= ~XMSTATE_SOL_DATA;
@@ -1794,7 +1743,7 @@
 	int sent;
 
 	tcp_ctask->xmstate &= ~XMSTATE_W_PAD;
-	iscsi_buf_init_virt(&tcp_ctask->sendbuf, (char*)&tcp_ctask->pad,
+	iscsi_buf_init_iov(&tcp_ctask->sendbuf, (char*)&tcp_ctask->pad,
 			    tcp_ctask->pad_count);
 	if (iscsi_sendpage(conn, &tcp_ctask->sendbuf, &tcp_ctask->pad_count,
 			   &sent)) {
@@ -1832,8 +1781,7 @@
 	return 0;
 }
 
-static int
-iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+int iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	int rc = 0;
@@ -1901,7 +1849,7 @@
 		r2t = tcp_ctask->r2t;
 		if (conn->hdrdgst_en)
 			iscsi_hdr_digest(conn, &r2t->headbuf,
-					(u8*)r2t->dtask->hdrext);
+					(u8*)r2t->dtask.hdrext);
 		if (iscsi_sendhdr(conn, &r2t->headbuf, r2t->data_count)) {
 			tcp_ctask->xmstate &= ~XMSTATE_SOL_DATA;
 			tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
@@ -1931,9 +1879,11 @@
 
 	return rc;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_ctask_xmit);
 
 struct iscsi_cls_conn *
-iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
+iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx,
+		      struct iscsi_tcp_operations *ops)
 {
 	struct iscsi_conn *conn;
 	struct iscsi_cls_conn *cls_conn;
@@ -1969,6 +1919,8 @@
 	if (!tcp_conn->data)
 		goto max_recv_dlenght_alloc_fail;
 
+	tcp_conn->ops = ops;
+
 	return cls_conn;
 
 max_recv_dlenght_alloc_fail:
@@ -1977,10 +1929,24 @@
 	iscsi_conn_teardown(cls_conn);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_conn_create);
 
-void
-iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
+static struct iscsi_tcp_operations iscsi_tcp_initiator_ops = {
+	.hdr_recv		=	iscsi_tcp_initiator_hdr_recv,
+	.data_recv		=	iscsi_tcp_initiator_data_recv,
+	.unsolicit_data_init	=	iscsi_unsolicit_data_init,
+};
+
+static struct iscsi_cls_conn *
+iscsi_tcp_initiator_conn_create(struct iscsi_cls_session *cls_session,
+				uint32_t conn_idx)
 {
+	return iscsi_tcp_conn_create(cls_session, conn_idx,
+				     &iscsi_tcp_initiator_ops);
+}
+
+void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
+{
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	int digest = 0;
@@ -2010,6 +1976,7 @@
 			   get_order(tcp_conn->data_size));
 	kfree(tcp_conn);
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_conn_destroy);
 
 int
 iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
@@ -2022,6 +1989,9 @@
 	struct socket *sock;
 	int err;
 
+	printk("%s(%d) %llu %d\n", __FUNCTION__, __LINE__,
+	       (unsigned long long) transport_eph, is_leading);
+
 	/* lookup for existing socket */
 	sock = sockfd_lookup((int)transport_eph, &err);
 	if (!sock) {
@@ -2033,6 +2003,9 @@
 	if (err)
 		return err;
 
+	printk("%s(%d) %llu %d %d\n", __FUNCTION__, __LINE__,
+	       (unsigned long long) transport_eph, is_leading, conn->stop_stage);
+
 	if (conn->stop_stage != STOP_CONN_SUSPEND) {
 		/* bind iSCSI connection and socket */
 		tcp_conn->sock = sock;
@@ -2058,10 +2031,13 @@
 		tcp_conn->in_progress = IN_PROGRESS_WAIT_HEADER;
 	}
 
+	printk("%s(%d) %llu %d\n", __FUNCTION__, __LINE__,
+	       (unsigned long long) transport_eph, is_leading);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_conn_bind);
 
-void
+static void
 iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
@@ -2090,8 +2066,7 @@
 	write_unlock_bh(&sk->sk_callback_lock);
 }
 
-void
-iscsi_tcp_terminate_conn(struct iscsi_conn *conn)
+void iscsi_tcp_terminate_conn(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 
@@ -2106,16 +2081,17 @@
 	tcp_conn->sock = NULL;
 	conn->recv_lock = NULL;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_terminate_conn);
 
 /* called with host lock */
-static void 
+static void
 iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
 		    char *data, uint32_t data_size)
 {
 	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
 
-	iscsi_buf_init_virt(&tcp_mtask->headbuf, (char*)mtask->hdr,
-				    sizeof(struct iscsi_hdr));
+	iscsi_buf_init_iov(&tcp_mtask->headbuf, (char*)mtask->hdr,
+			   sizeof(struct iscsi_hdr));
 	tcp_mtask->xmstate = XMSTATE_IMM_HDR;
 
 	if (mtask->data_count)
@@ -2157,21 +2133,6 @@
 					(void**)tcp_ctask->r2ts);
 			goto r2t_alloc_fail;
 		}
-
-		/*
-		 * number of
-		 * Data-Out PDU's within R2T-sequence can be quite big;
-		 * using mempool
-		 */
-		tcp_ctask->datapool = mempool_create(ISCSI_DTASK_DEFAULT_MAX,
-			 mempool_alloc_slab, mempool_free_slab, taskcache);
-		if (tcp_ctask->datapool == NULL) {
-			kfifo_free(tcp_ctask->r2tqueue);
-			iscsi_pool_free(&tcp_ctask->r2tpool,
-					(void**)tcp_ctask->r2ts);
-			goto r2t_alloc_fail;
-		}
-		INIT_LIST_HEAD(&tcp_ctask->dataqueue);
 	}
 
 	return 0;
@@ -2181,7 +2142,6 @@
 		struct iscsi_cmd_task *ctask = session->cmds[i];
 		struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
-		mempool_destroy(tcp_ctask->datapool);
 		kfifo_free(tcp_ctask->r2tqueue);
 		iscsi_pool_free(&tcp_ctask->r2tpool,
 				(void**)tcp_ctask->r2ts);
@@ -2198,16 +2158,14 @@
 		struct iscsi_cmd_task *ctask = session->cmds[i];
 		struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
-		mempool_destroy(tcp_ctask->datapool);
 		kfifo_free(tcp_ctask->r2tqueue);
 		iscsi_pool_free(&tcp_ctask->r2tpool,
 				(void**)tcp_ctask->r2ts);
 	}
 }
 
-int
-iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
-		     uint32_t value)
+int iscsi_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
+			     uint32_t value)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_session *session = conn->session;
@@ -2345,6 +2303,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_conn_set_param);
 
 static int
 iscsi_session_get_param(struct iscsi_cls_session *cls_session,
@@ -2420,7 +2379,7 @@
 		}
 
 		inet = inet_sk(tcp_conn->sock->sk);
-		*value = be16_to_cpu(inet->dport); 
+		*value = be16_to_cpu(inet->dport);
 		mutex_unlock(&conn->xmitmutex);
 	case ISCSI_PARAM_EXP_STATSN:
 		*value = conn->exp_statsn;
@@ -2537,27 +2496,14 @@
 	iscsi_session_teardown(cls_session);
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_session_create);
 
 void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
 {
-	struct iscsi_session *session = class_to_transport_session(cls_session);
-	struct iscsi_data_task *dtask, *n;
-	int cmd_i;
-
-	for (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {
-		struct iscsi_cmd_task *ctask = session->cmds[cmd_i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-		list_for_each_entry_safe(dtask, n, &tcp_ctask->dataqueue,
-					 item) {
-			list_del(&dtask->item);
-			mempool_free(dtask, tcp_ctask->datapool);
-		}
-	}
-
 	iscsi_r2tpool_free(class_to_transport_session(cls_session));
 	iscsi_session_teardown(cls_session);
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_session_destroy);
 
 static struct scsi_host_template iscsi_sht = {
 	.name			= "iSCSI Initiator over TCP/IP, v."
@@ -2602,10 +2548,10 @@
 	.create_session		= iscsi_tcp_session_create,
 	.destroy_session	= iscsi_tcp_session_destroy,
 	/* connection management */
-	.create_conn		= iscsi_tcp_conn_create,
+	.create_conn		= iscsi_tcp_initiator_conn_create,
 	.bind_conn		= iscsi_tcp_conn_bind,
 	.destroy_conn		= iscsi_tcp_conn_destroy,
-	.set_param		= iscsi_conn_set_param,
+	.set_param		= iscsi_tcp_conn_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
 	.get_conn_str_param	= iscsi_conn_get_str_param,
 	.get_session_param	= iscsi_session_get_param,
@@ -2626,28 +2572,27 @@
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 };
 
-int iscsi_tcp_init(void)
+static int __init
+iscsi_tcp_init(void)
 {
 	if (iscsi_max_lun < 1) {
-		printk(KERN_ERR "iscsi_tcp: Invalid max_lun value of %u\n", iscsi_max_lun);
+		printk(KERN_ERR "iscsi_tcp: Invalid max_lun value of %u\n",
+		       iscsi_max_lun);
 		return -EINVAL;
 	}
 	iscsi_tcp_transport.max_lun = iscsi_max_lun;
 
-	taskcache = kmem_cache_create("iscsi_taskcache",
-			sizeof(struct iscsi_data_task), 0,
-			SLAB_HWCACHE_ALIGN, NULL, NULL);
-	if (!taskcache)
-		return -ENOMEM;
-
 	if (!iscsi_register_transport(&iscsi_tcp_transport))
-		kmem_cache_destroy(taskcache);
+		return -ENODEV;
 
 	return 0;
 }
 
-void iscsi_tcp_exit(void)
+static void __exit
+iscsi_tcp_exit(void)
 {
 	iscsi_unregister_transport(&iscsi_tcp_transport);
-	kmem_cache_destroy(taskcache);
 }
+
+/* module_init(iscsi_tcp_init); */
+/* module_exit(iscsi_tcp_exit); */

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-22 16:03:36 UTC (rev 479)
@@ -71,6 +71,13 @@
 	char			zero_copy_hdr;
 };
 
+/* TODO: unsolicited and solicit data should be treated equally */
+struct iscsi_tcp_operations {
+	int (*hdr_recv)(struct iscsi_conn *);
+	int (*data_recv)(struct iscsi_conn *);
+	void (*unsolicit_data_init)(struct iscsi_conn *, struct iscsi_cmd_task *);
+};
+
 struct iscsi_tcp_conn {
 	struct iscsi_conn	*iscsi_conn;
 	struct socket		*sock;
@@ -107,6 +114,8 @@
 	uint32_t		discontiguous_hdr_cnt;
 
 	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
+	struct iscsi_tcp_operations *ops;
+	struct work_struct	recvwork;	/* per-conn. recv workqueue */
 };
 
 struct iscsi_buf {
@@ -118,11 +127,9 @@
 struct iscsi_data_task {
 	struct iscsi_data	hdr;			/* PDU */
 	char			hdrext[sizeof(__u32)];	/* Header-Digest */
-	struct list_head	item;			/* data queue item */
 	struct iscsi_buf	digestbuf;		/* digest buffer */
 	uint32_t		digest;			/* data digest */
 };
-#define ISCSI_DTASK_DEFAULT_MAX	ISCSI_SG_TABLESIZE * PAGE_SIZE / 512
 
 struct iscsi_tcp_mgmt_task {
 	struct iscsi_hdr	hdr;
@@ -144,7 +151,7 @@
 	int			data_count;	/* DATA-Out payload progress */
 	struct scatterlist	*sg;		/* per-R2T SG list */
 	int			solicit_datasn;
-	struct iscsi_data_task   *dtask;        /* which data task */
+	struct iscsi_data_task   dtask;        /* which data task */
 };
 
 struct iscsi_tcp_cmd_task {
@@ -167,21 +174,40 @@
 	struct iscsi_queue	r2tpool;
 	struct kfifo		*r2tqueue;
 	struct iscsi_r2t_info	**r2ts;
-	struct list_head	dataqueue;		/* Data-Out dataqueue */
-	mempool_t		*datapool;
 	uint32_t		datadigest;		/* for recover digest */
 	int			digest_count;
 	uint32_t		immdigest;		/* for imm data */
 	struct iscsi_buf	immbuf;			/* for imm data digest */
-	struct iscsi_data_task   *dtask;		/* data task in progress*/
-	int			digest_offset;		/* for partial buff digest */
-	struct iscsi_cmd	rhdr;
+	struct iscsi_data_task	*dtask;		/* data task in progress*/
+	struct iscsi_data_task	unsol_dtask;	/* unsol data task */
+	int			digest_offset;	/* for partial buff digest */
 };
 
-struct data_ready_desc {
-	struct iscsi_conn *conn;
-	int (* hdr_recv)(struct iscsi_conn *conn);
-	int (* data_recv)(struct iscsi_conn *conn);
-};
 
+extern struct iscsi_cls_session *
+iscsi_tcp_session_create(struct iscsi_transport *iscsit,
+			 struct scsi_transport_template *scsit,
+			 uint32_t initial_cmdsn, uint32_t *hostno);
+extern void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session);
+
+extern struct iscsi_cls_conn *
+iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx,
+		      struct iscsi_tcp_operations *ops);
+extern void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn);
+
+extern int iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
+			       struct iscsi_cls_conn *cls_conn,
+			       uint64_t transport_eph, int is_leading);
+extern int iscsi_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn,
+				    enum iscsi_param param, uint32_t value);
+extern void iscsi_tcp_terminate_conn(struct iscsi_conn *conn);
+
+extern int iscsi_tcp_ctask_xmit(struct iscsi_conn *conn,
+				struct iscsi_cmd_task *ctask);
+extern int iscsi_tcp_hdr_recv(struct iscsi_conn *conn);
+
+extern int iscsi_scsi_data_in(struct iscsi_conn *conn);
+extern void
+iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size);
+
 #endif /* ISCSI_H */

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-22 16:03:36 UTC (rev 479)
@@ -1,8 +1,8 @@
 /*
  * iSCSI Target over TCP/IP
  *
- * Copyright (C) 2004 - 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published
@@ -17,9 +17,6 @@
  * See the file COPYING included with this distribution for more details.
  */
 
-/*
- * This needs to be integrated with iscsi_tcp.
- */
 #include <linux/list.h>
 #include <linux/inet.h>
 #include <linux/kfifo.h>
@@ -32,7 +29,7 @@
 #include "iscsi_tcp.h"
 #include "libiscsi.h"
 #include "scsi_transport_iscsi.h"
-#include "iscsi_tcp_priv.h"
+#include "iscsi_tcp.h"
 
 /* tmp - will replace with SCSI logging stuff */
 #define eprintk(fmt, args...)					\
@@ -43,46 +40,21 @@
 #define dprintk eprintk
 
 struct istgt_session {
-	struct list_head recvlist;
-	struct list_head wtasklist;
-	/* replace with array later on */
+	struct list_head cmd_pending;
 	struct list_head cmd_hash;
-	struct work_struct recvwork;
 };
 
-static void r2t_build(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *) &tcp_ctask->rhdr;
-	int length;
+static struct workqueue_struct *recvwq;
 
-	rhdr->opcode = ISCSI_OP_R2T;
-	rhdr->flags = ISCSI_FLAG_CMD_FINAL;
-	memcpy(rhdr->lun, ctask->hdr->lun, 8);
-	rhdr->itt = ctask->hdr->itt;
-	rhdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
-	rhdr->data_offset = cpu_to_be32(tcp_ctask->data_offset);
-	rhdr->ttt = 0; /* FIXME */
-
-	length = min(tcp_ctask->r2t_data_count, session->max_burst);
-	rhdr->data_length = cpu_to_be32(length);
-
-	tcp_ctask->r2t_data_count -= length;
-
-	dprintk("%p %u %u %u %u\n",
-		ctask, length, tcp_ctask->r2t_data_count, tcp_ctask->data_offset,
-		session->max_burst);
-}
-
 static void hashlist_add(struct iscsi_cls_session *cls_session,
 			 struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_session *session = class_to_transport_session(cls_session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
 
-	spin_lock_bh(&ctask->conn->session->lock);
+	spin_lock_bh(&session->lock);
 	list_add(&ctask->hash, &istgt_session->cmd_hash);
-	spin_unlock_bh(&ctask->conn->session->lock);
+	spin_unlock_bh(&session->lock);
 }
 
 static struct iscsi_cmd_task *hashlist_find(struct iscsi_cls_session *cls_session, u32 itt)
@@ -102,8 +74,32 @@
 	return ctask;
 }
 
-static void istgt_scsi_tgt_queue_command(struct iscsi_cmd_task *ctask)
+static void iscsi_tcp_tgt_ctask_xmitqueue(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_conn *conn = ctask->conn;
+	struct iscsi_cls_session *cls_session = session_to_cls(conn->session);
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+
+	spin_lock_bh(&conn->session->lock);
+	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+	spin_unlock_bh(&conn->session->lock);
+	scsi_queue_work(shost, &conn->xmitwork);
+}
+
+static void iscsi_tcp_tgt_ctask_cleanup(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask->conn;
+
+	dprintk("%p %p\n", ctask, conn->session);
+	spin_lock_bh(&conn->session->lock);
+	list_del(&ctask->hash);
+	list_del_init(&ctask->running);
+	__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+	spin_unlock_bh(&conn->session->lock);
+}
+
+static void iscsi_tcp_tgt_sc_queue(struct iscsi_cmd_task *ctask)
+{
 	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
@@ -118,6 +114,7 @@
 	memcpy(scmd->data_cmnd, hdr->cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = be32_to_cpu(hdr->data_length);
 	scmd->SCp.ptr = (void *) ctask;
+	scmd->done = NULL;
 
 	switch (hdr->flags & ISCSI_FLAG_CMD_ATTR_MASK) {
 	case ISCSI_ATTR_UNTAGGED:
@@ -131,49 +128,53 @@
 	default:
 		scmd->tag = MSG_ORDERED_TAG;
 	}
-
 	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
 }
 
-static void istgt_scsi_cmd_exec(struct iscsi_cmd_task *ctask)
+/* TODO: we cannot handle multiple outstanding r2t. */
+static void iscsi_r2t_build(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_session *session = ctask->conn->session;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_cls_session *cls_session = session_to_cls(ctask->conn->session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_r2t_rsp *hdr =
+		(struct iscsi_r2t_rsp *) &tcp_ctask->unsol_dtask.hdr;
+	int length;
 
-	if (tcp_ctask->r2t_data_count) {
-		if (!ctask->unsol_count) {
-			__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
-			scsi_queue_work(shost, &ctask->conn->xmitwork);
-		}
-	} else {
-		if (ctask->sc) {
-			BUG_ON(!ctask->sc->done);
-			ctask->sc->done(ctask->sc);
-		} else
-			istgt_scsi_tgt_queue_command(ctask);
-	}
+	tcp_ctask->xmstate = XMSTATE_R_HDR;
+	memset(hdr, 0, sizeof(struct iscsi_hdr));
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *)hdr,
+			   sizeof(struct iscsi_hdr));
+
+	hdr->opcode = ISCSI_OP_R2T;
+	hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	memcpy(hdr->lun, ctask->hdr->lun, sizeof(hdr->lun));
+	hdr->itt = ctask->itt;
+	hdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
+	hdr->data_offset = cpu_to_be32(tcp_ctask->data_offset);
+	hdr->ttt = (unsigned long) ctask; /* FIXME */
+	length = min(tcp_ctask->r2t_data_count, session->max_burst);
+	hdr->data_length = cpu_to_be32(length);
+	tcp_ctask->r2t_data_count -= length;
+
+	dprintk("%p %u %u %u %u\n", ctask, length, tcp_ctask->r2t_data_count,
+		tcp_ctask->data_offset,	session->max_burst);
 }
 
-static void istgt_cmd_exec(struct iscsi_cmd_task *ctask)
+static void __iscsi_tgt_cmd_exec(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_conn *conn = ctask->conn;
-	struct iscsi_cls_session *cls_session =
-		session_to_cls(ctask->conn->session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	u8 opcode;
+	u8 opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
 
-	opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
-
 	dprintk("%p,%x,%u\n", ctask, opcode, ctask->hdr->cmdsn);
-
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
-		istgt_scsi_cmd_exec(ctask);
+		if (ctask->sc)
+			ctask->sc->done(ctask->sc);
+		else
+			iscsi_tcp_tgt_sc_queue(ctask);
 		break;
 	case ISCSI_OP_LOGOUT:
-		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-		scsi_queue_work(shost, &conn->xmitwork);
+		/* TODO: move to user-space */
+		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -187,85 +188,110 @@
 	}
 }
 
-static void istgt_recvworker(void *data)
+static void iscsi_tgt_cmd_exec(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_cls_session *cls_session = data;
-	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_cmd_task *pos;
+	struct iscsi_conn *conn = ctask->conn;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct istgt_session *istgt_session = cls_session->dd_data;
-	struct iscsi_cmd_task *ctask;
 
-	dprintk("%x\n", session->exp_cmdsn);
-retry:
+	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
+		__iscsi_tgt_cmd_exec(ctask);
+		return;
+	}
+
 	spin_lock_bh(&session->lock);
 
-	while (!list_empty(&istgt_session->wtasklist)) {
-		ctask = list_entry(istgt_session->wtasklist.next,
-				   struct iscsi_cmd_task, tgtlist);
-		list_del(&ctask->tgtlist);
-		spin_unlock_bh(&session->lock);
-		dprintk("found wtask %p\n", ctask);
-		istgt_scsi_tgt_queue_command(ctask);
-		goto retry;
-	}
+	list_for_each_entry(pos, &istgt_session->cmd_pending, pending)
+		if (before(ctask->hdr->cmdsn, pos->hdr->cmdsn))
+			break;
+	list_add_tail(&ctask->pending, &pos->pending);
 
-	while (!list_empty(&istgt_session->recvlist)) {
-		ctask = list_entry(istgt_session->recvlist.next,
-				   struct iscsi_cmd_task, tgtlist);
+retry:
+	while (!list_empty(&istgt_session->cmd_pending)) {
+		ctask = list_entry(istgt_session->cmd_pending.next,
+				   struct iscsi_cmd_task, pending);
 
 		dprintk("%p %x %x\n", ctask, ctask->hdr->cmdsn, session->exp_cmdsn);
-
 		if (be32_to_cpu(ctask->hdr->cmdsn) != session->exp_cmdsn)
 			break;
 
-		list_del(&ctask->tgtlist);
-		session->exp_cmdsn++;
+		list_del_init(&ctask->pending);
 
 		spin_unlock_bh(&session->lock);
-		istgt_cmd_exec(ctask);
+		session->exp_cmdsn++;
+		__iscsi_tgt_cmd_exec(ctask);
+		spin_lock_bh(&session->lock);
 		goto retry;
 	}
-
 	spin_unlock_bh(&session->lock);
 }
 
-static void istgt_ctask_add(struct iscsi_cmd_task *ctask)
+static struct iscsi_cmd_task *iscsi_tcp_tgt_cmd_init(struct iscsi_conn *conn)
 {
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
-	struct istgt_session *istgt_session = cls_session->dd_data;
-	struct iscsi_cmd_task *pos;
+	struct iscsi_cmd_task *ctask;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_tcp_cmd_task *tcp_ctask;
+	struct iscsi_hdr *hdr = tcp_conn->in.hdr;
 
-	dprintk("%p %x %x %x\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], ctask->hdr->cmdsn);
+	__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
+	BUG_ON(!ctask);
 
-	spin_lock_bh(&session->lock);
+	ctask->conn = conn;
+	ctask->data_count = 0;
+	ctask->sc = NULL;
+	ctask->datasn = 0;
+	ctask->itt = hdr->itt;
+	INIT_LIST_HEAD(&ctask->running);
+	INIT_LIST_HEAD(&ctask->hash);
+	INIT_LIST_HEAD(&ctask->pending);
+	memcpy(ctask->hdr, hdr, sizeof(*hdr));
+	ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
 
-	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
-		list_add(&ctask->tgtlist, &istgt_session->recvlist);
-		goto out;
-	}
+	tcp_ctask = ctask->dd_data;
+	tcp_ctask->sg = NULL;
+	tcp_ctask->sent = 0;
+	tcp_ctask->data_offset = 0;
 
-	list_for_each_entry(pos, &istgt_session->recvlist, tgtlist)
-		if (before(ctask->hdr->cmdsn, pos->hdr->cmdsn))
-			break;
+	if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+		tcp_ctask->exp_r2tsn = 0;
+		tcp_ctask->r2t_data_count = be32_to_cpu(ctask->hdr->data_length)
+			- tcp_conn->in.datalen;
+		if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
+			ctask->unsol_count = 0;
+		else
+			ctask->unsol_count = 1;
 
-	list_add_tail(&ctask->tgtlist, &pos->tgtlist);
-out:
-	spin_unlock_bh(&session->lock);
+		ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
+		dprintk("%p %x %u %u %u %u\n", ctask, hdr->flags,
+			tcp_ctask->r2t_data_count,
+			ctask->unsol_count,
+			ctask->total_length,
+			ctask->imm_count);
+
+		hashlist_add(session_to_cls(session), ctask);
+
+		/* we stop reading here. */
+		set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
+		iscsi_tcp_tgt_sc_queue(ctask);
+	} else
+		iscsi_tgt_cmd_exec(ctask);
+
+	return ctask;
 }
 
-static int istgt_tcp_hdr_recv(struct iscsi_conn *conn)
+static int iscsi_tcp_tgt_hdr_recv(struct iscsi_conn *conn)
 {
 	int rc, opcode;
 	struct iscsi_hdr *hdr;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = NULL;
-	struct iscsi_tcp_cmd_task *tcp_ctask;
-	struct istgt_session *istgt_session = cls_session->dd_data;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_cls_session *cls_session = session_to_cls(session);
 
-	rc = iscsi_tcp_hdr_recv_pre(conn);
+	rc = iscsi_tcp_hdr_recv(conn);
 	if (rc)
 		return rc;
 
@@ -276,59 +302,10 @@
 		hdr->hlength << 2, tcp_conn->in.datalen);
 
 	switch (opcode) {
-	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_LOGOUT:
-		spin_lock_bh(&session->lock);
-		__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-		spin_unlock_bh(&session->lock);
-		BUG_ON(!ctask);
-
-		ctask->conn = conn;
-		ctask->data_count = 0;
-		ctask->sc = NULL;
-		ctask->datasn = 0;
-		ctask->total_length = 0;
-		memcpy(ctask->hdr, hdr, sizeof(*hdr));
-
-		tcp_ctask = ctask->dd_data;
-		tcp_ctask->sg = NULL;
-		tcp_ctask->sent = 0;
-		tcp_ctask->data_offset = 0;
-		if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
-			tcp_ctask->xmstate = XMSTATE_W_HDR;
-			tcp_ctask->exp_r2tsn = 0;
-			tcp_ctask->r2t_data_count = be32_to_cpu(ctask->hdr->data_length)
-				- tcp_conn->in.datalen;
-			if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
-				ctask->unsol_count = 0;
-			else
-				ctask->unsol_count = 1;
-			/* FIXME */
-			ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
-			ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
-
-			dprintk("%p %x %u %u %u %u\n", ctask, hdr->flags,
-				tcp_ctask->r2t_data_count,
-				ctask->unsol_count,
-				ctask->total_length,
-				ctask->imm_count);
-
-			hashlist_add(cls_session, ctask);
-			spin_lock_bh(&session->lock);
-			list_add(&ctask->tgtlist, &istgt_session->wtasklist);
-			spin_unlock_bh(&session->lock);
-			schedule_work(&istgt_session->recvwork);
-
-			/* we stop reading here. */
-			set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
-			if (!tcp_conn->in.datalen)
-				ctask = NULL;
-		} else {
-			tcp_ctask->xmstate = XMSTATE_UNS_INIT;
-			istgt_ctask_add(ctask);
-			ctask = NULL;
-			schedule_work(&istgt_session->recvwork);
-		}
+	case ISCSI_OP_SCSI_CMD:
+		ctask = iscsi_tcp_tgt_cmd_init(conn);
+		dprintk("%p\n", ctask);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		ctask = hashlist_find(cls_session, hdr->itt);
@@ -338,13 +315,12 @@
 			break;
 		}
 		ctask->data_count = tcp_conn->in.datalen;
-		tcp_ctask = ctask->dd_data;
 		{
-			struct iscsi_data *dhdr =
-				(struct iscsi_data *) hdr;
+			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+			struct iscsi_data *hdr = (struct iscsi_data *) hdr;
 			dprintk("%p %u %u %u %u %u %x\n", ctask,
 				ctask->total_length,
-				be32_to_cpu(dhdr->offset),
+				be32_to_cpu(hdr->offset),
 				tcp_ctask->data_offset,
 				tcp_ctask->r2t_data_count, ctask->data_count,
 				tcp_conn->in.hdr->flags);
@@ -352,43 +328,68 @@
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
-		BUG_ON(1);
+		eprintk("Cannot handle yet %x\n", opcode);
 		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 	default:
 		rc = ISCSI_ERR_BAD_OPCODE;
 	}
+	tcp_conn->in.ctask = ctask;
 
-	if (ctask)
-		tcp_conn->in.ctask = ctask;
-
 	return rc;
 }
 
-static int
-istgt_data_recv(struct iscsi_conn *conn)
+static void iscsi_cmd_data_done(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+
+	if (tcp_ctask->r2t_data_count) {
+		iscsi_r2t_build(ctask);
+		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
+	} else
+		iscsi_tgt_cmd_exec(ctask);
+}
+
+static void iscsi_handle_data_out_cmd(struct iscsi_conn *conn)
+{
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
-	struct istgt_session *istgt_session = cls_session->dd_data;
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	int rc = 0, opcode;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
-	/* We need to return -EAGAIN if the buffer is not ready. */
+	BUG_ON(ctask->data_count);
+	tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
 
-	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
+	dprintk("%p %x %u %u %u %u %u\n", ctask, tcp_conn->in.hdr->flags,
+		tcp_ctask->r2t_data_count, ctask->unsol_count,
+		ctask->total_length, ctask->imm_count, tcp_ctask->data_offset);
 
+	if (tcp_conn->in.hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		tcp_ctask->r2t_data_count -= ntoh24(tcp_conn->in.hdr->dlength);
+		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+			ctask->unsol_count = 0;
+			iscsi_cmd_data_done(ctask);
+		}
+	} else {
+		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL)
+			iscsi_cmd_data_done(ctask);
+	}
+}
+
+static int iscsi_tcp_tgt_data_recv(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+	int rc = 0, opcode;
+
+	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
 	dprintk("opcode 0x%x offset %d copy %d datalen %d\n",
 		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
 		tcp_conn->in.datalen);
 
 	switch (opcode) {
 	case ISCSI_OP_SCSI_CMD:
-		/* read immediate data */
-		rc = __iscsi_scsi_data_in(conn);
+		rc = iscsi_scsi_data_in(conn);
 		if (!rc) {
 			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
@@ -399,45 +400,16 @@
 				ctask->total_length,
 				ctask->imm_count, tcp_ctask->data_offset);
 
-			BUG_ON(ctask->data_count);
 			tcp_ctask->data_offset += ctask->imm_count;
-			istgt_ctask_add(ctask);
-			schedule_work(&istgt_session->recvwork);
+			ctask->imm_count = 0;
+			if (!ctask->unsol_count)
+				iscsi_cmd_data_done(ctask);
 		}
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
-		rc = __iscsi_scsi_data_in(conn);
-		if (!rc) {
-			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-			BUG_ON(ctask->data_count);
-			tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
-
-			if (tcp_conn->in.hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-				dprintk("%p %x %u %u %u %u %u\n", ctask,
-					tcp_conn->in.hdr->flags,
-					tcp_ctask->r2t_data_count,
-					ctask->unsol_count,
-					ctask->total_length,
-					ctask->imm_count, tcp_ctask->data_offset);
-
-				tcp_ctask->r2t_data_count -= ntoh24(tcp_conn->in.hdr->dlength);
-				if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-					ctask->unsol_count = 0;
-					istgt_scsi_cmd_exec(ctask);
-				}
-			} else {
-				if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-					BUG_ON(tcp_ctask->r2t_data_count);
-					BUG_ON(!ctask->sc->done);
-					ctask->sc->done(ctask->sc);
-				} else if (tcp_ctask->r2t_data_count) {
-					tcp_ctask->xmstate = XMSTATE_W_HDR;
-					__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-					scsi_queue_work(shost, &conn->xmitwork);
-				}
-			}
-		}
+		rc = iscsi_scsi_data_in(conn);
+		if (!rc)
+			iscsi_handle_data_out_cmd(conn);
 		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_LOGOUT:
@@ -450,457 +422,349 @@
 	return rc;
 }
 
-static void
-istgt_tcp_data_ready(struct sock *sk, int flag)
+static void __iscsi_data_rsp_build(struct iscsi_cmd_task *ctask,
+				   struct iscsi_data_rsp *hdr)
 {
-	struct iscsi_conn *conn = sk->sk_user_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct scsi_cmnd *sc = ctask->sc;
+	struct iscsi_session *session = ctask->conn->session;
+	u32 left, residual, exp_datalen, size;
 
-	schedule_work(&conn->tcpwork);
-}
+	exp_datalen = be32_to_cpu(ctask->hdr->data_length);
+	left = min_t(int, ctask->unsol_count, exp_datalen);
 
-static void __istgt_tcp_data_ready(void *data)
-{
-	struct iscsi_cls_conn *cls_conn = data;
-	struct iscsi_conn *conn = cls_conn->dd_data;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct sock *sk = tcp_conn->sock->sk;
-	read_descriptor_t rd_desc;
-	struct data_ready_desc d;
+	hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
+	hdr->itt = ctask->itt;
+	hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	hdr->offset = cpu_to_be32(sc->offset + tcp_ctask->data_offset);
+	hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
+	hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
+	hdr->max_cmdsn = cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
+	hdr->datasn = cpu_to_be32(ctask->datasn++);
 
-	d.conn = conn;
-	d.hdr_recv = istgt_tcp_hdr_recv;
-	d.data_recv = istgt_data_recv;
+	if (left <= ctask->conn->max_xmit_dlength) {
+		hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
-	read_lock(&sk->sk_callback_lock);
+		if (sc->bufflen < exp_datalen) {
+			hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = exp_datalen - sc->bufflen;
+		} else if (sc->bufflen > exp_datalen) {
+			hdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = sc->bufflen - exp_datalen;
+		} else
+			residual = 0;
+		hdr->residual_count = cpu_to_be32(residual);
+		size = left;
+	} else
+		size = ctask->conn->max_xmit_dlength;
 
-	/* use rd_desc to pass 'conn' to iscsi_tcp_data_recv */
-	rd_desc.arg.data = &d;
-	rd_desc.count = 1;
-	tcp_read_sock(sk, &rd_desc, iscsi_tcp_data_recv);
+	dprintk("%d %d %d %d %d\n", size, left, ctask->conn->max_xmit_dlength,
+		exp_datalen, sc->bufflen);
 
-	read_unlock(&sk->sk_callback_lock);
+	hton24(hdr->dlength, size);
+	ctask->data_count = ctask->unsol_count = size;
+	tcp_ctask->data_offset += size;
 }
 
-static int
-istgt_tcp_conn_bind(struct iscsi_cls_session *cls_session,
-		    struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
-		    int is_leading)
+static void __iscsi_rsp_build(struct iscsi_cmd_task *ctask,
+			      struct iscsi_hdr *p)
 {
-	struct socket *sock;
-	struct iscsi_conn *conn = cls_conn->dd_data;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	int err;
-	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_session *session = ctask->conn->session;
+	u8 opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
 
-	dprintk("%llu %u\n", (unsigned long long) transport_eph, is_leading);
+	dprintk("%p %x\n", ctask, opcode);
+	ctask->data_count = 0;
+	tcp_ctask->xmstate = XMSTATE_R_HDR;
 
-	err = iscsi_tcp_conn_bind(cls_session, cls_conn, transport_eph, is_leading);
-	if (err) {
-		eprintk("fail to bind %d\n", err);
-		return err;
+	switch (opcode) {
+	case ISCSI_OP_SCSI_CMD:
+	{
+		struct iscsi_cmd_rsp *hdr = (struct iscsi_cmd_rsp *) p;
+
+		hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
+		hdr->itt = ctask->itt;
+		hdr->flags = ISCSI_FLAG_CMD_FINAL;
+		hdr->response = ISCSI_STATUS_CMD_COMPLETED;
+		hdr->cmd_status = SAM_STAT_GOOD;
+		hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
+		hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
+		hdr->max_cmdsn =
+			cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
+		break;
 	}
+	case ISCSI_OP_LOGOUT:
+	{
+		struct iscsi_logout_rsp *hdr = (struct iscsi_logout_rsp *) p;
+		hdr->opcode = ISCSI_OP_LOGOUT_RSP;
+		hdr->flags = ISCSI_FLAG_CMD_FINAL;
+		hdr->itt = ctask->itt;
+		break;
+	}
+	default:
+		BUG_ON(1);
+		break;
+	}
+	dprintk("%p %x\n", ctask, opcode);
+}
 
-	sock = tcp_conn->sock;
+static void iscsi_data_rsp_build(struct iscsi_conn *conn,
+				 struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_data_task *dtask;
 
-	write_lock_bh(&sock->sk->sk_callback_lock);
-	sock->sk->sk_data_ready = istgt_tcp_data_ready;
-	write_unlock_bh(&sock->sk->sk_callback_lock);
-
-	INIT_WORK(&conn->tcpwork, __istgt_tcp_data_ready, cls_conn);
-
-	dprintk("%u %u %u %u %u %u %u %u %u %u %u %u\n",
-		conn->max_recv_dlength, conn->max_xmit_dlength,
-		conn->hdrdgst_en, conn->datadgst_en, session->initial_r2t_en,
-		session->max_r2t, session->imm_data_en,
-		session->first_burst, session->max_burst,
-		session->pdu_inorder_en, session->dataseq_inorder_en, session->erl);
-
-	return 0;
+	dprintk("%p\n", ctask);
+	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
+	memset(&dtask->hdr, 0, sizeof(struct iscsi_hdr));
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+			   sizeof(struct iscsi_hdr));
+	__iscsi_data_rsp_build(ctask, (struct iscsi_data_rsp *) &dtask->hdr);
 }
 
-static struct iscsi_cls_session *
-istgt_tcp_session_create(struct iscsi_transport *iscsit,
-			 struct scsi_transport_template *scsit,
-			 uint32_t initial_cmdsn, uint32_t *hostno)
+static void iscsi_rsp_build(struct iscsi_conn *conn,
+			    struct iscsi_cmd_task *ctask)
 {
-	struct Scsi_Host *shost;
-	struct iscsi_cls_session *cls_session;
-	struct iscsi_session *session;
-	struct istgt_session *istgt_session;
-	int i, err;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_data_task *dtask;
 
-	dprintk("%u %u\n", initial_cmdsn, *hostno);
-	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn, hostno);
-	if (!cls_session)
-		return NULL;
-	shost = iscsi_session_to_shost(cls_session);
-	err = scsi_tgt_alloc_queue(shost);
-	if (err)
-		goto session_free;
-
-	session = class_to_transport_session(cls_session);
-	for (i = 0; i < initial_cmdsn; i++) {
-		struct iscsi_cmd_task *ctask = session->cmds[i];
-		INIT_LIST_HEAD(&ctask->hash);
-		INIT_LIST_HEAD(&ctask->tgtlist);
-	}
-	session->exp_cmdsn = initial_cmdsn;
-
-	istgt_session =	(struct istgt_session *) cls_session->dd_data;
-	INIT_LIST_HEAD(&istgt_session->recvlist);
-	INIT_LIST_HEAD(&istgt_session->wtasklist);
-	INIT_LIST_HEAD(&istgt_session->cmd_hash);
-	INIT_WORK(&istgt_session->recvwork, istgt_recvworker, cls_session);
-
-	return cls_session;
-session_free:
-	iscsi_session_teardown(cls_session);
-	return NULL;
+	dprintk("%p\n", ctask);
+	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
+	memset(&dtask->hdr, 0, sizeof(struct iscsi_hdr));
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+			   sizeof(struct iscsi_hdr));
+	__iscsi_rsp_build(ctask, (struct iscsi_hdr *) &dtask->hdr);
 }
 
-static int istgt_transfer_response(struct scsi_cmnd *scmd,
-				   void (*done)(struct scsi_cmnd *))
+static int iscsi_tgt_transfer_response(struct scsi_cmnd *scmd,
+				       void (*done)(struct scsi_cmnd *))
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_conn *conn = ctask->conn;
-	struct iscsi_cls_session *cls_session = session_to_cls(conn->session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 
-	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
+	dprintk("%p %x %x %u %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], scmd->request_bufflen,
+		scmd->bufflen, scmd->sc_data_direction);
 
-	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
-		tcp_ctask->xmstate = XMSTATE_UNS_INIT;
-		ctask->total_length = 0;
-		scmd->done = done;
-		__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-		scsi_queue_work(shost, &conn->xmitwork);
+	if (scmd->sc_data_direction == DMA_FROM_DEVICE && scmd->bufflen) {
+		/* We've already sent data in transfer_data. */
+		iscsi_tcp_tgt_ctask_cleanup(ctask);
+		done(scmd);
 	} else {
-		if (scmd->bufflen) {
-			done(scmd);
-			spin_lock_bh(&conn->session->lock);
-			__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-			iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
-			spin_unlock_bh(&conn->session->lock);
-		} else {
-			scmd->done = done;
-			__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
-			scsi_queue_work(shost, &ctask->conn->xmitwork);
-		}
+		scmd->done = done;
+		iscsi_rsp_build(ctask->conn, ctask);
+		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
 	}
 	return 0;
 }
 
-static int istgt_transfer_data(struct scsi_cmnd *scmd,
-			       void (*done)(struct scsi_cmnd *))
+static void recvworker(void *data)
 {
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
+	struct iscsi_conn *conn = data;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct sock *sk = tcp_conn->sock->sk;
+
+	bh_lock_sock(sk);
+	sk->sk_data_ready(sk, 0);
+	bh_unlock_sock(sk);
+}
+
+static int iscsi_tgt_transfer_data(struct scsi_cmnd *sc,
+				   void (*done)(struct scsi_cmnd *))
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) sc->SCp.ptr;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_cls_session *cls_session = session_to_cls(ctask->conn->session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 
 	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
+		ctask->hdr->cdb[0], sc->request_bufflen, sc->sc_data_direction);
 
-	if (scmd->sc_data_direction == DMA_TO_DEVICE) {
+	sc->done = done;
+	if (sc->sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
-		struct sock *sk = tcp_conn->sock->sk;
 
-		scmd->done = done;
-		/* FIXME: too hacky */
-		bh_lock_sock(sk);
+		if (!ctask->unsol_count && !ctask->imm_count)
+			iscsi_cmd_data_done(ctask);
 
-		if (tcp_conn->in.ctask == ctask) {
-			clear_bit(ISCSI_SUSPEND_BIT, &ctask->conn->suspend_rx);
-			sk->sk_data_ready(sk, 0);
-		}
-
-		bh_unlock_sock(sk);
+		clear_bit(ISCSI_SUSPEND_BIT, &ctask->conn->suspend_rx);
+		INIT_WORK(&tcp_conn->recvwork, recvworker, ctask->conn);
+		queue_work(recvwq, &tcp_conn->recvwork);
 	} else {
 		tcp_ctask->sg_count = 0;
 		tcp_ctask->data_offset = 0;
-		tcp_ctask->sg = scmd->request_buffer;
-
-		ctask->total_length = min(be32_to_cpu(ctask->hdr->data_length),
-					  scmd->request_bufflen);
-
-		scmd->done = done;
-		__kfifo_put(ctask->conn->xmitqueue, (void*)&ctask, sizeof(void*));
-		scsi_queue_work(shost, &ctask->conn->xmitwork);
+		ctask->unsol_count = sc->bufflen;
+		tcp_ctask->sg = sc->request_buffer;
+		tcp_ctask->xmstate = XMSTATE_UNS_INIT | XMSTATE_UNS_HDR;
+		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
 	}
+	return 0;
+}
 
+static int iscsi_tgt_eh_abort_handler(struct scsi_cmnd *scmd)
+{
+	BUG_ON(1);
 	return 0;
 }
 
-static void data_cmd_rsp_build(struct iscsi_cmd_task *ctask)
+static int iscsi_tcp_tgt_ctask_xmit(struct iscsi_conn *conn,
+				    struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct scsi_cmnd *sc = ctask->sc;
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *) &tcp_ctask->rhdr;
-	u32 left, residual, exp_datalen, size;
+	int err;
 
-	if (!tcp_ctask->data_offset)
-		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
-				  &tcp_ctask->sg[tcp_ctask->sg_count++]);
+	dprintk("%p\n", ctask);
 
-	exp_datalen = be32_to_cpu(ctask->hdr->data_length);
-	left = ctask->total_length;
+	err = iscsi_tcp_ctask_xmit(conn, ctask);
+	if (err)
+		return err;
 
-	dprintk("%p %u %u %u %u %u %u\n", ctask, exp_datalen, left,
-		ctask->total_length,
-		tcp_ctask->sg_count, ctask->conn->max_xmit_dlength, sc->bufflen);
+	dprintk("%p %d\n", ctask, err);
 
-	rhdr->opcode = ISCSI_OP_SCSI_DATA_IN;
-	rhdr->itt = ctask->hdr->itt;
-	rhdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	rhdr->offset = cpu_to_be32(sc->offset + tcp_ctask->data_offset);
-	rhdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
-	rhdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
-	rhdr->max_cmdsn =
-		cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
-	rhdr->datasn = cpu_to_be32(ctask->datasn++);
-
-	if (ctask->total_length <= ctask->conn->max_xmit_dlength) {
-		size = ctask->total_length;
-		if (ctask->total_length + tcp_ctask->sent ==
-		    min(exp_datalen, sc->bufflen)) {
-			rhdr->flags =
-				ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-
-			if (sc->bufflen < exp_datalen) {
-				rhdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-				residual = exp_datalen - sc->bufflen;
-			} else if (sc->bufflen > exp_datalen) {
-				rhdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-				residual = sc->bufflen - exp_datalen;
-			} else
-				residual = 0;
-			rhdr->residual_count = cpu_to_be32(residual);
-		}
-	} else
-		size = ctask->conn->max_xmit_dlength;
-
-	hton24(rhdr->dlength, size);
-	ctask->data_count = size;
-	tcp_ctask->data_offset += size;
-	ctask->total_length -= size;
-}
-
-static void rsp_build(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_session *session = ctask->conn->session;
-
-	ctask->data_count = 0;
-
 	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
-	case ISCSI_OP_SCSI_CMD:
-		if (ctask->total_length)
-			data_cmd_rsp_build(ctask);
-		else {
-			struct iscsi_cmd_rsp *hdr =
-				(struct iscsi_cmd_rsp *) &tcp_ctask->rhdr;
-			hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
-			hdr->itt = ctask->hdr->itt;
-			hdr->flags = ISCSI_FLAG_CMD_FINAL;
-			hdr->response = ISCSI_STATUS_CMD_COMPLETED;
-			hdr->cmd_status = SAM_STAT_GOOD;
-			hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
-			hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
-			hdr->max_cmdsn =
-				cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
-		}
-		break;
 	case ISCSI_OP_LOGOUT:
-	{
-		struct iscsi_logout_rsp *hdr =
-			(struct iscsi_logout_rsp *) &tcp_ctask->rhdr;
-		hdr->opcode = ISCSI_OP_LOGOUT_RSP;
-		hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		hdr->itt = tcp_ctask->hdr.itt;
+		iscsi_tcp_tgt_ctask_cleanup(ctask);
 		break;
+	case ISCSI_OP_SCSI_CMD:
+	{
+		struct iscsi_hdr *hdr =
+			(struct iscsi_hdr *) &tcp_ctask->unsol_dtask.hdr;
+		u8 opcode = hdr->opcode & ISCSI_OPCODE_MASK;
+
+		switch (opcode) {
+		case ISCSI_OP_SCSI_CMD_RSP:
+			iscsi_tcp_tgt_ctask_cleanup(ctask);
+			sc->done(sc);
+			break;
+		case ISCSI_OP_SCSI_DATA_IN:
+			sc->done(sc);
+			break;
+		}
 	}
 	default:
 		break;
 	}
-}
 
-static int
-istgt_tcp_ctask_data_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	int err;
+	dprintk("%p %d\n", ctask, err);
 
-	while (1) {
-		struct iscsi_buf *ibuf = &tcp_ctask->sendbuf;
-		dprintk("%p %p %u %u %u %u\n", ctask, ibuf->sg.page,
-			ibuf->sg.offset,
-			ibuf->sg.length, ctask->data_count, tcp_ctask->sg_count);
-
-		err = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
-				     &ctask->data_count, &tcp_ctask->sent);
-		if (err) {
-			dprintk("%u %u\n", ctask->data_count, tcp_ctask->sent);
-			BUG_ON(err != -EAGAIN);
-			return -EAGAIN;
-		}
-
-		if (!ctask->data_count)
-			break;
-
-		iscsi_buf_init_sg(&tcp_ctask->sendbuf,
-				  &tcp_ctask->sg[tcp_ctask->sg_count++]);
-	}
-
-	return 0;
+	return err;
 }
 
-static int
-istgt_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+static struct iscsi_cls_session *
+iscsi_tcp_tgt_session_create(struct iscsi_transport *iscsit,
+			     struct scsi_transport_template *scsit,
+			     uint32_t initial_cmdsn, uint32_t *hostno)
 {
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct scsi_cmnd *sc = ctask->sc;
-	int err;
+	struct Scsi_Host *shost;
+	struct iscsi_cls_session *cls_session;
+	struct iscsi_session *session;
+	struct istgt_session *istgt_session;
+	int i, err;
 
-	dprintk("%p %x %x %u %u %x\n", ctask,
-		ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], sc->bufflen, sc->request_bufflen,
-		tcp_ctask->xmstate);
-again:
-	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
-		rsp_build(ctask);
-		iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
-				   sizeof(struct iscsi_hdr));
-		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
-		tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
-	}
+	dprintk("%u %u\n", initial_cmdsn, *hostno);
+	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn, hostno);
+	if (!cls_session)
+		return NULL;
+	shost = iscsi_session_to_shost(cls_session);
+	err = scsi_tgt_alloc_queue(shost);
+	if (err)
+		goto session_free;
 
-	if (tcp_ctask->xmstate & XMSTATE_UNS_HDR) {
-		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
-		if (err)
-			return -EAGAIN;
-		else {
-			tcp_ctask->xmstate &= ~XMSTATE_UNS_HDR;
-
-			if (ctask->data_count)
-				tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
-		}
+	session = class_to_transport_session(cls_session);
+	for (i = 0; i < initial_cmdsn; i++) {
+		struct iscsi_cmd_task *ctask = session->cmds[i];
+		INIT_LIST_HEAD(&ctask->hash);
+		INIT_LIST_HEAD(&ctask->pending);
 	}
+	session->exp_cmdsn = initial_cmdsn;
 
-	if (tcp_ctask->xmstate & XMSTATE_UNS_DATA) {
-		err = istgt_tcp_ctask_data_xmit(conn, ctask);
-		if (err)
-			return -EAGAIN;
-		else
-			tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
+	istgt_session =	(struct istgt_session *) cls_session->dd_data;
+	INIT_LIST_HEAD(&istgt_session->cmd_hash);
+	INIT_LIST_HEAD(&istgt_session->cmd_pending);
 
-		if (ctask->total_length) {
-			tcp_ctask->xmstate |= XMSTATE_UNS_INIT;
-			goto again;
-		}
-	}
+	dprintk("%u %u\n", initial_cmdsn, *hostno);
 
-	if (tcp_ctask->xmstate & XMSTATE_W_HDR) {
-		r2t_build(ctask);
-		iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *) &tcp_ctask->rhdr,
-				   sizeof(struct iscsi_hdr));
-		tcp_ctask->xmstate &= ~XMSTATE_W_HDR;
-		tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
-	}
-
-	if (tcp_ctask->xmstate |= XMSTATE_SOL_HDR) {
-		err = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
-		if (err)
-			return -EAGAIN;
-		else
-			tcp_ctask->xmstate &= ~XMSTATE_SOL_HDR;
-	}
-
-	if (tcp_ctask->rhdr.opcode == ISCSI_OP_SCSI_CMD_RSP ||
-	    (tcp_ctask->rhdr.opcode == ISCSI_OP_SCSI_DATA_IN &&
-	     tcp_ctask->rhdr.flags & ISCSI_FLAG_CMD_FINAL)) {
-		spin_lock_bh(&conn->session->lock);
-		if (sc->sc_data_direction == DMA_TO_DEVICE)
-			list_del(&ctask->hash);
-		__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-		iscsi_tcp_cleanup_ctask(ctask->conn, ctask);
-		spin_unlock_bh(&conn->session->lock);
-	}
-
-	if (tcp_ctask->rhdr.opcode != ISCSI_OP_R2T)
-		sc->done(sc);
-
-	return 0;
+	return cls_session;
+session_free:
+	iscsi_session_teardown(cls_session);
+	return NULL;
 }
 
-static int istgt_tcp_eh_abort_handler(struct scsi_cmnd *scmd)
+static struct iscsi_tcp_operations iscsi_tcp_tgt_ops = {
+	.hdr_recv		= iscsi_tcp_tgt_hdr_recv,
+	.data_recv		= iscsi_tcp_tgt_data_recv,
+	.unsolicit_data_init	= iscsi_data_rsp_build,
+};
+
+static struct iscsi_cls_conn *
+iscsi_tcp_tgt_conn_create(struct iscsi_cls_session *cls_session,
+			  uint32_t conn_idx)
 {
-	BUG();
-	return 0;
+	struct iscsi_cls_conn *cls_conn;
+	dprintk("%u\n", conn_idx);
+	cls_conn = iscsi_tcp_conn_create(cls_session, conn_idx,
+					 &iscsi_tcp_tgt_ops);
+	dprintk("%u %p\n", conn_idx, cls_conn->dd_data);
+	return cls_conn;
 }
 
 #define	DEFAULT_NR_QUEUED_CMNDS	32
-#define TGT_NAME "iscsi_tgt_tcp"
+#define TGT_NAME "iscsi_tcp_tgt"
 
-static struct scsi_host_template istgt_tcp_sht = {
+static struct scsi_host_template iscsi_tcp_tgt_sht = {
 	.name			= TGT_NAME,
 	.module			= THIS_MODULE,
 	.can_queue		= DEFAULT_NR_QUEUED_CMNDS,
 	.sg_tablesize		= SG_ALL,
 	.max_sectors		= 65535,
 	.use_clustering		= DISABLE_CLUSTERING,
-	.transfer_response	= istgt_transfer_response,
-	.transfer_data		= istgt_transfer_data,
-	.eh_abort_handler	= istgt_tcp_eh_abort_handler,
+	.transfer_response	= iscsi_tgt_transfer_response,
+	.transfer_data		= iscsi_tgt_transfer_data,
+	.eh_abort_handler	= iscsi_tgt_eh_abort_handler,
 };
 
-static struct iscsi_transport istgt_tcp_transport = {
+static struct iscsi_transport iscsi_tcp_tgt_transport = {
 	.owner			= THIS_MODULE,
 	.name			= TGT_NAME,
-	.host_template		= &istgt_tcp_sht,
+	.host_template		= &iscsi_tcp_tgt_sht,
 	.conndata_size		= sizeof(struct iscsi_conn),
 	.sessiondata_size	= sizeof(struct istgt_session),
 	.max_conn		= 1,
 	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
-	.create_session		= istgt_tcp_session_create,
+	.create_session		= iscsi_tcp_tgt_session_create,
 	.destroy_session	= iscsi_tcp_session_destroy,
-	.create_conn		= iscsi_tcp_conn_create,
+	.create_conn		= iscsi_tcp_tgt_conn_create,
 	.destroy_conn		= iscsi_tcp_conn_destroy,
-	.bind_conn		= istgt_tcp_conn_bind,
+	.bind_conn		= iscsi_tcp_conn_bind,
 	.start_conn		= iscsi_conn_start,
-	.set_param		= iscsi_conn_set_param,
+	.set_param		= iscsi_tcp_conn_set_param,
 	.terminate_conn		= iscsi_tcp_terminate_conn,
-	.xmit_cmd_task		= istgt_tcp_ctask_xmit,
+	.xmit_cmd_task		= iscsi_tcp_tgt_ctask_xmit,
 };
 
-static int __init istgt_tcp_init(void)
+static int __init iscsi_tcp_tgt_init(void)
 {
-	int err;
 	printk("iSCSI Target over TCP\n");
 
-	err = iscsi_tcp_init();
-	if (err)
-		return err;
+	recvwq = create_workqueue("iscsi_recvwork");
+	if (!recvwq)
+		return -ENOMEM;
 
-	if (!iscsi_register_transport(&istgt_tcp_transport))
-		goto call_iscsi_tcp_exit;
-	return 0;
+	if (!iscsi_register_transport(&iscsi_tcp_tgt_transport))
+		goto destroy_wq;
 
-call_iscsi_tcp_exit:
-	iscsi_tcp_exit();
-	return -ENOMEM;
+	return 0;
+destroy_wq:
+	destroy_workqueue(recvwq);
+	return -ENODEV;
 }
 
-static void __exit istgt_tcp_exit(void)
+static void __exit iscsi_tcp_tgt_exit(void)
 {
-	iscsi_tcp_exit();
-	iscsi_unregister_transport(&istgt_tcp_transport);
+	destroy_workqueue(recvwq);
+	iscsi_unregister_transport(&iscsi_tcp_tgt_transport);
 }
 
-module_init(istgt_tcp_init);
-module_exit(istgt_tcp_exit);
+module_init(iscsi_tcp_tgt_init);
+module_exit(iscsi_tcp_tgt_exit);
 
-MODULE_DESCRIPTION("iSCSI target over TCP");
+MODULE_DESCRIPTION("iSCSI/TCP target");
 MODULE_LICENSE("GPL");

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-05-22 16:03:36 UTC (rev 479)
@@ -235,8 +235,8 @@
 
 		if (datalen < 2) {
 invalid_datalen:
-			printk(KERN_ERR "iscsi: Got CHECK_CONDITION but invalid "
-			       "data buffer size of %d\n", datalen);
+			printk(KERN_ERR "iscsi: Got CHECK_CONDITION but "
+			       "invalid data buffer size of %d\n", datalen);
 			sc->result = DID_BAD_TARGET << 16;
 			goto out;
 		}
@@ -1042,8 +1042,8 @@
 
 	/* what should we do here ? */
 	if (conn->ctask == ctask) {
-		printk(KERN_INFO "iscsi: sc %p itt 0x%x partially sent. Failing "
-		       "abort\n", sc, ctask->itt);
+		printk(KERN_INFO "iscsi: sc %p itt 0x%x partially sent. "
+		       "Failing abort\n", sc, ctask->itt);
 		goto failed;
 	}
 
@@ -1054,7 +1054,7 @@
 		if (list_empty(&pending_ctask->running)) {
 			debug_scsi("found pending task\n");
 			goto success;
-		} else 
+		} else
 			__kfifo_put(conn->xmitqueue, (void*)&pending_ctask,
 				    sizeof(void*));
 	}
@@ -1098,7 +1098,7 @@
 	write_unlock_bh(conn->recv_lock);
 
 	mutex_unlock(&conn->xmitmutex);
-	return SUCCESS;	
+	return SUCCESS;
 
 failed:
 	spin_unlock_bh(&session->lock);
@@ -1258,15 +1258,6 @@
 		if (mgmt_task_size)
 			mtask->dd_data = &mtask[1];
 		mtask->itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
-		mtask->data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH,
-				     GFP_KERNEL);
-		if (!mtask->data) {
-			int j;
-
-			for (j = 0; j < cmd_i; j++)
-				kfree(session->mgmt_cmds[j]->data);
-			goto immdata_alloc_fail;
-		}
 	}
 
 	if (scsi_add_host(shost, NULL))
@@ -1282,9 +1273,6 @@
 cls_session_fail:
 	scsi_remove_host(shost);
 add_host_fail:
-	for (cmd_i = 0; cmd_i < session->mgmtpool_max; cmd_i++)
-		kfree(session->mgmt_cmds[cmd_i]->data);
-immdata_alloc_fail:
 	iscsi_pool_free(&session->mgmtpool, (void**)session->mgmt_cmds);
 mgmtpool_alloc_fail:
 	iscsi_pool_free(&session->cmdpool, (void**)session->cmds);
@@ -1305,13 +1293,9 @@
 {
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
-	int cmd_i;
 
 	scsi_remove_host(shost);
 
-	for (cmd_i = 0; cmd_i < session->mgmtpool_max; cmd_i++)
-		kfree(session->mgmt_cmds[cmd_i]->data);
-
 	iscsi_pool_free(&session->mgmtpool, (void**)session->mgmt_cmds);
 	iscsi_pool_free(&session->cmdpool, (void**)session->cmds);
 
@@ -1331,6 +1315,7 @@
 	struct iscsi_session *session = class_to_transport_session(cls_session);
 	struct iscsi_conn *conn;
 	struct iscsi_cls_conn *cls_conn;
+	char *data;
 
 	cls_conn = iscsi_create_conn(cls_session, conn_idx);
 	if (!cls_conn)
@@ -1376,12 +1361,20 @@
 	}
 	spin_unlock_bh(&session->lock);
 
+	data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH, GFP_KERNEL);
+	if (!data)
+		goto login_mtask_data_alloc_fail;
+	conn->login_mtask->data = data;
+
 	init_timer(&conn->tmabort_timer);
 	mutex_init(&conn->xmitmutex);
 	init_waitqueue_head(&conn->ehwait);
 
 	return cls_conn;
 
+login_mtask_data_alloc_fail:
+	__kfifo_put(session->mgmtpool.queue, (void*)&conn->login_mtask,
+		    sizeof(void*));
 login_mtask_alloc_fail:
 	kfifo_free(conn->mgmtqueue);
 mgmtqueue_alloc_fail:
@@ -1441,8 +1434,9 @@
 		}
 		spin_unlock_irqrestore(session->host->host_lock, flags);
 		msleep_interruptible(500);
-		printk(KERN_INFO "iscsi: scsi conn_destroy(): host_busy %d host_failed %d\n",
-			session->host->host_busy, session->host->host_failed);
+		printk(KERN_INFO "iscsi: scsi conn_destroy(): host_busy %d "
+		       "host_failed %d\n", session->host->host_busy,
+		       session->host->host_failed);
 		/*
 		 * force eh_abort() to unblock
 		 */
@@ -1450,6 +1444,7 @@
 	}
 
 	spin_lock_bh(&session->lock);
+	kfree(conn->login_mtask->data);
 	__kfifo_put(session->mgmtpool.queue, (void*)&conn->login_mtask,
 		    sizeof(void*));
 	list_del(&conn->item);
@@ -1486,6 +1481,8 @@
 	conn->c_stage = ISCSI_CONN_STARTED;
 	session->state = ISCSI_STATE_LOGGED_IN;
 
+	printk("%s(%d) %x\n", __FUNCTION__, __LINE__, conn->stop_stage);
+
 	switch(conn->stop_stage) {
 	case STOP_CONN_RECOVER:
 		/*
@@ -1516,6 +1513,8 @@
 	}
 	spin_unlock_bh(&session->lock);
 
+	printk("%s(%d) %x\n", __FUNCTION__, __LINE__, conn->stop_stage);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_start);
@@ -1554,7 +1553,7 @@
 {
 	struct iscsi_cmd_task *ctask, *tmp;
 
-	/* flush pending */	
+	/* flush pending */
 	while (__kfifo_get(conn->xmitqueue, (void*)&ctask, sizeof(void*))) {
 		debug_scsi("failing pending sc %p itt 0x%x\n", ctask->sc,
 			   ctask->itt);

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-22 16:03:36 UTC (rev 479)
@@ -39,7 +39,7 @@
 struct iscsi_session;
 struct iscsi_nopin;
 
-/* #define DEBUG_SCSI */
+#define DEBUG_SCSI
 #ifdef DEBUG_SCSI
 #define debug_scsi(fmt...) printk(KERN_INFO "iscsi: " fmt)
 #else
@@ -103,9 +103,8 @@
 
 	struct list_head	running;	/* running cmd list */
 	void			*dd_data;	/* driver/transport data */
-
 	struct list_head	hash;
-	struct list_head	tgtlist;
+	struct list_head	pending;
 };
 
 struct iscsi_conn {
@@ -140,6 +139,7 @@
 	struct kfifo		*xmitqueue;	/* data-path cmd queue */
 	struct list_head	run_list;	/* list of cmds in progress */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
+
 	/*
 	 * serializes connection xmit, access to kfifos:
 	 * xmitqueue, immqueue, mgmtqueue
@@ -174,7 +174,6 @@
 
 	/* custom statistics */
 	uint32_t		eh_abort_cnt;
-	struct work_struct	tcpwork;
 };
 
 struct iscsi_queue {

Modified: branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c	2006-05-22 16:03:36 UTC (rev 479)
@@ -36,6 +36,7 @@
 #define ISCSI_HOST_ATTRS 0
 
 struct iscsi_internal {
+	int daemon_pid;
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
 	struct list_head list;
@@ -145,7 +146,6 @@
 			       NULL);
 
 static struct sock *nls;
-static int daemon_pid;
 static DEFINE_MUTEX(rx_queue_mutex);
 
 struct mempool_zone {
@@ -266,8 +266,8 @@
 {
 	struct iscsi_cls_session *session = data;
 
-	dev_printk(KERN_INFO, &session->dev, "iscsi: session recovery timed out "
-		  "after %d secs\n", session->recovery_tmo);
+	dev_printk(KERN_INFO, &session->dev, "iscsi: session recovery timed "
+		  "out after %d secs\n", session->recovery_tmo);
 
 	if (session->transport->session_recovery_timedout)
 		session->transport->session_recovery_timedout(session);
@@ -497,7 +497,7 @@
 }
 
 static void*
-mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
+mempool_zone_alloc_skb(gfp_t gfp_mask, void *pool_data)
 {
 	struct mempool_zone *zone = pool_data;
 
@@ -572,13 +572,13 @@
 }
 
 static int
-iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb)
+iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb, int pid)
 {
 	unsigned long flags;
 	int rc;
 
 	skb_get(skb);
-	rc = netlink_unicast(nls, skb, daemon_pid, MSG_DONTWAIT);
+	rc = netlink_unicast(nls, skb, pid, MSG_DONTWAIT);
 	if (rc < 0) {
 		mempool_free(skb, zone->pool);
 		printk(KERN_ERR "iscsi: can not unicast skb (%d)\n", rc);
@@ -600,9 +600,14 @@
 	struct sk_buff *skb;
 	struct iscsi_uevent *ev;
 	char *pdu;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +
 			      data_size);
 
+	priv = iscsi_if_transport_lookup(conn->transport);
+	if (!priv)
+		return -EINVAL;
+
 	mempool_zone_complete(conn->z_pdu);
 
 	skb = mempool_zone_get_skb(conn->z_pdu);
@@ -613,7 +618,7 @@
 		return -ENOMEM;
 	}
 
-	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	nlh = __nlmsg_put(skb, priv->daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 	ev->transport_handle = iscsi_handle(conn->transport);
@@ -626,7 +631,7 @@
 	memcpy(pdu, hdr, sizeof(struct iscsi_hdr));
 	memcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);
 
-	return iscsi_unicast_skb(conn->z_pdu, skb);
+	return iscsi_unicast_skb(conn->z_pdu, skb, priv->daemon_pid);
 }
 EXPORT_SYMBOL_GPL(iscsi_recv_pdu);
 
@@ -635,8 +640,13 @@
 	struct nlmsghdr	*nlh;
 	struct sk_buff	*skb;
 	struct iscsi_uevent *ev;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev));
 
+	priv = iscsi_if_transport_lookup(conn->transport);
+	if (!priv)
+		return;
+
 	mempool_zone_complete(conn->z_error);
 
 	skb = mempool_zone_get_skb(conn->z_error);
@@ -646,7 +656,7 @@
 		return;
 	}
 
-	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	nlh = __nlmsg_put(skb, priv->daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
 	ev = NLMSG_DATA(nlh);
 	ev->transport_handle = iscsi_handle(conn->transport);
 	ev->type = ISCSI_KEVENT_CONN_ERROR;
@@ -656,7 +666,7 @@
 	ev->r.connerror.cid = conn->cid;
 	ev->r.connerror.sid = iscsi_conn_get_sid(conn);
 
-	iscsi_unicast_skb(conn->z_error, skb);
+	iscsi_unicast_skb(conn->z_error, skb, priv->daemon_pid);
 
 	dev_printk(KERN_INFO, &conn->dev, "iscsi: detected conn error (%d)\n",
 		   error);
@@ -686,7 +696,7 @@
 	nlh = __nlmsg_put(skb, pid, seq, t, (len - sizeof(*nlh)), 0);
 	nlh->nlmsg_flags = flags;
 	memcpy(NLMSG_DATA(nlh), payload, size);
-	return iscsi_unicast_skb(z_reply, skb);
+	return iscsi_unicast_skb(z_reply, skb, pid);
 }
 
 static int
@@ -698,12 +708,17 @@
 	struct iscsi_cls_conn *conn;
 	struct nlmsghdr	*nlhstat;
 	struct iscsi_uevent *evstat;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev) +
 			      sizeof(struct iscsi_stats) +
 			      sizeof(struct iscsi_stats_custom) *
 			      ISCSI_STATS_CUSTOM_MAX);
 	int err = 0;
 
+	priv = iscsi_if_transport_lookup(transport);
+	if (!priv)
+		return -EINVAL;
+
 	conn = iscsi_conn_lookup(ev->u.get_stats.sid, ev->u.get_stats.cid);
 	if (!conn)
 		return -EEXIST;
@@ -720,7 +735,7 @@
 			return -ENOMEM;
 		}
 
-		nlhstat = __nlmsg_put(skbstat, daemon_pid, 0, 0,
+		nlhstat = __nlmsg_put(skbstat, priv->daemon_pid, 0, 0,
 				      (len - sizeof(*nlhstat)), 0);
 		evstat = NLMSG_DATA(nlhstat);
 		memset(evstat, 0, sizeof(*evstat));
@@ -746,7 +761,7 @@
 		skb_trim(skbstat, NLMSG_ALIGN(actual_size));
 		nlhstat->nlmsg_len = actual_size;
 
-		err = iscsi_unicast_skb(conn->z_pdu, skbstat);
+		err = iscsi_unicast_skb(conn->z_pdu, skbstat, priv->daemon_pid);
 	} while (err < 0 && err != -ECONNREFUSED);
 
 	return err;
@@ -981,6 +996,8 @@
 	if (!try_module_get(transport->owner))
 		return -EINVAL;
 
+	priv->daemon_pid = NETLINK_CREDS(skb)->pid;
+
 	switch (nlh->nlmsg_type) {
 	case ISCSI_UEVENT_CREATE_SESSION:
 		err = iscsi_if_create_session(priv, ev);
@@ -1073,7 +1090,6 @@
 			skb_pull(skb, skb->len);
 			goto free_skb;
 		}
-		daemon_pid = NETLINK_CREDS(skb)->pid;
 
 		while (skb->len >= NLMSG_SPACE(0)) {
 			int err;
@@ -1230,7 +1246,7 @@
  * be present in the iscsi_transport/LLD driver becuase userspace handles
  * login (and failback for login redirect) so for these type of drivers
  * the class manages the attrs and values for the iscsi_transport/LLD
- */ 
+ */
 #define iscsi_priv_session_attr_show(field, format)			\
 static ssize_t								\
 show_priv_session_##field(struct class_device *cdev, char *buf)	\

Modified: branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-05-22 16:03:36 UTC (rev 479)
@@ -117,7 +117,7 @@
 	void (*cleanup_cmd_task) (struct iscsi_conn *conn,
 				  struct iscsi_cmd_task *ctask);
 	int (*xmit_mgmt_task) (struct iscsi_conn *conn,
-			       struct iscsi_mgmt_task *mtask); 
+			       struct iscsi_mgmt_task *mtask);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 	int (*ep_connect) (struct sockaddr *dst_addr, int non_blocking,
 			   uint64_t *ep_handle);

Modified: branches/use-scsi-ml/istgt/usr/netlink.c
===================================================================
--- branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-20 14:24:08 UTC (rev 478)
+++ branches/use-scsi-ml/istgt/usr/netlink.c	2006-05-22 16:03:36 UTC (rev 479)
@@ -330,7 +330,7 @@
 	int fd, err;
 	char buf[64];
 
-	fd = open("/sys/class/iscsi_transport/iscsi_tgt_tcp/handle", O_RDONLY);
+	fd = open("/sys/class/iscsi_transport/iscsi_tcp_tgt/handle", O_RDONLY);
 	if (fd < 0)
 		return fd;
 	err = read(fd, buf, sizeof(buf));



From tomo at berlios.de  Mon May 22 18:10:39 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 22 May 2006 18:10:39 +0200
Subject: [Stgt-svn] r480 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605221610.k4MGAdCw018940@sheep.berlios.de>

Author: tomo
Date: 2006-05-22 18:10:38 +0200 (Mon, 22 May 2006)
New Revision: 480

Removed:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
Log:
Kill unused iscsi_tcp_priv.h

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-22 16:03:36 UTC (rev 479)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_priv.h	2006-05-22 16:10:38 UTC (rev 480)
@@ -1,46 +0,0 @@
-/*
- * makeshift to use iscsi_tcp.c like library
- */
-
-extern struct iscsi_cls_conn *
-iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx);
-extern void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn);
-extern int iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
-			       struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
-			       int is_leading);
-extern void iscsi_tcp_terminate_conn(struct iscsi_conn *conn);
-
-extern struct iscsi_cls_session *
-iscsi_tcp_session_create(struct iscsi_transport *iscsit,
-			 struct scsi_transport_template *scsit,
-			 uint32_t initial_cmdsn, uint32_t *hostno);
-extern void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session);
-
-extern int iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn);
-extern int iscsi_scsi_data_in(struct iscsi_conn *conn);
-
-extern int iscsi_tcp_hdr_recv_pre(struct iscsi_conn *conn);
-extern int iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
-			       unsigned int offset, size_t len);
-
-extern void
-iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size);
-extern void
-iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg);
-
-extern int
-iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen);
-extern int
-iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
-	       int *count, int *sent);
-
-extern void iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask);
-
-extern int
-iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
-		     uint32_t value);
-
-extern int __iscsi_scsi_data_in(struct iscsi_conn *conn);
-
-extern int iscsi_tcp_init(void);
-extern void iscsi_tcp_exit(void);



From tomo at berlios.de  Mon May 22 18:13:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 22 May 2006 18:13:48 +0200
Subject: [Stgt-svn] r481 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605221613.k4MGDmZn019335@sheep.berlios.de>

Author: tomo
Date: 2006-05-22 18:13:47 +0200 (Mon, 22 May 2006)
New Revision: 481

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Rename iscsi_conn_set_param and kill some debug code.


Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:10:38 UTC (rev 480)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:13:47 UTC (rev 481)
@@ -48,7 +48,7 @@
 MODULE_DESCRIPTION("iSCSI/TCP data-path");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0:4.445");
-#define DEBUG_TCP
+/* #define DEBUG_TCP */
 #define DEBUG_ASSERT
 
 #ifdef DEBUG_TCP
@@ -1989,9 +1989,6 @@
 	struct socket *sock;
 	int err;
 
-	printk("%s(%d) %llu %d\n", __FUNCTION__, __LINE__,
-	       (unsigned long long) transport_eph, is_leading);
-
 	/* lookup for existing socket */
 	sock = sockfd_lookup((int)transport_eph, &err);
 	if (!sock) {
@@ -2003,9 +2000,6 @@
 	if (err)
 		return err;
 
-	printk("%s(%d) %llu %d %d\n", __FUNCTION__, __LINE__,
-	       (unsigned long long) transport_eph, is_leading, conn->stop_stage);
-
 	if (conn->stop_stage != STOP_CONN_SUSPEND) {
 		/* bind iSCSI connection and socket */
 		tcp_conn->sock = sock;
@@ -2031,8 +2025,6 @@
 		tcp_conn->in_progress = IN_PROGRESS_WAIT_HEADER;
 	}
 
-	printk("%s(%d) %llu %d\n", __FUNCTION__, __LINE__,
-	       (unsigned long long) transport_eph, is_leading);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_conn_bind);
@@ -2164,8 +2156,8 @@
 	}
 }
 
-int iscsi_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
-			     uint32_t value)
+int iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
+			 uint32_t value)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_session *session = conn->session;
@@ -2303,7 +2295,7 @@
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(iscsi_tcp_conn_set_param);
+EXPORT_SYMBOL_GPL(iscsi_conn_set_param);
 
 static int
 iscsi_session_get_param(struct iscsi_cls_session *cls_session,
@@ -2551,7 +2543,7 @@
 	.create_conn		= iscsi_tcp_initiator_conn_create,
 	.bind_conn		= iscsi_tcp_conn_bind,
 	.destroy_conn		= iscsi_tcp_conn_destroy,
-	.set_param		= iscsi_tcp_conn_set_param,
+	.set_param		= iscsi_conn_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
 	.get_conn_str_param	= iscsi_conn_get_str_param,
 	.get_session_param	= iscsi_session_get_param,

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-22 16:10:38 UTC (rev 480)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-05-22 16:13:47 UTC (rev 481)
@@ -198,8 +198,8 @@
 extern int iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 			       struct iscsi_cls_conn *cls_conn,
 			       uint64_t transport_eph, int is_leading);
-extern int iscsi_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn,
-				    enum iscsi_param param, uint32_t value);
+extern int iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn,
+				enum iscsi_param param, uint32_t value);
 extern void iscsi_tcp_terminate_conn(struct iscsi_conn *conn);
 
 extern int iscsi_tcp_ctask_xmit(struct iscsi_conn *conn,

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-22 16:10:38 UTC (rev 480)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-05-22 16:13:47 UTC (rev 481)
@@ -735,7 +735,7 @@
 	.destroy_conn		= iscsi_tcp_conn_destroy,
 	.bind_conn		= iscsi_tcp_conn_bind,
 	.start_conn		= iscsi_conn_start,
-	.set_param		= iscsi_tcp_conn_set_param,
+	.set_param		= iscsi_conn_set_param,
 	.terminate_conn		= iscsi_tcp_terminate_conn,
 	.xmit_cmd_task		= iscsi_tcp_tgt_ctask_xmit,
 };



From tomo at berlios.de  Mon May 22 18:17:16 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 22 May 2006 18:17:16 +0200
Subject: [Stgt-svn] r482 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605221617.k4MGHGFN019688@sheep.berlios.de>

Author: tomo
Date: 2006-05-22 18:17:16 +0200 (Mon, 22 May 2006)
New Revision: 482

Modified:
   branches/use-scsi-ml/istgt/kernel/libiscsi.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
Log:
Kill some debug code.

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-05-22 16:13:47 UTC (rev 481)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-05-22 16:17:16 UTC (rev 482)
@@ -1481,8 +1481,6 @@
 	conn->c_stage = ISCSI_CONN_STARTED;
 	session->state = ISCSI_STATE_LOGGED_IN;
 
-	printk("%s(%d) %x\n", __FUNCTION__, __LINE__, conn->stop_stage);
-
 	switch(conn->stop_stage) {
 	case STOP_CONN_RECOVER:
 		/*
@@ -1513,8 +1511,6 @@
 	}
 	spin_unlock_bh(&session->lock);
 
-	printk("%s(%d) %x\n", __FUNCTION__, __LINE__, conn->stop_stage);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_start);

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-22 16:13:47 UTC (rev 481)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-22 16:17:16 UTC (rev 482)
@@ -39,7 +39,7 @@
 struct iscsi_session;
 struct iscsi_nopin;
 
-#define DEBUG_SCSI
+/* #define DEBUG_SCSI */
 #ifdef DEBUG_SCSI
 #define debug_scsi(fmt...) printk(KERN_INFO "iscsi: " fmt)
 #else
@@ -139,7 +139,6 @@
 	struct kfifo		*xmitqueue;	/* data-path cmd queue */
 	struct list_head	run_list;	/* list of cmds in progress */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
-
 	/*
 	 * serializes connection xmit, access to kfifos:
 	 * xmitqueue, immqueue, mgmtqueue



From tomo at berlios.de  Mon May 22 18:19:15 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 22 May 2006 18:19:15 +0200
Subject: [Stgt-svn] r483 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200605221619.k4MGJFmf019828@sheep.berlios.de>

Author: tomo
Date: 2006-05-22 18:19:14 +0200 (Mon, 22 May 2006)
New Revision: 483

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
Log:
Minor cleanup.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:17:16 UTC (rev 482)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:19:14 UTC (rev 483)
@@ -762,11 +762,10 @@
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
-	struct scsi_cmnd *sc = ctask->sc;
 
 	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
 		debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-			   (long)sc, sc->result, ctask->itt);
+			   (long)cask->sc, ctask->sc->result, ctask->itt);
 		spin_lock(&conn->session->lock);
 		__iscsi_ctask_cleanup(conn, ctask);
 		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);



