From tomo at mail.berlios.de  Wed Aug  2 07:18:32 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 2 Aug 2006 07:18:32 +0200
Subject: [Stgt-svn] r515 - trunk/usr
Message-ID: <200608020518.k725IWbS018312@sheep.berlios.de>

Author: tomo
Date: 2006-08-02 07:18:25 +0200 (Wed, 02 Aug 2006)
New Revision: 515

Modified:
   trunk/usr/target.c
   trunk/usr/tgtd.c
Log:
Add regular file support to tgtd.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-07-27 12:43:39 UTC (rev 514)
+++ trunk/usr/target.c	2006-08-02 05:18:25 UTC (rev 515)
@@ -30,6 +30,7 @@
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
+#include <sys/stat.h>
 
 #include <linux/fs.h>
 #define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
@@ -223,6 +224,7 @@
 {
 	struct target *target;
 	struct tgt_device *device;
+	struct stat64 st;
 	int err, dev_fd;
 	uint64_t size;
 
@@ -240,16 +242,29 @@
 
 	dev_fd = open(path, O_RDWR | O_LARGEFILE);
 	if (dev_fd < 0) {
-		eprintf("Could not open %s errno %d\n", path, errno);
+		eprintf("Could not open %s %s\n", path, strerror(errno));
 		return dev_fd;
 	}
 
-	err = ioctl(dev_fd, BLKGETSIZE64, &size);
+	err = fstat64(dev_fd, &st);
 	if (err < 0) {
-		eprintf("Cannot get size %d\n", dev_fd);
-		return err;
+		printf("Cannot get stat %d %s\n", dev_fd, strerror(errno));
+		goto close_dev_fd;
 	}
 
+	if (S_ISREG(st.st_mode))
+		size = st.st_size;
+	else if(S_ISBLK(st.st_mode)) {
+		err = ioctl(dev_fd, BLKGETSIZE64, &size);
+		if (err < 0) {
+			eprintf("Cannot get size %s\n", strerror(errno));
+			goto close_dev_fd;
+		}
+	} else {
+		eprintf("Cannot use this mode %x\n", st.st_mode);
+		goto close_dev_fd;
+	}
+
 	if (dev_id >= target->max_device)
 		resize_device_table(target, dev_id);
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-27 12:43:39 UTC (rev 514)
+++ trunk/usr/tgtd.c	2006-08-02 05:18:25 UTC (rev 515)
@@ -240,7 +240,7 @@
 	while ((ch = getopt_long(argc, argv, "l:fd:vh", long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
-		case 'p':
+		case 'l':
 			nr_lld = lld_init(optarg, &nr_pfd);
 			break;
 		case 'f':



From tomo at mail.berlios.de  Sat Aug  5 09:04:49 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 5 Aug 2006 09:04:49 +0200
Subject: [Stgt-svn] r516 - trunk/usr/iscsi
Message-ID: <200608050704.k7574nso006455@sheep.berlios.de>

Author: tomo
Date: 2006-08-05 09:04:32 +0200 (Sat, 05 Aug 2006)
New Revision: 516

Removed:
   trunk/usr/iscsi/misc.h
Modified:
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
Log:
Replace iscsi's list structure with the standard one.


Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-08-02 05:18:25 UTC (rev 515)
+++ trunk/usr/iscsi/conn.c	2006-08-05 07:04:32 UTC (rev 516)
@@ -26,7 +26,7 @@
 	}
 
 	conn->session = session;
-	insque(&conn->clist, &session->conn_list);
+	list_add(&conn->clist, &session->conn_list);
 }
 
 struct connection *conn_alloc(void)
@@ -47,7 +47,7 @@
 
 void conn_free(struct connection *conn)
 {
-	remque(&conn->clist);
+	list_del(&conn->clist);
 	free(conn->initiator);
 	free(conn);
 }

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-08-02 05:18:25 UTC (rev 515)
+++ trunk/usr/iscsi/iscsid.h	2006-08-05 07:04:32 UTC (rev 516)
@@ -7,13 +7,12 @@
 #ifndef ISCSID_H
 #define ISCSID_H
 
-#include <search.h>
 #include <sys/types.h>
 #include <linux/types.h>
 
 #include "types.h"
 #include "iscsi_if.h"
-#include "misc.h"
+#include "list.h"
 #include "param.h"
 #include "log.h"
 
@@ -50,8 +49,8 @@
 #define KEY_STATE_DONE		2
 
 struct session {
-	struct qelem slist;
-	struct qelem hlist;
+	struct list_head slist;
+	struct list_head hlist;
 
 	char *initiator;
 	struct target *target;
@@ -62,7 +61,7 @@
 	uint32_t ksid;
 	uint32_t hostno;
 
-	struct qelem conn_list;
+	struct list_head conn_list;
 	int conn_cnt;
 };
 
@@ -71,7 +70,7 @@
 	int iostate;
 	int fd;
 
-	struct qelem clist;
+	struct list_head clist;
 	struct session *session;
 
 	int tid;
@@ -152,9 +151,9 @@
 #define INCOMING_BUFSIZE	8192
 
 struct target {
-	struct qelem tlist;
+	struct list_head tlist;
 
-	struct qelem sessions_list;
+	struct list_head sessions_list;
 
 	int tid;
 	char name[ISCSI_NAME_LEN];

Deleted: trunk/usr/iscsi/misc.h
===================================================================
--- trunk/usr/iscsi/misc.h	2006-08-02 05:18:25 UTC (rev 515)
+++ trunk/usr/iscsi/misc.h	2006-08-05 07:04:32 UTC (rev 516)
@@ -1,45 +0,0 @@
-/*
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef MISC_H
-#define MISC_H
-
-struct qelem {
-	struct qelem *q_forw;
-	struct qelem *q_back;
-};
-
-/* stolen list stuff from Linux kernel */
-
-#undef offsetof
-#ifdef __compiler_offsetof
-#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
-#else
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-#endif
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
-} while (0)
-
-static inline int list_empty(const struct qelem *head)
-{
-	return head->q_forw == head;
-}
-
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-#define list_entry(ptr, type, member) \
-	container_of(ptr, type, member)
-
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
-	     &pos->member != (head); 	\
-	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
-
-#endif

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-08-02 05:18:25 UTC (rev 515)
+++ trunk/usr/iscsi/session.c	2006-08-05 07:04:32 UTC (rev 516)
@@ -16,7 +16,7 @@
 
 #include "iscsid.h"
 
-struct qelem sessions_list = LIST_HEAD_INIT(sessions_list);
+static LIST_HEAD(sessions_list);
 
 static struct session *session_alloc(int tid)
 {
@@ -31,7 +31,7 @@
 
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
-	insque(&session->slist, &target->sessions_list);
+	list_add(&session->slist, &target->sessions_list);
 
 	INIT_LIST_HEAD(&session->conn_list);
 
@@ -115,7 +115,7 @@
 	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
 			   &session->hostno);
 
-	insque(&session->hlist, &sessions_list);
+	list_add(&session->hlist, &sessions_list);
 }
 
 void session_remove(struct session *session)
@@ -131,11 +131,11 @@
 		ki->destroy_session(thandle, session->ksid);
 
 	if (session->target) {
-		remque(&session->slist);
+		list_del(&session->slist);
 /* 		session->target->nr_sessions--; */
 	}
 
-	remque(&session->hlist);
+	list_del(&session->hlist);
 
 	free(session->initiator);
 	free(session);

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-08-02 05:18:25 UTC (rev 515)
+++ trunk/usr/iscsi/target.c	2006-08-05 07:04:32 UTC (rev 516)
@@ -19,7 +19,7 @@
 #include "iscsid.h"
 #include "tgtadm.h"
 
-struct qelem targets_list = LIST_HEAD_INIT(targets_list);
+static LIST_HEAD(targets_list);
 
 void target_list_build(struct connection *conn, char *addr, char *name)
 {
@@ -77,7 +77,7 @@
 		exit(-1);
 	}
 
-	remque(&target->tlist);
+	list_del(&target->tlist);
 
 	free(target);
 
@@ -102,7 +102,7 @@
 	INIT_LIST_HEAD(&target->tlist);
 	INIT_LIST_HEAD(&target->sessions_list);
 	target->tid = tid;
-	insque(&target->tlist, &targets_list);
+	list_add(&target->tlist, &targets_list);
 
 	return 0;
 }



From tomo at mail.berlios.de  Mon Aug  7 16:59:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 7 Aug 2006 16:59:25 +0200
Subject: [Stgt-svn] r517 - trunk/usr
Message-ID: <200608071459.k77ExPA3027612@sheep.berlios.de>

Author: tomo
Date: 2006-08-07 16:59:24 +0200 (Mon, 07 Aug 2006)
New Revision: 517

Modified:
   trunk/usr/Makefile
   trunk/usr/driver.c
   trunk/usr/list.h
   trunk/usr/mgmt.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
   trunk/usr/util.h
Log:
Make chrdev_open() generic cause it is usefule for target driver code (now Xen).


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/Makefile	2006-08-07 14:59:24 UTC (rev 517)
@@ -1,6 +1,6 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o
+TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO

Modified: trunk/usr/driver.c
===================================================================
--- trunk/usr/driver.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/driver.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -3,6 +3,7 @@
 #include <poll.h>
 #include <inttypes.h>
 
+#include "list.h"
 #include "tgtd.h"
 #include "driver.h"
 

Modified: trunk/usr/list.h
===================================================================
--- trunk/usr/list.h	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/list.h	2006-08-07 14:59:24 UTC (rev 517)
@@ -1,3 +1,6 @@
+#ifndef __LIST_H__
+#define __LIST_H__
+
 /* taken from linux kernel */
 
 #undef offsetof
@@ -79,3 +82,5 @@
 	__list_del(entry->prev, entry->next);
 	entry->next = entry->prev = NULL;
 }
+
+#endif

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/mgmt.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -34,6 +34,7 @@
 #include <sys/un.h>
 #include <scsi/scsi_tgt_if.h>
 
+#include "list.h"
 #include "tgtd.h"
 #include "log.h"
 #include "tgtadm.h"

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/scsi.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -24,6 +24,8 @@
 #include <scsi/scsi.h>
 #include <sys/mman.h>
 
+#include "list.h"
+#include "util.h"
 #include "tgtd.h"
 #include "driver.h"
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/target.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -37,6 +37,8 @@
 #include <linux/hash.h>
 #include <scsi/scsi.h>
 
+#include "list.h"
+#include "util.h"
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "driver.h"

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/tgtadm.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -36,6 +36,8 @@
 #include <sys/types.h>
 #include <sys/un.h>
 
+#include "util.h"
+#include "list.h"
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "driver.h"

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/tgtd.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -34,6 +34,7 @@
 #include <sys/signal.h>
 #include <sys/stat.h>
 
+#include "list.h"
 #include "tgtd.h"
 #include "driver.h"
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/tgtd.h	2006-08-07 14:59:24 UTC (rev 517)
@@ -2,7 +2,6 @@
 #define __TARGET_DAEMON_H
 
 #include "log.h"
-#include "util.h"
 #include <scsi/scsi_tgt_if.h>
 
 #define	SCSI_ID_LEN	24

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/tgtif.c	2006-08-07 14:59:24 UTC (rev 517)
@@ -35,6 +35,8 @@
 #include <sys/stat.h>
 #include <scsi/scsi_tgt_if.h>
 
+#include "list.h"
+#include "util.h"
 #include "tgtd.h"
 
 struct uring {
@@ -106,66 +108,16 @@
 	goto retry;
 }
 
-static int ctrdev_open(char *devpath)
-{
-	FILE *f;
-	char devname[256];
-	char buf[256];
-	int devn;
-	int ctlfd;
-
-	f = fopen("/proc/devices", "r");
-	if (!f) {
-		eprintf("Cannot open control path to the driver\n");
-		return -1;
-	}
-
-	devn = 0;
-	while (!feof(f)) {
-		if (!fgets(buf, sizeof (buf), f))
-			break;
-
-		if (sscanf(buf, "%d %s", &devn, devname) != 2)
-			continue;
-
-		if (!strcmp(devname, "tgt"))
-			break;
-
-		devn = 0;
-	}
-
-	fclose(f);
-	if (!devn) {
-		eprintf("cannot find iscsictl in /proc/devices - "
-			"make sure the module is loaded\n");
-		return -1;
-	}
-
-	unlink(devpath);
-	if (mknod(devpath, (S_IFCHR | 0600), (devn << 8))) {
-		eprintf("cannot create %s %s\n", devpath, strerror(errno));
-		return -1;
-	}
-
-	ctlfd = open(devpath, O_RDWR);
-	if (ctlfd < 0) {
-		eprintf("cannot open %s %s\n", devpath, strerror(errno));
-		return -1;
-	}
-
-	return ctlfd;
-}
-
 #define CHRDEV_PATH "/dev/tgt"
 
 int kreq_init(int *ki_fd)
 {
-	int fd, size = TGT_RINGBUF_SIZE;
+	int err, fd, size = TGT_RINGBUF_SIZE;
 	char *buf;
 
-	fd = ctrdev_open(CHRDEV_PATH);
-	if (fd < 0)
-		return fd;
+	err = chrdev_open("tgt", CHRDEV_PATH, 0, &fd);
+	if (err)
+		return err;
 
 	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
 	if (buf == MAP_FAILED) {

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-08-05 07:04:32 UTC (rev 516)
+++ trunk/usr/util.h	2006-08-07 14:59:24 UTC (rev 517)
@@ -1,5 +1,7 @@
+#ifndef __UTIL_H__
+#define __UTIL_H__
+
 #include <sys/user.h>
-#include "list.h"
 
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 
@@ -31,3 +33,6 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
+extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
+
+#endif



From tomo at mail.berlios.de  Thu Aug 10 11:22:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 10 Aug 2006 11:22:10 +0200
Subject: [Stgt-svn] r518 - trunk/usr
Message-ID: <200608100922.k7A9MATP014480@sheep.berlios.de>

Author: tomo
Date: 2006-08-10 11:22:09 +0200 (Thu, 10 Aug 2006)
New Revision: 518

Added:
   trunk/usr/util.c
Log:
Forgot to add util.c


Added: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2006-08-07 14:59:24 UTC (rev 517)
+++ trunk/usr/util.c	2006-08-10 09:22:09 UTC (rev 518)
@@ -0,0 +1,58 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include "log.h"
+
+int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd)
+{
+	FILE *fp;
+	char name[256], buf[256];
+	int err, major;
+
+	fp = fopen("/proc/devices", "r");
+	if (!fp) {
+		eprintf("Cannot open control path to the driver\n");
+		return -1;
+	}
+
+	major = 0;
+	while (!feof(fp)) {
+		if (!fgets(buf, sizeof (buf), fp))
+			break;
+
+		if (sscanf(buf, "%d %s", &major, name) != 2)
+			continue;
+
+		if (!strcmp(name, modname))
+			break;
+		major = 0;
+	}
+	fclose(fp);
+
+	if (!major) {
+		eprintf("cannot find %s in /proc/devices - "
+			"make sure the module is loaded\n", modname);
+		return -1;
+	}
+
+	unlink(devpath);
+	err = mknod(devpath, (S_IFCHR | 0600), (major << 8) | minor);
+	if (err) {
+		eprintf("cannot create %s %s\n", devpath, strerror(errno));
+		return -errno;
+	}
+
+	*fd = open(devpath, O_RDWR);
+	if (*fd < 0) {
+		eprintf("cannot open %s %s\n", devpath, strerror(errno));
+		return -errno;
+	}
+
+	return 0;
+}



From tomo at mail.berlios.de  Sat Aug 12 06:23:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 06:23:33 +0200
Subject: [Stgt-svn] r519 - trunk/usr
Message-ID: <200608120423.k7C4NXoL008783@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 06:23:31 +0200 (Sat, 12 Aug 2006)
New Revision: 519

Modified:
   trunk/usr/target.c
Log:
Make tgt_cmd_queue_init static.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-10 09:22:09 UTC (rev 518)
+++ trunk/usr/target.c	2006-08-12 04:23:31 UTC (rev 519)
@@ -215,7 +215,7 @@
 	list_add(&dev->dlist, pos);
 }
 
-void tgt_cmd_queue_init(struct tgt_cmd_queue *q)
+static void tgt_cmd_queue_init(struct tgt_cmd_queue *q)
 {
 	q->active_cmd = 0;
 	q->state = 0;



From tomo at mail.berlios.de  Sat Aug 12 07:54:58 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 07:54:58 +0200
Subject: [Stgt-svn] r520 - trunk/usr
Message-ID: <200608120554.k7C5swgX031846@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 07:54:53 +0200 (Sat, 12 Aug 2006)
New Revision: 520

Added:
   trunk/usr/target.h
Modified:
   trunk/usr/target.c
Log:
Create target.h

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 04:23:31 UTC (rev 519)
+++ trunk/usr/target.c	2006-08-12 05:54:53 UTC (rev 520)
@@ -42,113 +42,11 @@
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "driver.h"
+#include "target.h"
 
-/* better if we can include the followings in kernel header files. */
-#define	MSG_SIMPLE_TAG	0x20
-#define	MSG_HEAD_TAG	0x21
-#define	MSG_ORDERED_TAG	0x22
-
-#define	MAX_NR_TARGET		1024
-#define	MAX_NR_HOST		1024
-#define	DEFAULT_NR_DEVICE	64
-#define	MAX_NR_DEVICE		(1 << 20)
-
-#define	HASH_ORDER	4
-#define	cmd_hashfn(cid)	hash_long((cid), HASH_ORDER)
-
-enum {
-	TGT_QUEUE_BLOCKED,
-	TGT_QUEUE_DELETED,
-};
-
-enum {
-	TGT_CMD_QUEUED,
-	TGT_CMD_PROCESSED,
-};
-
-struct mgmt_req {
-	uint64_t mid;
-	int busy;
-	int function;
-};
-
-struct cmd {
-	struct list_head hlist;
-	struct list_head qlist;
-	struct list_head clist;
-	uint32_t cid;
-	uint64_t uaddr;
-	uint32_t len;
-	int mmapped;
-	struct tgt_device *dev;
-	unsigned long state;
-
-	/* Kill the followings when we use shared memory instead of netlink. */
-	int hostno;
-	uint32_t data_len;
-	uint8_t scb[16];
-	uint8_t lun[8];
-	int attribute;
-	uint64_t tag;
-	struct mgmt_req *mreq;
-};
-
-struct target {
-	int tid;
-	int lid;
-
-	uint64_t max_device;
-	struct tgt_device **devt;
-	struct list_head device_list;
-
-	struct list_head cmd_hash_list[1 << HASH_ORDER];
-	struct list_head cmd_list;
-	struct tgt_cmd_queue cmd_queue;
-};
-
 static struct target *tgtt[MAX_NR_TARGET];
 static struct target *hostt[MAX_NR_HOST];
 
-#define QUEUE_FNS(bit, name)						\
-static inline void set_queue_##name(struct tgt_cmd_queue *q)		\
-{									\
-	(q)->state |= (1UL << TGT_QUEUE_##bit);				\
-}									\
-static inline void clear_queue_##name(struct tgt_cmd_queue *q)		\
-{									\
-	(q)->state &= ~(1UL << TGT_QUEUE_##bit);			\
-}									\
-static inline int queue_##name(const struct tgt_cmd_queue *q)		\
-{									\
-	return ((q)->state & (1UL << TGT_QUEUE_##bit));			\
-}
-
-static inline int queue_active(const struct tgt_cmd_queue *q)		\
-{									\
-	return ((q)->active_cmd);					\
-}
-
-QUEUE_FNS(BLOCKED, blocked)
-QUEUE_FNS(DELETED, deleted)
-
-#define CMD_FNS(bit, name)						\
-static inline void set_cmd_##name(struct cmd *c)			\
-{									\
-	(c)->state |= (1UL << TGT_CMD_##bit);				\
-}									\
-static inline void clear_cmd_##name(struct cmd *c)			\
-{									\
-	(c)->state &= ~(1UL << TGT_CMD_##bit);				\
-}									\
-static inline int cmd_##name(const struct cmd *c)			\
-{									\
-	return ((c)->state & (1UL << TGT_CMD_##bit));			\
-}
-
-CMD_FNS(QUEUED, queued)
-CMD_FNS(PROCESSED, processed)
-
-
 static struct target *target_get(int tid)
 {
 	if (tid >= MAX_NR_TARGET) {

Added: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-12 04:23:31 UTC (rev 519)
+++ trunk/usr/target.h	2006-08-12 05:54:53 UTC (rev 520)
@@ -0,0 +1,106 @@
+#ifndef __TARGET_H__
+#define __TARGET_H__
+
+/* better if we can include the followings in kernel header files. */
+#define	MSG_SIMPLE_TAG	0x20
+#define	MSG_HEAD_TAG	0x21
+#define	MSG_ORDERED_TAG	0x22
+
+#define	MAX_NR_TARGET		1024
+#define	MAX_NR_HOST		1024
+#define	DEFAULT_NR_DEVICE	64
+#define	MAX_NR_DEVICE		(1 << 20)
+
+#define	HASH_ORDER	4
+#define	cmd_hashfn(cid)	hash_long((cid), HASH_ORDER)
+
+struct mgmt_req {
+	uint64_t mid;
+	int busy;
+	int function;
+};
+
+struct cmd {
+	struct list_head hlist;
+	struct list_head qlist;
+	struct list_head clist;
+	uint32_t cid;
+	uint64_t uaddr;
+	uint32_t len;
+	int mmapped;
+	struct tgt_device *dev;
+	unsigned long state;
+
+	/* Kill the followings when we use shared memory instead of netlink. */
+	int hostno;
+	uint32_t data_len;
+	uint8_t scb[16];
+	uint8_t lun[8];
+	int attribute;
+	uint64_t tag;
+	struct mgmt_req *mreq;
+};
+
+struct target {
+	int tid;
+	int lid;
+
+	uint64_t max_device;
+	struct tgt_device **devt;
+	struct list_head device_list;
+
+	struct list_head cmd_hash_list[1 << HASH_ORDER];
+	struct list_head cmd_list;
+	struct tgt_cmd_queue cmd_queue;
+};
+
+enum {
+	TGT_QUEUE_BLOCKED,
+	TGT_QUEUE_DELETED,
+};
+
+enum {
+	TGT_CMD_QUEUED,
+	TGT_CMD_PROCESSED,
+};
+
+#define QUEUE_FNS(bit, name)						\
+static inline void set_queue_##name(struct tgt_cmd_queue *q)		\
+{									\
+	(q)->state |= (1UL << TGT_QUEUE_##bit);				\
+}									\
+static inline void clear_queue_##name(struct tgt_cmd_queue *q)		\
+{									\
+	(q)->state &= ~(1UL << TGT_QUEUE_##bit);			\
+}									\
+static inline int queue_##name(const struct tgt_cmd_queue *q)		\
+{									\
+	return ((q)->state & (1UL << TGT_QUEUE_##bit));			\
+}
+
+static inline int queue_active(const struct tgt_cmd_queue *q)		\
+{									\
+	return ((q)->active_cmd);					\
+}
+
+QUEUE_FNS(BLOCKED, blocked)
+QUEUE_FNS(DELETED, deleted)
+
+#define CMD_FNS(bit, name)						\
+static inline void set_cmd_##name(struct cmd *c)			\
+{									\
+	(c)->state |= (1UL << TGT_CMD_##bit);				\
+}									\
+static inline void clear_cmd_##name(struct cmd *c)			\
+{									\
+	(c)->state &= ~(1UL << TGT_CMD_##bit);				\
+}									\
+static inline int cmd_##name(const struct cmd *c)			\
+{									\
+	return ((c)->state & (1UL << TGT_CMD_##bit));			\
+}
+
+CMD_FNS(QUEUED, queued)
+CMD_FNS(PROCESSED, processed)
+
+#endif



From tomo at mail.berlios.de  Sat Aug 12 08:43:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 08:43:33 +0200
Subject: [Stgt-svn] r521 - trunk/usr
Message-ID: <200608120643.k7C6hXu5015077@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 08:43:30 +0200 (Sat, 12 Aug 2006)
New Revision: 521

Modified:
   trunk/usr/target.c
Log:
Disable try_mmap_device to mmap the whole device temporally. This is not useful for 32-bit architectures because the task size is only 3GB.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 05:54:53 UTC (rev 520)
+++ trunk/usr/target.c	2006-08-12 06:43:30 UTC (rev 521)
@@ -26,7 +26,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <poll.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
@@ -40,7 +39,6 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
-#include "tgtadm.h"
 #include "driver.h"
 #include "target.h"
 
@@ -86,20 +84,6 @@
 	free(q);
 }
 
-static uint64_t try_mmap_device(int fd, uint64_t size)
-{
-	void *p;
-
-	if (size != (size_t) size)
-		return 0;
-	p = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (p == MAP_FAILED)
-		return 0;
-	else
-		return (unsigned long) p;
-	return 0;
-}
-
 static void tgt_device_link(struct target *target, struct tgt_device *dev)
 {
 	struct tgt_device *ent;
@@ -173,7 +157,7 @@
 		goto close_dev_fd;
 
 	device->fd = dev_fd;
-	device->addr = try_mmap_device(dev_fd, size);
+	device->addr = 0;
 	device->size = size;
 	device->lun = dev_id;
 	snprintf(device->scsi_id, sizeof(device->scsi_id),



From tomo at mail.berlios.de  Sat Aug 12 10:49:23 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 10:49:23 +0200
Subject: [Stgt-svn] r522 - trunk/usr
Message-ID: <200608120849.k7C8nNOw026676@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 10:49:22 +0200 (Sat, 12 Aug 2006)
New Revision: 522

Modified:
   trunk/usr/target.c
   trunk/usr/target.h
Log:
Kill MAX_NR_TARGET

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 06:43:30 UTC (rev 521)
+++ trunk/usr/target.c	2006-08-12 08:49:22 UTC (rev 522)
@@ -42,18 +42,31 @@
 #include "driver.h"
 #include "target.h"
 
-static struct target *tgtt[MAX_NR_TARGET];
 static struct target *hostt[MAX_NR_HOST];
 
-static struct target *target_get(int tid)
+static struct list_head target_list[1 << HASH_ORDER];
+
+static struct target *target_lookup(int tid)
 {
-	if (tid >= MAX_NR_TARGET) {
-		eprintf("Too larget target id %d\n", tid);
-		return NULL;
-	}
-	return tgtt[tid];
+	struct target *target;
+
+	list_for_each_entry(target, &target_list[hashfn(tid)], tlist)
+		if (target->tid == tid)
+			return target;
+	return NULL;
 }
 
+static void target_list_insert(struct target *target)
+{
+	struct list_head *list = &target_list[hashfn(target->tid)];
+	list_add(&target->tlist, list);
+}
+
+static void target_list_remove(struct target *target)
+{
+	list_del(&target->tlist);
+}
+
 static struct tgt_device *device_get(struct target *target, uint64_t dev_id)
 {
 	if (dev_id < target->max_device || dev_id < MAX_NR_DEVICE)
@@ -114,7 +127,7 @@
 
 	dprintf("%d %" PRIu64 " %s\n", tid, dev_id, path);
 
-	target = target_get(tid);
+	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
 
@@ -187,7 +200,7 @@
 
 	dprintf("%u %" PRIu64 "\n", tid, dev_id);
 
-	target = target_get(tid);
+	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
 
@@ -312,7 +325,7 @@
 	cmd->attribute = ev_req->k.cmd_req.attribute;
 	cmd->tag = ev_req->k.cmd_req.tag;
 	list_add(&cmd->clist, &target->cmd_list);
-	list_add(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
+	list_add(&cmd->hlist, &target->cmd_hash_list[hashfn(cmd->cid)]);
 
 	dev_id = scsi_get_devid(target->lid, ev_req->k.cmd_req.lun);
 	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
@@ -398,7 +411,7 @@
 static struct cmd *find_cmd(struct target *target, uint32_t cid)
 {
 	struct cmd *cmd;
-	struct list_head *head = &target->cmd_hash_list[cmd_hashfn(cid)];
+	struct list_head *head = &target->cmd_hash_list[hashfn(cid)];
 
 	list_for_each_entry(cmd, head, hlist) {
 		if (cmd->cid == cid)
@@ -630,11 +643,14 @@
 
 int tgt_target_bind(int tid, int host_no, int lid)
 {
-	if (!tgtt[tid]) {
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target) {
 		eprintf("target is not found %d\n", tid);
 		return -EINVAL;
 	}
-	tgtt[tid]->lid = lid;
+	target->lid = lid;
 
 	if (hostt[host_no]) {
 		eprintf("host is already binded %d %d\n", tid, host_no);
@@ -643,7 +659,7 @@
 
 	eprintf("Succeed to bind the target %d to the scsi host %d\n",
 		tid, host_no);
-	hostt[host_no] = tgtt[tid];
+	hostt[host_no] = target;
 	return 0;
 }
 
@@ -652,12 +668,8 @@
 	int err, i;
 	struct target *target;
 
-	if (tid >= MAX_NR_TARGET) {
-		eprintf("Too larget target id %d\n", tid);
-		return -EINVAL;
-	}
-
-	if (tgtt[tid]) {
+	target = target_lookup(tid);
+	if (target) {
 		eprintf("Target id %d already exists\n", tid);
 		return -EINVAL;
 	}
@@ -686,7 +698,8 @@
 	tgt_cmd_queue_init(&target->cmd_queue);
 
 	eprintf("Succeed to create a new target %d\n", tid);
-	tgtt[tid] = target;
+	target_list_insert(target);
+
 	return 0;
 
 free_target:
@@ -696,8 +709,9 @@
 
 int tgt_target_destroy(int tid)
 {
-	struct target *target = target_get(tid);
+	struct target *target;
 
+	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
 
@@ -711,7 +725,7 @@
 
 	free(target->devt);
 
-	tgtt[tid] = NULL;
+	target_list_remove(target);
 	free(target);
 
 	return 0;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-12 06:43:30 UTC (rev 521)
+++ trunk/usr/target.h	2006-08-12 08:49:22 UTC (rev 522)
@@ -6,13 +6,12 @@
 #define	MSG_HEAD_TAG	0x21
 #define	MSG_ORDERED_TAG	0x22
 
-#define	MAX_NR_TARGET		1024
 #define	MAX_NR_HOST		1024
 #define	DEFAULT_NR_DEVICE	64
 #define	MAX_NR_DEVICE		(1 << 20)
 
 #define	HASH_ORDER	4
-#define	cmd_hashfn(cid)	hash_long((cid), HASH_ORDER)
+#define	hashfn(cid)	hash_long((cid), HASH_ORDER)
 
 struct mgmt_req {
 	uint64_t mid;
@@ -45,6 +44,8 @@
 	int tid;
 	int lid;
 
+	struct list_head tlist;
+
 	uint64_t max_device;
 	struct tgt_device **devt;
 	struct list_head device_list;



From tomo at mail.berlios.de  Sat Aug 12 12:47:01 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 12:47:01 +0200
Subject: [Stgt-svn] r523 - trunk/usr
Message-ID: <200608121047.k7CAl12j007258@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 12:46:59 +0200 (Sat, 12 Aug 2006)
New Revision: 523

Modified:
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
Kill poor NR_DEVICE stuff.

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-12 08:49:22 UTC (rev 522)
+++ trunk/usr/scsi.c	2006-08-12 10:46:59 UTC (rev 523)
@@ -287,7 +287,7 @@
 	idx = 1;
 	nr_luns = 0;
 
-	list_for_each_entry(dev, dev_list, dlist) {
+	list_for_each_entry(dev, dev_list, d_list) {
 		lun = dev->lun;
 
 		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 08:49:22 UTC (rev 522)
+++ trunk/usr/target.c	2006-08-12 10:46:59 UTC (rev 523)
@@ -32,8 +32,6 @@
 #include <sys/stat.h>
 
 #include <linux/fs.h>
-#define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
-#include <linux/hash.h>
 #include <scsi/scsi.h>
 
 #include "list.h"
@@ -43,71 +41,71 @@
 #include "target.h"
 
 static struct target *hostt[MAX_NR_HOST];
+static struct list_head target_hash_list[1 << HASH_ORDER];
 
-static struct list_head target_list[1 << HASH_ORDER];
-
 static struct target *target_lookup(int tid)
 {
 	struct target *target;
 
-	list_for_each_entry(target, &target_list[hashfn(tid)], tlist)
+	list_for_each_entry(target, &target_hash_list[hashfn(tid)], t_hlist)
 		if (target->tid == tid)
 			return target;
 	return NULL;
 }
 
-static void target_list_insert(struct target *target)
+static void target_hlist_insert(struct target *target)
 {
-	struct list_head *list = &target_list[hashfn(target->tid)];
-	list_add(&target->tlist, list);
+	struct list_head *list = &target_hash_list[hashfn(target->tid)];
+	list_add(&target->t_hlist, list);
 }
 
-static void target_list_remove(struct target *target)
+static void target_hlist_remove(struct target *target)
 {
-	list_del(&target->tlist);
+	list_del(&target->t_hlist);
 }
 
-static struct tgt_device *device_get(struct target *target, uint64_t dev_id)
+static struct tgt_device *device_lookup(struct target *target, uint64_t dev_id)
 {
-	if (dev_id < target->max_device || dev_id < MAX_NR_DEVICE)
-		return target->devt[dev_id];
-
-	dprintf("Invalid device id %" PRIu64 "%d\n", dev_id, MAX_NR_DEVICE);
+	struct tgt_device *device;
+	struct list_head *list = &target->device_hash_list[hashfn(dev_id)];
+	list_for_each_entry(device, list, d_hlist)
+		if (device->lun == dev_id)
+			return device;
 	return NULL;
 }
 
-static struct target *host_to_target(int host_no)
+static void device_hlist_insert(struct target *target, struct tgt_device *device)
 {
-	if (host_no < MAX_NR_HOST)
-		return hostt[host_no];
+	struct list_head *list = &target->device_hash_list[hashfn(device->lun)];
+	list_add(&device->d_hlist, list);
+}
 
-	return NULL;
+static void device_hlist_remove(struct tgt_device *device)
+{
+	list_del(&device->d_hlist);
 }
 
-static void resize_device_table(struct target *target, uint64_t did)
+static void device_list_insert(struct target *target, struct tgt_device *device)
 {
-	struct tgt_device *device;
-	void *p, *q;
+	struct tgt_device *pos;
+	list_for_each_entry(pos, &target->device_list, d_list) {
+		if (device->lun < pos->lun)
+			break;
+	}
+	list_add(&device->d_list, &pos->d_list);
+}
 
-	p = calloc(did + 1, sizeof(device));
-	memcpy(p, target->devt, sizeof(device) * target->max_device);
-	q = target->devt;
-	target->devt = p;
-	target->max_device = did + 1;
-	free(q);
+static void device_list_remove(struct tgt_device *device)
+{
+	list_del(&device->d_list);
 }
 
-static void tgt_device_link(struct target *target, struct tgt_device *dev)
+static struct target *host_to_target(int host_no)
 {
-	struct tgt_device *ent;
-	struct list_head *pos;
+	if (host_no < MAX_NR_HOST)
+		return hostt[host_no];
 
-	list_for_each(pos, &target->device_list) {
-		ent = list_entry(pos, struct tgt_device, dlist);
-		if (dev->lun < ent->lun)
-			break;
-	}
-	list_add(&dev->dlist, pos);
+	return NULL;
 }
 
 static void tgt_cmd_queue_init(struct tgt_cmd_queue *q)
@@ -131,7 +129,7 @@
 	if (!target)
 		return -ENOENT;
 
-	device = device_get(target, dev_id);
+	device = device_lookup(target, dev_id);
 	if (device) {
 		eprintf("device %" PRIu64 " already exists\n", dev_id);
 		return -EINVAL;
@@ -162,9 +160,6 @@
 		goto close_dev_fd;
 	}
 
-	if (dev_id >= target->max_device)
-		resize_device_table(target, dev_id);
-
 	device = malloc(sizeof(*device));
 	if (!device)
 		goto close_dev_fd;
@@ -175,14 +170,10 @@
 	device->lun = dev_id;
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, dev_id);
-	target->devt[dev_id] = device;
 
-	if (device->addr)
-		eprintf("Succeed to mmap the device %" PRIx64 "\n",
-			device->addr);
-
-	tgt_device_link(target, device);
 	tgt_cmd_queue_init(&device->cmd_queue);
+	device_hlist_insert(target, device);
+	device_list_insert(target, device);
 
 	eprintf("Succeed to add a logical unit %" PRIu64 " to the target %d\n",
 		dev_id, tid);
@@ -204,7 +195,7 @@
 	if (!target)
 		return -ENOENT;
 
-	device = device_get(target, dev_id);
+	device = device_lookup(target, dev_id);
 	if (!device) {
 		eprintf("device %" PRIu64 " not found\n", dev_id);
 		return -EINVAL;
@@ -213,14 +204,10 @@
 	if (!list_empty(&device->cmd_queue.queue))
 		return -EBUSY;
 
-	target->devt[dev_id] = NULL;
-	if (device->addr)
-		munmap((void *) (unsigned long) device->addr, device->size);
-
 	close(device->fd);
+	device_hlist_remove(device);
+	device_list_remove(device);
 
-	list_del(&device->dlist);
-
 	free(device);
 	return 0;
 }
@@ -331,9 +318,9 @@
 	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
 		dev_id);
 
-	cmd->dev = device_get(target, dev_id);
+	cmd->dev = device_lookup(target, dev_id);
 	if (cmd->dev) {
-		uaddr = target->devt[dev_id]->addr;
+		uaddr = cmd->dev->addr;
 		q = &cmd->dev->cmd_queue;
 	} else
 		q = &target->cmd_queue;
@@ -665,7 +652,7 @@
 
 int tgt_target_create(int tid)
 {
-	int err, i;
+	int i;
 	struct target *target;
 
 	target = target_lookup(tid);
@@ -686,25 +673,15 @@
 		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
 
 	INIT_LIST_HEAD(&target->device_list);
+	for (i = 0; i < ARRAY_SIZE(target->device_hash_list); i++)
+		INIT_LIST_HEAD(&target->device_hash_list[i]);
 
-	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct tgt_device *));
-	if (!target->devt) {
-		eprintf("Out of memoryn\n");
-		err = 0;
-		goto free_target;
-	}
-	target->max_device = DEFAULT_NR_DEVICE;
-
 	tgt_cmd_queue_init(&target->cmd_queue);
+	target_hlist_insert(target);
 
 	eprintf("Succeed to create a new target %d\n", tid);
-	target_list_insert(target);
 
 	return 0;
-
-free_target:
-	free(target);
-	return err;
 }
 
 int tgt_target_destroy(int tid)
@@ -723,9 +700,7 @@
 	if (!list_empty(&target->cmd_queue.queue))
 		return -EBUSY;
 
-	free(target->devt);
-
-	target_list_remove(target);
+	target_hlist_remove(target);
 	free(target);
 
 	return 0;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-12 08:49:22 UTC (rev 522)
+++ trunk/usr/target.h	2006-08-12 10:46:59 UTC (rev 523)
@@ -1,14 +1,15 @@
 #ifndef __TARGET_H__
 #define __TARGET_H__
 
+#define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
+#include <linux/hash.h>
+
 /* better if we can include the followings in kernel header files. */
 #define	MSG_SIMPLE_TAG	0x20
 #define	MSG_HEAD_TAG	0x21
 #define	MSG_ORDERED_TAG	0x22
 
 #define	MAX_NR_HOST		1024
-#define	DEFAULT_NR_DEVICE	64
-#define	MAX_NR_DEVICE		(1 << 20)
 
 #define	HASH_ORDER	4
 #define	hashfn(cid)	hash_long((cid), HASH_ORDER)
@@ -44,11 +45,10 @@
 	int tid;
 	int lid;
 
-	struct list_head tlist;
+	struct list_head t_hlist;
 
-	uint64_t max_device;
-	struct tgt_device **devt;
-	struct list_head device_list;
+	struct list_head device_hash_list[1 << HASH_ORDER];
+	struct list_head device_list; /* for REPORT_LUNS */
 
 	struct list_head cmd_hash_list[1 << HASH_ORDER];
 	struct list_head cmd_list;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-12 08:49:22 UTC (rev 522)
+++ trunk/usr/tgtd.h	2006-08-12 10:46:59 UTC (rev 523)
@@ -18,8 +18,10 @@
 	uint64_t size;
 	uint64_t lun;
 	char scsi_id[SCSI_ID_LEN];
-	struct list_head dlist;
 
+	struct list_head d_hlist;
+	struct list_head d_list;
+
 	struct tgt_cmd_queue cmd_queue;
 };
 



From tomo at mail.berlios.de  Sat Aug 12 12:58:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 12:58:50 +0200
Subject: [Stgt-svn] r524 - trunk/usr
Message-ID: <200608121058.k7CAwocO011194@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 12:58:45 +0200 (Sat, 12 Aug 2006)
New Revision: 524

Modified:
   trunk/usr/target.c
Log:
Initialize target_hash_list.

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 10:46:59 UTC (rev 523)
+++ trunk/usr/target.c	2006-08-12 10:58:45 UTC (rev 524)
@@ -705,3 +705,10 @@
 
 	return 0;
 }
+
+__attribute__((constructor)) static void target_init(void)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(target_hash_list); i++)
+		INIT_LIST_HEAD(&target_hash_list[i]);
+}



From tomo at mail.berlios.de  Sat Aug 12 15:10:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 15:10:59 +0200
Subject: [Stgt-svn] r525 - trunk/usr
Message-ID: <200608121310.k7CDAxC1018052@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 15:10:32 +0200 (Sat, 12 Aug 2006)
New Revision: 525

Modified:
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
For possible user-space target implementations, try to remove tgt_event in target.c


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 10:58:45 UTC (rev 524)
+++ trunk/usr/target.c	2006-08-12 13:10:32 UTC (rev 525)
@@ -46,7 +46,6 @@
 static struct target *target_lookup(int tid)
 {
 	struct target *target;
-
 	list_for_each_entry(target, &target_hash_list[hashfn(tid)], t_hlist)
 		if (target->tid == tid)
 			return target;
@@ -275,7 +274,8 @@
 	}
 }
 
-static void cmd_queue(struct tgt_event *ev_req)
+int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun, uint32_t data_len,
+		     int attribute, uint64_t tag)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
@@ -284,39 +284,38 @@
 	uint64_t offset, dev_id;
 	uint8_t rw = 0, mmapped = 0;
 	unsigned long uaddr = 0;
-	int hostno = ev_req->k.cmd_req.host_no;
 
-	target = host_to_target(hostno);
+	target = host_to_target(host_no);
 	if (!target) {
 		int tid, lid = 0, err = -1;
 		if (tgt_drivers[lid]->target_bind) {
-			tid = tgt_drivers[0]->target_bind(hostno);
+			tid = tgt_drivers[0]->target_bind(host_no);
 			if (tid >= 0) {
-				err = tgt_target_bind(tid, hostno, lid);
+				err = tgt_target_bind(tid, host_no, lid);
 				if (!err)
-					target = host_to_target(hostno);
+					target = host_to_target(host_no);
 			}
 		}
 
 		if (!target) {
-			eprintf("%d is not bind to any target\n",
-				ev_req->k.cmd_req.host_no);
-			return;
+			eprintf("%d is not bind to any target\n", host_no);
+			return -ENOENT;
 		}
 	}
 
 	/* TODO: preallocate cmd */
 	cmd = calloc(1, sizeof(*cmd));
-	cmd->hostno = ev_req->k.cmd_req.host_no;
- 	cmd->cid = ev_req->k.cmd_req.cid;
-	cmd->attribute = ev_req->k.cmd_req.attribute;
-	cmd->tag = ev_req->k.cmd_req.tag;
+	if (!cmd)
+		return -ENOMEM;
+	cmd->hostno = host_no;
+/*  	cmd->cid = ev_req->k.cmd_req.cid; */
+	cmd->attribute = attribute;
+	cmd->tag = tag;
 	list_add(&cmd->clist, &target->cmd_list);
-	list_add(&cmd->hlist, &target->cmd_hash_list[hashfn(cmd->cid)]);
+/* 	list_add(&cmd->hlist, &target->cmd_hash_list[hashfn(cmd->cid)]); */
 
-	dev_id = scsi_get_devid(target->lid, ev_req->k.cmd_req.lun);
-	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
-		dev_id);
+	dev_id = scsi_get_devid(target->lid, lun);
+	dprintf("%x %" PRIx64 "\n", scb[0], dev_id);
 
 	cmd->dev = device_lookup(target, dev_id);
 	if (cmd->dev) {
@@ -329,32 +328,33 @@
 
 	if (enabled) {
 		result = scsi_cmd_perform(target->lid,
-					  cmd->hostno, ev_req->k.cmd_req.scb,
-					  &len, ev_req->k.cmd_req.data_len,
+					  host_no, scb,
+					  &len, data_len,
 					  &uaddr, &rw, &mmapped, &offset,
-					  ev_req->k.cmd_req.lun, cmd->dev,
+					  lun, cmd->dev,
 					  &target->device_list);
 
 		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
 		dprintf("%u %x %lx %" PRIu64 " %d\n",
-			cmd->cid, ev_req->k.cmd_req.scb[0], uaddr,
-			offset, result);
+			cmd->cid, scb[0], uaddr, offset, result);
 
 		set_cmd_processed(cmd);
 		tgt_kspace_send_cmd(cmd, result, rw);
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %u %x %" PRIu64 " %d\n",
-			cmd->cid, ev_req->k.cmd_req.scb[0],
+			cmd->cid, scb[0],
 			cmd->dev ? cmd->dev->lun : ~0ULL,
 			q->active_cmd);
 
-		memcpy(cmd->scb, ev_req->k.cmd_req.scb, sizeof(cmd->scb));
-		memcpy(cmd->lun, ev_req->k.cmd_req.lun, sizeof(cmd->lun));
-		cmd->len = ev_req->k.cmd_req.data_len;
+		memcpy(cmd->scb, scb, sizeof(cmd->scb));
+		memcpy(cmd->lun, lun, sizeof(cmd->lun));
+		cmd->len = data_len;
 		list_add_tail(&cmd->qlist, &q->queue);
 	}
+
+	return 0;
 }
 
 static void post_cmd_done(struct tgt_cmd_queue *q)
@@ -476,13 +476,11 @@
 	return kreq_send(&ev);
 }
 
-static void cmd_done(struct tgt_event *ev)
+void target_cmd_done(int host_no, uint32_t cid)
 {
 	struct target *target;
 	struct cmd *cmd;
 	struct mgmt_req *mreq;
-	int host_no = ev->k.cmd_done.host_no;
-	uint32_t cid = ev->k.cmd_done.cid;
 
 	target = host_to_target(host_no);
 	if (!target) {
@@ -550,29 +548,26 @@
 	return count;
 }
 
-static void tsk_mgmt_req(struct tgt_event *ev_req)
+void target_mgmt_request(int host_no, int req_id, int function, uint8_t *lun,
+			 uint64_t tag)
 {
 	struct target *target;
 	struct mgmt_req *mreq;
 	int err = 0, count, send = 1;
-	int host_no = ev_req->k.cmd_req.host_no;
 
 	target = host_to_target(host_no);
 	if (!target) {
-		eprintf("%d is not bind to any target\n",
-			ev_req->k.cmd_req.host_no);
+		eprintf("%d is not bind to any target\n", host_no);
 		return;
 	}
 
 	mreq = calloc(1, sizeof(*mreq));
-	mreq->mid = ev_req->k.tsk_mgmt_req.mid;
-	mreq->function = ev_req->k.tsk_mgmt_req.function;
+	mreq->mid = req_id;
+	mreq->function = function;
 
-	switch (mreq->function) {
+	switch (function) {
 	case ABORT_TASK:
-		count = abort_task_set(mreq, target, host_no,
-				       ev_req->k.tsk_mgmt_req.tag,
-				       NULL, 0);
+		count = abort_task_set(mreq, target, host_no, tag, NULL, 0);
 		if (mreq->busy)
 			send = 0;
 		if (!count)
@@ -585,49 +580,25 @@
 		break;
 	case CLEAR_ACA:
 	case CLEAR_TASK_SET:
-		eprintf("Not supported yet %x\n",
-			ev_req->k.tsk_mgmt_req.function);
+		eprintf("Not supported yet %x\n", function);
 		err = -EINVAL;
 		break;
 	case LOGICAL_UNIT_RESET:
-		count = abort_task_set(mreq, target, host_no, 0,
-				       ev_req->k.tsk_mgmt_req.lun, 0);
+		count = abort_task_set(mreq, target, host_no, 0, lun, 0);
 		if (mreq->busy)
 			send = 0;
 		break;
 	default:
 		err = -EINVAL;
-		eprintf("Unknown task management %x\n",
-			ev_req->k.tsk_mgmt_req.function);
+		eprintf("Unknown task management %x\n", function);
 	}
 
 	if (send) {
-		tgt_kspace_send_tsk_mgmt(ev_req->k.cmd_req.host_no,
-					 ev_req->k.tsk_mgmt_req.mid, err);
+		tgt_kspace_send_tsk_mgmt(host_no, req_id, err);
 		free(mreq);
 	}
 }
 
-void kreq_exec(struct tgt_event *ev)
-{
-	dprintf("event %u\n", ev->type);
-
-	switch (ev->type) {
-	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(ev);
-		break;
-	case TGT_KEVENT_CMD_DONE:
-		cmd_done(ev);
-		break;
-	case TGT_KEVENT_TSK_MGMT_REQ:
-		tsk_mgmt_req(ev);
-		break;
-	default:
-		eprintf("unknown event %u\n", ev->type);
-		exit(1);
-	}
-}
-
 int tgt_target_bind(int tid, int host_no, int lid)
 {
 	struct target *target;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-12 10:58:45 UTC (rev 524)
+++ trunk/usr/tgtd.h	2006-08-12 13:10:32 UTC (rev 525)
@@ -32,13 +32,18 @@
 extern int ipc_init(int *fd);
 extern void ipc_event_handle(int accept_fd);
 
-extern void kreq_exec(struct tgt_event *ev);
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_target_create(int tid);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
+extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
+			    uint32_t data_len, int attribute, uint64_t tag);
+extern void target_cmd_done(int host_no, uint32_t cid);
+extern void target_mgmt_request(int host_no, int req_id, int function,
+				uint8_t *lun, uint64_t tag);
+
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-12 10:58:45 UTC (rev 524)
+++ trunk/usr/tgtif.c	2006-08-12 13:10:32 UTC (rev 525)
@@ -74,6 +74,32 @@
 	dprintf("%u %u\n", r->entry_size, r->nr_entry);
 }
 
+static void kreq_exec(struct tgt_event *ev)
+{
+	dprintf("event %u\n", ev->type);
+
+	switch (ev->type) {
+	case TGT_KEVENT_CMD_REQ:
+		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
+				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
+				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag);
+		break;
+	case TGT_KEVENT_CMD_DONE:
+		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.cid);
+		break;
+	case TGT_KEVENT_TSK_MGMT_REQ:
+		target_mgmt_request(ev->k.cmd_req.host_no,
+				    ev->k.tsk_mgmt_req.mid,
+				    ev->k.tsk_mgmt_req.function,
+				    ev->k.tsk_mgmt_req.lun,
+				    ev->k.tsk_mgmt_req.tag);
+		break;
+	default:
+		eprintf("unknown event %u\n", ev->type);
+		exit(1);
+	}
+}
+
 int kreq_send(struct tgt_event *ev)
 {
 	struct rbuf_hdr *hdr;



From tomo at mail.berlios.de  Sat Aug 12 15:58:14 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 15:58:14 +0200
Subject: [Stgt-svn] r526 - trunk/usr
Message-ID: <200608121358.k7CDwEmR011767@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 15:58:03 +0200 (Sat, 12 Aug 2006)
New Revision: 526

Modified:
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
Clean up command's lists.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 13:10:32 UTC (rev 525)
+++ trunk/usr/target.c	2006-08-12 13:58:03 UTC (rev 526)
@@ -99,6 +99,28 @@
 	list_del(&device->d_list);
 }
 
+static struct cmd *cmd_lookup(struct target *target, uint64_t tag)
+{
+	struct cmd *cmd;
+	struct list_head *list = &target->cmd_hash_list[hashfn(tag)];
+	list_for_each_entry(cmd, list, c_hlist) {
+		if (cmd->tag == tag)
+			return cmd;
+	}
+	return NULL;
+}
+
+static void cmd_hlist_insert(struct target *target, struct cmd *cmd)
+{
+	struct list_head *list = &target->cmd_hash_list[hashfn(cmd->tag)];
+	list_add(&cmd->c_hlist, list);
+}
+
+static void cmd_hlist_remove(struct cmd *cmd)
+{
+	list_del(&cmd->c_hlist);
+}
+
 static struct target *host_to_target(int host_no)
 {
 	if (host_no < MAX_NR_HOST)
@@ -217,7 +239,7 @@
 
 	ev.type = TGT_UEVENT_CMD_RSP;
 	ev.u.cmd_rsp.host_no = cmd->hostno;
-	ev.u.cmd_rsp.cid = cmd->cid;
+/* 	ev.u.cmd_rsp.cid = cmd->cid; */
 	ev.u.cmd_rsp.len = cmd->len;
 	ev.u.cmd_rsp.result = result;
 	ev.u.cmd_rsp.uaddr = cmd->uaddr;
@@ -231,8 +253,8 @@
 	int enabled = 0;
 
 	if (cmd->attribute != MSG_SIMPLE_TAG)
-		dprintf("non simple attribute %u %x %" PRIu64 " %d\n",
-			cmd->cid, cmd->attribute, cmd->dev ? cmd->dev->lun : ~0ULL,
+		dprintf("non simple attribute %" PRIx64 " %x %" PRIu64 " %d\n",
+			cmd->tag, cmd->attribute, cmd->dev ? cmd->dev->lun : ~0ULL,
 			q->active_cmd);
 
 	switch (cmd->attribute) {
@@ -308,11 +330,9 @@
 	if (!cmd)
 		return -ENOMEM;
 	cmd->hostno = host_no;
-/*  	cmd->cid = ev_req->k.cmd_req.cid; */
 	cmd->attribute = attribute;
 	cmd->tag = tag;
-	list_add(&cmd->clist, &target->cmd_list);
-/* 	list_add(&cmd->hlist, &target->cmd_hash_list[hashfn(cmd->cid)]); */
+	cmd_hlist_insert(target, cmd);
 
 	dev_id = scsi_get_devid(target->lid, lun);
 	dprintf("%x %" PRIx64 "\n", scb[0], dev_id);
@@ -336,16 +356,15 @@
 
 		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
-		dprintf("%u %x %lx %" PRIu64 " %d\n",
-			cmd->cid, scb[0], uaddr, offset, result);
+		dprintf("%" PRIx64 " %x %lx %" PRIu64 " %d\n",
+			tag, scb[0], uaddr, offset, result);
 
 		set_cmd_processed(cmd);
 		tgt_kspace_send_cmd(cmd, result, rw);
 	} else {
 		set_cmd_queued(cmd);
-		dprintf("blocked %u %x %" PRIu64 " %d\n",
-			cmd->cid, scb[0],
-			cmd->dev ? cmd->dev->lun : ~0ULL,
+		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
+			tag, scb[0], cmd->dev ? cmd->dev->lun : ~0ULL,
 			q->active_cmd);
 
 		memcpy(cmd->scb, scb, sizeof(cmd->scb));
@@ -375,7 +394,7 @@
 				eprintf("fail to find target!\n");
 				exit(1);
 			}
-			dprintf("perform %u %x\n", cmd->cid, cmd->attribute);
+			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
 			result = scsi_cmd_perform(target->lid,
 						  cmd->hostno, cmd->scb,
 						  &len,
@@ -395,18 +414,6 @@
 	}
 }
 
-static struct cmd *find_cmd(struct target *target, uint32_t cid)
-{
-	struct cmd *cmd;
-	struct list_head *head = &target->cmd_hash_list[hashfn(cid)];
-
-	list_for_each_entry(cmd, head, hlist) {
-		if (cmd->cid == cid)
-			return cmd;
-	}
-	return NULL;
-}
-
 static int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
@@ -430,8 +437,7 @@
 	struct tgt_cmd_queue *q;
 	int err, do_munmap;
 
-	list_del(&cmd->clist);
-	list_del(&cmd->hlist);
+	cmd_hlist_remove(cmd);
 
 	do_munmap = cmd->mmapped;
 	if (do_munmap) {
@@ -476,7 +482,7 @@
 	return kreq_send(&ev);
 }
 
-void target_cmd_done(int host_no, uint32_t cid)
+void target_cmd_done(int host_no, uint64_t tag)
 {
 	struct target *target;
 	struct cmd *cmd;
@@ -488,9 +494,9 @@
 		return;
 	}
 
-	cmd = find_cmd(target, cid);
+	cmd = cmd_lookup(target, tag);
 	if (!cmd) {
-		eprintf("Cannot find cmd %d %u\n", host_no, cid);
+		eprintf("Cannot find cmd %d %" PRIx64 "\n", host_no, tag);
 		return;
 	}
 
@@ -530,18 +536,21 @@
 			  uint64_t tag, uint8_t *lun, int all)
 {
 	struct cmd *cmd, *tmp;
-	int err, count = 0;
+	int i, err, count = 0;
 
 	eprintf("found %" PRIx64 " %d\n", tag, all);
 
-	list_for_each_entry_safe(cmd, tmp, &target->cmd_list, clist) {
-		if ((all && cmd->hostno == host_no)||
-		    (cmd->tag == tag && cmd->hostno == host_no) ||
-		    (lun && !memcmp(cmd->lun, lun, sizeof(cmd->lun)))) {
-			err = abort_cmd(target, mreq, cmd);
-			if (err)
-				mreq->busy++;
-			count++;
+	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++) {
+		struct list_head *list = &target->cmd_hash_list[i];
+		list_for_each_entry_safe(cmd, tmp, list, c_hlist) {
+			if ((all && cmd->hostno == host_no) ||
+			    (cmd->tag == tag && cmd->hostno == host_no) ||
+			    (lun && !memcmp(cmd->lun, lun, sizeof(cmd->lun)))) {
+				err = abort_cmd(target, mreq, cmd);
+				if (err)
+					mreq->busy++;
+				count++;
+			}
 		}
 	}
 
@@ -639,7 +648,6 @@
 	}
 
 	target->tid = tid;
-	INIT_LIST_HEAD(&target->cmd_list);
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
 		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
 

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-12 13:10:32 UTC (rev 525)
+++ trunk/usr/target.h	2006-08-12 13:58:03 UTC (rev 526)
@@ -12,7 +12,7 @@
 #define	MAX_NR_HOST		1024
 
 #define	HASH_ORDER	4
-#define	hashfn(cid)	hash_long((cid), HASH_ORDER)
+#define	hashfn(val)	hash_long((unsigned long) (val), HASH_ORDER)
 
 struct mgmt_req {
 	uint64_t mid;
@@ -21,10 +21,10 @@
 };
 
 struct cmd {
-	struct list_head hlist;
+	/* linked target->cmd_hash_list */
+	struct list_head c_hlist;
 	struct list_head qlist;
-	struct list_head clist;
-	uint32_t cid;
+
 	uint64_t uaddr;
 	uint32_t len;
 	int mmapped;
@@ -51,7 +51,7 @@
 	struct list_head device_list; /* for REPORT_LUNS */
 
 	struct list_head cmd_hash_list[1 << HASH_ORDER];
-	struct list_head cmd_list;
+
 	struct tgt_cmd_queue cmd_queue;
 };
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-12 13:10:32 UTC (rev 525)
+++ trunk/usr/tgtd.h	2006-08-12 13:58:03 UTC (rev 526)
@@ -40,7 +40,7 @@
 
 extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
 			    uint32_t data_len, int attribute, uint64_t tag);
-extern void target_cmd_done(int host_no, uint32_t cid);
+extern void target_cmd_done(int host_no, uint64_t tag);
 extern void target_mgmt_request(int host_no, int req_id, int function,
 				uint8_t *lun, uint64_t tag);
 



From tomo at mail.berlios.de  Sat Aug 12 16:41:30 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 12 Aug 2006 16:41:30 +0200
Subject: [Stgt-svn] r527 - trunk/usr
Message-ID: <200608121441.k7CEfUV5024778@sheep.berlios.de>

Author: tomo
Date: 2006-08-12 16:41:29 +0200 (Sat, 12 Aug 2006)
New Revision: 527

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Only tgtif depends on scsi_tgt_if.h


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/mgmt.c	2006-08-12 14:41:29 UTC (rev 527)
@@ -32,7 +32,6 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
-#include <scsi/scsi_tgt_if.h>
 
 #include "list.h"
 #include "tgtd.h"

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/target.c	2006-08-12 14:41:29 UTC (rev 527)
@@ -233,21 +233,6 @@
 	return 0;
 }
 
-static int tgt_kspace_send_cmd(struct cmd *cmd, int result, int rw)
-{
-	struct tgt_event ev;
-
-	ev.type = TGT_UEVENT_CMD_RSP;
-	ev.u.cmd_rsp.host_no = cmd->hostno;
-/* 	ev.u.cmd_rsp.cid = cmd->cid; */
-	ev.u.cmd_rsp.len = cmd->len;
-	ev.u.cmd_rsp.result = result;
-	ev.u.cmd_rsp.uaddr = cmd->uaddr;
-	ev.u.cmd_rsp.rw = rw;
-
-	return kreq_send(&ev);
-}
-
 static int cmd_pre_perform(struct tgt_cmd_queue *q, struct cmd *cmd)
 {
 	int enabled = 0;
@@ -297,7 +282,7 @@
 }
 
 int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun, uint32_t data_len,
-		     int attribute, uint64_t tag)
+		     int attribute, uint64_t tag, cmd_end_t *end_func)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
@@ -332,6 +317,7 @@
 	cmd->hostno = host_no;
 	cmd->attribute = attribute;
 	cmd->tag = tag;
+	cmd->cmd_end_func = end_func;
 	cmd_hlist_insert(target, cmd);
 
 	dev_id = scsi_get_devid(target->lid, lun);
@@ -360,7 +346,7 @@
 			tag, scb[0], uaddr, offset, result);
 
 		set_cmd_processed(cmd);
-		tgt_kspace_send_cmd(cmd, result, rw);
+		cmd->cmd_end_func(host_no, len, result, rw, uaddr, tag);
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
@@ -408,7 +394,8 @@
 						  &target->device_list);
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
 			set_cmd_processed(cmd);
-			tgt_kspace_send_cmd(cmd, result, rw);
+			cmd->cmd_end_func(cmd->hostno, len, result, rw,
+					  uaddr, cmd->tag);
 		} else
 			break;
 	}
@@ -471,17 +458,6 @@
 	post_cmd_done(q);
 }
 
-static int tgt_kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
-{
-	struct tgt_event ev;
-
-	ev.u.tsk_mgmt_rsp.host_no = host_no;
-	ev.u.tsk_mgmt_rsp.mid = mid;
-	ev.u.tsk_mgmt_rsp.result = result;
-
-	return kreq_send(&ev);
-}
-
 void target_cmd_done(int host_no, uint64_t tag)
 {
 	struct target *target;
@@ -503,7 +479,7 @@
 	mreq = cmd->mreq;
 	if (mreq && !--mreq->busy) {
 		int err = mreq->function == ABORT_TASK ? -EEXIST : 0;
-		tgt_kspace_send_tsk_mgmt(cmd->hostno, mreq->mid, err);
+		mreq->mgmt_end_func(cmd->hostno, mreq->mid, err);
 		free(mreq);
 	}
 
@@ -527,7 +503,7 @@
 		err = -EBUSY;
 	} else {
 		__cmd_done(target, cmd);
-		tgt_kspace_send_cmd(cmd, TASK_ABORTED, 0);
+		cmd->cmd_end_func(cmd->hostno, 0, TASK_ABORTED, 0, 0, cmd->tag);
 	}
 	return err;
 }
@@ -558,7 +534,7 @@
 }
 
 void target_mgmt_request(int host_no, int req_id, int function, uint8_t *lun,
-			 uint64_t tag)
+			 uint64_t tag, mgmt_end_t *end_func)
 {
 	struct target *target;
 	struct mgmt_req *mreq;
@@ -573,6 +549,7 @@
 	mreq = calloc(1, sizeof(*mreq));
 	mreq->mid = req_id;
 	mreq->function = function;
+	mreq->mgmt_end_func = end_func;
 
 	switch (function) {
 	case ABORT_TASK:
@@ -603,7 +580,7 @@
 	}
 
 	if (send) {
-		tgt_kspace_send_tsk_mgmt(host_no, req_id, err);
+		mreq->mgmt_end_func(host_no, req_id, err);
 		free(mreq);
 	}
 }

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/target.h	2006-08-12 14:41:29 UTC (rev 527)
@@ -18,6 +18,7 @@
 	uint64_t mid;
 	int busy;
 	int function;
+	mgmt_end_t *mgmt_end_func;
 };
 
 struct cmd {
@@ -39,6 +40,7 @@
 	int attribute;
 	uint64_t tag;
 	struct mgmt_req *mreq;
+	cmd_end_t *cmd_end_func;
 };
 
 struct target {

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/tgtd.c	2006-08-12 14:41:29 UTC (rev 527)
@@ -139,7 +139,7 @@
 	}
 
 	if (pfd[POLL_KI].revents) {
-		kreq_recv();
+		kspace_event_handle();
 		nevent--;
 	}
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/tgtd.h	2006-08-12 14:41:29 UTC (rev 527)
@@ -2,7 +2,6 @@
 #define __TARGET_DAEMON_H
 
 #include "log.h"
-#include <scsi/scsi_tgt_if.h>
 
 #define	SCSI_ID_LEN	24
 
@@ -26,8 +25,7 @@
 };
 
 extern int kreq_init(int *fd);
-extern int kreq_recv(void);
-extern int kreq_send(struct tgt_event *ev);
+extern void kspace_event_handle(void);
 
 extern int ipc_init(int *fd);
 extern void ipc_event_handle(int accept_fd);
@@ -38,11 +36,15 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
+typedef int (cmd_end_t)(int host_no, int len, int result, int rw, uint64_t addr,
+			 uint64_t tag);
+typedef int (mgmt_end_t)(int host_no, uint64_t mid, int result);
 extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
-			    uint32_t data_len, int attribute, uint64_t tag);
+			    uint32_t data_len, int attribute, uint64_t tag,
+			    cmd_end_t *cmd_end);
 extern void target_cmd_done(int host_no, uint64_t tag);
 extern void target_mgmt_request(int host_no, int req_id, int function,
-				uint8_t *lun, uint64_t tag);
+				uint8_t *lun, uint64_t tag, mgmt_end_t *mgmt_end);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-12 13:58:03 UTC (rev 526)
+++ trunk/usr/tgtif.c	2006-08-12 14:41:29 UTC (rev 527)
@@ -74,34 +74,8 @@
 	dprintf("%u %u\n", r->entry_size, r->nr_entry);
 }
 
-static void kreq_exec(struct tgt_event *ev)
+static int kreq_send(struct tgt_event *ev)
 {
-	dprintf("event %u\n", ev->type);
-
-	switch (ev->type) {
-	case TGT_KEVENT_CMD_REQ:
-		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
-				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
-				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag);
-		break;
-	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.cid);
-		break;
-	case TGT_KEVENT_TSK_MGMT_REQ:
-		target_mgmt_request(ev->k.cmd_req.host_no,
-				    ev->k.tsk_mgmt_req.mid,
-				    ev->k.tsk_mgmt_req.function,
-				    ev->k.tsk_mgmt_req.lun,
-				    ev->k.tsk_mgmt_req.tag);
-		break;
-	default:
-		eprintf("unknown event %u\n", ev->type);
-		exit(1);
-	}
-}
-
-int kreq_send(struct tgt_event *ev)
-{
 	struct rbuf_hdr *hdr;
 	hdr = head_ring_hdr(&ukring);
 	if (hdr->status)
@@ -116,18 +90,70 @@
 	return 0;
 }
 
-int kreq_recv(void)
+static int kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
 {
+	struct tgt_event ev;
+
+	ev.u.tsk_mgmt_rsp.host_no = host_no;
+	ev.u.tsk_mgmt_rsp.mid = mid;
+	ev.u.tsk_mgmt_rsp.result = result;
+
+	return kreq_send(&ev);
+}
+
+static int kspace_send_cmd_res(int host_no, int len, int result,
+			       int rw, uint64_t addr, uint64_t tag)
+{
+	struct tgt_event ev;
+
+	ev.type = TGT_UEVENT_CMD_RSP;
+	ev.u.cmd_rsp.host_no = host_no;
+/* 	ev.u.cmd_rsp.cid = cmd->cid; */
+	ev.u.cmd_rsp.len = len;
+	ev.u.cmd_rsp.result = result;
+	ev.u.cmd_rsp.uaddr = addr;
+	ev.u.cmd_rsp.rw = rw;
+
+	return kreq_send(&ev);
+}
+
+void kspace_event_handle(void)
+{
 	struct rbuf_hdr *hdr;
+	struct tgt_event *ev;
 
 	dprintf("nl event %u\n", kuring.idx);
-
 retry:
 	hdr = head_ring_hdr(&kuring);
 	if (!hdr->status)
-		return 0;
+		return;
 
-	kreq_exec((struct tgt_event *) (hdr->data));
+	ev = (struct tgt_event *) (hdr->data);
+
+	dprintf("event %u\n", ev->type);
+
+	switch (ev->type) {
+	case TGT_KEVENT_CMD_REQ:
+		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
+				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
+				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag,
+				 kspace_send_cmd_res);
+		break;
+	case TGT_KEVENT_CMD_DONE:
+		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.cid);
+		break;
+	case TGT_KEVENT_TSK_MGMT_REQ:
+		target_mgmt_request(ev->k.cmd_req.host_no,
+				    ev->k.tsk_mgmt_req.mid,
+				    ev->k.tsk_mgmt_req.function,
+				    ev->k.tsk_mgmt_req.lun,
+				    ev->k.tsk_mgmt_req.tag,
+				    kspace_send_tsk_mgmt);
+		break;
+	default:
+		eprintf("unknown event %u\n", ev->type);
+	}
+
 	hdr->status = 0;
 	kuring.idx++;
 



From tomo at mail.berlios.de  Thu Aug 17 01:58:11 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 17 Aug 2006 01:58:11 +0200
Subject: [Stgt-svn] r528 - trunk/patchset
Message-ID: <200608162358.k7GNwB69006635@sheep.berlios.de>

Author: tomo
Date: 2006-08-17 01:57:56 +0200 (Thu, 17 Aug 2006)
New Revision: 528

Added:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
   trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
Removed:
   trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   trunk/patchset/0005-scsi-target-kill-target-command-list.txt
Modified:
   trunk/patchset/README
Log:
Update the patchset (against James' scsi-rc-fixes tree).


Added: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,48 @@
+From 9286b9ae56bd63756c6f4e2993abf049c8f01153 Mon Sep 17 00:00:00 2001
+From: fujita <fujita at debian.localdomain>
+Date: Thu, 17 Aug 2006 06:56:32 +0900
+Subject: [PATCH 1/9] [PATCH] block layer: kill length alignment test in bin_map_user
+
+The tgt project is mapping in bios using bio_map_user. The current targets
+do not need their len to be aligned with a queue limit so this check is
+causing some problems. Note: pointers passed into the kernel are properly
+aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
+
+The major user, blk_bio_map_user checks for the len before mapping
+so it is not affected by this patch.
+
+And the semi-newly added user blk_rq_map_user_iov has been failing
+out when the len is not aligned properly so maybe people have been
+good and not sending misaligned lens or that path is not used very
+often and this change will not be very dangerous. st and sg do not
+check the length and we have not seen any problem reports from those
+wider used paths so this patch should be fairly safe - for mm
+and wider testing at least.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/fs/bio.c b/fs/bio.c
+index 6a0b9ad..6fe47ce 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,583 +0,0 @@
-Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
-From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
-Date: 1143376921 +0900
-
----
-
- drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
- drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
- drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
- drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
- 4 files changed, 142 insertions(+), 125 deletions(-)
-
-74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool->events[i].ext_list) {
- 			dma_free_coherent(hostdata->dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool->events[i].ext_list,
- 				  pool->events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd->sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd->data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_out_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd->data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_in_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd->data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd->data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd->buf_fmt = fmt << 4;
-+	else
-+		srp_cmd->buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i < num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i < num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd->data_out_format == SRP_NO_BUFFER) &&
--	    (cmd->data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd->buf_fmt >> 4;
-+	in_fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC && in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd->data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd->data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd->additional_data;
--		dma_unmap_single(dev, data->virtual_address, data->length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd->add_data;
-+		dma_unmap_single(dev, data->va, data->len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd->additional_data;
--		int num_mapped = indirect->head.length / 
--			sizeof(indirect->list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd->add_data;
-+		int num_mapped = indirect->table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped <= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &indirect->list[0]);
-+			unmap_sg_list(num_mapped, dev, &indirect->desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i < num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &sg[i];
--		descr->virtual_address = sg_dma_address(sg_entry);
--		descr->length = sg_dma_len(sg_entry);
--		descr->memory_handle = 0;
-+		descr->va = sg_dma_address(sg_entry);
-+		descr->len = sg_dma_len(sg_entry);
-+		descr->key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd->request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data->virtual_address = sg_dma_address(&sg[0]);
--		data->length = sg_dma_len(&sg[0]);
--		data->memory_handle = 0;
-+		data->va = sg_dma_address(&sg[0]);
-+		data->len = sg_dma_len(&sg[0]);
-+		data->key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect->head.virtual_address = 0;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	indirect->head.memory_handle = 0;
-+	indirect->table_desc.va = 0;
-+	indirect->table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect->table_desc.key = 0;
- 
- 	if (sg_mapped <= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &indirect->list[0]);
--		indirect->total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &indirect->desc_list[0]);
-+		indirect->len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct->ext_list) {
--		evt_struct->ext_list =(struct memory_descriptor*)
-+		evt_struct->ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&evt_struct->ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &evt_struct->ext_list_token, 0);
- 		if (!evt_struct->ext_list) {
--		    printk(KERN_ERR
--		   	"ibmvscsi: Can't allocate memory for indirect table\n");
-+			printk(KERN_ERR
-+			       "ibmvscsi: Can't allocate memory for indirect table\n");
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct->ext_list);	
- 
--	indirect->total_length = total_length;
--	indirect->head.virtual_address = evt_struct->ext_list_token;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	memcpy(indirect->list, evt_struct->ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect->len = total_length;
-+	indirect->table_desc.va = evt_struct->ext_list_token;
-+	indirect->table_desc.len = sg_mapped * sizeof(indirect->desc_list[0]);
-+	memcpy(indirect->desc_list, evt_struct->ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
- 
--	data->virtual_address =
-+	data->va =
- 		dma_map_single(dev, cmd->request_buffer,
- 			       cmd->request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data->virtual_address)) {
-+	if (dma_mapping_error(data->va)) {
- 		printk(KERN_ERR
- 		       "ibmvscsi: Unable to map request_buffer for command!\n");
- 		return 0;
- 	}
--	data->length = cmd->request_bufflen;
--	data->memory_handle = 0;
-+	data->len = cmd->request_bufflen;
-+	data->key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct->xfer_iu = evt_struct->iu;
--	evt_struct->xfer_iu->srp.generic.tag = (u64)evt_struct;
-+	evt_struct->xfer_iu->srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &evt_struct->xfer_iu->srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct->cmnd;
- 
--	if (unlikely(rsp->type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp->opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: bad SRP RSP type %d\n",
--			       rsp->type);
-+			       rsp->opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd->result = rsp->status;
- 		if (((cmnd->result >> 1) & 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd->sense_buffer,
--			       rsp->sense_and_response_data,
--			       rsp->sense_data_list_length);
-+			       rsp->data,
-+			       rsp->sense_data_len);
- 		unmap_cmd_data(&evt_struct->iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct->hostdata->dev);
- 
--		if (rsp->doover)
--			cmnd->resid = rsp->data_out_residual_count;
--		else if (rsp->diover)
--			cmnd->resid = rsp->data_in_residual_count;
-+		if (rsp->flags & SRP_RSP_FLAG_DOOVER)
-+			cmnd->resid = rsp->data_out_res_cnt;
-+		else if (rsp->flags & SRP_RSP_FLAG_DIOVER)
-+			cmnd->resid = rsp->data_in_res_cnt;
- 	}
- 
- 	if (evt_struct->cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&cmnd->device->host->hostdata;
- 	u16 lun = lun_from_dev(cmnd->device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&hostdata->pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &evt_struct->iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd->type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd->opcode = SRP_CMD;
- 	memcpy(srp_cmd->cdb, cmnd->cmnd, sizeof(cmnd->cmnd));
- 	srp_cmd->lun = ((u64) lun) << 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct->cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd->additional_data;
--	if (((srp_cmd->data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd->data_in_format == SRP_INDIRECT_BUFFER)) &&
--	    (indirect->head.virtual_address == 0)) {
--		indirect->head.virtual_address = evt_struct->crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd->add_data;
-+	out_fmt = srp_cmd->buf_fmt >> 4;
-+	in_fmt = srp_cmd->buf_fmt & ((1U << 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &&
-+	    indirect->table_desc.va == 0) {
-+		indirect->table_desc.va = evt_struct->crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
--	switch (evt_struct->xfer_iu->srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct->xfer_iu->srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO "ibmvscsi: SRP_LOGIN_REJ reason %u\n",
- 		       evt_struct->xfer_iu->srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       "ibmvscsi: Invalid login response typecode 0x%02x!\n",
--		       evt_struct->xfer_iu->srp.generic.type);
-+		       evt_struct->xfer_iu->srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&hostdata->request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
- 
--	if (evt_struct->xfer_iu->srp.login_rsp.request_limit_delta >
-+	if (evt_struct->xfer_iu->srp.login_rsp.req_lim_delta >
- 	    (max_requests - 2))
--		evt_struct->xfer_iu->srp.login_rsp.request_limit_delta =
-+		evt_struct->xfer_iu->srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&hostdata->request_limit,
--		   evt_struct->xfer_iu->srp.login_rsp.request_limit_delta);
-+		   evt_struct->xfer_iu->srp.login_rsp.req_lim_delta);
- 
- 	hostdata->host->can_queue =
--	    evt_struct->xfer_iu->srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct->xfer_iu->srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata->host->can_queue < 1) {
- 		printk(KERN_ERR "ibmvscsi: Invalid request_limit_delta\n");
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &evt_struct->iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login->type = SRP_LOGIN_REQ_TYPE;
--	login->max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login->required_buffer_formats = 0x0006;
-+	login->opcode = SRP_LOGIN_REQ;
-+	login->req_it_iu_len = sizeof(union srp_iu);
-+	login->req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt->managed_task_tag = (u64) found_evt;
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt->task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO "ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n",
--	       tsk_mgmt->lun, tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->lun, tsk_mgmt->task_tag);
- 
- 	evt->sync_srp = &srp_rsp;
- 	init_completion(&evt->comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: abort bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       "ibmvscsi: abort code %d for task tag 0x%lx\n",
-+			       "ibmvscsi: abort code %d for task tag 0x%lx\n",
- 			       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
- 		printk(KERN_INFO
- 		       "ibmvscsi: aborted task tag 0x%lx completed\n",
--		       tsk_mgmt->managed_task_tag);
-+		       tsk_mgmt->task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       "ibmvscsi: successfully aborted task tag 0x%lx\n",
--	       tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->task_tag);
- 
- 	cmd->result = (DID_ABORT << 16);
- 	list_del(&found_evt->list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO "ibmvscsi: resetting device. lun 0x%lx\n",
- 	       tsk_mgmt->lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset code %d for task tag 0x%lx\n",
--		       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       rsp_rc, tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq->format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct->xfer_iu->srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct->xfer_iu->srp.rsp.req_lim_delta,
- 			   &hostdata->request_limit);
- 
- 	if (evt_struct->done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include <linux/dma-mapping.h>
- #include <linux/interrupt.h>
- #include "ibmvscsi.h"
--#include "srp.h"
- 
- static char partition_name[97] = "UNKNOWN";
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include "srp.h"
-+#include <scsi/srp.h>
-+
-+#define SRP_VERSION "16.a"
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,
--- 
-1.1.3

Added: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,154 @@
+From 810f8fd6b5ad802477ad9a95bbf6540c5d44f2de Mon Sep 17 00:00:00 2001
+From: fujita <fujita at debian.localdomain>
+Date: Thu, 17 Aug 2006 07:31:59 +0900
+Subject: [PATCH 2/9] [PATCH] block layer: add partial mappings support to bio_map_user
+
+For target mode we could end up with the case where we get very large
+request from the initiator. The request could be so large that we
+cannot transfer all the data in one operation. For example the
+HBA's segment or max_sector limits might limit us to a 1 MB transfer.
+To send a 5 MB command then we need to transfer the command chunk by chunk.
+
+To do this, tgt core will map in as much data as possible into a bio,
+send this off, then when that transfer is completed we send off another
+request/bio. To be able to pack as much data into a bio as possible
+we need bio_map_user to support partially mapped bios.
+
+- bio_map_user_iov always allows partial mappings.
+
+- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
+if the bio is partially mapped.
+
+- Added a length argument to blk_rq_map_user_iov in order to avoid
+including sg.h in ll_rw_blk.c for struct sg_iovec.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
+ block/scsi_ioctl.c     |    3 ++-
+ fs/bio.c               |   14 +-------------
+ include/linux/blkdev.h |    3 ++-
+ 4 files changed, 23 insertions(+), 26 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 61d6b3c..aee4f4b 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+-	if (!IS_ERR(bio)) {
+-		rq->bio = rq->biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq->buffer = rq->data = NULL;
+-		rq->data_len = len;
+-		return 0;
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq->bio = rq->biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq->buffer = rq->data = NULL;
++	rq->data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq->bio = rq->biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq->buffer = rq->data = NULL;
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index b33eda2..b77e185 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
++					  hdr->dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
+diff --git a/fs/bio.c b/fs/bio.c
+index 6fe47ce..ade77bf 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
+ {
+ 	struct bio *bio;
+-	int len = 0, i;
+ 
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
+ 
+@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
+ 
+-	for (i = 0; i < iov_count; i++)
+-		len += iov[i].iov_len;
+-
+-	if (bio->bi_size == len)
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio->bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
+ 
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index aafe827..613a441 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,246 +0,0 @@
-Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
-From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
-Date: 1143377151 +0900
-
----
-
- drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
- 1 files changed, 0 insertions(+), 227 deletions(-)
- delete mode 100644 drivers/scsi/ibmvscsi/srp.h
-
-acbd74e89dc7bcf4e2596800e46a19378db44641
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION "16.a"
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
--- 
-1.1.3

Added: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,54 @@
+From 682da4d3e68a63d56a8a306b9e61ea0305be19d6 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Wed, 16 Aug 2006 08:23:21 +0900
+Subject: [PATCH 3/9] [PATCH] block layer: use blk_rq_bio_prep in init_request_from_bio
+
+Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
+blk_rq_bio_prep's flags copying. The first three bits have not been
+the same for some time so that has been broken. The user of
+blk_rq_bio_prep will setup the request flags so if it wanted failfast
+or to be a barrier it will set the correct flag itself.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ block/ll_rw_blk.c |   11 ++---------
+ 1 files changed, 2 insertions(+), 9 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index aee4f4b..3f46356 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
+ 
+ 	req->errors = 0;
+ 	req->hard_sector = req->sector = bio->bi_sector;
+-	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
+-	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
+-	req->nr_phys_segments = bio_phys_segments(req->q, bio);
+-	req->nr_hw_segments = bio_hw_segments(req->q, bio);
+-	req->buffer = bio_data(bio);	/* see ->buffer comment above */
+ 	req->waiting = NULL;
+-	req->bio = req->biotail = bio;
+ 	req->ioprio = bio_prio(bio);
+ 	req->rq_disk = bio->bi_bdev->bd_disk;
+ 	req->start_time = jiffies;
++
++	blk_rq_bio_prep(req->q, req, bio);
+ }
+ 
+ static int __make_request(request_queue_t *q, struct bio *bio)
+@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
+ 
+ void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
+ {
+-	/* first two bits are identical in rq->flags and bio->bi_rw */
+-	rq->flags |= (bio->bi_rw & 3);
+-
+ 	rq->nr_phys_segments = bio_phys_segments(q, bio);
+ 	rq->nr_hw_segments = bio_hw_segments(q, bio);
+ 	rq->current_nr_sectors = bio_cur_sectors(bio);
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,375 +0,0 @@
-Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
-
-This patch moves scsi_host_get_command and scsi_host_put_command to
-scsi_tgt_lib.c from scsi.c
-
-A target driver allocates scsi_cmnd structure via
-scsi_host_get_command, then pass it to tgt core via
-scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
-needs to allocate scsi_tgt_cmd structure (for tgt specific data).
-Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
-target drivers.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi.c         |  102 ++++------------------------------------
- drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
- include/scsi/scsi_cmnd.h    |    6 +-
- include/scsi/scsi_tgt.h     |    4 ++
- 4 files changed, 112 insertions(+), 109 deletions(-)
-
-b8f2574dbd844ac43602d9fa74e6196027528c63
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 9c22465..1d2fbe0 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
--
--/*
-- * Function:	scsi_host_get_command()
-- *
-- * Purpose:	Allocate and setup a scsi command block and blk request
-- *
-- * Arguments:	shost	- scsi host
-- *		data_dir - dma data dir
-- *		gfp_mask- allocator flags
-- *
-- * Returns:	The allocated scsi command structure.
-- *
-- * This should be called by target LLDs to get a command.
-- */
--struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
--					enum dma_data_direction data_dir,
--					gfp_t gfp_mask)
--{
--	int write = (data_dir == DMA_TO_DEVICE);
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--
--	/* Bail if we can't get a reference to the device */
--	if (!get_device(&shost->shost_gendev))
--		return NULL;
--
--	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
--	if (!rq)
--		goto put_dev;
--
--	cmd = __scsi_get_command(shost, gfp_mask);
--	if (!cmd)
--		goto release_rq;
--
--	memset(cmd, 0, sizeof(*cmd));
--	cmd->sc_data_direction = data_dir;
--	cmd->jiffies_at_alloc = jiffies;
--	cmd->request = rq;
--
--	rq->special = cmd;
--	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
--
--	return cmd;
--
--release_rq:
--	blk_put_request(rq);
--put_dev:
--	put_device(&shost->shost_gendev);
--	return NULL;
--
--}
--EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
--/*
-- * Function:	scsi_host_put_command()
-- *
-- * Purpose:	Free a scsi command block
-- *
-- * Arguments:	shost	- scsi host
-- * 		cmd	- command block to free
-- *
-- * Returns:	Nothing.
-- *
-- * Notes:	The command must not belong to any lists.
-- */
--void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
- {
--	struct request_queue *q = shost->uspace_req_q;
--	struct request *rq = cmd->request;
- 	unsigned long flags;
- 
- 	/* changing locks here, don't need to restore the irq state */
-@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
- 		list_add(&cmd->list, &shost->free_list);
- 		cmd = NULL;
- 	}
--	spin_unlock(&shost->free_list_lock);
--
--	spin_lock(q->queue_lock);
--	__blk_put_request(q, rq);
--	spin_unlock_irqrestore(q->queue_lock, flags);
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
- 
- 	if (likely(cmd != NULL))
- 		kmem_cache_free(shost->cmd_pool->slab, cmd);
- 
--	put_device(&shost->shost_gendev);
-+	put_device(dev);
- }
--EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+EXPORT_SYMBOL(__scsi_put_command);
- 
- /*
-  * Function:	scsi_put_command()
-@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
--
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index aea3e4d..e82340c 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
- 	struct list_head cmd_req;
- };
- 
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq->end_io_data = tcmd;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+static void scsi_host_put_command(struct Scsi_Host *shost,
-+				  struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q->queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-+}
-+
- static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
- {
- 	struct bio *bio;
-@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
- 		cmd->request->flags &= ~1UL;
- 
- 	scsi_unmap_user_pages(tcmd);
--	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
- }
- 
-@@ -177,13 +265,13 @@ out:
- 		goto retry;
- }
- 
--/**
-+/*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-  *
-  * This should be called by the LLD after host allocation.
-  * And will be released when the host is released.
-- **/
-+ */
- int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
- {
- 	struct scsi_tgt_queuedata *queuedata;
-@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
- 
--/**
-+/*
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-  * @noblock:	set to nonzero if the command should be queued
-- **/
-+ */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
- 	struct request_queue *q = cmd->request->q;
- 	struct scsi_tgt_queuedata *qdata = q->queuedata;
- 	unsigned long flags;
--	struct scsi_tgt_cmd *tcmd;
--
--	/*
--	 * It would be better to allocate scsi_tgt_cmd structure in
--	 * scsi_host_get_command and not to fail due to OOM.
--	 */
--	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
--	if (!tcmd)
--		return -ENOMEM;
--	cmd->request->end_io_data = tcmd;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
- 
- 	bio_list_init(&tcmd->xfer_list);
- 	bio_list_init(&tcmd->xfer_done_list);
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 51156c7..c822bc2 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -150,11 +150,11 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
--extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
--					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
--extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-index 2d65be7..61e8ee9 100644
---- a/include/scsi/scsi_tgt.h
-+++ b/include/scsi/scsi_tgt.h
-@@ -2,6 +2,8 @@
-  * SCSI target definitions
-  */
- 
-+#include <linux/dma-mapping.h>
-+
- struct Scsi_Host;
- struct scsi_cmnd;
- struct scsi_lun;
-@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
- extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
- extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
- 				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
--- 
-1.1.3

Added: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,306 @@
+From 26dc82d471a4e83acec09789c8da6cc7fa788c89 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:39:42 +0900
+Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+This patch contains the needed changes to the scsi-ml to support targets.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/hosts.c     |    4 ++++
+ drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
+ include/scsi/scsi_cmnd.h |    7 +++++++
+ include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 104 insertions(+), 26 deletions(-)
+
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index dfcb96f..341c1ee 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
+ 		kthread_stop(shost->ehandler);
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
+ 
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index b332cad..08f8597 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&dev->sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
++{
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(dev);
++}
++EXPORT_SYMBOL(__scsi_put_command);
++
+ /*
+  * Function:	scsi_put_command()
+  *
+@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd->device;
+-	struct Scsi_Host *shost = sdev->host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&cmd->device->list_lock, flags);
+ 	BUG_ON(list_empty(&cmd->list));
+ 	list_del_init(&cmd->list);
+-	spin_unlock(&cmd->device->list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&shost->free_list_lock);
+-	if (unlikely(list_empty(&shost->free_list))) {
+-		list_add(&cmd->list, &shost->free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
+ 
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost->cmd_pool->slab, cmd);
+-
+-	put_device(&sdev->sdev_gendev);
++	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 077c1c6..ea22612 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -734,7 +734,9 @@ #endif
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 58e6444..254a904 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@ #include <linux/timer.h>
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ 
+ 
+@@ -133,7 +134,10 @@ #define SCSI_STATE_MLQUEUE         0x100
+ 
+ 
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
+ extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
+@@ -142,4 +146,7 @@ extern void *scsi_kmap_atomic_sg(struct 
+ 				 size_t *offset, size_t *len);
+ extern void scsi_kunmap_atomic_sg(void *virt);
+ 
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
++
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index b3dd90f..1a393b6 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@ #include <linux/types.h>
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -122,6 +123,39 @@ #endif
+ 	int (* queuecommand)(struct scsi_cmnd *,
+ 			     void (*done)(struct scsi_cmnd *));
+ 
++ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
+ 	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+@@ -561,6 +595,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++						void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.4.1.1
+

Deleted: trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,554 +0,0 @@
-Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
-
-The user-space damoen and tgt kernel module need to exhange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch replaces netlink shared memory between kernel and user
-spaces. The user-space damoen and tgt kernel module creates shared
-memory via mmap and use it like ring buffer. poll (kernel to user) and
-write (user to kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
- drivers/scsi/scsi_tgt_lib.c  |   10 +
- drivers/scsi/scsi_tgt_priv.h |    6 -
- include/linux/netlink.h      |    1 
- include/scsi/scsi_tgt_if.h   |   19 +--
- 5 files changed, 216 insertions(+), 131 deletions(-)
-
-cd29acfca7cdeb8c351db14af357207e9dcb17f3
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-index 37e0feb..c4c5bdb 100644
---- a/drivers/scsi/scsi_tgt_if.c
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -21,7 +21,6 @@
-  */
- #include <linux/blkdev.h>
- #include <linux/file.h>
--#include <linux/netlink.h>
- #include <net/tcp.h>
- #include <scsi/scsi.h>
- #include <scsi/scsi_cmnd.h>
-@@ -32,87 +31,129 @@
- 
- #include "scsi_tgt_priv.h"
- 
--static int tgtd_pid;
--static struct sock *nl_sk;
-+struct rbuf {
-+	u32 idx;
-+	u32 nr_entry;
-+	int entry_size;
-+	char *buf;
-+	int buf_size;
-+	spinlock_t lock;
-+};
-+
-+static int chrdev;
-+static struct rbuf txbuf, rxbuf;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
- 
--static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
--			  pid_t pid)
-+static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-+{
-+	u32 offset = (idx & (rbuf->nr_entry - 1)) * rbuf->entry_size;
-+	return (struct rbuf_hdr *) (rbuf->buf + offset);
-+}
-+
-+static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-+{
-+	int i;
-+
-+	esize += sizeof(struct rbuf_hdr);
-+	rbuf->idx = 0;
-+	rbuf->entry_size = esize;
-+	rbuf->buf = buf;
-+	spin_lock_init(&rbuf->lock);
-+
-+	bsize /= esize;
-+	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
-+		;
-+	rbuf->nr_entry = 1 << i;
-+}
-+
-+static int send_event_rsp(u32 type, struct tgt_event *p)
- {
- 	struct tgt_event *ev;
--	struct nlmsghdr *nlh;
--	struct sk_buff *skb;
--	uint32_t len;
--
--	len = NLMSG_SPACE(sizeof(*ev));
--	skb = alloc_skb(len, flags);
--	if (!skb)
--		return -ENOMEM;
-+	struct rbuf_hdr *hdr;
-+	struct page *sp, *ep;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&txbuf.lock, flags);
-+
-+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx);
-+	if (hdr->status)
-+		err = 1;
-+	else
-+		txbuf.idx++;
- 
--	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+	spin_unlock_irqrestore(&txbuf.lock, flags);
- 
--	ev = NLMSG_DATA(nlh);
-+	if (err)
-+		return err;
-+
-+	ev = (struct tgt_event *) hdr->data;
- 	memcpy(ev, p, sizeof(*ev));
-+	ev->type = type;
-+	hdr->status = 1;
-+	mb();
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-+	for (;sp <= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	wake_up_interruptible(&tgt_poll_wait);
- 
--	return netlink_unicast(nl_sk, skb, pid, 0);
-+	return 0;
- }
- 
--int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
--			 gfp_t flags)
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
--	struct sk_buff *skb;
--	struct nlmsghdr *nlh;
--	struct tgt_event *ev;
--	int err, len;
-+	struct tgt_event ev;
-+	int err;
- 
--	len = NLMSG_SPACE(sizeof(*ev));
--	/*
--	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
--	 */
--	skb = alloc_skb(NLMSG_SPACE(len), flags);
--	if (!skb)
--		return -ENOMEM;
--
--	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
--			  len - sizeof(*nlh), 0);
--
--	ev = NLMSG_DATA(nlh);
--	ev->k.cmd_req.host_no = shost->host_no;
--	ev->k.cmd_req.cid = cmd->request->tag;
--	ev->k.cmd_req.data_len = cmd->request_bufflen;
--	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
--	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
--	ev->k.cmd_req.attribute = cmd->tag;
--	ev->k.cmd_req.tag = tag;
--
--	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev->k.cmd_req.cid,
--		ev->k.cmd_req.data_len, cmd->tag,
--		(unsigned long long) ev->k.cmd_req.tag);
--
--	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
--	if (err < 0)
--		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
--		       err);
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost->host_no;
-+	ev.k.cmd_req.cid = cmd->request->tag;
-+	ev.k.cmd_req.data_len = cmd->request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd->tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
- 	return err;
- }
- 
--int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&ev, 0, sizeof(ev));
- 	ev.k.cmd_done.host_no = shost->host_no;
- 	ev.k.cmd_done.cid = cmd->request->tag;
- 	ev.k.cmd_done.result = cmd->result;
- 
--	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
-+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+	return err;
- }
- 
- int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
- 				  struct scsi_lun *scsilun, void *data)
- {
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&ev, 0, sizeof(ev));
- 	ev.k.tsk_mgmt_req.host_no = host_no;
-@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
- 	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
- 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
- 
--	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev, GFP_KERNEL, tgtd_pid);
-+	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+	return err;
- }
- 
--static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+static int event_recv_msg(struct tgt_event *ev)
- {
--	struct tgt_event *ev = NLMSG_DATA(nlh);
- 	int err = 0;
- 
--	dprintk("%d %d %d\n", nlh->nlmsg_type,
--		nlh->nlmsg_pid, current->pid);
--
--	switch (nlh->nlmsg_type) {
--	case TGT_UEVENT_REQ:
--		tgtd_pid = NETLINK_CREDS(skb)->pid;
--		break;
-+	switch (ev->type) {
- 	case TGT_UEVENT_CMD_RSP:
--		/* TODO: handle multiple cmds in one event */
- 		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
- 					   ev->u.cmd_rsp.cid,
- 					   ev->u.cmd_rsp.result,
-@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
- 					       ev->u.tsk_mgmt_rsp.result);
- 		break;
- 	default:
--		eprintk("unknown type %d\n", nlh->nlmsg_type);
-+		eprintk("unknown type %d\n", ev->type);
- 		err = -EINVAL;
- 	}
- 
- 	return err;
- }
- 
--static int event_recv_skb(struct sk_buff *skb)
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
- {
--	int err;
--	uint32_t rlen;
--	struct nlmsghdr	*nlh;
--	struct tgt_event ev;
-+	struct rbuf_hdr *hdr;
-+	struct tgt_event *ev;
-+	struct page *sp, *ep;
- 
--	while (skb->len >= NLMSG_SPACE(0)) {
--		nlh = (struct nlmsghdr *) skb->data;
--		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
--			return 0;
--		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
--		if (rlen > skb->len)
--			rlen = skb->len;
--		err = event_recv_msg(skb, nlh);
--
--		dprintk("%d %d\n", nlh->nlmsg_type, err);
--		/*
--		 * TODO for passthru commands the lower level should
--		 * probably handle the result or we should modify this
--		 */
--		switch (nlh->nlmsg_type) {
--		case TGT_UEVENT_CMD_RSP:
--		case TGT_UEVENT_TSK_MGMT_RSP:
--			break;
--		default:
--			memset(&ev, 0, sizeof(ev));
--			ev.k.event_rsp.err = err;
--			send_event_rsp(TGT_KEVENT_RSP, &ev,
--				       GFP_KERNEL | __GFP_NOFAIL,
--					nlh->nlmsg_pid);
--		}
--		skb_pull(skb, rlen);
--	}
--	return 0;
-+retry:
-+	hdr = head_rbuf_hdr(&rxbuf, rxbuf.idx);
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-+	for (;sp <= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	if (!hdr->status)
-+		return count;
-+
-+	rxbuf.idx++;
-+	ev = (struct tgt_event *) hdr->data;
-+	event_recv_msg(ev);
-+	hdr->status = 0;
-+
-+	goto retry;
- }
- 
--static void event_recv(struct sock *sk, int length)
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
- {
--	struct sk_buff *skb;
-+	struct rbuf_hdr *hdr;
-+	unsigned long flags;
-+	unsigned int mask = 0;
- 
--	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
--		if (NETLINK_CREDS(skb)->uid) {
--			skb_pull(skb, skb->len);
--			kfree_skb(skb);
--			continue;
--		}
-+	poll_wait(file, &tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&txbuf.lock, flags);
- 
--		if (event_recv_skb(skb) && skb->len)
--			skb_queue_head(&sk->sk_receive_queue, skb);
--		else
--			kfree_skb(skb);
-+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx - 1);
-+	if (hdr->status)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&txbuf.lock, flags);
-+
-+	return mask;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long size, addr;
-+	struct page *page;
-+	int err, i;
-+
-+	if (vma->vm_pgoff) {
-+		eprintk("bug\n");
-+		return -EINVAL;
-+	}
-+
-+	size = vma->vm_end - vma->vm_start;
-+	if (size != TGT_RINGBUF_SIZE * 2) {
-+		eprintk("%lu\n", size);
-+		return -EINVAL;
-+	}
-+	addr = vma->vm_start;
-+	page = virt_to_page(txbuf.buf);
-+	for (i = 0; i < size >> PAGE_SHIFT; i++) {
-+		err = vm_insert_page(vma, addr, page);
-+		if (err) {
-+			eprintk("%d %d %lu\n", err, i, addr);
-+			return -EINVAL;
-+		}
-+		addr += PAGE_SIZE;
-+		page++;
- 	}
-+
-+	return 0;
- }
- 
-+static struct file_operations tgt_fops = {
-+	.owner	= THIS_MODULE,
-+	.poll	= tgt_poll,
-+	.write	= tgt_write,
-+	.mmap	= tgt_mmap,
-+};
-+
- void __exit scsi_tgt_if_exit(void)
- {
--	sock_release(nl_sk->sk_socket);
-+	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-+
-+	unregister_chrdev(chrdev, "tgt");
-+	free_pages((unsigned long) txbuf.buf, order);
- }
- 
- int __init scsi_tgt_if_init(void)
- {
--	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
--				    THIS_MODULE);
--	if (!nl_sk)
--		return -ENOMEM;
-+	u32 bsize = TGT_RINGBUF_SIZE;
-+	int order;
-+	char *buf;
-+
-+	chrdev = register_chrdev(0, "tgt", &tgt_fops);
-+	if (chrdev < 0)
-+		return chrdev;
-+
-+	order = long_log2((bsize * 2) >> PAGE_SHIFT);
-+	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-+					order);
-+	if (!buf)
-+		goto free_dev;
-+	rbuf_init(&txbuf, buf, bsize, sizeof(struct tgt_event));
-+	rbuf_init(&rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
- 
- 	return 0;
-+
-+free_dev:
-+	unregister_chrdev(chrdev, "tgt");
-+
-+	return -ENOMEM;
- }
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index e82340c..7ebfbc0 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -246,7 +246,7 @@ retry:
- 	tcmd = rq->end_io_data;
- 	init_scsi_tgt_cmd(rq, tcmd);
- 	cmd = rq->special;
--	err = scsi_tgt_uspace_send(cmd, tcmd->lun, tcmd->tag, GFP_ATOMIC);
-+	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
- 	if (err < 0) {
- 		eprintk("failed to send: %p %d\n", cmd, err);
- 
-@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
- 
- 	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
- 
--	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+	scsi_tgt_uspace_send_status(cmd);
- 	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
- 	queue_work(scsi_tgtd, &tcmd->work);
- }
-@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
- 		return;
- 
- 	cmd->result = DID_BUS_BUSY << 16;
--	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+	err = scsi_tgt_uspace_send_status(cmd);
-+	if (err <= 0)
- 		/* the eh will have to pick this up */
- 		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
- }
-@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
- 	/* should we free resources here on error ? */
- 	if (cmd->result) {
- send_uspace_err:
--		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+		err = scsi_tgt_uspace_send_status(cmd);
-+		if (err <= 0)
- 			/* the tgt uspace eh will have to pick this up */
- 			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
- 		return;
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-index 77a1d06..bd16a2c 100644
---- a/drivers/scsi/scsi_tgt_priv.h
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -14,9 +14,9 @@ do {								\
- extern void scsi_tgt_if_exit(void);
- extern int scsi_tgt_if_init(void);
- 
--extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
--				u64 tag, gfp_t flags);
--extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
- extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
- 				unsigned long uaddr, u8 rw);
- extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 9422ae5..c256ebe 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,7 +21,6 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
--#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-index 63b2e3a..74392a9 100644
---- a/include/scsi/scsi_tgt_if.h
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -24,25 +24,20 @@
- 
- enum tgt_event_type {
- 	/* user -> kernel */
--	TGT_UEVENT_REQ,
- 	TGT_UEVENT_CMD_RSP,
- 	TGT_UEVENT_TSK_MGMT_RSP,
- 
- 	/* kernel -> user */
--	TGT_KEVENT_RSP,
- 	TGT_KEVENT_CMD_REQ,
- 	TGT_KEVENT_CMD_DONE,
- 	TGT_KEVENT_TSK_MGMT_REQ,
- };
- 
- struct tgt_event {
-+	uint32_t type;
- 	/* user-> kernel */
- 	union {
- 		struct {
--			int type;
--			int host_no;
--		} event_req;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t len;
-@@ -60,9 +55,6 @@ struct tgt_event {
- 	/* kernel -> user */
- 	union {
- 		struct {
--			int err;
--		} event_rsp;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t data_len;
-@@ -86,4 +78,13 @@ struct tgt_event {
- 	} k;
- 
- } __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RINGBUF_SIZE (1UL << 16)
-+
-+struct rbuf_hdr {
-+	uint32_t status;
-+	uint32_t len;
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
- #endif
--- 
-1.1.3

Deleted: trunk/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,197 +0,0 @@
-Subject: [PATCH] scsi target: kill target command list
-
-scsi_tgt_queue_command just adds a command to the list and then kernel
-thread sends it to user space because scsi_tgt_queue_command cannot
-use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
-
-Now we don't use netlink any more. So we can kill the list and
-scsi_tgt_queue_command just sends a command to user space.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
- 1 files changed, 24 insertions(+), 82 deletions(-)
-
-0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index 7ebfbc0..5c66f10 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
- 	/* TODO replace the lists with a large bio */
- 	struct bio_list xfer_done_list;
- 	struct bio_list xfer_list;
--	struct scsi_lun *lun;
- 
- 	struct list_head hash_list;
- 	struct request *rq;
--	u64 tag;
- 
- 	void *buffer;
- 	unsigned bufflen;
-@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
- 	struct Scsi_Host *shost;
- 	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
- 	spinlock_t cmd_hash_lock;
--
--	struct work_struct uspace_send_work;
--
--	spinlock_t cmd_req_lock;
--	struct mutex cmd_req_mutex;
--	struct list_head cmd_req;
- };
- 
- /*
-@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
- 	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
- 	rq->end_io_data = tcmd;
- 
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+	tcmd->rq = rq;
-+
- 	return cmd;
- 
- release_rq:
-@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
- 	}
- }
- 
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_del(&tcmd->hash_list);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
- static void scsi_tgt_cmd_destroy(void *data)
- {
- 	struct scsi_cmnd *cmd = data;
- 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
--	struct scsi_tgt_queuedata *qdata = cmd->request->q->queuedata;
--	unsigned long flags;
- 
- 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
- 		rq_data_dir(cmd->request));
- 
--	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
--	list_del(&tcmd->hash_list);
--	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+	cmd_hashlist_del(cmd);
- 
- 	/*
- 	 * We must set rq->flags here because bio_map_user and
-@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
- 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
- }
- 
--static void scsi_tgt_uspace_send_fn(void *data)
--{
--	struct request_queue *q = data;
--	struct scsi_tgt_queuedata *qdata = q->queuedata;
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--	struct scsi_tgt_cmd *tcmd;
--	unsigned long flags;
--	int err;
--
--retry:
--	err = 0;
--	if (list_empty(&qdata->cmd_req))
--		return;
--
--	mutex_lock(&qdata->cmd_req_mutex);
--
--	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--	if (list_empty(&qdata->cmd_req)) {
--		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--		mutex_unlock(&qdata->cmd_req_mutex);
--		goto out;
--	}
--	rq = list_entry_rq(qdata->cmd_req.next);
--	list_del_init(&rq->queuelist);
--	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--
--	tcmd = rq->end_io_data;
--	init_scsi_tgt_cmd(rq, tcmd);
--	cmd = rq->special;
--	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
--	if (err < 0) {
--		eprintk("failed to send: %p %d\n", cmd, err);
--
--		spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--		list_add(&rq->queuelist, &qdata->cmd_req);
--		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--	}
--
--	mutex_unlock(&qdata->cmd_req_mutex);
--out:
--	/* TODO: proper error handling */
--	if (err < 0)
--		queue_delayed_work(scsi_tgtd, &qdata->uspace_send_work,
--				   HZ / 10);
--	else
--		goto retry;
--}
--
- /*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
- 		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
- 	spin_lock_init(&queuedata->cmd_hash_lock);
- 
--	INIT_LIST_HEAD(&queuedata->cmd_req);
--	spin_lock_init(&queuedata->cmd_req_lock);
--	INIT_WORK(&queuedata->uspace_send_work, scsi_tgt_uspace_send_fn, q);
--	mutex_init(&queuedata->cmd_req_mutex);
--
- 	return 0;
- 
- cleanup_queue:
-@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-- * @noblock:	set to nonzero if the command should be queued
-+ * @tag:	unique value to identify this command for tmf
-  */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
--	struct request_queue *q = cmd->request->q;
--	struct scsi_tgt_queuedata *qdata = q->queuedata;
--	unsigned long flags;
- 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
- 
--	bio_list_init(&tcmd->xfer_list);
--	bio_list_init(&tcmd->xfer_done_list);
--	tcmd->lun = scsilun;
--	tcmd->tag = tag;
--	tcmd->rq = cmd->request;
--
--	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
--	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-+	init_scsi_tgt_cmd(cmd->request, tcmd);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
- 
--	queue_work(scsi_tgtd, &qdata->uspace_send_work);
--	return 0;
-+	return err;
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
- 
--- 
-1.1.3

Added: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,787 @@
+From 74646b3cdc53f2f8bee28d5d5533b08ef93253c2 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:42:16 +0900
+Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
+
+The core scsi target lib functions.
+
+TODO:
+- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
+do that weird include.
+- convert scsi_tgt_cmd's work struct to James's execute code. And try
+to kill our scsi_tgt_cmd.
+- add host state checking. We do refcouting so hotplug is partially
+supported, but we need to add state checking to make it easier on
+the LLD.
+- must remove our request->flags hack
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/scsi_tgt_lib.c  |  699 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   24 +
+ include/scsi/scsi_tgt.h      |   17 +
+ 3 files changed, 740 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..f7ae7e2
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,699 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/hash.h>
++#include <linux/module.h>
++#include <linux/pagemap.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <../drivers/md/dm-bio-list.h>
++
++#include "scsi_tgt_priv.h"
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++
++	struct list_head hash_list;
++	struct request *rq;
++	u64 tag;
++
++	void *buffer;
++	unsigned bufflen;
++	unsigned offset; /* we need this ? */
++};
++
++#define TGT_HASH_ORDER	4
++#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
++	spinlock_t cmd_hash_lock;
++};
++
++/*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		goto put_dev;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto free_tcmd;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++	rq->end_io_data = tcmd;
++
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++	tcmd->rq = rq;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++free_tcmd:
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++static void scsi_host_put_command(struct Scsi_Host *shost,
++				  struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
++	unsigned long flags;
++
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++
++	spin_lock_irqsave(q->queue_lock, flags);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	__scsi_put_command(shost, cmd, &shost->shost_gendev);
++}
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void cmd_hashlist_del(struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = cmd->request->q;
++	struct scsi_tgt_queuedata *qdata = q->queuedata;
++	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	list_del(&tcmd->hash_list);
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
++		rq_data_dir(cmd->request));
++
++	cmd_hashlist_del(cmd);
++
++	/*
++	 * We must set rq->flags here because bio_map_user and
++	 * blk_rq_bio_prep ruined ti.
++	 */
++	if (cmd->sc_data_direction == DMA_TO_DEVICE)
++		cmd->request->flags |= 1;
++	else
++		cmd->request->flags &= ~1UL;
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
++			      u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
++	unsigned long flags;
++	struct list_head *head;
++
++	tcmd->tag = tag;
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	head = &qdata->cmd_hash[cmd_hashfn(tag)];
++	list_add(&tcmd->hash_list, head);
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++}
++
++/*
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ */
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err, i;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, NULL);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata->shost = shost;
++	q->queuedata = queuedata;
++
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q->nr_requests = shost->hostt->can_queue;
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost->uspace_req_q = q;
++
++	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
++		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
++	spin_lock_init(&queuedata->cmd_hash_lock);
++
++	return 0;
++
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
++	return queue->shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/*
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @tag:	unique value to identify this command for tmf
++ */
++int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			   u64 tag)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	int err;
++
++	init_scsi_tgt_cmd(cmd->request, tcmd, tag);
++	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
++	if (err)
++		cmd_hashlist_del(cmd);
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &tcmd->work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd->result = DID_BUS_BUSY << 16;
++	err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++	if (err <= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd->request;
++	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
++	int count;
++
++	cmd->use_sg = rq->nr_phys_segments;
++	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd->request_buffer)
++		return -ENOMEM;
++
++	cmd->request_bufflen = rq->data_len;
++
++	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
++		rq_data_dir(rq));
++	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
++	if (likely(count <= cmd->use_sg)) {
++		cmd->use_sg = count;
++		return 0;
++	}
++
++	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd->request->q;
++	struct request *rq = cmd->request;
++	void *uaddr = tcmd->buffer;
++	unsigned int len = tcmd->bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len > 0) {
++		dprintk("%lx %u\n", (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk("fail to map %lx %u %d %x\n",
++				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
++			goto unmap_bios;
++		}
++
++		uaddr += bio->bi_size;
++		len -= bio->bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq->bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq->data_len = bio->bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&tcmd->xfer_list, bio);
++	}
++
++	tcmd->offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq->bio) {
++		bio_unmap_user(rq->bio);
++		while ((bio = bio_list_pop(&tcmd->xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd->result) {
++send_uspace_err:
++		err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++		if (err <= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++		return;
++	}
++
++	dprintk("cmd %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, tcmd->bufflen);
++
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
++
++	tcmd->buffer += cmd->request_bufflen;
++	tcmd->offset += cmd->request_bufflen;
++
++	if (!tcmd->xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, tcmd->bufflen);
++
++	bio = bio_list_pop(&tcmd->xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
++	cmd->request->data_len = bio->bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd->result = DID_ERROR << 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd->result = DID_NO_CONNECT << 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd->sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR "Could not copy the sense buffer\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = host->hostt->eh_abort_handler(cmd);
++	if (err)
++		eprintk("fail to abort %p\n", cmd);
++
++	scsi_tgt_cmd_destroy(cmd);
++	return err;
++}
++
++static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = q->queuedata;
++	struct request *rq = NULL;
++	struct list_head *head;
++	struct scsi_tgt_cmd *tcmd;
++	unsigned long flags;
++
++	head = &qdata->cmd_hash[cmd_hashfn(tag)];
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	list_for_each_entry(tcmd, head, hash_list) {
++		if (tcmd->tag == tag) {
++			rq = tcmd->rq;
++			break;
++		}
++	}
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++
++	return rq;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++			 unsigned long uaddr, u8 rw)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	struct scsi_tgt_cmd *tcmd;
++	int err = 0;
++
++	dprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,
++		result, len, uaddr, rw);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++
++	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
++	if (!rq) {
++		printk(KERN_ERR "Could not find tag %llu\n",
++		       (unsigned long long) tag);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq->special;
++
++	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
++		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
++
++	if (result == TASK_ABORTED) {
++		scsi_tgt_abort_cmd(shost, cmd);
++		goto done;
++	}
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	tcmd = cmd->request->end_io_data;
++	tcmd->buffer = (void *)uaddr;
++	tcmd->bufflen = len;
++	cmd->result = result;
++
++	if (!tcmd->bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
++	if (err) {
++		eprintk("%p %d\n", cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd->result) {
++		if (status_byte(cmd->result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
++			      struct scsi_lun *scsilun, void *data)
++{
++	int err;
++
++	/* TODO: need to retry if this fails. */
++	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
++					    tag, scsilun, data);
++	if (err < 0)
++		eprintk("The task management request lost!\n");
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
++
++int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
++{
++	struct Scsi_Host *shost;
++	int err;
++
++	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
++
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++	err = shost->hostt->tsk_mgmt_response(mid, result);
++	scsi_host_put(shost);
++
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue("scsi_tgtd");
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION("SCSI target core");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..b7b6ea6
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,24 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define dprintk eprintk
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				    u64 tag);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
++extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++				unsigned long uaddr, u8 rw);
++extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++					 struct scsi_lun *scsilun, void *data);
++extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..61e8ee9
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,17 @@
++/*
++ * SCSI target definitions
++ */
++
++#include <linux/dma-mapping.h>
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
+-- 
+1.4.1.1
+

Added: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,481 @@
+From c4e930538407cf31b2eb9f718685cd07e4070569 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:44:21 +0900
+Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
+
+The user-space damoen and tgt kernel module need to exhange mmapped
+addresses. netlink cannot do that. We need two-way kernel/user
+high-performance interface, however, mainline kernel provides no
+standard interface like that.
+
+This patch addes shared memory interface between kernel and user
+spaces like some other drivers do. The user-space damoen and tgt
+kernel module creates shared memory via mmap and use it like ring
+buffer. poll (kernel to user) and write (user to kernel) system calls
+are used for notification.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+---
+ drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/scsi_tgt_if.h |   93 ++++++++++++
+ 2 files changed, 443 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..09c4ab1
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,350 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/miscdevice.h>
++#include <linux/file.h>
++#include <net/tcp.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/scsi_tgt_if.h>
++
++#include "scsi_tgt_priv.h"
++
++struct tgt_ring {
++	u32 tr_idx;
++	unsigned long tr_pages[TGT_RING_PAGES];
++	spinlock_t tr_lock;
++};
++
++/* tx_ring : kernel->user, rx_ring : user->kernel */
++static struct tgt_ring tx_ring, rx_ring;
++static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
++
++static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
++{
++	if (ring->tr_idx == TGT_MAX_EVENTS - 1)
++		ring->tr_idx = 0;
++	else
++		ring->tr_idx++;
++}
++
++static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
++{
++	u32 pidx, off;
++
++	pidx = idx / TGT_EVENT_PER_PAGE;
++	off = idx % TGT_EVENT_PER_PAGE;
++
++	return (struct tgt_event *)
++		(ring->tr_pages[pidx] + sizeof(struct tgt_event) * off);
++}
++
++static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &tx_ring;
++	unsigned long flags;
++	int err = 0;
++
++	spin_lock_irqsave(&ring->tr_lock, flags);
++
++	ev = tgt_head_event(ring, ring->tr_idx);
++	if (ev->status == TGT_EVENT_STATUS_EMPTY)
++		tgt_ring_idx_inc(ring);
++	else
++		err = -BUSY;
++
++	spin_unlock_irqrestore(&ring->tr_lock, flags);
++
++	if (err)
++		return err;
++
++	memcpy(ev, p, sizeof(*ev));
++	ev->type = type;
++	ev->status = TGT_EVENT_STATUS_USED;
++	mb();
++
++	flush_dcache_page(virt_to_page(ev));
++
++	wake_up_interruptible(&tgt_poll_wait);
++
++	return 0;
++}
++
++int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_req.host_no = shost->host_no;
++	ev.k.cmd_req.data_len = cmd->request_bufflen;
++	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
++	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
++	ev.k.cmd_req.attribute = cmd->tag;
++	ev.k.cmd_req.tag = tag;
++
++	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
++		ev.k.cmd_req.data_len, cmd->tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost->host_no;
++	ev.k.cmd_done.tag = tag;
++	ev.k.cmd_done.result = cmd->result;
++
++	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
++		(unsigned long long) ev.k.cmd_req.tag,
++		ev.k.cmd_req.data_len, cmd->tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++				  struct scsi_lun *scsilun, void *data)
++{
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.tsk_mgmt_req.host_no = host_no;
++	ev.k.tsk_mgmt_req.function = function;
++	ev.k.tsk_mgmt_req.tag = tag;
++	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
++	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
++
++	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
++		(unsigned long long) ev.k.tsk_mgmt_req.mid);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++static int event_recv_msg(struct tgt_event *ev)
++{
++	int err = 0;
++
++	switch (ev->type) {
++	case TGT_UEVENT_CMD_RSP:
++		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
++					   ev->u.cmd_rsp.tag,
++					   ev->u.cmd_rsp.result,
++					   ev->u.cmd_rsp.len,
++					   ev->u.cmd_rsp.uaddr,
++					   ev->u.cmd_rsp.rw);
++		break;
++	case TGT_UEVENT_TSK_MGMT_RSP:
++		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
++					       ev->u.tsk_mgmt_rsp.mid,
++					       ev->u.tsk_mgmt_rsp.result);
++		break;
++	default:
++		eprintk("unknown type %d\n", ev->type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static ssize_t tgt_write(struct file *file, const char __user * buffer,
++			 size_t count, loff_t * ppos)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &rx_ring;
++
++	while (1) {
++		ev = tgt_head_event(ring, ring->tr_idx);
++		if (ev->status == TGT_EVENT_STATUS_EMPTY)
++			break;
++
++		/* do we need this? */
++		flush_dcache_page(virt_to_page(ev));
++
++		tgt_ring_idx_inc(ring);
++		ev->status = TGT_EVENT_STATUS_EMPTY;
++		event_recv_msg(ev);
++	};
++
++	return count;
++}
++
++static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &tx_ring;
++	unsigned long flags;
++	unsigned int mask = 0;
++	u32 idx;
++
++	poll_wait(file, &tgt_poll_wait, wait);
++
++	spin_lock_irqsave(&ring->tr_lock, flags);
++
++	idx = ring->tr_idx ? ring->tr_idx - 1 : TGT_MAX_EVENTS - 1;
++	ev = tgt_head_event(ring, idx);
++	if (ev->status == TGT_EVENT_STATUS_USED)
++		mask |= POLLIN | POLLRDNORM;
++
++	spin_unlock_irqrestore(&ring->tr_lock, flags);
++
++	return mask;
++}
++
++static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
++			   struct tgt_ring *ring)
++{
++	int i, err;
++
++	for (i = 0; i < TGT_RING_PAGES; i++) {
++		struct page *page = virt_to_page(ring->tr_pages[i]);
++		err = vm_insert_page(vma, addr, page);
++		if (err)
++			return err;
++		addr += PAGE_SIZE;
++	}
++
++	return 0;
++}
++
++static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	unsigned long addr;
++	int err;
++
++	if (vma->vm_pgoff)
++		return -EINVAL;
++
++	if (vma->vm_end - vma->vm_start != TGT_RING_SIZE * 2) {
++		eprintk("mmap size must be %lu, not %lu \n",
++			TGT_RING_SIZE * 2, vma->vm_end - vma->vm_start);
++		return -EINVAL;
++	}
++
++	addr = vma->vm_start;
++	err = uspace_ring_map(vma, addr, &tx_ring);
++	if (err)
++		return err;
++	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &rx_ring);
++
++	return err;
++}
++
++static int tgt_open(struct inode *inode, struct file *file)
++{
++	tx_ring.tr_idx = rx_ring.tr_idx = 0;
++
++	return 0;
++}
++
++static struct file_operations tgt_fops = {
++	.owner		= THIS_MODULE,
++	.open		= tgt_open,
++	.poll		= tgt_poll,
++	.write		= tgt_write,
++	.mmap		= tgt_mmap,
++};
++
++static struct miscdevice tgt_miscdev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = "tgt",
++	.fops = &tgt_fops,
++};
++
++static void tgt_ring_exit(struct tgt_ring *ring)
++{
++	int i;
++
++	for (i = 0; i < TGT_RING_PAGES; i++)
++		free_page(ring->tr_pages[i]);
++}
++
++static int tgt_ring_init(struct tgt_ring *ring)
++{
++	int i;
++
++	spin_lock_init(&ring->tr_lock);
++
++	for (i = 0; i < TGT_RING_PAGES; i++) {
++		ring->tr_pages[i] = get_zeroed_page(GFP_KERNEL);
++		if (!ring->tr_pages[i]) {
++			eprintk("out of memory\n");
++			return -ENOMEM;
++		}
++	}
++
++	return 0;
++}
++
++void scsi_tgt_if_exit(void)
++{
++	tgt_ring_exit(&tx_ring);
++	tgt_ring_exit(&rx_ring);
++	misc_deregister(&tgt_miscdev);
++}
++
++int scsi_tgt_if_init(void)
++{
++	int err;
++
++	err = tgt_ring_init(&tx_ring);
++	if (err)
++		return err;
++
++	err = tgt_ring_init(&rx_ring);
++	if (err)
++		goto free_tx_ring;
++
++	err = misc_register(&tgt_miscdev);
++	if (err)
++		goto free_rx_ring;
++
++	return 0;
++free_rx_ring:
++	tgt_ring_exit(&rx_ring);
++free_tx_ring:
++	tgt_ring_exit(&tx_ring);
++
++	return err;
++}
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..5671920
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,93 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_status {
++	TGT_EVENT_STATUS_EMPTY = 0,
++	TGT_EVENT_STATUS_USED,
++};
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
++
++	/* kernel -> user */
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
++};
++
++struct tgt_event {
++	uint32_t status;
++	uint32_t type;
++
++	/* user-> kernel */
++	union {
++		struct {
++			int host_no;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint8_t rw;
++			uint64_t tag;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			uint64_t mid;
++			int result;
++		} tsk_mgmt_rsp;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int host_no;
++			uint32_t data_len;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
++			uint64_t tag;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint64_t tag;
++			int result;
++		} cmd_done;
++		struct {
++			int host_no;
++			int function;
++			uint64_t tag;
++			uint8_t lun[8];
++			uint64_t mid;
++		} tsk_mgmt_req;
++	} k;
++
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#define TGT_RING_SIZE (1UL << 16)
++#define TGT_RING_PAGES (TGT_RING_SIZE >> PAGE_SHIFT)
++#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
++#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
++
++#endif
+-- 
+1.4.1.1
+

Added: trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
===================================================================
--- trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,57 @@
+From fff20a33841c7ab473dea824b4c52e2b9a9c8edc Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:48:43 +0900
+Subject: [PATCH 7/9] scsi tgt: scsi target netlink interface
+
+Makefile and Kconfig stuff.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig  |    7 +++++++
+ drivers/scsi/Makefile |    3 +++
+ 2 files changed, 10 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 96a81cd..566626c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate "SCSI target support"
++	depends on SCSI && EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool "legacy /proc/scsi/ support"
+ 	depends on SCSI && PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ebd0cf0..ede0c45 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+-- 
+1.4.1.1
+

Added: trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,595 @@
+From dca0bd3d8d7bc4493a11c3897e69d0187513c5b4 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:50:32 +0900
+Subject: [PATCH 8/9] scsi tgt: SRP library functions
+
+libsrp provides helper functions for SRP target drivers.
+
+The next step would be to add initiator support to merge the two SRP
+initiator drivers (ibmvscsi and ib_srp) in mainline.
+
+Some SRP target drivers would be out of drivers/scsi/ so I added an
+entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
+it.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig  |    9 +
+ drivers/scsi/Makefile |    1 
+ drivers/scsi/libsrp.c |  449 +++++++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/libsrp.h |   75 ++++++++
+ 4 files changed, 534 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 566626c..e5098d3 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -1846,6 +1846,15 @@ config ZFCP
+           called zfcp. If you want to compile it as a module, say M here
+           and read <file:Documentation/modules.txt>.
+ 
++config SCSI_SRP
++	tristate "SCSI RDMA Protocol helper library"
++	depends on SCSI
++	help
++	  If you wish to use SRP target drivers, say Y.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called libsrp.
++
+ endmenu
+ 
+ source "drivers/scsi/pcmcia/Kconfig"
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ede0c45..d71bb59 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
+ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
+ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
++obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
+new file mode 100644
+index 0000000..b8a7c3d
+--- /dev/null
++++ b/drivers/scsi/libsrp.c
+@@ -0,0 +1,449 @@
++/*
++ * SCSI RDAM Protocol lib functions
++ *
++ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/err.h>
++#include <linux/kfifo.h>
++#include <linux/scatterlist.h>
++#include <linux/dma-mapping.h>
++#include <linux/pci.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_tcq.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/srp.h>
++#include <scsi/libsrp.h>
++
++enum srp_task_attributes {
++	SRP_SIMPLE_TASK = 0,
++	SRP_HEAD_TASK = 1,
++	SRP_ORDERED_TASK = 2,
++	SRP_ACA_TASK = 4
++};
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
++			     struct srp_buf **ring)
++{
++	int i;
++	struct iu_entry *iue;
++
++	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
++	if (!q->pool)
++		return -ENOMEM;
++	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
++	if (!q->items)
++		goto free_pool;
++
++	spin_lock_init(&q->lock);
++	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
++			      GFP_KERNEL, &q->lock);
++	if (IS_ERR(q->queue))
++		goto free_item;
++
++	for (i = 0, iue = q->items; i < max; i++) {
++		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
++		iue->sbuf = ring[i];
++		iue++;
++	}
++	return 0;
++
++free_item:
++	kfree(q->items);
++free_pool:
++	kfree(q->pool);
++	return -ENOMEM;
++}
++
++static void srp_iu_pool_free(struct srp_queue *q)
++{
++	kfree(q->items);
++	kfree(q->pool);
++}
++
++static struct srp_buf ** srp_ring_alloc(struct device *dev,
++					size_t max, size_t size)
++{
++	int i;
++	struct srp_buf **ring;
++
++	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
++	if (!ring)
++		return NULL;
++
++	for (i = 0; i < max; i++) {
++		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
++		if (!ring[i])
++			goto out;
++		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
++						  GFP_KERNEL);
++		if (!ring[i]->buf)
++			goto out;
++	}
++	return ring;
++
++out:
++	for (i = 0; i < max && ring[i]; i++) {
++		if (ring[i]->buf)
++			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
++		kfree(ring[i]);
++	}
++	kfree(ring);
++
++	return NULL;
++}
++
++static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
++			  size_t size)
++{
++	int i;
++
++	for (i = 0; i < max; i++) {
++		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
++		kfree(ring[i]);
++	}
++}
++
++int srp_target_alloc(struct srp_target *target, struct device *dev,
++		     size_t nr, size_t iu_size)
++{
++	int err;
++
++	spin_lock_init(&target->lock);
++	INIT_LIST_HEAD(&target->cmd_queue);
++
++	target->dev = dev;
++	target->dev->driver_data = target;
++
++	target->srp_iu_size = iu_size;
++	target->rx_ring_size = nr;
++	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
++	if (!target->rx_ring)
++		return -ENOMEM;
++	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
++	if (err)
++		goto free_ring;
++
++	return 0;
++
++free_ring:
++	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
++	return -ENOMEM;
++}
++EXPORT_SYMBOL_GPL(srp_target_alloc);
++
++void srp_target_free(struct srp_target *target)
++{
++	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
++		      target->srp_iu_size);
++	srp_iu_pool_free(&target->iu_queue);
++}
++EXPORT_SYMBOL_GPL(srp_target_free);
++
++struct iu_entry *srp_iu_get(struct srp_target *target)
++{
++	struct iu_entry *iue = NULL;
++
++	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
++	BUG_ON(!iue);
++
++	iue->target = target;
++	iue->scmd = NULL;
++	INIT_LIST_HEAD(&iue->ilist);
++	iue->flags = 0;
++	return iue;
++}
++EXPORT_SYMBOL_GPL(srp_iu_get);
++
++void srp_iu_put(struct iu_entry *iue)
++{
++	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
++}
++EXPORT_SYMBOL_GPL(srp_iu_put);
++
++static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
++		       enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
++	struct srp_target *target = iue->target;
++	struct scatterlist *sg = scmd->request_buffer;
++	int nsg, err;
++
++	dprintk("%p %u %u %u %d\n", iue, scmd->request_bufflen, scmd->bufflen,
++		md->len, scmd->use_sg);
++
++	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
++	if (!nsg) {
++		printk("fail to map %p %d\n", iue, scmd->use_sg);
++		return 0;
++	}
++	err = rdma_io(iue, sg, nsg, md, 1, dir,
++		      min(scmd->request_bufflen, md->len));
++
++	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++	return err;
++}
++
++static int indirect_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			 struct srp_indirect_buf *id,
++			 enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
++	struct srp_target *target = iue->target;
++	struct srp_direct_buf *md;
++	struct scatterlist dummy, *sg = scmd->request_buffer;
++	dma_addr_t token = 0;
++	long err;
++	unsigned int done = 0;
++	int nmd, nsg;
++
++	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
++
++	dprintk("%p %u %u %u %u %d %d %d\n",
++		iue, scmd->request_bufflen, scmd->bufflen,
++		id->len, scmd->offset, nmd,
++		cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
++
++	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
++	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
++		md = &id->desc_list[0];
++		goto rdma;
++	}
++
++	md = dma_alloc_coherent(target->dev, id->table_desc.len,
++				 &token, GFP_KERNEL);
++	if (!md) {
++		eprintk("Can't get dma memory %u\n", id->table_desc.len);
++		return 0;
++	}
++
++	sg_init_one(&dummy, md, id->table_desc.len);
++	sg_dma_address(&dummy) = token;
++	err = rdma_io(iue, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
++		      id->table_desc.len);
++	if (err < 0) {
++		eprintk("Error copying indirect table %ld\n", err);
++		goto free_mem;
++	}
++
++rdma:
++	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
++	if (!nsg) {
++		eprintk("fail to map %p %d\n", iue, scmd->use_sg);
++		goto free_mem;
++	}
++
++	err = rdma_io(iue, sg, nsg, md, nmd, dir,
++		      min(scmd->request_bufflen, id->len));
++	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++free_mem:
++	if (token)
++		dma_free_coherent(target->dev, id->table_desc.len, md, token);
++
++	return done;
++}
++
++static int data_out_desc_size(struct srp_cmd *cmd)
++{
++	int size = 0;
++	u8 fmt = cmd->buf_fmt >> 4;
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		size = sizeof(struct srp_direct_buf);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		size = sizeof(struct srp_indirect_buf) +
++			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
++		break;
++	default:
++		eprintk("client error. Invalid data_out_format %x\n", fmt);
++		break;
++	}
++	return size;
++}
++
++static int __srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			       enum dma_data_direction dir, rdma_io_t rdma_io)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	int offset, err = 0;
++	u8 format;
++
++	offset = cmd->add_cdb_len * 4;
++	if (dir == DMA_FROM_DEVICE)
++		offset += data_out_desc_size(cmd);
++
++	if (dir == DMA_TO_DEVICE)
++		format = cmd->buf_fmt >> 4;
++	else
++		format = cmd->buf_fmt & ((1U << 4) - 1);
++
++	switch (format) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *)
++			(cmd->add_data + offset);
++		err = direct_data(scmd, md, dir, rdma_io);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *)
++			(cmd->add_data + offset);
++		err = indirect_data(scmd, cmd, id, dir, rdma_io);
++		break;
++	default:
++		eprintk("Unknown format %d %x\n", dir, format);
++		break;
++	}
++
++	return err;
++}
++
++/* TODO: this can be called multiple times for a single command. */
++int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++		      rdma_io_t rdma_io)
++{
++	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
++	enum dma_data_direction dir;
++
++	if (test_bit(V_WRITE, &iue->flags))
++		dir = DMA_TO_DEVICE;
++	else
++		dir = DMA_FROM_DEVICE;
++	__srp_transfer_data(scmd, cmd, dir, rdma_io);
++	return 0;
++}
++EXPORT_SYMBOL_GPL(srp_transfer_data);
++
++static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	int len = 0, offset = cmd->add_cdb_len * 4;
++	u8 fmt;
++
++	if (dir == DMA_TO_DEVICE)
++		fmt = cmd->buf_fmt >> 4;
++	else {
++		fmt = cmd->buf_fmt & ((1U << 4) - 1);
++		offset += data_out_desc_size(cmd);
++	}
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *) (cmd->add_data + offset);
++		len = md->len;
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
++		len = id->len;
++		break;
++	default:
++		eprintk("invalid data format %x\n", fmt);
++		break;
++	}
++	return len;
++}
++
++static uint8_t getcontrolbyte(u8 *cdb)
++{
++	return cdb[COMMAND_SIZE(cdb[0]) - 1];
++}
++
++static inline uint8_t getlink(struct srp_cmd *cmd)
++{
++	return (getcontrolbyte(cmd->cdb) & 0x01);
++}
++
++int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
++{
++	struct Scsi_Host *shost = iue->target->shost;
++	enum dma_data_direction data_dir;
++	struct scsi_cmnd *scmd;
++	int tag, len;
++
++	if (getlink(cmd))
++		__set_bit(V_LINKED, &iue->flags);
++
++	tag = MSG_SIMPLE_TAG;
++
++	switch (cmd->task_attr) {
++	case SRP_SIMPLE_TASK:
++		tag = MSG_SIMPLE_TAG;
++		break;
++	case SRP_ORDERED_TASK:
++		tag = MSG_ORDERED_TAG;
++		break;
++	case SRP_HEAD_TASK:
++		tag = MSG_HEAD_TAG;
++		break;
++	default:
++		eprintk("Task attribute %d not supported\n", cmd->task_attr);
++		tag = MSG_ORDERED_TAG;
++	}
++
++	switch (cmd->cdb[0]) {
++	case WRITE_6:
++	case WRITE_10:
++	case WRITE_VERIFY:
++	case WRITE_12:
++	case WRITE_VERIFY_12:
++		__set_bit(V_WRITE, &iue->flags);
++	}
++
++	if (cmd->buf_fmt >> 4)
++		data_dir = DMA_TO_DEVICE;
++	else
++		data_dir = DMA_FROM_DEVICE;
++	len = vscsis_data_length(cmd, data_dir);
++
++	dprintk("%p %x %lx %d %d %d %llx\n", iue, cmd->cdb[0],
++		cmd->lun, data_dir, len, tag, (unsigned long long) cmd->tag);
++
++	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
++	BUG_ON(!scmd);
++	scmd->SCp.ptr = (char *) iue;
++	memcpy(scmd->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
++	scmd->request_bufflen = len;
++	scmd->tag = tag;
++	iue->scmd = scmd;
++	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &cmd->lun, cmd->tag);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(srp_cmd_perform);
++
++MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
++MODULE_AUTHOR("FUJITA Tomonori");
++MODULE_LICENSE("GPL");
+diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
+new file mode 100644
+index 0000000..9dd10ff
+--- /dev/null
++++ b/include/scsi/libsrp.h
+@@ -0,0 +1,75 @@
++#ifndef __LIBSRP_H__
++#define __LIBSRP_H__
++
++#include <linux/list.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_host.h>
++#include <scsi/srp.h>
++
++enum iue_flags {
++	V_DIOVER,
++	V_WRITE,
++	V_LINKED,
++	V_FLYING,
++};
++
++struct srp_buf {
++	dma_addr_t dma;
++	void *buf;
++};
++
++struct srp_queue {
++	void *pool;
++	void *items;
++	struct kfifo *queue;
++	spinlock_t lock;
++};
++
++struct srp_target {
++	struct Scsi_Host *shost;
++	struct device *dev;
++
++	spinlock_t lock;
++	struct list_head cmd_queue;
++
++	size_t srp_iu_size;
++	struct srp_queue iu_queue;
++	size_t rx_ring_size;
++	struct srp_buf **rx_ring;
++
++	/* IB needs tx_ring too */
++
++	void *ldata;
++};
++
++struct iu_entry {
++	struct srp_target *target;
++	struct scsi_cmnd *scmd;
++
++	struct list_head ilist;
++	dma_addr_t remote_token;
++	unsigned long flags;
++
++	struct srp_buf *sbuf;
++};
++
++typedef int (rdma_io_t) (struct iu_entry *, struct scatterlist *, int,
++			 struct srp_direct_buf *, int,
++			 enum dma_data_direction, unsigned int);
++
++static inline struct srp_target *host_to_target(struct Scsi_Host *host)
++{
++	return (struct srp_target *) host->hostdata;
++}
++
++extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
++extern void srp_target_free(struct srp_target *);
++
++extern struct iu_entry *srp_iu_get(struct srp_target *);
++extern void srp_iu_put(struct iu_entry *);
++
++extern int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd);
++extern int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
++			     rdma_io_t rdma_io);
++
++#endif
+-- 
+1.4.1.1
+

Added: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-16 23:57:56 UTC (rev 528)
@@ -0,0 +1,1023 @@
+From 49997b6ea087c515fad787cb90637e03a44f396f Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Thu, 17 Aug 2006 08:51:51 +0900
+Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries Virtual SCSI Target Driver
+
+This is IBM Virtual SCSI target driver for tgt.
+
+This patch dependents on the previous patch to convert the ibmvscsi
+driver to use include/scsi/srp.h.
+
+The driver is based on the original ibmvscsis driver:
+
+http://lkml.org/lkml/2005/10/17/99
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig             |   14 +
+ drivers/scsi/Makefile            |    1 
+ drivers/scsi/ibmvscsi/Makefile   |    2 
+ drivers/scsi/ibmvscsi/ibmvstgt.c |  943 ++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 960 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index e5098d3..c25154c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ibmvscsic.
+ 
++config SCSI_IBMVSCSIS
++	tristate "IBM Virtual SCSI Server support"
++	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
++	help
++	  This is the SRP target driver for IBM pSeries virtual environments.
++
++	  The userspace component needed to initialize the driver and
++	  documentation can be found:
++
++	  http://stgt.berlios.de/
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ibmvstgt.
++
+ config SCSI_INITIO
+ 	tristate "Initio 9100U(W) support"
+ 	depends on PCI && SCSI
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index d71bb59..78544e3 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
+ obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+ obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
+diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
+index 4e247b6..6ac0633 100644
+--- a/drivers/scsi/ibmvscsi/Makefile
++++ b/drivers/scsi/ibmvscsi/Makefile
+@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
+ ibmvscsic-y			+= ibmvscsi.o
+ ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
+ ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
++
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
+diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
+new file mode 100644
+index 0000000..cf1e851
+--- /dev/null
++++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
+@@ -0,0 +1,943 @@
++/*
++ * IBM eServer i/pSeries Virtual SCSI Target Driver
++ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
++ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
++ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
++ *
++ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
++ * USA
++ */
++#include <linux/interrupt.h>
++#include <linux/module.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/libsrp.h>
++#include <asm/hvcall.h>
++#include <asm/iommu.h>
++#include <asm/prom.h>
++#include <asm/vio.h>
++
++#include "ibmvscsi.h"
++
++#define	INITIAL_SRP_LIMIT	16
++#define	DEFAULT_MAX_SECTORS	512
++
++#define	TGT_NAME	"ibmvstgt"
++
++/*
++ * Hypervisor calls.
++ */
++#define h_copy_rdma(l, sa, sb, da, db) \
++			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
++#define h_send_crq(ua, l, h) \
++			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
++#define h_reg_crq(ua, tok, sz)\
++			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
++#define h_free_crq(ua) \
++			plpar_hcall_norets(H_FREE_CRQ, ua);
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++struct vio_port {
++	struct vio_dev *dma_dev;
++
++	struct crq_queue crq_queue;
++	struct work_struct crq_work;
++
++	unsigned long liobn;
++	unsigned long riobn;
++};
++
++static struct workqueue_struct *vtgtd;
++
++/*
++ * These are fixed for the system and come from the Open Firmware device tree.
++ * We just store them here to save getting them every time.
++ */
++static char system_id[64] = "";
++static char partition_name[97] = "UNKNOWN";
++static unsigned int partition_number = -1;
++
++static struct vio_port *target_to_port(struct srp_target *target)
++{
++	return (struct vio_port *) target->ldata;
++}
++
++static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
++{
++	return (union viosrp_iu *) (iue->sbuf->buf);
++}
++
++static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
++{
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	long rc, rc1;
++	union {
++		struct viosrp_crq cooked;
++		uint64_t raw[2];
++	} crq;
++
++	/* First copy the SRP */
++	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
++			 vport->riobn, iue->remote_token);
++
++	if (rc)
++		eprintk("Error %ld transferring data\n", rc);
++
++	crq.cooked.valid = 0x80;
++	crq.cooked.format = format;
++	crq.cooked.reserved = 0x00;
++	crq.cooked.timeout = 0x00;
++	crq.cooked.IU_length = length;
++	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
++
++	if (rc == 0)
++		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
++	else
++		crq.cooked.status = 0x00;
++
++	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
++
++	if (rc1) {
++		eprintk("%ld sending response\n", rc1);
++		return rc1;
++	}
++
++	return rc;
++}
++
++#define SRP_RSP_SENSE_DATA_LEN	18
++
++static int send_rsp(struct iu_entry *iue, unsigned char status,
++		    unsigned char asc)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	uint64_t tag = iu->srp.rsp.tag;
++
++	/* If the linked bit is on and status is good */
++	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
++		status = 0x10;
++
++	memset(iu, 0, sizeof(struct srp_rsp));
++	iu->srp.rsp.opcode = SRP_RSP;
++	iu->srp.rsp.req_lim_delta = 1;
++	iu->srp.rsp.tag = tag;
++
++	if (test_bit(V_DIOVER, &iue->flags))
++		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
++
++	iu->srp.rsp.data_in_res_cnt = 0;
++	iu->srp.rsp.data_out_res_cnt = 0;
++
++	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
++
++	iu->srp.rsp.resp_data_len = 0;
++	iu->srp.rsp.status = status;
++	if (status) {
++		uint8_t *sense = iu->srp.rsp.data;
++
++		if (iue->scmd) {
++			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
++			memcpy(sense, iue->scmd->sense_buffer,
++			       SCSI_SENSE_BUFFERSIZE);
++		} else {
++			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
++			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
++
++			/* Valid bit and 'current errors' */
++			sense[0] = (0x1 << 7 | 0x70);
++			/* Sense key */
++			sense[2] = status;
++			/* Additional sense length */
++			sense[7] = 0xa;	/* 10 bytes */
++			/* Additional sense code */
++			sense[12] = asc;
++		}
++	}
++
++	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
++		VIOSRP_SRP_FORMAT);
++
++	return 0;
++}
++
++static void handle_cmd_queue(struct srp_target *target)
++{
++	struct iu_entry *iue;
++	unsigned long flags;
++
++retry:
++	spin_lock_irqsave(&target->lock, flags);
++
++	list_for_each_entry(iue, &target->cmd_queue, ilist) {
++		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
++			spin_unlock_irqrestore(&target->lock, flags);
++			srp_cmd_perform(iue, (struct srp_cmd *) iue->sbuf->buf);
++			goto retry;
++		}
++	}
++
++	spin_unlock_irqrestore(&target->lock, flags);
++}
++
++static int ibmvstgt_rdma(struct iu_entry *iue, struct scatterlist *sg, int nsg,
++			 struct srp_direct_buf *md, int nmd,
++			 enum dma_data_direction dir, unsigned int rest)
++{
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	dma_addr_t token;
++	long err;
++	unsigned int done = 0;
++	int i, sidx, soff;
++
++	sidx = soff = 0;
++	token = sg_dma_address(sg + sidx);
++
++	for (i = 0; i < nmd && rest; i++) {
++		unsigned int mdone, mlen;
++
++		mlen = min(rest, md[i].len);
++		for (mdone = 0; mlen;) {
++			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
++
++			if (dir == DMA_TO_DEVICE)
++				err = h_copy_rdma(slen,
++						  vport->riobn,
++						  md[i].va + mdone,
++						  vport->liobn,
++						  token + soff);
++			else
++				err = h_copy_rdma(slen,
++						  vport->liobn,
++						  token + soff,
++						  vport->riobn,
++						  md[i].va + mdone);
++
++			if (err != H_SUCCESS) {
++				eprintk("rdma error %d %d\n", dir, slen);
++				goto out;
++			}
++
++			mlen -= slen;
++			mdone += slen;
++			soff += slen;
++			done += slen;
++
++			if (soff == sg_dma_len(sg + sidx)) {
++				sidx++;
++				soff = 0;
++				token = sg_dma_address(sg + sidx);
++
++				if (sidx > nsg) {
++					eprintk("out of sg %p %d %d\n",
++						iue, sidx, nsg);
++					goto out;
++				}
++			}
++		};
++
++		rest -= mlen;
++	}
++out:
++
++	return 0;
++}
++
++static int ibmvstgt_transfer_data(struct scsi_cmnd *scmd,
++				  void (*done)(struct scsi_cmnd *))
++{
++	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
++	int err;
++
++	err = srp_transfer_data(scmd, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma);
++	done(scmd);
++
++	return err;
++}
++
++static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
++			     void (*done)(struct scsi_cmnd *))
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
++	struct srp_target *target = iue->target;
++
++	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_del(&iue->ilist);
++	spin_unlock_irqrestore(&target->lock, flags);
++
++	if (scmd->result != SAM_STAT_GOOD) {
++		eprintk("operation failed %p %d %x\n",
++			iue, scmd->result, vio_iu(iue)->srp.cmd.cdb[0]);
++		send_rsp(iue, HARDWARE_ERROR, 0x00);
++	} else
++		send_rsp(iue, NO_SENSE, 0x00);
++
++	done(scmd);
++	srp_iu_put(iue);
++	return 0;
++}
++
++int send_adapter_info(struct iu_entry *iue,
++		      dma_addr_t remote_buffer, uint16_t length)
++{
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	struct Scsi_Host *shost = target->shost;
++	dma_addr_t data_token;
++	struct mad_adapter_info_data *info;
++	int err;
++
++	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
++				  GFP_KERNEL);
++	if (!info) {
++		eprintk("bad dma_alloc_coherent %p\n", target);
++		return 1;
++	}
++
++	/* Get remote info */
++	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
++			  vport->liobn, data_token);
++	if (err == H_SUCCESS) {
++		dprintk("Client connect: %s (%d)\n",
++			info->partition_name, info->partition_number);
++	}
++
++	memset(info, 0, sizeof(*info));
++
++	strcpy(info->srp_version, "16.a");
++	strncpy(info->partition_name, partition_name,
++		sizeof(info->partition_name));
++	info->partition_number = partition_number;
++	info->mad_version = 1;
++	info->os_type = 2;
++	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
++
++	/* Send our info to remote */
++	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
++			  vport->riobn, remote_buffer);
++
++	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
++
++	if (err != H_SUCCESS) {
++		eprintk("Error sending adapter info %d\n", err);
++		return 1;
++	}
++
++	return 0;
++}
++
++static void process_login(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
++	uint64_t tag = iu->srp.rsp.tag;
++
++	/* TODO handle case that requested size is wrong and
++	 * buffer format is wrong
++	 */
++	memset(iu, 0, sizeof(struct srp_login_rsp));
++	rsp->opcode = SRP_LOGIN_RSP;
++	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
++	rsp->tag = tag;
++	rsp->max_it_iu_len = sizeof(union srp_iu);
++	rsp->max_ti_iu_len = sizeof(union srp_iu);
++	/* direct and indirect */
++	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
++
++	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
++}
++
++static inline void queue_cmd(struct iu_entry *iue)
++{
++	struct srp_target *target = iue->target;
++	unsigned long flags;
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_add_tail(&iue->ilist, &target->cmd_queue);
++	spin_unlock_irqrestore(&target->lock, flags);
++}
++
++static int process_tsk_mgmt(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int fn;
++
++	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
++
++	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		fn = ABORT_TASK;
++		break;
++	case SRP_TSK_ABORT_TASK_SET:
++		fn = ABORT_TASK_SET;
++		break;
++	case SRP_TSK_CLEAR_TASK_SET:
++		fn = CLEAR_TASK_SET;
++		break;
++	case SRP_TSK_LUN_RESET:
++		fn = LOGICAL_UNIT_RESET;
++		break;
++	case SRP_TSK_CLEAR_ACA:
++		fn = CLEAR_ACA;
++		break;
++	default:
++		fn = 0;
++	}
++	if (fn)
++		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
++					  iu->srp.tsk_mgmt.task_tag,
++					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
++					  iue);
++	else
++		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
++
++	return !fn;
++}
++
++static int process_mad_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct viosrp_adapter_info *info;
++	struct viosrp_host_config *conf;
++
++	switch (iu->mad.empty_iu.common.type) {
++	case VIOSRP_EMPTY_IU_TYPE:
++		eprintk("%s\n", "Unsupported EMPTY MAD IU");
++		break;
++	case VIOSRP_ERROR_LOG_TYPE:
++		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
++		iu->mad.error_log.common.status = 1;
++		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_ADAPTER_INFO_TYPE:
++		info = &iu->mad.adapter_info;
++		info->common.status = send_adapter_info(iue, info->buffer,
++							info->common.length);
++		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_HOST_CONFIG_TYPE:
++		conf = &iu->mad.host_config;
++		conf->common.status = 1;
++		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
++		break;
++	default:
++		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
++	}
++
++	return 1;
++}
++
++static int process_srp_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int done = 1;
++	u8 opcode = iu->srp.rsp.opcode;
++
++	switch (opcode) {
++	case SRP_LOGIN_REQ:
++		process_login(iue);
++		break;
++	case SRP_TSK_MGMT:
++		done = process_tsk_mgmt(iue);
++		break;
++	case SRP_CMD:
++		queue_cmd(iue);
++		done = 0;
++		break;
++	case SRP_LOGIN_RSP:
++	case SRP_I_LOGOUT:
++	case SRP_T_LOGOUT:
++	case SRP_RSP:
++	case SRP_CRED_REQ:
++	case SRP_CRED_RSP:
++	case SRP_AER_REQ:
++	case SRP_AER_RSP:
++		eprintk("Unsupported type %u\n", opcode);
++		break;
++	default:
++		eprintk("Unknown type %u\n", opcode);
++	}
++
++	return done;
++}
++
++static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct iu_entry *iue;
++	long err, done;
++
++	iue = srp_iu_get(target);
++	if (!iue) {
++		eprintk("Error getting IU from pool, %p\n", target);
++		return;
++	}
++
++	iue->remote_token = crq->IU_data_ptr;
++
++	err = h_copy_rdma(crq->IU_length, vport->riobn,
++			  iue->remote_token, vport->liobn, iue->sbuf->dma);
++
++	if (err != H_SUCCESS)
++		eprintk("%ld transferring data error %p\n", err, iue);
++
++	if (crq->format == VIOSRP_MAD_FORMAT)
++		done = process_mad_iu(iue);
++	else
++		done = process_srp_iu(iue);
++
++	if (done)
++		srp_iu_put(iue);
++}
++
++static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++
++	vio_disable_interrupts(vport->dma_dev);
++	queue_work(vtgtd, &vport->crq_work);
++
++	return IRQ_HANDLED;
++}
++
++static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
++{
++	int err;
++	struct vio_port *vport = target_to_port(target);
++
++	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
++	if (!queue->msgs)
++		goto malloc_failed;
++	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
++
++	queue->msg_token = dma_map_single(target->dev, queue->msgs,
++					  queue->size * sizeof(*queue->msgs),
++					  DMA_BIDIRECTIONAL);
++
++	if (dma_mapping_error(queue->msg_token))
++		goto map_failed;
++
++	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
++			PAGE_SIZE);
++
++	/* If the adapter was left active for some reason (like kexec)
++	 * try freeing and re-registering
++	 */
++	if (err == H_RESOURCE) {
++	    do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
++			    PAGE_SIZE);
++	}
++
++	if (err != H_SUCCESS && err != 2) {
++		eprintk("Error 0x%x opening virtual adapter\n", err);
++		goto reg_crq_failed;
++	}
++
++	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
++			  SA_INTERRUPT, "ibmvstgt", target);
++	if (err)
++		goto req_irq_failed;
++
++	vio_enable_interrupts(vport->dma_dev);
++
++	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
++
++	queue->cur = 0;
++	spin_lock_init(&queue->lock);
++
++	return 0;
++
++req_irq_failed:
++	do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++reg_crq_failed:
++	dma_unmap_single(target->dev, queue->msg_token,
++			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
++map_failed:
++	free_page((unsigned long) queue->msgs);
++
++malloc_failed:
++	return -ENOMEM;
++}
++
++static void crq_queue_destroy(struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct crq_queue *queue = &vport->crq_queue;
++	int err;
++
++	free_irq(vport->dma_dev->irq, target);
++	do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	dma_unmap_single(target->dev, queue->msg_token,
++			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
++
++	free_page((unsigned long) queue->msgs);
++}
++
++static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	dprintk("%x %x\n", crq->valid, crq->format);
++
++	switch (crq->valid) {
++	case 0xC0:
++		/* initialization */
++		switch (crq->format) {
++		case 0x01:
++			h_send_crq(vport->dma_dev->unit_address,
++				   0xC002000000000000, 0);
++			break;
++		case 0x02:
++			break;
++		default:
++			eprintk("Unknown format %u\n", crq->format);
++		}
++		break;
++	case 0xFF:
++		/* transport event */
++		break;
++	case 0x80:
++		/* real payload */
++		switch (crq->format) {
++		case VIOSRP_SRP_FORMAT:
++		case VIOSRP_MAD_FORMAT:
++			process_iu(crq, target);
++			break;
++		case VIOSRP_OS400_FORMAT:
++		case VIOSRP_AIX_FORMAT:
++		case VIOSRP_LINUX_FORMAT:
++		case VIOSRP_INLINE_FORMAT:
++			eprintk("Unsupported format %u\n", crq->format);
++			break;
++		default:
++			eprintk("Unknown format %u\n", crq->format);
++		}
++		break;
++	default:
++		eprintk("unknown message type 0x%02x!?\n", crq->valid);
++	}
++}
++
++static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
++{
++	struct viosrp_crq *crq;
++	unsigned long flags;
++
++	spin_lock_irqsave(&queue->lock, flags);
++	crq = &queue->msgs[queue->cur];
++	if (crq->valid & 0x80) {
++		if (++queue->cur == queue->size)
++			queue->cur = 0;
++	} else
++		crq = NULL;
++	spin_unlock_irqrestore(&queue->lock, flags);
++
++	return crq;
++}
++
++static void handle_crq(void *data)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++	struct viosrp_crq *crq;
++	int done = 0;
++
++	while (!done) {
++		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
++			process_crq(crq, target);
++			crq->valid = 0x00;
++		}
++
++		vio_enable_interrupts(vport->dma_dev);
++
++		crq = next_crq(&vport->crq_queue);
++		if (crq) {
++			vio_disable_interrupts(vport->dma_dev);
++			process_crq(crq, target);
++			crq->valid = 0x00;
++		} else
++			done = 1;
++	}
++
++	handle_cmd_queue(target);
++}
++
++
++static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
++	struct srp_target *target = iue->target;
++
++	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_del(&iue->ilist);
++	spin_unlock_irqrestore(&target->lock, flags);
++
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
++{
++	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
++	union viosrp_iu *iu = vio_iu(iue);
++	unsigned char status, asc;
++
++	eprintk("%p %d\n", iue, result);
++	status = NO_SENSE;
++	asc = 0;
++
++	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		asc = 0x14;
++		if (result)
++			status = ABORTED_COMMAND;
++		break;
++	default:
++		break;
++	}
++
++	send_rsp(iue, status, asc);
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static ssize_t system_id_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
++}
++
++static ssize_t partition_number_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
++}
++
++static ssize_t unit_address_show(struct class_device *cdev, char *buf)
++{
++	struct Scsi_Host *shost = class_to_shost(cdev);
++	struct srp_target *target = host_to_target(shost);
++	struct vio_port *vport = target_to_port(target);
++	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
++}
++
++static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
++static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
++static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
++
++static struct class_device_attribute *ibmvstgt_attrs[] = {
++	&class_device_attr_system_id,
++	&class_device_attr_partition_number,
++	&class_device_attr_unit_address,
++	NULL,
++};
++
++static struct scsi_host_template ibmvstgt_sht = {
++	.name			= TGT_NAME,
++	.module			= THIS_MODULE,
++	.can_queue		= INITIAL_SRP_LIMIT,
++	.sg_tablesize		= SG_ALL,
++	.use_clustering		= DISABLE_CLUSTERING,
++	.max_sectors		= DEFAULT_MAX_SECTORS,
++	.transfer_response	= ibmvstgt_cmd_done,
++	.transfer_data		= ibmvstgt_transfer_data,
++	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
++	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
++	.shost_attrs		= ibmvstgt_attrs,
++	.proc_name		= TGT_NAME,
++};
++
++static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
++{
++	struct Scsi_Host *shost;
++	struct srp_target *target;
++	struct vio_port *vport;
++	unsigned int *dma, dma_size;
++	int err = -ENOMEM;
++
++	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
++	if (!vport)
++		return err;
++	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
++	if (!shost)
++		goto free_vport;
++	err = scsi_tgt_alloc_queue(shost);
++	if (err)
++		goto put_host;
++
++	target = host_to_target(shost);
++	target->shost = shost;
++	vport->dma_dev = dev;
++	target->ldata = vport;
++	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
++			       SRP_MAX_IU_LEN);
++	if (err)
++		goto put_host;
++
++	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
++						 &dma_size);
++	if (!dma || dma_size != 40) {
++		eprintk("Couldn't get window property %d\n", dma_size);
++		err = -EIO;
++		goto free_srp_target;
++	}
++	vport->liobn = dma[0];
++	vport->riobn = dma[5];
++
++	INIT_WORK(&vport->crq_work, handle_crq, target);
++
++	err = crq_queue_create(&vport->crq_queue, target);
++	if (err)
++		goto free_srp_target;
++
++	err = scsi_add_host(shost, target->dev);
++	if (err)
++		goto destroy_queue;
++	return 0;
++
++destroy_queue:
++	crq_queue_destroy(target);
++free_srp_target:
++	srp_target_free(target);
++put_host:
++	scsi_host_put(shost);
++free_vport:
++	kfree(vport);
++	return err;
++}
++
++static int ibmvstgt_remove(struct vio_dev *dev)
++{
++	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
++	struct Scsi_Host *shost = target->shost;
++
++	srp_target_free(target);
++	crq_queue_destroy(target);
++	scsi_remove_host(shost);
++	scsi_host_put(shost);
++	return 0;
++}
++
++static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
++	{"v-scsi-host", "IBM,v-scsi-host"},
++	{"",""}
++};
++
++MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
++
++static struct vio_driver ibmvstgt_driver = {
++	.id_table = ibmvstgt_device_table,
++	.probe = ibmvstgt_probe,
++	.remove = ibmvstgt_remove,
++	.driver = {
++		.name = "ibmvscsi",
++		.owner = THIS_MODULE,
++	}
++};
++
++static int get_system_info(void)
++{
++	struct device_node *rootdn;
++	char *id, *model, *name;
++	unsigned int *num;
++
++	rootdn = find_path_device("/");
++	if (!rootdn)
++		return -ENOENT;
++
++	model = get_property(rootdn, "model", NULL);
++	id = get_property(rootdn, "system-id", NULL);
++	if (model && id)
++		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
++
++	name = get_property(rootdn, "ibm,partition-name", NULL);
++	if (name)
++		strncpy(partition_name, name, sizeof(partition_name));
++
++	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
++	if (num)
++		partition_number = *num;
++
++	return 0;
++}
++
++static int ibmvstgt_init(void)
++{
++	int err = -ENOMEM;
++
++	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
++
++	vtgtd = create_workqueue("ibmvtgtd");
++	if (!vtgtd)
++		return err;
++
++	err = get_system_info();
++	if (err)
++		goto destroy_wq;
++
++	err = vio_register_driver(&ibmvstgt_driver);
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(vtgtd);
++	return err;
++}
++
++static void ibmvstgt_exit(void)
++{
++	printk("Unregister IBM virtual SCSI driver\n");
++
++	destroy_workqueue(vtgtd);
++	vio_unregister_driver(&ibmvstgt_driver);
++}
++
++MODULE_DESCRIPTION("IBM Virtual SCSI Target");
++MODULE_AUTHOR("Dave Boutcher");
++MODULE_LICENSE("GPL");
++
++module_init(ibmvstgt_init);
++module_exit(ibmvstgt_exit);
+-- 
+1.4.1.1
+

Modified: trunk/patchset/README
===================================================================
--- trunk/patchset/README	2006-08-12 14:41:29 UTC (rev 527)
+++ trunk/patchset/README	2006-08-16 23:57:56 UTC (rev 528)
@@ -1,7 +1,6 @@
-This patchset for scsi-target git tree:
+This patchset for scsi-rc-fixes git tree:
 
-http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary
+http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-rc-fixes-2.6.git;a=summary
 
-
 Get the tree and apply all the patches. Sorry for the
 inconvenience. We will create our own git tree shortly.



From tomo at mail.berlios.de  Thu Aug 17 01:59:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 17 Aug 2006 01:59:19 +0200
Subject: [Stgt-svn] r529 - in trunk/usr: . ibmvio
Message-ID: <200608162359.k7GNxJmR007133@sheep.berlios.de>

Author: tomo
Date: 2006-08-17 01:59:15 +0200 (Thu, 17 Aug 2006)
New Revision: 529

Modified:
   trunk/usr/Makefile
   trunk/usr/ibmvio/Makefile
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/tgtif.c
Log:
Changes for the new patchset.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-16 23:57:56 UTC (rev 528)
+++ trunk/usr/Makefile	2006-08-16 23:59:15 UTC (rev 529)
@@ -24,3 +24,4 @@
 clean:
 	rm -f *.o $(PROGRAMS)
 	$(MAKE) -C iscsi clean
+	$(MAKE) -C ibmvio clean

Modified: trunk/usr/ibmvio/Makefile
===================================================================
--- trunk/usr/ibmvio/Makefile	2006-08-16 23:57:56 UTC (rev 528)
+++ trunk/usr/ibmvio/Makefile	2006-08-16 23:59:15 UTC (rev 529)
@@ -1,9 +1,4 @@
 CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../usr
-OBJS = libibmvstgt.o
-SHAREDLIB = libibmvstgt.so
 
-$(SHAREDLIB): $(OBJS)
-	$(CC) -shared -o $@ $(OBJS)
-
 clean:
-	rm -f *.o $(PROGRAMS) $(SHAREDLIB)
+	rm -f *.o

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2006-08-16 23:57:56 UTC (rev 528)
+++ trunk/usr/ibmvio/ibmvio.c	2006-08-16 23:59:15 UTC (rev 529)
@@ -40,6 +40,8 @@
 #include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
 
+#include "list.h"
+#include "util.h"
 #include "tgtd.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
@@ -230,7 +232,7 @@
 	idx = 2;
 	nr_luns = 1;
 
-	list_for_each_entry(dev, dev_list, dlist) {
+	list_for_each_entry(dev, dev_list, d_list) {
 		lun = dev->lun;
 		lun = make_lun(0, lun & 0x003f, 0);
 		data[idx++] = __cpu_to_be64(lun);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-16 23:57:56 UTC (rev 528)
+++ trunk/usr/tgtif.c	2006-08-16 23:59:15 UTC (rev 529)
@@ -41,49 +41,38 @@
 
 struct uring {
 	uint32_t idx;
-	uint32_t nr_entry;
-	int entry_size;
 	char *buf;
-	int buf_size;
 };
 
 static struct uring kuring, ukring;
 static int chrfd;
 
-static inline struct rbuf_hdr *head_ring_hdr(struct uring *r)
+static inline void ring_index_inc(struct uring *ring)
 {
-	uint32_t offset = (r->idx & (r->nr_entry - 1)) * r->entry_size;
-	return (struct rbuf_hdr *) (r->buf + offset);
+	ring->idx = (ring->idx == TGT_MAX_EVENTS - 1) ? 0 : ring->idx + 1;
 }
 
-static void ring_init(struct uring *r, char *buf, int bsize, int esize)
+static inline struct tgt_event *head_ring_hdr(struct uring *ring)
 {
-	int i;
+	uint32_t pidx, off, pos;
 
-	esize += sizeof(struct rbuf_hdr);
-	r->idx = 0;
-	r->buf = buf;
-	r->buf_size = bsize;
-	r->entry_size = esize;
+	pidx = ring->idx / TGT_EVENT_PER_PAGE;
+	off = ring->idx % TGT_EVENT_PER_PAGE;
+	pos = pidx * PAGE_SIZE + off * sizeof(struct tgt_event);
 
-	bsize /= esize;
-	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
-		;
-	r->nr_entry = 1 << i;
-
-	dprintf("%u %u\n", r->entry_size, r->nr_entry);
+	return (struct tgt_event *) (ring->buf + pos);
 }
 
-static int kreq_send(struct tgt_event *ev)
+static int kreq_send(struct tgt_event *p)
 {
-	struct rbuf_hdr *hdr;
-	hdr = head_ring_hdr(&ukring);
-	if (hdr->status)
+	struct tgt_event *ev;
+	ev = head_ring_hdr(&ukring);
+	if (ev->status == TGT_EVENT_STATUS_USED)
 		return -ENOMEM;
 
-	memcpy(hdr->data, ev, sizeof(*ev));
-	ukring.idx++;
-	hdr->status = 1;
+	memcpy(ev, p, sizeof(*p));
+	ring_index_inc(&ukring);
+	ev->status = TGT_EVENT_STATUS_USED;
 
 	write(chrfd, ev, 1);
 
@@ -108,28 +97,25 @@
 
 	ev.type = TGT_UEVENT_CMD_RSP;
 	ev.u.cmd_rsp.host_no = host_no;
-/* 	ev.u.cmd_rsp.cid = cmd->cid; */
 	ev.u.cmd_rsp.len = len;
 	ev.u.cmd_rsp.result = result;
 	ev.u.cmd_rsp.uaddr = addr;
 	ev.u.cmd_rsp.rw = rw;
+	ev.u.cmd_rsp.tag = tag;
 
 	return kreq_send(&ev);
 }
 
 void kspace_event_handle(void)
 {
-	struct rbuf_hdr *hdr;
 	struct tgt_event *ev;
 
 	dprintf("nl event %u\n", kuring.idx);
 retry:
-	hdr = head_ring_hdr(&kuring);
-	if (!hdr->status)
+	ev = head_ring_hdr(&kuring);
+	if (ev->status == TGT_EVENT_STATUS_EMPTY)
 		return;
 
-	ev = (struct tgt_event *) (hdr->data);
-
 	dprintf("event %u\n", ev->type);
 
 	switch (ev->type) {
@@ -140,7 +126,7 @@
 				 kspace_send_cmd_res);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.cid);
+		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.tag);
 		break;
 	case TGT_KEVENT_TSK_MGMT_REQ:
 		target_mgmt_request(ev->k.cmd_req.host_no,
@@ -154,20 +140,55 @@
 		eprintf("unknown event %u\n", ev->type);
 	}
 
-	hdr->status = 0;
-	kuring.idx++;
+	ev->status = TGT_EVENT_STATUS_EMPTY;
+	ring_index_inc(&kuring);
 
 	goto retry;
 }
 
 #define CHRDEV_PATH "/dev/tgt"
 
+static int tgt_miscdev_init(char *path, int *fd)
+{
+	int major, minor, err;
+	FILE *fp;
+	char buf[64];
+
+	fp = fopen("/sys/class/misc/tgt/dev", "r");
+	if (!fp) {
+		eprintf("Cannot open control path to the driver\n");
+		return -1;
+	}
+
+	if (!fgets(buf, sizeof(buf), fp))
+		goto out;
+
+	if (sscanf(buf, "%d:%d", &major, &minor) != 2)
+		goto out;
+
+	unlink(path);
+	err = mknod(path, (S_IFCHR | 0600), (major << 8) | minor);
+	if (err)
+		goto out;
+
+	*fd = open(path, O_RDWR);
+	if (*fd < 0) {
+		eprintf("cannot open %s %s\n", path, strerror(errno));
+		goto out;
+	}
+
+	return 0;
+out:
+	fclose(fp);
+	return -errno;
+}
+
 int kreq_init(int *ki_fd)
 {
-	int err, fd, size = TGT_RINGBUF_SIZE;
+	int err, fd, size = TGT_RING_SIZE;
 	char *buf;
 
-	err = chrdev_open("tgt", CHRDEV_PATH, 0, &fd);
+	err = tgt_miscdev_init(CHRDEV_PATH, &fd);
 	if (err)
 		return err;
 
@@ -178,8 +199,9 @@
 		return -EINVAL;
 	}
 
-	ring_init(&kuring, buf, size, sizeof(struct tgt_event));
-	ring_init(&ukring, buf + size, size, sizeof(struct tgt_event));
+	kuring.idx = ukring.idx = 0;
+	kuring.buf = buf;
+	ukring.buf = buf + size;
 
 	*ki_fd = chrfd = fd;
 



From tomo at mail.berlios.de  Thu Aug 17 19:23:00 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 17 Aug 2006 19:23:00 +0200
Subject: [Stgt-svn] r530 - trunk/patchset
Message-ID: <200608171723.k7HHN0dJ004713@sheep.berlios.de>

Author: tomo
Date: 2006-08-17 19:22:56 +0200 (Thu, 17 Aug 2006)
New Revision: 530

Added:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
   trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
Removed:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
   trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
Log:
Add the new patchset.

Deleted: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,48 +0,0 @@
-From 9286b9ae56bd63756c6f4e2993abf049c8f01153 Mon Sep 17 00:00:00 2001
-From: fujita <fujita at debian.localdomain>
-Date: Thu, 17 Aug 2006 06:56:32 +0900
-Subject: [PATCH 1/9] [PATCH] block layer: kill length alignment test in bin_map_user
-
-The tgt project is mapping in bios using bio_map_user. The current targets
-do not need their len to be aligned with a queue limit so this check is
-causing some problems. Note: pointers passed into the kernel are properly
-aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
-
-The major user, blk_bio_map_user checks for the len before mapping
-so it is not affected by this patch.
-
-And the semi-newly added user blk_rq_map_user_iov has been failing
-out when the len is not aligned properly so maybe people have been
-good and not sending misaligned lens or that path is not used very
-often and this change will not be very dangerous. st and sg do not
-check the length and we have not seen any problem reports from those
-wider used paths so this patch should be fairly safe - for mm
-and wider testing at least.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- fs/bio.c |    5 ++---
- 1 files changed, 2 insertions(+), 3 deletions(-)
-
-diff --git a/fs/bio.c b/fs/bio.c
-index 6a0b9ad..6fe47ce 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
--- 
-1.4.1.1
-

Added: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,48 @@
+From 41e2998c000a999a60c4f035af7ab6593cc9b747 Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Thu, 17 Aug 2006 23:47:00 +0900
+Subject: [PATCH 1/9] block layer: kill length alignment test in bin_map_user
+
+The tgt project is mapping in bios using bio_map_user. The current targets
+do not need their len to be aligned with a queue limit so this check is
+causing some problems. Note: pointers passed into the kernel are properly
+aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
+
+The major user, blk_bio_map_user checks for the len before mapping
+so it is not affected by this patch.
+
+And the semi-newly added user blk_rq_map_user_iov has been failing
+out when the len is not aligned properly so maybe people have been
+good and not sending misaligned lens or that path is not used very
+often and this change will not be very dangerous. st and sg do not
+check the length and we have not seen any problem reports from those
+wider used paths so this patch should be fairly safe - for mm
+and wider testing at least.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+diff --git a/fs/bio.c b/fs/bio.c
+index 6a0b9ad..6fe47ce 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.4.1
+

Deleted: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,154 +0,0 @@
-From 810f8fd6b5ad802477ad9a95bbf6540c5d44f2de Mon Sep 17 00:00:00 2001
-From: fujita <fujita at debian.localdomain>
-Date: Thu, 17 Aug 2006 07:31:59 +0900
-Subject: [PATCH 2/9] [PATCH] block layer: add partial mappings support to bio_map_user
-
-For target mode we could end up with the case where we get very large
-request from the initiator. The request could be so large that we
-cannot transfer all the data in one operation. For example the
-HBA's segment or max_sector limits might limit us to a 1 MB transfer.
-To send a 5 MB command then we need to transfer the command chunk by chunk.
-
-To do this, tgt core will map in as much data as possible into a bio,
-send this off, then when that transfer is completed we send off another
-request/bio. To be able to pack as much data into a bio as possible
-we need bio_map_user to support partially mapped bios.
-
-- bio_map_user_iov always allows partial mappings.
-
-- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
-if the bio is partially mapped.
-
-- Added a length argument to blk_rq_map_user_iov in order to avoid
-including sg.h in ll_rw_blk.c for struct sg_iovec.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
- block/scsi_ioctl.c     |    3 ++-
- fs/bio.c               |   14 +-------------
- include/linux/blkdev.h |    3 ++-
- 4 files changed, 23 insertions(+), 26 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index 61d6b3c..aee4f4b 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
--	if (!IS_ERR(bio)) {
--		rq->bio = rq->biotail = bio;
--		blk_rq_bio_prep(q, rq, bio);
-+	if (IS_ERR(bio))
-+		return PTR_ERR(bio);
- 
--		rq->buffer = rq->data = NULL;
--		rq->data_len = len;
--		return 0;
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
- 	}
- 
--	/*
--	 * bio is the err-ptr
--	 */
--	return PTR_ERR(bio);
-+	rq->bio = rq->biotail = bio;
-+	blk_rq_bio_prep(q, rq, bio);
-+	rq->buffer = rq->data = NULL;
-+	rq->data_len = len;
-+	return 0;
- }
- 
- EXPORT_SYMBOL(blk_rq_map_user);
-@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
-  *    unmapping.
-  */
- int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
--			struct sg_iovec *iov, int iov_count)
-+			struct sg_iovec *iov, int iov_count, unsigned int len)
- {
- 	struct bio *bio;
- 
-@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
-+	}
-+
- 	rq->bio = rq->biotail = bio;
- 	blk_rq_bio_prep(q, rq, bio);
- 	rq->buffer = rq->data = NULL;
-diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
-index b33eda2..b77e185 100644
---- a/block/scsi_ioctl.c
-+++ b/block/scsi_ioctl.c
-@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
- 			goto out;
- 		}
- 
--		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
-+		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
-+					  hdr->dxfer_len);
- 		kfree(iov);
- 	} else if (hdr->dxfer_len)
- 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
-diff --git a/fs/bio.c b/fs/bio.c
-index 6fe47ce..ade77bf 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
- 			     int write_to_vm)
- {
- 	struct bio *bio;
--	int len = 0, i;
- 
- 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
- 
-@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
- 	 */
- 	bio_get(bio);
- 
--	for (i = 0; i < iov_count; i++)
--		len += iov[i].iov_len;
--
--	if (bio->bi_size == len)
--		return bio;
--
--	/*
--	 * don't support partial mappings
--	 */
--	bio_endio(bio, bio->bi_size, 0);
--	bio_unmap_user(bio);
--	return ERR_PTR(-EINVAL);
-+	return bio;
- }
- 
- static void __bio_unmap_user(struct bio *bio)
-diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
-index aafe827..613a441 100644
---- a/include/linux/blkdev.h
-+++ b/include/linux/blkdev.h
-@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
- extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
- extern int blk_rq_unmap_user(struct bio *, unsigned int);
- extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
--extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
-+extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
-+			       struct sg_iovec *, int, unsigned int);
- extern int blk_execute_rq(request_queue_t *, struct gendisk *,
- 			  struct request *, int);
- extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
--- 
-1.4.1.1
-

Added: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,154 @@
+From edae3e91816a0aa1d6afc5bfc5c7cbdb8d2f1229 Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Thu, 17 Aug 2006 23:48:58 +0900
+Subject: [PATCH 2/9] block layer: add partial mappings support to bio_map_user
+
+For target mode we could end up with the case where we get very large
+request from the initiator. The request could be so large that we
+cannot transfer all the data in one operation. For example the
+HBA's segment or max_sector limits might limit us to a 1 MB transfer.
+To send a 5 MB command then we need to transfer the command chunk by chunk.
+
+To do this, tgt core will map in as much data as possible into a bio,
+send this off, then when that transfer is completed we send off another
+request/bio. To be able to pack as much data into a bio as possible
+we need bio_map_user to support partially mapped bios.
+
+- bio_map_user_iov always allows partial mappings.
+
+- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
+if the bio is partially mapped.
+
+- Added a length argument to blk_rq_map_user_iov in order to avoid
+including sg.h in ll_rw_blk.c for struct sg_iovec.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
+ block/scsi_ioctl.c     |    3 ++-
+ fs/bio.c               |   14 +-------------
+ include/linux/blkdev.h |    3 ++-
+ 4 files changed, 23 insertions(+), 26 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 61d6b3c..aee4f4b 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+-	if (!IS_ERR(bio)) {
+-		rq->bio = rq->biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq->buffer = rq->data = NULL;
+-		rq->data_len = len;
+-		return 0;
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq->bio = rq->biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq->buffer = rq->data = NULL;
++	rq->data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq->bio = rq->biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq->buffer = rq->data = NULL;
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index b33eda2..b77e185 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
++					  hdr->dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
+diff --git a/fs/bio.c b/fs/bio.c
+index 6fe47ce..ade77bf 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
+ {
+ 	struct bio *bio;
+-	int len = 0, i;
+ 
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
+ 
+@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
+ 
+-	for (i = 0; i < iov_count; i++)
+-		len += iov[i].iov_len;
+-
+-	if (bio->bi_size == len)
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio->bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
+ 
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index aafe827..613a441 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
+-- 
+1.4.1
+

Deleted: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,54 +0,0 @@
-From 682da4d3e68a63d56a8a306b9e61ea0305be19d6 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Wed, 16 Aug 2006 08:23:21 +0900
-Subject: [PATCH 3/9] [PATCH] block layer: use blk_rq_bio_prep in init_request_from_bio
-
-Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
-blk_rq_bio_prep's flags copying. The first three bits have not been
-the same for some time so that has been broken. The user of
-blk_rq_bio_prep will setup the request flags so if it wanted failfast
-or to be a barrier it will set the correct flag itself.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c |   11 ++---------
- 1 files changed, 2 insertions(+), 9 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index aee4f4b..3f46356 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
- 
- 	req->errors = 0;
- 	req->hard_sector = req->sector = bio->bi_sector;
--	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
--	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
--	req->nr_phys_segments = bio_phys_segments(req->q, bio);
--	req->nr_hw_segments = bio_hw_segments(req->q, bio);
--	req->buffer = bio_data(bio);	/* see ->buffer comment above */
- 	req->waiting = NULL;
--	req->bio = req->biotail = bio;
- 	req->ioprio = bio_prio(bio);
- 	req->rq_disk = bio->bi_bdev->bd_disk;
- 	req->start_time = jiffies;
-+
-+	blk_rq_bio_prep(req->q, req, bio);
- }
- 
- static int __make_request(request_queue_t *q, struct bio *bio)
-@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
- 
- void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
- {
--	/* first two bits are identical in rq->flags and bio->bi_rw */
--	rq->flags |= (bio->bi_rw & 3);
--
- 	rq->nr_phys_segments = bio_phys_segments(q, bio);
- 	rq->nr_hw_segments = bio_hw_segments(q, bio);
- 	rq->current_nr_sectors = bio_cur_sectors(bio);
--- 
-1.4.1.1
-

Added: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,54 @@
+From 23c2123adf959725f1f7b49b0b13606725586d82 Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Thu, 17 Aug 2006 23:52:17 +0900
+Subject: [PATCH 3/9] block layer: use blk_rq_bio_prep in init_request_from_bio
+
+Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
+blk_rq_bio_prep's flags copying. The first three bits have not been
+the same for some time so that has been broken. The user of
+blk_rq_bio_prep will setup the request flags so if it wanted failfast
+or to be a barrier it will set the correct flag itself.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ block/ll_rw_blk.c |   11 ++---------
+ 1 files changed, 2 insertions(+), 9 deletions(-)
+
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index aee4f4b..3f46356 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
+ 
+ 	req->errors = 0;
+ 	req->hard_sector = req->sector = bio->bi_sector;
+-	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
+-	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
+-	req->nr_phys_segments = bio_phys_segments(req->q, bio);
+-	req->nr_hw_segments = bio_hw_segments(req->q, bio);
+-	req->buffer = bio_data(bio);	/* see ->buffer comment above */
+ 	req->waiting = NULL;
+-	req->bio = req->biotail = bio;
+ 	req->ioprio = bio_prio(bio);
+ 	req->rq_disk = bio->bi_bdev->bd_disk;
+ 	req->start_time = jiffies;
++
++	blk_rq_bio_prep(req->q, req, bio);
+ }
+ 
+ static int __make_request(request_queue_t *q, struct bio *bio)
+@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
+ 
+ void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
+ {
+-	/* first two bits are identical in rq->flags and bio->bi_rw */
+-	rq->flags |= (bio->bi_rw & 3);
+-
+ 	rq->nr_phys_segments = bio_phys_segments(q, bio);
+ 	rq->nr_hw_segments = bio_hw_segments(q, bio);
+ 	rq->current_nr_sectors = bio_cur_sectors(bio);
+-- 
+1.4.1
+

Deleted: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,306 +0,0 @@
-From 26dc82d471a4e83acec09789c8da6cc7fa788c89 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:39:42 +0900
-Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
-
-This patch contains the needed changes to the scsi-ml to support targets.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/hosts.c     |    4 ++++
- drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
- drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
- include/scsi/scsi_cmnd.h |    7 +++++++
- include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
- 5 files changed, 104 insertions(+), 26 deletions(-)
-
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index dfcb96f..341c1ee 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
- 		kthread_stop(shost->ehandler);
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
- 
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index b332cad..08f8597 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
-+{
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(dev);
-+}
-+EXPORT_SYMBOL(__scsi_put_command);
-+
- /*
-  * Function:	scsi_put_command()
-  *
-@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
--
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 077c1c6..ea22612 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -734,7 +734,9 @@ #endif
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 58e6444..254a904 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@ #include <linux/timer.h>
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- 
- 
-@@ -133,7 +134,10 @@ #define SCSI_STATE_MLQUEUE         0x100
- 
- 
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
-@@ -142,4 +146,7 @@ extern void *scsi_kmap_atomic_sg(struct 
- 				 size_t *offset, size_t *len);
- extern void scsi_kunmap_atomic_sg(void *virt);
- 
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
-+
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index b3dd90f..1a393b6 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@ #include <linux/types.h>
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -122,6 +123,39 @@ #endif
- 	int (* queuecommand)(struct scsi_cmnd *,
- 			     void (*done)(struct scsi_cmnd *));
- 
-+ 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/* Used as callback for the completion of task management request. */
-+	int (* tsk_mgmt_response)(u64 mid, int result);
-+
- 	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
-@@ -561,6 +595,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+						void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
--- 
-1.4.1.1
-

Added: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,330 @@
+From 3ee7022b3d6bed6ea506c205e58f03588d7a170e Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Thu, 17 Aug 2006 23:56:41 +0900
+Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+This patch contains the needed changes to the scsi-ml to support targets.
+
+Note, per the last review we moved almost all the fields we added
+to the scsi_cmnd to our internal data structure which we are going
+to try and kill off when we can replace it with support from other
+parts of the kernel.
+
+The one field we left on was the offset variable. This is needed to handle
+the case where the target gets request that is so large that it cannot
+execute it in one dma operation. So max_secotors or a segment limit may
+limit the size of the transfer. In this case our tgt core code will
+break up the command into managable transfers and send them to the
+LLD one at a time. The offset is then used to tell the LLD where in
+the command we are at. Is there another field on the scsi_cmd for
+that?
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/hosts.c     |    4 ++++
+ drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
+ include/scsi/scsi_cmnd.h |   10 ++++++++++
+ include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
+ 5 files changed, 107 insertions(+), 26 deletions(-)
+
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index dfcb96f..341c1ee 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
+ 		kthread_stop(shost->ehandler);
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
+ 
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index b332cad..08f8597 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&dev->sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
++{
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(dev);
++}
++EXPORT_SYMBOL(__scsi_put_command);
++
+ /*
+  * Function:	scsi_put_command()
+  *
+@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd->device;
+-	struct Scsi_Host *shost = sdev->host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&cmd->device->list_lock, flags);
+ 	BUG_ON(list_empty(&cmd->list));
+ 	list_del_init(&cmd->list);
+-	spin_unlock(&cmd->device->list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&shost->free_list_lock);
+-	if (unlikely(list_empty(&shost->free_list))) {
+-		list_add(&cmd->list, &shost->free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
+ 
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost->cmd_pool->slab, cmd);
+-
+-	put_device(&sdev->sdev_gendev);
++	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 077c1c6..ea22612 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -734,7 +734,9 @@ #endif
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 58e6444..fe4455c 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@ #include <linux/timer.h>
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ 
+ 
+@@ -72,6 +73,9 @@ #define MAX_COMMAND_SIZE	16
+ 	unsigned short use_sg;	/* Number of pieces of scatter-gather */
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
++
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+ 
+@@ -133,7 +137,10 @@ #define SCSI_STATE_MLQUEUE         0x100
+ 
+ 
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
+ extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
+@@ -142,4 +149,7 @@ extern void *scsi_kmap_atomic_sg(struct 
+ 				 size_t *offset, size_t *len);
+ extern void scsi_kunmap_atomic_sg(void *virt);
+ 
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
++
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index b3dd90f..1a393b6 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@ #include <linux/types.h>
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -122,6 +123,39 @@ #endif
+ 	int (* queuecommand)(struct scsi_cmnd *,
+ 			     void (*done)(struct scsi_cmnd *));
+ 
++ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
+ 	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+@@ -561,6 +595,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++						void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.4.1
+

Deleted: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,787 +0,0 @@
-From 74646b3cdc53f2f8bee28d5d5533b08ef93253c2 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:42:16 +0900
-Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
-
-The core scsi target lib functions.
-
-TODO:
-- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
-do that weird include.
-- convert scsi_tgt_cmd's work struct to James's execute code. And try
-to kill our scsi_tgt_cmd.
-- add host state checking. We do refcouting so hotplug is partially
-supported, but we need to add state checking to make it easier on
-the LLD.
-- must remove our request->flags hack
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/scsi_tgt_lib.c  |  699 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   24 +
- include/scsi/scsi_tgt.h      |   17 +
- 3 files changed, 740 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-new file mode 100644
-index 0000000..f7ae7e2
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,699 @@
-+/*
-+ * SCSI target lib functions
-+ *
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/hash.h>
-+#include <linux/module.h>
-+#include <linux/pagemap.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <../drivers/md/dm-bio-list.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static struct workqueue_struct *scsi_tgtd;
-+static kmem_cache_t *scsi_tgt_cmd_cache;
-+
-+/*
-+ * TODO: this struct will be killed when the block layer supports large bios
-+ * and James's work struct code is in
-+ */
-+struct scsi_tgt_cmd {
-+	/* TODO replace work with James b's code */
-+	struct work_struct work;
-+	/* TODO replace the lists with a large bio */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
-+
-+	struct list_head hash_list;
-+	struct request *rq;
-+	u64 tag;
-+
-+	void *buffer;
-+	unsigned bufflen;
-+	unsigned offset; /* we need this ? */
-+};
-+
-+#define TGT_HASH_ORDER	4
-+#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
-+
-+struct scsi_tgt_queuedata {
-+	struct Scsi_Host *shost;
-+	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
-+	spinlock_t cmd_hash_lock;
-+};
-+
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq->end_io_data = tcmd;
-+
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+	tcmd->rq = rq;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+static void scsi_host_put_command(struct Scsi_Host *shost,
-+				  struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q->queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-+}
-+
-+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-+{
-+	struct bio *bio;
-+
-+	/* must call bio_endio in case bio was bounced */
-+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+
-+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+}
-+
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_del(&tcmd->hash_list);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+static void scsi_tgt_cmd_destroy(void *data)
-+{
-+	struct scsi_cmnd *cmd = data;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
-+		rq_data_dir(cmd->request));
-+
-+	cmd_hashlist_del(cmd);
-+
-+	/*
-+	 * We must set rq->flags here because bio_map_user and
-+	 * blk_rq_bio_prep ruined ti.
-+	 */
-+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-+		cmd->request->flags |= 1;
-+	else
-+		cmd->request->flags &= ~1UL;
-+
-+	scsi_unmap_user_pages(tcmd);
-+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-+}
-+
-+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
-+			      u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
-+	unsigned long flags;
-+	struct list_head *head;
-+
-+	tcmd->tag = tag;
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	list_add(&tcmd->hash_list, head);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+/*
-+ * scsi_tgt_alloc_queue - setup queue used for message passing
-+ * shost: scsi host
-+ *
-+ * This should be called by the LLD after host allocation.
-+ * And will be released when the host is released.
-+ */
-+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-+{
-+	struct scsi_tgt_queuedata *queuedata;
-+	struct request_queue *q;
-+	int err, i;
-+
-+	/*
-+	 * Do we need to send a netlink event or should uspace
-+	 * just respond to the hotplug event?
-+	 */
-+	q = __scsi_alloc_queue(shost, NULL);
-+	if (!q)
-+		return -ENOMEM;
-+
-+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-+	if (!queuedata) {
-+		err = -ENOMEM;
-+		goto cleanup_queue;
-+	}
-+	queuedata->shost = shost;
-+	q->queuedata = queuedata;
-+
-+	/*
-+	 * this is a silly hack. We should probably just queue as many
-+	 * command as is recvd to userspace. uspace can then make
-+	 * sure we do not overload the HBA
-+	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	/*
-+	 * We currently only support software LLDs so this does
-+	 * not matter for now. Do we need this for the cards we support?
-+	 * If so we should make it a host template value.
-+	 */
-+	blk_queue_dma_alignment(q, 0);
-+	shost->uspace_req_q = q;
-+
-+	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
-+		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
-+	spin_lock_init(&queuedata->cmd_hash_lock);
-+
-+	return 0;
-+
-+cleanup_queue:
-+	blk_cleanup_queue(q);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-+
-+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-+	return queue->shost;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-+
-+/*
-+ * scsi_tgt_queue_command - queue command for userspace processing
-+ * @cmd:	scsi command
-+ * @scsilun:	scsi lun
-+ * @tag:	unique value to identify this command for tmf
-+ */
-+int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			   u64 tag)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	init_scsi_tgt_cmd(cmd->request, tcmd, tag);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-+
-+/*
-+ * This is run from a interrpt handler normally and the unmap
-+ * needs process context so we must queue
-+ */
-+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-+	queue_work(scsi_tgtd, &tcmd->work);
-+}
-+
-+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	int err;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-+	switch (err) {
-+	case SCSI_MLQUEUE_HOST_BUSY:
-+	case SCSI_MLQUEUE_DEVICE_BUSY:
-+		return -EAGAIN;
-+	}
-+
-+	return 0;
-+}
-+
-+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	err = __scsi_tgt_transfer_response(cmd);
-+	if (!err)
-+		return;
-+
-+	cmd->result = DID_BUS_BUSY << 16;
-+	err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	if (err <= 0)
-+		/* the eh will have to pick this up */
-+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+}
-+
-+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	int count;
-+
-+	cmd->use_sg = rq->nr_phys_segments;
-+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-+	if (!cmd->request_buffer)
-+		return -ENOMEM;
-+
-+	cmd->request_bufflen = rq->data_len;
-+
-+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
-+		rq_data_dir(rq));
-+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-+	if (likely(count <= cmd->use_sg)) {
-+		cmd->use_sg = count;
-+		return 0;
-+	}
-+
-+	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	return -EINVAL;
-+}
-+
-+/* TODO: test this crap and replace bio_map_user with new interface maybe */
-+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-+			       int rw)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct request *rq = cmd->request;
-+	void *uaddr = tcmd->buffer;
-+	unsigned int len = tcmd->bufflen;
-+	struct bio *bio;
-+	int err;
-+
-+	while (len > 0) {
-+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
-+		if (IS_ERR(bio)) {
-+			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u %d %x\n",
-+				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-+			goto unmap_bios;
-+		}
-+
-+		uaddr += bio->bi_size;
-+		len -= bio->bi_size;
-+
-+		/*
-+		 * The first bio is added and merged. We could probably
-+		 * try to add others using scsi_merge_bio() but for now
-+		 * we keep it simple. The first bio should be pretty large
-+		 * (either hitting the 1 MB bio pages limit or a queue limit)
-+		 * already but for really large IO we may want to try and
-+		 * merge these.
-+		 */
-+		if (!rq->bio) {
-+			blk_rq_bio_prep(q, rq, bio);
-+			rq->data_len = bio->bi_size;
-+		} else
-+			/* put list of bios to transfer in next go around */
-+			bio_list_add(&tcmd->xfer_list, bio);
-+	}
-+
-+	tcmd->offset = 0;
-+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-+	if (err)
-+		goto unmap_bios;
-+
-+	return 0;
-+
-+unmap_bios:
-+	if (rq->bio) {
-+		bio_unmap_user(rq->bio);
-+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-+			bio_unmap_user(bio);
-+	}
-+
-+	return err;
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-+
-+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	struct bio *bio;
-+	int err;
-+
-+	/* should we free resources here on error ? */
-+	if (cmd->result) {
-+send_uspace_err:
-+		err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+		if (err <= 0)
-+			/* the tgt uspace eh will have to pick this up */
-+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-+
-+	tcmd->buffer += cmd->request_bufflen;
-+	tcmd->offset += cmd->request_bufflen;
-+
-+	if (!tcmd->xfer_list.head) {
-+		scsi_tgt_transfer_response(cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	bio = bio_list_pop(&tcmd->xfer_list);
-+	BUG_ON(!bio);
-+
-+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-+	cmd->request->data_len = bio->bi_size;
-+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-+	if (err) {
-+		cmd->result = DID_ERROR << 16;
-+		goto send_uspace_err;
-+	}
-+
-+	if (scsi_tgt_transfer_data(cmd)) {
-+		cmd->result = DID_NO_CONNECT << 16;
-+		goto send_uspace_err;
-+	}
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-+
-+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-+	switch (err) {
-+		case SCSI_MLQUEUE_HOST_BUSY:
-+		case SCSI_MLQUEUE_DEVICE_BUSY:
-+			return -EAGAIN;
-+	default:
-+		return 0;
-+	}
-+}
-+
-+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-+				unsigned len)
-+{
-+	char __user *p = (char __user *) uaddr;
-+
-+	if (copy_from_user(cmd->sense_buffer, p,
-+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-+		printk(KERN_ERR "Could not copy the sense buffer\n");
-+		return -EIO;
-+	}
-+	return 0;
-+}
-+
-+static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = host->hostt->eh_abort_handler(cmd);
-+	if (err)
-+		eprintk("fail to abort %p\n", cmd);
-+
-+	scsi_tgt_cmd_destroy(cmd);
-+	return err;
-+}
-+
-+static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	struct request *rq = NULL;
-+	struct list_head *head;
-+	struct scsi_tgt_cmd *tcmd;
-+	unsigned long flags;
-+
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_for_each_entry(tcmd, head, hash_list) {
-+		if (tcmd->tag == tag) {
-+			rq = tcmd->rq;
-+			break;
-+		}
-+	}
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+
-+	return rq;
-+}
-+
-+int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+			 unsigned long uaddr, u8 rw)
-+{
-+	struct Scsi_Host *shost;
-+	struct scsi_cmnd *cmd;
-+	struct request *rq;
-+	struct scsi_tgt_cmd *tcmd;
-+	int err = 0;
-+
-+	dprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,
-+		result, len, uaddr, rw);
-+
-+	/* TODO: replace with a O(1) alg */
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+
-+	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
-+	if (!rq) {
-+		printk(KERN_ERR "Could not find tag %llu\n",
-+		       (unsigned long long) tag);
-+		err = -EINVAL;
-+		goto done;
-+	}
-+	cmd = rq->special;
-+
-+	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
-+		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
-+
-+	if (result == TASK_ABORTED) {
-+		scsi_tgt_abort_cmd(shost, cmd);
-+		goto done;
-+	}
-+	/*
-+	 * store the userspace values here, the working values are
-+	 * in the request_* values
-+	 */
-+	tcmd = cmd->request->end_io_data;
-+	tcmd->buffer = (void *)uaddr;
-+	tcmd->bufflen = len;
-+	cmd->result = result;
-+
-+	if (!tcmd->bufflen) {
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+
-+	/*
-+	 * TODO: Do we need to handle case where request does not
-+	 * align with LLD.
-+	 */
-+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-+	if (err) {
-+		eprintk("%p %d\n", cmd, err);
-+		err = -EAGAIN;
-+		goto done;
-+	}
-+
-+	/* userspace failure */
-+	if (cmd->result) {
-+		if (status_byte(cmd->result) == CHECK_CONDITION)
-+			scsi_tgt_copy_sense(cmd, uaddr, len);
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+	/* ask the target LLD to transfer the data to the buffer */
-+	err = scsi_tgt_transfer_data(cmd);
-+
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-+			      struct scsi_lun *scsilun, void *data)
-+{
-+	int err;
-+
-+	/* TODO: need to retry if this fails. */
-+	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
-+					    tag, scsilun, data);
-+	if (err < 0)
-+		eprintk("The task management request lost!\n");
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-+
-+int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-+{
-+	struct Scsi_Host *shost;
-+	int err;
-+
-+	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
-+
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+	err = shost->hostt->tsk_mgmt_response(mid, result);
-+	scsi_host_put(shost);
-+
-+	return err;
-+}
-+
-+static int __init scsi_tgt_init(void)
-+{
-+	int err;
-+
-+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-+					       sizeof(struct scsi_tgt_cmd),
-+					       0, 0, NULL, NULL);
-+	if (!scsi_tgt_cmd_cache)
-+		return -ENOMEM;
-+
-+	scsi_tgtd = create_workqueue("scsi_tgtd");
-+	if (!scsi_tgtd) {
-+		err = -ENOMEM;
-+		goto free_kmemcache;
-+	}
-+
-+	err = scsi_tgt_if_init();
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(scsi_tgtd);
-+free_kmemcache:
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+	return err;
-+}
-+
-+static void __exit scsi_tgt_exit(void)
-+{
-+	destroy_workqueue(scsi_tgtd);
-+	scsi_tgt_if_exit();
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+}
-+
-+module_init(scsi_tgt_init);
-+module_exit(scsi_tgt_exit);
-+
-+MODULE_DESCRIPTION("SCSI target core");
-+MODULE_LICENSE("GPL");
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-new file mode 100644
-index 0000000..b7b6ea6
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,24 @@
-+struct scsi_cmnd;
-+struct scsi_lun;
-+struct Scsi_Host;
-+struct task_struct;
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+
-+#define dprintk eprintk
-+
-+extern void scsi_tgt_if_exit(void);
-+extern int scsi_tgt_if_init(void);
-+
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
-+extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+				unsigned long uaddr, u8 rw);
-+extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+					 struct scsi_lun *scsilun, void *data);
-+extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..61e8ee9
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,17 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+#include <linux/dma-mapping.h>
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
-+extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
-+				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
--- 
-1.4.1.1
-

Added: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,788 @@
+From dc6a0cdc52e680b696d86b25d698a847205cad98 Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Fri, 18 Aug 2006 00:45:35 +0900
+Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
+
+The core scsi target lib functions.
+
+TODO:
+- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
+do that weird include.
+- convert scsi_tgt_cmd's work struct to James's execute code. And try
+to kill our scsi_tgt_cmd.
+- add host state checking. We do refcouting so hotplug is partially
+supported, but we need to add state checking to make it easier on
+the LLD.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/scsi_tgt_lib.c  |  700 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   24 +
+ include/scsi/scsi_tgt.h      |   18 +
+ 3 files changed, 742 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..c515c27
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,700 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/blkdev.h>
++#include <linux/hash.h>
++#include <linux/module.h>
++#include <linux/pagemap.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <../drivers/md/dm-bio-list.h>
++
++#include "scsi_tgt_priv.h"
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++
++	struct list_head hash_list;
++	struct request *rq;
++	u64 tag;
++
++	void *buffer;
++	unsigned bufflen;
++};
++
++#define TGT_HASH_ORDER	4
++#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
++	spinlock_t cmd_hash_lock;
++};
++
++/*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		goto put_dev;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto free_tcmd;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++	rq->end_io_data = tcmd;
++
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++	tcmd->rq = rq;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++free_tcmd:
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
++	unsigned long flags;
++
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++
++	spin_lock_irqsave(q->queue_lock, flags);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	__scsi_put_command(shost, cmd, &shost->shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void cmd_hashlist_del(struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = cmd->request->q;
++	struct scsi_tgt_queuedata *qdata = q->queuedata;
++	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	list_del(&tcmd->hash_list);
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
++		rq_data_dir(cmd->request));
++
++	cmd_hashlist_del(cmd);
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
++			      u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
++	unsigned long flags;
++	struct list_head *head;
++
++	tcmd->tag = tag;
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	head = &qdata->cmd_hash[cmd_hashfn(tag)];
++	list_add(&tcmd->hash_list, head);
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++}
++
++/*
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ */
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err, i;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, NULL);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata->shost = shost;
++	q->queuedata = queuedata;
++
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q->nr_requests = shost->hostt->can_queue;
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost->uspace_req_q = q;
++
++	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
++		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
++	spin_lock_init(&queuedata->cmd_hash_lock);
++
++	return 0;
++
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
++	return queue->shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/*
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @tag:	unique value to identify this command for tmf
++ */
++int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			   u64 tag)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	int err;
++
++	init_scsi_tgt_cmd(cmd->request, tcmd, tag);
++	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
++	if (err)
++		cmd_hashlist_del(cmd);
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &tcmd->work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
++
++	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd->result = DID_BUS_BUSY << 16;
++	err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++	if (err <= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd->request;
++	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
++	int count;
++
++	cmd->use_sg = rq->nr_phys_segments;
++	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd->request_buffer)
++		return -ENOMEM;
++
++	cmd->request_bufflen = rq->data_len;
++
++	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
++		rq_data_dir(rq));
++	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
++	if (likely(count <= cmd->use_sg)) {
++		cmd->use_sg = count;
++		return 0;
++	}
++
++	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd->request->q;
++	struct request *rq = cmd->request;
++	void *uaddr = tcmd->buffer;
++	unsigned int len = tcmd->bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len > 0) {
++		dprintk("%lx %u\n", (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk("fail to map %lx %u %d %x\n",
++				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
++			goto unmap_bios;
++		}
++
++		uaddr += bio->bi_size;
++		len -= bio->bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq->bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq->data_len = bio->bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&tcmd->xfer_list, bio);
++	}
++
++	cmd->offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq->bio) {
++		bio_unmap_user(rq->bio);
++		while ((bio = bio_list_pop(&tcmd->xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd->result) {
++send_uspace_err:
++		err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
++		if (err <= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
++		return;
++	}
++
++	dprintk("cmd %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, tcmd->bufflen);
++
++	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
++	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
++
++	tcmd->buffer += cmd->request_bufflen;
++	cmd->offset += cmd->request_bufflen;
++
++	if (!tcmd->xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
++		cmd, cmd->request_bufflen, tcmd->bufflen);
++
++	bio = bio_list_pop(&tcmd->xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
++	cmd->request->data_len = bio->bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd->result = DID_ERROR << 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd->result = DID_NO_CONNECT << 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd->sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR "Could not copy the sense buffer\n");
++		return -EIO;
++	}
++	return 0;
++}
++
++static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = host->hostt->eh_abort_handler(cmd);
++	if (err)
++		eprintk("fail to abort %p\n", cmd);
++
++	scsi_tgt_cmd_destroy(cmd);
++	return err;
++}
++
++static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
++{
++	struct scsi_tgt_queuedata *qdata = q->queuedata;
++	struct request *rq = NULL;
++	struct list_head *head;
++	struct scsi_tgt_cmd *tcmd;
++	unsigned long flags;
++
++	head = &qdata->cmd_hash[cmd_hashfn(tag)];
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	list_for_each_entry(tcmd, head, hash_list) {
++		if (tcmd->tag == tag) {
++			rq = tcmd->rq;
++			break;
++		}
++	}
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++
++	return rq;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++			 unsigned long uaddr, u8 rw)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	struct scsi_tgt_cmd *tcmd;
++	int err = 0;
++
++	dprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,
++		result, len, uaddr, rw);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return -EINVAL;
++	}
++
++	if (!shost->uspace_req_q) {
++		printk(KERN_ERR "Not target scsi host %d\n", host_no);
++		goto done;
++	}
++
++	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
++	if (!rq) {
++		printk(KERN_ERR "Could not find tag %llu\n",
++		       (unsigned long long) tag);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq->special;
++
++	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
++		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
++
++	if (result == TASK_ABORTED) {
++		scsi_tgt_abort_cmd(shost, cmd);
++		goto done;
++	}
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	tcmd = cmd->request->end_io_data;
++	tcmd->buffer = (void *)uaddr;
++	tcmd->bufflen = len;
++	cmd->result = result;
++
++	if (!tcmd->bufflen || cmd->request_buffer) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
++	if (err) {
++		eprintk("%p %d\n", cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd->result) {
++		if (status_byte(cmd->result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
++			      struct scsi_lun *scsilun, void *data)
++{
++	int err;
++
++	/* TODO: need to retry if this fails. */
++	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
++					    tag, scsilun, data);
++	if (err < 0)
++		eprintk("The task management request lost!\n");
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
++
++int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
++{
++	struct Scsi_Host *shost;
++	int err = -EINVAL;
++
++	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
++
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR "Could not find host no %d\n", host_no);
++		return err;
++	}
++
++	if (!shost->uspace_req_q) {
++		printk(KERN_ERR "Not target scsi host %d\n", host_no);
++		goto done;
++	}
++
++	err = shost->hostt->tsk_mgmt_response(mid, result);
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue("scsi_tgtd");
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION("SCSI target core");
++MODULE_LICENSE("GPL");
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..b7b6ea6
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,24 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define dprintk eprintk
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				    u64 tag);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
++extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
++				unsigned long uaddr, u8 rw);
++extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++					 struct scsi_lun *scsilun, void *data);
++extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..1771151
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,18 @@
++/*
++ * SCSI target definitions
++ */
++
++#include <linux/dma-mapping.h>
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
+-- 
+1.4.1
+

Deleted: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,481 +0,0 @@
-From c4e930538407cf31b2eb9f718685cd07e4070569 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:44:21 +0900
-Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
-
-The user-space damoen and tgt kernel module need to exhange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch addes shared memory interface between kernel and user
-spaces like some other drivers do. The user-space damoen and tgt
-kernel module creates shared memory via mmap and use it like ring
-buffer. poll (kernel to user) and write (user to kernel) system calls
-are used for notification.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
----
- drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/scsi_tgt_if.h |   93 ++++++++++++
- 2 files changed, 443 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-new file mode 100644
-index 0000000..09c4ab1
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,350 @@
-+/*
-+ * SCSI target kernel/user interface functions
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/miscdevice.h>
-+#include <linux/file.h>
-+#include <net/tcp.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/scsi_tgt_if.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+struct tgt_ring {
-+	u32 tr_idx;
-+	unsigned long tr_pages[TGT_RING_PAGES];
-+	spinlock_t tr_lock;
-+};
-+
-+/* tx_ring : kernel->user, rx_ring : user->kernel */
-+static struct tgt_ring tx_ring, rx_ring;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
-+
-+static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
-+{
-+	if (ring->tr_idx == TGT_MAX_EVENTS - 1)
-+		ring->tr_idx = 0;
-+	else
-+		ring->tr_idx++;
-+}
-+
-+static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
-+{
-+	u32 pidx, off;
-+
-+	pidx = idx / TGT_EVENT_PER_PAGE;
-+	off = idx % TGT_EVENT_PER_PAGE;
-+
-+	return (struct tgt_event *)
-+		(ring->tr_pages[pidx] + sizeof(struct tgt_event) * off);
-+}
-+
-+static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	ev = tgt_head_event(ring, ring->tr_idx);
-+	if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+		tgt_ring_idx_inc(ring);
-+	else
-+		err = -BUSY;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	if (err)
-+		return err;
-+
-+	memcpy(ev, p, sizeof(*ev));
-+	ev->type = type;
-+	ev->status = TGT_EVENT_STATUS_USED;
-+	mb();
-+
-+	flush_dcache_page(virt_to_page(ev));
-+
-+	wake_up_interruptible(&tgt_poll_wait);
-+
-+	return 0;
-+}
-+
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost->host_no;
-+	ev.k.cmd_req.data_len = cmd->request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd->tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_done.host_no = shost->host_no;
-+	ev.k.cmd_done.tag = tag;
-+	ev.k.cmd_done.result = cmd->result;
-+
-+	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
-+		(unsigned long long) ev.k.cmd_req.tag,
-+		ev.k.cmd_req.data_len, cmd->tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+				  struct scsi_lun *scsilun, void *data)
-+{
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.tsk_mgmt_req.host_no = host_no;
-+	ev.k.tsk_mgmt_req.function = function;
-+	ev.k.tsk_mgmt_req.tag = tag;
-+	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-+	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
-+
-+	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
-+		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+static int event_recv_msg(struct tgt_event *ev)
-+{
-+	int err = 0;
-+
-+	switch (ev->type) {
-+	case TGT_UEVENT_CMD_RSP:
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
-+					   ev->u.cmd_rsp.tag,
-+					   ev->u.cmd_rsp.result,
-+					   ev->u.cmd_rsp.len,
-+					   ev->u.cmd_rsp.uaddr,
-+					   ev->u.cmd_rsp.rw);
-+		break;
-+	case TGT_UEVENT_TSK_MGMT_RSP:
-+		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
-+					       ev->u.tsk_mgmt_rsp.mid,
-+					       ev->u.tsk_mgmt_rsp.result);
-+		break;
-+	default:
-+		eprintk("unknown type %d\n", ev->type);
-+		err = -EINVAL;
-+	}
-+
-+	return err;
-+}
-+
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &rx_ring;
-+
-+	while (1) {
-+		ev = tgt_head_event(ring, ring->tr_idx);
-+		if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+			break;
-+
-+		/* do we need this? */
-+		flush_dcache_page(virt_to_page(ev));
-+
-+		tgt_ring_idx_inc(ring);
-+		ev->status = TGT_EVENT_STATUS_EMPTY;
-+		event_recv_msg(ev);
-+	};
-+
-+	return count;
-+}
-+
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	unsigned int mask = 0;
-+	u32 idx;
-+
-+	poll_wait(file, &tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	idx = ring->tr_idx ? ring->tr_idx - 1 : TGT_MAX_EVENTS - 1;
-+	ev = tgt_head_event(ring, idx);
-+	if (ev->status == TGT_EVENT_STATUS_USED)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	return mask;
-+}
-+
-+static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
-+			   struct tgt_ring *ring)
-+{
-+	int i, err;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		struct page *page = virt_to_page(ring->tr_pages[i]);
-+		err = vm_insert_page(vma, addr, page);
-+		if (err)
-+			return err;
-+		addr += PAGE_SIZE;
-+	}
-+
-+	return 0;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long addr;
-+	int err;
-+
-+	if (vma->vm_pgoff)
-+		return -EINVAL;
-+
-+	if (vma->vm_end - vma->vm_start != TGT_RING_SIZE * 2) {
-+		eprintk("mmap size must be %lu, not %lu \n",
-+			TGT_RING_SIZE * 2, vma->vm_end - vma->vm_start);
-+		return -EINVAL;
-+	}
-+
-+	addr = vma->vm_start;
-+	err = uspace_ring_map(vma, addr, &tx_ring);
-+	if (err)
-+		return err;
-+	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &rx_ring);
-+
-+	return err;
-+}
-+
-+static int tgt_open(struct inode *inode, struct file *file)
-+{
-+	tx_ring.tr_idx = rx_ring.tr_idx = 0;
-+
-+	return 0;
-+}
-+
-+static struct file_operations tgt_fops = {
-+	.owner		= THIS_MODULE,
-+	.open		= tgt_open,
-+	.poll		= tgt_poll,
-+	.write		= tgt_write,
-+	.mmap		= tgt_mmap,
-+};
-+
-+static struct miscdevice tgt_miscdev = {
-+	.minor = MISC_DYNAMIC_MINOR,
-+	.name = "tgt",
-+	.fops = &tgt_fops,
-+};
-+
-+static void tgt_ring_exit(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++)
-+		free_page(ring->tr_pages[i]);
-+}
-+
-+static int tgt_ring_init(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	spin_lock_init(&ring->tr_lock);
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		ring->tr_pages[i] = get_zeroed_page(GFP_KERNEL);
-+		if (!ring->tr_pages[i]) {
-+			eprintk("out of memory\n");
-+			return -ENOMEM;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+void scsi_tgt_if_exit(void)
-+{
-+	tgt_ring_exit(&tx_ring);
-+	tgt_ring_exit(&rx_ring);
-+	misc_deregister(&tgt_miscdev);
-+}
-+
-+int scsi_tgt_if_init(void)
-+{
-+	int err;
-+
-+	err = tgt_ring_init(&tx_ring);
-+	if (err)
-+		return err;
-+
-+	err = tgt_ring_init(&rx_ring);
-+	if (err)
-+		goto free_tx_ring;
-+
-+	err = misc_register(&tgt_miscdev);
-+	if (err)
-+		goto free_rx_ring;
-+
-+	return 0;
-+free_rx_ring:
-+	tgt_ring_exit(&rx_ring);
-+free_tx_ring:
-+	tgt_ring_exit(&tx_ring);
-+
-+	return err;
-+}
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..5671920
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,93 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_status {
-+	TGT_EVENT_STATUS_EMPTY = 0,
-+	TGT_EVENT_STATUS_USED,
-+};
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_CMD_RSP,
-+	TGT_UEVENT_TSK_MGMT_RSP,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+	TGT_KEVENT_TSK_MGMT_REQ,
-+};
-+
-+struct tgt_event {
-+	uint32_t status;
-+	uint32_t type;
-+
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint8_t rw;
-+			uint64_t tag;
-+		} cmd_rsp;
-+		struct {
-+			int host_no;
-+			uint64_t mid;
-+			int result;
-+		} tsk_mgmt_rsp;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t data_len;
-+			uint8_t scb[16];
-+			uint8_t lun[8];
-+			int attribute;
-+			uint64_t tag;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint64_t tag;
-+			int result;
-+		} cmd_done;
-+		struct {
-+			int host_no;
-+			int function;
-+			uint64_t tag;
-+			uint8_t lun[8];
-+			uint64_t mid;
-+		} tsk_mgmt_req;
-+	} k;
-+
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RING_SIZE (1UL << 16)
-+#define TGT_RING_PAGES (TGT_RING_SIZE >> PAGE_SHIFT)
-+#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
-+#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
-+
-+#endif
--- 
-1.4.1.1
-

Added: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,481 @@
+From 4587372bbb53c83f86c14cc2f33073937e2ca0b7 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Fri, 18 Aug 2006 00:32:41 +0900
+Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
+
+The user-space daemon and tgt kernel module need to exchange mmapped
+addresses. netlink cannot do that. We need two-way kernel/user
+high-performance interface, however, mainline kernel provides no
+standard interface like that.
+
+This patch adds shared memory interface between kernel and user spaces
+like some other drivers do by using own character device. The
+user-space daemon and tgt kernel module creates shared memory via mmap
+and use it like ring buffer. poll (kernel to user) and write (user to
+kernel) system calls are used for notification.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+---
+ drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/scsi_tgt_if.h |   93 ++++++++++++
+ 2 files changed, 443 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..09c4ab1
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,350 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/miscdevice.h>
++#include <linux/file.h>
++#include <net/tcp.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_device.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/scsi_tgt_if.h>
++
++#include "scsi_tgt_priv.h"
++
++struct tgt_ring {
++	u32 tr_idx;
++	unsigned long tr_pages[TGT_RING_PAGES];
++	spinlock_t tr_lock;
++};
++
++/* tx_ring : kernel->user, rx_ring : user->kernel */
++static struct tgt_ring tx_ring, rx_ring;
++static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
++
++static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
++{
++	if (ring->tr_idx == TGT_MAX_EVENTS - 1)
++		ring->tr_idx = 0;
++	else
++		ring->tr_idx++;
++}
++
++static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
++{
++	u32 pidx, off;
++
++	pidx = idx / TGT_EVENT_PER_PAGE;
++	off = idx % TGT_EVENT_PER_PAGE;
++
++	return (struct tgt_event *)
++		(ring->tr_pages[pidx] + sizeof(struct tgt_event) * off);
++}
++
++static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &tx_ring;
++	unsigned long flags;
++	int err = 0;
++
++	spin_lock_irqsave(&ring->tr_lock, flags);
++
++	ev = tgt_head_event(ring, ring->tr_idx);
++	if (ev->status == TGT_EVENT_STATUS_EMPTY)
++		tgt_ring_idx_inc(ring);
++	else
++		err = -BUSY;
++
++	spin_unlock_irqrestore(&ring->tr_lock, flags);
++
++	if (err)
++		return err;
++
++	memcpy(ev, p, sizeof(*ev));
++	ev->type = type;
++	ev->status = TGT_EVENT_STATUS_USED;
++	mb();
++
++	flush_dcache_page(virt_to_page(ev));
++
++	wake_up_interruptible(&tgt_poll_wait);
++
++	return 0;
++}
++
++int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_req.host_no = shost->host_no;
++	ev.k.cmd_req.data_len = cmd->request_bufflen;
++	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
++	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
++	ev.k.cmd_req.attribute = cmd->tag;
++	ev.k.cmd_req.tag = tag;
++
++	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
++		ev.k.cmd_req.data_len, cmd->tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost->host_no;
++	ev.k.cmd_done.tag = tag;
++	ev.k.cmd_done.result = cmd->result;
++
++	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
++		(unsigned long long) ev.k.cmd_req.tag,
++		ev.k.cmd_req.data_len, cmd->tag);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++				  struct scsi_lun *scsilun, void *data)
++{
++	struct tgt_event ev;
++	int err;
++
++	memset(&ev, 0, sizeof(ev));
++	ev.k.tsk_mgmt_req.host_no = host_no;
++	ev.k.tsk_mgmt_req.function = function;
++	ev.k.tsk_mgmt_req.tag = tag;
++	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
++	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
++
++	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
++		(unsigned long long) ev.k.tsk_mgmt_req.mid);
++
++	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++
++	return err;
++}
++
++static int event_recv_msg(struct tgt_event *ev)
++{
++	int err = 0;
++
++	switch (ev->type) {
++	case TGT_UEVENT_CMD_RSP:
++		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
++					   ev->u.cmd_rsp.tag,
++					   ev->u.cmd_rsp.result,
++					   ev->u.cmd_rsp.len,
++					   ev->u.cmd_rsp.uaddr,
++					   ev->u.cmd_rsp.rw);
++		break;
++	case TGT_UEVENT_TSK_MGMT_RSP:
++		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
++					       ev->u.tsk_mgmt_rsp.mid,
++					       ev->u.tsk_mgmt_rsp.result);
++		break;
++	default:
++		eprintk("unknown type %d\n", ev->type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static ssize_t tgt_write(struct file *file, const char __user * buffer,
++			 size_t count, loff_t * ppos)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &rx_ring;
++
++	while (1) {
++		ev = tgt_head_event(ring, ring->tr_idx);
++		if (ev->status == TGT_EVENT_STATUS_EMPTY)
++			break;
++
++		/* do we need this? */
++		flush_dcache_page(virt_to_page(ev));
++
++		tgt_ring_idx_inc(ring);
++		ev->status = TGT_EVENT_STATUS_EMPTY;
++		event_recv_msg(ev);
++	};
++
++	return count;
++}
++
++static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
++{
++	struct tgt_event *ev;
++	struct tgt_ring *ring = &tx_ring;
++	unsigned long flags;
++	unsigned int mask = 0;
++	u32 idx;
++
++	poll_wait(file, &tgt_poll_wait, wait);
++
++	spin_lock_irqsave(&ring->tr_lock, flags);
++
++	idx = ring->tr_idx ? ring->tr_idx - 1 : TGT_MAX_EVENTS - 1;
++	ev = tgt_head_event(ring, idx);
++	if (ev->status == TGT_EVENT_STATUS_USED)
++		mask |= POLLIN | POLLRDNORM;
++
++	spin_unlock_irqrestore(&ring->tr_lock, flags);
++
++	return mask;
++}
++
++static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
++			   struct tgt_ring *ring)
++{
++	int i, err;
++
++	for (i = 0; i < TGT_RING_PAGES; i++) {
++		struct page *page = virt_to_page(ring->tr_pages[i]);
++		err = vm_insert_page(vma, addr, page);
++		if (err)
++			return err;
++		addr += PAGE_SIZE;
++	}
++
++	return 0;
++}
++
++static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	unsigned long addr;
++	int err;
++
++	if (vma->vm_pgoff)
++		return -EINVAL;
++
++	if (vma->vm_end - vma->vm_start != TGT_RING_SIZE * 2) {
++		eprintk("mmap size must be %lu, not %lu \n",
++			TGT_RING_SIZE * 2, vma->vm_end - vma->vm_start);
++		return -EINVAL;
++	}
++
++	addr = vma->vm_start;
++	err = uspace_ring_map(vma, addr, &tx_ring);
++	if (err)
++		return err;
++	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &rx_ring);
++
++	return err;
++}
++
++static int tgt_open(struct inode *inode, struct file *file)
++{
++	tx_ring.tr_idx = rx_ring.tr_idx = 0;
++
++	return 0;
++}
++
++static struct file_operations tgt_fops = {
++	.owner		= THIS_MODULE,
++	.open		= tgt_open,
++	.poll		= tgt_poll,
++	.write		= tgt_write,
++	.mmap		= tgt_mmap,
++};
++
++static struct miscdevice tgt_miscdev = {
++	.minor = MISC_DYNAMIC_MINOR,
++	.name = "tgt",
++	.fops = &tgt_fops,
++};
++
++static void tgt_ring_exit(struct tgt_ring *ring)
++{
++	int i;
++
++	for (i = 0; i < TGT_RING_PAGES; i++)
++		free_page(ring->tr_pages[i]);
++}
++
++static int tgt_ring_init(struct tgt_ring *ring)
++{
++	int i;
++
++	spin_lock_init(&ring->tr_lock);
++
++	for (i = 0; i < TGT_RING_PAGES; i++) {
++		ring->tr_pages[i] = get_zeroed_page(GFP_KERNEL);
++		if (!ring->tr_pages[i]) {
++			eprintk("out of memory\n");
++			return -ENOMEM;
++		}
++	}
++
++	return 0;
++}
++
++void scsi_tgt_if_exit(void)
++{
++	tgt_ring_exit(&tx_ring);
++	tgt_ring_exit(&rx_ring);
++	misc_deregister(&tgt_miscdev);
++}
++
++int scsi_tgt_if_init(void)
++{
++	int err;
++
++	err = tgt_ring_init(&tx_ring);
++	if (err)
++		return err;
++
++	err = tgt_ring_init(&rx_ring);
++	if (err)
++		goto free_tx_ring;
++
++	err = misc_register(&tgt_miscdev);
++	if (err)
++		goto free_rx_ring;
++
++	return 0;
++free_rx_ring:
++	tgt_ring_exit(&rx_ring);
++free_tx_ring:
++	tgt_ring_exit(&tx_ring);
++
++	return err;
++}
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..5671920
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,93 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_status {
++	TGT_EVENT_STATUS_EMPTY = 0,
++	TGT_EVENT_STATUS_USED,
++};
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
++
++	/* kernel -> user */
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
++};
++
++struct tgt_event {
++	uint32_t status;
++	uint32_t type;
++
++	/* user-> kernel */
++	union {
++		struct {
++			int host_no;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint8_t rw;
++			uint64_t tag;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			uint64_t mid;
++			int result;
++		} tsk_mgmt_rsp;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int host_no;
++			uint32_t data_len;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
++			uint64_t tag;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint64_t tag;
++			int result;
++		} cmd_done;
++		struct {
++			int host_no;
++			int function;
++			uint64_t tag;
++			uint8_t lun[8];
++			uint64_t mid;
++		} tsk_mgmt_req;
++	} k;
++
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#define TGT_RING_SIZE (1UL << 16)
++#define TGT_RING_PAGES (TGT_RING_SIZE >> PAGE_SHIFT)
++#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
++#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
++
++#endif
+-- 
+1.4.1
+

Added: trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
===================================================================
--- trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,57 @@
+From 855bdf3bd4a0c9cbcb57a37fe34a7188e8adb61f Mon Sep 17 00:00:00 2001
+From: Mike Christie <michaelc at cs.wisc.edu>
+Date: Fri, 18 Aug 2006 00:33:17 +0900
+Subject: [PATCH 7/9] scsi-ml: Makefile and Kconfig changes for tgt
+
+Makefile and Kconfig stuff.
+
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig  |    7 +++++++
+ drivers/scsi/Makefile |    3 +++
+ 2 files changed, 10 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 96a81cd..566626c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate "SCSI target support"
++	depends on SCSI && EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool "legacy /proc/scsi/ support"
+ 	depends on SCSI && PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ebd0cf0..ede0c45 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+-- 
+1.4.1
+

Deleted: trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt
===================================================================
--- trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0007-scsi-tgt-scsi-target-netlink-interface.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,57 +0,0 @@
-From fff20a33841c7ab473dea824b4c52e2b9a9c8edc Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:48:43 +0900
-Subject: [PATCH 7/9] scsi tgt: scsi target netlink interface
-
-Makefile and Kconfig stuff.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    7 +++++++
- drivers/scsi/Makefile |    3 +++
- 2 files changed, 10 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 96a81cd..566626c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -27,6 +27,13 @@ config SCSI
- 	  However, do not compile this as a module if your root file system
- 	  (the one containing the directory /) is located on a SCSI device.
- 
-+config SCSI_TGT
-+	tristate "SCSI target support"
-+	depends on SCSI && EXPERIMENTAL
-+	---help---
-+	  If you want to use SCSI target mode drivers enable this option.
-+	  If you choose M, the module will be called scsi_tgt.
-+
- config SCSI_PROC_FS
- 	bool "legacy /proc/scsi/ support"
- 	depends on SCSI && PROC_FS
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ebd0cf0..ede0c45 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
- subdir-$(CONFIG_PCMCIA)		+= pcmcia
- 
- obj-$(CONFIG_SCSI)		+= scsi_mod.o
-+obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
- 
- obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
- 
-@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
- scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
- scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
- 
-+scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
-+
- sd_mod-objs	:= sd.o
- sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
- ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
--- 
-1.4.1.1
-

Added: trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,591 @@
+From 7f19e763441525e31f6b771890ef534e0512398d Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Fri, 18 Aug 2006 00:36:47 +0900
+Subject: [PATCH 8/9] scsi tgt: SCSI RDMA Protocol library functions
+
+libsrp provides helper functions for SRP target drivers.
+
+The next step would be to add initiator support to merge the two SRP
+initiator drivers (ibmvscsi and ib_srp) in mainline.
+
+Some SRP target drivers would be out of drivers/scsi/ so I added an
+entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
+it.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig  |    9 +
+ drivers/scsi/Makefile |    1 
+ drivers/scsi/libsrp.c |  441 +++++++++++++++++++++++++++++++++++++++++++++++++
+ include/scsi/libsrp.h |   79 +++++++++
+ 4 files changed, 530 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 566626c..e5098d3 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -1846,6 +1846,15 @@ config ZFCP
+           called zfcp. If you want to compile it as a module, say M here
+           and read <file:Documentation/modules.txt>.
+ 
++config SCSI_SRP
++	tristate "SCSI RDMA Protocol helper library"
++	depends on SCSI
++	help
++	  If you wish to use SRP target drivers, say Y.
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called libsrp.
++
+ endmenu
+ 
+ source "drivers/scsi/pcmcia/Kconfig"
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index ede0c45..d71bb59 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
+ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
+ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
++obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
+new file mode 100644
+index 0000000..86b7718
+--- /dev/null
++++ b/drivers/scsi/libsrp.c
+@@ -0,0 +1,441 @@
++/*
++ * SCSI RDAM Protocol lib functions
++ *
++ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include <linux/err.h>
++#include <linux/kfifo.h>
++#include <linux/scatterlist.h>
++#include <linux/dma-mapping.h>
++#include <linux/pci.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_tcq.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/srp.h>
++#include <scsi/libsrp.h>
++
++enum srp_task_attributes {
++	SRP_SIMPLE_TASK = 0,
++	SRP_HEAD_TASK = 1,
++	SRP_ORDERED_TASK = 2,
++	SRP_ACA_TASK = 4
++};
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
++			     struct srp_buf **ring)
++{
++	int i;
++	struct iu_entry *iue;
++
++	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
++	if (!q->pool)
++		return -ENOMEM;
++	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
++	if (!q->items)
++		goto free_pool;
++
++	spin_lock_init(&q->lock);
++	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
++			      GFP_KERNEL, &q->lock);
++	if (IS_ERR(q->queue))
++		goto free_item;
++
++	for (i = 0, iue = q->items; i < max; i++) {
++		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
++		iue->sbuf = ring[i];
++		iue++;
++	}
++	return 0;
++
++free_item:
++	kfree(q->items);
++free_pool:
++	kfree(q->pool);
++	return -ENOMEM;
++}
++
++static void srp_iu_pool_free(struct srp_queue *q)
++{
++	kfree(q->items);
++	kfree(q->pool);
++}
++
++static struct srp_buf **srp_ring_alloc(struct device *dev,
++				       size_t max, size_t size)
++{
++	int i;
++	struct srp_buf **ring;
++
++	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
++	if (!ring)
++		return NULL;
++
++	for (i = 0; i < max; i++) {
++		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
++		if (!ring[i])
++			goto out;
++		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
++						  GFP_KERNEL);
++		if (!ring[i]->buf)
++			goto out;
++	}
++	return ring;
++
++out:
++	for (i = 0; i < max && ring[i]; i++) {
++		if (ring[i]->buf)
++			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
++		kfree(ring[i]);
++	}
++	kfree(ring);
++
++	return NULL;
++}
++
++static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
++			  size_t size)
++{
++	int i;
++
++	for (i = 0; i < max; i++) {
++		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
++		kfree(ring[i]);
++	}
++}
++
++int srp_target_alloc(struct srp_target *target, struct device *dev,
++		     size_t nr, size_t iu_size)
++{
++	int err;
++
++	spin_lock_init(&target->lock);
++	INIT_LIST_HEAD(&target->cmd_queue);
++
++	target->dev = dev;
++	target->dev->driver_data = target;
++
++	target->srp_iu_size = iu_size;
++	target->rx_ring_size = nr;
++	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
++	if (!target->rx_ring)
++		return -ENOMEM;
++	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
++	if (err)
++		goto free_ring;
++
++	return 0;
++
++free_ring:
++	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
++	return -ENOMEM;
++}
++EXPORT_SYMBOL_GPL(srp_target_alloc);
++
++void srp_target_free(struct srp_target *target)
++{
++	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
++		      target->srp_iu_size);
++	srp_iu_pool_free(&target->iu_queue);
++}
++EXPORT_SYMBOL_GPL(srp_target_free);
++
++struct iu_entry *srp_iu_get(struct srp_target *target)
++{
++	struct iu_entry *iue = NULL;
++
++	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
++	BUG_ON(!iue);
++
++	iue->target = target;
++	INIT_LIST_HEAD(&iue->ilist);
++	iue->flags = 0;
++	return iue;
++}
++EXPORT_SYMBOL_GPL(srp_iu_get);
++
++void srp_iu_put(struct iu_entry *iue)
++{
++	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
++}
++EXPORT_SYMBOL_GPL(srp_iu_put);
++
++static int srp_direct_data(struct scsi_cmnd *sc, struct srp_direct_buf *md,
++			   enum dma_data_direction dir, srp_rdma_t rdma_io,
++			   int dma_map, int ext_desc)
++{
++	struct iu_entry *iue = NULL;
++	struct scatterlist *sg = NULL;
++	int err, nsg = 0, len;
++
++	if (dma_map) {
++		iue = (struct iu_entry *) sc->SCp.ptr;
++		sg = sc->request_buffer;
++
++		dprintk("%p %u %u %d\n", iue, sc->request_bufflen,
++			md->len, sc->use_sg);
++
++		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg,
++				 DMA_BIDIRECTIONAL);
++		if (!nsg) {
++			printk("fail to map %p %d\n", iue, sc->use_sg);
++			return 0;
++		}
++		len = min(sc->request_bufflen, md->len);
++	} else
++		len = md->len;
++
++	err = rdma_io(sc, sg, nsg, md, 1, dir, len);
++
++	if (dma_map)
++		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++	return err;
++}
++
++static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
++			     struct srp_indirect_buf *id,
++			     enum dma_data_direction dir, srp_rdma_t rdma_io,
++			     int dma_map, int ext_desc)
++{
++	struct iu_entry *iue = NULL;
++	struct srp_direct_buf *md = NULL;
++	struct scatterlist dummy, *sg = NULL;
++	dma_addr_t token = 0;
++	long err;
++	unsigned int done = 0;
++	int nmd, nsg = 0, len;
++
++	if (dma_map || ext_desc) {
++		iue = (struct iu_entry *) sc->SCp.ptr;
++		sg = sc->request_buffer;
++
++		dprintk("%p %u %u %d %d\n",
++			iue, sc->request_bufflen, id->len,
++			cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
++	}
++
++	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
++
++	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
++	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
++		md = &id->desc_list[0];
++		goto rdma;
++	}
++
++	if (ext_desc && dma_map) {
++		md = dma_alloc_coherent(iue->target->dev, id->table_desc.len,
++				&token, GFP_KERNEL);
++		if (!md) {
++			eprintk("Can't get dma memory %u\n", id->table_desc.len);
++			return -ENOMEM;
++		}
++
++		sg_init_one(&dummy, md, id->table_desc.len);
++		sg_dma_address(&dummy) = token;
++		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
++			      id->table_desc.len);
++		if (err < 0) {
++			eprintk("Error copying indirect table %ld\n", err);
++			goto free_mem;
++		}
++	} else {
++		eprintk("This command uses external indirect buffer\n");
++		return -EINVAL;
++	}
++
++rdma:
++	if (dma_map) {
++		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
++		if (!nsg) {
++			eprintk("fail to map %p %d\n", iue, sc->use_sg);
++			goto free_mem;
++		}
++		len = min(sc->request_bufflen, id->len);
++	} else
++		len = id->len;
++
++	err = rdma_io(sc, sg, nsg, md, nmd, dir, len);
++
++	if (dma_map)
++		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
++
++free_mem:
++	if (token && dma_map)
++		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
++
++	return done;
++}
++
++static int data_out_desc_size(struct srp_cmd *cmd)
++{
++	int size = 0;
++	u8 fmt = cmd->buf_fmt >> 4;
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		size = sizeof(struct srp_direct_buf);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		size = sizeof(struct srp_indirect_buf) +
++			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
++		break;
++	default:
++		eprintk("client error. Invalid data_out_format %x\n", fmt);
++		break;
++	}
++	return size;
++}
++
++/*
++ * TODO: this can be called multiple times for a single command if it
++ * has very long data.
++ */
++int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
++		      srp_rdma_t rdma_io, int dma_map, int ext_desc)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	enum dma_data_direction dir;
++	int offset, err = 0;
++	u8 format;
++
++	offset = cmd->add_cdb_len * 4;
++
++	dir = srp_cmd_direction(cmd);
++	if (dir == DMA_FROM_DEVICE)
++		offset += data_out_desc_size(cmd);
++
++	if (dir == DMA_TO_DEVICE)
++		format = cmd->buf_fmt >> 4;
++	else
++		format = cmd->buf_fmt & ((1U << 4) - 1);
++
++	switch (format) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *)
++			(cmd->add_data + offset);
++		err = srp_direct_data(sc, md, dir, rdma_io, dma_map, ext_desc);
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *)
++			(cmd->add_data + offset);
++		err = srp_indirect_data(sc, cmd, id, dir, rdma_io, dma_map,
++					ext_desc);
++		break;
++	default:
++		eprintk("Unknown format %d %x\n", dir, format);
++		break;
++	}
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(srp_transfer_data);
++
++static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
++{
++	struct srp_direct_buf *md;
++	struct srp_indirect_buf *id;
++	int len = 0, offset = cmd->add_cdb_len * 4;
++	u8 fmt;
++
++	if (dir == DMA_TO_DEVICE)
++		fmt = cmd->buf_fmt >> 4;
++	else {
++		fmt = cmd->buf_fmt & ((1U << 4) - 1);
++		offset += data_out_desc_size(cmd);
++	}
++
++	switch (fmt) {
++	case SRP_NO_DATA_DESC:
++		break;
++	case SRP_DATA_DESC_DIRECT:
++		md = (struct srp_direct_buf *) (cmd->add_data + offset);
++		len = md->len;
++		break;
++	case SRP_DATA_DESC_INDIRECT:
++		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
++		len = id->len;
++		break;
++	default:
++		eprintk("invalid data format %x\n", fmt);
++		break;
++	}
++	return len;
++}
++
++int srp_cmd_queue(struct Scsi_Host *shost, struct srp_cmd *cmd, void *info,
++		  u64 addr)
++{
++	enum dma_data_direction dir;
++	struct scsi_cmnd *sc;
++	int tag, len, err;
++
++	switch (cmd->task_attr) {
++	case SRP_SIMPLE_TASK:
++		tag = MSG_SIMPLE_TAG;
++		break;
++	case SRP_ORDERED_TASK:
++		tag = MSG_ORDERED_TAG;
++		break;
++	case SRP_HEAD_TASK:
++		tag = MSG_HEAD_TAG;
++		break;
++	default:
++		eprintk("Task attribute %d not supported\n", cmd->task_attr);
++		tag = MSG_ORDERED_TAG;
++	}
++
++	dir = srp_cmd_direction(cmd);
++	len = vscsis_data_length(cmd, dir);
++
++	dprintk("%p %x %lx %d %d %d %llx\n", info, cmd->cdb[0],
++		cmd->lun, dir, len, tag, (unsigned long long) cmd->tag);
++
++	sc = scsi_host_get_command(shost, dir, GFP_KERNEL);
++	if (!sc)
++		return -ENOMEM;
++
++	sc->SCp.ptr = info;
++	memcpy(sc->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
++	sc->request_bufflen = len;
++	sc->request_buffer = (void *) (unsigned long) addr;
++	sc->tag = tag;
++	err = scsi_tgt_queue_command(sc, (struct scsi_lun *) &cmd->lun, cmd->tag);
++	if (err)
++		scsi_host_put_command(shost, sc);
++
++	return err;
++}
++EXPORT_SYMBOL_GPL(srp_cmd_queue);
++
++MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
++MODULE_AUTHOR("FUJITA Tomonori");
++MODULE_LICENSE("GPL");
+diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
+new file mode 100644
+index 0000000..8ec13b9
+--- /dev/null
++++ b/include/scsi/libsrp.h
+@@ -0,0 +1,79 @@
++#ifndef __LIBSRP_H__
++#define __LIBSRP_H__
++
++#include <linux/list.h>
++#include <scsi/scsi_cmnd.h>
++#include <scsi/scsi_host.h>
++#include <scsi/srp.h>
++
++enum iue_flags {
++	V_DIOVER,
++	V_WRITE,
++	V_LINKED,
++	V_FLYING,
++};
++
++struct srp_buf {
++	dma_addr_t dma;
++	void *buf;
++};
++
++struct srp_queue {
++	void *pool;
++	void *items;
++	struct kfifo *queue;
++	spinlock_t lock;
++};
++
++struct srp_target {
++	struct Scsi_Host *shost;
++	struct device *dev;
++
++	spinlock_t lock;
++	struct list_head cmd_queue;
++
++	size_t srp_iu_size;
++	struct srp_queue iu_queue;
++	size_t rx_ring_size;
++	struct srp_buf **rx_ring;
++
++	/* IB needs tx_ring too */
++
++	void *ldata;
++};
++
++struct iu_entry {
++	struct srp_target *target;
++
++	struct list_head ilist;
++	dma_addr_t remote_token;
++	unsigned long flags;
++
++	struct srp_buf *sbuf;
++};
++
++typedef int (srp_rdma_t)(struct scsi_cmnd *, struct scatterlist *, int,
++			 struct srp_direct_buf *, int,
++			 enum dma_data_direction, unsigned int);
++extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
++extern void srp_target_free(struct srp_target *);
++
++extern struct iu_entry *srp_iu_get(struct srp_target *);
++extern void srp_iu_put(struct iu_entry *);
++
++extern int srp_cmd_queue(struct Scsi_Host *, struct srp_cmd *, void *, u64);
++extern int srp_transfer_data(struct scsi_cmnd *, struct srp_cmd *,
++			     srp_rdma_t, int, int);
++
++
++static inline struct srp_target *host_to_srp_target(struct Scsi_Host *host)
++{
++	return (struct srp_target *) host->hostdata;
++}
++
++static inline int srp_cmd_direction(struct srp_cmd *cmd)
++{
++	return (cmd->buf_fmt >> 4) ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
++}
++
++#endif
+-- 
+1.4.1
+

Deleted: trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0008-scsi-tgt-SRP-library-functions.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,595 +0,0 @@
-From dca0bd3d8d7bc4493a11c3897e69d0187513c5b4 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:50:32 +0900
-Subject: [PATCH 8/9] scsi tgt: SRP library functions
-
-libsrp provides helper functions for SRP target drivers.
-
-The next step would be to add initiator support to merge the two SRP
-initiator drivers (ibmvscsi and ib_srp) in mainline.
-
-Some SRP target drivers would be out of drivers/scsi/ so I added an
-entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
-it.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    9 +
- drivers/scsi/Makefile |    1 
- drivers/scsi/libsrp.c |  449 +++++++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/libsrp.h |   75 ++++++++
- 4 files changed, 534 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 566626c..e5098d3 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -1846,6 +1846,15 @@ config ZFCP
-           called zfcp. If you want to compile it as a module, say M here
-           and read <file:Documentation/modules.txt>.
- 
-+config SCSI_SRP
-+	tristate "SCSI RDMA Protocol helper library"
-+	depends on SCSI
-+	help
-+	  If you wish to use SRP target drivers, say Y.
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called libsrp.
-+
- endmenu
- 
- source "drivers/scsi/pcmcia/Kconfig"
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ede0c45..d71bb59 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
- obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
-+obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
-diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
-new file mode 100644
-index 0000000..b8a7c3d
---- /dev/null
-+++ b/drivers/scsi/libsrp.c
-@@ -0,0 +1,449 @@
-+/*
-+ * SCSI RDAM Protocol lib functions
-+ *
-+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/err.h>
-+#include <linux/kfifo.h>
-+#include <linux/scatterlist.h>
-+#include <linux/dma-mapping.h>
-+#include <linux/pci.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_tcq.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/srp.h>
-+#include <scsi/libsrp.h>
-+
-+enum srp_task_attributes {
-+	SRP_SIMPLE_TASK = 0,
-+	SRP_HEAD_TASK = 1,
-+	SRP_ORDERED_TASK = 2,
-+	SRP_ACA_TASK = 4
-+};
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
-+			     struct srp_buf **ring)
-+{
-+	int i;
-+	struct iu_entry *iue;
-+
-+	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
-+	if (!q->pool)
-+		return -ENOMEM;
-+	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
-+	if (!q->items)
-+		goto free_pool;
-+
-+	spin_lock_init(&q->lock);
-+	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
-+			      GFP_KERNEL, &q->lock);
-+	if (IS_ERR(q->queue))
-+		goto free_item;
-+
-+	for (i = 0, iue = q->items; i < max; i++) {
-+		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
-+		iue->sbuf = ring[i];
-+		iue++;
-+	}
-+	return 0;
-+
-+free_item:
-+	kfree(q->items);
-+free_pool:
-+	kfree(q->pool);
-+	return -ENOMEM;
-+}
-+
-+static void srp_iu_pool_free(struct srp_queue *q)
-+{
-+	kfree(q->items);
-+	kfree(q->pool);
-+}
-+
-+static struct srp_buf ** srp_ring_alloc(struct device *dev,
-+					size_t max, size_t size)
-+{
-+	int i;
-+	struct srp_buf **ring;
-+
-+	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
-+	if (!ring)
-+		return NULL;
-+
-+	for (i = 0; i < max; i++) {
-+		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
-+		if (!ring[i])
-+			goto out;
-+		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
-+						  GFP_KERNEL);
-+		if (!ring[i]->buf)
-+			goto out;
-+	}
-+	return ring;
-+
-+out:
-+	for (i = 0; i < max && ring[i]; i++) {
-+		if (ring[i]->buf)
-+			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+	kfree(ring);
-+
-+	return NULL;
-+}
-+
-+static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
-+			  size_t size)
-+{
-+	int i;
-+
-+	for (i = 0; i < max; i++) {
-+		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+}
-+
-+int srp_target_alloc(struct srp_target *target, struct device *dev,
-+		     size_t nr, size_t iu_size)
-+{
-+	int err;
-+
-+	spin_lock_init(&target->lock);
-+	INIT_LIST_HEAD(&target->cmd_queue);
-+
-+	target->dev = dev;
-+	target->dev->driver_data = target;
-+
-+	target->srp_iu_size = iu_size;
-+	target->rx_ring_size = nr;
-+	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
-+	if (!target->rx_ring)
-+		return -ENOMEM;
-+	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
-+	if (err)
-+		goto free_ring;
-+
-+	return 0;
-+
-+free_ring:
-+	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
-+	return -ENOMEM;
-+}
-+EXPORT_SYMBOL_GPL(srp_target_alloc);
-+
-+void srp_target_free(struct srp_target *target)
-+{
-+	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
-+		      target->srp_iu_size);
-+	srp_iu_pool_free(&target->iu_queue);
-+}
-+EXPORT_SYMBOL_GPL(srp_target_free);
-+
-+struct iu_entry *srp_iu_get(struct srp_target *target)
-+{
-+	struct iu_entry *iue = NULL;
-+
-+	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+	BUG_ON(!iue);
-+
-+	iue->target = target;
-+	iue->scmd = NULL;
-+	INIT_LIST_HEAD(&iue->ilist);
-+	iue->flags = 0;
-+	return iue;
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_get);
-+
-+void srp_iu_put(struct iu_entry *iue)
-+{
-+	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_put);
-+
-+static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
-+		       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct scatterlist *sg = scmd->request_buffer;
-+	int nsg, err;
-+
-+	dprintk("%p %u %u %u %d\n", iue, scmd->request_bufflen, scmd->bufflen,
-+		md->len, scmd->use_sg);
-+
-+	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		printk("fail to map %p %d\n", iue, scmd->use_sg);
-+		return 0;
-+	}
-+	err = rdma_io(iue, sg, nsg, md, 1, dir,
-+		      min(scmd->request_bufflen, md->len));
-+
-+	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+	return err;
-+}
-+
-+static int indirect_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			 struct srp_indirect_buf *id,
-+			 enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct srp_direct_buf *md;
-+	struct scatterlist dummy, *sg = scmd->request_buffer;
-+	dma_addr_t token = 0;
-+	long err;
-+	unsigned int done = 0;
-+	int nmd, nsg;
-+
-+	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
-+
-+	dprintk("%p %u %u %u %u %d %d %d\n",
-+		iue, scmd->request_bufflen, scmd->bufflen,
-+		id->len, scmd->offset, nmd,
-+		cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
-+
-+	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
-+	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
-+		md = &id->desc_list[0];
-+		goto rdma;
-+	}
-+
-+	md = dma_alloc_coherent(target->dev, id->table_desc.len,
-+				 &token, GFP_KERNEL);
-+	if (!md) {
-+		eprintk("Can't get dma memory %u\n", id->table_desc.len);
-+		return 0;
-+	}
-+
-+	sg_init_one(&dummy, md, id->table_desc.len);
-+	sg_dma_address(&dummy) = token;
-+	err = rdma_io(iue, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
-+		      id->table_desc.len);
-+	if (err < 0) {
-+		eprintk("Error copying indirect table %ld\n", err);
-+		goto free_mem;
-+	}
-+
-+rdma:
-+	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		eprintk("fail to map %p %d\n", iue, scmd->use_sg);
-+		goto free_mem;
-+	}
-+
-+	err = rdma_io(iue, sg, nsg, md, nmd, dir,
-+		      min(scmd->request_bufflen, id->len));
-+	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+free_mem:
-+	if (token)
-+		dma_free_coherent(target->dev, id->table_desc.len, md, token);
-+
-+	return done;
-+}
-+
-+static int data_out_desc_size(struct srp_cmd *cmd)
-+{
-+	int size = 0;
-+	u8 fmt = cmd->buf_fmt >> 4;
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		size = sizeof(struct srp_direct_buf);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		size = sizeof(struct srp_indirect_buf) +
-+			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
-+		break;
-+	default:
-+		eprintk("client error. Invalid data_out_format %x\n", fmt);
-+		break;
-+	}
-+	return size;
-+}
-+
-+static int __srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int offset, err = 0;
-+	u8 format;
-+
-+	offset = cmd->add_cdb_len * 4;
-+	if (dir == DMA_FROM_DEVICE)
-+		offset += data_out_desc_size(cmd);
-+
-+	if (dir == DMA_TO_DEVICE)
-+		format = cmd->buf_fmt >> 4;
-+	else
-+		format = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	switch (format) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *)
-+			(cmd->add_data + offset);
-+		err = direct_data(scmd, md, dir, rdma_io);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *)
-+			(cmd->add_data + offset);
-+		err = indirect_data(scmd, cmd, id, dir, rdma_io);
-+		break;
-+	default:
-+		eprintk("Unknown format %d %x\n", dir, format);
-+		break;
-+	}
-+
-+	return err;
-+}
-+
-+/* TODO: this can be called multiple times for a single command. */
-+int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+		      rdma_io_t rdma_io)
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
-+	enum dma_data_direction dir;
-+
-+	if (test_bit(V_WRITE, &iue->flags))
-+		dir = DMA_TO_DEVICE;
-+	else
-+		dir = DMA_FROM_DEVICE;
-+	__srp_transfer_data(scmd, cmd, dir, rdma_io);
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_transfer_data);
-+
-+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int len = 0, offset = cmd->add_cdb_len * 4;
-+	u8 fmt;
-+
-+	if (dir == DMA_TO_DEVICE)
-+		fmt = cmd->buf_fmt >> 4;
-+	else {
-+		fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+		offset += data_out_desc_size(cmd);
-+	}
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *) (cmd->add_data + offset);
-+		len = md->len;
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
-+		len = id->len;
-+		break;
-+	default:
-+		eprintk("invalid data format %x\n", fmt);
-+		break;
-+	}
-+	return len;
-+}
-+
-+static uint8_t getcontrolbyte(u8 *cdb)
-+{
-+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
-+}
-+
-+static inline uint8_t getlink(struct srp_cmd *cmd)
-+{
-+	return (getcontrolbyte(cmd->cdb) & 0x01);
-+}
-+
-+int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
-+{
-+	struct Scsi_Host *shost = iue->target->shost;
-+	enum dma_data_direction data_dir;
-+	struct scsi_cmnd *scmd;
-+	int tag, len;
-+
-+	if (getlink(cmd))
-+		__set_bit(V_LINKED, &iue->flags);
-+
-+	tag = MSG_SIMPLE_TAG;
-+
-+	switch (cmd->task_attr) {
-+	case SRP_SIMPLE_TASK:
-+		tag = MSG_SIMPLE_TAG;
-+		break;
-+	case SRP_ORDERED_TASK:
-+		tag = MSG_ORDERED_TAG;
-+		break;
-+	case SRP_HEAD_TASK:
-+		tag = MSG_HEAD_TAG;
-+		break;
-+	default:
-+		eprintk("Task attribute %d not supported\n", cmd->task_attr);
-+		tag = MSG_ORDERED_TAG;
-+	}
-+
-+	switch (cmd->cdb[0]) {
-+	case WRITE_6:
-+	case WRITE_10:
-+	case WRITE_VERIFY:
-+	case WRITE_12:
-+	case WRITE_VERIFY_12:
-+		__set_bit(V_WRITE, &iue->flags);
-+	}
-+
-+	if (cmd->buf_fmt >> 4)
-+		data_dir = DMA_TO_DEVICE;
-+	else
-+		data_dir = DMA_FROM_DEVICE;
-+	len = vscsis_data_length(cmd, data_dir);
-+
-+	dprintk("%p %x %lx %d %d %d %llx\n", iue, cmd->cdb[0],
-+		cmd->lun, data_dir, len, tag, (unsigned long long) cmd->tag);
-+
-+	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
-+	BUG_ON(!scmd);
-+	scmd->SCp.ptr = (char *) iue;
-+	memcpy(scmd->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
-+	scmd->request_bufflen = len;
-+	scmd->tag = tag;
-+	iue->scmd = scmd;
-+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &cmd->lun, cmd->tag);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_cmd_perform);
-+
-+MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
-+MODULE_AUTHOR("FUJITA Tomonori");
-+MODULE_LICENSE("GPL");
-diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
-new file mode 100644
-index 0000000..9dd10ff
---- /dev/null
-+++ b/include/scsi/libsrp.h
-@@ -0,0 +1,75 @@
-+#ifndef __LIBSRP_H__
-+#define __LIBSRP_H__
-+
-+#include <linux/list.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/srp.h>
-+
-+enum iue_flags {
-+	V_DIOVER,
-+	V_WRITE,
-+	V_LINKED,
-+	V_FLYING,
-+};
-+
-+struct srp_buf {
-+	dma_addr_t dma;
-+	void *buf;
-+};
-+
-+struct srp_queue {
-+	void *pool;
-+	void *items;
-+	struct kfifo *queue;
-+	spinlock_t lock;
-+};
-+
-+struct srp_target {
-+	struct Scsi_Host *shost;
-+	struct device *dev;
-+
-+	spinlock_t lock;
-+	struct list_head cmd_queue;
-+
-+	size_t srp_iu_size;
-+	struct srp_queue iu_queue;
-+	size_t rx_ring_size;
-+	struct srp_buf **rx_ring;
-+
-+	/* IB needs tx_ring too */
-+
-+	void *ldata;
-+};
-+
-+struct iu_entry {
-+	struct srp_target *target;
-+	struct scsi_cmnd *scmd;
-+
-+	struct list_head ilist;
-+	dma_addr_t remote_token;
-+	unsigned long flags;
-+
-+	struct srp_buf *sbuf;
-+};
-+
-+typedef int (rdma_io_t) (struct iu_entry *, struct scatterlist *, int,
-+			 struct srp_direct_buf *, int,
-+			 enum dma_data_direction, unsigned int);
-+
-+static inline struct srp_target *host_to_target(struct Scsi_Host *host)
-+{
-+	return (struct srp_target *) host->hostdata;
-+}
-+
-+extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
-+extern void srp_target_free(struct srp_target *);
-+
-+extern struct iu_entry *srp_iu_get(struct srp_target *);
-+extern void srp_iu_put(struct iu_entry *);
-+
-+extern int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd);
-+extern int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			     rdma_io_t rdma_io);
-+
-+#endif
--- 
-1.4.1.1
-

Deleted: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-Virtual-SCSI-Target-Driver.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -1,1023 +0,0 @@
-From 49997b6ea087c515fad787cb90637e03a44f396f Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Thu, 17 Aug 2006 08:51:51 +0900
-Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries Virtual SCSI Target Driver
-
-This is IBM Virtual SCSI target driver for tgt.
-
-This patch dependents on the previous patch to convert the ibmvscsi
-driver to use include/scsi/srp.h.
-
-The driver is based on the original ibmvscsis driver:
-
-http://lkml.org/lkml/2005/10/17/99
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig             |   14 +
- drivers/scsi/Makefile            |    1 
- drivers/scsi/ibmvscsi/Makefile   |    2 
- drivers/scsi/ibmvscsi/ibmvstgt.c |  943 ++++++++++++++++++++++++++++++++++++++
- 4 files changed, 960 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index e5098d3..c25154c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
- 	  To compile this driver as a module, choose M here: the
- 	  module will be called ibmvscsic.
- 
-+config SCSI_IBMVSCSIS
-+	tristate "IBM Virtual SCSI Server support"
-+	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
-+	help
-+	  This is the SRP target driver for IBM pSeries virtual environments.
-+
-+	  The userspace component needed to initialize the driver and
-+	  documentation can be found:
-+
-+	  http://stgt.berlios.de/
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called ibmvstgt.
-+
- config SCSI_INITIO
- 	tristate "Initio 9100U(W) support"
- 	depends on PCI && SCSI
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index d71bb59..78544e3 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
- obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
- obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
-diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
-index 4e247b6..6ac0633 100644
---- a/drivers/scsi/ibmvscsi/Makefile
-+++ b/drivers/scsi/ibmvscsi/Makefile
-@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
- ibmvscsic-y			+= ibmvscsi.o
- ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
- ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
-+
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
-diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
-new file mode 100644
-index 0000000..cf1e851
---- /dev/null
-+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
-@@ -0,0 +1,943 @@
-+/*
-+ * IBM eServer i/pSeries Virtual SCSI Target Driver
-+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
-+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
-+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
-+ *
-+ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-+ * USA
-+ */
-+#include <linux/interrupt.h>
-+#include <linux/module.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/libsrp.h>
-+#include <asm/hvcall.h>
-+#include <asm/iommu.h>
-+#include <asm/prom.h>
-+#include <asm/vio.h>
-+
-+#include "ibmvscsi.h"
-+
-+#define	INITIAL_SRP_LIMIT	16
-+#define	DEFAULT_MAX_SECTORS	512
-+
-+#define	TGT_NAME	"ibmvstgt"
-+
-+/*
-+ * Hypervisor calls.
-+ */
-+#define h_copy_rdma(l, sa, sb, da, db) \
-+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
-+#define h_send_crq(ua, l, h) \
-+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
-+#define h_reg_crq(ua, tok, sz)\
-+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
-+#define h_free_crq(ua) \
-+			plpar_hcall_norets(H_FREE_CRQ, ua);
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+struct vio_port {
-+	struct vio_dev *dma_dev;
-+
-+	struct crq_queue crq_queue;
-+	struct work_struct crq_work;
-+
-+	unsigned long liobn;
-+	unsigned long riobn;
-+};
-+
-+static struct workqueue_struct *vtgtd;
-+
-+/*
-+ * These are fixed for the system and come from the Open Firmware device tree.
-+ * We just store them here to save getting them every time.
-+ */
-+static char system_id[64] = "";
-+static char partition_name[97] = "UNKNOWN";
-+static unsigned int partition_number = -1;
-+
-+static struct vio_port *target_to_port(struct srp_target *target)
-+{
-+	return (struct vio_port *) target->ldata;
-+}
-+
-+static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
-+{
-+	return (union viosrp_iu *) (iue->sbuf->buf);
-+}
-+
-+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	long rc, rc1;
-+	union {
-+		struct viosrp_crq cooked;
-+		uint64_t raw[2];
-+	} crq;
-+
-+	/* First copy the SRP */
-+	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
-+			 vport->riobn, iue->remote_token);
-+
-+	if (rc)
-+		eprintk("Error %ld transferring data\n", rc);
-+
-+	crq.cooked.valid = 0x80;
-+	crq.cooked.format = format;
-+	crq.cooked.reserved = 0x00;
-+	crq.cooked.timeout = 0x00;
-+	crq.cooked.IU_length = length;
-+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
-+
-+	if (rc == 0)
-+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
-+	else
-+		crq.cooked.status = 0x00;
-+
-+	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
-+
-+	if (rc1) {
-+		eprintk("%ld sending response\n", rc1);
-+		return rc1;
-+	}
-+
-+	return rc;
-+}
-+
-+#define SRP_RSP_SENSE_DATA_LEN	18
-+
-+static int send_rsp(struct iu_entry *iue, unsigned char status,
-+		    unsigned char asc)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* If the linked bit is on and status is good */
-+	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
-+		status = 0x10;
-+
-+	memset(iu, 0, sizeof(struct srp_rsp));
-+	iu->srp.rsp.opcode = SRP_RSP;
-+	iu->srp.rsp.req_lim_delta = 1;
-+	iu->srp.rsp.tag = tag;
-+
-+	if (test_bit(V_DIOVER, &iue->flags))
-+		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
-+
-+	iu->srp.rsp.data_in_res_cnt = 0;
-+	iu->srp.rsp.data_out_res_cnt = 0;
-+
-+	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
-+
-+	iu->srp.rsp.resp_data_len = 0;
-+	iu->srp.rsp.status = status;
-+	if (status) {
-+		uint8_t *sense = iu->srp.rsp.data;
-+
-+		if (iue->scmd) {
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
-+			memcpy(sense, iue->scmd->sense_buffer,
-+			       SCSI_SENSE_BUFFERSIZE);
-+		} else {
-+			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
-+
-+			/* Valid bit and 'current errors' */
-+			sense[0] = (0x1 << 7 | 0x70);
-+			/* Sense key */
-+			sense[2] = status;
-+			/* Additional sense length */
-+			sense[7] = 0xa;	/* 10 bytes */
-+			/* Additional sense code */
-+			sense[12] = asc;
-+		}
-+	}
-+
-+	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
-+		VIOSRP_SRP_FORMAT);
-+
-+	return 0;
-+}
-+
-+static void handle_cmd_queue(struct srp_target *target)
-+{
-+	struct iu_entry *iue;
-+	unsigned long flags;
-+
-+retry:
-+	spin_lock_irqsave(&target->lock, flags);
-+
-+	list_for_each_entry(iue, &target->cmd_queue, ilist) {
-+		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
-+			spin_unlock_irqrestore(&target->lock, flags);
-+			srp_cmd_perform(iue, (struct srp_cmd *) iue->sbuf->buf);
-+			goto retry;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int ibmvstgt_rdma(struct iu_entry *iue, struct scatterlist *sg, int nsg,
-+			 struct srp_direct_buf *md, int nmd,
-+			 enum dma_data_direction dir, unsigned int rest)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	dma_addr_t token;
-+	long err;
-+	unsigned int done = 0;
-+	int i, sidx, soff;
-+
-+	sidx = soff = 0;
-+	token = sg_dma_address(sg + sidx);
-+
-+	for (i = 0; i < nmd && rest; i++) {
-+		unsigned int mdone, mlen;
-+
-+		mlen = min(rest, md[i].len);
-+		for (mdone = 0; mlen;) {
-+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
-+
-+			if (dir == DMA_TO_DEVICE)
-+				err = h_copy_rdma(slen,
-+						  vport->riobn,
-+						  md[i].va + mdone,
-+						  vport->liobn,
-+						  token + soff);
-+			else
-+				err = h_copy_rdma(slen,
-+						  vport->liobn,
-+						  token + soff,
-+						  vport->riobn,
-+						  md[i].va + mdone);
-+
-+			if (err != H_SUCCESS) {
-+				eprintk("rdma error %d %d\n", dir, slen);
-+				goto out;
-+			}
-+
-+			mlen -= slen;
-+			mdone += slen;
-+			soff += slen;
-+			done += slen;
-+
-+			if (soff == sg_dma_len(sg + sidx)) {
-+				sidx++;
-+				soff = 0;
-+				token = sg_dma_address(sg + sidx);
-+
-+				if (sidx > nsg) {
-+					eprintk("out of sg %p %d %d\n",
-+						iue, sidx, nsg);
-+					goto out;
-+				}
-+			}
-+		};
-+
-+		rest -= mlen;
-+	}
-+out:
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_transfer_data(struct scsi_cmnd *scmd,
-+				  void (*done)(struct scsi_cmnd *))
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
-+	int err;
-+
-+	err = srp_transfer_data(scmd, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma);
-+	done(scmd);
-+
-+	return err;
-+}
-+
-+static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
-+			     void (*done)(struct scsi_cmnd *))
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	if (scmd->result != SAM_STAT_GOOD) {
-+		eprintk("operation failed %p %d %x\n",
-+			iue, scmd->result, vio_iu(iue)->srp.cmd.cdb[0]);
-+		send_rsp(iue, HARDWARE_ERROR, 0x00);
-+	} else
-+		send_rsp(iue, NO_SENSE, 0x00);
-+
-+	done(scmd);
-+	srp_iu_put(iue);
-+	return 0;
-+}
-+
-+int send_adapter_info(struct iu_entry *iue,
-+		      dma_addr_t remote_buffer, uint16_t length)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	struct Scsi_Host *shost = target->shost;
-+	dma_addr_t data_token;
-+	struct mad_adapter_info_data *info;
-+	int err;
-+
-+	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
-+				  GFP_KERNEL);
-+	if (!info) {
-+		eprintk("bad dma_alloc_coherent %p\n", target);
-+		return 1;
-+	}
-+
-+	/* Get remote info */
-+	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
-+			  vport->liobn, data_token);
-+	if (err == H_SUCCESS) {
-+		dprintk("Client connect: %s (%d)\n",
-+			info->partition_name, info->partition_number);
-+	}
-+
-+	memset(info, 0, sizeof(*info));
-+
-+	strcpy(info->srp_version, "16.a");
-+	strncpy(info->partition_name, partition_name,
-+		sizeof(info->partition_name));
-+	info->partition_number = partition_number;
-+	info->mad_version = 1;
-+	info->os_type = 2;
-+	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
-+
-+	/* Send our info to remote */
-+	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
-+			  vport->riobn, remote_buffer);
-+
-+	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
-+
-+	if (err != H_SUCCESS) {
-+		eprintk("Error sending adapter info %d\n", err);
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static void process_login(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* TODO handle case that requested size is wrong and
-+	 * buffer format is wrong
-+	 */
-+	memset(iu, 0, sizeof(struct srp_login_rsp));
-+	rsp->opcode = SRP_LOGIN_RSP;
-+	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
-+	rsp->tag = tag;
-+	rsp->max_it_iu_len = sizeof(union srp_iu);
-+	rsp->max_ti_iu_len = sizeof(union srp_iu);
-+	/* direct and indirect */
-+	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
-+
-+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
-+}
-+
-+static inline void queue_cmd(struct iu_entry *iue)
-+{
-+	struct srp_target *target = iue->target;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_add_tail(&iue->ilist, &target->cmd_queue);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int process_tsk_mgmt(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int fn;
-+
-+	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		fn = ABORT_TASK;
-+		break;
-+	case SRP_TSK_ABORT_TASK_SET:
-+		fn = ABORT_TASK_SET;
-+		break;
-+	case SRP_TSK_CLEAR_TASK_SET:
-+		fn = CLEAR_TASK_SET;
-+		break;
-+	case SRP_TSK_LUN_RESET:
-+		fn = LOGICAL_UNIT_RESET;
-+		break;
-+	case SRP_TSK_CLEAR_ACA:
-+		fn = CLEAR_ACA;
-+		break;
-+	default:
-+		fn = 0;
-+	}
-+	if (fn)
-+		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
-+					  iu->srp.tsk_mgmt.task_tag,
-+					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
-+					  iue);
-+	else
-+		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
-+
-+	return !fn;
-+}
-+
-+static int process_mad_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct viosrp_adapter_info *info;
-+	struct viosrp_host_config *conf;
-+
-+	switch (iu->mad.empty_iu.common.type) {
-+	case VIOSRP_EMPTY_IU_TYPE:
-+		eprintk("%s\n", "Unsupported EMPTY MAD IU");
-+		break;
-+	case VIOSRP_ERROR_LOG_TYPE:
-+		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
-+		iu->mad.error_log.common.status = 1;
-+		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_ADAPTER_INFO_TYPE:
-+		info = &iu->mad.adapter_info;
-+		info->common.status = send_adapter_info(iue, info->buffer,
-+							info->common.length);
-+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_HOST_CONFIG_TYPE:
-+		conf = &iu->mad.host_config;
-+		conf->common.status = 1;
-+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
-+	}
-+
-+	return 1;
-+}
-+
-+static int process_srp_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int done = 1;
-+	u8 opcode = iu->srp.rsp.opcode;
-+
-+	switch (opcode) {
-+	case SRP_LOGIN_REQ:
-+		process_login(iue);
-+		break;
-+	case SRP_TSK_MGMT:
-+		done = process_tsk_mgmt(iue);
-+		break;
-+	case SRP_CMD:
-+		queue_cmd(iue);
-+		done = 0;
-+		break;
-+	case SRP_LOGIN_RSP:
-+	case SRP_I_LOGOUT:
-+	case SRP_T_LOGOUT:
-+	case SRP_RSP:
-+	case SRP_CRED_REQ:
-+	case SRP_CRED_RSP:
-+	case SRP_AER_REQ:
-+	case SRP_AER_RSP:
-+		eprintk("Unsupported type %u\n", opcode);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", opcode);
-+	}
-+
-+	return done;
-+}
-+
-+static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct iu_entry *iue;
-+	long err, done;
-+
-+	iue = srp_iu_get(target);
-+	if (!iue) {
-+		eprintk("Error getting IU from pool, %p\n", target);
-+		return;
-+	}
-+
-+	iue->remote_token = crq->IU_data_ptr;
-+
-+	err = h_copy_rdma(crq->IU_length, vport->riobn,
-+			  iue->remote_token, vport->liobn, iue->sbuf->dma);
-+
-+	if (err != H_SUCCESS)
-+		eprintk("%ld transferring data error %p\n", err, iue);
-+
-+	if (crq->format == VIOSRP_MAD_FORMAT)
-+		done = process_mad_iu(iue);
-+	else
-+		done = process_srp_iu(iue);
-+
-+	if (done)
-+		srp_iu_put(iue);
-+}
-+
-+static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	vio_disable_interrupts(vport->dma_dev);
-+	queue_work(vtgtd, &vport->crq_work);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
-+{
-+	int err;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
-+	if (!queue->msgs)
-+		goto malloc_failed;
-+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
-+
-+	queue->msg_token = dma_map_single(target->dev, queue->msgs,
-+					  queue->size * sizeof(*queue->msgs),
-+					  DMA_BIDIRECTIONAL);
-+
-+	if (dma_mapping_error(queue->msg_token))
-+		goto map_failed;
-+
-+	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			PAGE_SIZE);
-+
-+	/* If the adapter was left active for some reason (like kexec)
-+	 * try freeing and re-registering
-+	 */
-+	if (err == H_RESOURCE) {
-+	    do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			    PAGE_SIZE);
-+	}
-+
-+	if (err != H_SUCCESS && err != 2) {
-+		eprintk("Error 0x%x opening virtual adapter\n", err);
-+		goto reg_crq_failed;
-+	}
-+
-+	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
-+			  SA_INTERRUPT, "ibmvstgt", target);
-+	if (err)
-+		goto req_irq_failed;
-+
-+	vio_enable_interrupts(vport->dma_dev);
-+
-+	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
-+
-+	queue->cur = 0;
-+	spin_lock_init(&queue->lock);
-+
-+	return 0;
-+
-+req_irq_failed:
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+reg_crq_failed:
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+map_failed:
-+	free_page((unsigned long) queue->msgs);
-+
-+malloc_failed:
-+	return -ENOMEM;
-+}
-+
-+static void crq_queue_destroy(struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct crq_queue *queue = &vport->crq_queue;
-+	int err;
-+
-+	free_irq(vport->dma_dev->irq, target);
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+
-+	free_page((unsigned long) queue->msgs);
-+}
-+
-+static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	dprintk("%x %x\n", crq->valid, crq->format);
-+
-+	switch (crq->valid) {
-+	case 0xC0:
-+		/* initialization */
-+		switch (crq->format) {
-+		case 0x01:
-+			h_send_crq(vport->dma_dev->unit_address,
-+				   0xC002000000000000, 0);
-+			break;
-+		case 0x02:
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	case 0xFF:
-+		/* transport event */
-+		break;
-+	case 0x80:
-+		/* real payload */
-+		switch (crq->format) {
-+		case VIOSRP_SRP_FORMAT:
-+		case VIOSRP_MAD_FORMAT:
-+			process_iu(crq, target);
-+			break;
-+		case VIOSRP_OS400_FORMAT:
-+		case VIOSRP_AIX_FORMAT:
-+		case VIOSRP_LINUX_FORMAT:
-+		case VIOSRP_INLINE_FORMAT:
-+			eprintk("Unsupported format %u\n", crq->format);
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	default:
-+		eprintk("unknown message type 0x%02x!?\n", crq->valid);
-+	}
-+}
-+
-+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
-+{
-+	struct viosrp_crq *crq;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&queue->lock, flags);
-+	crq = &queue->msgs[queue->cur];
-+	if (crq->valid & 0x80) {
-+		if (++queue->cur == queue->size)
-+			queue->cur = 0;
-+	} else
-+		crq = NULL;
-+	spin_unlock_irqrestore(&queue->lock, flags);
-+
-+	return crq;
-+}
-+
-+static void handle_crq(void *data)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+	struct viosrp_crq *crq;
-+	int done = 0;
-+
-+	while (!done) {
-+		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		}
-+
-+		vio_enable_interrupts(vport->dma_dev);
-+
-+		crq = next_crq(&vport->crq_queue);
-+		if (crq) {
-+			vio_disable_interrupts(vport->dma_dev);
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		} else
-+			done = 1;
-+	}
-+
-+	handle_cmd_queue(target);
-+}
-+
-+
-+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
-+	union viosrp_iu *iu = vio_iu(iue);
-+	unsigned char status, asc;
-+
-+	eprintk("%p %d\n", iue, result);
-+	status = NO_SENSE;
-+	asc = 0;
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		asc = 0x14;
-+		if (result)
-+			status = ABORTED_COMMAND;
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	send_rsp(iue, status, asc);
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static ssize_t system_id_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
-+}
-+
-+static ssize_t partition_number_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
-+}
-+
-+static ssize_t unit_address_show(struct class_device *cdev, char *buf)
-+{
-+	struct Scsi_Host *shost = class_to_shost(cdev);
-+	struct srp_target *target = host_to_target(shost);
-+	struct vio_port *vport = target_to_port(target);
-+	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
-+}
-+
-+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
-+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
-+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
-+
-+static struct class_device_attribute *ibmvstgt_attrs[] = {
-+	&class_device_attr_system_id,
-+	&class_device_attr_partition_number,
-+	&class_device_attr_unit_address,
-+	NULL,
-+};
-+
-+static struct scsi_host_template ibmvstgt_sht = {
-+	.name			= TGT_NAME,
-+	.module			= THIS_MODULE,
-+	.can_queue		= INITIAL_SRP_LIMIT,
-+	.sg_tablesize		= SG_ALL,
-+	.use_clustering		= DISABLE_CLUSTERING,
-+	.max_sectors		= DEFAULT_MAX_SECTORS,
-+	.transfer_response	= ibmvstgt_cmd_done,
-+	.transfer_data		= ibmvstgt_transfer_data,
-+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
-+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
-+	.shost_attrs		= ibmvstgt_attrs,
-+	.proc_name		= TGT_NAME,
-+};
-+
-+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
-+{
-+	struct Scsi_Host *shost;
-+	struct srp_target *target;
-+	struct vio_port *vport;
-+	unsigned int *dma, dma_size;
-+	int err = -ENOMEM;
-+
-+	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
-+	if (!vport)
-+		return err;
-+	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
-+	if (!shost)
-+		goto free_vport;
-+	err = scsi_tgt_alloc_queue(shost);
-+	if (err)
-+		goto put_host;
-+
-+	target = host_to_target(shost);
-+	target->shost = shost;
-+	vport->dma_dev = dev;
-+	target->ldata = vport;
-+	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
-+			       SRP_MAX_IU_LEN);
-+	if (err)
-+		goto put_host;
-+
-+	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
-+						 &dma_size);
-+	if (!dma || dma_size != 40) {
-+		eprintk("Couldn't get window property %d\n", dma_size);
-+		err = -EIO;
-+		goto free_srp_target;
-+	}
-+	vport->liobn = dma[0];
-+	vport->riobn = dma[5];
-+
-+	INIT_WORK(&vport->crq_work, handle_crq, target);
-+
-+	err = crq_queue_create(&vport->crq_queue, target);
-+	if (err)
-+		goto free_srp_target;
-+
-+	err = scsi_add_host(shost, target->dev);
-+	if (err)
-+		goto destroy_queue;
-+	return 0;
-+
-+destroy_queue:
-+	crq_queue_destroy(target);
-+free_srp_target:
-+	srp_target_free(target);
-+put_host:
-+	scsi_host_put(shost);
-+free_vport:
-+	kfree(vport);
-+	return err;
-+}
-+
-+static int ibmvstgt_remove(struct vio_dev *dev)
-+{
-+	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
-+	struct Scsi_Host *shost = target->shost;
-+
-+	srp_target_free(target);
-+	crq_queue_destroy(target);
-+	scsi_remove_host(shost);
-+	scsi_host_put(shost);
-+	return 0;
-+}
-+
-+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
-+	{"v-scsi-host", "IBM,v-scsi-host"},
-+	{"",""}
-+};
-+
-+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
-+
-+static struct vio_driver ibmvstgt_driver = {
-+	.id_table = ibmvstgt_device_table,
-+	.probe = ibmvstgt_probe,
-+	.remove = ibmvstgt_remove,
-+	.driver = {
-+		.name = "ibmvscsi",
-+		.owner = THIS_MODULE,
-+	}
-+};
-+
-+static int get_system_info(void)
-+{
-+	struct device_node *rootdn;
-+	char *id, *model, *name;
-+	unsigned int *num;
-+
-+	rootdn = find_path_device("/");
-+	if (!rootdn)
-+		return -ENOENT;
-+
-+	model = get_property(rootdn, "model", NULL);
-+	id = get_property(rootdn, "system-id", NULL);
-+	if (model && id)
-+		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
-+
-+	name = get_property(rootdn, "ibm,partition-name", NULL);
-+	if (name)
-+		strncpy(partition_name, name, sizeof(partition_name));
-+
-+	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
-+	if (num)
-+		partition_number = *num;
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_init(void)
-+{
-+	int err = -ENOMEM;
-+
-+	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
-+
-+	vtgtd = create_workqueue("ibmvtgtd");
-+	if (!vtgtd)
-+		return err;
-+
-+	err = get_system_info();
-+	if (err)
-+		goto destroy_wq;
-+
-+	err = vio_register_driver(&ibmvstgt_driver);
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(vtgtd);
-+	return err;
-+}
-+
-+static void ibmvstgt_exit(void)
-+{
-+	printk("Unregister IBM virtual SCSI driver\n");
-+
-+	destroy_workqueue(vtgtd);
-+	vio_unregister_driver(&ibmvstgt_driver);
-+}
-+
-+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
-+MODULE_AUTHOR("Dave Boutcher");
-+MODULE_LICENSE("GPL");
-+
-+module_init(ibmvstgt_init);
-+module_exit(ibmvstgt_exit);
--- 
-1.4.1.1
-

Added: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-16 23:59:15 UTC (rev 529)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-17 17:22:56 UTC (rev 530)
@@ -0,0 +1,1028 @@
+From 747144ea9774596a61b7ba39c0ae18b378b33d36 Mon Sep 17 00:00:00 2001
+From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Date: Fri, 18 Aug 2006 00:41:02 +0900
+Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries virtual SCSI target driver
+
+This is IBM Virtual SCSI target driver for tgt. The driver is based on
+the original ibmvscsis driver:
+
+http://lkml.org/lkml/2005/10/17/99
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
+---
+ drivers/scsi/Kconfig             |   14 +
+ drivers/scsi/Makefile            |    1 
+ drivers/scsi/ibmvscsi/Makefile   |    2 
+ drivers/scsi/ibmvscsi/ibmvstgt.c |  952 ++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 969 insertions(+), 0 deletions(-)
+
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index e5098d3..c25154c 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called ibmvscsic.
+ 
++config SCSI_IBMVSCSIS
++	tristate "IBM Virtual SCSI Server support"
++	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
++	help
++	  This is the SRP target driver for IBM pSeries virtual environments.
++
++	  The userspace component needed to initialize the driver and
++	  documentation can be found:
++
++	  http://stgt.berlios.de/
++
++	  To compile this driver as a module, choose M here: the
++	  module will be called ibmvstgt.
++
+ config SCSI_INITIO
+ 	tristate "Initio 9100U(W) support"
+ 	depends on PCI && SCSI
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index d71bb59..78544e3 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
+ obj-$(CONFIG_SCSI_IPR)		+= ipr.o
+ obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
+ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
+ obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
+ obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
+ obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
+diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
+index 4e247b6..6ac0633 100644
+--- a/drivers/scsi/ibmvscsi/Makefile
++++ b/drivers/scsi/ibmvscsi/Makefile
+@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
+ ibmvscsic-y			+= ibmvscsi.o
+ ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
+ ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
++
++obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
+diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
+new file mode 100644
+index 0000000..7a98517
+--- /dev/null
++++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
+@@ -0,0 +1,952 @@
++/*
++ * IBM eServer i/pSeries Virtual SCSI Target Driver
++ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
++ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
++ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
++ *
++ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
++ *
++ * This program is free software; you can redistribute it and/or modify
++ * it under the terms of the GNU General Public License as published by
++ * the Free Software Foundation; either version 2 of the License, or
++ * (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
++ * USA
++ */
++#include <linux/interrupt.h>
++#include <linux/module.h>
++#include <scsi/scsi.h>
++#include <scsi/scsi_host.h>
++#include <scsi/scsi_tgt.h>
++#include <scsi/libsrp.h>
++#include <asm/hvcall.h>
++#include <asm/iommu.h>
++#include <asm/prom.h>
++#include <asm/vio.h>
++
++#include "ibmvscsi.h"
++
++#define	INITIAL_SRP_LIMIT	16
++#define	DEFAULT_MAX_SECTORS	512
++
++#define	TGT_NAME	"ibmvstgt"
++
++/*
++ * Hypervisor calls.
++ */
++#define h_copy_rdma(l, sa, sb, da, db) \
++			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
++#define h_send_crq(ua, l, h) \
++			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
++#define h_reg_crq(ua, tok, sz)\
++			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
++#define h_free_crq(ua) \
++			plpar_hcall_norets(H_FREE_CRQ, ua);
++
++/* tmp - will replace with SCSI logging stuff */
++#define eprintk(fmt, args...)					\
++do {								\
++	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++/* #define dprintk eprintk */
++#define dprintk(fmt, args...)
++
++struct vio_port {
++	struct vio_dev *dma_dev;
++
++	struct crq_queue crq_queue;
++	struct work_struct crq_work;
++
++	unsigned long liobn;
++	unsigned long riobn;
++};
++
++static struct workqueue_struct *vtgtd;
++
++/*
++ * These are fixed for the system and come from the Open Firmware device tree.
++ * We just store them here to save getting them every time.
++ */
++static char system_id[64] = "";
++static char partition_name[97] = "UNKNOWN";
++static unsigned int partition_number = -1;
++
++static struct vio_port *target_to_port(struct srp_target *target)
++{
++	return (struct vio_port *) target->ldata;
++}
++
++static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
++{
++	return (union viosrp_iu *) (iue->sbuf->buf);
++}
++
++static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
++{
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	long rc, rc1;
++	union {
++		struct viosrp_crq cooked;
++		uint64_t raw[2];
++	} crq;
++
++	/* First copy the SRP */
++	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
++			 vport->riobn, iue->remote_token);
++
++	if (rc)
++		eprintk("Error %ld transferring data\n", rc);
++
++	crq.cooked.valid = 0x80;
++	crq.cooked.format = format;
++	crq.cooked.reserved = 0x00;
++	crq.cooked.timeout = 0x00;
++	crq.cooked.IU_length = length;
++	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
++
++	if (rc == 0)
++		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
++	else
++		crq.cooked.status = 0x00;
++
++	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
++
++	if (rc1) {
++		eprintk("%ld sending response\n", rc1);
++		return rc1;
++	}
++
++	return rc;
++}
++
++#define SRP_RSP_SENSE_DATA_LEN	18
++
++static int send_rsp(struct iu_entry *iue, struct scsi_cmnd *sc,
++		    unsigned char status, unsigned char asc)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	uint64_t tag = iu->srp.rsp.tag;
++
++	/* If the linked bit is on and status is good */
++	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
++		status = 0x10;
++
++	memset(iu, 0, sizeof(struct srp_rsp));
++	iu->srp.rsp.opcode = SRP_RSP;
++	iu->srp.rsp.req_lim_delta = 1;
++	iu->srp.rsp.tag = tag;
++
++	if (test_bit(V_DIOVER, &iue->flags))
++		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
++
++	iu->srp.rsp.data_in_res_cnt = 0;
++	iu->srp.rsp.data_out_res_cnt = 0;
++
++	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
++
++	iu->srp.rsp.resp_data_len = 0;
++	iu->srp.rsp.status = status;
++	if (status) {
++		uint8_t *sense = iu->srp.rsp.data;
++
++		if (sc) {
++			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
++			memcpy(sense, sc->sense_buffer, SCSI_SENSE_BUFFERSIZE);
++		} else {
++			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
++			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
++			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
++
++			/* Valid bit and 'current errors' */
++			sense[0] = (0x1 << 7 | 0x70);
++			/* Sense key */
++			sense[2] = status;
++			/* Additional sense length */
++			sense[7] = 0xa;	/* 10 bytes */
++			/* Additional sense code */
++			sense[12] = asc;
++		}
++	}
++
++	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
++		VIOSRP_SRP_FORMAT);
++
++	return 0;
++}
++
++static void handle_cmd_queue(struct srp_target *target)
++{
++	struct Scsi_Host *shost = target->shost;
++	struct iu_entry *iue;
++	struct srp_cmd *cmd;
++	unsigned long flags;
++	int err;
++
++retry:
++	spin_lock_irqsave(&target->lock, flags);
++
++	list_for_each_entry(iue, &target->cmd_queue, ilist) {
++		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
++			spin_unlock_irqrestore(&target->lock, flags);
++			cmd = iue->sbuf->buf;
++			err = srp_cmd_queue(shost, cmd, iue, 0);
++			if (err) {
++				eprintk("cannot queue cmd %p %d\n", cmd, err);
++				srp_iu_put(iue);
++			}
++			goto retry;
++		}
++	}
++
++	spin_unlock_irqrestore(&target->lock, flags);
++}
++
++static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
++			 struct srp_direct_buf *md, int nmd,
++			 enum dma_data_direction dir, unsigned int rest)
++{
++	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	dma_addr_t token;
++	long err;
++	unsigned int done = 0;
++	int i, sidx, soff;
++
++	sidx = soff = 0;
++	token = sg_dma_address(sg + sidx);
++
++	for (i = 0; i < nmd && rest; i++) {
++		unsigned int mdone, mlen;
++
++		mlen = min(rest, md[i].len);
++		for (mdone = 0; mlen;) {
++			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
++
++			if (dir == DMA_TO_DEVICE)
++				err = h_copy_rdma(slen,
++						  vport->riobn,
++						  md[i].va + mdone,
++						  vport->liobn,
++						  token + soff);
++			else
++				err = h_copy_rdma(slen,
++						  vport->liobn,
++						  token + soff,
++						  vport->riobn,
++						  md[i].va + mdone);
++
++			if (err != H_SUCCESS) {
++				eprintk("rdma error %d %d\n", dir, slen);
++				goto out;
++			}
++
++			mlen -= slen;
++			mdone += slen;
++			soff += slen;
++			done += slen;
++
++			if (soff == sg_dma_len(sg + sidx)) {
++				sidx++;
++				soff = 0;
++				token = sg_dma_address(sg + sidx);
++
++				if (sidx > nsg) {
++					eprintk("out of sg %p %d %d\n",
++						iue, sidx, nsg);
++					goto out;
++				}
++			}
++		};
++
++		rest -= mlen;
++	}
++out:
++
++	return 0;
++}
++
++static int ibmvstgt_transfer_data(struct scsi_cmnd *sc,
++				  void (*done)(struct scsi_cmnd *))
++{
++	struct iu_entry	*iue = (struct iu_entry *) sc->SCp.ptr;
++	int err;
++
++	err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
++
++	done(sc);
++
++	return err;
++}
++
++static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
++			     void (*done)(struct scsi_cmnd *))
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
++	struct srp_target *target = iue->target;
++
++	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_del(&iue->ilist);
++	spin_unlock_irqrestore(&target->lock, flags);
++
++	if (sc->result != SAM_STAT_GOOD) {
++		eprintk("operation failed %p %d %x\n",
++			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
++		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
++	} else
++		send_rsp(iue, sc, NO_SENSE, 0x00);
++
++	done(sc);
++	srp_iu_put(iue);
++	return 0;
++}
++
++int send_adapter_info(struct iu_entry *iue,
++		      dma_addr_t remote_buffer, uint16_t length)
++{
++	struct srp_target *target = iue->target;
++	struct vio_port *vport = target_to_port(target);
++	struct Scsi_Host *shost = target->shost;
++	dma_addr_t data_token;
++	struct mad_adapter_info_data *info;
++	int err;
++
++	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
++				  GFP_KERNEL);
++	if (!info) {
++		eprintk("bad dma_alloc_coherent %p\n", target);
++		return 1;
++	}
++
++	/* Get remote info */
++	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
++			  vport->liobn, data_token);
++	if (err == H_SUCCESS) {
++		dprintk("Client connect: %s (%d)\n",
++			info->partition_name, info->partition_number);
++	}
++
++	memset(info, 0, sizeof(*info));
++
++	strcpy(info->srp_version, "16.a");
++	strncpy(info->partition_name, partition_name,
++		sizeof(info->partition_name));
++	info->partition_number = partition_number;
++	info->mad_version = 1;
++	info->os_type = 2;
++	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
++
++	/* Send our info to remote */
++	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
++			  vport->riobn, remote_buffer);
++
++	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
++
++	if (err != H_SUCCESS) {
++		eprintk("Error sending adapter info %d\n", err);
++		return 1;
++	}
++
++	return 0;
++}
++
++static void process_login(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
++	uint64_t tag = iu->srp.rsp.tag;
++
++	/* TODO handle case that requested size is wrong and
++	 * buffer format is wrong
++	 */
++	memset(iu, 0, sizeof(struct srp_login_rsp));
++	rsp->opcode = SRP_LOGIN_RSP;
++	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
++	rsp->tag = tag;
++	rsp->max_it_iu_len = sizeof(union srp_iu);
++	rsp->max_ti_iu_len = sizeof(union srp_iu);
++	/* direct and indirect */
++	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
++
++	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
++}
++
++static inline void queue_cmd(struct iu_entry *iue)
++{
++	struct srp_target *target = iue->target;
++	unsigned long flags;
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_add_tail(&iue->ilist, &target->cmd_queue);
++	spin_unlock_irqrestore(&target->lock, flags);
++}
++
++static int process_tsk_mgmt(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int fn;
++
++	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
++
++	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		fn = ABORT_TASK;
++		break;
++	case SRP_TSK_ABORT_TASK_SET:
++		fn = ABORT_TASK_SET;
++		break;
++	case SRP_TSK_CLEAR_TASK_SET:
++		fn = CLEAR_TASK_SET;
++		break;
++	case SRP_TSK_LUN_RESET:
++		fn = LOGICAL_UNIT_RESET;
++		break;
++	case SRP_TSK_CLEAR_ACA:
++		fn = CLEAR_ACA;
++		break;
++	default:
++		fn = 0;
++	}
++	if (fn)
++		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
++					  iu->srp.tsk_mgmt.task_tag,
++					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
++					  iue);
++	else
++		send_rsp(iue, NULL, ILLEGAL_REQUEST, 0x20);
++
++	return !fn;
++}
++
++static int process_mad_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	struct viosrp_adapter_info *info;
++	struct viosrp_host_config *conf;
++
++	switch (iu->mad.empty_iu.common.type) {
++	case VIOSRP_EMPTY_IU_TYPE:
++		eprintk("%s\n", "Unsupported EMPTY MAD IU");
++		break;
++	case VIOSRP_ERROR_LOG_TYPE:
++		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
++		iu->mad.error_log.common.status = 1;
++		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_ADAPTER_INFO_TYPE:
++		info = &iu->mad.adapter_info;
++		info->common.status = send_adapter_info(iue, info->buffer,
++							info->common.length);
++		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
++		break;
++	case VIOSRP_HOST_CONFIG_TYPE:
++		conf = &iu->mad.host_config;
++		conf->common.status = 1;
++		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
++		break;
++	default:
++		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
++	}
++
++	return 1;
++}
++
++static int process_srp_iu(struct iu_entry *iue)
++{
++	union viosrp_iu *iu = vio_iu(iue);
++	int done = 1;
++	u8 opcode = iu->srp.rsp.opcode;
++
++	switch (opcode) {
++	case SRP_LOGIN_REQ:
++		process_login(iue);
++		break;
++	case SRP_TSK_MGMT:
++		done = process_tsk_mgmt(iue);
++		break;
++	case SRP_CMD:
++		queue_cmd(iue);
++		done = 0;
++		break;
++	case SRP_LOGIN_RSP:
++	case SRP_I_LOGOUT:
++	case SRP_T_LOGOUT:
++	case SRP_RSP:
++	case SRP_CRED_REQ:
++	case SRP_CRED_RSP:
++	case SRP_AER_REQ:
++	case SRP_AER_RSP:
++		eprintk("Unsupported type %u\n", opcode);
++		break;
++	default:
++		eprintk("Unknown type %u\n", opcode);
++	}
++
++	return done;
++}
++
++static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct iu_entry *iue;
++	long err, done;
++
++	iue = srp_iu_get(target);
++	if (!iue) {
++		eprintk("Error getting IU from pool, %p\n", target);
++		return;
++	}
++
++	iue->remote_token = crq->IU_data_ptr;
++
++	err = h_copy_rdma(crq->IU_length, vport->riobn,
++			  iue->remote_token, vport->liobn, iue->sbuf->dma);
++
++	if (err != H_SUCCESS)
++		eprintk("%ld transferring data error %p\n", err, iue);
++
++	if (crq->format == VIOSRP_MAD_FORMAT)
++		done = process_mad_iu(iue);
++	else
++		done = process_srp_iu(iue);
++
++	if (done)
++		srp_iu_put(iue);
++}
++
++static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++
++	vio_disable_interrupts(vport->dma_dev);
++	queue_work(vtgtd, &vport->crq_work);
++
++	return IRQ_HANDLED;
++}
++
++static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
++{
++	int err;
++	struct vio_port *vport = target_to_port(target);
++
++	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
++	if (!queue->msgs)
++		goto malloc_failed;
++	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
++
++	queue->msg_token = dma_map_single(target->dev, queue->msgs,
++					  queue->size * sizeof(*queue->msgs),
++					  DMA_BIDIRECTIONAL);
++
++	if (dma_mapping_error(queue->msg_token))
++		goto map_failed;
++
++	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
++			PAGE_SIZE);
++
++	/* If the adapter was left active for some reason (like kexec)
++	 * try freeing and re-registering
++	 */
++	if (err == H_RESOURCE) {
++	    do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
++			    PAGE_SIZE);
++	}
++
++	if (err != H_SUCCESS && err != 2) {
++		eprintk("Error 0x%x opening virtual adapter\n", err);
++		goto reg_crq_failed;
++	}
++
++	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
++			  SA_INTERRUPT, "ibmvstgt", target);
++	if (err)
++		goto req_irq_failed;
++
++	vio_enable_interrupts(vport->dma_dev);
++
++	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
++
++	queue->cur = 0;
++	spin_lock_init(&queue->lock);
++
++	return 0;
++
++req_irq_failed:
++	do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++reg_crq_failed:
++	dma_unmap_single(target->dev, queue->msg_token,
++			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
++map_failed:
++	free_page((unsigned long) queue->msgs);
++
++malloc_failed:
++	return -ENOMEM;
++}
++
++static void crq_queue_destroy(struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	struct crq_queue *queue = &vport->crq_queue;
++	int err;
++
++	free_irq(vport->dma_dev->irq, target);
++	do {
++		err = h_free_crq(vport->dma_dev->unit_address);
++	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
++
++	dma_unmap_single(target->dev, queue->msg_token,
++			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
++
++	free_page((unsigned long) queue->msgs);
++}
++
++static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
++{
++	struct vio_port *vport = target_to_port(target);
++	dprintk("%x %x\n", crq->valid, crq->format);
++
++	switch (crq->valid) {
++	case 0xC0:
++		/* initialization */
++		switch (crq->format) {
++		case 0x01:
++			h_send_crq(vport->dma_dev->unit_address,
++				   0xC002000000000000, 0);
++			break;
++		case 0x02:
++			break;
++		default:
++			eprintk("Unknown format %u\n", crq->format);
++		}
++		break;
++	case 0xFF:
++		/* transport event */
++		break;
++	case 0x80:
++		/* real payload */
++		switch (crq->format) {
++		case VIOSRP_SRP_FORMAT:
++		case VIOSRP_MAD_FORMAT:
++			process_iu(crq, target);
++			break;
++		case VIOSRP_OS400_FORMAT:
++		case VIOSRP_AIX_FORMAT:
++		case VIOSRP_LINUX_FORMAT:
++		case VIOSRP_INLINE_FORMAT:
++			eprintk("Unsupported format %u\n", crq->format);
++			break;
++		default:
++			eprintk("Unknown format %u\n", crq->format);
++		}
++		break;
++	default:
++		eprintk("unknown message type 0x%02x!?\n", crq->valid);
++	}
++}
++
++static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
++{
++	struct viosrp_crq *crq;
++	unsigned long flags;
++
++	spin_lock_irqsave(&queue->lock, flags);
++	crq = &queue->msgs[queue->cur];
++	if (crq->valid & 0x80) {
++		if (++queue->cur == queue->size)
++			queue->cur = 0;
++	} else
++		crq = NULL;
++	spin_unlock_irqrestore(&queue->lock, flags);
++
++	return crq;
++}
++
++static void handle_crq(void *data)
++{
++	struct srp_target *target = (struct srp_target *) data;
++	struct vio_port *vport = target_to_port(target);
++	struct viosrp_crq *crq;
++	int done = 0;
++
++	while (!done) {
++		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
++			process_crq(crq, target);
++			crq->valid = 0x00;
++		}
++
++		vio_enable_interrupts(vport->dma_dev);
++
++		crq = next_crq(&vport->crq_queue);
++		if (crq) {
++			vio_disable_interrupts(vport->dma_dev);
++			process_crq(crq, target);
++			crq->valid = 0x00;
++		} else
++			done = 1;
++	}
++
++	handle_cmd_queue(target);
++}
++
++
++static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *sc)
++{
++	unsigned long flags;
++	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
++	struct srp_target *target = iue->target;
++
++	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
++
++	spin_lock_irqsave(&target->lock, flags);
++	list_del(&iue->ilist);
++	spin_unlock_irqrestore(&target->lock, flags);
++
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
++{
++	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
++	union viosrp_iu *iu = vio_iu(iue);
++	unsigned char status, asc;
++
++	eprintk("%p %d\n", iue, result);
++	status = NO_SENSE;
++	asc = 0;
++
++	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
++	case SRP_TSK_ABORT_TASK:
++		asc = 0x14;
++		if (result)
++			status = ABORTED_COMMAND;
++		break;
++	default:
++		break;
++	}
++
++	send_rsp(iue, NULL, status, asc);
++	srp_iu_put(iue);
++
++	return 0;
++}
++
++static ssize_t system_id_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
++}
++
++static ssize_t partition_number_show(struct class_device *cdev, char *buf)
++{
++	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
++}
++
++static ssize_t unit_address_show(struct class_device *cdev, char *buf)
++{
++	struct Scsi_Host *shost = class_to_shost(cdev);
++	struct srp_target *target = host_to_srp_target(shost);
++	struct vio_port *vport = target_to_port(target);
++	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
++}
++
++static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
++static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
++static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
++
++static struct class_device_attribute *ibmvstgt_attrs[] = {
++	&class_device_attr_system_id,
++	&class_device_attr_partition_number,
++	&class_device_attr_unit_address,
++	NULL,
++};
++
++static struct scsi_host_template ibmvstgt_sht = {
++	.name			= TGT_NAME,
++	.module			= THIS_MODULE,
++	.can_queue		= INITIAL_SRP_LIMIT,
++	.sg_tablesize		= SG_ALL,
++	.use_clustering		= DISABLE_CLUSTERING,
++	.max_sectors		= DEFAULT_MAX_SECTORS,
++	.transfer_response	= ibmvstgt_cmd_done,
++	.transfer_data		= ibmvstgt_transfer_data,
++	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
++	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
++	.shost_attrs		= ibmvstgt_attrs,
++	.proc_name		= TGT_NAME,
++};
++
++static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
++{
++	struct Scsi_Host *shost;
++	struct srp_target *target;
++	struct vio_port *vport;
++	unsigned int *dma, dma_size;
++	int err = -ENOMEM;
++
++	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
++	if (!vport)
++		return err;
++	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
++	if (!shost)
++		goto free_vport;
++	err = scsi_tgt_alloc_queue(shost);
++	if (err)
++		goto put_host;
++
++	target = host_to_srp_target(shost);
++	target->shost = shost;
++	vport->dma_dev = dev;
++	target->ldata = vport;
++	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
++			       SRP_MAX_IU_LEN);
++	if (err)
++		goto put_host;
++
++	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
++						 &dma_size);
++	if (!dma || dma_size != 40) {
++		eprintk("Couldn't get window property %d\n", dma_size);
++		err = -EIO;
++		goto free_srp_target;
++	}
++	vport->liobn = dma[0];
++	vport->riobn = dma[5];
++
++	INIT_WORK(&vport->crq_work, handle_crq, target);
++
++	err = crq_queue_create(&vport->crq_queue, target);
++	if (err)
++		goto free_srp_target;
++
++	err = scsi_add_host(shost, target->dev);
++	if (err)
++		goto destroy_queue;
++	return 0;
++
++destroy_queue:
++	crq_queue_destroy(target);
++free_srp_target:
++	srp_target_free(target);
++put_host:
++	scsi_host_put(shost);
++free_vport:
++	kfree(vport);
++	return err;
++}
++
++static int ibmvstgt_remove(struct vio_dev *dev)
++{
++	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
++	struct Scsi_Host *shost = target->shost;
++
++	srp_target_free(target);
++	crq_queue_destroy(target);
++	scsi_remove_host(shost);
++	scsi_host_put(shost);
++	return 0;
++}
++
++static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
++	{"v-scsi-host", "IBM,v-scsi-host"},
++	{"",""}
++};
++
++MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
++
++static struct vio_driver ibmvstgt_driver = {
++	.id_table = ibmvstgt_device_table,
++	.probe = ibmvstgt_probe,
++	.remove = ibmvstgt_remove,
++	.driver = {
++		.name = "ibmvscsis",
++		.owner = THIS_MODULE,
++	}
++};
++
++static int get_system_info(void)
++{
++	struct device_node *rootdn;
++	char *id, *model, *name;
++	unsigned int *num;
++
++	rootdn = find_path_device("/");
++	if (!rootdn)
++		return -ENOENT;
++
++	model = get_property(rootdn, "model", NULL);
++	id = get_property(rootdn, "system-id", NULL);
++	if (model && id)
++		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
++
++	name = get_property(rootdn, "ibm,partition-name", NULL);
++	if (name)
++		strncpy(partition_name, name, sizeof(partition_name));
++
++	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
++	if (num)
++		partition_number = *num;
++
++	return 0;
++}
++
++static int ibmvstgt_init(void)
++{
++	int err = -ENOMEM;
++
++	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
++
++	vtgtd = create_workqueue("ibmvtgtd");
++	if (!vtgtd)
++		return err;
++
++	err = get_system_info();
++	if (err)
++		goto destroy_wq;
++
++	err = vio_register_driver(&ibmvstgt_driver);
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(vtgtd);
++	return err;
++}
++
++static void ibmvstgt_exit(void)
++{
++	printk("Unregister IBM virtual SCSI driver\n");
++
++	destroy_workqueue(vtgtd);
++	vio_unregister_driver(&ibmvstgt_driver);
++}
++
++MODULE_DESCRIPTION("IBM Virtual SCSI Target");
++MODULE_AUTHOR("Dave Boutcher");
++MODULE_LICENSE("GPL");
++
++module_init(ibmvstgt_init);
++module_exit(ibmvstgt_exit);
+-- 
+1.4.1
+



From tomo at mail.berlios.de  Fri Aug 18 05:23:35 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 18 Aug 2006 05:23:35 +0200
Subject: [Stgt-svn] r531 - trunk/patchset
Message-ID: <200608180323.k7I3NZad009774@sheep.berlios.de>

Author: tomo
Date: 2006-08-18 05:23:22 +0200 (Fri, 18 Aug 2006)
New Revision: 531

Modified:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
   trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
Log:
Update the patchset (just disable the debug option by default).

Modified: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 41e2998c000a999a60c4f035af7ab6593cc9b747 Mon Sep 17 00:00:00 2001
+From 44951054af3722883087e928979f1c89fdee918b Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
 Date: Thu, 17 Aug 2006 23:47:00 +0900
 Subject: [PATCH 1/9] block layer: kill length alignment test in bin_map_user

Modified: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From edae3e91816a0aa1d6afc5bfc5c7cbdb8d2f1229 Mon Sep 17 00:00:00 2001
+From 79acdaa1243aecedcd035c3219375a7cb9c9f786 Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
 Date: Thu, 17 Aug 2006 23:48:58 +0900
 Subject: [PATCH 2/9] block layer: add partial mappings support to bio_map_user

Modified: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 23c2123adf959725f1f7b49b0b13606725586d82 Mon Sep 17 00:00:00 2001
+From 3f63e5e44b012927b6054f7025d3a5e7be6f7f09 Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
 Date: Thu, 17 Aug 2006 23:52:17 +0900
 Subject: [PATCH 3/9] block layer: use blk_rq_bio_prep in init_request_from_bio

Modified: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 3ee7022b3d6bed6ea506c205e58f03588d7a170e Mon Sep 17 00:00:00 2001
+From 8f167fea740f5d82c70a2e9938e983b704baae67 Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
 Date: Thu, 17 Aug 2006 23:56:41 +0900
 Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs

Modified: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,6 +1,6 @@
-From dc6a0cdc52e680b696d86b25d698a847205cad98 Mon Sep 17 00:00:00 2001
+From 116f6f576a16fd7a2685916e4146930f90204d46 Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Fri, 18 Aug 2006 00:45:35 +0900
+Date: Fri, 18 Aug 2006 11:55:41 +0900
 Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
 
 The core scsi target lib functions.
@@ -19,9 +19,9 @@
 Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
 ---
  drivers/scsi/scsi_tgt_lib.c  |  700 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   24 +
+ drivers/scsi/scsi_tgt_priv.h |   25 ++
  include/scsi/scsi_tgt.h      |   18 +
- 3 files changed, 742 insertions(+), 0 deletions(-)
+ 3 files changed, 743 insertions(+), 0 deletions(-)
 
 diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
 new file mode 100644
@@ -731,10 +731,10 @@
 +MODULE_LICENSE("GPL");
 diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
 new file mode 100644
-index 0000000..b7b6ea6
+index 0000000..84488c5
 --- /dev/null
 +++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,24 @@
+@@ -0,0 +1,25 @@
 +struct scsi_cmnd;
 +struct scsi_lun;
 +struct Scsi_Host;
@@ -746,7 +746,8 @@
 +	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 +} while (0)
 +
-+#define dprintk eprintk
++#define dprintk(fmt, args...)
++/* #define dprintk eprintk */
 +
 +extern void scsi_tgt_if_exit(void);
 +extern int scsi_tgt_if_init(void);

Modified: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 4587372bbb53c83f86c14cc2f33073937e2ca0b7 Mon Sep 17 00:00:00 2001
+From 4f1934d63d45a88066061f460a7e57fdddba6bf6 Mon Sep 17 00:00:00 2001
 From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 Date: Fri, 18 Aug 2006 00:32:41 +0900
 Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface

Modified: trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
===================================================================
--- trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 855bdf3bd4a0c9cbcb57a37fe34a7188e8adb61f Mon Sep 17 00:00:00 2001
+From 4d62965a2d1d43b05529bf2f26563d3ddbe449cb Mon Sep 17 00:00:00 2001
 From: Mike Christie <michaelc at cs.wisc.edu>
 Date: Fri, 18 Aug 2006 00:33:17 +0900
 Subject: [PATCH 7/9] scsi-ml: Makefile and Kconfig changes for tgt

Modified: trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 7f19e763441525e31f6b771890ef534e0512398d Mon Sep 17 00:00:00 2001
+From b5ab4781574e70ed224a5dee7fe600880c98dda4 Mon Sep 17 00:00:00 2001
 From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 Date: Fri, 18 Aug 2006 00:36:47 +0900
 Subject: [PATCH 8/9] scsi tgt: SCSI RDMA Protocol library functions

Modified: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-17 17:22:56 UTC (rev 530)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-18 03:23:22 UTC (rev 531)
@@ -1,4 +1,4 @@
-From 747144ea9774596a61b7ba39c0ae18b378b33d36 Mon Sep 17 00:00:00 2001
+From eed708a465130a096f3ce2892198ed77ef2504b8 Mon Sep 17 00:00:00 2001
 From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
 Date: Fri, 18 Aug 2006 00:41:02 +0900
 Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries virtual SCSI target driver



From tomo at mail.berlios.de  Fri Aug 18 10:01:24 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 18 Aug 2006 10:01:24 +0200
Subject: [Stgt-svn] r532 - trunk/usr
Message-ID: <200608180801.k7I81Ofp027412@sheep.berlios.de>

Author: tomo
Date: 2006-08-18 10:01:20 +0200 (Fri, 18 Aug 2006)
New Revision: 532

Modified:
   trunk/usr/mgmt.c
Log:
Add workaround for EAGAIN.

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-18 03:23:22 UTC (rev 531)
+++ trunk/usr/mgmt.c	2006-08-18 08:01:20 UTC (rev 532)
@@ -223,8 +223,16 @@
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 
+retry:
 	err = recvmsg(fd, &msg, MSG_PEEK | MSG_DONTWAIT);
 	if (err != len) {
+		/*
+		 * workaround. We need to put this request to
+		 * scheduler and wait for timeout or data.
+		 */
+		if (errno == EAGAIN)
+			goto retry;
+
 		eprintf("can't read %s\n", strerror(errno));
 		goto out;
 	}



From tomo at mail.berlios.de  Sun Aug 20 19:34:38 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 19:34:38 +0200
Subject: [Stgt-svn] r533 - trunk
Message-ID: <200608201734.k7KHYciE010988@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 19:34:33 +0200 (Sun, 20 Aug 2006)
New Revision: 533

Modified:
   trunk/Makefile
Log:
Remove tgt kernel code and ibmvstgt driver entries in Makefile.


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-08-18 08:01:20 UTC (rev 532)
+++ trunk/Makefile	2006-08-20 17:34:33 UTC (rev 533)
@@ -14,19 +14,9 @@
 export KERNELSRC
 
 all:
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt
-else
-	make -C istgt
-endif
 	make -C usr
-	make -C kernel
+	make -C istgt
+
 clean:
 	make -C usr clean
-	make -C kernel clean
-
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt clean
-else
 	make -C istgt clean
-endif



From tomo at mail.berlios.de  Sun Aug 20 19:50:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 19:50:19 +0200
Subject: [Stgt-svn] r534 - branches
Message-ID: <200608201750.k7KHoJ1G013469@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 19:50:14 +0200 (Sun, 20 Aug 2006)
New Revision: 534

Added:
   branches/user-iscsi/
Log:
Create an experimental branch for user-space iscsi target.

Copied: branches/user-iscsi (from rev 527, trunk)



From tomo at mail.berlios.de  Sun Aug 20 21:01:31 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 21:01:31 +0200
Subject: [Stgt-svn] r535 - in branches/user-iscsi: . ibmvstgt kernel
	patchset usr usr/iscsi
Message-ID: <200608201901.k7KJ1VOX004329@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 21:00:24 +0200 (Sun, 20 Aug 2006)
New Revision: 535

Removed:
   branches/user-iscsi/ibmv
   branches/user-iscsi/ibmvstgt/Makefile
   branches/user-iscsi/ibmvstgt/kernel/
   branches/user-iscsi/initd
   branches/user-iscsi/kernel/Makefile
   branches/user-iscsi/kernel/scsi_tgt_if.c
   branches/user-iscsi/kernel/scsi_tgt_lib.c
   branches/user-iscsi/kernel/scsi_tgt_priv.h
   branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt
   branches/user-iscsi/patchset/README
   branches/user-iscsi/qla2xxx/
   branches/user-iscsi/usr/ibmvio/
   branches/user-iscsi/usr/iscsi/Makefile
   branches/user-iscsi/usr/iscsi/netlink.c
   branches/user-iscsi/usr/tgtif.c
Modified:
   branches/user-iscsi/Makefile
   branches/user-iscsi/README
   branches/user-iscsi/iscsi
   branches/user-iscsi/usr/Makefile
   branches/user-iscsi/usr/iscsi/conn.c
   branches/user-iscsi/usr/iscsi/iscsi.h
   branches/user-iscsi/usr/iscsi/iscsid.c
   branches/user-iscsi/usr/iscsi/iscsid.h
   branches/user-iscsi/usr/iscsi/istgt.c
   branches/user-iscsi/usr/iscsi/session.c
   branches/user-iscsi/usr/iscsi/types.h
   branches/user-iscsi/usr/mgmt.c
   branches/user-iscsi/usr/scsi.c
   branches/user-iscsi/usr/target.c
   branches/user-iscsi/usr/tgtd.c
   branches/user-iscsi/usr/tgtd.h
   branches/user-iscsi/usr/util.h
Log:
Commit initial code.

Modified: branches/user-iscsi/Makefile
===================================================================
--- branches/user-iscsi/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -2,31 +2,7 @@
 # Need to use some magic to select what target drivers will be complied
 #
 
-IBMVIO=1
-ISCSI=1
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-export IBMVIO
-export ISCSI
-export KERNELSRC
-
 all:
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt
-else
-	make -C istgt
-endif
 	make -C usr
-	make -C kernel
 clean:
 	make -C usr clean
-	make -C kernel clean
-
-ifeq ($(ARCH), powerpc)
-	make -C ibmvstgt clean
-else
-	make -C istgt clean
-endif

Modified: branches/user-iscsi/README
===================================================================
--- branches/user-iscsi/README	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/README	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,83 +1,15 @@
 Introduction
 -------------
-Note that linux target framework (tgt) is under active
-development. Don't play with important data.
 
-Currently, tgt supports only one low level driver, IBM VIO server
-(ibmvstgt).
+This is an experimental branch to implement iscsi target software in
+user space by exploiting tgt user-space code.
 
 
 Starting
 -------------
-The software consists of kernel modules and user-space tools (daemon,
-management tool, dynamic libraries).
 
-First, get kernel sources from James's scsi-rc-fixes-2.6 git tree:
+First, modify the user-iscsi/iscsi schell script for configuration.
 
-master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-target-2.6.git
-
-Second, if you use ibmvstgt, apply scsi-target-2.6-tree.diff in the
-patchset directory. If not, you can skip this.
-
-Third, rebuild the kernel, and reboot with the new kernel.
-
-The compilation of the kernel modules require the path to above kernel
-source:
-
-host:~/use-scsi-ml$ make KERNELSRC=<kernel-src>
-
-Make sure that everything is built successfully. Now you can load the
-kernel modules by typing the followings.
-
-host:~/use-scsi-ml$ su
-host:~/use-scsi-ml# ./initd start
-
-See /var/log/kern.log (your Linux distributions may use the different
-log file name) to make sure that the kernel modules are loaded
-properly. You should see messages like the followings:
-
-Feb 27 19:37:52 lilac kernel: IBM eServer i/pSeries Virtual SCSI Target Driver
-Feb 27 19:37:52 lilac kernel: vio_register_driver: driver ibmvscsi registering
-Feb 27 19:37:52 lilac kernel: scsi1 : ibmvstgt
-
-You need the scsi host number (it is 1 in this example) in the next
-stage (configuration).
-
-
-Configuration
--------------
-
-Everyting is configured via the tgtadm management tool. Currenlty, tgt
-does not support persistent configurations. You can use a makeshift
-script, 'ibmv' to do the necessary job.
-
-Note that the ibmv script exports /dev/sdb1 to initiators as LUN 0 by
-defaults. You MUST change the device path if your /dev/sdb1 stores
-important data or your box does not have /dev/sdb1.
-
-host:~/use-scsi-ml# ./ibmv 1
-
-You need to specify the scsi host number as the first argument.
-
-Please see /var/log/daemon.log (your Linux distributions may use the
-different log file name again) to make sure that everything is
-fine. You should see something like the followings:
-
-Feb 27 22:36:40 lilac tgtd: dl_init(71) istgt library is not loaded.
-Feb 27 22:36:40 lilac tgtd: dl_init(71) ibmvstgt library is not loaded.
-Feb 27 22:37:08 lilac tgtd: tgt_target_create(572) Succeed to create a new target 1
-Feb 27 22:37:08 lilac tgtd: tgt_target_bind(517) Succeed to bind the target 1 to the scsi host 1
-Feb 27 22:37:08 lilac tgtd: tgt_device_create(238) Succeed to add a logical unit 0 to the target 1
-
-
-Now you are ready. Boot up VIO clients.
-
-Note that the tgt kernel modules enable the debug option by
-defaults. We are not ready for improving performance.
-
-
-Stopping
--------------
-Simply execute:
-
-host:~/use-scsi-ml# ./initd stop
+host:~/user-iscsi$ make
+host:~/user-iscsi$ su
+host:~/user-iscsi# ./iscsi

Deleted: branches/user-iscsi/ibmv
===================================================================
--- branches/user-iscsi/ibmv	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/ibmv	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,10 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start ibmvstgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
-${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --bus vio,30000003
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1

Deleted: branches/user-iscsi/ibmvstgt/Makefile
===================================================================
--- branches/user-iscsi/ibmvstgt/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/ibmvstgt/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,7 +0,0 @@
-SUBDIRS := $(shell pwd)
-
-mods:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
-
-clean:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Deleted: branches/user-iscsi/initd
===================================================================
--- branches/user-iscsi/initd	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/initd	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,132 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start tgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
-
-#
-# Need to select one
-#
-#TARGET=ibmvio
-TARGET=iscsi_tcp
-
-#
-# IBM pSeries VIO server
-#
-start_ibmvio()
-{
-	insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
-	insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
-}
-
-stop_ibmvio()
-{
-	rmmod libsrp
-	rmmod ibmvstgt
-}
-
-
-#
-# iSCSI stuff
-#
-start_iscsi_core()
-{
-	insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
-	insmod ${PWD}/istgt/kernel/libiscsi.ko
-}
-
-stop_iscsi_core()
-{
-	rmmod libiscsi
-	rmmod scsi_transport_iscsi
-}
-
-start_iscsi_tcp()
-{
-	modprobe -q crc32c
-
-	start_iscsi_core
-
-	insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
-	insmod ${PWD}/istgt/kernel/iscsi_tcp_target.ko
-}
-
-stop_iscsi_tcp()
-{
-	rmmod iscsi_tcp_target
-	rmmod iscsi_tcp
-}
-
-start_iscsi_iser()
-{
-    	start_iscsi_core
-}
-
-start_server()
-{
-	insmod ${PWD}/kernel/scsi_tgt.ko
-
-	case "$TARGET" in
-	    iscsi_tcp)
-		start_iscsi_tcp
-		;;
-	    ibmvio)
-		start_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	${PWD}/usr/tgtd -d8 --drivers iscsi
-
-	sleep 1
-}
-	
-stop_server()
-{
-	case "$TARGET" in
-	    iscsi_tcp)
-		${PWD}/usr/tgtadm --driver istgt --op delete
-		killall -9 istgtd
-		;;
-	    ibmvio)
-		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
-		;;
-	    *)
-		;;
-	esac
-
-	killall -9 tgtd
-
-	sleep 1
-
-	case "$TARGET" in
-	    iscsi_tcp)
-		stop_iscsi_tcp
-		;;
-	    ibmvio)
-		stop_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	rmmod scsi_tgt
-}
-
-case "$1" in
-	start)
-		start_server
-		;;
-	stop)
-		stop_server
-		;;
-	*)
-		echo "Usage: {start|stop}" >&2
-		exit 1
-		;;
-esac
-
-exit 0

Modified: branches/user-iscsi/iscsi
===================================================================
--- branches/user-iscsi/iscsi	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/iscsi	2006-08-20 19:00:24 UTC (rev 535)
@@ -5,5 +5,6 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+${PWD}/usr/tgtd --lld iscsi
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1

Deleted: branches/user-iscsi/kernel/Makefile
===================================================================
--- branches/user-iscsi/kernel/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,24 +0,0 @@
-#
-# Makefile for the Linux kernel device drivers.
-#
-
-EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17
-
-ifneq ($(KERNELRELEASE),)
-obj-m			+= scsi_tgt.o
-scsi_tgt-objs		:= scsi_tgt_lib.o scsi_tgt_if.o
-
-else
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-PWD := $(shell pwd)
-
-default:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) modules
-
-clean:
-	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(PWD) clean
-endif

Deleted: branches/user-iscsi/kernel/scsi_tgt_if.c
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_if.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_if.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,315 +0,0 @@
-/*
- * SCSI target kernel/user interface functions
- *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <linux/blkdev.h>
-#include <linux/file.h>
-#include <net/tcp.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_tgt.h>
-#include <scsi/scsi_tgt_if.h>
-
-#include "scsi_tgt_priv.h"
-
-struct rbuf {
-	u32 idx;
-	u32 nr_entry;
-	int entry_size;
-	char *buf;
-	int buf_size;
-	spinlock_t lock;
-};
-
-static int chrdev;
-static struct rbuf txbuf, rxbuf;
-static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
-
-static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-{
-	u32 offset = (idx & (rbuf->nr_entry - 1)) * rbuf->entry_size;
-	return (struct rbuf_hdr *) (rbuf->buf + offset);
-}
-
-static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-{
-	int i;
-
-	esize += sizeof(struct rbuf_hdr);
-	rbuf->idx = 0;
-	rbuf->entry_size = esize;
-	rbuf->buf = buf;
-	spin_lock_init(&rbuf->lock);
-
-	bsize /= esize;
-	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
-		;
-	rbuf->nr_entry = 1 << i;
-}
-
-static int send_event_rsp(u32 type, struct tgt_event *p)
-{
-	struct tgt_event *ev;
-	struct rbuf_hdr *hdr;
-	struct page *sp, *ep;
-	unsigned long flags;
-	int err = 0;
-
-	spin_lock_irqsave(&txbuf.lock, flags);
-
-	hdr = head_rbuf_hdr(&txbuf, txbuf.idx);
-	if (hdr->status)
-		err = 1;
-	else
-		txbuf.idx++;
-
-	spin_unlock_irqrestore(&txbuf.lock, flags);
-
-	if (err)
-		return err;
-
-	ev = (struct tgt_event *) hdr->data;
-	memcpy(ev, p, sizeof(*ev));
-	ev->type = type;
-	hdr->status = 1;
-	mb();
-
-	sp = virt_to_page(hdr);
-	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-	for (;sp <= ep; sp++)
-		flush_dcache_page(sp);
-
-	wake_up_interruptible(&tgt_poll_wait);
-
-	return 0;
-}
-
-int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct tgt_event ev;
-	int err;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_req.host_no = shost->host_no;
-	ev.k.cmd_req.cid = cmd->request->tag;
-	ev.k.cmd_req.data_len = cmd->request_bufflen;
-	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-	ev.k.cmd_req.attribute = cmd->tag;
-	ev.k.cmd_req.tag = tag;
-
-	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-		ev.k.cmd_req.data_len, cmd->tag,
-		(unsigned long long) ev.k.cmd_req.tag);
-
-	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &ev);
-	if (err)
-		eprintk("tx buf is full, could not send\n");
-	return err;
-}
-
-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct tgt_event ev;
-	int err;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.cmd_done.host_no = shost->host_no;
-	ev.k.cmd_done.cid = cmd->request->tag;
-	ev.k.cmd_done.result = cmd->result;
-
-	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-		ev.k.cmd_req.data_len, cmd->tag,
-		(unsigned long long) ev.k.cmd_req.tag);
-
-	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &ev);
-	if (err)
-		eprintk("tx buf is full, could not send\n");
-	return err;
-}
-
-int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-				  struct scsi_lun *scsilun, void *data)
-{
-	struct tgt_event ev;
-	int err;
-
-	memset(&ev, 0, sizeof(ev));
-	ev.k.tsk_mgmt_req.host_no = host_no;
-	ev.k.tsk_mgmt_req.function = function;
-	ev.k.tsk_mgmt_req.tag = tag;
-	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
-
-	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
-		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-
-	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-	if (err)
-		eprintk("tx buf is full, could not send\n");
-	return err;
-}
-
-static int event_recv_msg(struct tgt_event *ev)
-{
-	int err = 0;
-
-	switch (ev->type) {
-	case TGT_UEVENT_CMD_RSP:
-		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
-					   ev->u.cmd_rsp.cid,
-					   ev->u.cmd_rsp.result,
-					   ev->u.cmd_rsp.len,
-					   ev->u.cmd_rsp.uaddr,
-					   ev->u.cmd_rsp.rw);
-		break;
-	case TGT_UEVENT_TSK_MGMT_RSP:
-		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
-					       ev->u.tsk_mgmt_rsp.mid,
-					       ev->u.tsk_mgmt_rsp.result);
-		break;
-	default:
-		eprintk("unknown type %d\n", ev->type);
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static ssize_t tgt_write(struct file *file, const char __user * buffer,
-			 size_t count, loff_t * ppos)
-{
-	struct rbuf_hdr *hdr;
-	struct tgt_event *ev;
-	struct page *sp, *ep;
-
-retry:
-	hdr = head_rbuf_hdr(&rxbuf, rxbuf.idx);
-
-	sp = virt_to_page(hdr);
-	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-	for (;sp <= ep; sp++)
-		flush_dcache_page(sp);
-
-	if (!hdr->status)
-		return count;
-
-	rxbuf.idx++;
-	ev = (struct tgt_event *) hdr->data;
-	event_recv_msg(ev);
-	hdr->status = 0;
-
-	goto retry;
-}
-
-static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
-{
-	struct rbuf_hdr *hdr;
-	unsigned long flags;
-	unsigned int mask = 0;
-
-	poll_wait(file, &tgt_poll_wait, wait);
-
-	spin_lock_irqsave(&txbuf.lock, flags);
-
-	hdr = head_rbuf_hdr(&txbuf, txbuf.idx - 1);
-	if (hdr->status)
-		mask |= POLLIN | POLLRDNORM;
-
-	spin_unlock_irqrestore(&txbuf.lock, flags);
-
-	return mask;
-}
-
-static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-	unsigned long size, addr;
-	struct page *page;
-	int err, i;
-
-	if (vma->vm_pgoff) {
-		eprintk("bug\n");
-		return -EINVAL;
-	}
-
-	size = vma->vm_end - vma->vm_start;
-	if (size != TGT_RINGBUF_SIZE * 2) {
-		eprintk("%lu\n", size);
-		return -EINVAL;
-	}
-	addr = vma->vm_start;
-	page = virt_to_page(txbuf.buf);
-	for (i = 0; i < size >> PAGE_SHIFT; i++) {
-		err = vm_insert_page(vma, addr, page);
-		if (err) {
-			eprintk("%d %d %lu\n", err, i, addr);
-			return -EINVAL;
-		}
-		addr += PAGE_SIZE;
-		page++;
-	}
-
-	return 0;
-}
-
-static struct file_operations tgt_fops = {
-	.owner	= THIS_MODULE,
-	.poll	= tgt_poll,
-	.write	= tgt_write,
-	.mmap	= tgt_mmap,
-};
-
-void __exit scsi_tgt_if_exit(void)
-{
-	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-
-	unregister_chrdev(chrdev, "tgt");
-	free_pages((unsigned long) txbuf.buf, order);
-}
-
-int __init scsi_tgt_if_init(void)
-{
-	u32 bsize = TGT_RINGBUF_SIZE;
-	int order;
-	char *buf;
-
-	chrdev = register_chrdev(0, "tgt", &tgt_fops);
-	if (chrdev < 0)
-		return chrdev;
-
-	order = long_log2((bsize * 2) >> PAGE_SHIFT);
-	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-					order);
-	if (!buf)
-		goto free_dev;
-	rbuf_init(&txbuf, buf, bsize, sizeof(struct tgt_event));
-	rbuf_init(&rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
-
-	return 0;
-
-free_dev:
-	unregister_chrdev(chrdev, "tgt");
-
-	return -ENOMEM;
-}

Deleted: branches/user-iscsi/kernel/scsi_tgt_lib.c
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_lib.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_lib.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,695 +0,0 @@
-/*
- * SCSI target lib functions
- *
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <linux/blkdev.h>
-#include <linux/hash.h>
-#include <linux/module.h>
-#include <linux/pagemap.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_tgt.h>
-#include <../drivers/md/dm-bio-list.h>
-
-#include "scsi_tgt_priv.h"
-
-static struct workqueue_struct *scsi_tgtd;
-static kmem_cache_t *scsi_tgt_cmd_cache;
-
-/*
- * TODO: this struct will be killed when the block layer supports large bios
- * and James's work struct code is in
- */
-struct scsi_tgt_cmd {
-	/* TODO replace work with James b's code */
-	struct work_struct work;
-	/* TODO replace the lists with a large bio */
-	struct bio_list xfer_done_list;
-	struct bio_list xfer_list;
-
-	struct list_head hash_list;
-	struct request *rq;
-
-	void *buffer;
-	unsigned bufflen;
-};
-
-#define TGT_HASH_ORDER	4
-#define cmd_hashfn(cid)	hash_long((cid), TGT_HASH_ORDER)
-
-struct scsi_tgt_queuedata {
-	struct Scsi_Host *shost;
-	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
-	spinlock_t cmd_hash_lock;
-};
-
-/*
- * Function:	scsi_host_get_command()
- *
- * Purpose:	Allocate and setup a scsi command block and blk request
- *
- * Arguments:	shost	- scsi host
- *		data_dir - dma data dir
- *		gfp_mask- allocator flags
- *
- * Returns:	The allocated scsi command structure.
- *
- * This should be called by target LLDs to get a command.
- */
-struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-					enum dma_data_direction data_dir,
-					gfp_t gfp_mask)
-{
-	int write = (data_dir == DMA_TO_DEVICE);
-	struct request *rq;
-	struct scsi_cmnd *cmd;
-	struct scsi_tgt_cmd *tcmd;
-
-	/* Bail if we can't get a reference to the device */
-	if (!get_device(&shost->shost_gendev))
-		return NULL;
-
-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-	if (!tcmd)
-		goto put_dev;
-
-	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-	if (!rq)
-		goto free_tcmd;
-
-	cmd = __scsi_get_command(shost, gfp_mask);
-	if (!cmd)
-		goto release_rq;
-
-	memset(cmd, 0, sizeof(*cmd));
-	cmd->sc_data_direction = data_dir;
-	cmd->jiffies_at_alloc = jiffies;
-	cmd->request = rq;
-
-	rq->special = cmd;
-	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-	rq->end_io_data = tcmd;
-
-	bio_list_init(&tcmd->xfer_list);
-	bio_list_init(&tcmd->xfer_done_list);
-	tcmd->rq = rq;
-
-	return cmd;
-
-release_rq:
-	blk_put_request(rq);
-free_tcmd:
-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-put_dev:
-	put_device(&shost->shost_gendev);
-	return NULL;
-
-}
-EXPORT_SYMBOL_GPL(scsi_host_get_command);
-
-/*
- * Function:	scsi_host_put_command()
- *
- * Purpose:	Free a scsi command block
- *
- * Arguments:	shost	- scsi host
- * 		cmd	- command block to free
- *
- * Returns:	Nothing.
- *
- * Notes:	The command must not belong to any lists.
- */
-static void scsi_host_put_command(struct Scsi_Host *shost,
-				  struct scsi_cmnd *cmd)
-{
-	struct request_queue *q = shost->uspace_req_q;
-	struct request *rq = cmd->request;
-	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-	unsigned long flags;
-
-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-
-	spin_lock_irqsave(q->queue_lock, flags);
-	__blk_put_request(q, rq);
-	spin_unlock_irqrestore(q->queue_lock, flags);
-
-	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-}
-
-static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-{
-	struct bio *bio;
-
-	/* must call bio_endio in case bio was bounced */
-	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-		bio_endio(bio, bio->bi_size, 0);
-		bio_unmap_user(bio);
-	}
-
-	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-		bio_endio(bio, bio->bi_size, 0);
-		bio_unmap_user(bio);
-	}
-}
-
-static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-{
-	struct request_queue *q = cmd->request->q;
-	struct scsi_tgt_queuedata *qdata = q->queuedata;
-	unsigned long flags;
-	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-
-	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-	list_del(&tcmd->hash_list);
-	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-}
-
-static void scsi_tgt_cmd_destroy(void *data)
-{
-	struct scsi_cmnd *cmd = data;
-	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-
-	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
-		rq_data_dir(cmd->request));
-
-	cmd_hashlist_del(cmd);
-
-	/*
-	 * We must set rq->flags here because bio_map_user and
-	 * blk_rq_bio_prep ruined ti.
-	 */
-	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-		cmd->request->flags |= 1;
-	else
-		cmd->request->flags &= ~1UL;
-
-	scsi_unmap_user_pages(tcmd);
-	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-}
-
-static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
-{
-	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
-	unsigned long flags;
-	struct list_head *head;
-	static u32 tag = 0;
-
-	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-	rq->tag = tag++;
-	head = &qdata->cmd_hash[cmd_hashfn(rq->tag)];
-	list_add(&tcmd->hash_list, head);
-	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-}
-
-/*
- * scsi_tgt_alloc_queue - setup queue used for message passing
- * shost: scsi host
- *
- * This should be called by the LLD after host allocation.
- * And will be released when the host is released.
- */
-int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-{
-	struct scsi_tgt_queuedata *queuedata;
-	struct request_queue *q;
-	int err, i;
-
-	/*
-	 * Do we need to send a netlink event or should uspace
-	 * just respond to the hotplug event?
-	 */
-	q = __scsi_alloc_queue(shost, NULL);
-	if (!q)
-		return -ENOMEM;
-
-	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-	if (!queuedata) {
-		err = -ENOMEM;
-		goto cleanup_queue;
-	}
-	queuedata->shost = shost;
-	q->queuedata = queuedata;
-
-	/*
-	 * this is a silly hack. We should probably just queue as many
-	 * command as is recvd to userspace. uspace can then make
-	 * sure we do not overload the HBA
-	 */
-	q->nr_requests = shost->hostt->can_queue;
-	/*
-	 * We currently only support software LLDs so this does
-	 * not matter for now. Do we need this for the cards we support?
-	 * If so we should make it a host template value.
-	 */
-	blk_queue_dma_alignment(q, 0);
-	shost->uspace_req_q = q;
-
-	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
-		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
-	spin_lock_init(&queuedata->cmd_hash_lock);
-
-	return 0;
-
-cleanup_queue:
-	blk_cleanup_queue(q);
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-
-struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-	return queue->shost;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-
-/*
- * scsi_tgt_queue_command - queue command for userspace processing
- * @cmd:	scsi command
- * @scsilun:	scsi lun
- * @tag:	unique value to identify this command for tmf
- */
-int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-			   u64 tag)
-{
-	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-	int err;
-
-	init_scsi_tgt_cmd(cmd->request, tcmd);
-	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-	if (err)
-		cmd_hashlist_del(cmd);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-
-/*
- * This is run from a interrpt handler normally and the unmap
- * needs process context so we must queue
- */
-static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-
-	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-
-	scsi_tgt_uspace_send_status(cmd);
-	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-	queue_work(scsi_tgtd, &tcmd->work);
-}
-
-static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-{
-	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	int err;
-
-	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-
-	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-	switch (err) {
-	case SCSI_MLQUEUE_HOST_BUSY:
-	case SCSI_MLQUEUE_DEVICE_BUSY:
-		return -EAGAIN;
-	}
-
-	return 0;
-}
-
-static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-{
-	int err;
-
-	err = __scsi_tgt_transfer_response(cmd);
-	if (!err)
-		return;
-
-	cmd->result = DID_BUS_BUSY << 16;
-	err = scsi_tgt_uspace_send_status(cmd);
-	if (err <= 0)
-		/* the eh will have to pick this up */
-		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-}
-
-static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-{
-	struct request *rq = cmd->request;
-	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-	int count;
-
-	cmd->use_sg = rq->nr_phys_segments;
-	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-	if (!cmd->request_buffer)
-		return -ENOMEM;
-
-	cmd->request_bufflen = rq->data_len;
-
-	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
-		rq_data_dir(rq));
-	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-	if (likely(count <= cmd->use_sg)) {
-		cmd->use_sg = count;
-		return 0;
-	}
-
-	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
-	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-	return -EINVAL;
-}
-
-/* TODO: test this crap and replace bio_map_user with new interface maybe */
-static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-			       int rw)
-{
-	struct request_queue *q = cmd->request->q;
-	struct request *rq = cmd->request;
-	void *uaddr = tcmd->buffer;
-	unsigned int len = tcmd->bufflen;
-	struct bio *bio;
-	int err;
-
-	while (len > 0) {
-		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
-		if (IS_ERR(bio)) {
-			err = PTR_ERR(bio);
-			dprintk("fail to map %lx %u %d %x\n",
-				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-			goto unmap_bios;
-		}
-
-		uaddr += bio->bi_size;
-		len -= bio->bi_size;
-
-		/*
-		 * The first bio is added and merged. We could probably
-		 * try to add others using scsi_merge_bio() but for now
-		 * we keep it simple. The first bio should be pretty large
-		 * (either hitting the 1 MB bio pages limit or a queue limit)
-		 * already but for really large IO we may want to try and
-		 * merge these.
-		 */
-		if (!rq->bio) {
-			blk_rq_bio_prep(q, rq, bio);
-			rq->data_len = bio->bi_size;
-		} else
-			/* put list of bios to transfer in next go around */
-			bio_list_add(&tcmd->xfer_list, bio);
-	}
-
-	cmd->offset = 0;
-	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-	if (err)
-		goto unmap_bios;
-
-	return 0;
-
-unmap_bios:
-	if (rq->bio) {
-		bio_unmap_user(rq->bio);
-		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-			bio_unmap_user(bio);
-	}
-
-	return err;
-}
-
-static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-
-static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-{
-	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-	struct bio *bio;
-	int err;
-
-	/* should we free resources here on error ? */
-	if (cmd->result) {
-send_uspace_err:
-		err = scsi_tgt_uspace_send_status(cmd);
-		if (err <= 0)
-			/* the tgt uspace eh will have to pick this up */
-			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-		return;
-	}
-
-	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-		cmd, cmd->request_bufflen, tcmd->bufflen);
-
-	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-
-	tcmd->buffer += cmd->request_bufflen;
-	cmd->offset += cmd->request_bufflen;
-
-	if (!tcmd->xfer_list.head) {
-		scsi_tgt_transfer_response(cmd);
-		return;
-	}
-
-	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-		cmd, cmd->request_bufflen, tcmd->bufflen);
-
-	bio = bio_list_pop(&tcmd->xfer_list);
-	BUG_ON(!bio);
-
-	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-	cmd->request->data_len = bio->bi_size;
-	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-	if (err) {
-		cmd->result = DID_ERROR << 16;
-		goto send_uspace_err;
-	}
-
-	if (scsi_tgt_transfer_data(cmd)) {
-		cmd->result = DID_NO_CONNECT << 16;
-		goto send_uspace_err;
-	}
-}
-
-static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-{
-	int err;
-	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-
-	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-	switch (err) {
-		case SCSI_MLQUEUE_HOST_BUSY:
-		case SCSI_MLQUEUE_DEVICE_BUSY:
-			return -EAGAIN;
-	default:
-		return 0;
-	}
-}
-
-static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-				unsigned len)
-{
-	char __user *p = (char __user *) uaddr;
-
-	if (copy_from_user(cmd->sense_buffer, p,
-			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-		printk(KERN_ERR "Could not copy the sense buffer\n");
-		return -EIO;
-	}
-	return 0;
-}
-
-static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-{
-	int err;
-
-	err = host->hostt->eh_abort_handler(cmd);
-	if (err)
-		eprintk("fail to abort %p\n", cmd);
-
-	scsi_tgt_cmd_destroy(cmd);
-	return err;
-}
-
-static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
-{
-	struct scsi_tgt_queuedata *qdata = q->queuedata;
-	struct request *rq = NULL;
-	struct list_head *head;
-	struct scsi_tgt_cmd *tcmd;
-	unsigned long flags;
-
-	head = &qdata->cmd_hash[cmd_hashfn(cid)];
-	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-	list_for_each_entry(tcmd, head, hash_list) {
-		if (tcmd->rq->tag == cid) {
-			rq = tcmd->rq;
-			break;
-		}
-	}
-	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-
-	return rq;
-}
-
-int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-			 unsigned long uaddr, u8 rw)
-{
-	struct Scsi_Host *shost;
-	struct scsi_cmnd *cmd;
-	struct request *rq;
-	struct scsi_tgt_cmd *tcmd;
-	int err = 0;
-
-	dprintk("%d %u %d %u %lx %u\n", host_no, cid, result,
-		len, uaddr, rw);
-
-	/* TODO: replace with a O(1) alg */
-	shost = scsi_host_lookup(host_no);
-	if (IS_ERR(shost)) {
-		printk(KERN_ERR "Could not find host no %d\n", host_no);
-		return -EINVAL;
-	}
-
-	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, cid);
-	if (!rq) {
-		printk(KERN_ERR "Could not find cid %u\n", cid);
-		err = -EINVAL;
-		goto done;
-	}
-	cmd = rq->special;
-
-	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
-		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
-
-	if (result == TASK_ABORTED) {
-		scsi_tgt_abort_cmd(shost, cmd);
-		goto done;
-	}
-	/*
-	 * store the userspace values here, the working values are
-	 * in the request_* values
-	 */
-	tcmd = cmd->request->end_io_data;
-	tcmd->buffer = (void *)uaddr;
-	tcmd->bufflen = len;
-	cmd->result = result;
-
-	if (!tcmd->bufflen) {
-		err = __scsi_tgt_transfer_response(cmd);
-		goto done;
-	}
-
-	/*
-	 * TODO: Do we need to handle case where request does not
-	 * align with LLD.
-	 */
-	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-	if (err) {
-		eprintk("%p %d\n", cmd, err);
-		err = -EAGAIN;
-		goto done;
-	}
-
-	/* userspace failure */
-	if (cmd->result) {
-		if (status_byte(cmd->result) == CHECK_CONDITION)
-			scsi_tgt_copy_sense(cmd, uaddr, len);
-		err = __scsi_tgt_transfer_response(cmd);
-		goto done;
-	}
-	/* ask the target LLD to transfer the data to the buffer */
-	err = scsi_tgt_transfer_data(cmd);
-
-done:
-	scsi_host_put(shost);
-	return err;
-}
-
-int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-			      struct scsi_lun *scsilun, void *data)
-{
-	int err;
-
-	/* TODO: need to retry if this fails. */
-	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
-					    tag, scsilun, data);
-	if (err < 0)
-		eprintk("The task management request lost!\n");
-	return err;
-}
-EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-
-int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-{
-	struct Scsi_Host *shost;
-	int err;
-
-	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
-
-	shost = scsi_host_lookup(host_no);
-	if (IS_ERR(shost)) {
-		printk(KERN_ERR "Could not find host no %d\n", host_no);
-		return -EINVAL;
-	}
-	err = shost->hostt->tsk_mgmt_response(mid, result);
-	scsi_host_put(shost);
-
-	return err;
-}
-
-static int __init scsi_tgt_init(void)
-{
-	int err;
-
-	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-					       sizeof(struct scsi_tgt_cmd),
-					       0, 0, NULL, NULL);
-	if (!scsi_tgt_cmd_cache)
-		return -ENOMEM;
-
-	scsi_tgtd = create_workqueue("scsi_tgtd");
-	if (!scsi_tgtd) {
-		err = -ENOMEM;
-		goto free_kmemcache;
-	}
-
-	err = scsi_tgt_if_init();
-	if (err)
-		goto destroy_wq;
-
-	return 0;
-
-destroy_wq:
-	destroy_workqueue(scsi_tgtd);
-free_kmemcache:
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
-	return err;
-}
-
-static void __exit scsi_tgt_exit(void)
-{
-	destroy_workqueue(scsi_tgtd);
-	scsi_tgt_if_exit();
-	kmem_cache_destroy(scsi_tgt_cmd_cache);
-}
-
-module_init(scsi_tgt_init);
-module_exit(scsi_tgt_exit);
-
-MODULE_DESCRIPTION("SCSI target core");
-MODULE_LICENSE("GPL");

Deleted: branches/user-iscsi/kernel/scsi_tgt_priv.h
===================================================================
--- branches/user-iscsi/kernel/scsi_tgt_priv.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/kernel/scsi_tgt_priv.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,24 +0,0 @@
-struct scsi_cmnd;
-struct scsi_lun;
-struct Scsi_Host;
-struct task_struct;
-
-/* tmp - will replace with SCSI logging stuff */
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#define dprintk eprintk
-
-extern void scsi_tgt_if_exit(void);
-extern int scsi_tgt_if_init(void);
-
-extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-				    u64 tag);
-extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
-extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
-				unsigned long uaddr, u8 rw);
-extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-					 struct scsi_lun *scsilun, void *data);
-extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);

Deleted: branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,583 +0,0 @@
-Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
-From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
-Date: 1143376921 +0900
-
----
-
- drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
- drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
- drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
- drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
- 4 files changed, 142 insertions(+), 125 deletions(-)
-
-74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool->events[i].ext_list) {
- 			dma_free_coherent(hostdata->dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool->events[i].ext_list,
- 				  pool->events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd->sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd->data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_out_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd->data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_in_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd->data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd->data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd->buf_fmt = fmt << 4;
-+	else
-+		srp_cmd->buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i < num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i < num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd->data_out_format == SRP_NO_BUFFER) &&
--	    (cmd->data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd->buf_fmt >> 4;
-+	in_fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC && in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd->data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd->data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd->additional_data;
--		dma_unmap_single(dev, data->virtual_address, data->length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd->add_data;
-+		dma_unmap_single(dev, data->va, data->len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd->additional_data;
--		int num_mapped = indirect->head.length / 
--			sizeof(indirect->list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd->add_data;
-+		int num_mapped = indirect->table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped <= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &indirect->list[0]);
-+			unmap_sg_list(num_mapped, dev, &indirect->desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i < num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &sg[i];
--		descr->virtual_address = sg_dma_address(sg_entry);
--		descr->length = sg_dma_len(sg_entry);
--		descr->memory_handle = 0;
-+		descr->va = sg_dma_address(sg_entry);
-+		descr->len = sg_dma_len(sg_entry);
-+		descr->key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd->request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data->virtual_address = sg_dma_address(&sg[0]);
--		data->length = sg_dma_len(&sg[0]);
--		data->memory_handle = 0;
-+		data->va = sg_dma_address(&sg[0]);
-+		data->len = sg_dma_len(&sg[0]);
-+		data->key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect->head.virtual_address = 0;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	indirect->head.memory_handle = 0;
-+	indirect->table_desc.va = 0;
-+	indirect->table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect->table_desc.key = 0;
- 
- 	if (sg_mapped <= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &indirect->list[0]);
--		indirect->total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &indirect->desc_list[0]);
-+		indirect->len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct->ext_list) {
--		evt_struct->ext_list =(struct memory_descriptor*)
-+		evt_struct->ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&evt_struct->ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &evt_struct->ext_list_token, 0);
- 		if (!evt_struct->ext_list) {
--		    printk(KERN_ERR
--		   	"ibmvscsi: Can't allocate memory for indirect table\n");
-+			printk(KERN_ERR
-+			       "ibmvscsi: Can't allocate memory for indirect table\n");
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct->ext_list);	
- 
--	indirect->total_length = total_length;
--	indirect->head.virtual_address = evt_struct->ext_list_token;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	memcpy(indirect->list, evt_struct->ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect->len = total_length;
-+	indirect->table_desc.va = evt_struct->ext_list_token;
-+	indirect->table_desc.len = sg_mapped * sizeof(indirect->desc_list[0]);
-+	memcpy(indirect->desc_list, evt_struct->ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
- 
--	data->virtual_address =
-+	data->va =
- 		dma_map_single(dev, cmd->request_buffer,
- 			       cmd->request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data->virtual_address)) {
-+	if (dma_mapping_error(data->va)) {
- 		printk(KERN_ERR
- 		       "ibmvscsi: Unable to map request_buffer for command!\n");
- 		return 0;
- 	}
--	data->length = cmd->request_bufflen;
--	data->memory_handle = 0;
-+	data->len = cmd->request_bufflen;
-+	data->key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct->xfer_iu = evt_struct->iu;
--	evt_struct->xfer_iu->srp.generic.tag = (u64)evt_struct;
-+	evt_struct->xfer_iu->srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &evt_struct->xfer_iu->srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct->cmnd;
- 
--	if (unlikely(rsp->type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp->opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: bad SRP RSP type %d\n",
--			       rsp->type);
-+			       rsp->opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd->result = rsp->status;
- 		if (((cmnd->result >> 1) & 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd->sense_buffer,
--			       rsp->sense_and_response_data,
--			       rsp->sense_data_list_length);
-+			       rsp->data,
-+			       rsp->sense_data_len);
- 		unmap_cmd_data(&evt_struct->iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct->hostdata->dev);
- 
--		if (rsp->doover)
--			cmnd->resid = rsp->data_out_residual_count;
--		else if (rsp->diover)
--			cmnd->resid = rsp->data_in_residual_count;
-+		if (rsp->flags & SRP_RSP_FLAG_DOOVER)
-+			cmnd->resid = rsp->data_out_res_cnt;
-+		else if (rsp->flags & SRP_RSP_FLAG_DIOVER)
-+			cmnd->resid = rsp->data_in_res_cnt;
- 	}
- 
- 	if (evt_struct->cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&cmnd->device->host->hostdata;
- 	u16 lun = lun_from_dev(cmnd->device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&hostdata->pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &evt_struct->iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd->type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd->opcode = SRP_CMD;
- 	memcpy(srp_cmd->cdb, cmnd->cmnd, sizeof(cmnd->cmnd));
- 	srp_cmd->lun = ((u64) lun) << 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct->cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd->additional_data;
--	if (((srp_cmd->data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd->data_in_format == SRP_INDIRECT_BUFFER)) &&
--	    (indirect->head.virtual_address == 0)) {
--		indirect->head.virtual_address = evt_struct->crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd->add_data;
-+	out_fmt = srp_cmd->buf_fmt >> 4;
-+	in_fmt = srp_cmd->buf_fmt & ((1U << 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &&
-+	    indirect->table_desc.va == 0) {
-+		indirect->table_desc.va = evt_struct->crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
--	switch (evt_struct->xfer_iu->srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct->xfer_iu->srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO "ibmvscsi: SRP_LOGIN_REJ reason %u\n",
- 		       evt_struct->xfer_iu->srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       "ibmvscsi: Invalid login response typecode 0x%02x!\n",
--		       evt_struct->xfer_iu->srp.generic.type);
-+		       evt_struct->xfer_iu->srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&hostdata->request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
- 
--	if (evt_struct->xfer_iu->srp.login_rsp.request_limit_delta >
-+	if (evt_struct->xfer_iu->srp.login_rsp.req_lim_delta >
- 	    (max_requests - 2))
--		evt_struct->xfer_iu->srp.login_rsp.request_limit_delta =
-+		evt_struct->xfer_iu->srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&hostdata->request_limit,
--		   evt_struct->xfer_iu->srp.login_rsp.request_limit_delta);
-+		   evt_struct->xfer_iu->srp.login_rsp.req_lim_delta);
- 
- 	hostdata->host->can_queue =
--	    evt_struct->xfer_iu->srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct->xfer_iu->srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata->host->can_queue < 1) {
- 		printk(KERN_ERR "ibmvscsi: Invalid request_limit_delta\n");
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &evt_struct->iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login->type = SRP_LOGIN_REQ_TYPE;
--	login->max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login->required_buffer_formats = 0x0006;
-+	login->opcode = SRP_LOGIN_REQ;
-+	login->req_it_iu_len = sizeof(union srp_iu);
-+	login->req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt->managed_task_tag = (u64) found_evt;
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt->task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO "ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n",
--	       tsk_mgmt->lun, tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->lun, tsk_mgmt->task_tag);
- 
- 	evt->sync_srp = &srp_rsp;
- 	init_completion(&evt->comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: abort bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       "ibmvscsi: abort code %d for task tag 0x%lx\n",
-+			       "ibmvscsi: abort code %d for task tag 0x%lx\n",
- 			       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
- 		printk(KERN_INFO
- 		       "ibmvscsi: aborted task tag 0x%lx completed\n",
--		       tsk_mgmt->managed_task_tag);
-+		       tsk_mgmt->task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       "ibmvscsi: successfully aborted task tag 0x%lx\n",
--	       tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->task_tag);
- 
- 	cmd->result = (DID_ABORT << 16);
- 	list_del(&found_evt->list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO "ibmvscsi: resetting device. lun 0x%lx\n",
- 	       tsk_mgmt->lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset code %d for task tag 0x%lx\n",
--		       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       rsp_rc, tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq->format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct->xfer_iu->srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct->xfer_iu->srp.rsp.req_lim_delta,
- 			   &hostdata->request_limit);
- 
- 	if (evt_struct->done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include <linux/dma-mapping.h>
- #include <linux/interrupt.h>
- #include "ibmvscsi.h"
--#include "srp.h"
- 
- static char partition_name[97] = "UNKNOWN";
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include "srp.h"
-+#include <scsi/srp.h>
-+
-+#define SRP_VERSION "16.a"
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,246 +0,0 @@
-Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
-From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
-Date: 1143377151 +0900
-
----
-
- drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
- 1 files changed, 0 insertions(+), 227 deletions(-)
- delete mode 100644 drivers/scsi/ibmvscsi/srp.h
-
-acbd74e89dc7bcf4e2596800e46a19378db44641
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION "16.a"
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,375 +0,0 @@
-Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
-
-This patch moves scsi_host_get_command and scsi_host_put_command to
-scsi_tgt_lib.c from scsi.c
-
-A target driver allocates scsi_cmnd structure via
-scsi_host_get_command, then pass it to tgt core via
-scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
-needs to allocate scsi_tgt_cmd structure (for tgt specific data).
-Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
-target drivers.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi.c         |  102 ++++------------------------------------
- drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
- include/scsi/scsi_cmnd.h    |    6 +-
- include/scsi/scsi_tgt.h     |    4 ++
- 4 files changed, 112 insertions(+), 109 deletions(-)
-
-b8f2574dbd844ac43602d9fa74e6196027528c63
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 9c22465..1d2fbe0 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
--
--/*
-- * Function:	scsi_host_get_command()
-- *
-- * Purpose:	Allocate and setup a scsi command block and blk request
-- *
-- * Arguments:	shost	- scsi host
-- *		data_dir - dma data dir
-- *		gfp_mask- allocator flags
-- *
-- * Returns:	The allocated scsi command structure.
-- *
-- * This should be called by target LLDs to get a command.
-- */
--struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
--					enum dma_data_direction data_dir,
--					gfp_t gfp_mask)
--{
--	int write = (data_dir == DMA_TO_DEVICE);
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--
--	/* Bail if we can't get a reference to the device */
--	if (!get_device(&shost->shost_gendev))
--		return NULL;
--
--	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
--	if (!rq)
--		goto put_dev;
--
--	cmd = __scsi_get_command(shost, gfp_mask);
--	if (!cmd)
--		goto release_rq;
--
--	memset(cmd, 0, sizeof(*cmd));
--	cmd->sc_data_direction = data_dir;
--	cmd->jiffies_at_alloc = jiffies;
--	cmd->request = rq;
--
--	rq->special = cmd;
--	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
--
--	return cmd;
--
--release_rq:
--	blk_put_request(rq);
--put_dev:
--	put_device(&shost->shost_gendev);
--	return NULL;
--
--}
--EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
--/*
-- * Function:	scsi_host_put_command()
-- *
-- * Purpose:	Free a scsi command block
-- *
-- * Arguments:	shost	- scsi host
-- * 		cmd	- command block to free
-- *
-- * Returns:	Nothing.
-- *
-- * Notes:	The command must not belong to any lists.
-- */
--void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
- {
--	struct request_queue *q = shost->uspace_req_q;
--	struct request *rq = cmd->request;
- 	unsigned long flags;
- 
- 	/* changing locks here, don't need to restore the irq state */
-@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
- 		list_add(&cmd->list, &shost->free_list);
- 		cmd = NULL;
- 	}
--	spin_unlock(&shost->free_list_lock);
--
--	spin_lock(q->queue_lock);
--	__blk_put_request(q, rq);
--	spin_unlock_irqrestore(q->queue_lock, flags);
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
- 
- 	if (likely(cmd != NULL))
- 		kmem_cache_free(shost->cmd_pool->slab, cmd);
- 
--	put_device(&shost->shost_gendev);
-+	put_device(dev);
- }
--EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+EXPORT_SYMBOL(__scsi_put_command);
- 
- /*
-  * Function:	scsi_put_command()
-@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
--
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index aea3e4d..e82340c 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
- 	struct list_head cmd_req;
- };
- 
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq->end_io_data = tcmd;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+static void scsi_host_put_command(struct Scsi_Host *shost,
-+				  struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q->queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-+}
-+
- static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
- {
- 	struct bio *bio;
-@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
- 		cmd->request->flags &= ~1UL;
- 
- 	scsi_unmap_user_pages(tcmd);
--	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
- }
- 
-@@ -177,13 +265,13 @@ out:
- 		goto retry;
- }
- 
--/**
-+/*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-  *
-  * This should be called by the LLD after host allocation.
-  * And will be released when the host is released.
-- **/
-+ */
- int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
- {
- 	struct scsi_tgt_queuedata *queuedata;
-@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
- 
--/**
-+/*
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-  * @noblock:	set to nonzero if the command should be queued
-- **/
-+ */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
- 	struct request_queue *q = cmd->request->q;
- 	struct scsi_tgt_queuedata *qdata = q->queuedata;
- 	unsigned long flags;
--	struct scsi_tgt_cmd *tcmd;
--
--	/*
--	 * It would be better to allocate scsi_tgt_cmd structure in
--	 * scsi_host_get_command and not to fail due to OOM.
--	 */
--	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
--	if (!tcmd)
--		return -ENOMEM;
--	cmd->request->end_io_data = tcmd;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
- 
- 	bio_list_init(&tcmd->xfer_list);
- 	bio_list_init(&tcmd->xfer_done_list);
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 51156c7..c822bc2 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -150,11 +150,11 @@ struct scsi_cmnd {
- #define SCSI_STATE_MLQUEUE         0x100b
- 
- 
--extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
--					       enum dma_data_direction, gfp_t);
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
--extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-index 2d65be7..61e8ee9 100644
---- a/include/scsi/scsi_tgt.h
-+++ b/include/scsi/scsi_tgt.h
-@@ -2,6 +2,8 @@
-  * SCSI target definitions
-  */
- 
-+#include <linux/dma-mapping.h>
-+
- struct Scsi_Host;
- struct scsi_cmnd;
- struct scsi_lun;
-@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
- extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
- extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
- 				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,554 +0,0 @@
-Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
-
-The user-space damoen and tgt kernel module need to exhange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch replaces netlink shared memory between kernel and user
-spaces. The user-space damoen and tgt kernel module creates shared
-memory via mmap and use it like ring buffer. poll (kernel to user) and
-write (user to kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
- drivers/scsi/scsi_tgt_lib.c  |   10 +
- drivers/scsi/scsi_tgt_priv.h |    6 -
- include/linux/netlink.h      |    1 
- include/scsi/scsi_tgt_if.h   |   19 +--
- 5 files changed, 216 insertions(+), 131 deletions(-)
-
-cd29acfca7cdeb8c351db14af357207e9dcb17f3
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-index 37e0feb..c4c5bdb 100644
---- a/drivers/scsi/scsi_tgt_if.c
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -21,7 +21,6 @@
-  */
- #include <linux/blkdev.h>
- #include <linux/file.h>
--#include <linux/netlink.h>
- #include <net/tcp.h>
- #include <scsi/scsi.h>
- #include <scsi/scsi_cmnd.h>
-@@ -32,87 +31,129 @@
- 
- #include "scsi_tgt_priv.h"
- 
--static int tgtd_pid;
--static struct sock *nl_sk;
-+struct rbuf {
-+	u32 idx;
-+	u32 nr_entry;
-+	int entry_size;
-+	char *buf;
-+	int buf_size;
-+	spinlock_t lock;
-+};
-+
-+static int chrdev;
-+static struct rbuf txbuf, rxbuf;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
- 
--static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
--			  pid_t pid)
-+static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
-+{
-+	u32 offset = (idx & (rbuf->nr_entry - 1)) * rbuf->entry_size;
-+	return (struct rbuf_hdr *) (rbuf->buf + offset);
-+}
-+
-+static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
-+{
-+	int i;
-+
-+	esize += sizeof(struct rbuf_hdr);
-+	rbuf->idx = 0;
-+	rbuf->entry_size = esize;
-+	rbuf->buf = buf;
-+	spin_lock_init(&rbuf->lock);
-+
-+	bsize /= esize;
-+	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
-+		;
-+	rbuf->nr_entry = 1 << i;
-+}
-+
-+static int send_event_rsp(u32 type, struct tgt_event *p)
- {
- 	struct tgt_event *ev;
--	struct nlmsghdr *nlh;
--	struct sk_buff *skb;
--	uint32_t len;
--
--	len = NLMSG_SPACE(sizeof(*ev));
--	skb = alloc_skb(len, flags);
--	if (!skb)
--		return -ENOMEM;
-+	struct rbuf_hdr *hdr;
-+	struct page *sp, *ep;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&txbuf.lock, flags);
-+
-+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx);
-+	if (hdr->status)
-+		err = 1;
-+	else
-+		txbuf.idx++;
- 
--	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
-+	spin_unlock_irqrestore(&txbuf.lock, flags);
- 
--	ev = NLMSG_DATA(nlh);
-+	if (err)
-+		return err;
-+
-+	ev = (struct tgt_event *) hdr->data;
- 	memcpy(ev, p, sizeof(*ev));
-+	ev->type = type;
-+	hdr->status = 1;
-+	mb();
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-+	for (;sp <= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	wake_up_interruptible(&tgt_poll_wait);
- 
--	return netlink_unicast(nl_sk, skb, pid, 0);
-+	return 0;
- }
- 
--int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
--			 gfp_t flags)
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
--	struct sk_buff *skb;
--	struct nlmsghdr *nlh;
--	struct tgt_event *ev;
--	int err, len;
-+	struct tgt_event ev;
-+	int err;
- 
--	len = NLMSG_SPACE(sizeof(*ev));
--	/*
--	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
--	 */
--	skb = alloc_skb(NLMSG_SPACE(len), flags);
--	if (!skb)
--		return -ENOMEM;
--
--	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
--			  len - sizeof(*nlh), 0);
--
--	ev = NLMSG_DATA(nlh);
--	ev->k.cmd_req.host_no = shost->host_no;
--	ev->k.cmd_req.cid = cmd->request->tag;
--	ev->k.cmd_req.data_len = cmd->request_bufflen;
--	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
--	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
--	ev->k.cmd_req.attribute = cmd->tag;
--	ev->k.cmd_req.tag = tag;
--
--	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev->k.cmd_req.cid,
--		ev->k.cmd_req.data_len, cmd->tag,
--		(unsigned long long) ev->k.cmd_req.tag);
--
--	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
--	if (err < 0)
--		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
--		       err);
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost->host_no;
-+	ev.k.cmd_req.cid = cmd->request->tag;
-+	ev.k.cmd_req.data_len = cmd->request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd->tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
- 	return err;
- }
- 
--int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&ev, 0, sizeof(ev));
- 	ev.k.cmd_done.host_no = shost->host_no;
- 	ev.k.cmd_done.cid = cmd->request->tag;
- 	ev.k.cmd_done.result = cmd->result;
- 
--	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
-+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+	return err;
- }
- 
- int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
- 				  struct scsi_lun *scsilun, void *data)
- {
- 	struct tgt_event ev;
-+	int err;
- 
- 	memset(&ev, 0, sizeof(ev));
- 	ev.k.tsk_mgmt_req.host_no = host_no;
-@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
- 	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
- 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
- 
--	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev, GFP_KERNEL, tgtd_pid);
-+	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+	return err;
- }
- 
--static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
-+static int event_recv_msg(struct tgt_event *ev)
- {
--	struct tgt_event *ev = NLMSG_DATA(nlh);
- 	int err = 0;
- 
--	dprintk("%d %d %d\n", nlh->nlmsg_type,
--		nlh->nlmsg_pid, current->pid);
--
--	switch (nlh->nlmsg_type) {
--	case TGT_UEVENT_REQ:
--		tgtd_pid = NETLINK_CREDS(skb)->pid;
--		break;
-+	switch (ev->type) {
- 	case TGT_UEVENT_CMD_RSP:
--		/* TODO: handle multiple cmds in one event */
- 		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
- 					   ev->u.cmd_rsp.cid,
- 					   ev->u.cmd_rsp.result,
-@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
- 					       ev->u.tsk_mgmt_rsp.result);
- 		break;
- 	default:
--		eprintk("unknown type %d\n", nlh->nlmsg_type);
-+		eprintk("unknown type %d\n", ev->type);
- 		err = -EINVAL;
- 	}
- 
- 	return err;
- }
- 
--static int event_recv_skb(struct sk_buff *skb)
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
- {
--	int err;
--	uint32_t rlen;
--	struct nlmsghdr	*nlh;
--	struct tgt_event ev;
-+	struct rbuf_hdr *hdr;
-+	struct tgt_event *ev;
-+	struct page *sp, *ep;
- 
--	while (skb->len >= NLMSG_SPACE(0)) {
--		nlh = (struct nlmsghdr *) skb->data;
--		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
--			return 0;
--		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
--		if (rlen > skb->len)
--			rlen = skb->len;
--		err = event_recv_msg(skb, nlh);
--
--		dprintk("%d %d\n", nlh->nlmsg_type, err);
--		/*
--		 * TODO for passthru commands the lower level should
--		 * probably handle the result or we should modify this
--		 */
--		switch (nlh->nlmsg_type) {
--		case TGT_UEVENT_CMD_RSP:
--		case TGT_UEVENT_TSK_MGMT_RSP:
--			break;
--		default:
--			memset(&ev, 0, sizeof(ev));
--			ev.k.event_rsp.err = err;
--			send_event_rsp(TGT_KEVENT_RSP, &ev,
--				       GFP_KERNEL | __GFP_NOFAIL,
--					nlh->nlmsg_pid);
--		}
--		skb_pull(skb, rlen);
--	}
--	return 0;
-+retry:
-+	hdr = head_rbuf_hdr(&rxbuf, rxbuf.idx);
-+
-+	sp = virt_to_page(hdr);
-+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
-+	for (;sp <= ep; sp++)
-+		flush_dcache_page(sp);
-+
-+	if (!hdr->status)
-+		return count;
-+
-+	rxbuf.idx++;
-+	ev = (struct tgt_event *) hdr->data;
-+	event_recv_msg(ev);
-+	hdr->status = 0;
-+
-+	goto retry;
- }
- 
--static void event_recv(struct sock *sk, int length)
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
- {
--	struct sk_buff *skb;
-+	struct rbuf_hdr *hdr;
-+	unsigned long flags;
-+	unsigned int mask = 0;
- 
--	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
--		if (NETLINK_CREDS(skb)->uid) {
--			skb_pull(skb, skb->len);
--			kfree_skb(skb);
--			continue;
--		}
-+	poll_wait(file, &tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&txbuf.lock, flags);
- 
--		if (event_recv_skb(skb) && skb->len)
--			skb_queue_head(&sk->sk_receive_queue, skb);
--		else
--			kfree_skb(skb);
-+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx - 1);
-+	if (hdr->status)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&txbuf.lock, flags);
-+
-+	return mask;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long size, addr;
-+	struct page *page;
-+	int err, i;
-+
-+	if (vma->vm_pgoff) {
-+		eprintk("bug\n");
-+		return -EINVAL;
-+	}
-+
-+	size = vma->vm_end - vma->vm_start;
-+	if (size != TGT_RINGBUF_SIZE * 2) {
-+		eprintk("%lu\n", size);
-+		return -EINVAL;
-+	}
-+	addr = vma->vm_start;
-+	page = virt_to_page(txbuf.buf);
-+	for (i = 0; i < size >> PAGE_SHIFT; i++) {
-+		err = vm_insert_page(vma, addr, page);
-+		if (err) {
-+			eprintk("%d %d %lu\n", err, i, addr);
-+			return -EINVAL;
-+		}
-+		addr += PAGE_SIZE;
-+		page++;
- 	}
-+
-+	return 0;
- }
- 
-+static struct file_operations tgt_fops = {
-+	.owner	= THIS_MODULE,
-+	.poll	= tgt_poll,
-+	.write	= tgt_write,
-+	.mmap	= tgt_mmap,
-+};
-+
- void __exit scsi_tgt_if_exit(void)
- {
--	sock_release(nl_sk->sk_socket);
-+	int order = long_log2(TGT_RINGBUF_SIZE * 2);
-+
-+	unregister_chrdev(chrdev, "tgt");
-+	free_pages((unsigned long) txbuf.buf, order);
- }
- 
- int __init scsi_tgt_if_init(void)
- {
--	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
--				    THIS_MODULE);
--	if (!nl_sk)
--		return -ENOMEM;
-+	u32 bsize = TGT_RINGBUF_SIZE;
-+	int order;
-+	char *buf;
-+
-+	chrdev = register_chrdev(0, "tgt", &tgt_fops);
-+	if (chrdev < 0)
-+		return chrdev;
-+
-+	order = long_log2((bsize * 2) >> PAGE_SHIFT);
-+	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
-+					order);
-+	if (!buf)
-+		goto free_dev;
-+	rbuf_init(&txbuf, buf, bsize, sizeof(struct tgt_event));
-+	rbuf_init(&rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
- 
- 	return 0;
-+
-+free_dev:
-+	unregister_chrdev(chrdev, "tgt");
-+
-+	return -ENOMEM;
- }
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index e82340c..7ebfbc0 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -246,7 +246,7 @@ retry:
- 	tcmd = rq->end_io_data;
- 	init_scsi_tgt_cmd(rq, tcmd);
- 	cmd = rq->special;
--	err = scsi_tgt_uspace_send(cmd, tcmd->lun, tcmd->tag, GFP_ATOMIC);
-+	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
- 	if (err < 0) {
- 		eprintk("failed to send: %p %d\n", cmd, err);
- 
-@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
- 
- 	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
- 
--	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-+	scsi_tgt_uspace_send_status(cmd);
- 	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
- 	queue_work(scsi_tgtd, &tcmd->work);
- }
-@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
- 		return;
- 
- 	cmd->result = DID_BUS_BUSY << 16;
--	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+	err = scsi_tgt_uspace_send_status(cmd);
-+	if (err <= 0)
- 		/* the eh will have to pick this up */
- 		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
- }
-@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
- 	/* should we free resources here on error ? */
- 	if (cmd->result) {
- send_uspace_err:
--		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
-+		err = scsi_tgt_uspace_send_status(cmd);
-+		if (err <= 0)
- 			/* the tgt uspace eh will have to pick this up */
- 			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
- 		return;
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-index 77a1d06..bd16a2c 100644
---- a/drivers/scsi/scsi_tgt_priv.h
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -14,9 +14,9 @@ do {								\
- extern void scsi_tgt_if_exit(void);
- extern int scsi_tgt_if_init(void);
- 
--extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
--				u64 tag, gfp_t flags);
--extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
- extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
- 				unsigned long uaddr, u8 rw);
- extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 9422ae5..c256ebe 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,7 +21,6 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
--#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-index 63b2e3a..74392a9 100644
---- a/include/scsi/scsi_tgt_if.h
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -24,25 +24,20 @@
- 
- enum tgt_event_type {
- 	/* user -> kernel */
--	TGT_UEVENT_REQ,
- 	TGT_UEVENT_CMD_RSP,
- 	TGT_UEVENT_TSK_MGMT_RSP,
- 
- 	/* kernel -> user */
--	TGT_KEVENT_RSP,
- 	TGT_KEVENT_CMD_REQ,
- 	TGT_KEVENT_CMD_DONE,
- 	TGT_KEVENT_TSK_MGMT_REQ,
- };
- 
- struct tgt_event {
-+	uint32_t type;
- 	/* user-> kernel */
- 	union {
- 		struct {
--			int type;
--			int host_no;
--		} event_req;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t len;
-@@ -60,9 +55,6 @@ struct tgt_event {
- 	/* kernel -> user */
- 	union {
- 		struct {
--			int err;
--		} event_rsp;
--		struct {
- 			int host_no;
- 			uint32_t cid;
- 			uint32_t data_len;
-@@ -86,4 +78,13 @@ struct tgt_event {
- 	} k;
- 
- } __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RINGBUF_SIZE (1UL << 16)
-+
-+struct rbuf_hdr {
-+	uint32_t status;
-+	uint32_t len;
-+	uint64_t data[0];
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
- #endif
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/0005-scsi-target-kill-target-command-list.txt	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,197 +0,0 @@
-Subject: [PATCH] scsi target: kill target command list
-
-scsi_tgt_queue_command just adds a command to the list and then kernel
-thread sends it to user space because scsi_tgt_queue_command cannot
-use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
-
-Now we don't use netlink any more. So we can kill the list and
-scsi_tgt_queue_command just sends a command to user space.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
- 1 files changed, 24 insertions(+), 82 deletions(-)
-
-0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index 7ebfbc0..5c66f10 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
- 	/* TODO replace the lists with a large bio */
- 	struct bio_list xfer_done_list;
- 	struct bio_list xfer_list;
--	struct scsi_lun *lun;
- 
- 	struct list_head hash_list;
- 	struct request *rq;
--	u64 tag;
- 
- 	void *buffer;
- 	unsigned bufflen;
-@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
- 	struct Scsi_Host *shost;
- 	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
- 	spinlock_t cmd_hash_lock;
--
--	struct work_struct uspace_send_work;
--
--	spinlock_t cmd_req_lock;
--	struct mutex cmd_req_mutex;
--	struct list_head cmd_req;
- };
- 
- /*
-@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
- 	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
- 	rq->end_io_data = tcmd;
- 
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+	tcmd->rq = rq;
-+
- 	return cmd;
- 
- release_rq:
-@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
- 	}
- }
- 
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_del(&tcmd->hash_list);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
- static void scsi_tgt_cmd_destroy(void *data)
- {
- 	struct scsi_cmnd *cmd = data;
- 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
--	struct scsi_tgt_queuedata *qdata = cmd->request->q->queuedata;
--	unsigned long flags;
- 
- 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
- 		rq_data_dir(cmd->request));
- 
--	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
--	list_del(&tcmd->hash_list);
--	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+	cmd_hashlist_del(cmd);
- 
- 	/*
- 	 * We must set rq->flags here because bio_map_user and
-@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
- 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
- }
- 
--static void scsi_tgt_uspace_send_fn(void *data)
--{
--	struct request_queue *q = data;
--	struct scsi_tgt_queuedata *qdata = q->queuedata;
--	struct request *rq;
--	struct scsi_cmnd *cmd;
--	struct scsi_tgt_cmd *tcmd;
--	unsigned long flags;
--	int err;
--
--retry:
--	err = 0;
--	if (list_empty(&qdata->cmd_req))
--		return;
--
--	mutex_lock(&qdata->cmd_req_mutex);
--
--	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--	if (list_empty(&qdata->cmd_req)) {
--		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--		mutex_unlock(&qdata->cmd_req_mutex);
--		goto out;
--	}
--	rq = list_entry_rq(qdata->cmd_req.next);
--	list_del_init(&rq->queuelist);
--	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--
--	tcmd = rq->end_io_data;
--	init_scsi_tgt_cmd(rq, tcmd);
--	cmd = rq->special;
--	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
--	if (err < 0) {
--		eprintk("failed to send: %p %d\n", cmd, err);
--
--		spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--		list_add(&rq->queuelist, &qdata->cmd_req);
--		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
--	}
--
--	mutex_unlock(&qdata->cmd_req_mutex);
--out:
--	/* TODO: proper error handling */
--	if (err < 0)
--		queue_delayed_work(scsi_tgtd, &qdata->uspace_send_work,
--				   HZ / 10);
--	else
--		goto retry;
--}
--
- /*
-  * scsi_tgt_alloc_queue - setup queue used for message passing
-  * shost: scsi host
-@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
- 		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
- 	spin_lock_init(&queuedata->cmd_hash_lock);
- 
--	INIT_LIST_HEAD(&queuedata->cmd_req);
--	spin_lock_init(&queuedata->cmd_req_lock);
--	INIT_WORK(&queuedata->uspace_send_work, scsi_tgt_uspace_send_fn, q);
--	mutex_init(&queuedata->cmd_req_mutex);
--
- 	return 0;
- 
- cleanup_queue:
-@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-  * scsi_tgt_queue_command - queue command for userspace processing
-  * @cmd:	scsi command
-  * @scsilun:	scsi lun
-- * @noblock:	set to nonzero if the command should be queued
-+ * @tag:	unique value to identify this command for tmf
-  */
- int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
- 			   u64 tag)
- {
--	struct request_queue *q = cmd->request->q;
--	struct scsi_tgt_queuedata *qdata = q->queuedata;
--	unsigned long flags;
- 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
- 
--	bio_list_init(&tcmd->xfer_list);
--	bio_list_init(&tcmd->xfer_done_list);
--	tcmd->lun = scsilun;
--	tcmd->tag = tag;
--	tcmd->rq = cmd->request;
--
--	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
--	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
--	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-+	init_scsi_tgt_cmd(cmd->request, tcmd);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
- 
--	queue_work(scsi_tgtd, &qdata->uspace_send_work);
--	return 0;
-+	return err;
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
- 
--- 
-1.1.3

Deleted: branches/user-iscsi/patchset/README
===================================================================
--- branches/user-iscsi/patchset/README	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/patchset/README	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,7 +0,0 @@
-This patchset for scsi-target git tree:
-
-http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary
-
-
-Get the tree and apply all the patches. Sorry for the
-inconvenience. We will create our own git tree shortly.

Modified: branches/user-iscsi/usr/Makefile
===================================================================
--- branches/user-iscsi/usr/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,17 +1,10 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -D_LARGEFILE64_SOURCE -I./include -I.
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
+TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o
 
-ifneq ($(IBMVIO),)
-CFLAGS += -DIBMVIO
-TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
-endif
-
-ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
+TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o)
 LIBS = -lcrypto
-endif
 
 all: $(PROGRAMS)
 

Deleted: branches/user-iscsi/usr/iscsi/Makefile
===================================================================
--- branches/user-iscsi/usr/iscsi/Makefile	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/Makefile	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,9 +0,0 @@
-CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../istgt/include -I../../include -I../../usr
-LIBS = -lcrypto
-DAEMON = iscsi.o
-
-$(DAEMON): istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
-	$(CC) -o $@ $^ $(LIBS)
-
-clean:
-	rm -f *.o istgtd $(SHAREDLIB)

Modified: branches/user-iscsi/usr/iscsi/conn.c
===================================================================
--- branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -13,6 +13,7 @@
 #include <sys/stat.h>
 
 #include "iscsid.h"
+#include "tgtd.h"
 
 #define ISCSI_CONN_NEW		1
 #define ISCSI_CONN_EXIT		5
@@ -33,13 +34,26 @@
 {
 	struct connection *conn;
 
-	if (!(conn = malloc(sizeof(*conn))))
+	conn = zalloc(sizeof(*conn));
+	if (!conn)
 		return NULL;
 
-	memset(conn, 0, sizeof(*conn));
+	conn->req_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->req_buffer) {
+		free(conn);
+		return NULL;
+	}
+	conn->rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->rsp_buffer) {
+		free(conn->req_buffer);
+		free(conn);
+		return NULL;
+	}
+
 	conn->state = STATE_FREE;
 	param_set_defaults(conn->session_param, session_keys);
 
+	INIT_LIST_HEAD(&conn->send);
 	INIT_LIST_HEAD(&conn->clist);
 
 	return conn;
@@ -48,6 +62,8 @@
 void conn_free(struct connection *conn)
 {
 	list_del(&conn->clist);
+	free(conn->req_buffer);
+	free(conn->rsp_buffer);
 	free(conn->initiator);
 	free(conn);
 }
@@ -64,9 +80,8 @@
 	return NULL;
 }
 
-void conn_take_fd(struct connection *conn, int fd)
+int conn_take_fd(struct connection *conn, int fd)
 {
-	int i, err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
 	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
@@ -74,51 +89,25 @@
 
 	conn->session->conn_cnt++;
 
-	err = ki->create_conn(thandle, conn->session->ksid, conn->kcid,
-			      &conn->kcid);
-	if (err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
+	dprintf("conn_take_fd: %d %u %u %u\n", conn->session->target->tid,
+		conn->cid, conn->stat_sn, conn->exp_stat_sn);
 
-	for (i = 0; i < ISCSI_PARAM_ERL + 1; i++) {
-		/* FIXME */
-		if (i == ISCSI_PARAM_DATADGST_EN || i == ISCSI_PARAM_HDRDGST_EN)
-			continue;
-		if (ki->set_param(thandle, conn->session->ksid, conn->kcid, i,
-				  &conn->session_param[i].val,
-				  sizeof(uint32_t), &err) || err) {
-			break;
-		}
-	}
+	/* FIXME */
+	tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
 
-	if (ki->bind_conn(thandle, conn->session->ksid, conn->kcid, fd, 1, &err) || err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
-
-	if (ki->start_conn(thandle, conn->session->ksid, conn->kcid, &err) || err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
-
-out:
-	return;
+	return 0;
 }
 
 void conn_read_pdu(struct connection *conn)
 {
-	conn->iostate = IOSTATE_READ_BHS;
+	conn->rx_iostate = IOSTATE_READ_BHS;
 	conn->buffer = (void *)&conn->req.bhs;
 	conn->rwsize = BHS_SIZE;
 }
 
 void conn_write_pdu(struct connection *conn)
 {
-	conn->iostate = IOSTATE_WRITE_BHS;
+	conn->tx_iostate = IOSTATE_WRITE_BHS;
 	memset(&conn->rsp, 0, sizeof(conn->rsp));
 	conn->buffer = (void *)&conn->rsp.bhs;
 	conn->rwsize = BHS_SIZE;
@@ -126,17 +115,17 @@
 
 void conn_free_pdu(struct connection *conn)
 {
-	conn->iostate = IOSTATE_FREE;
-	if (conn->req.ahs) {
-		free(conn->req.ahs);
-		conn->req.ahs = NULL;
-	}
-	if (conn->rsp.ahs) {
-		free(conn->rsp.ahs);
-		conn->rsp.ahs = NULL;
-	}
-	if (conn->rsp.data) {
-		free(conn->rsp.data);
-		conn->rsp.data = NULL;
-	}
+	conn->rx_iostate = conn->tx_iostate = IOSTATE_FREE;
+/* 	if (conn->req.ahs) { */
+/* 		free(conn->req.ahs); */
+/* 		conn->req.ahs = NULL; */
+/* 	} */
+/* 	if (conn->rsp.ahs) { */
+/* 		free(conn->rsp.ahs); */
+/* 		conn->rsp.ahs = NULL; */
+/* 	} */
+/* 	if (conn->rsp.data) { */
+/* 		free(conn->rsp.data); */
+/* 		conn->rsp.data = NULL; */
+/* 	} */
 }

Modified: branches/user-iscsi/usr/iscsi/iscsi.h
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsi.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsi.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -3,7 +3,6 @@
 extern int iscsi_event_handle(struct pollfd *);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
-extern int iscsi_target_bind(int);
 
 struct tgt_driver iscsi = {
 	.name		= "iscsi",
@@ -12,5 +11,5 @@
 	.event_handle	= iscsi_event_handle,
 	.target_create	= iscsi_target_create,
 	.target_destroy	= iscsi_target_destroy,
-	.target_bind	= iscsi_target_bind,
+/* 	.target_bind	= iscsi_target_bind, */
 };

Modified: branches/user-iscsi/usr/iscsi/iscsid.c
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -13,8 +13,10 @@
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <netdb.h>
+#include <scsi/scsi.h>
 
 #include "iscsid.h"
+#include "tgtd.h"
 
 static struct iscsi_key login_keys[] = {
 	{"InitiatorName",},
@@ -88,11 +90,9 @@
 	int len = keylen + valuelen + 2;
 	char *buffer;
 
-	if (!conn->rsp.datasize) {
-		if (!conn->rsp_buffer)
-			conn->rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->rsp.datasize)
 		conn->rsp.data = conn->rsp_buffer;
-	}
+
 	if (conn->rwsize + len > INCOMING_BUFSIZE) {
 		log_warning("Dropping key (%s=%s)", key, value);
 		return;
@@ -676,7 +676,7 @@
 
 int cmnd_execute(struct connection *conn)
 {
-	int res = 1;
+	int res = 0;
 
 	switch (conn->req.bhs.opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_LOGIN:
@@ -702,7 +702,7 @@
 		break;
 	default:
 		//reject
-		res = 0;
+		res = -EINVAL;
 		break;
 	}
 
@@ -728,3 +728,311 @@
 		break;
 	}
 }
+
+static int iscsi_cmd_done(int host_no, int len, int result, int rw,
+			  uint64_t addr, uint64_t tag)
+{
+	struct session *session;
+	struct iscsi_ctask *ctask;
+
+	dprintf("%u %d %d %d %" PRIx64 " %" PRIx64 "\n", host_no, len, result,
+		rw, addr, tag);
+	session = session_lookup(host_no);
+	if (!session)
+		return -EINVAL;
+
+	list_for_each_entry(ctask, &session->cmd_list, c_hlist) {
+		if (ctask->tag == tag)
+			goto found;
+	}
+	eprintf("Cannot find a task %" PRIx64 "\n", tag);
+	return -EINVAL;
+
+found:
+	eprintf("found a task %" PRIx64 "\n", tag);
+	ctask->addr = addr;
+	ctask->result = result;
+	ctask->len = len;
+	ctask->rw = rw;
+
+	return 0;
+}
+
+static int iscsi_cmd_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp->itt = ctask->tag;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp->cmd_status = ctask->result;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+
+	return 0;
+}
+
+static int iscsi_data_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	int residual, datalen, exp_datalen = ntohl(req->data_length);
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
+	rsp->itt = ctask->tag;
+	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
+
+	rsp->offset = cpu_to_be32(ctask->offset);
+	rsp->datasn = cpu_to_be32(ctask->data_sn++);
+	rsp->cmd_status = ctask->result;
+
+	datalen = min(exp_datalen, ctask->len);
+	if (datalen > conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val)
+		eprintf("cannot handle %d %d %d %d\n",
+			datalen, exp_datalen, ctask->len,
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val);
+
+	rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+	if (ctask->len < exp_datalen) {
+		rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+		residual = exp_datalen - ctask->len;
+	} else if (ctask->len > exp_datalen) {
+		rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+		residual = ctask->len - exp_datalen;
+	} else
+		residual = 0;
+
+	rsp->residual_count = cpu_to_be32(residual);
+	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
+		rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+
+	conn->rsp.datasize = datalen;
+	hton24(rsp->dlength, datalen);
+	conn->rsp.data = (void *) (unsigned long) ctask->addr;
+
+	return 0;
+}
+
+static int iscsi_r2t_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
+	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
+	memset(rsp, 0, sizeof(*rsp));
+
+	rsp->opcode = ISCSI_OP_R2T;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	memcpy(rsp->lun, ctask->req.lun, sizeof(rsp->lun));
+
+	rsp->itt = ctask->req.itt;
+	rsp->r2tsn = cpu_to_be32(ctask->exp_r2tsn++);
+	rsp->data_offset = cpu_to_be32(ctask->offset);
+	rsp->ttt = (unsigned long) ctask;
+	length = min(ctask->r2t_count, max_burst);
+	rsp->data_length = cpu_to_be32(length);
+	ctask->r2t_count -= length;
+
+	return 0;
+}
+
+static int iscsi_data_out_rx_start(struct connection *conn)
+{
+	struct iscsi_ctask *ctask;
+	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
+
+	list_for_each_entry(ctask, &conn->session->cmd_list, c_hlist) {
+		if (ctask->tag == req->itt)
+			goto found;
+	}
+	return -EINVAL;
+found:
+	eprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
+		ctask->r2t_count,
+		ntoh24(req->dlength), be32_to_cpu(req->offset));
+
+	conn->buffer = (void *) (unsigned long) ctask->addr;
+	conn->buffer += be32_to_cpu(req->offset);
+	conn->rwsize = ntoh24(req->dlength);
+
+	ctask->offset += ntoh24(req->dlength);
+
+	conn->ctask = ctask;
+
+	return 0;
+}
+
+static int iscsi_cmd_init(struct connection *conn)
+{
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
+	struct iscsi_ctask *ctask;
+	int err, attr;
+
+	ctask = zalloc(sizeof(*ctask));
+	if (!ctask) {
+		eprintf("OOM\n");
+		return -ENOMEM;
+	}
+
+	memcpy(&ctask->req, req, sizeof(*req));
+	ctask->tag = req->itt;
+	ctask->conn = conn;
+	INIT_LIST_HEAD(&ctask->c_hlist);
+
+	list_add(&ctask->c_hlist, &conn->session->cmd_list);
+
+	dprintf("%u %x %d %d %u\n", conn->session->tsih,
+		req->cdb[0], ntohl(req->data_length),
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
+
+	switch (req->flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		attr = SIMPLE_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		attr = HEAD_OF_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+	default:
+		attr = ORDERED_QUEUE_TAG;
+	}
+
+	attr = SIMPLE_QUEUE_TAG;
+	err = target_cmd_queue(conn->session->tsih, req->cdb,
+			       req->lun, ntohl(req->data_length),
+			       attr,
+			       req->itt, iscsi_cmd_done);
+
+	conn->exp_cmd_sn++;
+	conn->ctask = ctask;
+
+	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
+		conn->rwsize = ntoh24(req->dlength);
+		conn->buffer = (void *) (unsigned long) conn->ctask->addr;
+		ctask->r2t_count = ntohl(req->data_length) - conn->rwsize;
+		ctask->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
+		ctask->offset = conn->rwsize;
+
+		dprintf("%d %d %d %d\n", conn->rwsize, ctask->r2t_count,
+			ctask->unsol_count, ctask->offset);
+	}
+
+	return err;
+}
+
+static int __iscsi_cmd_rx_done(struct connection *conn, int *is_rsp)
+{
+	struct iscsi_ctask *ctask = conn->ctask;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	int err = 0;
+
+	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
+		if (ctask->r2t_count) {
+			if (ctask->unsol_count)
+				*is_rsp = 0;
+			else
+				err = iscsi_r2t_build(ctask);
+		} else
+			err = iscsi_cmd_rsp_build(ctask);
+	} else {
+		if (ctask->len)
+			err = iscsi_data_rsp_build(ctask);
+		else
+			err = iscsi_cmd_rsp_build(ctask);
+	}
+
+	return err;
+}
+
+int iscsi_cmd_rx_done(struct connection *conn, int *is_rsp)
+{
+	struct iscsi_hdr *hdr = &conn->req.bhs;
+	uint8_t op;
+	int err = 0;
+
+	*is_rsp = 1;
+	op = hdr->opcode & ISCSI_OPCODE_MASK;
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		__iscsi_cmd_rx_done(conn, is_rsp);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		dprintf("%d\n", conn->ctask->r2t_count);
+		if (conn->ctask->r2t_count)
+			err = iscsi_r2t_build(conn->ctask);
+		else
+			err = iscsi_cmd_rsp_build(conn->ctask);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+	default:
+		eprintf("Cannot handle yet %x\n", op);
+		break;
+	}
+
+	return err;
+}
+
+int iscsi_cmd_rx_start(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &conn->req.bhs;
+	uint8_t op;
+	int err;
+
+	op = hdr->opcode & ISCSI_OPCODE_MASK;
+	dprintf("%u\n", op);
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_cmd_init(conn);
+		if (!err)
+			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		err = iscsi_data_out_rx_start(conn);
+		if (!err)
+			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		eprintf("Cannot handle yet %x\n", op);
+		err = -EINVAL;
+	default:
+		eprintf("Unknown op %x\n", op);
+		err = -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+void iscsi_cmd_tx_done(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &conn->rsp.bhs;
+
+	switch (hdr->opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_R2T:
+		break;
+	default:
+		target_cmd_done(conn->session->tsih, conn->ctask->tag);
+		list_del(&conn->ctask->c_hlist);
+		free(conn->ctask);
+	}
+
+	conn->ctask = NULL;
+}

Modified: branches/user-iscsi/usr/iscsi/iscsid.h
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -11,12 +11,13 @@
 #include <linux/types.h>
 
 #include "types.h"
-#include "iscsi_if.h"
-#include "list.h"
 #include "param.h"
-#include "log.h"
+#include "../list.h"
+#include "../log.h"
+#include "../util.h"
 
-#include <scsi/iscsi_proto.h>
+#include <iscsi_proto.h>
+#include <iscsi_if.h>
 
 #define ISCSI_NAME_LEN 255
 #define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
@@ -25,9 +26,6 @@
 #define DIGEST_NONE		(1 << 0)
 #define DIGEST_CRC32C           (1 << 1)
 
-extern uint64_t thandle;
-extern int nl_fd;
-
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
@@ -36,6 +34,8 @@
 	(uint64_t) tsih << 48;					\
 })
 
+struct connection;
+
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;
@@ -52,24 +52,47 @@
 	struct list_head slist;
 	struct list_head hlist;
 
+
 	char *initiator;
 	struct target *target;
 	uint8_t isid[6];
 	uint16_t tsih;
 
-	/* workaroud */
-	uint32_t ksid;
-	uint32_t hostno;
-
 	struct list_head conn_list;
 	int conn_cnt;
+
+	struct list_head cmd_list;
 };
 
+struct iscsi_ctask {
+	struct iscsi_hdr req;
+	struct iscsi_hdr rsp;
+
+	uint64_t tag;
+	struct connection *conn;
+
+	struct list_head c_hlist;
+
+	uint64_t addr;
+	int result;
+	int len;
+	int rw;
+
+	int offset;
+	int data_sn;
+
+	int r2t_count;
+	int unsol_count;
+	int exp_r2tsn;
+};
+
 struct connection {
 	int state;
-	int iostate;
+	int tx_iostate;
+	int rx_iostate;
 	int fd;
 
+	struct list_head send;
 	struct list_head clist;
 	struct session *session;
 
@@ -84,9 +107,6 @@
 	int session_type;
 	int auth_method;
 
-	/* workaroud */
-	uint32_t kcid;
-
 	uint32_t stat_sn;
 	uint32_t exp_stat_sn;
 
@@ -110,6 +130,8 @@
 			unsigned char *challenge;
 		} chap;
 	} auth;
+
+	struct iscsi_ctask *ctask;
 };
 
 #define IOSTATE_FREE		0
@@ -131,6 +153,7 @@
 #define STATE_KERNEL		9
 #define STATE_CLOSE		10
 #define STATE_EXIT		11
+#define STATE_SCSI		12
 
 #define AUTH_STATE_START	0
 #define AUTH_STATE_CHALLENGE	1
@@ -170,7 +193,7 @@
 extern struct connection *conn_alloc(void);
 extern void conn_free(struct connection *conn);
 extern struct connection * conn_find(struct session *session, uint32_t cid);
-extern void conn_take_fd(struct connection *conn, int fd);
+extern int conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
 extern void conn_free_pdu(struct connection *conn);
@@ -183,13 +206,15 @@
 extern void cmnd_finish(struct connection *conn);
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
+extern int iscsi_cmd_rx_start(struct connection *conn);
+extern int iscsi_cmd_rx_done(struct connection *conn, int *is_rsp);
+extern void iscsi_cmd_tx_done(struct connection *conn);
 
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
-extern struct session *session_find_id(int tid, uint64_t sid);
-extern struct session *session_find_hostno(int hostno);
-extern void session_create(struct connection *conn);
-extern void session_remove(struct session *session);
+extern int session_create(struct connection *conn);
+extern void session_destroy(struct session *session);
+extern struct session *session_lookup(uint16_t tsih);
 
 /* target.c */
 extern int target_find_by_name(const char *name, int *tid);
@@ -197,9 +222,6 @@
 extern void target_list_build(struct connection *, char *, char *);
 extern int target_bind(int tid, int hostno);
 
-extern void ipc_event(void);
-extern int ipc_init(void);
-
 /* netlink.c */
 struct iscsi_kernel_interface {
 	int (*set_param) (uint64_t transport_handle, uint32_t sid,

Modified: branches/user-iscsi/usr/iscsi/istgt.c
===================================================================
--- branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -41,14 +41,11 @@
 
 enum {
 	POLL_LISTEN,
-	POLL_NL = POLL_LISTEN + LISTEN_MAX,
-	POLL_INCOMING,
+	POLL_INCOMING = POLL_LISTEN + LISTEN_MAX,
 	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
 };
 
 static struct connection *incoming[INCOMING_MAX];
-uint64_t thandle;
-int nl_fd;
 
 static void set_non_blocking(int fd)
 {
@@ -127,24 +124,22 @@
 
 	eprintf("%d\n", afd);
 
-	namesize = sizeof(from);
-	if ((fd = accept(afd, (struct sockaddr *) &from, &namesize)) < 0) {
-		if (errno != EINTR && errno != EAGAIN) {
-			eprintf("accept(incoming_socket)\n");
-			exit(1);
-		}
-		return;
-	}
-
 	for (i = 0; i < INCOMING_MAX; i++) {
 		if (!incoming[i])
 			break;
 	}
 	if (i >= INCOMING_MAX) {
-		eprintf("unable to find incoming slot? %d\n", i);
-		goto out;
+		eprintf("unable to find incoming slot %d\n", i);
+		return;
 	}
 
+	namesize = sizeof(from);
+	fd = accept(afd, (struct sockaddr *) &from, &namesize);
+	if (fd < 0) {
+		eprintf("%s\n", strerror(errno));
+		return;
+	}
+
 	conn = conn_alloc();
 	if (!conn) {
 		eprintf("fail to allocate conn\n");
@@ -166,145 +161,206 @@
 	return;
 }
 
-void iscsi_event_handle(struct pollfd *pfds)
+static void iscsi_rx(struct pollfd *pfd, struct connection *conn)
 {
-	struct connection *conn;
-	struct pollfd *pfd;
-	int i, res, opt;
+	int res;
 
-	for (i = 0; i < LISTEN_MAX; i++) {
-		if (pfds[POLL_LISTEN + i].revents)
-			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
-	}
+	switch (conn->rx_iostate) {
+	case IOSTATE_READ_BHS:
+	case IOSTATE_READ_AHS_DATA:
+	read_again:
+		res = read(pfd->fd, conn->buffer, conn->rwsize);
+		if (res <= 0) {
+			if (res == 0 || (errno != EINTR && errno != EAGAIN))
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto read_again;
+			break;
+		}
+		conn->rwsize -= res;
+		conn->buffer += res;
+		if (conn->rwsize)
+			break;
 
-	for (i = 0; i < INCOMING_MAX; i++) {
-		conn = incoming[i];
-		pfd = &pfds[POLL_INCOMING + i];
-		if (!conn || !pfd->revents)
-			continue;
+		switch (conn->rx_iostate) {
+		case IOSTATE_READ_BHS:
+			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
+			conn->req.ahssize = conn->req.bhs.hlength * 4;
+			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+			conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
 
-		pfd->revents = 0;
+			if (conn->req.ahssize) {
+				eprintf("FIXME: we cannot handle ahs\n");
+				conn->state = STATE_CLOSE;
+				break;
+			}
 
-		switch (conn->iostate) {
-		case IOSTATE_READ_BHS:
-		case IOSTATE_READ_AHS_DATA:
-		read_again:
-			res = read(pfd->fd, conn->buffer, conn->rwsize);
-			if (res <= 0) {
-				if (res == 0 || (errno != EINTR && errno != EAGAIN))
+			if (conn->state == STATE_SCSI) {
+				res = iscsi_cmd_rx_start(conn);
+				if (res) {
 					conn->state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto read_again;
-				break;
+					break;
+				}
 			}
-			conn->rwsize -= res;
-			conn->buffer += res;
-			if (conn->rwsize)
-				break;
-
-			switch (conn->iostate) {
-			case IOSTATE_READ_BHS:
-				conn->iostate = IOSTATE_READ_AHS_DATA;
-				conn->req.ahssize =
-					conn->req.bhs.hlength * 4;
-				conn->req.datasize =
-					ntoh24(conn->req.bhs.dlength);
-				conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
-				if (conn->rwsize) {
-					if (!conn->req_buffer)
-						conn->req_buffer = malloc(INCOMING_BUFSIZE);
+			if (conn->rwsize) {
+				if (conn->state == STATE_SCSI) {
+					dprintf("%d\n", conn->rwsize);
+				} else {
 					conn->buffer = conn->req_buffer;
 					conn->req.ahs = conn->buffer;
-					conn->req.data = conn->buffer + conn->req.ahssize;
-					goto read_again;
 				}
+				conn->req.data =
+					conn->buffer + conn->req.ahssize;
+				goto read_again;
+			}
 
-			case IOSTATE_READ_AHS_DATA:
+		case IOSTATE_READ_AHS_DATA:
+			if (conn->state == STATE_SCSI) {
+				int rsp;
+
+				dprintf("done\n");
+
 				conn_write_pdu(conn);
 				pfd->events = POLLOUT;
+				res = iscsi_cmd_rx_done(conn, &rsp);
+				if (!res && !rsp) {
+					conn_read_pdu(conn);
+					pfd->events = POLLIN;
+				}
+			} else {
+				conn_write_pdu(conn);
+				pfd->events = POLLOUT;
+				res = cmnd_execute(conn);
+			}
 
-				if (!cmnd_execute(conn))
-					conn->state = STATE_CLOSE;
-				break;
-			}
+			if (res)
+				conn->state = STATE_CLOSE;
 			break;
+		break;
+		}
+	}
+}
 
-		case IOSTATE_WRITE_BHS:
-		case IOSTATE_WRITE_AHS:
-		case IOSTATE_WRITE_DATA:
-		write_again:
-			opt = 1;
-			setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-			res = write(pfd->fd, conn->buffer, conn->rwsize);
-			if (res < 0) {
-				if (errno != EINTR && errno != EAGAIN)
-					conn->state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto write_again;
-				break;
-			}
+static void iscsi_tx(struct pollfd *pfd, struct connection *conn)
+{
+	int opt, res;
 
-			conn->rwsize -= res;
-			conn->buffer += res;
-			if (conn->rwsize)
+	switch (conn->tx_iostate) {
+	case IOSTATE_WRITE_BHS:
+	case IOSTATE_WRITE_AHS:
+	case IOSTATE_WRITE_DATA:
+	write_again:
+		if (conn->state == STATE_SCSI)
+			dprintf("%d %d %d\n", conn->rwsize, conn->rsp.ahssize,
+				conn->rsp.datasize);
+		opt = 1;
+		setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+		res = write(pfd->fd, conn->buffer, conn->rwsize);
+		if (res < 0) {
+			if (errno != EINTR && errno != EAGAIN)
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
 				goto write_again;
+			break;
+		}
 
-			switch (conn->iostate) {
-			case IOSTATE_WRITE_BHS:
-				if (conn->rsp.ahssize) {
-					conn->iostate = IOSTATE_WRITE_AHS;
-					conn->buffer = conn->rsp.ahs;
-					conn->rwsize = conn->rsp.ahssize;
-					goto write_again;
-				}
-			case IOSTATE_WRITE_AHS:
-				if (conn->rsp.datasize) {
-					int o;
+		conn->rwsize -= res;
+		conn->buffer += res;
+		if (conn->rwsize)
+			goto write_again;
 
-					conn->iostate = IOSTATE_WRITE_DATA;
-					conn->buffer = conn->rsp.data;
-					conn->rwsize = conn->rsp.datasize;
-					o = conn->rwsize & 3;
-					if (o) {
-						for (o = 4 - o; o; o--)
-							*((uint8_t *)conn->buffer + conn->rwsize++) = 0;
-					}
-					goto write_again;
+		switch (conn->tx_iostate) {
+		case IOSTATE_WRITE_BHS:
+			if (conn->rsp.ahssize) {
+				conn->tx_iostate = IOSTATE_WRITE_AHS;
+				conn->buffer = conn->rsp.ahs;
+				conn->rwsize = conn->rsp.ahssize;
+				goto write_again;
+			}
+		case IOSTATE_WRITE_AHS:
+			if (conn->rsp.datasize) {
+				int pad;
+
+				conn->tx_iostate = IOSTATE_WRITE_DATA;
+				conn->buffer = conn->rsp.data;
+				conn->rwsize = conn->rsp.datasize;
+				pad = conn->rwsize & (PAD_WORD_LEN - 1);
+				if (pad) {
+					for (pad = PAD_WORD_LEN - pad; pad; pad--)
+						*((uint8_t *)conn->buffer + conn->rwsize++) = 0;
 				}
-			case IOSTATE_WRITE_DATA:
-				opt = 0;
-				setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-				cmnd_finish(conn);
+				goto write_again;
+			}
+		case IOSTATE_WRITE_DATA:
+			opt = 0;
+			setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+			cmnd_finish(conn);
 
-				switch (conn->state) {
-				case STATE_KERNEL:
-					conn_take_fd(conn, pfd->fd);
+			switch (conn->state) {
+			case STATE_KERNEL:
+				res = conn_take_fd(conn, pfd->fd);
+				if (res)
 					conn->state = STATE_CLOSE;
-					break;
-				case STATE_EXIT:
-				case STATE_CLOSE:
-					break;
-				default:
+				else {
+					conn->state = STATE_SCSI;
 					conn_read_pdu(conn);
 					pfd->events = POLLIN;
-					break;
 				}
 				break;
+			case STATE_EXIT:
+			case STATE_CLOSE:
+				break;
+			case STATE_SCSI:
+				iscsi_cmd_tx_done(conn);
+			default:
+				conn_read_pdu(conn);
+				pfd->events = POLLIN;
+				break;
 			}
-
 			break;
-		default:
-			eprintf("illegal iostate %d for port %d!\n", conn->iostate, i);
-			exit(1);
 		}
 
+		break;
+	default:
+		eprintf("illegal iostate %d\n", conn->tx_iostate);
+		conn->state = STATE_CLOSE;
+	}
+}
+
+void iscsi_event_handle(struct pollfd *pfds)
+{
+	struct session *session;
+	struct connection *conn;
+	struct pollfd *pfd;
+	int i;
+
+	for (i = 0; i < LISTEN_MAX; i++) {
+		if (pfds[POLL_LISTEN + i].revents)
+			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
+	}
+
+	for (i = 0; i < INCOMING_MAX; i++) {
+		conn = incoming[i];
+		pfd = &pfds[POLL_INCOMING + i];
+		if (!conn || !pfd->revents)
+			continue;
+
+		if (pfd->revents & POLLIN)
+			iscsi_rx(pfd, conn);
+		if (pfd->revents & POLLOUT)
+			iscsi_tx(pfd, conn);
+		pfd->revents = 0;
+
 		if (conn->state == STATE_CLOSE) {
 			dprintf("connection closed\n");
+			session = conn->session;
 			conn_free_pdu(conn);
 			conn_free(conn);
-/* 			close(pfd->fd); */
+			close(pfd->fd);
 			pfd->fd = -1;
 			incoming[i] = NULL;
+			if (session)
+				session_destroy(session);
 		}
 	}
 }
@@ -313,9 +369,6 @@
 {
 	int i;
 
-	pfd[POLL_NL].fd = nl_fd;
-	pfd[POLL_NL].events = POLLIN;
-
 	listen_socket_create(pfd + POLL_LISTEN);
 
 	for (i = 0; i < INCOMING_MAX; i++) {
@@ -329,7 +382,6 @@
 
 int iscsi_init(int *npfd)
 {
-	iscsi_nl_init();
 	*npfd = POLL_MAX;
 
 	return 0;

Deleted: branches/user-iscsi/usr/iscsi/netlink.c
===================================================================
--- branches/user-iscsi/usr/iscsi/netlink.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/netlink.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,372 +0,0 @@
-/*
- * iSCSI Netlink/Linux Interface
- *
- * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-#include "tgtadm.h"
-
-#define NL_BUFSIZE 4096
-
-static struct sockaddr_nl saddr, daddr;
-
-static int __nl_read(int fd, void *data, int size, int flags)
-{
-	struct sockaddr_nl saddr;
-	socklen_t slen = sizeof(saddr);
-
-	memset(&saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-
-	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
-}
-
-static int nl_read(char *buf)
-{
-	struct nlmsghdr *nlh;
-	int err;
-
-peek_again:
-	err = __nl_read(nl_fd, buf, NLMSG_LENGTH(0), MSG_PEEK);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-
-/* 	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid()); */
-read_again:
-	err = __nl_read(nl_fd, buf, nlh->nlmsg_len, 0);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto read_again;
-		return err;
-	}
-
-	return err;
-}
-
-static int __kipc_call(struct iscsi_uevent *ev, int len)
-{
-	struct nlmsghdr *nlh;
-	char sbuf[NL_BUFSIZE];
-	int err;
-
-	nlh = (struct nlmsghdr *) sbuf;
-	memset(sbuf, 0, NL_BUFSIZE);
-	memcpy(NLMSG_DATA(nlh), ev, len);
-
-	len = NLMSG_SPACE(len);
-	nlh->nlmsg_pid = getpid();
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_type = ev->type;
-
-	err = sendto(nl_fd, nlh, len, 0, (struct sockaddr *) &daddr, sizeof(daddr));
-	if (err < 0) {
-		eprintf("%d\n", err);
-		return err;
-	}
-
-	memset(sbuf, 0, NL_BUFSIZE);
-	err = nl_read(sbuf);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		return err;
-	}
-
-	memcpy(ev, NLMSG_DATA(sbuf), sizeof(*ev));
-
-	return err;
-}
-
-static int kcreate_session(uint64_t transport_handle, uint32_t initial_cmdsn,
-		uint32_t *out_sid, uint32_t *out_hostno)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf("%"PRIx64 " %u %u %u\n",
-		transport_handle, initial_cmdsn, *out_sid, *out_hostno);
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.c_session.initial_cmdsn = initial_cmdsn;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*out_hostno = ev.r.c_session_ret.host_no;
-	*out_sid = ev.r.c_session_ret.sid;
-
-	return 0;
-}
-
-static int kdestroy_session(uint64_t transport_handle, uint32_t sid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.d_session.sid = sid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int kcreate_conn(uint64_t transport_handle, uint32_t sid,
-		       uint32_t cid, uint32_t *out_cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf("%"PRIx64 " %u %u\n", transport_handle, sid, cid);
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.c_conn.cid = cid;
-	ev.u.c_conn.sid = sid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		eprintf("%d\n", rc);
-		return rc;
-	}
-
-	if ((int)ev.r.c_conn_ret.cid == -1)
-		return -EIO;
-
-	*out_cid = ev.r.c_conn_ret.cid;
-	return 0;
-}
-
-static int kdestroy_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.d_conn.sid = sid;
-	ev.u.d_conn.cid = cid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		eprintf("%d\n", rc);
-	}
-
-	return 0;
-}
-
-static int
-kbind_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   uint64_t transport_eph, int is_leading, int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	ev.type = ISCSI_UEVENT_BIND_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.b_conn.sid = sid;
-	ev.u.b_conn.cid = cid;
-	ev.u.b_conn.transport_eph = transport_eph;
-	ev.u.b_conn.is_leading = is_leading;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-
-	return 0;
-}
-
-static int
-kstop_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid, int flag)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_STOP_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.stop_conn.sid = sid;
-	ev.u.stop_conn.cid = cid;
-	ev.u.stop_conn.flag = flag;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int
-kstart_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	    int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_START_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.start_conn.sid = sid;
-	ev.u.start_conn.cid = cid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-	return 0;
-}
-
-static int
-kset_param(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   enum iscsi_param param, void *value, int len, int *retcode)
-{
-	struct iscsi_uevent *ev;
-	char setparam_buf[NL_BUFSIZE];
-	int rc;
-
-	memset(setparam_buf, 0, sizeof(setparam_buf));
-	ev = (struct iscsi_uevent *) setparam_buf;
-	ev->type = ISCSI_UEVENT_SET_PARAM;
-	ev->transport_handle = transport_handle;
-	ev->u.set_param.sid = sid;
-	ev->u.set_param.cid = cid;
-	ev->u.set_param.param = param;
-	ev->u.set_param.len = len;
-	memcpy(setparam_buf + sizeof(*ev), value, len);
-
-	if ((rc = __kipc_call(ev, sizeof(*ev) + len)) < 0) {
-		return rc;
-	}
-
-	*retcode = ev->r.retcode;
-
-	return 0;
-}
-
-static int transport_handle_init(void)
-{
-	int fd, err;
-	char buf[64];
-
-	fd = open("/sys/class/iscsi_transport/iscsi_tcp_tgt/handle", O_RDONLY);
-	if (fd < 0)
-		return fd;
-	err = read(fd, buf, sizeof(buf));
-	if (err < 0)
-		goto out;
-	thandle = strtoull(buf, NULL, 10);
-	dprintf("%" PRIx64 "\n", thandle);
-	err = 0;
-out:
-	close(fd);
-	return err;
-}
-
-int iscsi_nl_init(void)
-{
-	int err, rsize = 256 * 1024;
-
-	err = transport_handle_init();
-	if (err)
-		return err;
-
-	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
-	if (nl_fd < 0) {
-		eprintf("Fail to create the netlink socket %d\n", errno);
-		return err;
-	}
-	eprintf("create the netlink socket %d\n", nl_fd);
-
-	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
-	if (err) {
-		eprintf("fail to setsockopt %d\n", errno);
-		return err;
-	}
-
-	memset(&saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-/* 	err = bind(nl_fd, (struct sockaddr *) &saddr, sizeof(saddr)); */
-/* 	if (err) { */
-/* 		eprintf("can not bind NETLINK_ISCSI socket %d\n", errno); */
-/* 		close(nl_fd); */
-/* 		return err; */
-/* 	} */
-
-	memset(&daddr, 0, sizeof(daddr));
-	daddr.nl_family = AF_NETLINK;
-	daddr.nl_pid = 0; /* kernel */
-	daddr.nl_groups = 0; /* unicast */
-	eprintf("create the netlink socket %d %d\n", nl_fd, err);
-
-	return err;
-}
-
-struct iscsi_kernel_interface nl_ki = {
-	.create_session		= kcreate_session,
-	.destroy_session	= kdestroy_session,
-	.create_conn		= kcreate_conn,
-	.destroy_conn		= kdestroy_conn,
-	.bind_conn		= kbind_conn,
-	.set_param              = kset_param,
-	.start_conn             = kstart_conn,
-	.stop_conn              = kstop_conn,
-};
-
-struct iscsi_kernel_interface *ki = &nl_ki;

Modified: branches/user-iscsi/usr/iscsi/session.c
===================================================================
--- branches/user-iscsi/usr/iscsi/session.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/session.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -18,38 +18,6 @@
 
 static LIST_HEAD(sessions_list);
 
-static struct session *session_alloc(int tid)
-{
-	struct session *session;
-	struct target *target = target_find_by_id(tid);
-
-	if (!target)
-		return NULL;
-	if (!(session = malloc(sizeof(*session))))
-		return NULL;
-	memset(session, 0, sizeof(*session));
-
-	session->target = target;
-	INIT_LIST_HEAD(&session->slist);
-	list_add(&session->slist, &target->sessions_list);
-
-	INIT_LIST_HEAD(&session->conn_list);
-
-	return session;
-}
-
-int iscsi_target_bind(int hostno)
-{
-	struct session *session;
-
-	list_for_each_entry(session, &sessions_list, hlist) {
-		if (session->hostno == hostno)
-			return session->target->tid;
-	}
-
-	return -ENOENT;
-}
-
 struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
@@ -69,67 +37,69 @@
 	return NULL;
 }
 
-struct session *session_find_id(int tid, uint64_t sid)
+struct session *session_lookup(uint16_t tsih)
 {
 	struct session *session;
-	struct target *target;
-
-	if (!(target = target_find_by_id(tid)))
-		return NULL;
-
-	log_debug("session_find_id: %#" PRIx64, sid);
-	list_for_each_entry(session, &target->sessions_list, slist) {
-		if (sid64(session->isid, session->tsih) == sid)
+	list_for_each_entry(session, &sessions_list, hlist) {
+		if (session->tsih == tsih)
 			return session;
 	}
-
 	return NULL;
 }
 
-void session_create(struct connection *conn)
+int session_create(struct connection *conn)
 {
-	struct session *session;
-	uint64_t sid;
-	static uint16_t tsih = 1;
+	struct session *session = NULL;
+	static uint16_t tsih, last_tsih = 0;
+	struct target *target;
 
-	/* First, we need to get an available sid. */
-	while (1) {
-		sid = sid64(conn->isid, tsih);
-		if (!session_find_id(conn->tid, sid))
+	target = target_find_by_id(conn->tid);
+	if (!target)
+		return -EINVAL;
+
+	for (tsih = last_tsih + 1; tsih != last_tsih; tsih++) {
+		if (!tsih)
+			continue;
+		session = session_lookup(tsih);
+		if (!session)
 			break;
-		tsih++;
 	}
+	if (session)
+		return -EINVAL;
 
-	session = session_alloc(conn->tid);
+	session = zalloc(sizeof(*session));
 	if (!session)
-		return;
+		return -ENOMEM;
 
+	session->target = target;
+	INIT_LIST_HEAD(&session->slist);
+	list_add(&session->slist, &target->sessions_list);
+
+	INIT_LIST_HEAD(&session->conn_list);
+	INIT_LIST_HEAD(&session->cmd_list);
+
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
-	session->tsih = tsih++;
+	session->tsih = last_tsih = tsih;
 
 	conn_add_to_session(conn, session);
 	conn->session->initiator = strdup(conn->initiator);
 
-	log_debug("session_create: %#" PRIx64, sid);
+	log_debug("session_create: %#" PRIx64, sid64(conn->isid, session->tsih));
 
-	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
-			   &session->hostno);
-
 	list_add(&session->hlist, &sessions_list);
+
+	return 0;
 }
 
-void session_remove(struct session *session)
+void session_destroy(struct session *session)
 {
-	uint64_t sid = sid64(session->isid, session->tsih);
+	eprintf("%d\n", session->tsih);
 
-	eprintf("%#"  PRIx64 "\n", sid);
+	if (!list_empty(&session->conn_list)) {
+		eprintf("%d conn_list is not null\n", session->tsih);
+		return;
+	}
 
-	if (!list_empty(&session->conn_list))
-		eprintf("%" PRIx64 " conn_list is not null\n", sid);
-
-	if (!session->tsih)
-		ki->destroy_session(thandle, session->ksid);
-
 	if (session->target) {
 		list_del(&session->slist);
 /* 		session->target->nr_sessions--; */

Modified: branches/user-iscsi/usr/iscsi/types.h
===================================================================
--- branches/user-iscsi/usr/iscsi/types.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/iscsi/types.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -27,4 +27,7 @@
 #error "unknown endianess!"
 #endif
 
+typedef uint16_t __be16;
+typedef uint32_t __be32;
+
 #endif	/* TYPES_H */

Modified: branches/user-iscsi/usr/mgmt.c
===================================================================
--- branches/user-iscsi/usr/mgmt.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/mgmt.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -223,8 +223,16 @@
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 
+retry:
 	err = recvmsg(fd, &msg, MSG_PEEK | MSG_DONTWAIT);
 	if (err != len) {
+		/*
+		 * workaround. We need to put this request to
+		 * scheduler and wait for timeout or data.
+		 */
+		if (errno == EAGAIN)
+			goto retry;
+
 		eprintf("can't read %s\n", strerror(errno));
 		goto out;
 	}

Modified: branches/user-iscsi/usr/scsi.c
===================================================================
--- branches/user-iscsi/usr/scsi.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/scsi.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -21,7 +21,7 @@
 #include <unistd.h>
 #include <asm/byteorder.h>
 #include <linux/fs.h>
-#include <scsi/scsi.h>
+#include "scsi.h"
 #include <sys/mman.h>
 
 #include "list.h"

Modified: branches/user-iscsi/usr/target.c
===================================================================
--- branches/user-iscsi/usr/target.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/target.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -32,7 +32,7 @@
 #include <sys/stat.h>
 
 #include <linux/fs.h>
-#include <scsi/scsi.h>
+#include "scsi.h"
 
 #include "list.h"
 #include "util.h"

Modified: branches/user-iscsi/usr/tgtd.c
===================================================================
--- branches/user-iscsi/usr/tgtd.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtd.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -39,7 +39,7 @@
 #include "driver.h"
 
 enum {
-	POLL_KI, /* kernel interface */
+/* 	POLL_KI, /\* kernel interface *\/ */
 	POLL_IPC, /* unix domain socket for tgtdadm */
 	POLL_END,
 };
@@ -138,10 +138,10 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_KI].revents) {
-		kspace_event_handle();
-		nevent--;
-	}
+/* 	if (pfd[POLL_KI].revents) { */
+/* 		kspace_event_handle(); */
+/* 		nevent--; */
+/* 	} */
 
 	if (pfd[POLL_IPC].revents) {
 		dprintf("ipc event\n");
@@ -171,8 +171,8 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_KI].fd = nl_fd;
-	pfd[POLL_KI].events = POLLIN;
+/* 	pfd[POLL_KI].fd = nl_fd; */
+/* 	pfd[POLL_KI].events = POLLIN; */
 	pfd[POLL_IPC].fd = ud_fd;
 	pfd[POLL_IPC].events = POLLIN;
 
@@ -276,14 +276,15 @@
 	if (err)
 		exit(1);
 
-	err = kreq_init(&ki_fd);
-	if (err)
-		exit(1);
+/* 	err = kreq_init(&ki_fd); */
+/* 	if (err) */
+/* 		exit(1); */
 
 	err = ipc_init(&ipc_fd);
 	if (err)
 		exit(1);
 
+	ki_fd = 0;
 	pfd = pfd_init(nr_pfd, ki_fd, ipc_fd);
 
 	event_loop(pfd, nr_pfd, timeout);

Modified: branches/user-iscsi/usr/tgtd.h
===================================================================
--- branches/user-iscsi/usr/tgtd.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtd.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -37,7 +37,7 @@
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
 typedef int (cmd_end_t)(int host_no, int len, int result, int rw, uint64_t addr,
-			 uint64_t tag);
+			uint64_t tag);
 typedef int (mgmt_end_t)(int host_no, uint64_t mid, int result);
 extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
 			    uint32_t data_len, int attribute, uint64_t tag,

Deleted: branches/user-iscsi/usr/tgtif.c
===================================================================
--- branches/user-iscsi/usr/tgtif.c	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/tgtif.c	2006-08-20 19:00:24 UTC (rev 535)
@@ -1,187 +0,0 @@
-/*
- * SCSI kernel and user interface
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <inttypes.h>
-#include <stdint.h>
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <asm/types.h>
-#include <sys/mman.h>
-#include <sys/poll.h>
-#include <sys/stat.h>
-#include <scsi/scsi_tgt_if.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-
-struct uring {
-	uint32_t idx;
-	uint32_t nr_entry;
-	int entry_size;
-	char *buf;
-	int buf_size;
-};
-
-static struct uring kuring, ukring;
-static int chrfd;
-
-static inline struct rbuf_hdr *head_ring_hdr(struct uring *r)
-{
-	uint32_t offset = (r->idx & (r->nr_entry - 1)) * r->entry_size;
-	return (struct rbuf_hdr *) (r->buf + offset);
-}
-
-static void ring_init(struct uring *r, char *buf, int bsize, int esize)
-{
-	int i;
-
-	esize += sizeof(struct rbuf_hdr);
-	r->idx = 0;
-	r->buf = buf;
-	r->buf_size = bsize;
-	r->entry_size = esize;
-
-	bsize /= esize;
-	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
-		;
-	r->nr_entry = 1 << i;
-
-	dprintf("%u %u\n", r->entry_size, r->nr_entry);
-}
-
-static int kreq_send(struct tgt_event *ev)
-{
-	struct rbuf_hdr *hdr;
-	hdr = head_ring_hdr(&ukring);
-	if (hdr->status)
-		return -ENOMEM;
-
-	memcpy(hdr->data, ev, sizeof(*ev));
-	ukring.idx++;
-	hdr->status = 1;
-
-	write(chrfd, ev, 1);
-
-	return 0;
-}
-
-static int kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
-{
-	struct tgt_event ev;
-
-	ev.u.tsk_mgmt_rsp.host_no = host_no;
-	ev.u.tsk_mgmt_rsp.mid = mid;
-	ev.u.tsk_mgmt_rsp.result = result;
-
-	return kreq_send(&ev);
-}
-
-static int kspace_send_cmd_res(int host_no, int len, int result,
-			       int rw, uint64_t addr, uint64_t tag)
-{
-	struct tgt_event ev;
-
-	ev.type = TGT_UEVENT_CMD_RSP;
-	ev.u.cmd_rsp.host_no = host_no;
-/* 	ev.u.cmd_rsp.cid = cmd->cid; */
-	ev.u.cmd_rsp.len = len;
-	ev.u.cmd_rsp.result = result;
-	ev.u.cmd_rsp.uaddr = addr;
-	ev.u.cmd_rsp.rw = rw;
-
-	return kreq_send(&ev);
-}
-
-void kspace_event_handle(void)
-{
-	struct rbuf_hdr *hdr;
-	struct tgt_event *ev;
-
-	dprintf("nl event %u\n", kuring.idx);
-retry:
-	hdr = head_ring_hdr(&kuring);
-	if (!hdr->status)
-		return;
-
-	ev = (struct tgt_event *) (hdr->data);
-
-	dprintf("event %u\n", ev->type);
-
-	switch (ev->type) {
-	case TGT_KEVENT_CMD_REQ:
-		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
-				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
-				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag,
-				 kspace_send_cmd_res);
-		break;
-	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.cid);
-		break;
-	case TGT_KEVENT_TSK_MGMT_REQ:
-		target_mgmt_request(ev->k.cmd_req.host_no,
-				    ev->k.tsk_mgmt_req.mid,
-				    ev->k.tsk_mgmt_req.function,
-				    ev->k.tsk_mgmt_req.lun,
-				    ev->k.tsk_mgmt_req.tag,
-				    kspace_send_tsk_mgmt);
-		break;
-	default:
-		eprintf("unknown event %u\n", ev->type);
-	}
-
-	hdr->status = 0;
-	kuring.idx++;
-
-	goto retry;
-}
-
-#define CHRDEV_PATH "/dev/tgt"
-
-int kreq_init(int *ki_fd)
-{
-	int err, fd, size = TGT_RINGBUF_SIZE;
-	char *buf;
-
-	err = chrdev_open("tgt", CHRDEV_PATH, 0, &fd);
-	if (err)
-		return err;
-
-	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (buf == MAP_FAILED) {
-		eprintf("fail to mmap %s\n", strerror(errno));
-		close(fd);
-		return -EINVAL;
-	}
-
-	ring_init(&kuring, buf, size, sizeof(struct tgt_event));
-	ring_init(&ukring, buf + size, size, sizeof(struct tgt_event));
-
-	*ki_fd = chrfd = fd;
-
-	return 0;
-}

Modified: branches/user-iscsi/usr/util.h
===================================================================
--- branches/user-iscsi/usr/util.h	2006-08-20 17:50:14 UTC (rev 534)
+++ branches/user-iscsi/usr/util.h	2006-08-20 19:00:24 UTC (rev 535)
@@ -33,6 +33,14 @@
 #define max_t(type,x,y) \
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
+static inline void *zalloc(size_t size)
+{
+	void *p = malloc(size);
+	if (p)
+		memset(p, 0, size);
+	return p;
+}
+
 extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
 
 #endif



From tomo at mail.berlios.de  Sun Aug 20 21:15:21 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 21:15:21 +0200
Subject: [Stgt-svn] r536 - in branches/user-iscsi: . usr usr/include
Message-ID: <200608201915.k7KJFLSZ008249@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 21:15:18 +0200 (Sun, 20 Aug 2006)
New Revision: 536

Added:
   branches/user-iscsi/usr/include/
   branches/user-iscsi/usr/include/iscsi_if.h
   branches/user-iscsi/usr/include/iscsi_proto.h
   branches/user-iscsi/usr/include/scsi.h
Removed:
   branches/user-iscsi/ibmvstgt/
   branches/user-iscsi/istgt/
   branches/user-iscsi/kernel/
   branches/user-iscsi/patchset/
Modified:
   branches/user-iscsi/usr/Makefile
Log:
Opps, forgot to add include files taken from kernel tree.


Modified: branches/user-iscsi/usr/Makefile
===================================================================
--- branches/user-iscsi/usr/Makefile	2006-08-20 19:00:24 UTC (rev 535)
+++ branches/user-iscsi/usr/Makefile	2006-08-20 19:15:18 UTC (rev 536)
@@ -15,5 +15,4 @@
 	$(CC) $^ -o $@
 
 clean:
-	rm -f *.o $(PROGRAMS)
-	$(MAKE) -C iscsi clean
+	rm -f *.o iscsi/*.o $(PROGRAMS)

Added: branches/user-iscsi/usr/include/iscsi_if.h
===================================================================
--- branches/user-iscsi/usr/include/iscsi_if.h	2006-08-20 19:00:24 UTC (rev 535)
+++ branches/user-iscsi/usr/include/iscsi_if.h	2006-08-20 19:15:18 UTC (rev 536)
@@ -0,0 +1,333 @@
+/*
+ * iSCSI User/Kernel Shares (Defines, Constants, Protocol definitions, etc)
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_IF_H
+#define ISCSI_IF_H
+
+#define UEVENT_BASE			10
+#define KEVENT_BASE			100
+#define ISCSI_ERR_BASE			1000
+
+enum iscsi_uevent_e {
+	ISCSI_UEVENT_UNKNOWN		= 0,
+
+	/* down events */
+	ISCSI_UEVENT_CREATE_SESSION	= UEVENT_BASE + 1,
+	ISCSI_UEVENT_DESTROY_SESSION	= UEVENT_BASE + 2,
+	ISCSI_UEVENT_CREATE_CONN	= UEVENT_BASE + 3,
+	ISCSI_UEVENT_DESTROY_CONN	= UEVENT_BASE + 4,
+	ISCSI_UEVENT_BIND_CONN		= UEVENT_BASE + 5,
+	ISCSI_UEVENT_SET_PARAM		= UEVENT_BASE + 6,
+	ISCSI_UEVENT_START_CONN		= UEVENT_BASE + 7,
+	ISCSI_UEVENT_STOP_CONN		= UEVENT_BASE + 8,
+	ISCSI_UEVENT_SEND_PDU		= UEVENT_BASE + 9,
+	ISCSI_UEVENT_GET_STATS		= UEVENT_BASE + 10,
+	ISCSI_UEVENT_GET_PARAM		= UEVENT_BASE + 11,
+
+	ISCSI_UEVENT_TRANSPORT_EP_CONNECT	= UEVENT_BASE + 12,
+	ISCSI_UEVENT_TRANSPORT_EP_POLL		= UEVENT_BASE + 13,
+	ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT	= UEVENT_BASE + 14,
+
+	ISCSI_UEVENT_TGT_DSCVR		= UEVENT_BASE + 15,
+
+	/* up events */
+	ISCSI_KEVENT_RECV_PDU		= KEVENT_BASE + 1,
+	ISCSI_KEVENT_CONN_ERROR		= KEVENT_BASE + 2,
+	ISCSI_KEVENT_IF_ERROR		= KEVENT_BASE + 3,
+	ISCSI_KEVENT_DESTROY_SESSION	= KEVENT_BASE + 4,
+};
+
+enum iscsi_tgt_dscvr {
+	ISCSI_TGT_DSCVR_SEND_TARGETS	= 1,
+	ISCSI_TGT_DSCVR_ISNS		= 2,
+	ISCSI_TGT_DSCVR_SLP		= 3,
+};
+
+struct iscsi_uevent {
+	uint32_t type; /* k/u events type */
+	uint32_t iferror; /* carries interface or resource errors */
+	uint64_t transport_handle;
+
+	union {
+		/* messages u -> k */
+		struct msg_create_session {
+			uint32_t	initial_cmdsn;
+		} c_session;
+		struct msg_destroy_session {
+			uint32_t	sid;
+		} d_session;
+		struct msg_create_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn;
+		struct msg_bind_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	transport_eph;
+			uint32_t	is_leading;
+		} b_conn;
+		struct msg_destroy_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} d_conn;
+		struct msg_send_pdu {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	hdr_size;
+			uint32_t	data_size;
+		} send_pdu;
+		struct msg_set_param {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	param; /* enum iscsi_param */
+			uint32_t	len;
+		} set_param;
+		struct msg_start_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} start_conn;
+		struct msg_stop_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	conn_handle;
+			uint32_t	flag;
+		} stop_conn;
+		struct msg_get_stats {
+			uint32_t	sid;
+			uint32_t	cid;
+		} get_stats;
+		struct msg_transport_connect {
+			uint32_t	non_blocking;
+		} ep_connect;
+		struct msg_transport_poll {
+			uint64_t	ep_handle;
+			uint32_t	timeout_ms;
+		} ep_poll;
+		struct msg_transport_disconnect {
+			uint64_t	ep_handle;
+		} ep_disconnect;
+		struct msg_tgt_dscvr {
+			enum iscsi_tgt_dscvr	type;
+			uint32_t	host_no;
+			/*
+ 			 * enable = 1 to establish a new connection
+			 * with the server. enable = 0 to disconnect
+			 * from the server. Used primarily to switch
+			 * from one iSNS server to another.
+			 */
+			uint32_t	enable;
+		} tgt_dscvr;
+	} u;
+	union {
+		/* messages k -> u */
+		int			retcode;
+		struct msg_create_session_ret {
+			uint32_t	sid;
+			uint32_t	host_no;
+		} c_session_ret;
+		struct msg_create_conn_ret {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn_ret;
+		struct msg_recv_req {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	recv_handle;
+		} recv_req;
+		struct msg_conn_error {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	error; /* enum iscsi_err */
+		} connerror;
+		struct msg_session_destroyed {
+			uint32_t	host_no;
+			uint32_t	sid;
+		} d_session;
+		struct msg_transport_connect_ret {
+			uint64_t	handle;
+		} ep_connect_ret;
+	} r;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+/*
+ * Common error codes
+ */
+enum iscsi_err {
+	ISCSI_OK			= 0,
+
+	ISCSI_ERR_DATASN		= ISCSI_ERR_BASE + 1,
+	ISCSI_ERR_DATA_OFFSET		= ISCSI_ERR_BASE + 2,
+	ISCSI_ERR_MAX_CMDSN		= ISCSI_ERR_BASE + 3,
+	ISCSI_ERR_EXP_CMDSN		= ISCSI_ERR_BASE + 4,
+	ISCSI_ERR_BAD_OPCODE		= ISCSI_ERR_BASE + 5,
+	ISCSI_ERR_DATALEN		= ISCSI_ERR_BASE + 6,
+	ISCSI_ERR_AHSLEN		= ISCSI_ERR_BASE + 7,
+	ISCSI_ERR_PROTO			= ISCSI_ERR_BASE + 8,
+	ISCSI_ERR_LUN			= ISCSI_ERR_BASE + 9,
+	ISCSI_ERR_BAD_ITT		= ISCSI_ERR_BASE + 10,
+	ISCSI_ERR_CONN_FAILED		= ISCSI_ERR_BASE + 11,
+	ISCSI_ERR_R2TSN			= ISCSI_ERR_BASE + 12,
+	ISCSI_ERR_SESSION_FAILED	= ISCSI_ERR_BASE + 13,
+	ISCSI_ERR_HDR_DGST		= ISCSI_ERR_BASE + 14,
+	ISCSI_ERR_DATA_DGST		= ISCSI_ERR_BASE + 15,
+	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16,
+	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
+};
+
+/*
+ * iSCSI Parameters (RFC3720)
+ */
+enum iscsi_param {
+	/* passed in using netlink set param */
+	ISCSI_PARAM_MAX_RECV_DLENGTH,
+	ISCSI_PARAM_MAX_XMIT_DLENGTH,
+	ISCSI_PARAM_HDRDGST_EN,
+	ISCSI_PARAM_DATADGST_EN,
+	ISCSI_PARAM_INITIAL_R2T_EN,
+	ISCSI_PARAM_MAX_R2T,
+	ISCSI_PARAM_IMM_DATA_EN,
+	ISCSI_PARAM_FIRST_BURST,
+	ISCSI_PARAM_MAX_BURST,
+	ISCSI_PARAM_PDU_INORDER_EN,
+	ISCSI_PARAM_DATASEQ_INORDER_EN,
+	ISCSI_PARAM_ERL,
+	ISCSI_PARAM_IFMARKER_EN,
+	ISCSI_PARAM_OFMARKER_EN,
+	ISCSI_PARAM_EXP_STATSN,
+	ISCSI_PARAM_TARGET_NAME,
+	ISCSI_PARAM_TPGT,
+	ISCSI_PARAM_PERSISTENT_ADDRESS,
+	ISCSI_PARAM_PERSISTENT_PORT,
+	ISCSI_PARAM_SESS_RECOVERY_TMO,
+
+	/* pased in through bind conn using transport_fd */
+	ISCSI_PARAM_CONN_PORT,
+	ISCSI_PARAM_CONN_ADDRESS,
+
+	/* must always be last */
+	ISCSI_PARAM_MAX,
+};
+
+#define ISCSI_MAX_RECV_DLENGTH		(1 << ISCSI_PARAM_MAX_RECV_DLENGTH)
+#define ISCSI_MAX_XMIT_DLENGTH		(1 << ISCSI_PARAM_MAX_XMIT_DLENGTH)
+#define ISCSI_HDRDGST_EN		(1 << ISCSI_PARAM_HDRDGST_EN)
+#define ISCSI_DATADGST_EN		(1 << ISCSI_PARAM_DATADGST_EN)
+#define ISCSI_INITIAL_R2T_EN		(1 << ISCSI_PARAM_INITIAL_R2T_EN)
+#define ISCSI_MAX_R2T			(1 << ISCSI_PARAM_MAX_R2T)
+#define ISCSI_IMM_DATA_EN		(1 << ISCSI_PARAM_IMM_DATA_EN)
+#define ISCSI_FIRST_BURST		(1 << ISCSI_PARAM_FIRST_BURST)
+#define ISCSI_MAX_BURST			(1 << ISCSI_PARAM_MAX_BURST)
+#define ISCSI_PDU_INORDER_EN		(1 << ISCSI_PARAM_PDU_INORDER_EN)
+#define ISCSI_DATASEQ_INORDER_EN	(1 << ISCSI_PARAM_DATASEQ_INORDER_EN)
+#define ISCSI_ERL			(1 << ISCSI_PARAM_ERL)
+#define ISCSI_IFMARKER_EN		(1 << ISCSI_PARAM_IFMARKER_EN)
+#define ISCSI_OFMARKER_EN		(1 << ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_EXP_STATSN		(1 << ISCSI_PARAM_EXP_STATSN)
+#define ISCSI_TARGET_NAME		(1 << ISCSI_PARAM_TARGET_NAME)
+#define ISCSI_TPGT			(1 << ISCSI_PARAM_TPGT)
+#define ISCSI_PERSISTENT_ADDRESS	(1 << ISCSI_PARAM_PERSISTENT_ADDRESS)
+#define ISCSI_PERSISTENT_PORT		(1 << ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_SESS_RECOVERY_TMO		(1 << ISCSI_PARAM_SESS_RECOVERY_TMO)
+#define ISCSI_CONN_PORT			(1 << ISCSI_PARAM_CONN_PORT)
+#define ISCSI_CONN_ADDRESS		(1 << ISCSI_PARAM_CONN_ADDRESS)
+
+#define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
+#define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_hostdata - get LLD hostdata from scsi_host
+ * @_hostdata: pointer to scsi host's hostdata
+ **/
+#define iscsi_hostdata(_hostdata) ((void*)_hostdata + sizeof(unsigned long))
+
+/*
+ * These flags presents iSCSI Data-Path capabilities.
+ */
+#define CAP_RECOVERY_L0		0x1
+#define CAP_RECOVERY_L1		0x2
+#define CAP_RECOVERY_L2		0x4
+#define CAP_MULTI_R2T		0x8
+#define CAP_HDRDGST		0x10
+#define CAP_DATADGST		0x20
+#define CAP_MULTI_CONN		0x40
+#define CAP_TEXT_NEGO		0x80
+#define CAP_MARKERS		0x100
+
+/*
+ * These flags describes reason of stop_conn() call
+ */
+#define STOP_CONN_TERM		0x1
+#define STOP_CONN_SUSPEND	0x2
+#define STOP_CONN_RECOVER	0x3
+
+#define ISCSI_STATS_CUSTOM_MAX		32
+#define ISCSI_STATS_CUSTOM_DESC_MAX	64
+struct iscsi_stats_custom {
+	char desc[ISCSI_STATS_CUSTOM_DESC_MAX];
+	uint64_t value;
+};
+
+/*
+ * struct iscsi_stats - iSCSI Statistics (iSCSI MIB)
+ *
+ * Note: this structure contains counters collected on per-connection basis.
+ */
+struct iscsi_stats {
+	/* octets */
+	uint64_t txdata_octets;
+	uint64_t rxdata_octets;
+
+	/* xmit pdus */
+	uint32_t noptx_pdus;
+	uint32_t scsicmd_pdus;
+	uint32_t tmfcmd_pdus;
+	uint32_t login_pdus;
+	uint32_t text_pdus;
+	uint32_t dataout_pdus;
+	uint32_t logout_pdus;
+	uint32_t snack_pdus;
+
+	/* recv pdus */
+	uint32_t noprx_pdus;
+	uint32_t scsirsp_pdus;
+	uint32_t tmfrsp_pdus;
+	uint32_t textrsp_pdus;
+	uint32_t datain_pdus;
+	uint32_t logoutrsp_pdus;
+	uint32_t r2t_pdus;
+	uint32_t async_pdus;
+	uint32_t rjt_pdus;
+
+	/* errors */
+	uint32_t digest_err;
+	uint32_t timeout_err;
+
+	/*
+	 * iSCSI Custom Statistics support, i.e. Transport could
+	 * extend existing MIB statistics with its own specific statistics
+	 * up to ISCSI_STATS_CUSTOM_MAX
+	 */
+	uint32_t custom_length;
+	struct iscsi_stats_custom custom[0]
+		__attribute__ ((aligned (sizeof(uint64_t))));
+};
+
+#endif

Added: branches/user-iscsi/usr/include/iscsi_proto.h
===================================================================
--- branches/user-iscsi/usr/include/iscsi_proto.h	2006-08-20 19:00:24 UTC (rev 535)
+++ branches/user-iscsi/usr/include/iscsi_proto.h	2006-08-20 19:15:18 UTC (rev 536)
@@ -0,0 +1,587 @@
+/*
+ * RFC 3720 (iSCSI) protocol data types
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_PROTO_H
+#define ISCSI_PROTO_H
+
+#define ISCSI_DRAFT20_VERSION	0x00
+
+/* default iSCSI listen port for incoming connections */
+#define ISCSI_LISTEN_PORT	3260
+
+/* Padding word length */
+#define PAD_WORD_LEN		4
+
+/*
+ * useful common(control and data pathes) macro
+ */
+#define ntoh24(p) (((p)[0] << 16) | ((p)[1] << 8) | ((p)[2]))
+#define hton24(p, v) { \
+        p[0] = (((v) >> 16) & 0xFF); \
+        p[1] = (((v) >> 8) & 0xFF); \
+        p[2] = ((v) & 0xFF); \
+}
+#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
+
+/*
+ * iSCSI Template Message Header
+ */
+struct iscsi_hdr {
+	uint8_t		opcode;
+	uint8_t		flags;		/* Final bit */
+	uint8_t		rsvd2[2];
+	uint8_t		hlength;	/* AHSs total length */
+	uint8_t		dlength[3];	/* Data length */
+	uint8_t		lun[8];
+	__be32		itt;		/* Initiator Task Tag */
+	__be32		ttt;		/* Target Task Tag */
+	__be32		statsn;
+	__be32		exp_statsn;
+	__be32		max_statsn;
+	uint8_t		other[12];
+};
+
+/************************* RFC 3720 Begin *****************************/
+
+#define ISCSI_RESERVED_TAG		0xffffffff
+
+/* Opcode encoding bits */
+#define ISCSI_OP_RETRY			0x80
+#define ISCSI_OP_IMMEDIATE		0x40
+#define ISCSI_OPCODE_MASK		0x3F
+
+/* Initiator Opcode values */
+#define ISCSI_OP_NOOP_OUT		0x00
+#define ISCSI_OP_SCSI_CMD		0x01
+#define ISCSI_OP_SCSI_TMFUNC		0x02
+#define ISCSI_OP_LOGIN			0x03
+#define ISCSI_OP_TEXT			0x04
+#define ISCSI_OP_SCSI_DATA_OUT		0x05
+#define ISCSI_OP_LOGOUT			0x06
+#define ISCSI_OP_SNACK			0x10
+
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
+/* Target Opcode values */
+#define ISCSI_OP_NOOP_IN		0x20
+#define ISCSI_OP_SCSI_CMD_RSP		0x21
+#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
+#define ISCSI_OP_LOGIN_RSP		0x23
+#define ISCSI_OP_TEXT_RSP		0x24
+#define ISCSI_OP_SCSI_DATA_IN		0x25
+#define ISCSI_OP_LOGOUT_RSP		0x26
+#define ISCSI_OP_R2T			0x31
+#define ISCSI_OP_ASYNC_EVENT		0x32
+#define ISCSI_OP_REJECT			0x3f
+
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
+/* iSCSI PDU Header */
+struct iscsi_cmd {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16 rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32 itt;	/* Initiator Task Tag */
+	__be32 data_length;
+	__be32 cmdsn;
+	__be32 exp_statsn;
+	uint8_t cdb[16];	/* SCSI Command Block */
+	/* Additional Data (Command Dependent) */
+};
+
+/* Command PDU flags */
+#define ISCSI_FLAG_CMD_FINAL		0x80
+#define ISCSI_FLAG_CMD_READ		0x40
+#define ISCSI_FLAG_CMD_WRITE		0x20
+#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
+
+/* SCSI Command Attribute values */
+#define ISCSI_ATTR_UNTAGGED		0
+#define ISCSI_ATTR_SIMPLE		1
+#define ISCSI_ATTR_ORDERED		2
+#define ISCSI_ATTR_HEAD_OF_QUEUE	3
+#define ISCSI_ATTR_ACA			4
+
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
+/* SCSI Response Header */
+struct iscsi_cmd_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd1;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	exp_datasn;
+	__be32	bi_residual_count;
+	__be32	residual_count;
+	/* Response or Sense Data (optional) */
+};
+
+/* Command Response PDU flags */
+#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
+#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
+#define ISCSI_FLAG_CMD_OVERFLOW		0x04
+#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
+
+/* iSCSI Status values. Valid if Rsp Selector bit is not set */
+#define ISCSI_STATUS_CMD_COMPLETED	0
+#define ISCSI_STATUS_TARGET_FAILURE	1
+#define ISCSI_STATUS_SUBSYS_FAILURE	2
+
+/* Asynchronous Event Header */
+struct iscsi_async {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	uint8_t rsvd4[8];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t async_event;
+	uint8_t async_vcode;
+	__be16	param1;
+	__be16	param2;
+	__be16	param3;
+	uint8_t rsvd5[4];
+};
+
+/* iSCSI Event Codes */
+#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
+#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
+#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
+#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
+#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
+#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
+
+/* NOP-Out Message */
+struct iscsi_nopout {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* NOP-In Message */
+struct iscsi_nopin {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd4[12];
+};
+
+/* SCSI Task Management Message Header */
+struct iscsi_tm {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	__be32	refcmdsn;
+	__be32	exp_datasn;
+	uint8_t rsvd2[8];
+};
+
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
+
+/* Function values */
+#define ISCSI_TM_FUNC_ABORT_TASK		1
+#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
+#define ISCSI_TM_FUNC_CLEAR_ACA			3
+#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
+#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
+#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
+#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
+#define ISCSI_TM_FUNC_TASK_REASSIGN		8
+
+/* SCSI Task Management Response Header */
+struct iscsi_tm_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Response values below */
+	uint8_t qualifier;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd3[12];
+};
+
+/* Response values */
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
+
+/* Ready To Transfer Header */
+struct iscsi_r2t_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t	hlength;
+	uint8_t	dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	r2tsn;
+	__be32	data_offset;
+	__be32	data_length;
+};
+
+/* SCSI Data Hdr */
+struct iscsi_data {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	rsvd4;
+	__be32	exp_statsn;
+	__be32	rsvd5;
+	__be32	datasn;
+	__be32	offset;
+	__be32	rsvd6;
+	/* Payload */
+};
+
+/* SCSI Data Response Hdr */
+struct iscsi_data_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	__be32	offset;
+	__be32	residual_count;
+};
+
+/* Data Response PDU flags */
+#define ISCSI_FLAG_DATA_ACK		0x40
+#define ISCSI_FLAG_DATA_OVERFLOW	0x04
+#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
+#define ISCSI_FLAG_DATA_STATUS		0x01
+
+/* Text Header */
+struct iscsi_text {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+	/* Text - key=value pairs */
+};
+
+#define ISCSI_FLAG_TEXT_CONTINUE	0x40
+
+/* Text Response Header */
+struct iscsi_text_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd5[12];
+	/* Text Response - key:value pairs */
+};
+
+/* Login Header */
+struct iscsi_login {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t min_version;	/* Min. version supported */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	__be16	rsvd3;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+};
+
+/* Login PDU flags */
+#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
+#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
+#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
+#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
+
+#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
+	((flags & ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) >> 2)
+#define ISCSI_LOGIN_NEXT_STAGE(flags) \
+	(flags & ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
+
+/* Login Response Header */
+struct iscsi_login_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t active_version;	/* Active version */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd3;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t status_class;	/* see Login RSP ststus classes below */
+	uint8_t status_detail;	/* see Login RSP Status details below */
+	uint8_t rsvd4[10];
+};
+
+/* Login stage (phase) codes for CSG, NSG */
+#define ISCSI_INITIAL_LOGIN_STAGE		-1
+#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
+#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
+#define ISCSI_FULL_FEATURE_PHASE		3
+
+/* Login Status response classes */
+#define ISCSI_STATUS_CLS_SUCCESS		0x00
+#define ISCSI_STATUS_CLS_REDIRECT		0x01
+#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
+#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
+
+/* Login Status response detail codes */
+/* Class-0 (Success) */
+#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
+
+/* Class-1 (Redirection) */
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
+
+/* Class-2 (Initiator Error) */
+#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
+#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
+#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
+#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
+#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
+#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
+#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
+#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
+#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
+#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
+#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
+#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
+
+/* Class-3 (Target Error) */
+#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
+#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
+#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
+
+/* Logout Header */
+struct iscsi_logout {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	uint8_t rsvd3[2];
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* Logout PDU flags */
+#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
+
+/* logout reason_code values */
+
+#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
+#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
+#define ISCSI_LOGOUT_REASON_RECOVERY		2
+#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
+
+/* Logout Response Header */
+struct iscsi_logout_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Logout response values below */
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd4;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	rsvd5;
+	__be16	t2wait;
+	__be16	t2retain;
+	__be32	rsvd6;
+};
+
+/* logout response status values */
+
+#define ISCSI_LOGOUT_SUCCESS			0
+#define ISCSI_LOGOUT_CID_NOT_FOUND		1
+#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
+#define ISCSI_LOGOUT_CLEANUP_FAILED		3
+
+/* SNACK Header */
+struct iscsi_snack {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[14];
+	__be32	itt;
+	__be32	begrun;
+	__be32	runlength;
+	__be32	exp_statsn;
+	__be32	rsvd3;
+	__be32	exp_datasn;
+	uint8_t rsvd6[8];
+};
+
+/* SNACK PDU flags */
+#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
+
+/* Reject Message Header */
+struct iscsi_reject {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t reason;
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32  ffffffff;
+	uint8_t rsvd4[4];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	uint8_t rsvd5[8];
+	/* Text - Rejected hdr */
+};
+
+/* Reason for Reject */
+#define ISCSI_REASON_CMD_BEFORE_LOGIN	1
+#define ISCSI_REASON_DATA_DIGEST_ERROR	2
+#define ISCSI_REASON_DATA_SNACK_REJECT	3
+#define ISCSI_REASON_PROTOCOL_ERROR	4
+#define ISCSI_REASON_CMD_NOT_SUPPORTED	5
+#define ISCSI_REASON_IMM_CMD_REJECT		6
+#define ISCSI_REASON_TASK_IN_PROGRESS	7
+#define ISCSI_REASON_INVALID_SNACK		8
+#define ISCSI_REASON_BOOKMARK_INVALID	9
+#define ISCSI_REASON_BOOKMARK_NO_RESOURCES	10
+#define ISCSI_REASON_NEGOTIATION_RESET	11
+
+/* Max. number of Key=Value pairs in a text message */
+#define MAX_KEY_VALUE_PAIRS	8192
+
+/* maximum length for text keys/values */
+#define KEY_MAXLEN		64
+#define VALUE_MAXLEN		255
+#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
+
+#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
+
+/************************* RFC 3720 End *****************************/
+
+#endif /* ISCSI_PROTO_H */

Added: branches/user-iscsi/usr/include/scsi.h
===================================================================
--- branches/user-iscsi/usr/include/scsi.h	2006-08-20 19:00:24 UTC (rev 535)
+++ branches/user-iscsi/usr/include/scsi.h	2006-08-20 19:15:18 UTC (rev 536)
@@ -0,0 +1,436 @@
+/*
+ * This header file contains public constants and structures used by
+ * the scsi code for linux.
+ *
+ * For documentation on the OPCODES, MESSAGES, and SENSE values,
+ * please consult the SCSI standard.
+ */
+#ifndef _SCSI_SCSI_H
+#define _SCSI_SCSI_H
+
+#include <linux/types.h>
+
+/*
+ *	The maximum sg list length SCSI can cope with
+ *	(currently must be a power of 2 between 32 and 256)
+ */
+#define SCSI_MAX_PHYS_SEGMENTS	MAX_PHYS_SEGMENTS
+
+
+/*
+ *	SCSI command lengths
+ */
+
+extern const unsigned char scsi_command_size[8];
+#define COMMAND_SIZE(opcode) scsi_command_size[((opcode) >> 5) & 7]
+
+/*
+ *	SCSI device types
+ */
+
+#define MAX_SCSI_DEVICE_CODE 15
+extern const char *const scsi_device_types[MAX_SCSI_DEVICE_CODE];
+
+/*
+ * Special value for scanning to specify scanning or rescanning of all
+ * possible channels, (target) ids, or luns on a given shost.
+ */
+#define SCAN_WILD_CARD	~0
+
+/*
+ *      SCSI opcodes
+ */
+
+#define TEST_UNIT_READY       0x00
+#define REZERO_UNIT           0x01
+#define REQUEST_SENSE         0x03
+#define FORMAT_UNIT           0x04
+#define READ_BLOCK_LIMITS     0x05
+#define REASSIGN_BLOCKS       0x07
+#define INITIALIZE_ELEMENT_STATUS 0x07
+#define READ_6                0x08
+#define WRITE_6               0x0a
+#define SEEK_6                0x0b
+#define READ_REVERSE          0x0f
+#define WRITE_FILEMARKS       0x10
+#define SPACE                 0x11
+#define INQUIRY               0x12
+#define RECOVER_BUFFERED_DATA 0x14
+#define MODE_SELECT           0x15
+#define RESERVE               0x16
+#define RELEASE               0x17
+#define COPY                  0x18
+#define ERASE                 0x19
+#define MODE_SENSE            0x1a
+#define START_STOP            0x1b
+#define RECEIVE_DIAGNOSTIC    0x1c
+#define SEND_DIAGNOSTIC       0x1d
+#define ALLOW_MEDIUM_REMOVAL  0x1e
+
+#define SET_WINDOW            0x24
+#define READ_CAPACITY         0x25
+#define READ_10               0x28
+#define WRITE_10              0x2a
+#define SEEK_10               0x2b
+#define POSITION_TO_ELEMENT   0x2b
+#define WRITE_VERIFY          0x2e
+#define VERIFY                0x2f
+#define SEARCH_HIGH           0x30
+#define SEARCH_EQUAL          0x31
+#define SEARCH_LOW            0x32
+#define SET_LIMITS            0x33
+#define PRE_FETCH             0x34
+#define READ_POSITION         0x34
+#define SYNCHRONIZE_CACHE     0x35
+#define LOCK_UNLOCK_CACHE     0x36
+#define READ_DEFECT_DATA      0x37
+#define MEDIUM_SCAN           0x38
+#define COMPARE               0x39
+#define COPY_VERIFY           0x3a
+#define WRITE_BUFFER          0x3b
+#define READ_BUFFER           0x3c
+#define UPDATE_BLOCK          0x3d
+#define READ_LONG             0x3e
+#define WRITE_LONG            0x3f
+#define CHANGE_DEFINITION     0x40
+#define WRITE_SAME            0x41
+#define READ_TOC              0x43
+#define LOG_SELECT            0x4c
+#define LOG_SENSE             0x4d
+#define MODE_SELECT_10        0x55
+#define RESERVE_10            0x56
+#define RELEASE_10            0x57
+#define MODE_SENSE_10         0x5a
+#define PERSISTENT_RESERVE_IN 0x5e
+#define PERSISTENT_RESERVE_OUT 0x5f
+#define REPORT_LUNS           0xa0
+#define MOVE_MEDIUM           0xa5
+#define EXCHANGE_MEDIUM       0xa6
+#define READ_12               0xa8
+#define WRITE_12              0xaa
+#define WRITE_VERIFY_12       0xae
+#define SEARCH_HIGH_12        0xb0
+#define SEARCH_EQUAL_12       0xb1
+#define SEARCH_LOW_12         0xb2
+#define READ_ELEMENT_STATUS   0xb8
+#define SEND_VOLUME_TAG       0xb6
+#define WRITE_LONG_2          0xea
+#define READ_16               0x88
+#define WRITE_16              0x8a
+#define VERIFY_16	      0x8f
+#define SERVICE_ACTION_IN     0x9e
+/* values for service action in */
+#define	SAI_READ_CAPACITY_16  0x10
+
+/* Values for T10/04-262r7 */
+#define	ATA_16		      0x85	/* 16-byte pass-thru */
+#define	ATA_12		      0xa1	/* 12-byte pass-thru */
+
+/*
+ *  SCSI Architecture Model (SAM) Status codes. Taken from SAM-3 draft
+ *  T10/1561-D Revision 4 Draft dated 7th November 2002.
+ */
+#define SAM_STAT_GOOD            0x00
+#define SAM_STAT_CHECK_CONDITION 0x02
+#define SAM_STAT_CONDITION_MET   0x04
+#define SAM_STAT_BUSY            0x08
+#define SAM_STAT_INTERMEDIATE    0x10
+#define SAM_STAT_INTERMEDIATE_CONDITION_MET 0x14
+#define SAM_STAT_RESERVATION_CONFLICT 0x18
+#define SAM_STAT_COMMAND_TERMINATED 0x22	/* obsolete in SAM-3 */
+#define SAM_STAT_TASK_SET_FULL   0x28
+#define SAM_STAT_ACA_ACTIVE      0x30
+#define SAM_STAT_TASK_ABORTED    0x40
+
+/** scsi_status_is_good - check the status return.
+ *
+ * @status: the status passed up from the driver (including host and
+ *          driver components)
+ *
+ * This returns true for known good conditions that may be treated as
+ * command completed normally
+ */
+static inline int scsi_status_is_good(int status)
+{
+	/*
+	 * FIXME: bit0 is listed as reserved in SCSI-2, but is
+	 * significant in SCSI-3.  For now, we follow the SCSI-2
+	 * behaviour and ignore reserved bits.
+	 */
+	status &= 0xfe;
+	return ((status == SAM_STAT_GOOD) ||
+		(status == SAM_STAT_INTERMEDIATE) ||
+		(status == SAM_STAT_INTERMEDIATE_CONDITION_MET) ||
+		/* FIXME: this is obsolete in SAM-3 */
+		(status == SAM_STAT_COMMAND_TERMINATED));
+}
+
+/*
+ *  Status codes. These are deprecated as they are shifted 1 bit right
+ *  from those found in the SCSI standards. This causes confusion for
+ *  applications that are ported to several OSes. Prefer SAM Status codes
+ *  above.
+ */
+
+#define GOOD                 0x00
+#define CHECK_CONDITION      0x01
+#define CONDITION_GOOD       0x02
+#define BUSY                 0x04
+#define INTERMEDIATE_GOOD    0x08
+#define INTERMEDIATE_C_GOOD  0x0a
+#define RESERVATION_CONFLICT 0x0c
+#define COMMAND_TERMINATED   0x11
+#define QUEUE_FULL           0x14
+#define ACA_ACTIVE           0x18
+#define TASK_ABORTED         0x20
+
+#define STATUS_MASK          0xfe
+
+/*
+ *  SENSE KEYS
+ */
+
+#define NO_SENSE            0x00
+#define RECOVERED_ERROR     0x01
+#define NOT_READY           0x02
+#define MEDIUM_ERROR        0x03
+#define HARDWARE_ERROR      0x04
+#define ILLEGAL_REQUEST     0x05
+#define UNIT_ATTENTION      0x06
+#define DATA_PROTECT        0x07
+#define BLANK_CHECK         0x08
+#define COPY_ABORTED        0x0a
+#define ABORTED_COMMAND     0x0b
+#define VOLUME_OVERFLOW     0x0d
+#define MISCOMPARE          0x0e
+
+
+/*
+ *  DEVICE TYPES
+ */
+
+#define TYPE_DISK           0x00
+#define TYPE_TAPE           0x01
+#define TYPE_PRINTER        0x02
+#define TYPE_PROCESSOR      0x03    /* HP scanners use this */
+#define TYPE_WORM           0x04    /* Treated as ROM by our system */
+#define TYPE_ROM            0x05
+#define TYPE_SCANNER        0x06
+#define TYPE_MOD            0x07    /* Magneto-optical disk - 
+				     * - treated as TYPE_DISK */
+#define TYPE_MEDIUM_CHANGER 0x08
+#define TYPE_COMM           0x09    /* Communications device */
+#define TYPE_RAID           0x0c
+#define TYPE_ENCLOSURE      0x0d    /* Enclosure Services Device */
+#define TYPE_RBC	    0x0e
+#define TYPE_NO_LUN         0x7f
+
+/*
+ * standard mode-select header prepended to all mode-select commands
+ */
+
+struct ccs_modesel_head {
+	__u8 _r1;			/* reserved */
+	__u8 medium;		/* device-specific medium type */
+	__u8 _r2;			/* reserved */
+	__u8 block_desc_length;	/* block descriptor length */
+	__u8 density;		/* device-specific density code */
+	__u8 number_blocks_hi;	/* number of blocks in this block desc */
+	__u8 number_blocks_med;
+	__u8 number_blocks_lo;
+	__u8 _r3;
+	__u8 block_length_hi;	/* block length for blocks in this desc */
+	__u8 block_length_med;
+	__u8 block_length_lo;
+};
+
+/*
+ * ScsiLun: 8 byte LUN.
+ */
+struct scsi_lun {
+	__u8 scsi_lun[8];
+};
+
+/*
+ *  MESSAGE CODES
+ */
+
+#define COMMAND_COMPLETE    0x00
+#define EXTENDED_MESSAGE    0x01
+#define     EXTENDED_MODIFY_DATA_POINTER    0x00
+#define     EXTENDED_SDTR                   0x01
+#define     EXTENDED_EXTENDED_IDENTIFY      0x02    /* SCSI-I only */
+#define     EXTENDED_WDTR                   0x03
+#define     EXTENDED_PPR                    0x04
+#define     EXTENDED_MODIFY_BIDI_DATA_PTR   0x05
+#define SAVE_POINTERS       0x02
+#define RESTORE_POINTERS    0x03
+#define DISCONNECT          0x04
+#define INITIATOR_ERROR     0x05
+#define ABORT_TASK_SET      0x06
+#define MESSAGE_REJECT      0x07
+#define NOP                 0x08
+#define MSG_PARITY_ERROR    0x09
+#define LINKED_CMD_COMPLETE 0x0a
+#define LINKED_FLG_CMD_COMPLETE 0x0b
+#define TARGET_RESET        0x0c
+#define ABORT_TASK          0x0d
+#define CLEAR_TASK_SET      0x0e
+#define INITIATE_RECOVERY   0x0f            /* SCSI-II only */
+#define RELEASE_RECOVERY    0x10            /* SCSI-II only */
+#define CLEAR_ACA           0x16
+#define LOGICAL_UNIT_RESET  0x17
+#define SIMPLE_QUEUE_TAG    0x20
+#define HEAD_OF_QUEUE_TAG   0x21
+#define ORDERED_QUEUE_TAG   0x22
+#define IGNORE_WIDE_RESIDUE 0x23
+#define ACA                 0x24
+#define QAS_REQUEST         0x55
+
+/* Old SCSI2 names, don't use in new code */
+#define BUS_DEVICE_RESET    TARGET_RESET
+#define ABORT               ABORT_TASK_SET
+
+/*
+ * Host byte codes
+ */
+
+#define DID_OK          0x00	/* NO error                                */
+#define DID_NO_CONNECT  0x01	/* Couldn't connect before timeout period  */
+#define DID_BUS_BUSY    0x02	/* BUS stayed busy through time out period */
+#define DID_TIME_OUT    0x03	/* TIMED OUT for other reason              */
+#define DID_BAD_TARGET  0x04	/* BAD target.                             */
+#define DID_ABORT       0x05	/* Told to abort for some other reason     */
+#define DID_PARITY      0x06	/* Parity error                            */
+#define DID_ERROR       0x07	/* Internal error                          */
+#define DID_RESET       0x08	/* Reset by somebody.                      */
+#define DID_BAD_INTR    0x09	/* Got an interrupt we weren't expecting.  */
+#define DID_PASSTHROUGH 0x0a	/* Force command past mid-layer            */
+#define DID_SOFT_ERROR  0x0b	/* The low level driver just wish a retry  */
+#define DID_IMM_RETRY   0x0c	/* Retry without decrementing retry count  */
+#define DID_REQUEUE	0x0d	/* Requeue command (no immediate retry) also
+				 * without decrementing the retry count	   */
+#define DRIVER_OK       0x00	/* Driver status                           */
+
+/*
+ *  These indicate the error that occurred, and what is available.
+ */
+
+#define DRIVER_BUSY         0x01
+#define DRIVER_SOFT         0x02
+#define DRIVER_MEDIA        0x03
+#define DRIVER_ERROR        0x04
+
+#define DRIVER_INVALID      0x05
+#define DRIVER_TIMEOUT      0x06
+#define DRIVER_HARD         0x07
+#define DRIVER_SENSE	    0x08
+
+#define SUGGEST_RETRY       0x10
+#define SUGGEST_ABORT       0x20
+#define SUGGEST_REMAP       0x30
+#define SUGGEST_DIE         0x40
+#define SUGGEST_SENSE       0x80
+#define SUGGEST_IS_OK       0xff
+
+#define DRIVER_MASK         0x0f
+#define SUGGEST_MASK        0xf0
+
+/*
+ * Internal return values.
+ */
+
+#define NEEDS_RETRY     0x2001
+#define SUCCESS         0x2002
+#define FAILED          0x2003
+#define QUEUED          0x2004
+#define SOFT_ERROR      0x2005
+#define ADD_TO_MLQUEUE  0x2006
+#define TIMEOUT_ERROR   0x2007
+
+/*
+ * Midlevel queue return values.
+ */
+#define SCSI_MLQUEUE_HOST_BUSY   0x1055
+#define SCSI_MLQUEUE_DEVICE_BUSY 0x1056
+#define SCSI_MLQUEUE_EH_RETRY    0x1057
+
+/*
+ *  Use these to separate status msg and our bytes
+ *
+ *  These are set by:
+ *
+ *      status byte = set from target device
+ *      msg_byte    = return status from host adapter itself.
+ *      host_byte   = set by low-level driver to indicate status.
+ *      driver_byte = set by mid-level.
+ */
+#define status_byte(result) (((result) >> 1) & 0x7f)
+#define msg_byte(result)    (((result) >> 8) & 0xff)
+#define host_byte(result)   (((result) >> 16) & 0xff)
+#define driver_byte(result) (((result) >> 24) & 0xff)
+#define suggestion(result)  (driver_byte(result) & SUGGEST_MASK)
+
+#define sense_class(sense)  (((sense) >> 4) & 0x7)
+#define sense_error(sense)  ((sense) & 0xf)
+#define sense_valid(sense)  ((sense) & 0x80);
+
+/*
+ * default timeouts
+*/
+#define FORMAT_UNIT_TIMEOUT		(2 * 60 * 60 * HZ)
+#define START_STOP_TIMEOUT		(60 * HZ)
+#define MOVE_MEDIUM_TIMEOUT		(5 * 60 * HZ)
+#define READ_ELEMENT_STATUS_TIMEOUT	(5 * 60 * HZ)
+#define READ_DEFECT_DATA_TIMEOUT	(60 * HZ )
+
+
+#define IDENTIFY_BASE       0x80
+#define IDENTIFY(can_disconnect, lun)   (IDENTIFY_BASE |\
+		     ((can_disconnect) ?  0x40 : 0) |\
+		     ((lun) & 0x07))
+
+/*
+ *  struct scsi_device::scsi_level values. For SCSI devices other than those
+ *  prior to SCSI-2 (i.e. over 12 years old) this value is (resp[2] + 1)
+ *  where "resp" is a byte array of the response to an INQUIRY. The scsi_level
+ *  variable is visible to the user via sysfs.
+ */
+
+#define SCSI_UNKNOWN    0
+#define SCSI_1          1
+#define SCSI_1_CCS      2
+#define SCSI_2          3
+#define SCSI_3          4        /* SPC */
+#define SCSI_SPC_2      5
+#define SCSI_SPC_3      6
+
+/*
+ * INQ PERIPHERAL QUALIFIERS
+ */
+#define SCSI_INQ_PQ_CON         0x00
+#define SCSI_INQ_PQ_NOT_CON     0x01
+#define SCSI_INQ_PQ_NOT_CAP     0x03
+
+
+/*
+ * Here are some scsi specific ioctl commands which are sometimes useful.
+ *
+ * Note that include/linux/cdrom.h also defines IOCTL 0x5300 - 0x5395
+ */
+
+/* Used to obtain PUN and LUN info.  Conflicts with CDROMAUDIOBUFSIZ */
+#define SCSI_IOCTL_GET_IDLUN		0x5382
+
+/* 0x5383 and 0x5384 were used for SCSI_IOCTL_TAGGED_{ENABLE,DISABLE} */
+
+/* Used to obtain the host number of a device. */
+#define SCSI_IOCTL_PROBE_HOST		0x5385
+
+/* Used to obtain the bus number for a device */
+#define SCSI_IOCTL_GET_BUS_NUMBER	0x5386
+
+/* Used to obtain the PCI location of a device */
+#define SCSI_IOCTL_GET_PCI		0x5387
+
+#endif /* _SCSI_SCSI_H */



From tomo at mail.berlios.de  Sun Aug 20 21:54:27 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 21:54:27 +0200
Subject: [Stgt-svn] r537 - branches/user-iscsi/usr/iscsi
Message-ID: <200608201954.k7KJsRP9031405@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 21:54:26 +0200 (Sun, 20 Aug 2006)
New Revision: 537

Modified:
   branches/user-iscsi/usr/iscsi/conn.c
   branches/user-iscsi/usr/iscsi/iscsid.c
   branches/user-iscsi/usr/iscsi/iscsid.h
   branches/user-iscsi/usr/iscsi/istgt.c
Log:
Honor max burst about data response.


Modified: branches/user-iscsi/usr/iscsi/conn.c
===================================================================
--- branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 19:15:18 UTC (rev 536)
+++ branches/user-iscsi/usr/iscsi/conn.c	2006-08-20 19:54:26 UTC (rev 537)
@@ -105,10 +105,11 @@
 	conn->rwsize = BHS_SIZE;
 }
 
-void conn_write_pdu(struct connection *conn)
+void conn_write_pdu(struct connection *conn, int clear)
 {
 	conn->tx_iostate = IOSTATE_WRITE_BHS;
-	memset(&conn->rsp, 0, sizeof(conn->rsp));
+	if (clear)
+		memset(&conn->rsp, 0, sizeof(conn->rsp));
 	conn->buffer = (void *)&conn->rsp.bhs;
 	conn->rwsize = BHS_SIZE;
 }

Modified: branches/user-iscsi/usr/iscsi/iscsid.c
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 19:15:18 UTC (rev 536)
+++ branches/user-iscsi/usr/iscsi/iscsid.c	2006-08-20 19:54:26 UTC (rev 537)
@@ -782,6 +782,7 @@
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
 	int residual, datalen, exp_datalen = ntohl(req->data_length);
+	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
@@ -794,22 +795,24 @@
 	rsp->cmd_status = ctask->result;
 
 	datalen = min(exp_datalen, ctask->len);
-	if (datalen > conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val)
-		eprintf("cannot handle %d %d %d %d\n",
-			datalen, exp_datalen, ctask->len,
-			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val);
+	datalen -= ctask->offset;
 
-	rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-	if (ctask->len < exp_datalen) {
-		rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-		residual = exp_datalen - ctask->len;
-	} else if (ctask->len > exp_datalen) {
-		rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-		residual = ctask->len - exp_datalen;
+	dprintf("%d %d %d %d\n", datalen, exp_datalen, ctask->len, max_burst);
+
+	if (datalen <= max_burst) {
+		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+		if (ctask->len < exp_datalen) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = exp_datalen - ctask->len;
+		} else if (ctask->len > exp_datalen) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = ctask->len - exp_datalen;
+		} else
+			residual = 0;
+		rsp->residual_count = cpu_to_be32(residual);
 	} else
-		residual = 0;
+		datalen = max_burst;
 
-	rsp->residual_count = cpu_to_be32(residual);
 	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
 		rsp->statsn = cpu_to_be32(conn->stat_sn++);
 	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
@@ -818,7 +821,10 @@
 	conn->rsp.datasize = datalen;
 	hton24(rsp->dlength, datalen);
 	conn->rsp.data = (void *) (unsigned long) ctask->addr;
+	conn->rsp.data += ctask->offset;
 
+	ctask->offset += datalen;
+
 	return 0;
 }
 
@@ -1021,13 +1027,21 @@
 	return 0;
 }
 
-void iscsi_cmd_tx_done(struct connection *conn)
+void iscsi_cmd_tx_done(struct connection *conn, int *more_rsp)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
 
+	*more_rsp = 0;
+
 	switch (hdr->opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_R2T:
 		break;
+	case ISCSI_OP_SCSI_DATA_IN:
+		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
+			iscsi_data_rsp_build(conn->ctask);
+			*more_rsp = 1;
+			return;
+		}
 	default:
 		target_cmd_done(conn->session->tsih, conn->ctask->tag);
 		list_del(&conn->ctask->c_hlist);

Modified: branches/user-iscsi/usr/iscsi/iscsid.h
===================================================================
--- branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 19:15:18 UTC (rev 536)
+++ branches/user-iscsi/usr/iscsi/iscsid.h	2006-08-20 19:54:26 UTC (rev 537)
@@ -195,7 +195,7 @@
 extern struct connection * conn_find(struct session *session, uint32_t cid);
 extern int conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
-extern void conn_write_pdu(struct connection *conn);
+extern void conn_write_pdu(struct connection *conn, int clear);
 extern void conn_free_pdu(struct connection *conn);
 extern void conn_add_to_session(struct connection *conn, struct session *session);
 
@@ -208,7 +208,7 @@
 extern void text_key_add(struct connection *conn, char *key, char *value);
 extern int iscsi_cmd_rx_start(struct connection *conn);
 extern int iscsi_cmd_rx_done(struct connection *conn, int *is_rsp);
-extern void iscsi_cmd_tx_done(struct connection *conn);
+extern void iscsi_cmd_tx_done(struct connection *conn, int *more_rsp);
 
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
@@ -222,36 +222,6 @@
 extern void target_list_build(struct connection *, char *, char *);
 extern int target_bind(int tid, int hostno);
 
-/* netlink.c */
-struct iscsi_kernel_interface {
-	int (*set_param) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, enum iscsi_param param,
-			  void *value, int len, int *retcode);
-
-	int (*create_session) (uint64_t transport_handle,
-			       uint32_t initial_cmdsn,
-			       uint32_t *out_sid, uint32_t *out_hostno);
-
-	int (*destroy_session) (uint64_t transport_handle, uint32_t sid);
-
-	int (*create_conn) (uint64_t transport_handle,
-			    uint32_t sid, uint32_t cid, uint32_t *out_cid);
-	int (*destroy_conn) (uint64_t transport_handle, uint32_t sid,
-			     uint32_t cid);
-	int (*bind_conn) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, uint64_t transport_eph,
-			  int is_leading, int *retcode);
-	int (*start_conn) (uint64_t transport_handle, uint32_t sid,
-			   uint32_t cid, int *retcode);
-
-	int (*stop_conn) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, int flag);
-};
-
-extern int iscsi_nl_init(void);
-
-extern struct iscsi_kernel_interface *ki;
-
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 

Modified: branches/user-iscsi/usr/iscsi/istgt.c
===================================================================
--- branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 19:15:18 UTC (rev 536)
+++ branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 19:54:26 UTC (rev 537)
@@ -220,7 +220,7 @@
 
 				dprintf("done\n");
 
-				conn_write_pdu(conn);
+				conn_write_pdu(conn, 0);
 				pfd->events = POLLOUT;
 				res = iscsi_cmd_rx_done(conn, &rsp);
 				if (!res && !rsp) {
@@ -228,7 +228,7 @@
 					pfd->events = POLLIN;
 				}
 			} else {
-				conn_write_pdu(conn);
+				conn_write_pdu(conn, 1);
 				pfd->events = POLLOUT;
 				res = cmnd_execute(conn);
 			}
@@ -243,7 +243,7 @@
 
 static void iscsi_tx(struct pollfd *pfd, struct connection *conn)
 {
-	int opt, res;
+	int opt, res, more_rsp;
 
 	switch (conn->tx_iostate) {
 	case IOSTATE_WRITE_BHS:
@@ -311,7 +311,11 @@
 			case STATE_CLOSE:
 				break;
 			case STATE_SCSI:
-				iscsi_cmd_tx_done(conn);
+				iscsi_cmd_tx_done(conn, &more_rsp);
+				if (more_rsp) {
+					conn_write_pdu(conn, 0);
+					goto write_again;
+				}
 			default:
 				conn_read_pdu(conn);
 				pfd->events = POLLIN;



From tomo at mail.berlios.de  Sun Aug 20 22:16:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 20 Aug 2006 22:16:57 +0200
Subject: [Stgt-svn] r538 - branches/user-iscsi/usr/iscsi
Message-ID: <200608202016.k7KKGv4r009091@sheep.berlios.de>

Author: tomo
Date: 2006-08-20 22:16:57 +0200 (Sun, 20 Aug 2006)
New Revision: 538

Modified:
   branches/user-iscsi/usr/iscsi/istgt.c
Log:
Fix tx bug.

Modified: branches/user-iscsi/usr/iscsi/istgt.c
===================================================================
--- branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 19:54:26 UTC (rev 537)
+++ branches/user-iscsi/usr/iscsi/istgt.c	2006-08-20 20:16:57 UTC (rev 538)
@@ -218,9 +218,7 @@
 			if (conn->state == STATE_SCSI) {
 				int rsp;
 
-				dprintf("done\n");
-
-				conn_write_pdu(conn, 0);
+				conn_write_pdu(conn, 1);
 				pfd->events = POLLOUT;
 				res = iscsi_cmd_rx_done(conn, &rsp);
 				if (!res && !rsp) {



From tomo at mail.berlios.de  Thu Aug 24 11:49:55 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 24 Aug 2006 11:49:55 +0200
Subject: [Stgt-svn] r539 - trunk/usr
Message-ID: <200608240949.k7O9nt4M010738@sheep.berlios.de>

Author: tomo
Date: 2006-08-24 11:49:55 +0200 (Thu, 24 Aug 2006)
New Revision: 539

Modified:
   trunk/usr/tgtd.c
Log:
Use daemon() instead of own function.

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-20 20:16:57 UTC (rev 538)
+++ trunk/usr/tgtd.c	2006-08-24 09:49:55 UTC (rev 539)
@@ -76,26 +76,6 @@
 static void signal_catch(int signo) {
 }
 
-static int daemonize(void)
-{
-	pid_t pid;
-
-	pid = fork();
-	if (pid < 0)
-		return -ENOMEM;
-	else if (pid)
-		exit(0);
-
-	setsid();
-	chdir("/");
-	close(0);
-	open("/dev/null", O_RDWR);
-	dup2(0, 1);
-	dup2(0, 2);
-
-	return 0;
-}
-
 static void oom_adjust(void)
 {
 	int fd;
@@ -267,7 +247,7 @@
 		exit(1);
 	}
 
-	if (is_daemon && daemonize())
+	if (is_daemon && daemon(0,0))
 		exit(1);
 
 	oom_adjust();



From tomo at mail.berlios.de  Sat Aug 26 05:53:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 26 Aug 2006 05:53:17 +0200
Subject: [Stgt-svn] r540 - trunk/usr
Message-ID: <200608260353.k7Q3rHHf002009@sheep.berlios.de>

Author: tomo
Date: 2006-08-26 05:53:16 +0200 (Sat, 26 Aug 2006)
New Revision: 540

Modified:
   trunk/usr/tgtd.c
Log:
Rename POLL_KI POLL_KERN.

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-24 09:49:55 UTC (rev 539)
+++ trunk/usr/tgtd.c	2006-08-26 03:53:16 UTC (rev 540)
@@ -39,7 +39,7 @@
 #include "driver.h"
 
 enum {
-	POLL_KI, /* kernel interface */
+	POLL_KERN, /* kernel interface */
 	POLL_IPC, /* unix domain socket for tgtdadm */
 	POLL_END,
 };
@@ -118,7 +118,7 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_KI].revents) {
+	if (pfd[POLL_KERN].revents) {
 		kspace_event_handle();
 		nevent--;
 	}
@@ -151,8 +151,8 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_KI].fd = nl_fd;
-	pfd[POLL_KI].events = POLLIN;
+	pfd[POLL_KERN].fd = nl_fd;
+	pfd[POLL_KERN].events = POLLIN;
 	pfd[POLL_IPC].fd = ud_fd;
 	pfd[POLL_IPC].events = POLLIN;
 



From tomo at mail.berlios.de  Sat Aug 26 12:02:49 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 26 Aug 2006 12:02:49 +0200
Subject: [Stgt-svn] r541 - in trunk/usr: . iscsi
Message-ID: <200608261002.k7QA2nTL025520@sheep.berlios.de>

Author: tomo
Date: 2006-08-26 12:02:40 +0200 (Sat, 26 Aug 2006)
New Revision: 541

Modified:
   trunk/usr/iscsi/istgt.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.c
   trunk/usr/tgtif.c
   trunk/usr/util.c
Log:
Replace strerror with %m

Modified: trunk/usr/iscsi/istgt.c
===================================================================
--- trunk/usr/iscsi/istgt.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/iscsi/istgt.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -57,9 +57,9 @@
 	if (res != -1) {
 		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
 		if (res)
-			dprintf("unable to set fd flags (%s)!\n", strerror(errno));
+			dprintf("unable to set fd flags, %m\n");
 	} else
-		dprintf("unable to get fd flags (%s)!\n", strerror(errno));
+		dprintf("unable to get fd flags, %m\n");
 }
 
 static void listen_socket_create(struct pollfd *pfds)
@@ -76,35 +76,35 @@
 	hints.ai_flags = AI_PASSIVE;
 
 	if (getaddrinfo(NULL, servname, &hints, &res0)) {
-		eprintf("unable to get address info (%s)!\n", strerror(errno));
+		eprintf("unable to get address info, %m\n");
 		exit(1);
 	}
 
 	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
 		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (sock < 0) {
-			eprintf("unable to create server socket (%s) %d %d %d!\n",
-				  strerror(errno), res->ai_family,
-				  res->ai_socktype, res->ai_protocol);
+			eprintf("unable to create socket %d %d %d, %m\n",
+				res->ai_family,	res->ai_socktype,
+				res->ai_protocol);
 			continue;
 		}
 
 		opt = 1;
 		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
-			dprintf("unable to set SO_REUSEADDR on server socket (%s)!\n",
-				    strerror(errno));
+			dprintf("unable to set SO_REUSEADDR, %m\n");
+
 		opt = 1;
 		if (res->ai_family == AF_INET6 &&
 		    setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)))
 			continue;
 
 		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
-			eprintf("unable to bind server socket (%s)!\n", strerror(errno));
+			eprintf("unable to bind server socket, %m\n");
 			continue;
 		}
 
 		if (listen(sock, INCOMING_MAX)) {
-			eprintf("unable to listen to server socket (%s)!\n", strerror(errno));
+			eprintf("unable to listen to server socket, %m\n");
 			continue;
 		}
 

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/mgmt.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -155,7 +155,7 @@
 	len = sizeof(addr);
 	fd = accept(accept_fd, (struct sockaddr *) &addr, &len);
 	if (fd < 0)
-		eprintf("can't accept a new connection %s\n", strerror(errno));
+		eprintf("can't accept a new connection, %m\n");
 	return fd;
 }
 
@@ -168,7 +168,7 @@
 	len = sizeof(cred);
 	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
 	if (err) {
-		eprintf("can't get sockopt %s\n", strerror(errno));
+		eprintf("can't get sockopt, %m\n");
 		return -1;
 	}
 
@@ -192,7 +192,7 @@
 
 	err = sendmsg(fd, &msg, MSG_DONTWAIT);
 	if (err != res->len)
-		eprintf("can't write %s\n", strerror(errno));
+		eprintf("can't write, %m\n");
 }
 
 void ipc_event_handle(int accept_fd)
@@ -233,7 +233,7 @@
 		if (errno == EAGAIN)
 			goto retry;
 
-		eprintf("can't read %s\n", strerror(errno));
+		eprintf("can't read, %m\n");
 		goto out;
 	}
 
@@ -250,7 +250,7 @@
 
 	err = recvmsg(fd, &msg, MSG_DONTWAIT);
 	if (err != req->len) {
-		eprintf("can't read %s\n", strerror(errno));
+		eprintf("can't read, %m\n");
 		err = -EIO;
 		goto out;
 	}
@@ -287,7 +287,7 @@
 
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (fd < 0) {
-		eprintf("can't open a socket %s\n", strerror(errno));
+		eprintf("can't open a socket, %m\n");
 		return -1;
 	}
 
@@ -298,13 +298,13 @@
 
 	err = bind(fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err) {
-		eprintf("can't bind a socket %s\n", strerror(errno));
+		eprintf("can't bind a socket, %m\n");
 		goto out;
 	}
 
 	err = listen(fd, 32);
 	if (err < 0) {
-		eprintf("can't listen a socket %s\n", strerror(errno));
+		eprintf("can't listen a socket, %m\n");
 		goto out;
 	}
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/target.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -158,13 +158,13 @@
 
 	dev_fd = open(path, O_RDWR | O_LARGEFILE);
 	if (dev_fd < 0) {
-		eprintf("Could not open %s %s\n", path, strerror(errno));
+		eprintf("Could not open %s, %m\n", path);
 		return dev_fd;
 	}
 
 	err = fstat64(dev_fd, &st);
 	if (err < 0) {
-		printf("Cannot get stat %d %s\n", dev_fd, strerror(errno));
+		printf("Cannot get stat %d, %m\n", dev_fd);
 		goto close_dev_fd;
 	}
 
@@ -173,7 +173,7 @@
 	else if(S_ISBLK(st.st_mode)) {
 		err = ioctl(dev_fd, BLKGETSIZE64, &size);
 		if (err < 0) {
-			eprintf("Cannot get size %s\n", strerror(errno));
+			eprintf("Cannot get size, %m\n");
 			goto close_dev_fd;
 		}
 	} else {

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/tgtadm.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -129,7 +129,7 @@
 
 	*fd = socket(AF_LOCAL, SOCK_STREAM, 0);
 	if (*fd < 0) {
-		eprintf("Cannot create a socket %s\n", strerror(errno));
+		eprintf("Cannot create a socket, %m\n");
 		return -1;
 	}
 
@@ -139,7 +139,7 @@
 
 	err = connect(*fd, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
-		eprintf("Cannot connect to tgtd %s\n", strerror(errno));
+		eprintf("Cannot connect to tgtd, %m\n");
 		return -1;
 	}
 
@@ -154,7 +154,7 @@
 
 	err = read(fd, buf, len);
 	if (err < 0) {
-		eprintf("Cannot read from tgtd %s\n", strerror(errno));
+		eprintf("Cannot read from tgtd, %m\n");
 		return -1;
 	}
 
@@ -176,7 +176,7 @@
 		t = min_t(int, sizeof(buf), len);
 		err = read(fd, buf, t);
 		if (err < 0) {
-			eprintf("Cannot read from tgtd %s\n", strerror(errno));
+			eprintf("Cannot read from tgtd, %m\n");
 			return -1;
 		}
 		printf("%s", buf);
@@ -196,7 +196,7 @@
 
 	err = write(fd, (char *) req, req->len);
 	if (err < 0) {
-		eprintf("Cannot send to tgtd %s\n", strerror(errno));
+		eprintf("Cannot send to tgtd, %m\n");
 		goto out;
 	}
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/tgtd.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -107,7 +107,7 @@
 	nevent = poll(pfd, npfd, timeout);
 	if (nevent < 0) {
 		if (errno != EINTR) {
-			eprintf("%s\n", strerror(errno));
+			eprintf("%m\n");
 			exit(1);
 		}
 		goto retry;

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/tgtif.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -173,7 +173,7 @@
 
 	*fd = open(path, O_RDWR);
 	if (*fd < 0) {
-		eprintf("cannot open %s %s\n", path, strerror(errno));
+		eprintf("cannot open %s, %m\n", path);
 		goto out;
 	}
 
@@ -194,7 +194,7 @@
 
 	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
 	if (buf == MAP_FAILED) {
-		eprintf("fail to mmap %s\n", strerror(errno));
+		eprintf("fail to mmap, %m\n");
 		close(fd);
 		return -EINVAL;
 	}

Modified: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2006-08-26 03:53:16 UTC (rev 540)
+++ trunk/usr/util.c	2006-08-26 10:02:40 UTC (rev 541)
@@ -17,7 +17,7 @@
 
 	fp = fopen("/proc/devices", "r");
 	if (!fp) {
-		eprintf("Cannot open control path to the driver\n");
+		eprintf("Cannot open /proc/devices, %m\n");
 		return -1;
 	}
 
@@ -44,13 +44,13 @@
 	unlink(devpath);
 	err = mknod(devpath, (S_IFCHR | 0600), (major << 8) | minor);
 	if (err) {
-		eprintf("cannot create %s %s\n", devpath, strerror(errno));
+		eprintf("cannot create %s, %m\n", devpath);
 		return -errno;
 	}
 
 	*fd = open(devpath, O_RDWR);
 	if (*fd < 0) {
-		eprintf("cannot open %s %s\n", devpath, strerror(errno));
+		eprintf("cannot open %s, %m\n", devpath);
 		return -errno;
 	}
 



From tomo at mail.berlios.de  Sat Aug 26 12:08:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 26 Aug 2006 12:08:40 +0200
Subject: [Stgt-svn] r542 - trunk/usr
Message-ID: <200608261008.k7QA8e67025950@sheep.berlios.de>

Author: tomo
Date: 2006-08-26 12:08:40 +0200 (Sat, 26 Aug 2006)
New Revision: 542

Modified:
   trunk/usr/tgtd.c
Log:
We can continue even if kernel shared buf is not available.

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-26 10:02:40 UTC (rev 541)
+++ trunk/usr/tgtd.c	2006-08-26 10:08:40 UTC (rev 542)
@@ -141,7 +141,7 @@
 	goto retry;
 }
 
-static struct pollfd *pfd_init(int npfd, int nl_fd, int ud_fd)
+static struct pollfd *pfd_init(int npfd, int ki_fd, int ud_fd)
 {
 	struct tgt_driver *d;
 	struct pollfd *pfd;
@@ -151,8 +151,10 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_KERN].fd = nl_fd;
-	pfd[POLL_KERN].events = POLLIN;
+	if (ki_fd) {
+		pfd[POLL_KERN].fd = ki_fd;
+		pfd[POLL_KERN].events = POLLIN;
+	}
 	pfd[POLL_IPC].fd = ud_fd;
 	pfd[POLL_IPC].events = POLLIN;
 
@@ -257,8 +259,10 @@
 		exit(1);
 
 	err = kreq_init(&ki_fd);
-	if (err)
-		exit(1);
+	if (err) {
+		eprintf("No kernel interface\n");
+		ki_fd = 0;
+	}
 
 	err = ipc_init(&ipc_fd);
 	if (err)



From tomo at mail.berlios.de  Sat Aug 26 14:45:27 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 26 Aug 2006 14:45:27 +0200
Subject: [Stgt-svn] r543 - trunk/usr
Message-ID: <200608261245.k7QCjRxW003554@sheep.berlios.de>

Author: tomo
Date: 2006-08-26 14:45:22 +0200 (Sat, 26 Aug 2006)
New Revision: 543

Modified:
   trunk/usr/driver.h
   trunk/usr/mgmt.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Replace poll with epoll.


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-26 10:08:40 UTC (rev 542)
+++ trunk/usr/driver.h	2006-08-26 12:45:22 UTC (rev 543)
@@ -1,11 +1,7 @@
-#include <poll.h>
-
 struct tgt_driver {
 	const char *name;
 
 	int (*init) (int *);
-	int (*poll_init) (struct pollfd *);
-	int (*event_handle) (struct pollfd *);
 
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);
@@ -16,7 +12,6 @@
 				uint8_t *, int *);
 	int (*scsi_inquiry)(struct tgt_device *, int, uint8_t *, uint8_t *,
 			    uint8_t *, int *);
-	int npfd;
 	int enable;
 	int pfd_index;
 };

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-26 10:08:40 UTC (rev 542)
+++ trunk/usr/mgmt.c	2006-08-26 12:45:22 UTC (rev 543)
@@ -195,7 +195,7 @@
 		eprintf("can't write, %m\n");
 }
 
-void ipc_event_handle(int accept_fd)
+void mgmt_event_handler(int accept_fd, void *data)
 {
 	int fd, err;
 	char sbuf[BUFSIZE], rbuf[BUFSIZE];

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-26 10:08:40 UTC (rev 542)
+++ trunk/usr/tgtd.c	2006-08-26 12:45:22 UTC (rev 543)
@@ -23,7 +23,7 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
-#include <poll.h>
+#include <sys/epoll.h>
 #include <signal.h>
 #include <string.h>
 #include <stdint.h>
@@ -37,14 +37,20 @@
 #include "list.h"
 #include "tgtd.h"
 #include "driver.h"
+#include "util.h"
 
-enum {
-	POLL_KERN, /* kernel interface */
-	POLL_IPC, /* unix domain socket for tgtdadm */
-	POLL_END,
+#define MAX_FDS	4096
+
+struct tgt_event {
+	event_handler_t *handler;
+	void *data;
+	int fd;
+	struct list_head e_list;
 };
 
+static int ep_fd;
 static char program_name[] = "tgtd";
+static LIST_HEAD(tgt_events_list);
 
 static struct option const long_options[] =
 {
@@ -95,16 +101,54 @@
 	close(fd);
 }
 
-static void event_loop(struct pollfd *pfd, int npfd, int timeout)
+int tgt_event_add(int fd, int events, event_handler_t handler, void *data)
 {
+	struct epoll_event ev;
+	struct tgt_event *tev;
+	int err;
+
+	tev = malloc(sizeof(*tev));
+	if (!tev)
+		return -ENOMEM;
+
+	tev->data = data;
+	tev->handler = handler;
+	tev->fd = fd;
+
+	ev.events = events;
+	ev.data.ptr = tev;
+	err = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &ev);
+	if (err)
+		free(tev);
+	else
+		list_add(&tev->e_list, &tgt_events_list);
+
+	return err;
+}
+
+void tgt_event_del(int fd)
+{
+	struct tgt_event *tev;
+
+	epoll_ctl(ep_fd, EPOLL_CTL_DEL, fd, NULL);
+
+	list_for_each_entry(tev, &tgt_events_list, e_list) {
+		if (tev->fd == fd) {
+			list_del(&tev->e_list);
+			free(tev);
+			break;
+		}
+	}
+}
+
+static void event_loop(int timeout)
+{
 	int nevent, i;
-	struct tgt_driver *d;
+	struct epoll_event events[1024];
+	struct tgt_event *tev;
 
 retry:
-	/*
-	 * TODO: replace something efficient than poll.
-	 */
-	nevent = poll(pfd, npfd, timeout);
+	nevent = epoll_wait(ep_fd, events, ARRAY_SIZE(events), timeout);
 	if (nevent < 0) {
 		if (errno != EINTR) {
 			eprintf("%m\n");
@@ -118,60 +162,16 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_KERN].revents) {
-		kspace_event_handle();
-		nevent--;
+	for (i = 0; i < nevent; i++) {
+		tev = (struct tgt_event *) events[i].data.ptr;
+		tev->handler(tev->fd, tev->data);
 	}
 
-	if (pfd[POLL_IPC].revents) {
-		dprintf("ipc event\n");
-		ipc_event_handle(pfd[POLL_IPC].fd);
-		nevent--;
-	}
-
-	if (!nevent)
-		goto retry;
-
-	for (i = 0; tgt_drivers[i]; i++) {
-		dprintf("lld event\n");
-		d = tgt_drivers[i];
-		d->event_handle(pfd + d->pfd_index);
-	}
-
 	goto retry;
 }
 
-static struct pollfd *pfd_init(int npfd, int ki_fd, int ud_fd)
+static int lld_init(char *data)
 {
-	struct tgt_driver *d;
-	struct pollfd *pfd;
-	int i, idx = POLL_END;
-
-	pfd = calloc(npfd, sizeof(struct pollfd));
-	if (!pfd)
-		return NULL;
-
-	if (ki_fd) {
-		pfd[POLL_KERN].fd = ki_fd;
-		pfd[POLL_KERN].events = POLLIN;
-	}
-	pfd[POLL_IPC].fd = ud_fd;
-	pfd[POLL_IPC].events = POLLIN;
-
-	for (i = 0; tgt_drivers[i]; i++) {
-		d = tgt_drivers[i];
-		if (d->enable && d->npfd) {
-			d->pfd_index = idx;
-			d->poll_init(pfd + idx);
-			idx += d->npfd;
-		}
-	}
-
-	return pfd;
-}
-
-static int lld_init(char *data, int *npfd)
-{
 	char *list, *p, *q;
 	int index, err, np, ndriver = 0;
 
@@ -193,9 +193,7 @@
 					continue;
 			}
 			tgt_drivers[index]->enable = 1;
-			tgt_drivers[index]->npfd = np;
 			ndriver++;
-			*npfd += np;
 		}
 	}
 	free(list);
@@ -205,12 +203,11 @@
 
 int main(int argc, char **argv)
 {
-	struct pollfd *pfd;
 	struct sigaction sa_old;
 	struct sigaction sa_new;
-	int err, ch, longindex, nr_lld = 0, nr_pfd = POLL_END;
+	int err, ch, longindex, fd, nr_lld = 0, maxfds = MAX_FDS, timeout = -1;
 	int is_daemon = 1, is_debug = 1;
-	int ki_fd, ipc_fd, timeout = -1;
+	char *modes = NULL;
 
 	/* do not allow ctrl-c for now... */
 	sa_new.sa_handler = signal_catch;
@@ -224,7 +221,7 @@
 				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'l':
-			nr_lld = lld_init(optarg, &nr_pfd);
+			modes = optarg;
 			break;
 		case 'f':
 			is_daemon = 0;
@@ -244,6 +241,7 @@
 		}
 	}
 
+	nr_lld = lld_init(modes);
 	if (!nr_lld) {
 		printf("No available low level driver!\n");
 		exit(1);
@@ -258,19 +256,25 @@
 	if (err)
 		exit(1);
 
-	err = kreq_init(&ki_fd);
-	if (err) {
-		eprintf("No kernel interface\n");
-		ki_fd = 0;
+	ep_fd = epoll_create(maxfds);
+	if (ep_fd < 0) {
+		eprintf("can't create epoll fd, %m\n");
+		exit(1);
 	}
 
-	err = ipc_init(&ipc_fd);
+	err = kreq_init(&fd);
 	if (err)
+		eprintf("No kernel interface\n");
+	else
+		tgt_event_add(fd, POLL_IN, kern_event_handler, NULL);
+
+	err = ipc_init(&fd);
+	if (err)
 		exit(1);
+	else
+		tgt_event_add(fd, POLL_IN, mgmt_event_handler, NULL);
 
-	pfd = pfd_init(nr_pfd, ki_fd, ipc_fd);
+	event_loop(timeout);
 
-	event_loop(pfd, nr_pfd, timeout);
-
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-26 10:08:40 UTC (rev 542)
+++ trunk/usr/tgtd.h	2006-08-26 12:45:22 UTC (rev 543)
@@ -25,10 +25,10 @@
 };
 
 extern int kreq_init(int *fd);
-extern void kspace_event_handle(void);
+extern void kern_event_handler(int, void *data);
 
 extern int ipc_init(int *fd);
-extern void ipc_event_handle(int accept_fd);
+extern void mgmt_event_handler(int accept_fd, void *data);
 
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
@@ -36,6 +36,10 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
+typedef void (event_handler_t)(int fd, void *data);
+extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
+extern void tgt_event_del(int fd);
+
 typedef int (cmd_end_t)(int host_no, int len, int result, int rw, uint64_t addr,
 			 uint64_t tag);
 typedef int (mgmt_end_t)(int host_no, uint64_t mid, int result);
@@ -54,4 +58,5 @@
 
 extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq);
+
 #endif

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-26 10:08:40 UTC (rev 542)
+++ trunk/usr/tgtif.c	2006-08-26 12:45:22 UTC (rev 543)
@@ -106,7 +106,7 @@
 	return kreq_send(&ev);
 }
 
-void kspace_event_handle(void)
+void kern_event_handler(int fd, void *data)
 {
 	struct tgt_event *ev;
 



From tomo at mail.berlios.de  Sat Aug 26 15:26:54 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 26 Aug 2006 15:26:54 +0200
Subject: [Stgt-svn] r544 - trunk/usr
Message-ID: <200608261326.k7QDQs6K030126@sheep.berlios.de>

Author: tomo
Date: 2006-08-26 15:26:50 +0200 (Sat, 26 Aug 2006)
New Revision: 544

Modified:
   trunk/usr/driver.c
   trunk/usr/tgtif.c
Log:
Kill poll header.

Modified: trunk/usr/driver.c
===================================================================
--- trunk/usr/driver.c	2006-08-26 12:45:22 UTC (rev 543)
+++ trunk/usr/driver.c	2006-08-26 13:26:50 UTC (rev 544)
@@ -1,6 +1,5 @@
 #include <errno.h>
 #include <string.h>
-#include <poll.h>
 #include <inttypes.h>
 
 #include "list.h"

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-26 12:45:22 UTC (rev 543)
+++ trunk/usr/tgtif.c	2006-08-26 13:26:50 UTC (rev 544)
@@ -31,7 +31,6 @@
 #include <unistd.h>
 #include <asm/types.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
 #include <sys/stat.h>
 #include <scsi/scsi_tgt_if.h>
 



From tomo at mail.berlios.de  Sun Aug 27 10:38:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 27 Aug 2006 10:38:04 +0200
Subject: [Stgt-svn] r545 - trunk/usr
Message-ID: <200608270838.k7R8c4WX008143@sheep.berlios.de>

Author: tomo
Date: 2006-08-27 10:38:02 +0200 (Sun, 27 Aug 2006)
New Revision: 545

Modified:
   trunk/usr/scsi.c
Log:
Split mmap code and scsi protocol code.

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-26 13:26:50 UTC (rev 544)
+++ trunk/usr/scsi.c	2006-08-27 08:38:02 UTC (rev 545)
@@ -385,13 +385,9 @@
 	return SAM_STAT_GOOD;
 }
 
-static int mmap_device(uint8_t *scb, int *len, int fd, uint32_t datalen, unsigned long *uaddr,
-		       uint64_t *offset)
+static uint64_t scsi_cmd_data_offset(uint8_t *scb)
 {
-	void *p;
 	uint64_t off;
-	*len = 0;
-	int err = SAM_STAT_GOOD;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -412,31 +408,38 @@
 		break;
 	}
 
-	off <<= BLK_SHIFT;
+	return off << BLK_SHIFT;
+}
 
+static int mmap_device(struct tgt_device *dev, uint32_t datalen,
+		       unsigned long *uaddr, uint64_t offset)
+{
+	int fd = dev->fd;
+	void *p;
+	int err = SAM_STAT_GOOD;
+
 	if (*uaddr)
-		*uaddr = *uaddr + off;
+		*uaddr = *uaddr + offset;
 	else {
-		p = mmap64(NULL, pgcnt(datalen, off) << PAGE_SHIFT,
+		p = mmap64(NULL, pgcnt(datalen, offset) << PAGE_SHIFT,
 			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   off & ~((1ULL << PAGE_SHIFT) - 1));
+			   offset & ~((1ULL << PAGE_SHIFT) - 1));
 
-		*uaddr = (unsigned long) p + (off & ~PAGE_MASK);
+		*uaddr = (unsigned long) p + (offset & ~PAGE_MASK);
 		if (p == MAP_FAILED) {
 			err = SAM_STAT_CHECK_CONDITION;
-			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
+			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
 		}
 	}
-	*offset = off;
-	*len = datalen;
-	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, off);
 
+	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+
 	return err;
 }
 
-static inline int mmap_cmd_init(uint8_t *scb, uint8_t *rw)
+static int scsi_cmd_rw(uint8_t *scb, uint8_t *rw)
 {
-	int result = 1;
+	int is_data = 1;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -451,9 +454,9 @@
 		*rw = WRITE;
 		break;
 	default:
-		result = 0;
+		is_data = 0;
 	}
-	return result;
+	return is_data;
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
@@ -496,7 +499,7 @@
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*offset = 0;
-	if (!mmap_cmd_init(scb, rw)) {
+	if (!scsi_cmd_rw(scb, rw)) {
 		data = valloc(PAGE_SIZE);
 		memset(data, 0, PAGE_SIZE);
 	}
@@ -553,11 +556,12 @@
 	case WRITE_10:
 	case WRITE_16:
 	case WRITE_VERIFY:
-		result = mmap_device(scb, len, dev->fd, datalen,
-				     uaddr, offset);
-		if (result == SAM_STAT_GOOD)
+		*offset = scsi_cmd_data_offset(scb);
+		result = mmap_device(dev, datalen, uaddr, *offset);
+		if (result == SAM_STAT_GOOD) {
+			*len = datalen;
 			*try_map = 1;
-		else {
+		} else {
 			*rw = READ;
 			*offset = 0;
 			if (!data)



From tomo at mail.berlios.de  Sun Aug 27 16:55:16 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 27 Aug 2006 16:55:16 +0200
Subject: [Stgt-svn] r546 - in trunk/usr: . ibmvio
Message-ID: <200608271455.k7REtGjA004650@sheep.berlios.de>

Author: tomo
Date: 2006-08-27 16:55:06 +0200 (Sun, 27 Aug 2006)
New Revision: 546

Added:
   trunk/usr/mmapio.c
Modified:
   trunk/usr/Makefile
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/util.h
Log:
Create backedio_operations for various I/O models, mmap, AIO, etc.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/Makefile	2006-08-27 14:55:06 UTC (rev 546)
@@ -1,6 +1,6 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
+TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o mmapio.o
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/driver.h	2006-08-27 14:55:06 UTC (rev 546)
@@ -1,3 +1,5 @@
+extern struct backedio_operations mmapio;
+
 struct tgt_driver {
 	const char *name;
 
@@ -14,6 +16,8 @@
 			    uint8_t *, int *);
 	int enable;
 	int pfd_index;
+
+	struct backedio_operations *io_ops;
 };
 
 extern struct tgt_driver *tgt_drivers[];

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/ibmvio/ibmvio.h	2006-08-27 14:55:06 UTC (rev 546)
@@ -10,4 +10,5 @@
 	.scsi_get_lun		= scsi_lun_to_int,
 	.scsi_report_luns	= scsi_report_luns,
 	.scsi_inquiry		= scsi_inquiry,
+	.io_ops			= &mmapio,
 };

Added: trunk/usr/mmapio.c
===================================================================
--- trunk/usr/mmapio.c	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/mmapio.c	2006-08-27 14:55:06 UTC (rev 546)
@@ -0,0 +1,74 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+
+static void *mmapio_cmd_buffer_alloc(int devio, uint32_t datalen)
+{
+	void *data = NULL;
+	if (!devio) {
+		datalen = ALIGN(datalen, PAGE_SIZE);
+		data = valloc(datalen);
+		if (data)
+			memset(data, 0, datalen);
+	}
+	return data;
+}
+
+static int mmapio_cmd_prepare(struct tgt_device *dev, uint32_t datalen,
+			      unsigned long *uaddr, uint64_t offset)
+{
+	int fd = dev->fd;
+	void *p;
+	int err = 0;
+
+	if (*uaddr)
+		*uaddr = *uaddr + offset;
+	else {
+		p = mmap64(NULL, pgcnt(datalen, offset) << PAGE_SHIFT,
+			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
+			   offset & ~((1ULL << PAGE_SHIFT) - 1));
+
+		*uaddr = (unsigned long) p + (offset & ~PAGE_MASK);
+		if (p == MAP_FAILED) {
+			err = -EINVAL;
+			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+		}
+	}
+
+	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+
+	return err;
+}
+
+static int mmapio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	int err = 0;
+
+	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
+
+	if (do_munmap) {
+		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
+		uaddr &= PAGE_MASK;
+		err = munmap((void *) (unsigned long) uaddr, len);
+		if (err)
+			eprintf("%" PRIx64 " %d\n", uaddr, len);
+	} else if (do_free)
+		free((void *) (unsigned long) uaddr);
+
+	return err;
+}
+
+struct backedio_operations mmapio = {
+	.cmd_prepare = mmapio_cmd_prepare,
+	.cmd_buffer_alloc = mmapio_cmd_buffer_alloc,
+	.cmd_done = mmapio_cmd_done,
+};

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/scsi.c	2006-08-27 14:55:06 UTC (rev 546)
@@ -22,7 +22,6 @@
 #include <asm/byteorder.h>
 #include <linux/fs.h>
 #include <scsi/scsi.h>
-#include <sys/mman.h>
 
 #include "list.h"
 #include "util.h"
@@ -411,32 +410,6 @@
 	return off << BLK_SHIFT;
 }
 
-static int mmap_device(struct tgt_device *dev, uint32_t datalen,
-		       unsigned long *uaddr, uint64_t offset)
-{
-	int fd = dev->fd;
-	void *p;
-	int err = SAM_STAT_GOOD;
-
-	if (*uaddr)
-		*uaddr = *uaddr + offset;
-	else {
-		p = mmap64(NULL, pgcnt(datalen, offset) << PAGE_SHIFT,
-			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   offset & ~((1ULL << PAGE_SHIFT) - 1));
-
-		*uaddr = (unsigned long) p + (offset & ~PAGE_MASK);
-		if (p == MAP_FAILED) {
-			err = SAM_STAT_CHECK_CONDITION;
-			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
-		}
-	}
-
-	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
-
-	return err;
-}
-
 static int scsi_cmd_rw(uint8_t *scb, uint8_t *rw)
 {
 	int is_data = 1;
@@ -494,15 +467,13 @@
 		     struct tgt_device *dev, struct list_head *dev_list)
 {
 	int result = SAM_STAT_GOOD;
-	uint8_t *data = NULL, *scb = pdu;
+	uint8_t *data, *scb = pdu;
 
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*offset = 0;
-	if (!scsi_cmd_rw(scb, rw)) {
-		data = valloc(PAGE_SIZE);
-		memset(data, 0, PAGE_SIZE);
-	}
+	data = tgt_drivers[lid]->io_ops->cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
+							  datalen);
 
 	if (!dev)
 		switch (scb[0]) {
@@ -557,7 +528,8 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = mmap_device(dev, datalen, uaddr, *offset);
+		result = tgt_drivers[lid]->io_ops->cmd_prepare(dev, datalen,
+							       uaddr, *offset);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/target.c	2006-08-27 14:55:06 UTC (rev 546)
@@ -27,7 +27,6 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
-#include <sys/mman.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 
@@ -401,24 +400,6 @@
 	}
 }
 
-static int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	int err = 0;
-
-	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
-
-	if (do_munmap) {
-		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
-		uaddr &= PAGE_MASK;
-		err = munmap((void *) (unsigned long) uaddr, len);
-		if (err)
-			eprintf("%" PRIx64 " %d\n", uaddr, len);
-	} else if (do_free)
-		free((void *) (unsigned long) uaddr);
-
-	return err;
-}
-
 static void __cmd_done(struct target *target, struct cmd *cmd)
 {
 	struct tgt_cmd_queue *q;
@@ -436,7 +417,9 @@
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = scsi_cmd_done(do_munmap, !cmd->mmapped, cmd->uaddr, cmd->len);
+	err = tgt_drivers[target->lid]->io_ops->cmd_done(do_munmap,
+							 !cmd->mmapped,
+							 cmd->uaddr, cmd->len);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/tgtd.h	2006-08-27 14:55:06 UTC (rev 546)
@@ -24,6 +24,13 @@
 	struct tgt_cmd_queue cmd_queue;
 };
 
+struct backedio_operations {
+	void * (*cmd_buffer_alloc)(int devio, uint32_t datalen);
+	int (*cmd_prepare)(struct tgt_device *dev, uint32_t datalen,
+			   unsigned long *uaddr, uint64_t offset);
+	int (*cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+};
+
 extern int kreq_init(int *fd);
 extern void kern_event_handler(int, void *data);
 

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-08-27 08:38:02 UTC (rev 545)
+++ trunk/usr/util.h	2006-08-27 14:55:06 UTC (rev 546)
@@ -4,6 +4,7 @@
 #include <sys/user.h>
 
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
 
 #ifndef PAGE_SHIFT
 #define	PAGE_SHIFT	12



From tomo at mail.berlios.de  Mon Aug 28 09:02:51 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 09:02:51 +0200
Subject: [Stgt-svn] r547 - trunk/usr
Message-ID: <200608280702.k7S72pIC001598@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 09:02:48 +0200 (Mon, 28 Aug 2006)
New Revision: 547

Modified:
   trunk/usr/mmapio.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Add open and close operations to backedio_operations structure.


Modified: trunk/usr/mmapio.c
===================================================================
--- trunk/usr/mmapio.c	2006-08-27 14:55:06 UTC (rev 546)
+++ trunk/usr/mmapio.c	2006-08-28 07:02:48 UTC (rev 547)
@@ -23,8 +23,8 @@
 	return data;
 }
 
-static int mmapio_cmd_prepare(struct tgt_device *dev, uint32_t datalen,
-			      unsigned long *uaddr, uint64_t offset)
+static int mmapio_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
+			     unsigned long *uaddr, uint64_t offset)
 {
 	int fd = dev->fd;
 	void *p;
@@ -68,7 +68,7 @@
 }
 
 struct backedio_operations mmapio = {
-	.cmd_prepare = mmapio_cmd_prepare,
-	.cmd_buffer_alloc = mmapio_cmd_buffer_alloc,
-	.cmd_done = mmapio_cmd_done,
+	.bd_cmd_buffer_alloc	= mmapio_cmd_buffer_alloc,
+	.bd_cmd_submit		= mmapio_cmd_submit,
+	.bd_cmd_done		= mmapio_cmd_done,
 };

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-27 14:55:06 UTC (rev 546)
+++ trunk/usr/scsi.c	2006-08-28 07:02:48 UTC (rev 547)
@@ -472,8 +472,8 @@
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*offset = 0;
-	data = tgt_drivers[lid]->io_ops->cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
-							  datalen);
+	data = tgt_drivers[lid]->io_ops->bd_cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
+							     datalen);
 
 	if (!dev)
 		switch (scb[0]) {
@@ -528,8 +528,8 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = tgt_drivers[lid]->io_ops->cmd_prepare(dev, datalen,
-							       uaddr, *offset);
+		result = tgt_drivers[lid]->io_ops->bd_cmd_submit(dev, datalen,
+								 uaddr, *offset);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-27 14:55:06 UTC (rev 546)
+++ trunk/usr/target.c	2006-08-28 07:02:48 UTC (rev 547)
@@ -311,8 +311,10 @@
 
 	/* TODO: preallocate cmd */
 	cmd = calloc(1, sizeof(*cmd));
-	if (!cmd)
+	if (!cmd) {
+		eprintf("out of memory");
 		return -ENOMEM;
+	}
 	cmd->hostno = host_no;
 	cmd->attribute = attribute;
 	cmd->tag = tag;
@@ -417,9 +419,9 @@
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = tgt_drivers[target->lid]->io_ops->cmd_done(do_munmap,
-							 !cmd->mmapped,
-							 cmd->uaddr, cmd->len);
+	err = tgt_drivers[target->lid]->io_ops->bd_cmd_done(do_munmap,
+							    !cmd->mmapped,
+							    cmd->uaddr, cmd->len);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-27 14:55:06 UTC (rev 546)
+++ trunk/usr/tgtd.h	2006-08-28 07:02:48 UTC (rev 547)
@@ -25,10 +25,12 @@
 };
 
 struct backedio_operations {
-	void * (*cmd_buffer_alloc)(int devio, uint32_t datalen);
-	int (*cmd_prepare)(struct tgt_device *dev, uint32_t datalen,
-			   unsigned long *uaddr, uint64_t offset);
-	int (*cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+	void *(*bd_cmd_buffer_alloc)(int devio, uint32_t datalen);
+	int (*bd_cmd_submit)(struct tgt_device *dev, uint32_t datalen,
+			     unsigned long *uaddr, uint64_t offset);
+	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
+	int (*bd_open)(struct tgt_device *dev);
+	void (*bd_close)(struct tgt_device *dev);
 };
 
 extern int kreq_init(int *fd);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-27 14:55:06 UTC (rev 546)
+++ trunk/usr/tgtif.c	2006-08-28 07:02:48 UTC (rev 547)
@@ -109,13 +109,12 @@
 {
 	struct tgt_event *ev;
 
-	dprintf("nl event %u\n", kuring.idx);
 retry:
 	ev = head_ring_hdr(&kuring);
 	if (ev->status == TGT_EVENT_STATUS_EMPTY)
 		return;
 
-	dprintf("event %u\n", ev->type);
+	dprintf("event %u %u\n", kuring.idx, ev->type);
 
 	switch (ev->type) {
 	case TGT_KEVENT_CMD_REQ:



From tomo at mail.berlios.de  Mon Aug 28 09:09:42 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 09:09:42 +0200
Subject: [Stgt-svn] r548 - trunk/usr
Message-ID: <200608280709.k7S79g7c004978@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 09:09:38 +0200 (Mon, 28 Aug 2006)
New Revision: 548

Modified:
   trunk/usr/driver.h
   trunk/usr/mmapio.c
   trunk/usr/scsi.c
   trunk/usr/tgtd.h
Log:
Fix a minor bug from the previous commit.

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-28 07:02:48 UTC (rev 547)
+++ trunk/usr/driver.h	2006-08-28 07:09:38 UTC (rev 548)
@@ -1,4 +1,4 @@
-extern struct backedio_operations mmapio;
+extern struct backedio_operations mmap_bdops;
 
 struct tgt_driver {
 	const char *name;

Modified: trunk/usr/mmapio.c
===================================================================
--- trunk/usr/mmapio.c	2006-08-28 07:02:48 UTC (rev 547)
+++ trunk/usr/mmapio.c	2006-08-28 07:09:38 UTC (rev 548)
@@ -67,7 +67,7 @@
 	return err;
 }
 
-struct backedio_operations mmapio = {
+struct backedio_operations mmap_bdops = {
 	.bd_cmd_buffer_alloc	= mmapio_cmd_buffer_alloc,
 	.bd_cmd_submit		= mmapio_cmd_submit,
 	.bd_cmd_done		= mmapio_cmd_done,

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-28 07:02:48 UTC (rev 547)
+++ trunk/usr/scsi.c	2006-08-28 07:09:38 UTC (rev 548)
@@ -528,7 +528,7 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = tgt_drivers[lid]->io_ops->bd_cmd_submit(dev, datalen,
+		result = tgt_drivers[lid]->io_ops->bd_cmd_submit(dev, *rw, datalen,
 								 uaddr, *offset);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-28 07:02:48 UTC (rev 547)
+++ trunk/usr/tgtd.h	2006-08-28 07:09:38 UTC (rev 548)
@@ -26,7 +26,7 @@
 
 struct backedio_operations {
 	void *(*bd_cmd_buffer_alloc)(int devio, uint32_t datalen);
-	int (*bd_cmd_submit)(struct tgt_device *dev, uint32_t datalen,
+	int (*bd_cmd_submit)(struct tgt_device *dev, int rw, uint32_t datalen,
 			     unsigned long *uaddr, uint64_t offset);
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 	int (*bd_open)(struct tgt_device *dev);



From tomo at mail.berlios.de  Mon Aug 28 11:09:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 11:09:33 +0200
Subject: [Stgt-svn] r549 - in trunk/usr: . ibmvio
Message-ID: <200608280909.k7S99X9w009977@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 11:09:32 +0200 (Mon, 28 Aug 2006)
New Revision: 549

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/mmapio.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/util.c
   trunk/usr/util.h
Log:
Add mmap open and close operations.


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/driver.h	2006-08-28 09:09:32 UTC (rev 549)
@@ -1,4 +1,4 @@
-extern struct backedio_operations mmap_bdops;
+extern struct backedio_template mmap_bdt;
 
 struct tgt_driver {
 	const char *name;
@@ -17,7 +17,7 @@
 	int enable;
 	int pfd_index;
 
-	struct backedio_operations *io_ops;
+	struct backedio_template *bdt;
 };
 
 extern struct tgt_driver *tgt_drivers[];

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/ibmvio/ibmvio.h	2006-08-28 09:09:32 UTC (rev 549)
@@ -10,5 +10,5 @@
 	.scsi_get_lun		= scsi_lun_to_int,
 	.scsi_report_luns	= scsi_report_luns,
 	.scsi_inquiry		= scsi_inquiry,
-	.io_ops			= &mmapio,
+	.bdt			= &mmap_bdt,
 };

Modified: trunk/usr/mmapio.c
===================================================================
--- trunk/usr/mmapio.c	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/mmapio.c	2006-08-28 09:09:32 UTC (rev 549)
@@ -11,8 +11,30 @@
 #include "util.h"
 #include "tgtd.h"
 
-static void *mmapio_cmd_buffer_alloc(int devio, uint32_t datalen)
+static struct tgt_device *bd_mmap_open(char *path, int *fd, uint64_t *size)
 {
+	struct tgt_device *dev;
+
+	dev = malloc(sizeof(*dev));
+	if (!dev)
+		return NULL;
+
+	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
+	if (*fd < 0) {
+		free(dev);
+		dev = NULL;
+	}
+
+	return dev;
+}
+
+static void bd_mmap_close(struct tgt_device *dev)
+{
+	free(dev);
+}
+
+static void *bd_mmap_cmd_buffer_alloc(int devio, uint32_t datalen)
+{
 	void *data = NULL;
 	if (!devio) {
 		datalen = ALIGN(datalen, PAGE_SIZE);
@@ -23,8 +45,8 @@
 	return data;
 }
 
-static int mmapio_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
-			     unsigned long *uaddr, uint64_t offset)
+static int bd_mmap_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
+			      unsigned long *uaddr, uint64_t offset)
 {
 	int fd = dev->fd;
 	void *p;
@@ -49,7 +71,7 @@
 	return err;
 }
 
-static int mmapio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+static int bd_mmap_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
 
@@ -67,8 +89,10 @@
 	return err;
 }
 
-struct backedio_operations mmap_bdops = {
-	.bd_cmd_buffer_alloc	= mmapio_cmd_buffer_alloc,
-	.bd_cmd_submit		= mmapio_cmd_submit,
-	.bd_cmd_done		= mmapio_cmd_done,
+struct backedio_template mmap_bdt = {
+	.bd_open		= bd_mmap_open,
+	.bd_close		= bd_mmap_close,
+	.bd_cmd_buffer_alloc	= bd_mmap_cmd_buffer_alloc,
+	.bd_cmd_submit		= bd_mmap_cmd_submit,
+	.bd_cmd_done		= bd_mmap_cmd_done,
 };

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/scsi.c	2006-08-28 09:09:32 UTC (rev 549)
@@ -472,8 +472,8 @@
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*offset = 0;
-	data = tgt_drivers[lid]->io_ops->bd_cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
-							     datalen);
+	data = tgt_drivers[lid]->bdt->bd_cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
+							  datalen);
 
 	if (!dev)
 		switch (scb[0]) {
@@ -528,8 +528,8 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = tgt_drivers[lid]->io_ops->bd_cmd_submit(dev, *rw, datalen,
-								 uaddr, *offset);
+		result = tgt_drivers[lid]->bdt->bd_cmd_submit(dev, *rw, datalen,
+							      uaddr, *offset);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/target.c	2006-08-28 09:09:32 UTC (rev 549)
@@ -26,11 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <sys/ioctl.h>
 #include <sys/socket.h>
-#include <sys/stat.h>
-
-#include <linux/fs.h>
 #include <scsi/scsi.h>
 
 #include "list.h"
@@ -139,8 +135,7 @@
 {
 	struct target *target;
 	struct tgt_device *device;
-	struct stat64 st;
-	int err, dev_fd;
+	int dev_fd;
 	uint64_t size;
 
 	dprintf("%d %" PRIu64 " %s\n", tid, dev_id, path);
@@ -155,34 +150,9 @@
 		return -EINVAL;
 	}
 
-	dev_fd = open(path, O_RDWR | O_LARGEFILE);
-	if (dev_fd < 0) {
-		eprintf("Could not open %s, %m\n", path);
-		return dev_fd;
-	}
-
-	err = fstat64(dev_fd, &st);
-	if (err < 0) {
-		printf("Cannot get stat %d, %m\n", dev_fd);
-		goto close_dev_fd;
-	}
-
-	if (S_ISREG(st.st_mode))
-		size = st.st_size;
-	else if(S_ISBLK(st.st_mode)) {
-		err = ioctl(dev_fd, BLKGETSIZE64, &size);
-		if (err < 0) {
-			eprintf("Cannot get size, %m\n");
-			goto close_dev_fd;
-		}
-	} else {
-		eprintf("Cannot use this mode %x\n", st.st_mode);
-		goto close_dev_fd;
-	}
-
-	device = malloc(sizeof(*device));
+	device = tgt_drivers[target->lid]->bdt->bd_open(path, &dev_fd, &size);
 	if (!device)
-		goto close_dev_fd;
+		return -EINVAL;
 
 	device->fd = dev_fd;
 	device->addr = 0;
@@ -199,9 +169,6 @@
 		dev_id, tid);
 
 	return 0;
-close_dev_fd:
-	close(dev_fd);
-	return err;
 }
 
 int tgt_device_destroy(int tid, uint64_t dev_id)
@@ -228,7 +195,7 @@
 	device_hlist_remove(device);
 	device_list_remove(device);
 
-	free(device);
+	tgt_drivers[target->lid]->bdt->bd_close(device);
 	return 0;
 }
 
@@ -419,9 +386,9 @@
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = tgt_drivers[target->lid]->io_ops->bd_cmd_done(do_munmap,
-							    !cmd->mmapped,
-							    cmd->uaddr, cmd->len);
+	err = tgt_drivers[target->lid]->bdt->bd_cmd_done(do_munmap,
+							 !cmd->mmapped,
+							 cmd->uaddr, cmd->len);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/tgtd.h	2006-08-28 09:09:32 UTC (rev 549)
@@ -22,15 +22,17 @@
 	struct list_head d_list;
 
 	struct tgt_cmd_queue cmd_queue;
+
+	unsigned long bddata[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
-struct backedio_operations {
+struct backedio_template {
+	struct tgt_device *(*bd_open)(char *path, int *fd, uint64_t *size);
+	void (*bd_close)(struct tgt_device *dev);
 	void *(*bd_cmd_buffer_alloc)(int devio, uint32_t datalen);
 	int (*bd_cmd_submit)(struct tgt_device *dev, int rw, uint32_t datalen,
 			     unsigned long *uaddr, uint64_t offset);
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
-	int (*bd_open)(struct tgt_device *dev);
-	void (*bd_close)(struct tgt_device *dev);
 };
 
 extern int kreq_init(int *fd);

Modified: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/util.c	2006-08-28 09:09:32 UTC (rev 549)
@@ -6,6 +6,8 @@
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <sys/ioctl.h>
+#include <linux/fs.h>
 
 #include "log.h"
 
@@ -56,3 +58,41 @@
 
 	return 0;
 }
+
+int backed_file_open(char *path, int oflag, uint64_t *size)
+{
+	int fd, err;
+	struct stat64 st;
+
+	fd = open(path, oflag);
+	if (fd < 0) {
+		eprintf("Could not open %s, %m\n", path);
+		return fd;
+	}
+
+	err = fstat64(fd, &st);
+	if (err < 0) {
+		printf("Cannot get stat %d, %m\n", fd);
+		goto close_fd;
+	}
+
+	if (S_ISREG(st.st_mode))
+		*size = st.st_size;
+	else if(S_ISBLK(st.st_mode)) {
+		err = ioctl(fd, BLKGETSIZE64, size);
+		if (err < 0) {
+			eprintf("Cannot get size, %m\n");
+			goto close_fd;
+		}
+	} else {
+		eprintf("Cannot use this mode %x\n", st.st_mode);
+		err = -EINVAL;
+		goto close_fd;
+	}
+
+	return fd;
+
+close_fd:
+	close(fd);
+	return err;
+}

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-08-28 07:09:38 UTC (rev 548)
+++ trunk/usr/util.h	2006-08-28 09:09:32 UTC (rev 549)
@@ -35,5 +35,6 @@
 	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
 
 extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
+extern int backed_file_open(char *path, int oflag, uint64_t *size);
 
 #endif



From tomo at mail.berlios.de  Mon Aug 28 11:13:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 11:13:18 +0200
Subject: [Stgt-svn] r550 - trunk/usr
Message-ID: <200608280913.k7S9DIYj010273@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 11:13:17 +0200 (Mon, 28 Aug 2006)
New Revision: 550

Added:
   trunk/usr/bd_mmap.c
Removed:
   trunk/usr/mmapio.c
Modified:
   trunk/usr/Makefile
Log:
Rename mmapio.c bd_mmap.c.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-28 09:09:32 UTC (rev 549)
+++ trunk/usr/Makefile	2006-08-28 09:13:17 UTC (rev 550)
@@ -1,6 +1,6 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o mmapio.o
+TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o bd_mmap.o
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO

Copied: trunk/usr/bd_mmap.c (from rev 549, trunk/usr/mmapio.c)

Deleted: trunk/usr/mmapio.c
===================================================================
--- trunk/usr/mmapio.c	2006-08-28 09:09:32 UTC (rev 549)
+++ trunk/usr/mmapio.c	2006-08-28 09:13:17 UTC (rev 550)
@@ -1,98 +0,0 @@
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/mman.h>
-
-#include "list.h"
-#include "util.h"
-#include "tgtd.h"
-
-static struct tgt_device *bd_mmap_open(char *path, int *fd, uint64_t *size)
-{
-	struct tgt_device *dev;
-
-	dev = malloc(sizeof(*dev));
-	if (!dev)
-		return NULL;
-
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
-	if (*fd < 0) {
-		free(dev);
-		dev = NULL;
-	}
-
-	return dev;
-}
-
-static void bd_mmap_close(struct tgt_device *dev)
-{
-	free(dev);
-}
-
-static void *bd_mmap_cmd_buffer_alloc(int devio, uint32_t datalen)
-{
-	void *data = NULL;
-	if (!devio) {
-		datalen = ALIGN(datalen, PAGE_SIZE);
-		data = valloc(datalen);
-		if (data)
-			memset(data, 0, datalen);
-	}
-	return data;
-}
-
-static int bd_mmap_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
-			      unsigned long *uaddr, uint64_t offset)
-{
-	int fd = dev->fd;
-	void *p;
-	int err = 0;
-
-	if (*uaddr)
-		*uaddr = *uaddr + offset;
-	else {
-		p = mmap64(NULL, pgcnt(datalen, offset) << PAGE_SHIFT,
-			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   offset & ~((1ULL << PAGE_SHIFT) - 1));
-
-		*uaddr = (unsigned long) p + (offset & ~PAGE_MASK);
-		if (p == MAP_FAILED) {
-			err = -EINVAL;
-			eprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
-		}
-	}
-
-	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
-
-	return err;
-}
-
-static int bd_mmap_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
-{
-	int err = 0;
-
-	dprintf("%d %d %" PRIx64 " %d\n", do_munmap, do_free, uaddr, len);
-
-	if (do_munmap) {
-		len = pgcnt(len, (uaddr & ~PAGE_MASK)) << PAGE_SHIFT;
-		uaddr &= PAGE_MASK;
-		err = munmap((void *) (unsigned long) uaddr, len);
-		if (err)
-			eprintf("%" PRIx64 " %d\n", uaddr, len);
-	} else if (do_free)
-		free((void *) (unsigned long) uaddr);
-
-	return err;
-}
-
-struct backedio_template mmap_bdt = {
-	.bd_open		= bd_mmap_open,
-	.bd_close		= bd_mmap_close,
-	.bd_cmd_buffer_alloc	= bd_mmap_cmd_buffer_alloc,
-	.bd_cmd_submit		= bd_mmap_cmd_submit,
-	.bd_cmd_done		= bd_mmap_cmd_done,
-};



From tomo at mail.berlios.de  Mon Aug 28 14:51:36 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 14:51:36 +0200
Subject: [Stgt-svn] r551 - trunk/usr
Message-ID: <200608281251.k7SCpa1r028186@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 14:50:36 +0200 (Mon, 28 Aug 2006)
New Revision: 551

Modified:
   trunk/usr/mgmt.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Make mgmt/kern_event_handler static.

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-28 09:13:17 UTC (rev 550)
+++ trunk/usr/mgmt.c	2006-08-28 12:50:36 UTC (rev 551)
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <signal.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -195,7 +196,7 @@
 		eprintf("can't write, %m\n");
 }
 
-void mgmt_event_handler(int accept_fd, void *data)
+static void mgmt_event_handler(int accept_fd, void *data)
 {
 	int fd, err;
 	char sbuf[BUFSIZE], rbuf[BUFSIZE];
@@ -280,7 +281,7 @@
 	return;
 }
 
-int ipc_init(int *ipc_fd)
+int ipc_init(void)
 {
 	int fd, err;
 	struct sockaddr_un addr;
@@ -308,7 +309,10 @@
 		goto out;
 	}
 
-	*ipc_fd = fd;
+	err = tgt_event_add(fd, POLL_IN, mgmt_event_handler, NULL);
+	if (err)
+		goto out;
+
 	return 0;
 out:
 	close(fd);

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-28 09:13:17 UTC (rev 550)
+++ trunk/usr/tgtd.c	2006-08-28 12:50:36 UTC (rev 551)
@@ -23,16 +23,13 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
-#include <sys/epoll.h>
 #include <signal.h>
-#include <string.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
-#include <asm/types.h>
-#include <sys/signal.h>
-#include <sys/stat.h>
+#include <sys/epoll.h>
 
 #include "list.h"
 #include "tgtd.h"
@@ -108,8 +105,10 @@
 	int err;
 
 	tev = malloc(sizeof(*tev));
-	if (!tev)
+	if (!tev) {
+		eprintf("OOM, %m\n");
 		return -ENOMEM;
+	}
 
 	tev->data = data;
 	tev->handler = handler;
@@ -118,9 +117,10 @@
 	ev.events = events;
 	ev.data.ptr = tev;
 	err = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &ev);
-	if (err)
+	if (err) {
+		eprintf("Cannot add fd, %m\n");
 		free(tev);
-	else
+	} else
 		list_add(&tev->e_list, &tgt_events_list);
 
 	return err;
@@ -205,7 +205,7 @@
 {
 	struct sigaction sa_old;
 	struct sigaction sa_new;
-	int err, ch, longindex, fd, nr_lld = 0, maxfds = MAX_FDS, timeout = -1;
+	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS, timeout = -1;
 	int is_daemon = 1, is_debug = 1;
 	char *modes = NULL;
 
@@ -262,17 +262,13 @@
 		exit(1);
 	}
 
-	err = kreq_init(&fd);
+	err = kreq_init();
 	if (err)
 		eprintf("No kernel interface\n");
-	else
-		tgt_event_add(fd, POLL_IN, kern_event_handler, NULL);
 
-	err = ipc_init(&fd);
+	err = ipc_init();
 	if (err)
 		exit(1);
-	else
-		tgt_event_add(fd, POLL_IN, mgmt_event_handler, NULL);
 
 	event_loop(timeout);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-28 09:13:17 UTC (rev 550)
+++ trunk/usr/tgtd.h	2006-08-28 12:50:36 UTC (rev 551)
@@ -35,11 +35,9 @@
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 };
 
-extern int kreq_init(int *fd);
-extern void kern_event_handler(int, void *data);
+extern int kreq_init(void);
 
-extern int ipc_init(int *fd);
-extern void mgmt_event_handler(int accept_fd, void *data);
+extern int ipc_init(void);
 
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-28 09:13:17 UTC (rev 550)
+++ trunk/usr/tgtif.c	2006-08-28 12:50:36 UTC (rev 551)
@@ -24,14 +24,15 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
+#include <signal.h>
 #include <stdint.h>
-#include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
-#include <asm/types.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+
 #include <scsi/scsi_tgt_if.h>
 
 #include "list.h"
@@ -105,7 +106,7 @@
 	return kreq_send(&ev);
 }
 
-void kern_event_handler(int fd, void *data)
+static void kern_event_handler(int fd, void *data)
 {
 	struct tgt_event *ev;
 
@@ -181,19 +182,19 @@
 	return -errno;
 }
 
-int kreq_init(int *ki_fd)
+int kreq_init(void)
 {
-	int err, fd, size = TGT_RING_SIZE;
+	int err, size = TGT_RING_SIZE;
 	char *buf;
 
-	err = tgt_miscdev_init(CHRDEV_PATH, &fd);
+	err = tgt_miscdev_init(CHRDEV_PATH, &chrfd);
 	if (err)
 		return err;
 
-	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, chrfd, 0);
 	if (buf == MAP_FAILED) {
 		eprintf("fail to mmap, %m\n");
-		close(fd);
+		close(chrfd);
 		return -EINVAL;
 	}
 
@@ -201,7 +202,8 @@
 	kuring.buf = buf;
 	ukring.buf = buf + size;
 
-	*ki_fd = chrfd = fd;
-
-	return 0;
+	err = tgt_event_add(chrfd, POLL_IN, kern_event_handler, NULL);
+	if (err)
+		close(chrfd);
+	return err;
 }



From tomo at mail.berlios.de  Mon Aug 28 15:00:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 28 Aug 2006 15:00:40 +0200
Subject: [Stgt-svn] r552 - trunk/usr
Message-ID: <200608281300.k7SD0eB1031277@sheep.berlios.de>

Author: tomo
Date: 2006-08-28 15:00:27 +0200 (Mon, 28 Aug 2006)
New Revision: 552

Modified:
   trunk/usr/tgtd.c
Log:
Minor cleanups.

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-28 12:50:36 UTC (rev 551)
+++ trunk/usr/tgtd.c	2006-08-28 13:00:27 UTC (rev 552)
@@ -73,7 +73,7 @@
   -h, --help              display this help and exit\n\
 ");
 	}
-	exit(1);
+	exit(status);
 }
 
 static void signal_catch(int signo) {
@@ -141,9 +141,9 @@
 	}
 }
 
-static void event_loop(int timeout)
+static void event_loop(void)
 {
-	int nevent, i;
+	int nevent, i, timeout = -1;
 	struct epoll_event events[1024];
 	struct tgt_event *tev;
 
@@ -205,7 +205,7 @@
 {
 	struct sigaction sa_old;
 	struct sigaction sa_new;
-	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS, timeout = -1;
+	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS;
 	int is_daemon = 1, is_debug = 1;
 	char *modes = NULL;
 
@@ -270,7 +270,7 @@
 	if (err)
 		exit(1);
 
-	event_loop(timeout);
+	event_loop();
 
 	return 0;
 }



From tomo at mail.berlios.de  Tue Aug 29 01:05:21 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 01:05:21 +0200
Subject: [Stgt-svn] r553 - trunk/usr
Message-ID: <200608282305.k7SN5Lkm019960@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 01:05:01 +0200 (Tue, 29 Aug 2006)
New Revision: 553

Modified:
   trunk/usr/bd_mmap.c
Log:
Add copyright to bd_mmap.c

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-08-28 13:00:27 UTC (rev 552)
+++ trunk/usr/bd_mmap.c	2006-08-28 23:05:01 UTC (rev 553)
@@ -1,3 +1,24 @@
+/*
+ * mmap file backed routine
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>



From tomo at mail.berlios.de  Tue Aug 29 01:35:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 01:35:04 +0200
Subject: [Stgt-svn] r554 - trunk/usr
Message-ID: <200608282335.k7SNZ4xC028518@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 01:35:01 +0200 (Tue, 29 Aug 2006)
New Revision: 554

Modified:
   trunk/usr/driver.h
   trunk/usr/target.c
Log:
Kill target_bind in tgt_driver structure.

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-28 23:05:01 UTC (rev 553)
+++ trunk/usr/driver.h	2006-08-28 23:35:01 UTC (rev 554)
@@ -7,7 +7,6 @@
 
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);
-	int (*target_bind)(int);
 
 	uint64_t (*scsi_get_lun)(uint8_t *);
 	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-28 23:05:01 UTC (rev 553)
+++ trunk/usr/target.c	2006-08-28 23:35:01 UTC (rev 554)
@@ -199,7 +199,7 @@
 	return 0;
 }
 
-static int cmd_pre_perform(struct tgt_cmd_queue *q, struct cmd *cmd)
+static int cmd_enabled(struct tgt_cmd_queue *q, struct cmd *cmd)
 {
 	int enabled = 0;
 
@@ -231,8 +231,7 @@
 }
 
 static void cmd_post_perform(struct tgt_cmd_queue *q, struct cmd *cmd,
-			     unsigned long uaddr,
-			     int len, uint8_t mmapped)
+			     unsigned long uaddr, int len, uint8_t mmapped)
 {
 	cmd->uaddr = uaddr;
 	cmd->len = len;
@@ -260,20 +259,8 @@
 
 	target = host_to_target(host_no);
 	if (!target) {
-		int tid, lid = 0, err = -1;
-		if (tgt_drivers[lid]->target_bind) {
-			tid = tgt_drivers[0]->target_bind(host_no);
-			if (tid >= 0) {
-				err = tgt_target_bind(tid, host_no, lid);
-				if (!err)
-					target = host_to_target(host_no);
-			}
-		}
-
-		if (!target) {
-			eprintf("%d is not bind to any target\n", host_no);
-			return -ENOENT;
-		}
+		eprintf("%d is not bind to any target\n", host_no);
+		return -ENOENT;
 	}
 
 	/* TODO: preallocate cmd */
@@ -298,8 +285,7 @@
 	} else
 		q = &target->cmd_queue;
 
-	enabled = cmd_pre_perform(q, cmd);
-
+	enabled = cmd_enabled(q, cmd);
 	if (enabled) {
 		result = scsi_cmd_perform(target->lid,
 					  host_no, scb,
@@ -340,7 +326,7 @@
 	struct target *target;
 
 	list_for_each_entry_safe(cmd, tmp, &q->queue, qlist) {
-		enabled = cmd_pre_perform(q, cmd);
+		enabled = cmd_enabled(q, cmd);
 		if (enabled) {
 			list_del(&cmd->qlist);
 			target = host_to_target(cmd->hostno);



From tomo at mail.berlios.de  Tue Aug 29 02:32:14 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 02:32:14 +0200
Subject: [Stgt-svn] r555 - trunk/usr
Message-ID: <200608290032.k7T0WEIp007625@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 02:32:10 +0200 (Tue, 29 Aug 2006)
New Revision: 555

Modified:
   trunk/usr/target.c
   trunk/usr/target.h
Log:
Add target structure to cmd structure.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-28 23:35:01 UTC (rev 554)
+++ trunk/usr/target.c	2006-08-29 00:32:10 UTC (rev 555)
@@ -269,6 +269,7 @@
 		eprintf("out of memory");
 		return -ENOMEM;
 	}
+	cmd->c_target = target;
 	cmd->hostno = host_no;
 	cmd->attribute = attribute;
 	cmd->tag = tag;
@@ -323,19 +324,13 @@
 	uint8_t rw = 0, mmapped = 0;
 	uint64_t offset;
 	unsigned long uaddr = 0;
-	struct target *target;
 
 	list_for_each_entry_safe(cmd, tmp, &q->queue, qlist) {
 		enabled = cmd_enabled(q, cmd);
 		if (enabled) {
 			list_del(&cmd->qlist);
-			target = host_to_target(cmd->hostno);
-			if (!target) {
-				eprintf("fail to find target!\n");
-				exit(1);
-			}
 			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
-			result = scsi_cmd_perform(target->lid,
+			result = scsi_cmd_perform(cmd->c_target->lid,
 						  cmd->hostno, cmd->scb,
 						  &len,
 						  cmd->len,
@@ -345,7 +340,7 @@
 						  &offset,
 						  cmd->lun,
 						  cmd->dev,
-						  &target->device_list);
+						  &cmd->c_target->device_list);
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
 			set_cmd_processed(cmd);
 			cmd->cmd_end_func(cmd->hostno, len, result, rw,

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-28 23:35:01 UTC (rev 554)
+++ trunk/usr/target.h	2006-08-29 00:32:10 UTC (rev 555)
@@ -21,7 +21,22 @@
 	mgmt_end_t *mgmt_end_func;
 };
 
+struct target {
+	int tid;
+	int lid;
+
+	struct list_head t_hlist;
+
+	struct list_head device_hash_list[1 << HASH_ORDER];
+	struct list_head device_list; /* for REPORT_LUNS */
+
+	struct list_head cmd_hash_list[1 << HASH_ORDER];
+
+	struct tgt_cmd_queue cmd_queue;
+};
+
 struct cmd {
+	struct target *c_target;
 	/* linked target->cmd_hash_list */
 	struct list_head c_hlist;
 	struct list_head qlist;
@@ -32,7 +47,6 @@
 	struct tgt_device *dev;
 	unsigned long state;
 
-	/* Kill the followings when we use shared memory instead of netlink. */
 	int hostno;
 	uint32_t data_len;
 	uint8_t scb[16];
@@ -43,20 +57,6 @@
 	cmd_end_t *cmd_end_func;
 };
 
-struct target {
-	int tid;
-	int lid;
-
-	struct list_head t_hlist;
-
-	struct list_head device_hash_list[1 << HASH_ORDER];
-	struct list_head device_list; /* for REPORT_LUNS */
-
-	struct list_head cmd_hash_list[1 << HASH_ORDER];
-
-	struct tgt_cmd_queue cmd_queue;
-};
-
 enum {
 	TGT_QUEUE_BLOCKED,
 	TGT_QUEUE_DELETED,



From tomo at mail.berlios.de  Tue Aug 29 02:40:01 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 02:40:01 +0200
Subject: [Stgt-svn] r556 - trunk/usr
Message-ID: <200608290040.k7T0e150009403@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 02:39:51 +0200 (Tue, 29 Aug 2006)
New Revision: 556

Modified:
   trunk/usr/bd_mmap.c
   trunk/usr/target.c
   trunk/usr/tgtd.c
   trunk/usr/util.h
Log:
Add zalloc macro.

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-08-29 00:32:10 UTC (rev 555)
+++ trunk/usr/bd_mmap.c	2006-08-29 00:39:51 UTC (rev 556)
@@ -36,7 +36,7 @@
 {
 	struct tgt_device *dev;
 
-	dev = malloc(sizeof(*dev));
+	dev = zalloc(sizeof(*dev));
 	if (!dev)
 		return NULL;
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-29 00:32:10 UTC (rev 555)
+++ trunk/usr/target.c	2006-08-29 00:39:51 UTC (rev 556)
@@ -264,11 +264,10 @@
 	}
 
 	/* TODO: preallocate cmd */
-	cmd = calloc(1, sizeof(*cmd));
-	if (!cmd) {
-		eprintf("out of memory");
+	cmd = zalloc(sizeof(*cmd));
+	if (!cmd)
 		return -ENOMEM;
-	}
+
 	cmd->c_target = target;
 	cmd->hostno = host_no;
 	cmd->attribute = attribute;
@@ -551,11 +550,9 @@
 		return -EINVAL;
 	}
 
-	target = malloc(sizeof(*target));
-	if (!target) {
-		eprintf("Out of memoryn\n");
+	target = zalloc(sizeof(*target));
+	if (!target)
 		return -ENOMEM;
-	}
 
 	target->tid = tid;
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-29 00:32:10 UTC (rev 555)
+++ trunk/usr/tgtd.c	2006-08-29 00:39:51 UTC (rev 556)
@@ -104,11 +104,9 @@
 	struct tgt_event *tev;
 	int err;
 
-	tev = malloc(sizeof(*tev));
-	if (!tev) {
-		eprintf("OOM, %m\n");
+	tev = zalloc(sizeof(*tev));
+	if (!tev)
 		return -ENOMEM;
-	}
 
 	tev->data = data;
 	tev->handler = handler;

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-08-29 00:32:10 UTC (rev 555)
+++ trunk/usr/util.h	2006-08-29 00:39:51 UTC (rev 556)
@@ -37,4 +37,14 @@
 extern int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd);
 extern int backed_file_open(char *path, int oflag, uint64_t *size);
 
+#define zalloc(size)			\
+({					\
+	void *ptr = malloc(size);	\
+	if (ptr)			\
+		memset(ptr, 0, size);	\
+	else				\
+		eprintf("%m\n");	\
+	ptr;				\
+})
+
 #endif



From tomo at mail.berlios.de  Tue Aug 29 03:04:24 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 03:04:24 +0200
Subject: [Stgt-svn] r557 - in trunk/usr: . ibmvio
Message-ID: <200608290104.k7T14Ons017801@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 03:04:15 +0200 (Tue, 29 Aug 2006)
New Revision: 557

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Add cmd/mgmt_end_notify to driver structure.

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/driver.h	2006-08-29 01:04:15 UTC (rev 557)
@@ -13,6 +13,10 @@
 				uint8_t *, int *);
 	int (*scsi_inquiry)(struct tgt_device *, int, uint8_t *, uint8_t *,
 			    uint8_t *, int *);
+	int (*cmd_end_notify)(int host_no, int len, int result, int rw, uint64_t addr,
+			      uint64_t tag);
+	int (*mgmt_end_notify)(int host_no, uint64_t mid, int result);
+
 	int enable;
 	int pfd_index;
 

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/ibmvio/ibmvio.h	2006-08-29 01:04:15 UTC (rev 557)
@@ -10,5 +10,7 @@
 	.scsi_get_lun		= scsi_lun_to_int,
 	.scsi_report_luns	= scsi_report_luns,
 	.scsi_inquiry		= scsi_inquiry,
+	.cmd_end_notify		= kspace_send_cmd_res,
+	.mgtm_end_notify	= kspace_send_tsk_mgmt_res,
 	.bdt			= &mmap_bdt,
 };

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/target.c	2006-08-29 01:04:15 UTC (rev 557)
@@ -247,7 +247,7 @@
 }
 
 int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun, uint32_t data_len,
-		     int attribute, uint64_t tag, cmd_end_t *end_func)
+		     int attribute, uint64_t tag)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
@@ -272,7 +272,6 @@
 	cmd->hostno = host_no;
 	cmd->attribute = attribute;
 	cmd->tag = tag;
-	cmd->cmd_end_func = end_func;
 	cmd_hlist_insert(target, cmd);
 
 	dev_id = scsi_get_devid(target->lid, lun);
@@ -300,7 +299,7 @@
 			tag, scb[0], uaddr, offset, result);
 
 		set_cmd_processed(cmd);
-		cmd->cmd_end_func(host_no, len, result, rw, uaddr, tag);
+		tgt_drivers[target->lid]->cmd_end_notify(host_no, len, result, rw, uaddr, tag);
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
@@ -342,8 +341,12 @@
 						  &cmd->c_target->device_list);
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
 			set_cmd_processed(cmd);
-			cmd->cmd_end_func(cmd->hostno, len, result, rw,
-					  uaddr, cmd->tag);
+			tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno,
+									len,
+									result,
+									rw,
+									uaddr,
+									cmd->tag);
 		} else
 			break;
 	}
@@ -411,7 +414,8 @@
 	mreq = cmd->mreq;
 	if (mreq && !--mreq->busy) {
 		int err = mreq->function == ABORT_TASK ? -EEXIST : 0;
-		mreq->mgmt_end_func(cmd->hostno, mreq->mid, err);
+		tgt_drivers[cmd->c_target->lid]->mgmt_end_notify(cmd->hostno,
+								 mreq->mid, err);
 		free(mreq);
 	}
 
@@ -435,7 +439,8 @@
 		err = -EBUSY;
 	} else {
 		__cmd_done(target, cmd);
-		cmd->cmd_end_func(cmd->hostno, 0, TASK_ABORTED, 0, 0, cmd->tag);
+		tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno, 0,
+								TASK_ABORTED, 0, 0, cmd->tag);
 	}
 	return err;
 }
@@ -466,7 +471,7 @@
 }
 
 void target_mgmt_request(int host_no, int req_id, int function, uint8_t *lun,
-			 uint64_t tag, mgmt_end_t *end_func)
+			 uint64_t tag)
 {
 	struct target *target;
 	struct mgmt_req *mreq;
@@ -481,7 +486,6 @@
 	mreq = calloc(1, sizeof(*mreq));
 	mreq->mid = req_id;
 	mreq->function = function;
-	mreq->mgmt_end_func = end_func;
 
 	switch (function) {
 	case ABORT_TASK:
@@ -512,7 +516,7 @@
 	}
 
 	if (send) {
-		mreq->mgmt_end_func(host_no, req_id, err);
+		tgt_drivers[target->lid]->mgmt_end_notify(host_no, req_id, err);
 		free(mreq);
 	}
 }

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/target.h	2006-08-29 01:04:15 UTC (rev 557)
@@ -18,7 +18,6 @@
 	uint64_t mid;
 	int busy;
 	int function;
-	mgmt_end_t *mgmt_end_func;
 };
 
 struct target {
@@ -54,7 +53,6 @@
 	int attribute;
 	uint64_t tag;
 	struct mgmt_req *mreq;
-	cmd_end_t *cmd_end_func;
 };
 
 enum {

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/tgtd.h	2006-08-29 01:04:15 UTC (rev 557)
@@ -36,6 +36,9 @@
 };
 
 extern int kreq_init(void);
+extern int kspace_send_tsk_mgmt_res(int host_no, uint64_t mid, int result);
+extern int kspace_send_cmd_res(int host_no, int len, int result,
+			       int rw, uint64_t addr, uint64_t tag);
 
 extern int ipc_init(void);
 
@@ -49,15 +52,11 @@
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
 extern void tgt_event_del(int fd);
 
-typedef int (cmd_end_t)(int host_no, int len, int result, int rw, uint64_t addr,
-			 uint64_t tag);
-typedef int (mgmt_end_t)(int host_no, uint64_t mid, int result);
 extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
-			    uint32_t data_len, int attribute, uint64_t tag,
-			    cmd_end_t *cmd_end);
+			    uint32_t data_len, int attribute, uint64_t tag);
 extern void target_cmd_done(int host_no, uint64_t tag);
 extern void target_mgmt_request(int host_no, int req_id, int function,
-				uint8_t *lun, uint64_t tag, mgmt_end_t *mgmt_end);
+				uint8_t *lun, uint64_t tag);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-29 00:39:51 UTC (rev 556)
+++ trunk/usr/tgtif.c	2006-08-29 01:04:15 UTC (rev 557)
@@ -79,7 +79,7 @@
 	return 0;
 }
 
-static int kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
+int kspace_send_tsk_mgmt_res(int host_no, uint64_t mid, int result)
 {
 	struct tgt_event ev;
 
@@ -90,8 +90,8 @@
 	return kreq_send(&ev);
 }
 
-static int kspace_send_cmd_res(int host_no, int len, int result,
-			       int rw, uint64_t addr, uint64_t tag)
+int kspace_send_cmd_res(int host_no, int len, int result,
+			int rw, uint64_t addr, uint64_t tag)
 {
 	struct tgt_event ev;
 
@@ -121,8 +121,7 @@
 	case TGT_KEVENT_CMD_REQ:
 		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
 				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
-				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag,
-				 kspace_send_cmd_res);
+				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag);
 		break;
 	case TGT_KEVENT_CMD_DONE:
 		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.tag);
@@ -132,8 +131,7 @@
 				    ev->k.tsk_mgmt_req.mid,
 				    ev->k.tsk_mgmt_req.function,
 				    ev->k.tsk_mgmt_req.lun,
-				    ev->k.tsk_mgmt_req.tag,
-				    kspace_send_tsk_mgmt);
+				    ev->k.tsk_mgmt_req.tag);
 		break;
 	default:
 		eprintf("unknown event %u\n", ev->type);



From tomo at mail.berlios.de  Tue Aug 29 08:27:41 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 29 Aug 2006 08:27:41 +0200
Subject: [Stgt-svn] r558 - in trunk/usr: . ibmvio
Message-ID: <200608290627.k7T6RfQ6016907@sheep.berlios.de>

Author: tomo
Date: 2006-08-29 08:27:37 +0200 (Tue, 29 Aug 2006)
New Revision: 558

Added:
   trunk/usr/bd_aio.c
Modified:
   trunk/usr/Makefile
   trunk/usr/bd_mmap.c
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Add AIO backedio operation.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/Makefile	2006-08-29 06:27:37 UTC (rev 558)
@@ -1,18 +1,28 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o bd_mmap.o
+TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
+BD_MMAP=1
 endif
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
-LIBS = -lcrypto
+LIBS += -lcrypto
 endif
 
+ifneq ($(BD_MMAP),)
+TGTD_OBJS += bd_mmap.o
+endif
+
+# ifneq ($(BD_AIO),)
+# TGTD_OBJS += bd_aio.o
+# LIBS += -laio
+# endif
+
 all: $(PROGRAMS)
 
 tgtd: $(TGTD_OBJS)

Added: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/bd_aio.c	2006-08-29 06:27:37 UTC (rev 558)
@@ -0,0 +1,135 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "libaio.h"
+
+/*
+ * We need an interface to wait for both synchronous and asynchronous
+ * descriptors (something like BSD's kqueue). Now we use a kernel
+ * patch to return an fd associated with the AIO context because Xen
+ * blktap uses it (so we avoid introducing another patch). However,
+ * I'm not sure the patch will go into mainline. Another approach,
+ * IO_CMD_EPOLL_WAIT, looks more promising. kqueue is promising too.
+ */
+
+#define REQUEST_ASYNC_FD 1
+
+/* FIXME */
+#define MAX_AIO_REQS 1024
+#define O_DIRECT 040000 /* who defines this?*/
+
+struct bd_aio_info {
+	int fd;
+	int aio_fd;
+
+	io_context_t ctx;
+	/* TODO: batch requests*/
+	struct iocb iocb[MAX_AIO_REQS];
+	struct io_event events[MAX_AIO_REQS];
+};
+
+static void aio_event_handler(int fd, void *data)
+{
+	struct tgt_device *dev = (struct tgt_device *) data;
+	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
+	int i, nr;
+	struct iocb *iocb;
+
+	nr = io_getevents(bai->ctx, 0, MAX_AIO_REQS, bai->events, NULL);
+
+	for (i = 0; i < nr; i++) {
+		iocb = bai->events[i].obj;
+		target_cmd_io_done(iocb->data, 0);
+	}
+}
+
+static struct tgt_device *bd_aio_open(char *path, int *fd, uint64_t *size)
+{
+	struct tgt_device *dev;
+	struct bd_aio_info *bai;
+	int err;
+
+	dev = malloc(sizeof(*dev) + sizeof(struct bd_aio_info));
+	if (!dev)
+		return NULL;
+
+	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE | O_DIRECT, size);
+	if (*fd < 0)
+		goto free_info;
+
+	bai = (struct bd_aio_info *)dev->bddata;
+
+	bai->ctx = (io_context_t) REQUEST_ASYNC_FD;
+	bai->aio_fd = io_setup(MAX_AIO_REQS, &bai->ctx);
+	if (bai->aio_fd < 0)
+		goto close_fd;
+
+	err = tgt_event_add(bai->aio_fd, POLL_IN, aio_event_handler, dev);
+	if (err)
+		goto aio_cb_destroy;
+
+	bai->fd = *fd;
+	return dev;
+
+aio_cb_destroy:
+	io_destroy(bai->ctx);
+close_fd:
+	close(*fd);
+free_info:
+	free(dev);
+
+	return NULL;
+}
+
+static void bd_aio_close(struct tgt_device *dev)
+{
+	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
+
+	tgt_event_del(bai->fd);
+	io_destroy(bai->ctx);
+	free(dev);
+}
+
+static int bd_aio_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
+			     unsigned long *uaddr,
+			     uint64_t offset, int *async, void *key)
+{
+	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
+	struct iocb iocb, *io;
+
+	*async = 1;
+
+	io = &iocb;
+	memset(io, 0, sizeof(*io));
+
+	io->data = key;
+	if (rw == READ)
+		io_prep_pread(io, bai->fd, uaddr, datalen, offset);
+	else
+		io_prep_pwrite(io, bai->fd, uaddr, datalen, offset);
+
+	return io_submit(bai->ctx, 1, &io);
+}
+
+static int bd_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	return 0;
+}
+
+struct backedio_template aio_bdt = {
+	.bd_open	= bd_aio_open,
+	.bd_close	= bd_aio_close,
+	.bd_cmd_submit	= bd_aio_cmd_submit,
+	.bd_cmd_done	= bd_aio_cmd_done,
+};

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/bd_mmap.c	2006-08-29 06:27:37 UTC (rev 558)
@@ -67,7 +67,8 @@
 }
 
 static int bd_mmap_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
-			      unsigned long *uaddr, uint64_t offset)
+			      unsigned long *uaddr, uint64_t offset, int *async,
+			      void *key)
 {
 	int fd = dev->fd;
 	void *p;

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/ibmvio/ibmvio.h	2006-08-29 06:27:37 UTC (rev 558)
@@ -11,6 +11,6 @@
 	.scsi_report_luns	= scsi_report_luns,
 	.scsi_inquiry		= scsi_inquiry,
 	.cmd_end_notify		= kspace_send_cmd_res,
-	.mgtm_end_notify	= kspace_send_tsk_mgmt_res,
+	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
 	.bdt			= &mmap_bdt,
 };

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/scsi.c	2006-08-29 06:27:37 UTC (rev 558)
@@ -464,14 +464,15 @@
 int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
-		     struct tgt_device *dev, struct list_head *dev_list)
+		     struct tgt_device *dev, struct list_head *dev_list, int *async,
+		     void *key)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t *data, *scb = pdu;
 
 	dprintf("%x %u\n", scb[0], datalen);
 
-	*offset = 0;
+	*async = *offset = 0;
 	data = tgt_drivers[lid]->bdt->bd_cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
 							  datalen);
 
@@ -529,7 +530,7 @@
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
 		result = tgt_drivers[lid]->bdt->bd_cmd_submit(dev, *rw, datalen,
-							      uaddr, *offset);
+							      uaddr, *offset, async, key);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/target.c	2006-08-29 06:27:37 UTC (rev 558)
@@ -252,7 +252,7 @@
 	struct target *target;
 	struct tgt_cmd_queue *q;
 	struct cmd *cmd;
-	int result, enabled, len = 0;
+	int result, enabled, async, len = 0;
 	uint64_t offset, dev_id;
 	uint8_t rw = 0, mmapped = 0;
 	unsigned long uaddr = 0;
@@ -291,15 +291,18 @@
 					  &len, data_len,
 					  &uaddr, &rw, &mmapped, &offset,
 					  lun, cmd->dev,
-					  &target->device_list);
+					  &target->device_list, &async, (void *) cmd);
 
 		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
 		dprintf("%" PRIx64 " %x %lx %" PRIu64 " %d\n",
 			tag, scb[0], uaddr, offset, result);
 
+		cmd->rw = rw;
 		set_cmd_processed(cmd);
-		tgt_drivers[target->lid]->cmd_end_notify(host_no, len, result, rw, uaddr, tag);
+		if (!async)
+			tgt_drivers[target->lid]->cmd_end_notify(host_no, len, result,
+								 rw, uaddr, tag);
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
@@ -315,10 +318,22 @@
 	return 0;
 }
 
+void target_cmd_io_done(void *key, int result)
+{
+	struct cmd *cmd = (struct cmd *) key;
+
+	/* TODO: sense in case of error. */
+	tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno,
+							cmd->len, result,
+							cmd->rw, cmd->uaddr,
+							cmd->tag);
+	return;
+}
+
 static void post_cmd_done(struct tgt_cmd_queue *q)
 {
 	struct cmd *cmd, *tmp;
-	int enabled, result, len = 0;
+	int enabled, result, async, len = 0;
 	uint8_t rw = 0, mmapped = 0;
 	uint64_t offset;
 	unsigned long uaddr = 0;
@@ -330,23 +345,21 @@
 			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
 			result = scsi_cmd_perform(cmd->c_target->lid,
 						  cmd->hostno, cmd->scb,
-						  &len,
-						  cmd->len,
-						  &uaddr,
-						  &rw,
-						  &mmapped,
-						  &offset,
-						  cmd->lun,
-						  cmd->dev,
-						  &cmd->c_target->device_list);
+						  &len, cmd->len, &uaddr,
+						  &rw, &mmapped, &offset,
+						  cmd->lun, cmd->dev,
+						  &cmd->c_target->device_list,
+						  &async, (void *) cmd);
+			cmd->rw = rw;
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
 			set_cmd_processed(cmd);
-			tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno,
-									len,
-									result,
-									rw,
-									uaddr,
-									cmd->tag);
+			if (!async)
+				tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno,
+										len,
+										result,
+										rw,
+										uaddr,
+										cmd->tag);
 		} else
 			break;
 	}

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/target.h	2006-08-29 06:27:37 UTC (rev 558)
@@ -52,6 +52,7 @@
 	uint8_t lun[8];
 	int attribute;
 	uint64_t tag;
+	int rw;
 	struct mgmt_req *mreq;
 };
 

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/tgtd.c	2006-08-29 06:27:37 UTC (rev 558)
@@ -204,7 +204,7 @@
 	struct sigaction sa_old;
 	struct sigaction sa_new;
 	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS;
-	int is_daemon = 1, is_debug = 1;
+	int is_daemon = 1, is_debug = 0;
 	char *modes = NULL;
 
 	/* do not allow ctrl-c for now... */

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-29 01:04:15 UTC (rev 557)
+++ trunk/usr/tgtd.h	2006-08-29 06:27:37 UTC (rev 558)
@@ -31,7 +31,8 @@
 	void (*bd_close)(struct tgt_device *dev);
 	void *(*bd_cmd_buffer_alloc)(int devio, uint32_t datalen);
 	int (*bd_cmd_submit)(struct tgt_device *dev, int rw, uint32_t datalen,
-			     unsigned long *uaddr, uint64_t offset);
+			     unsigned long *uaddr, uint64_t offset, int *async,
+			     void *key);
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 };
 
@@ -58,11 +59,14 @@
 extern void target_mgmt_request(int host_no, int req_id, int function,
 				uint8_t *lun, uint64_t tag);
 
+extern void target_cmd_io_done(void *key, int result);
+
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
-			    struct tgt_device *dev, struct list_head *dev_list);
+			    struct tgt_device *dev, struct list_head *dev_list,
+			    int *async, void *key);
 
 extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq);



From tomo at mail.berlios.de  Thu Aug 31 09:44:34 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 09:44:34 +0200
Subject: [Stgt-svn] r559 - trunk/usr
Message-ID: <200608310744.k7V7iYcw008189@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 09:44:04 +0200 (Thu, 31 Aug 2006)
New Revision: 559

Modified:
   trunk/usr/Makefile
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/driver.h
   trunk/usr/mgmt.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Preparation for user-mode iSCSI target code.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/Makefile	2006-08-31 07:44:04 UTC (rev 559)
@@ -10,18 +10,19 @@
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
+TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o)
 LIBS += -lcrypto
+BD_AIO=1
 endif
 
 ifneq ($(BD_MMAP),)
 TGTD_OBJS += bd_mmap.o
 endif
 
-# ifneq ($(BD_AIO),)
-# TGTD_OBJS += bd_aio.o
-# LIBS += -laio
-# endif
+ifneq ($(BD_AIO),)
+TGTD_OBJS += bd_aio.o
+LIBS += -laio
+endif
 
 all: $(PROGRAMS)
 

Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/bd_aio.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -1,3 +1,24 @@
+/*
+ * AIO file backed routine
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
@@ -5,14 +26,14 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <signal.h>
+#include <libaio.h>
 
 #include <linux/fs.h>
+#include <sys/epoll.h>
 
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
-#include "libaio.h"
 
 /*
  * We need an interface to wait for both synchronous and asynchronous
@@ -39,17 +60,21 @@
 	struct io_event events[MAX_AIO_REQS];
 };
 
-static void aio_event_handler(int fd, void *data)
+static void aio_event_handler(int fd, int events, void *data)
 {
-	struct tgt_device *dev = (struct tgt_device *) data;
-	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
+	struct tgt_device *dev;
+	struct bd_aio_info *bai;
 	int i, nr;
 	struct iocb *iocb;
 
+	dev = (struct tgt_device *) data;
+	bai = (struct bd_aio_info *) dev->bddata;
+
 	nr = io_getevents(bai->ctx, 0, MAX_AIO_REQS, bai->events, NULL);
 
 	for (i = 0; i < nr; i++) {
 		iocb = bai->events[i].obj;
+		dprintf("%p\n", iocb->data);
 		target_cmd_io_done(iocb->data, 0);
 	}
 }
@@ -60,25 +85,29 @@
 	struct bd_aio_info *bai;
 	int err;
 
-	dev = malloc(sizeof(*dev) + sizeof(struct bd_aio_info));
+	dev = zalloc(sizeof(*dev) + sizeof(*bai));
 	if (!dev)
 		return NULL;
 
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE | O_DIRECT, size);
+	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
 	if (*fd < 0)
-		goto free_info;
+		goto free_dev;
 
-	bai = (struct bd_aio_info *)dev->bddata;
+	bai = (struct bd_aio_info *) dev->bddata;
 
 	bai->ctx = (io_context_t) REQUEST_ASYNC_FD;
 	bai->aio_fd = io_setup(MAX_AIO_REQS, &bai->ctx);
-	if (bai->aio_fd < 0)
+	if (bai->aio_fd < 0) {
+		eprintf("Can't setup aio fd, %m\n");
 		goto close_fd;
+	}
 
-	err = tgt_event_add(bai->aio_fd, POLL_IN, aio_event_handler, dev);
+	err = tgt_event_add(bai->aio_fd, EPOLLIN, aio_event_handler, dev);
 	if (err)
 		goto aio_cb_destroy;
 
+	dprintf("Succeeded to setup aio fd, %s\n", path);
+
 	bai->fd = *fd;
 	return dev;
 
@@ -86,7 +115,7 @@
 	io_destroy(bai->ctx);
 close_fd:
 	close(*fd);
-free_info:
+free_dev:
 	free(dev);
 
 	return NULL;
@@ -107,19 +136,24 @@
 {
 	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
 	struct iocb iocb, *io;
+	int err;
 
 	*async = 1;
 
 	io = &iocb;
 	memset(io, 0, sizeof(*io));
 
-	io->data = key;
+	dprintf("%d %d %u %lx %" PRIx64 " %p\n", bai->fd, rw, datalen, *uaddr, offset, key);
+
 	if (rw == READ)
-		io_prep_pread(io, bai->fd, uaddr, datalen, offset);
+		io_prep_pread(io, bai->fd, (void *) *uaddr, datalen, offset);
 	else
-		io_prep_pwrite(io, bai->fd, uaddr, datalen, offset);
+		io_prep_pwrite(io, bai->fd, (void *) *uaddr, datalen, offset);
 
-	return io_submit(bai->ctx, 1, &io);
+	io->data = key;
+	err = io_submit(bai->ctx, 1, &io);
+
+	return 0;
 }
 
 static int bd_aio_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/bd_mmap.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -54,18 +54,6 @@
 	free(dev);
 }
 
-static void *bd_mmap_cmd_buffer_alloc(int devio, uint32_t datalen)
-{
-	void *data = NULL;
-	if (!devio) {
-		datalen = ALIGN(datalen, PAGE_SIZE);
-		data = valloc(datalen);
-		if (data)
-			memset(data, 0, datalen);
-	}
-	return data;
-}
-
 static int bd_mmap_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
 			      unsigned long *uaddr, uint64_t offset, int *async,
 			      void *key)
@@ -114,7 +102,6 @@
 struct backedio_template mmap_bdt = {
 	.bd_open		= bd_mmap_open,
 	.bd_close		= bd_mmap_close,
-	.bd_cmd_buffer_alloc	= bd_mmap_cmd_buffer_alloc,
 	.bd_cmd_submit		= bd_mmap_cmd_submit,
 	.bd_cmd_done		= bd_mmap_cmd_done,
 };

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/driver.h	2006-08-31 07:44:04 UTC (rev 559)
@@ -1,9 +1,9 @@
-extern struct backedio_template mmap_bdt;
+extern struct backedio_template mmap_bdt, aio_bdt;
 
 struct tgt_driver {
 	const char *name;
 
-	int (*init) (int *);
+	int (*init) (void);
 
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/mgmt.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -28,7 +28,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <signal.h>
+#include <sys/epoll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
@@ -196,7 +196,7 @@
 		eprintf("can't write, %m\n");
 }
 
-static void mgmt_event_handler(int accept_fd, void *data)
+static void mgmt_event_handler(int accept_fd, int events, void *data)
 {
 	int fd, err;
 	char sbuf[BUFSIZE], rbuf[BUFSIZE];
@@ -304,12 +304,12 @@
 	}
 
 	err = listen(fd, 32);
-	if (err < 0) {
+	if (err) {
 		eprintf("can't listen a socket, %m\n");
 		goto out;
 	}
 
-	err = tgt_event_add(fd, POLL_IN, mgmt_event_handler, NULL);
+	err = tgt_event_add(fd, EPOLLIN, mgmt_event_handler, NULL);
 	if (err)
 		goto out;
 

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/scsi.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -412,7 +412,7 @@
 
 static int scsi_cmd_rw(uint8_t *scb, uint8_t *rw)
 {
-	int is_data = 1;
+	int is_alloc = 0;
 
 	switch (scb[0]) {
 	case READ_6:
@@ -427,9 +427,9 @@
 		*rw = WRITE;
 		break;
 	default:
-		is_data = 0;
+		is_alloc = 1;
 	}
-	return is_data;
+	return is_alloc;
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
@@ -461,20 +461,22 @@
 	return fn(p);
 }
 
-int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
-		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
+int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu,
+		     int *len, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
 		     struct tgt_device *dev, struct list_head *dev_list, int *async,
 		     void *key)
 {
 	int result = SAM_STAT_GOOD;
-	uint8_t *data, *scb = pdu;
+	uint8_t *data = NULL, *scb = pdu;
 
 	dprintf("%x %u\n", scb[0], datalen);
 
 	*async = *offset = 0;
-	data = tgt_drivers[lid]->bdt->bd_cmd_buffer_alloc(scsi_cmd_rw(scb, rw),
-							  datalen);
+	if (scsi_cmd_rw(scb, rw)) {
+		data = valloc(PAGE_SIZE);
+		memset(data, 0, PAGE_SIZE);
+	}
 
 	if (!dev)
 		switch (scb[0]) {

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/target.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -246,7 +246,8 @@
 	}
 }
 
-int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun, uint32_t data_len,
+int target_cmd_queue(int host_no, uint8_t *scb, unsigned long uaddr,
+		     uint8_t *lun, uint32_t data_len,
 		     int attribute, uint64_t tag)
 {
 	struct target *target;
@@ -255,7 +256,6 @@
 	int result, enabled, async, len = 0;
 	uint64_t offset, dev_id;
 	uint8_t rw = 0, mmapped = 0;
-	unsigned long uaddr = 0;
 
 	target = host_to_target(host_no);
 	if (!target) {
@@ -278,10 +278,9 @@
 	dprintf("%x %" PRIx64 "\n", scb[0], dev_id);
 
 	cmd->dev = device_lookup(target, dev_id);
-	if (cmd->dev) {
-		uaddr = cmd->dev->addr;
+	if (cmd->dev)
 		q = &cmd->dev->cmd_queue;
-	} else
+	else
 		q = &target->cmd_queue;
 
 	enabled = cmd_enabled(q, cmd);
@@ -295,8 +294,8 @@
 
 		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
-		dprintf("%" PRIx64 " %x %lx %" PRIu64 " %d\n",
-			tag, scb[0], uaddr, offset, result);
+		dprintf("%" PRIx64 " %x %lx %" PRIu64 " %d %d\n",
+			tag, scb[0], uaddr, offset, result, async);
 
 		cmd->rw = rw;
 		set_cmd_processed(cmd);
@@ -312,6 +311,7 @@
 		memcpy(cmd->scb, scb, sizeof(cmd->scb));
 		memcpy(cmd->lun, lun, sizeof(cmd->lun));
 		cmd->len = data_len;
+		cmd->uaddr = uaddr;
 		list_add_tail(&cmd->qlist, &q->queue);
 	}
 
@@ -336,7 +336,6 @@
 	int enabled, result, async, len = 0;
 	uint8_t rw = 0, mmapped = 0;
 	uint64_t offset;
-	unsigned long uaddr = 0;
 
 	list_for_each_entry_safe(cmd, tmp, &q->queue, qlist) {
 		enabled = cmd_enabled(q, cmd);
@@ -345,20 +344,21 @@
 			dprintf("perform %" PRIx64 " %x\n", cmd->tag, cmd->attribute);
 			result = scsi_cmd_perform(cmd->c_target->lid,
 						  cmd->hostno, cmd->scb,
-						  &len, cmd->len, &uaddr,
+						  &len, cmd->len,
+						  (unsigned long *) &cmd->uaddr,
 						  &rw, &mmapped, &offset,
 						  cmd->lun, cmd->dev,
 						  &cmd->c_target->device_list,
 						  &async, (void *) cmd);
 			cmd->rw = rw;
-			cmd_post_perform(q, cmd, uaddr, len, mmapped);
+			cmd_post_perform(q, cmd, cmd->uaddr, len, mmapped);
 			set_cmd_processed(cmd);
 			if (!async)
 				tgt_drivers[cmd->c_target->lid]->cmd_end_notify(cmd->hostno,
 										len,
 										result,
 										rw,
-										uaddr,
+										cmd->uaddr,
 										cmd->tag);
 		} else
 			break;

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/tgtd.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -124,19 +124,47 @@
 	return err;
 }
 
+static struct tgt_event *tgt_event_lookup(int fd)
+{
+	struct tgt_event *tev;
+
+	list_for_each_entry(tev, &tgt_events_list, e_list) {
+		if (tev->fd == fd)
+			return tev;
+	}
+	return NULL;
+}
+
 void tgt_event_del(int fd)
 {
 	struct tgt_event *tev;
 
+	tev = tgt_event_lookup(fd);
+	if (!tev) {
+		eprintf("Cannot find event %d\n", fd);
+		return;
+	}
+
 	epoll_ctl(ep_fd, EPOLL_CTL_DEL, fd, NULL);
+	list_del(&tev->e_list);
+	free(tev);
+}
 
-	list_for_each_entry(tev, &tgt_events_list, e_list) {
-		if (tev->fd == fd) {
-			list_del(&tev->e_list);
-			free(tev);
-			break;
-		}
+int tgt_event_modify(int fd, int events)
+{
+	struct epoll_event ev;
+	struct tgt_event *tev;
+
+	tev = tgt_event_lookup(fd);
+	if (!tev) {
+		eprintf("Cannot find event %d\n", fd);
+		return -EINVAL;
 	}
+
+	ev.events = events;
+	ev.data.ptr = tev;
+
+	return epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &ev);
 }
 
 static void event_loop(void)
@@ -162,7 +190,7 @@
 
 	for (i = 0; i < nevent; i++) {
 		tev = (struct tgt_event *) events[i].data.ptr;
-		tev->handler(tev->fd, tev->data);
+		tev->handler(tev->fd, events[i].events, tev->data);
 	}
 
 	goto retry;
@@ -171,7 +199,7 @@
 static int lld_init(char *data)
 {
 	char *list, *p, *q;
-	int index, err, np, ndriver = 0;
+	int index, err, ndriver = 0;
 
 	p = list = strdup(data);
 	if (!p)
@@ -184,9 +212,8 @@
 		index = get_driver_index(p);
 		p = q;
 		if (index >= 0) {
-			np = 0;
 			if (tgt_drivers[index]->init) {
-				err = tgt_drivers[index]->init(&np);
+				err = tgt_drivers[index]->init();
 				if (err)
 					continue;
 			}
@@ -239,7 +266,14 @@
 		}
 	}
 
-	nr_lld = lld_init(modes);
+	ep_fd = epoll_create(maxfds);
+	if (ep_fd < 0) {
+		fprintf(stderr, "can't create epoll fd, %m\n");
+		exit(1);
+	}
+
+	if (modes)
+		nr_lld = lld_init(modes);
 	if (!nr_lld) {
 		printf("No available low level driver!\n");
 		exit(1);
@@ -254,12 +288,6 @@
 	if (err)
 		exit(1);
 
-	ep_fd = epoll_create(maxfds);
-	if (ep_fd < 0) {
-		eprintf("can't create epoll fd, %m\n");
-		exit(1);
-	}
-
 	err = kreq_init();
 	if (err)
 		eprintf("No kernel interface\n");

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/tgtd.h	2006-08-31 07:44:04 UTC (rev 559)
@@ -29,7 +29,6 @@
 struct backedio_template {
 	struct tgt_device *(*bd_open)(char *path, int *fd, uint64_t *size);
 	void (*bd_close)(struct tgt_device *dev);
-	void *(*bd_cmd_buffer_alloc)(int devio, uint32_t datalen);
 	int (*bd_cmd_submit)(struct tgt_device *dev, int rw, uint32_t datalen,
 			     unsigned long *uaddr, uint64_t offset, int *async,
 			     void *key);
@@ -49,12 +48,14 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
-typedef void (event_handler_t)(int fd, void *data);
+typedef void (event_handler_t)(int fd, int events, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
 extern void tgt_event_del(int fd);
+extern int tgt_event_modify(int fd, int events);
 
-extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t *lun,
-			    uint32_t data_len, int attribute, uint64_t tag);
+extern int target_cmd_queue(int host_no, uint8_t *scb, unsigned long uaddr,
+			    uint8_t *lun, uint32_t data_len,
+			    int attribute, uint64_t tag);
 extern void target_cmd_done(int host_no, uint64_t tag);
 extern void target_mgmt_request(int host_no, int req_id, int function,
 				uint8_t *lun, uint64_t tag);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-08-29 06:27:37 UTC (rev 558)
+++ trunk/usr/tgtif.c	2006-08-31 07:44:04 UTC (rev 559)
@@ -24,12 +24,12 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
-#include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/epoll.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
 
@@ -106,7 +106,7 @@
 	return kreq_send(&ev);
 }
 
-static void kern_event_handler(int fd, void *data)
+static void kern_event_handler(int fd, int events, void *data)
 {
 	struct tgt_event *ev;
 
@@ -120,6 +120,8 @@
 	switch (ev->type) {
 	case TGT_KEVENT_CMD_REQ:
 		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
+				 0,
+/* 				 ev->k.cmd_req.uaddr, */
 				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
 				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag);
 		break;
@@ -200,7 +202,7 @@
 	kuring.buf = buf;
 	ukring.buf = buf + size;
 
-	err = tgt_event_add(chrfd, POLL_IN, kern_event_handler, NULL);
+	err = tgt_event_add(chrfd, EPOLLIN, kern_event_handler, NULL);
 	if (err)
 		close(chrfd);
 	return err;



From tomo at mail.berlios.de  Thu Aug 31 09:48:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 09:48:10 +0200
Subject: [Stgt-svn] r560 - branches
Message-ID: <200608310748.k7V7mAvo009120@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 09:48:06 +0200 (Thu, 31 Aug 2006)
New Revision: 560

Added:
   branches/kern-iscsi/
Log:
This branch is for old kernel-mode iSCSI target code.


Copied: branches/kern-iscsi (from rev 559, trunk)



From tomo at mail.berlios.de  Thu Aug 31 09:49:35 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 09:49:35 +0200
Subject: [Stgt-svn] r561 - trunk/usr/iscsi
Message-ID: <200608310749.k7V7nZ23009752@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 09:49:26 +0200 (Thu, 31 Aug 2006)
New Revision: 561

Modified:
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/istgt.c
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
Log:
Add user-space iSCSI target code.


Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/conn.c	2006-08-31 07:49:26 UTC (rev 561)
@@ -13,6 +13,8 @@
 #include <sys/stat.h>
 
 #include "iscsid.h"
+#include "tgtd.h"
+#include "util.h"
 
 #define ISCSI_CONN_NEW		1
 #define ISCSI_CONN_EXIT		5
@@ -33,14 +35,28 @@
 {
 	struct connection *conn;
 
-	if (!(conn = malloc(sizeof(*conn))))
+	conn = zalloc(sizeof(*conn));
+	if (!conn)
 		return NULL;
 
-	memset(conn, 0, sizeof(*conn));
+	conn->req_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->req_buffer) {
+		free(conn);
+		return NULL;
+	}
+	conn->rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->rsp_buffer) {
+		free(conn->req_buffer);
+		free(conn);
+		return NULL;
+	}
+
+
 	conn->state = STATE_FREE;
 	param_set_defaults(conn->session_param, session_keys);
 
 	INIT_LIST_HEAD(&conn->clist);
+	INIT_LIST_HEAD(&conn->tx_clist);
 
 	return conn;
 }
@@ -48,6 +64,8 @@
 void conn_free(struct connection *conn)
 {
 	list_del(&conn->clist);
+	free(conn->req_buffer);
+	free(conn->rsp_buffer);
 	free(conn->initiator);
 	free(conn);
 }
@@ -64,9 +82,8 @@
 	return NULL;
 }
 
-void conn_take_fd(struct connection *conn, int fd)
+int conn_take_fd(struct connection *conn, int fd)
 {
-	int i, err;
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
 	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
@@ -74,69 +91,23 @@
 
 	conn->session->conn_cnt++;
 
-	err = ki->create_conn(thandle, conn->session->ksid, conn->kcid,
-			      &conn->kcid);
-	if (err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
+	/* FIXME */
+	tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
 
-	for (i = 0; i < ISCSI_PARAM_ERL + 1; i++) {
-		/* FIXME */
-		if (i == ISCSI_PARAM_DATADGST_EN || i == ISCSI_PARAM_HDRDGST_EN)
-			continue;
-		if (ki->set_param(thandle, conn->session->ksid, conn->kcid, i,
-				  &conn->session_param[i].val,
-				  sizeof(uint32_t), &err) || err) {
-			break;
-		}
-	}
-
-	if (ki->bind_conn(thandle, conn->session->ksid, conn->kcid, fd, 1, &err) || err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
-
-	if (ki->start_conn(thandle, conn->session->ksid, conn->kcid, &err) || err) {
-		eprintf("%d %d %u %u %u %" PRIx64,
-			fd, err, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
-		goto out;
-	}
-
-out:
-	return;
+	return 0;
 }
 
 void conn_read_pdu(struct connection *conn)
 {
-	conn->iostate = IOSTATE_READ_BHS;
-	conn->buffer = (void *)&conn->req.bhs;
-	conn->rwsize = BHS_SIZE;
+	conn->rx_iostate = IOSTATE_READ_BHS;
+	conn->rx_buffer = (void *)&conn->req.bhs;
+	conn->rx_size = BHS_SIZE;
 }
 
 void conn_write_pdu(struct connection *conn)
 {
-	conn->iostate = IOSTATE_WRITE_BHS;
+	conn->tx_iostate = IOSTATE_WRITE_BHS;
 	memset(&conn->rsp, 0, sizeof(conn->rsp));
-	conn->buffer = (void *)&conn->rsp.bhs;
-	conn->rwsize = BHS_SIZE;
+	conn->tx_buffer = (void *)&conn->rsp.bhs;
+	conn->tx_size = BHS_SIZE;
 }
-
-void conn_free_pdu(struct connection *conn)
-{
-	conn->iostate = IOSTATE_FREE;
-	if (conn->req.ahs) {
-		free(conn->req.ahs);
-		conn->req.ahs = NULL;
-	}
-	if (conn->rsp.ahs) {
-		free(conn->rsp.ahs);
-		conn->rsp.ahs = NULL;
-	}
-	if (conn->rsp.data) {
-		free(conn->rsp.data);
-		conn->rsp.data = NULL;
-	}
-}

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/iscsi.h	2006-08-31 07:49:26 UTC (rev 561)
@@ -1,16 +1,14 @@
-extern int iscsi_init(int *);
-extern int iscsi_poll_init(struct pollfd *);
-extern int iscsi_event_handle(struct pollfd *);
+extern int iscsi_init(void);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
-extern int iscsi_target_bind(int);
+extern int iscsi_cmd_done(int host_no, int len, int result, int rw,
+			  uint64_t addr, uint64_t tag);
 
 struct tgt_driver iscsi = {
 	.name		= "iscsi",
 	.init		= iscsi_init,
-	.poll_init	= iscsi_poll_init,
-	.event_handle	= iscsi_event_handle,
 	.target_create	= iscsi_target_create,
 	.target_destroy	= iscsi_target_destroy,
-	.target_bind	= iscsi_target_bind,
+	.cmd_end_notify	= iscsi_cmd_done,
+	.bdt		= &aio_bdt,
 };

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/iscsid.c	2006-08-31 07:49:26 UTC (rev 561)
@@ -1,20 +1,28 @@
 /*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
+ * Software iSCSI target protocol routines
  *
- * Released under the terms of the GNU GPL v2.0.
+ * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
+ *   licensed under the terms of the GNU GPL v2.0,
  */
-
 #include <ctype.h>
 #include <errno.h>
+#include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <arpa/inet.h>
+#include <scsi/scsi.h>
+#include <sys/epoll.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-
 #include "iscsid.h"
+#include "tgtd.h"
+#include "util.h"
 
 static struct iscsi_key login_keys[] = {
 	{"InitiatorName",},
@@ -88,12 +96,10 @@
 	int len = keylen + valuelen + 2;
 	char *buffer;
 
-	if (!conn->rsp.datasize) {
-		if (!conn->rsp_buffer)
-			conn->rsp_buffer = malloc(INCOMING_BUFSIZE);
+	if (!conn->rsp.datasize)
 		conn->rsp.data = conn->rsp_buffer;
-	}
-	if (conn->rwsize + len > INCOMING_BUFSIZE) {
+
+	if (conn->tx_size + len > INCOMING_BUFSIZE) {
 		log_warning("Dropping key (%s=%s)", key, value);
 		return;
 	}
@@ -448,7 +454,7 @@
 
 	switch (ISCSI_LOGIN_CURRENT_STAGE(req->flags)) {
 	case ISCSI_SECURITY_NEGOTIATION_STAGE:
-		log_debug("Login request (security negotiation): %d", conn->state);
+		dprintf("Login request (security negotiation): %d", conn->state);
 		rsp->flags = ISCSI_SECURITY_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
@@ -484,7 +490,8 @@
 
 		break;
 	case ISCSI_OP_PARMS_NEGOTIATION_STAGE:
-		log_debug("Login request (operational negotiation): %d", conn->state);
+		dprintf("Login request (operational negotiation): %d\n",
+			conn->state);
 		rsp->flags = ISCSI_OP_PARMS_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
@@ -676,7 +683,7 @@
 
 int cmnd_execute(struct connection *conn)
 {
-	int res = 1;
+	int res = 0;
 
 	switch (conn->req.bhs.opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_LOGIN:
@@ -702,7 +709,7 @@
 		break;
 	default:
 		//reject
-		res = 0;
+		res = 1;
 		break;
 	}
 
@@ -728,3 +735,390 @@
 		break;
 	}
 }
+
+static int iscsi_cmd_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp->itt = ctask->tag;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp->cmd_status = ctask->result;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+
+	return 0;
+}
+
+static int iscsi_data_rsp_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	int residual, datalen, exp_datalen = ntohl(req->data_length);
+	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
+	rsp->itt = ctask->tag;
+	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
+
+	rsp->offset = cpu_to_be32(ctask->offset);
+	rsp->datasn = cpu_to_be32(ctask->data_sn++);
+	rsp->cmd_status = ctask->result;
+
+	datalen = min(exp_datalen, ctask->len);
+	datalen -= ctask->offset;
+
+	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, ctask->len, max_burst, rsp->itt);
+
+	if (datalen <= max_burst) {
+		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
+		if (ctask->len < exp_datalen) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = exp_datalen - ctask->len;
+		} else if (ctask->len > exp_datalen) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = ctask->len - exp_datalen;
+		} else
+			residual = 0;
+		rsp->residual_count = cpu_to_be32(residual);
+	} else
+		datalen = max_burst;
+
+	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
+		rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+
+	conn->rsp.datasize = datalen;
+	hton24(rsp->dlength, datalen);
+	conn->rsp.data = (void *) (unsigned long) ctask->addr;
+	conn->rsp.data += ctask->offset;
+
+	ctask->offset += datalen;
+
+	return 0;
+}
+
+static int iscsi_r2t_build(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
+	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
+	memset(rsp, 0, sizeof(*rsp));
+
+	rsp->opcode = ISCSI_OP_R2T;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	memcpy(rsp->lun, ctask->req.lun, sizeof(rsp->lun));
+
+	rsp->itt = ctask->req.itt;
+	rsp->r2tsn = cpu_to_be32(ctask->exp_r2tsn++);
+	rsp->data_offset = cpu_to_be32(ctask->offset);
+	rsp->ttt = (unsigned long) ctask;
+	length = min(ctask->r2t_count, max_burst);
+	rsp->data_length = cpu_to_be32(length);
+	ctask->r2t_count -= length;
+
+	return 0;
+}
+
+int iscsi_cmd_done(int host_no, int len, int result, int rw, uint64_t addr,
+		   uint64_t tag)
+{
+	struct session *session;
+	struct iscsi_ctask *ctask;
+
+	dprintf("%u %d %d %d %" PRIx64 " %" PRIx64 "\n", host_no, len, result,
+		rw, addr, tag);
+	session = session_lookup(host_no);
+	if (!session)
+		return -EINVAL;
+
+	list_for_each_entry(ctask, &session->cmd_list, c_hlist) {
+		if (ctask->tag == tag)
+			goto found;
+	}
+	eprintf("Cannot find a task %" PRIx64 "\n", tag);
+	return -EINVAL;
+
+found:
+	eprintf("found a task %" PRIx64 "\n", tag);
+	ctask->addr = addr;
+	ctask->result = result;
+	ctask->len = len;
+	ctask->rw = rw;
+
+	list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+	tgt_event_modify(ctask->conn->fd, EPOLLIN|EPOLLOUT);
+
+	return 0;
+}
+
+static int iscsi_data_out_rx_start(struct connection *conn)
+{
+	struct iscsi_ctask *ctask;
+	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
+
+	list_for_each_entry(ctask, &conn->session->cmd_list, c_hlist) {
+		if (ctask->tag == req->itt)
+			goto found;
+	}
+	return -EINVAL;
+found:
+	eprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
+		ctask->r2t_count,
+		ntoh24(req->dlength), be32_to_cpu(req->offset));
+
+/* 	conn->rx_buffer = (void *) (unsigned long) ctask->addr; */
+	conn->rx_buffer = (void *) (unsigned long) ctask->c_buffer;
+	conn->rx_buffer += be32_to_cpu(req->offset);
+	conn->rx_size = ntoh24(req->dlength);
+
+	ctask->offset += ntoh24(req->dlength);
+
+	conn->rx_ctask = ctask;
+
+	return 0;
+}
+
+static int iscsi_cmd_init(struct connection *conn)
+{
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
+	struct iscsi_ctask *ctask;
+	int len;
+
+	ctask = zalloc(sizeof(*ctask));
+	if (!ctask)
+		return -ENOMEM;
+
+	memcpy(&ctask->req, req, sizeof(*req));
+	ctask->tag = req->itt;
+	ctask->conn = conn;
+	INIT_LIST_HEAD(&ctask->c_hlist);
+
+	list_add(&ctask->c_hlist, &conn->session->cmd_list);
+
+	dprintf("%u %x %d %d %u\n", conn->session->tsih,
+		req->cdb[0], ntohl(req->data_length),
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
+
+	len = ntohl(req->data_length);
+	if (len) {
+		ctask->c_buffer = malloc(len);
+		if (!ctask->c_buffer)
+			return -ENOMEM;
+		dprintf("%p\n", ctask->c_buffer);
+	}
+
+	conn->exp_cmd_sn++;
+	conn->rx_ctask = ctask;
+
+	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
+		conn->rx_size = ntoh24(req->dlength);
+		conn->rx_buffer = ctask->c_buffer;
+		ctask->r2t_count = ntohl(req->data_length) - conn->rx_size;
+		ctask->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
+		ctask->offset = conn->rx_size;
+
+		dprintf("%d %d %d %d\n", conn->rx_size, ctask->r2t_count,
+			ctask->unsol_count, ctask->offset);
+	}
+
+	return 0;
+}
+
+int cmd_attr(struct iscsi_ctask *ctask)
+{
+	int attr;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+
+	switch (req->flags & ISCSI_FLAG_CMD_ATTR_MASK) {
+	case ISCSI_ATTR_UNTAGGED:
+	case ISCSI_ATTR_SIMPLE:
+		attr = SIMPLE_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_HEAD_OF_QUEUE:
+		attr = HEAD_OF_QUEUE_TAG;
+		break;
+	case ISCSI_ATTR_ORDERED:
+	default:
+		attr = ORDERED_QUEUE_TAG;
+	}
+	return attr;
+}
+
+static int __iscsi_cmd_rx_done(struct iscsi_ctask *ctask)
+{
+	struct connection *conn = ctask->conn;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	unsigned long uaddr = (unsigned long) ctask->c_buffer;
+	int err = 0;
+
+	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
+		if (ctask->r2t_count) {
+			if (ctask->unsol_count)
+				;
+			else
+				list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+		} else
+			err = target_cmd_queue(conn->session->tsih, req->cdb,
+					       uaddr, req->lun,
+					       ntohl(req->data_length),
+					       cmd_attr(ctask), req->itt);
+
+	} else
+		err = target_cmd_queue(conn->session->tsih, req->cdb,
+				       uaddr, req->lun, ntohl(req->data_length),
+				       cmd_attr(ctask), req->itt);
+
+	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
+
+	return err;
+}
+
+int iscsi_cmd_rx_done(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &conn->req.bhs;
+	struct iscsi_ctask *ctask = conn->rx_ctask;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	uint8_t op;
+	int err = 0;
+
+	op = hdr->opcode & ISCSI_OPCODE_MASK;
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		__iscsi_cmd_rx_done(ctask);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		if (ctask->r2t_count) {
+			dprintf("%x %d\n", hdr->itt, ctask->r2t_count);
+			list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+			tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
+		} else
+			err = target_cmd_queue(conn->session->tsih, req->cdb,
+					       (unsigned long) ctask->c_buffer,
+					       req->lun,
+					       ntohl(req->data_length),
+					       cmd_attr(ctask), req->itt);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+	default:
+		eprintf("Cannot handle yet %x\n", op);
+		break;
+	}
+
+	conn->rx_ctask = NULL;
+	return err;
+}
+
+int iscsi_cmd_rx_start(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &conn->req.bhs;
+	uint8_t op;
+	int err;
+
+	op = hdr->opcode & ISCSI_OPCODE_MASK;
+	dprintf("%u\n", op);
+	switch (op) {
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_cmd_init(conn);
+		if (!err)
+			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
+		break;
+	case ISCSI_OP_SCSI_DATA_OUT:
+		err = iscsi_data_out_rx_start(conn);
+		if (!err)
+			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
+	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		eprintf("Cannot handle yet %x\n", op);
+		err = -EINVAL;
+	default:
+		eprintf("Unknown op %x\n", op);
+		err = -EINVAL;
+		break;
+	}
+
+	return 0;
+}
+
+int iscsi_cmd_tx_done(struct connection *conn)
+{
+	struct iscsi_hdr *hdr = &conn->rsp.bhs;
+	struct iscsi_ctask *ctask = conn->tx_ctask;
+
+	switch (hdr->opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_R2T:
+		break;
+	case ISCSI_OP_SCSI_DATA_IN:
+		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
+			dprintf("more data %x\n", hdr->itt);
+			list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+			goto out;
+		}
+	default:
+		target_cmd_done(conn->session->tsih, ctask->tag);
+		list_del(&ctask->c_hlist);
+		if (ctask->c_buffer) {
+			if ((unsigned long) ctask->c_buffer != ctask->addr)
+				free((void *) (unsigned long) ctask->addr);
+			free(ctask->c_buffer);
+		}
+		free(ctask);
+	}
+
+out:
+	conn->tx_ctask = NULL;
+	return 0;
+}
+
+int iscsi_cmd_tx_start(struct connection *conn)
+{
+	struct iscsi_ctask *ctask;
+	struct iscsi_cmd *req;
+	int err = 0;
+
+	if (list_empty(&conn->tx_clist)) {
+		dprintf("no more data\n");
+		tgt_event_modify(conn->fd, EPOLLIN);
+		return -EAGAIN;
+	}
+
+	conn_write_pdu(conn);
+
+	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_txlist);
+	conn->tx_ctask = ctask;
+	list_del(&ctask->c_txlist);
+
+	req = (struct iscsi_cmd *) &ctask->req;
+
+	if (ctask->r2t_count)
+		iscsi_r2t_build(ctask);
+	else {
+		if (req->flags & ISCSI_FLAG_CMD_WRITE)
+			err = iscsi_cmd_rsp_build(ctask);
+		else {
+			if (ctask->len)
+				err = iscsi_data_rsp_build(ctask);
+			else
+				err = iscsi_cmd_rsp_build(ctask);
+		}
+	}
+
+	return err;
+}

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/iscsid.h	2006-08-31 07:49:26 UTC (rev 561)
@@ -18,16 +18,13 @@
 
 #include <scsi/iscsi_proto.h>
 
-#define ISCSI_NAME_LEN 255
+#define ISCSI_NAME_LEN 256
 #define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
 
 #define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
 #define DIGEST_NONE		(1 << 0)
 #define DIGEST_CRC32C           (1 << 1)
 
-extern uint64_t thandle;
-extern int nl_fd;
-
 #define sid64(isid, tsih)					\
 ({								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
@@ -57,17 +54,41 @@
 	uint8_t isid[6];
 	uint16_t tsih;
 
-	/* workaroud */
-	uint32_t ksid;
-	uint32_t hostno;
-
 	struct list_head conn_list;
 	int conn_cnt;
+
+	struct list_head cmd_list;
 };
 
+struct iscsi_ctask {
+	struct iscsi_hdr req;
+	struct iscsi_hdr rsp;
+
+	uint64_t tag;
+	struct connection *conn;
+
+	struct list_head c_hlist;
+	struct list_head c_txlist;
+
+	uint64_t addr;
+	int result;
+	int len;
+	int rw;
+
+	int offset;
+	int data_sn;
+
+	int r2t_count;
+	int unsol_count;
+	int exp_r2tsn;
+
+	void *c_buffer;
+};
+
 struct connection {
 	int state;
-	int iostate;
+	int rx_iostate;
+	int tx_iostate;
 	int fd;
 
 	struct list_head clist;
@@ -84,9 +105,6 @@
 	int session_type;
 	int auth_method;
 
-	/* workaroud */
-	uint32_t kcid;
-
 	uint32_t stat_sn;
 	uint32_t exp_stat_sn;
 
@@ -98,9 +116,16 @@
 	void *req_buffer;
 	struct PDU rsp;
 	void *rsp_buffer;
-	unsigned char *buffer;
-	int rwsize;
+	unsigned char *rx_buffer;
+	unsigned char *tx_buffer;
+	int rx_size;
+	int tx_size;
 
+	struct iscsi_ctask *rx_ctask;
+	struct iscsi_ctask *tx_ctask;
+
+	struct list_head tx_clist;
+
 	int auth_state;
 	union {
 		struct {
@@ -131,6 +156,7 @@
 #define STATE_KERNEL		9
 #define STATE_CLOSE		10
 #define STATE_EXIT		11
+#define STATE_SCSI		12
 
 #define AUTH_STATE_START	0
 #define AUTH_STATE_CHALLENGE	1
@@ -170,26 +196,27 @@
 extern struct connection *conn_alloc(void);
 extern void conn_free(struct connection *conn);
 extern struct connection * conn_find(struct session *session, uint32_t cid);
-extern void conn_take_fd(struct connection *conn, int fd);
+extern int conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
-extern void conn_free_pdu(struct connection *conn);
 extern void conn_add_to_session(struct connection *conn, struct session *session);
 
 /* iscsid.c */
-extern int iscsi_debug;
-
 extern int cmnd_execute(struct connection *conn);
 extern void cmnd_finish(struct connection *conn);
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
 
+extern int iscsi_cmd_rx_start(struct connection *conn);
+extern int iscsi_cmd_rx_done(struct connection *conn);
+extern int iscsi_cmd_tx_start(struct connection *conn);
+extern int iscsi_cmd_tx_done(struct connection *conn);
+
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
-extern struct session *session_find_id(int tid, uint64_t sid);
-extern struct session *session_find_hostno(int hostno);
-extern void session_create(struct connection *conn);
-extern void session_remove(struct session *session);
+extern int session_create(struct connection *conn);
+extern void session_destroy(struct session *session);
+extern struct session *session_lookup(uint16_t tsih);
 
 /* target.c */
 extern int target_find_by_name(const char *name, int *tid);
@@ -197,39 +224,6 @@
 extern void target_list_build(struct connection *, char *, char *);
 extern int target_bind(int tid, int hostno);
 
-extern void ipc_event(void);
-extern int ipc_init(void);
-
-/* netlink.c */
-struct iscsi_kernel_interface {
-	int (*set_param) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, enum iscsi_param param,
-			  void *value, int len, int *retcode);
-
-	int (*create_session) (uint64_t transport_handle,
-			       uint32_t initial_cmdsn,
-			       uint32_t *out_sid, uint32_t *out_hostno);
-
-	int (*destroy_session) (uint64_t transport_handle, uint32_t sid);
-
-	int (*create_conn) (uint64_t transport_handle,
-			    uint32_t sid, uint32_t cid, uint32_t *out_cid);
-	int (*destroy_conn) (uint64_t transport_handle, uint32_t sid,
-			     uint32_t cid);
-	int (*bind_conn) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, uint64_t transport_eph,
-			  int is_leading, int *retcode);
-	int (*start_conn) (uint64_t transport_handle, uint32_t sid,
-			   uint32_t cid, int *retcode);
-
-	int (*stop_conn) (uint64_t transport_handle, uint32_t sid,
-			  uint32_t cid, int flag);
-};
-
-extern int iscsi_nl_init(void);
-
-extern struct iscsi_kernel_interface *ki;
-
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 

Modified: trunk/usr/iscsi/istgt.c
===================================================================
--- trunk/usr/iscsi/istgt.c	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/istgt.c	2006-08-31 07:49:26 UTC (rev 561)
@@ -1,16 +1,14 @@
 /*
  * Software iSCSI target library
  *
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- * This code is licenced under the GPL.
+ * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
  *
- * This is based on Ardis's iSCSI implementation.
+ * This code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/
  *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
  *   licensed under the terms of the GNU GPL v2.0,
  */
-
 #include <ctype.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -21,11 +19,11 @@
 #include <getopt.h>
 #include <netdb.h>
 
-#include <sys/poll.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
+#include <sys/epoll.h>
 
 #include <netinet/in.h>
 #include <netinet/tcp.h>
@@ -33,304 +31,315 @@
 #include <arpa/inet.h>
 
 #include "iscsid.h"
+#include "tgtd.h"
 
 #define ISCSI_LISTEN_PORT	3260
+#define LISTEN_MAX		4
+#define INCOMING_MAX		32
 
-#define LISTEN_MAX	4
-#define INCOMING_MAX	32
-
-enum {
-	POLL_LISTEN,
-	POLL_NL = POLL_LISTEN + LISTEN_MAX,
-	POLL_INCOMING,
-	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
-};
-
-static struct connection *incoming[INCOMING_MAX];
-uint64_t thandle;
-int nl_fd;
-
 static void set_non_blocking(int fd)
 {
-	int res = fcntl(fd, F_GETFL);
+	int err;
 
-	if (res != -1) {
-		res = fcntl(fd, F_SETFL, res | O_NONBLOCK);
-		if (res)
-			dprintf("unable to set fd flags, %m\n");
-	} else
-		dprintf("unable to get fd flags, %m\n");
+	err = fcntl(fd, F_GETFL);
+	if (err < 0) {
+		eprintf("unable to get fd flags, %m\n");
+	} else {
+		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
+		if (err == -1)
+			eprintf("unable to set fd flags, %m\n");
+	}
 }
 
-static void listen_socket_create(struct pollfd *pfds)
+static void iscsi_rx_handler(int fd, struct connection *conn)
 {
-	struct addrinfo hints, *res, *res0;
-	char servname[64];
-	int i, sock, opt;
+	int res;
 
-	memset(servname, 0, sizeof(servname));
-	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
+	switch (conn->rx_iostate) {
+	case IOSTATE_READ_BHS:
+	case IOSTATE_READ_AHS_DATA:
+	read_again:
+		res = read(fd, conn->rx_buffer, conn->rx_size);
+		if (res <= 0) {
+			if (res == 0 || (errno != EINTR && errno != EAGAIN))
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto read_again;
+			break;
+		}
+		conn->rx_size -= res;
+		conn->rx_buffer += res;
+		if (conn->rx_size)
+			break;
 
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_flags = AI_PASSIVE;
+		switch (conn->rx_iostate) {
+		case IOSTATE_READ_BHS:
+			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
+			conn->req.ahssize = conn->req.bhs.hlength * 4;
+			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+			conn->rx_size = (conn->req.ahssize + conn->req.datasize + 3) & -4;
 
-	if (getaddrinfo(NULL, servname, &hints, &res0)) {
-		eprintf("unable to get address info, %m\n");
-		exit(1);
-	}
+			if (conn->req.ahssize) {
+				eprintf("FIXME: we cannot handle ahs\n");
+				conn->state = STATE_CLOSE;
+				break;
+			}
 
-	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
-		sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-		if (sock < 0) {
-			eprintf("unable to create socket %d %d %d, %m\n",
-				res->ai_family,	res->ai_socktype,
-				res->ai_protocol);
-			continue;
+			if (conn->state == STATE_SCSI) {
+				res = iscsi_cmd_rx_start(conn);
+				if (res) {
+					conn->state = STATE_CLOSE;
+					break;
+				}
+			}
+
+			if (conn->rx_size) {
+				if (conn->state != STATE_SCSI) {
+					conn->rx_buffer = conn->req_buffer;
+					conn->req.ahs = conn->rx_buffer;
+				}
+				conn->req.data =
+					conn->rx_buffer + conn->req.ahssize;
+				goto read_again;
+			}
+
+		case IOSTATE_READ_AHS_DATA:
+			if (conn->state == STATE_SCSI) {
+				res = iscsi_cmd_rx_done(conn);
+				if (!res)
+					conn_read_pdu(conn);
+			} else {
+				conn_write_pdu(conn);
+				tgt_event_modify(fd, EPOLLOUT);
+				res = cmnd_execute(conn);
+			}
+
+			if (res)
+				conn->state = STATE_CLOSE;
+			break;
 		}
+		break;
+	}
+}
 
-		opt = 1;
-		if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)))
-			dprintf("unable to set SO_REUSEADDR, %m\n");
+static void iscsi_tx_handler(int fd, struct connection *conn)
+{
+	int res, opt;
 
+	if (conn->state == STATE_SCSI && !conn->tx_ctask) {
+		res = iscsi_cmd_tx_start(conn);
+		if (res)
+			return;
+	}
+
+	switch (conn->tx_iostate) {
+	case IOSTATE_WRITE_BHS:
+	case IOSTATE_WRITE_AHS:
+	case IOSTATE_WRITE_DATA:
+	write_again:
 		opt = 1;
-		if (res->ai_family == AF_INET6 &&
-		    setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt)))
-			continue;
-
-		if (bind(sock, res->ai_addr, res->ai_addrlen)) {
-			eprintf("unable to bind server socket, %m\n");
-			continue;
+		setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+		res = write(fd, conn->tx_buffer, conn->tx_size);
+		if (res < 0) {
+			if (errno != EINTR && errno != EAGAIN)
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto write_again;
+			break;
 		}
 
-		if (listen(sock, INCOMING_MAX)) {
-			eprintf("unable to listen to server socket, %m\n");
-			continue;
+		conn->tx_size -= res;
+		conn->tx_buffer += res;
+		if (conn->tx_size)
+			goto write_again;
+
+		switch (conn->tx_iostate) {
+		case IOSTATE_WRITE_BHS:
+			if (conn->rsp.ahssize) {
+				conn->tx_iostate = IOSTATE_WRITE_AHS;
+				conn->tx_buffer = conn->rsp.ahs;
+				conn->tx_size = conn->rsp.ahssize;
+				goto write_again;
+			}
+		case IOSTATE_WRITE_AHS:
+			if (conn->rsp.datasize) {
+				int pad;
+
+				conn->tx_iostate = IOSTATE_WRITE_DATA;
+				conn->tx_buffer = conn->rsp.data;
+				conn->tx_size = conn->rsp.datasize;
+				pad = conn->tx_size & (PAD_WORD_LEN - 1);
+				if (pad) {
+					memset(conn->tx_buffer + conn->tx_size,
+					       0, pad);
+					conn->tx_size += pad;
+				}
+				goto write_again;
+			}
+		case IOSTATE_WRITE_DATA:
+			opt = 0;
+			setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+			cmnd_finish(conn);
+
+			switch (conn->state) {
+			case STATE_KERNEL:
+				res = conn_take_fd(conn, fd);
+				if (res)
+					conn->state = STATE_CLOSE;
+				else {
+					conn->state = STATE_SCSI;
+					conn_read_pdu(conn);
+					tgt_event_modify(fd, EPOLLIN);
+				}
+				break;
+			case STATE_EXIT:
+			case STATE_CLOSE:
+				break;
+			case STATE_SCSI:
+				iscsi_cmd_tx_done(conn);
+				break;
+			default:
+				conn_read_pdu(conn);
+				tgt_event_modify(fd, EPOLLIN);
+				break;
+			}
+			break;
 		}
 
-		set_non_blocking(sock);
-
-		pfds[i].fd = sock;
-		pfds[i].events = POLLIN;
+		break;
+	default:
+		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
+			conn->tx_iostate);
+		conn->state = STATE_CLOSE;
 	}
 
-	freeaddrinfo(res0);
 }
 
-static void accept_connection(struct pollfd *pfds, int afd)
+static void iscsi_event_handler(int fd, int events, void *data)
 {
+	struct connection *conn = (struct connection *) data;
+
+	if (events & EPOLLIN)
+		iscsi_rx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE)
+		dprintf("connection closed\n");
+
+	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
+		iscsi_tx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE) {
+		dprintf("connection closed\n");
+		conn_free(conn);
+		tgt_event_del(fd);
+		close(fd);
+	}
+}
+
+static void accept_connection(int afd, int events, void *data)
+{
 	struct sockaddr_storage from;
 	socklen_t namesize;
-	struct pollfd *pfd;
 	struct connection *conn;
-	int fd, i;
+	int fd, err;
 
 	eprintf("%d\n", afd);
 
 	namesize = sizeof(from);
-	if ((fd = accept(afd, (struct sockaddr *) &from, &namesize)) < 0) {
-		if (errno != EINTR && errno != EAGAIN) {
-			eprintf("accept(incoming_socket)\n");
-			exit(1);
-		}
+	fd = accept(afd, (struct sockaddr *) &from, &namesize);
+	if (fd < 0) {
+		eprintf("can't accept, %m\n");
 		return;
 	}
 
-	for (i = 0; i < INCOMING_MAX; i++) {
-		if (!incoming[i])
-			break;
-	}
-	if (i >= INCOMING_MAX) {
-		eprintf("unable to find incoming slot? %d\n", i);
+	conn = conn_alloc();
+	if (!conn)
 		goto out;
-	}
 
-	conn = conn_alloc();
-	if (!conn) {
-		eprintf("fail to allocate conn\n");
-		goto out;
-	}
 	conn->fd = fd;
-	incoming[i] = conn;
+
 	conn_read_pdu(conn);
-
 	set_non_blocking(fd);
-	pfd = &pfds[POLL_INCOMING + i];
-	pfd->fd = fd;
-	pfd->events = POLLIN;
-	pfd->revents = 0;
 
+	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
+	if (err)
+		goto free_conn;
+
 	return;
+free_conn:
+	free(conn);
 out:
 	close(fd);
 	return;
 }
 
-void iscsi_event_handle(struct pollfd *pfds)
+int iscsi_init(void)
 {
-	struct connection *conn;
-	struct pollfd *pfd;
-	int i, res, opt;
+	struct addrinfo hints, *res, *res0;
+	char servname[64];
+	int err, i, fd, opt, nr_sock = 0;
 
-	for (i = 0; i < LISTEN_MAX; i++) {
-		if (pfds[POLL_LISTEN + i].revents)
-			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
+	memset(servname, 0, sizeof(servname));
+	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_PASSIVE;
+
+	err = getaddrinfo(NULL, servname, &hints, &res0);
+	if (err) {
+		eprintf("unable to get address info, %m\n");
+		return -errno;
 	}
 
-	for (i = 0; i < INCOMING_MAX; i++) {
-		conn = incoming[i];
-		pfd = &pfds[POLL_INCOMING + i];
-		if (!conn || !pfd->revents)
+	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
+		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (fd < 0) {
+			eprintf("unable to create fdet %d %d %d, %m\n",
+				res->ai_family,	res->ai_socktype,
+				res->ai_protocol);
 			continue;
+		}
 
-		pfd->revents = 0;
+		opt = 1;
+		err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt,
+				 sizeof(opt));
+		if (err)
+			dprintf("unable to set SO_REUSEADDR, %m\n");
 
-		switch (conn->iostate) {
-		case IOSTATE_READ_BHS:
-		case IOSTATE_READ_AHS_DATA:
-		read_again:
-			res = read(pfd->fd, conn->buffer, conn->rwsize);
-			if (res <= 0) {
-				if (res == 0 || (errno != EINTR && errno != EAGAIN))
-					conn->state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto read_again;
-				break;
+		opt = 1;
+		if (res->ai_family == AF_INET6) {
+			err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt,
+					 sizeof(opt));
+			if (err) {
+				close(fd);
+				continue;
 			}
-			conn->rwsize -= res;
-			conn->buffer += res;
-			if (conn->rwsize)
-				break;
+		}
 
-			switch (conn->iostate) {
-			case IOSTATE_READ_BHS:
-				conn->iostate = IOSTATE_READ_AHS_DATA;
-				conn->req.ahssize =
-					conn->req.bhs.hlength * 4;
-				conn->req.datasize =
-					ntoh24(conn->req.bhs.dlength);
-				conn->rwsize = (conn->req.ahssize + conn->req.datasize + 3) & -4;
-				if (conn->rwsize) {
-					if (!conn->req_buffer)
-						conn->req_buffer = malloc(INCOMING_BUFSIZE);
-					conn->buffer = conn->req_buffer;
-					conn->req.ahs = conn->buffer;
-					conn->req.data = conn->buffer + conn->req.ahssize;
-					goto read_again;
-				}
-
-			case IOSTATE_READ_AHS_DATA:
-				conn_write_pdu(conn);
-				pfd->events = POLLOUT;
-
-				if (!cmnd_execute(conn))
-					conn->state = STATE_CLOSE;
-				break;
-			}
-			break;
-
-		case IOSTATE_WRITE_BHS:
-		case IOSTATE_WRITE_AHS:
-		case IOSTATE_WRITE_DATA:
-		write_again:
-			opt = 1;
-			setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-			res = write(pfd->fd, conn->buffer, conn->rwsize);
-			if (res < 0) {
-				if (errno != EINTR && errno != EAGAIN)
-					conn->state = STATE_CLOSE;
-				else if (errno == EINTR)
-					goto write_again;
-				break;
-			}
-
-			conn->rwsize -= res;
-			conn->buffer += res;
-			if (conn->rwsize)
-				goto write_again;
-
-			switch (conn->iostate) {
-			case IOSTATE_WRITE_BHS:
-				if (conn->rsp.ahssize) {
-					conn->iostate = IOSTATE_WRITE_AHS;
-					conn->buffer = conn->rsp.ahs;
-					conn->rwsize = conn->rsp.ahssize;
-					goto write_again;
-				}
-			case IOSTATE_WRITE_AHS:
-				if (conn->rsp.datasize) {
-					int o;
-
-					conn->iostate = IOSTATE_WRITE_DATA;
-					conn->buffer = conn->rsp.data;
-					conn->rwsize = conn->rsp.datasize;
-					o = conn->rwsize & 3;
-					if (o) {
-						for (o = 4 - o; o; o--)
-							*((uint8_t *)conn->buffer + conn->rwsize++) = 0;
-					}
-					goto write_again;
-				}
-			case IOSTATE_WRITE_DATA:
-				opt = 0;
-				setsockopt(pfd->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-				cmnd_finish(conn);
-
-				switch (conn->state) {
-				case STATE_KERNEL:
-					conn_take_fd(conn, pfd->fd);
-					conn->state = STATE_CLOSE;
-					break;
-				case STATE_EXIT:
-				case STATE_CLOSE:
-					break;
-				default:
-					conn_read_pdu(conn);
-					pfd->events = POLLIN;
-					break;
-				}
-				break;
-			}
-
-			break;
-		default:
-			eprintf("illegal iostate %d for port %d!\n", conn->iostate, i);
-			exit(1);
+		err = bind(fd, res->ai_addr, res->ai_addrlen);
+		if (err) {
+			close(fd);
+			eprintf("unable to bind server socket, %m\n");
+			continue;
 		}
 
-		if (conn->state == STATE_CLOSE) {
-			dprintf("connection closed\n");
-			conn_free_pdu(conn);
-			conn_free(conn);
-/* 			close(pfd->fd); */
-			pfd->fd = -1;
-			incoming[i] = NULL;
+		err = listen(fd, INCOMING_MAX);
+		if (err) {
+			eprintf("unable to listen to server socket, %m\n");
+			close(fd);
+			continue;
 		}
-	}
-}
 
-int iscsi_poll_init(struct pollfd *pfd)
-{
-	int i;
-
-	pfd[POLL_NL].fd = nl_fd;
-	pfd[POLL_NL].events = POLLIN;
-
-	listen_socket_create(pfd + POLL_LISTEN);
-
-	for (i = 0; i < INCOMING_MAX; i++) {
-		pfd[POLL_INCOMING + i].fd = -1;
-		pfd[POLL_INCOMING + i].events = 0;
-		incoming[i] = NULL;
+		set_non_blocking(fd);
+		err = tgt_event_add(fd, EPOLLIN, accept_connection, NULL);
+		if (err)
+			close(fd);
+		else
+			nr_sock++;
 	}
 
-	return 0;
-}
+	freeaddrinfo(res0);
 
-int iscsi_init(int *npfd)
-{
-	iscsi_nl_init();
-	*npfd = POLL_MAX;
-
-	return 0;
+	return !nr_sock;
 }

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/session.c	2006-08-31 07:49:26 UTC (rev 561)
@@ -15,41 +15,10 @@
 #include <errno.h>
 
 #include "iscsid.h"
+#include "util.h"
 
 static LIST_HEAD(sessions_list);
 
-static struct session *session_alloc(int tid)
-{
-	struct session *session;
-	struct target *target = target_find_by_id(tid);
-
-	if (!target)
-		return NULL;
-	if (!(session = malloc(sizeof(*session))))
-		return NULL;
-	memset(session, 0, sizeof(*session));
-
-	session->target = target;
-	INIT_LIST_HEAD(&session->slist);
-	list_add(&session->slist, &target->sessions_list);
-
-	INIT_LIST_HEAD(&session->conn_list);
-
-	return session;
-}
-
-int iscsi_target_bind(int hostno)
-{
-	struct session *session;
-
-	list_for_each_entry(session, &sessions_list, hlist) {
-		if (session->hostno == hostno)
-			return session->target->tid;
-	}
-
-	return -ENOENT;
-}
-
 struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
@@ -69,67 +38,69 @@
 	return NULL;
 }
 
-struct session *session_find_id(int tid, uint64_t sid)
+struct session *session_lookup(uint16_t tsih)
 {
 	struct session *session;
-	struct target *target;
-
-	if (!(target = target_find_by_id(tid)))
-		return NULL;
-
-	log_debug("session_find_id: %#" PRIx64, sid);
-	list_for_each_entry(session, &target->sessions_list, slist) {
-		if (sid64(session->isid, session->tsih) == sid)
+	list_for_each_entry(session, &sessions_list, hlist) {
+		if (session->tsih == tsih)
 			return session;
 	}
-
 	return NULL;
 }
 
-void session_create(struct connection *conn)
+int session_create(struct connection *conn)
 {
-	struct session *session;
-	uint64_t sid;
-	static uint16_t tsih = 1;
+	struct session *session = NULL;
+	static uint16_t tsih, last_tsih = 0;
+	struct target *target;
 
-	/* First, we need to get an available sid. */
-	while (1) {
-		sid = sid64(conn->isid, tsih);
-		if (!session_find_id(conn->tid, sid))
+	target = target_find_by_id(conn->tid);
+	if (!target)
+		return -EINVAL;
+
+	for (tsih = last_tsih + 1; tsih != last_tsih; tsih++) {
+		if (!tsih)
+			continue;
+		session = session_lookup(tsih);
+		if (!session)
 			break;
-		tsih++;
 	}
+	if (session)
+		return -EINVAL;
 
-	session = session_alloc(conn->tid);
+	session = zalloc(sizeof(*session));
 	if (!session)
-		return;
+		return -ENOMEM;
 
+	session->target = target;
+	INIT_LIST_HEAD(&session->slist);
+	list_add(&session->slist, &target->sessions_list);
+
+	INIT_LIST_HEAD(&session->conn_list);
+	INIT_LIST_HEAD(&session->cmd_list);
+
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
-	session->tsih = tsih++;
+	session->tsih = last_tsih = tsih;
 
 	conn_add_to_session(conn, session);
 	conn->session->initiator = strdup(conn->initiator);
 
-	log_debug("session_create: %#" PRIx64, sid);
+	log_debug("session_create: %#" PRIx64, sid64(conn->isid, session->tsih));
 
-	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
-			   &session->hostno);
-
 	list_add(&session->hlist, &sessions_list);
+
+	return 0;
 }
 
-void session_remove(struct session *session)
+void session_destroy(struct session *session)
 {
-	uint64_t sid = sid64(session->isid, session->tsih);
+	eprintf("%d\n", session->tsih);
 
-	eprintf("%#"  PRIx64 "\n", sid);
+	if (!list_empty(&session->conn_list)) {
+		eprintf("%d conn_list is not null\n", session->tsih);
+		return;
+	}
 
-	if (!list_empty(&session->conn_list))
-		eprintf("%" PRIx64 " conn_list is not null\n", sid);
-
-	if (!session->tsih)
-		ki->destroy_session(thandle, session->ksid);
-
 	if (session->target) {
 		list_del(&session->slist);
 /* 		session->target->nr_sessions--; */

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-08-31 07:48:06 UTC (rev 560)
+++ trunk/usr/iscsi/target.c	2006-08-31 07:49:26 UTC (rev 561)
@@ -15,7 +15,6 @@
 #include <sys/un.h>
 #include <linux/netlink.h>
 #include <sys/socket.h>
-
 #include "iscsid.h"
 #include "tgtadm.h"
 



From tomo at mail.berlios.de  Thu Aug 31 09:57:39 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 09:57:39 +0200
Subject: [Stgt-svn] r562 - in trunk: . usr usr/iscsi
Message-ID: <200608310757.k7V7vdSB011192@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 09:57:02 +0200 (Thu, 31 Aug 2006)
New Revision: 562

Removed:
   trunk/istgt/
   trunk/usr/iscsi/Makefile
Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/iscsid.h
Log:
Kill old kernel-mode iSCSI target code.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-31 07:49:26 UTC (rev 561)
+++ trunk/usr/Makefile	2006-08-31 07:57:02 UTC (rev 562)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE -I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
 TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
 
@@ -33,6 +33,4 @@
 	$(CC) $^ -o $@
 
 clean:
-	rm -f *.o $(PROGRAMS)
-	$(MAKE) -C iscsi clean
-	$(MAKE) -C ibmvio clean
+	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o

Deleted: trunk/usr/iscsi/Makefile
===================================================================
--- trunk/usr/iscsi/Makefile	2006-08-31 07:49:26 UTC (rev 561)
+++ trunk/usr/iscsi/Makefile	2006-08-31 07:57:02 UTC (rev 562)
@@ -1,9 +0,0 @@
-CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../istgt/include -I../../include -I../../usr
-LIBS = -lcrypto
-DAEMON = iscsi.o
-
-$(DAEMON): istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
-	$(CC) -o $@ $^ $(LIBS)
-
-clean:
-	rm -f *.o istgtd $(SHAREDLIB)

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-08-31 07:49:26 UTC (rev 561)
+++ trunk/usr/iscsi/iscsid.h	2006-08-31 07:57:02 UTC (rev 562)
@@ -11,11 +11,11 @@
 #include <linux/types.h>
 
 #include "types.h"
-#include "iscsi_if.h"
 #include "list.h"
 #include "param.h"
 #include "log.h"
 
+#include <scsi/iscsi_if.h>
 #include <scsi/iscsi_proto.h>
 
 #define ISCSI_NAME_LEN 256



From tomo at mail.berlios.de  Thu Aug 31 10:10:45 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 10:10:45 +0200
Subject: [Stgt-svn] r563 - trunk/usr/iscsi
Message-ID: <200608310810.k7V8AjJD014359@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 10:10:12 +0200 (Thu, 31 Aug 2006)
New Revision: 563

Modified:
   trunk/usr/iscsi/chap.c
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/session.c
Log:
Kill log_debug and log_error.

Modified: trunk/usr/iscsi/chap.c
===================================================================
--- trunk/usr/iscsi/chap.c	2006-08-31 07:57:02 UTC (rev 562)
+++ trunk/usr/iscsi/chap.c	2006-08-31 08:10:12 UTC (rev 563)
@@ -264,18 +264,16 @@
 {
 	if (encoding_fmt == HEX_FORMAT) {
 		if ((strlen(encoded) - 2) > (2 * buf_len)) {
-			log_error("%s(%d) BUG? "
-				  " buf[%d] !sufficient to decode string[%d]",
-				  __FUNCTION__, __LINE__, buf_len, (int) strlen(encoded));
+			eprintf("buf[%d] !sufficient to decode string[%d]\n",
+				  buf_len, (int) strlen(encoded));
 			return CHAP_TARGET_ERROR;
 		}
 		decode_hex_string(encoded + 2, decode_buf, buf_len);
 
 	} else if (encoding_fmt == BASE64_FORMAT) {
 		if ((strlen(encoded) - 2) > ((buf_len - 1) / 3 + 1) * 4) {
-			log_error("%s(%d) BUG? "
-				  " buf[%d] !sufficient to decode string[%d]",
-				  __FUNCTION__, __LINE__, buf_len, (int) strlen(encoded));
+			eprintf("buf[%d] !sufficient to decode string[%d]",
+				buf_len, (int) strlen(encoded));
 			return CHAP_TARGET_ERROR;
 		}
 		decode_base64_string(encoded + 2, decode_buf, buf_len);
@@ -619,8 +617,7 @@
 		res = chap_target_auth_create_response(conn);
 		break;
 	default:
-		log_error("%s(%d): BUG. unknown conn->auth_state %d",
-			  __FUNCTION__, __LINE__, conn->auth_state);
+		eprintf("BUG. unknown conn->auth_state %d\n", conn->auth_state);
 		res = CHAP_TARGET_ERROR;
 	}
 

Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-08-31 07:57:02 UTC (rev 562)
+++ trunk/usr/iscsi/conn.c	2006-08-31 08:10:12 UTC (rev 563)
@@ -86,7 +86,7 @@
 {
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
-	log_debug("conn_take_fd: %d %u %u %u %" PRIx64,
+	dprintf("conn_take_fd: %d %u %u %u %" PRIx64 "\n",
 		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 07:57:02 UTC (rev 562)
+++ trunk/usr/iscsi/iscsid.c	2006-08-31 08:10:12 UTC (rev 563)
@@ -386,7 +386,7 @@
 
 /* 		ki->param_get(conn->tid, 0, conn->session_param); */
 		conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
-		log_debug("exp_cmd_sn: %d,%d", conn->exp_cmd_sn, req->cmdsn);
+		dprintf("exp_cmd_sn: %d,%d\n", conn->exp_cmd_sn, req->cmdsn);
 		conn->max_cmd_sn = conn->exp_cmd_sn;
 	}
 	text_key_add(conn, "TargetPortalGroupTag", "1");
@@ -420,7 +420,7 @@
                 res = 0;
                 break;
         default:
-                log_error("Unknown auth. method %d", conn->auth_method);
+                eprintf("Unknown auth. method %d\n", conn->auth_method);
                 res = -3;
         }
 
@@ -652,7 +652,7 @@
 	if (!(req->opcode & ISCSI_OP_IMMEDIATE))
 		conn->exp_cmd_sn++;
 
-	log_debug("Text request: %d", conn->state);
+	dprintf("Text request: %d\n", conn->state);
 	text_scan_text(conn);
 
 	if (req->flags & ISCSI_FLAG_CMD_FINAL)

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-08-31 07:57:02 UTC (rev 562)
+++ trunk/usr/iscsi/session.c	2006-08-31 08:10:12 UTC (rev 563)
@@ -27,7 +27,7 @@
 	if (!(target = target_find_by_id(tid)))
 		return NULL;
 
-	log_debug("session_find_name: %s %x %x %x %x %x %x", iname,
+	dprintf("session_find_name: %s %x %x %x %x %x %x\n", iname,
 		  isid[0], isid[1], isid[2], isid[3], isid[4], isid[5]);
 	list_for_each_entry(session, &target->sessions_list, slist) {
 		if (!memcmp(isid, session->isid, sizeof(session->isid)) &&
@@ -85,7 +85,7 @@
 	conn_add_to_session(conn, session);
 	conn->session->initiator = strdup(conn->initiator);
 
-	log_debug("session_create: %#" PRIx64, sid64(conn->isid, session->tsih));
+	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
 
 	list_add(&session->hlist, &sessions_list);
 



From tomo at mail.berlios.de  Thu Aug 31 13:11:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 13:11:40 +0200
Subject: [Stgt-svn] r564 - trunk/usr/iscsi
Message-ID: <200608311111.k7VBBepC015358@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 13:11:39 +0200 (Thu, 31 Aug 2006)
New Revision: 564

Removed:
   trunk/usr/iscsi/netlink.c
Log:
remove netlink.c

Deleted: trunk/usr/iscsi/netlink.c
===================================================================
--- trunk/usr/iscsi/netlink.c	2006-08-31 08:10:12 UTC (rev 563)
+++ trunk/usr/iscsi/netlink.c	2006-08-31 11:11:39 UTC (rev 564)
@@ -1,372 +0,0 @@
-/*
- * iSCSI Netlink/Linux Interface
- *
- * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-#include "tgtadm.h"
-
-#define NL_BUFSIZE 4096
-
-static struct sockaddr_nl saddr, daddr;
-
-static int __nl_read(int fd, void *data, int size, int flags)
-{
-	struct sockaddr_nl saddr;
-	socklen_t slen = sizeof(saddr);
-
-	memset(&saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-
-	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
-}
-
-static int nl_read(char *buf)
-{
-	struct nlmsghdr *nlh;
-	int err;
-
-peek_again:
-	err = __nl_read(nl_fd, buf, NLMSG_LENGTH(0), MSG_PEEK);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-
-/* 	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid()); */
-read_again:
-	err = __nl_read(nl_fd, buf, nlh->nlmsg_len, 0);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto read_again;
-		return err;
-	}
-
-	return err;
-}
-
-static int __kipc_call(struct iscsi_uevent *ev, int len)
-{
-	struct nlmsghdr *nlh;
-	char sbuf[NL_BUFSIZE];
-	int err;
-
-	nlh = (struct nlmsghdr *) sbuf;
-	memset(sbuf, 0, NL_BUFSIZE);
-	memcpy(NLMSG_DATA(nlh), ev, len);
-
-	len = NLMSG_SPACE(len);
-	nlh->nlmsg_pid = getpid();
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_type = ev->type;
-
-	err = sendto(nl_fd, nlh, len, 0, (struct sockaddr *) &daddr, sizeof(daddr));
-	if (err < 0) {
-		eprintf("%d\n", err);
-		return err;
-	}
-
-	memset(sbuf, 0, NL_BUFSIZE);
-	err = nl_read(sbuf);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		return err;
-	}
-
-	memcpy(ev, NLMSG_DATA(sbuf), sizeof(*ev));
-
-	return err;
-}
-
-static int kcreate_session(uint64_t transport_handle, uint32_t initial_cmdsn,
-		uint32_t *out_sid, uint32_t *out_hostno)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf("%"PRIx64 " %u %u %u\n",
-		transport_handle, initial_cmdsn, *out_sid, *out_hostno);
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.c_session.initial_cmdsn = initial_cmdsn;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*out_hostno = ev.r.c_session_ret.host_no;
-	*out_sid = ev.r.c_session_ret.sid;
-
-	return 0;
-}
-
-static int kdestroy_session(uint64_t transport_handle, uint32_t sid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_SESSION;
-	ev.transport_handle = transport_handle;
-	ev.u.d_session.sid = sid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int kcreate_conn(uint64_t transport_handle, uint32_t sid,
-		       uint32_t cid, uint32_t *out_cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	dprintf("%"PRIx64 " %u %u\n", transport_handle, sid, cid);
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_CREATE_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.c_conn.cid = cid;
-	ev.u.c_conn.sid = sid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		eprintf("%d\n", rc);
-		return rc;
-	}
-
-	if ((int)ev.r.c_conn_ret.cid == -1)
-		return -EIO;
-
-	*out_cid = ev.r.c_conn_ret.cid;
-	return 0;
-}
-
-static int kdestroy_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_DESTROY_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.d_conn.sid = sid;
-	ev.u.d_conn.cid = cid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		eprintf("%d\n", rc);
-	}
-
-	return 0;
-}
-
-static int
-kbind_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   uint64_t transport_eph, int is_leading, int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	ev.type = ISCSI_UEVENT_BIND_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.b_conn.sid = sid;
-	ev.u.b_conn.cid = cid;
-	ev.u.b_conn.transport_eph = transport_eph;
-	ev.u.b_conn.is_leading = is_leading;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-
-	return 0;
-}
-
-static int
-kstop_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid, int flag)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_STOP_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.stop_conn.sid = sid;
-	ev.u.stop_conn.cid = cid;
-	ev.u.stop_conn.flag = flag;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	return 0;
-}
-
-static int
-kstart_conn(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	    int *retcode)
-{
-	int rc;
-	struct iscsi_uevent ev;
-
-	memset(&ev, 0, sizeof(struct iscsi_uevent));
-
-	ev.type = ISCSI_UEVENT_START_CONN;
-	ev.transport_handle = transport_handle;
-	ev.u.start_conn.sid = sid;
-	ev.u.start_conn.cid = cid;
-
-	if ((rc = __kipc_call(&ev, sizeof(ev))) < 0) {
-		return rc;
-	}
-
-	*retcode = ev.r.retcode;
-	return 0;
-}
-
-static int
-kset_param(uint64_t transport_handle, uint32_t sid, uint32_t cid,
-	   enum iscsi_param param, void *value, int len, int *retcode)
-{
-	struct iscsi_uevent *ev;
-	char setparam_buf[NL_BUFSIZE];
-	int rc;
-
-	memset(setparam_buf, 0, sizeof(setparam_buf));
-	ev = (struct iscsi_uevent *) setparam_buf;
-	ev->type = ISCSI_UEVENT_SET_PARAM;
-	ev->transport_handle = transport_handle;
-	ev->u.set_param.sid = sid;
-	ev->u.set_param.cid = cid;
-	ev->u.set_param.param = param;
-	ev->u.set_param.len = len;
-	memcpy(setparam_buf + sizeof(*ev), value, len);
-
-	if ((rc = __kipc_call(ev, sizeof(*ev) + len)) < 0) {
-		return rc;
-	}
-
-	*retcode = ev->r.retcode;
-
-	return 0;
-}
-
-static int transport_handle_init(void)
-{
-	int fd, err;
-	char buf[64];
-
-	fd = open("/sys/class/iscsi_transport/iscsi_tcp_tgt/handle", O_RDONLY);
-	if (fd < 0)
-		return fd;
-	err = read(fd, buf, sizeof(buf));
-	if (err < 0)
-		goto out;
-	thandle = strtoull(buf, NULL, 10);
-	dprintf("%" PRIx64 "\n", thandle);
-	err = 0;
-out:
-	close(fd);
-	return err;
-}
-
-int iscsi_nl_init(void)
-{
-	int err, rsize = 256 * 1024;
-
-	err = transport_handle_init();
-	if (err)
-		return err;
-
-	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_ISCSI);
-	if (nl_fd < 0) {
-		eprintf("Fail to create the netlink socket %d\n", errno);
-		return err;
-	}
-	eprintf("create the netlink socket %d\n", nl_fd);
-
-	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
-	if (err) {
-		eprintf("fail to setsockopt %d\n", errno);
-		return err;
-	}
-
-	memset(&saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-/* 	err = bind(nl_fd, (struct sockaddr *) &saddr, sizeof(saddr)); */
-/* 	if (err) { */
-/* 		eprintf("can not bind NETLINK_ISCSI socket %d\n", errno); */
-/* 		close(nl_fd); */
-/* 		return err; */
-/* 	} */
-
-	memset(&daddr, 0, sizeof(daddr));
-	daddr.nl_family = AF_NETLINK;
-	daddr.nl_pid = 0; /* kernel */
-	daddr.nl_groups = 0; /* unicast */
-	eprintf("create the netlink socket %d %d\n", nl_fd, err);
-
-	return err;
-}
-
-struct iscsi_kernel_interface nl_ki = {
-	.create_session		= kcreate_session,
-	.destroy_session	= kdestroy_session,
-	.create_conn		= kcreate_conn,
-	.destroy_conn		= kdestroy_conn,
-	.bind_conn		= kbind_conn,
-	.set_param              = kset_param,
-	.start_conn             = kstart_conn,
-	.stop_conn              = kstop_conn,
-};
-
-struct iscsi_kernel_interface *ki = &nl_ki;



From tomo at mail.berlios.de  Thu Aug 31 14:14:01 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:14:01 +0200
Subject: [Stgt-svn] r565 - trunk/usr
Message-ID: <200608311214.k7VCE1HD010013@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:14:00 +0200 (Thu, 31 Aug 2006)
New Revision: 565

Modified:
   trunk/usr/bd_aio.c
Log:
Use edge triggering because we want only one notification per task.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-08-31 11:11:39 UTC (rev 564)
+++ trunk/usr/bd_aio.c	2006-08-31 12:14:00 UTC (rev 565)
@@ -102,7 +102,10 @@
 		goto close_fd;
 	}
 
-	err = tgt_event_add(bai->aio_fd, EPOLLIN, aio_event_handler, dev);
+	/*
+	 * We use edge triggering because we want only one notification per task.
+	 */
+	err = tgt_event_add(bai->aio_fd, EPOLLIN | EPOLLET, aio_event_handler, dev);
 	if (err)
 		goto aio_cb_destroy;
 



From tomo at mail.berlios.de  Thu Aug 31 14:14:35 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:14:35 +0200
Subject: [Stgt-svn] r566 - in trunk/usr: . iscsi
Message-ID: <200608311214.k7VCEZYH010422@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:14:34 +0200 (Thu, 31 Aug 2006)
New Revision: 566

Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/iscsid.c
Log:
Compile with -g.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-31 12:14:00 UTC (rev 565)
+++ trunk/usr/Makefile	2006-08-31 12:14:34 UTC (rev 566)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE -I$(KERNELSRC)/include -I../include -I.
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE -I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
 TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o
 

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 12:14:00 UTC (rev 565)
+++ trunk/usr/iscsi/iscsid.c	2006-08-31 12:14:34 UTC (rev 566)
@@ -872,7 +872,9 @@
 	}
 	return -EINVAL;
 found:
-	eprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
+	eprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
+		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
+		ctask->offset,
 		ctask->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
@@ -905,7 +907,7 @@
 
 	list_add(&ctask->c_hlist, &conn->session->cmd_list);
 
-	dprintf("%u %x %d %d %u\n", conn->session->tsih,
+	dprintf("%u %x %d %d %x\n", conn->session->tsih,
 		req->cdb[0], ntohl(req->data_length),
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
@@ -1029,7 +1031,6 @@
 	int err;
 
 	op = hdr->opcode & ISCSI_OPCODE_MASK;
-	dprintf("%u\n", op);
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
 		err = iscsi_cmd_init(conn);
@@ -1103,6 +1104,11 @@
 
 	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_txlist);
 	conn->tx_ctask = ctask;
+	eprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
+		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
+		ctask->offset,
+		ctask->r2t_count);
+
 	list_del(&ctask->c_txlist);
 
 	req = (struct iscsi_cmd *) &ctask->req;



From tomo at mail.berlios.de  Thu Aug 31 14:16:22 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:16:22 +0200
Subject: [Stgt-svn] r567 - trunk/usr/iscsi
Message-ID: <200608311216.k7VCGMvi011089@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:16:21 +0200 (Thu, 31 Aug 2006)
New Revision: 567

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
Fix some debug messages.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 12:14:34 UTC (rev 566)
+++ trunk/usr/iscsi/iscsid.c	2006-08-31 12:16:21 UTC (rev 567)
@@ -849,7 +849,7 @@
 	return -EINVAL;
 
 found:
-	eprintf("found a task %" PRIx64 "\n", tag);
+	dprintf("found a task %" PRIx64 "\n", tag);
 	ctask->addr = addr;
 	ctask->result = result;
 	ctask->len = len;
@@ -872,7 +872,7 @@
 	}
 	return -EINVAL;
 found:
-	eprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
+	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
 		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
 		ctask->offset,
 		ctask->r2t_count,
@@ -1104,7 +1104,7 @@
 
 	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_txlist);
 	conn->tx_ctask = ctask;
-	eprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
+	dprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
 		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
 		ctask->offset,
 		ctask->r2t_count);



From tomo at mail.berlios.de  Thu Aug 31 14:22:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:22:40 +0200
Subject: [Stgt-svn] r568 - in trunk/usr: . iscsi
Message-ID: <200608311222.k7VCMeiV013230@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:22:39 +0200 (Thu, 31 Aug 2006)
New Revision: 568

Removed:
   trunk/usr/iscsi/istgt.c
Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/iscsid.c
Log:
Move istgt code to iscsid.

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-08-31 12:16:21 UTC (rev 567)
+++ trunk/usr/Makefile	2006-08-31 12:22:39 UTC (rev 568)
@@ -10,7 +10,7 @@
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o)
+TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o chap.o)
 LIBS += -lcrypto
 BD_AIO=1
 endif

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 12:16:21 UTC (rev 567)
+++ trunk/usr/iscsi/iscsid.c	2006-08-31 12:22:39 UTC (rev 568)
@@ -9,17 +9,19 @@
  *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
  *   licensed under the terms of the GNU GPL v2.0,
  */
-#include <ctype.h>
 #include <errno.h>
+#include <fcntl.h>
 #include <netdb.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <arpa/inet.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
 #include <scsi/scsi.h>
 #include <sys/epoll.h>
 #include <sys/socket.h>
-#include <netinet/in.h>
+
 #include "iscsid.h"
 #include "tgtd.h"
 #include "util.h"
@@ -1128,3 +1130,315 @@
 
 	return err;
 }
+
+
+#define ISCSI_LISTEN_PORT	3260
+#define LISTEN_MAX		4
+#define INCOMING_MAX		32
+
+static void set_non_blocking(int fd)
+{
+	int err;
+
+	err = fcntl(fd, F_GETFL);
+	if (err < 0) {
+		eprintf("unable to get fd flags, %m\n");
+	} else {
+		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
+		if (err == -1)
+			eprintf("unable to set fd flags, %m\n");
+	}
+}
+
+static void iscsi_rx_handler(int fd, struct connection *conn)
+{
+	int res;
+
+	switch (conn->rx_iostate) {
+	case IOSTATE_READ_BHS:
+	case IOSTATE_READ_AHS_DATA:
+	read_again:
+		res = read(fd, conn->rx_buffer, conn->rx_size);
+		if (res <= 0) {
+			if (res == 0 || (errno != EINTR && errno != EAGAIN))
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto read_again;
+			break;
+		}
+		conn->rx_size -= res;
+		conn->rx_buffer += res;
+		if (conn->rx_size)
+			break;
+
+		switch (conn->rx_iostate) {
+		case IOSTATE_READ_BHS:
+			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
+			conn->req.ahssize = conn->req.bhs.hlength * 4;
+			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+			conn->rx_size = (conn->req.ahssize + conn->req.datasize + 3) & -4;
+
+			if (conn->req.ahssize) {
+				eprintf("FIXME: we cannot handle ahs\n");
+				conn->state = STATE_CLOSE;
+				break;
+			}
+
+			if (conn->state == STATE_SCSI) {
+				res = iscsi_cmd_rx_start(conn);
+				if (res) {
+					conn->state = STATE_CLOSE;
+					break;
+				}
+			}
+
+			if (conn->rx_size) {
+				if (conn->state != STATE_SCSI) {
+					conn->rx_buffer = conn->req_buffer;
+					conn->req.ahs = conn->rx_buffer;
+				}
+				conn->req.data =
+					conn->rx_buffer + conn->req.ahssize;
+				goto read_again;
+			}
+
+		case IOSTATE_READ_AHS_DATA:
+			if (conn->state == STATE_SCSI) {
+				res = iscsi_cmd_rx_done(conn);
+				if (!res)
+					conn_read_pdu(conn);
+			} else {
+				conn_write_pdu(conn);
+				tgt_event_modify(fd, EPOLLOUT);
+				res = cmnd_execute(conn);
+			}
+
+			if (res)
+				conn->state = STATE_CLOSE;
+			break;
+		}
+		break;
+	}
+}
+
+static void iscsi_tx_handler(int fd, struct connection *conn)
+{
+	int res, opt;
+
+	if (conn->state == STATE_SCSI && !conn->tx_ctask) {
+		res = iscsi_cmd_tx_start(conn);
+		if (res)
+			return;
+	}
+
+	switch (conn->tx_iostate) {
+	case IOSTATE_WRITE_BHS:
+	case IOSTATE_WRITE_AHS:
+	case IOSTATE_WRITE_DATA:
+	write_again:
+		opt = 1;
+		setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+		res = write(fd, conn->tx_buffer, conn->tx_size);
+		if (res < 0) {
+			if (errno != EINTR && errno != EAGAIN)
+				conn->state = STATE_CLOSE;
+			else if (errno == EINTR)
+				goto write_again;
+			break;
+		}
+
+		conn->tx_size -= res;
+		conn->tx_buffer += res;
+		if (conn->tx_size)
+			goto write_again;
+
+		switch (conn->tx_iostate) {
+		case IOSTATE_WRITE_BHS:
+			if (conn->rsp.ahssize) {
+				conn->tx_iostate = IOSTATE_WRITE_AHS;
+				conn->tx_buffer = conn->rsp.ahs;
+				conn->tx_size = conn->rsp.ahssize;
+				goto write_again;
+			}
+		case IOSTATE_WRITE_AHS:
+			if (conn->rsp.datasize) {
+				int pad;
+
+				conn->tx_iostate = IOSTATE_WRITE_DATA;
+				conn->tx_buffer = conn->rsp.data;
+				conn->tx_size = conn->rsp.datasize;
+				pad = conn->tx_size & (PAD_WORD_LEN - 1);
+				if (pad) {
+					memset(conn->tx_buffer + conn->tx_size,
+					       0, pad);
+					conn->tx_size += pad;
+				}
+				goto write_again;
+			}
+		case IOSTATE_WRITE_DATA:
+			opt = 0;
+			setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+			cmnd_finish(conn);
+
+			switch (conn->state) {
+			case STATE_KERNEL:
+				res = conn_take_fd(conn, fd);
+				if (res)
+					conn->state = STATE_CLOSE;
+				else {
+					conn->state = STATE_SCSI;
+					conn_read_pdu(conn);
+					tgt_event_modify(fd, EPOLLIN);
+				}
+				break;
+			case STATE_EXIT:
+			case STATE_CLOSE:
+				break;
+			case STATE_SCSI:
+				iscsi_cmd_tx_done(conn);
+				break;
+			default:
+				conn_read_pdu(conn);
+				tgt_event_modify(fd, EPOLLIN);
+				break;
+			}
+			break;
+		}
+
+		break;
+	default:
+		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
+			conn->tx_iostate);
+		conn->state = STATE_CLOSE;
+	}
+
+}
+
+static void iscsi_event_handler(int fd, int events, void *data)
+{
+	struct connection *conn = (struct connection *) data;
+
+	if (events & EPOLLIN)
+		iscsi_rx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE)
+		dprintf("connection closed\n");
+
+	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
+		iscsi_tx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE) {
+		dprintf("connection closed\n");
+		conn_free(conn);
+		tgt_event_del(fd);
+		close(fd);
+	}
+}
+
+static void accept_connection(int afd, int events, void *data)
+{
+	struct sockaddr_storage from;
+	socklen_t namesize;
+	struct connection *conn;
+	int fd, err;
+
+	eprintf("%d\n", afd);
+
+	namesize = sizeof(from);
+	fd = accept(afd, (struct sockaddr *) &from, &namesize);
+	if (fd < 0) {
+		eprintf("can't accept, %m\n");
+		return;
+	}
+
+	conn = conn_alloc();
+	if (!conn)
+		goto out;
+
+	conn->fd = fd;
+
+	conn_read_pdu(conn);
+	set_non_blocking(fd);
+
+	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
+	if (err)
+		goto free_conn;
+
+	return;
+free_conn:
+	free(conn);
+out:
+	close(fd);
+	return;
+}
+
+int iscsi_init(void)
+{
+	struct addrinfo hints, *res, *res0;
+	char servname[64];
+	int err, i, fd, opt, nr_sock = 0;
+
+	memset(servname, 0, sizeof(servname));
+	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_PASSIVE;
+
+	err = getaddrinfo(NULL, servname, &hints, &res0);
+	if (err) {
+		eprintf("unable to get address info, %m\n");
+		return -errno;
+	}
+
+	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
+		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (fd < 0) {
+			eprintf("unable to create fdet %d %d %d, %m\n",
+				res->ai_family,	res->ai_socktype,
+				res->ai_protocol);
+			continue;
+		}
+
+		opt = 1;
+		err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt,
+				 sizeof(opt));
+		if (err)
+			dprintf("unable to set SO_REUSEADDR, %m\n");
+
+		opt = 1;
+		if (res->ai_family == AF_INET6) {
+			err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt,
+					 sizeof(opt));
+			if (err) {
+				close(fd);
+				continue;
+			}
+		}
+
+		err = bind(fd, res->ai_addr, res->ai_addrlen);
+		if (err) {
+			close(fd);
+			eprintf("unable to bind server socket, %m\n");
+			continue;
+		}
+
+		err = listen(fd, INCOMING_MAX);
+		if (err) {
+			eprintf("unable to listen to server socket, %m\n");
+			close(fd);
+			continue;
+		}
+
+		set_non_blocking(fd);
+		err = tgt_event_add(fd, EPOLLIN, accept_connection, NULL);
+		if (err)
+			close(fd);
+		else
+			nr_sock++;
+	}
+
+	freeaddrinfo(res0);
+
+	return !nr_sock;
+}

Deleted: trunk/usr/iscsi/istgt.c
===================================================================
--- trunk/usr/iscsi/istgt.c	2006-08-31 12:16:21 UTC (rev 567)
+++ trunk/usr/iscsi/istgt.c	2006-08-31 12:22:39 UTC (rev 568)
@@ -1,345 +0,0 @@
-/*
- * Software iSCSI target library
- *
- * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This code is based on Ardis's iSCSI implementation.
- *   http://www.ardistech.com/iscsi/
- *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
- *   licensed under the terms of the GNU GPL v2.0,
- */
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <getopt.h>
-#include <netdb.h>
-
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-#include <sys/epoll.h>
-
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <netinet/ip.h>
-#include <arpa/inet.h>
-
-#include "iscsid.h"
-#include "tgtd.h"
-
-#define ISCSI_LISTEN_PORT	3260
-#define LISTEN_MAX		4
-#define INCOMING_MAX		32
-
-static void set_non_blocking(int fd)
-{
-	int err;
-
-	err = fcntl(fd, F_GETFL);
-	if (err < 0) {
-		eprintf("unable to get fd flags, %m\n");
-	} else {
-		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
-		if (err == -1)
-			eprintf("unable to set fd flags, %m\n");
-	}
-}
-
-static void iscsi_rx_handler(int fd, struct connection *conn)
-{
-	int res;
-
-	switch (conn->rx_iostate) {
-	case IOSTATE_READ_BHS:
-	case IOSTATE_READ_AHS_DATA:
-	read_again:
-		res = read(fd, conn->rx_buffer, conn->rx_size);
-		if (res <= 0) {
-			if (res == 0 || (errno != EINTR && errno != EAGAIN))
-				conn->state = STATE_CLOSE;
-			else if (errno == EINTR)
-				goto read_again;
-			break;
-		}
-		conn->rx_size -= res;
-		conn->rx_buffer += res;
-		if (conn->rx_size)
-			break;
-
-		switch (conn->rx_iostate) {
-		case IOSTATE_READ_BHS:
-			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
-			conn->req.ahssize = conn->req.bhs.hlength * 4;
-			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-			conn->rx_size = (conn->req.ahssize + conn->req.datasize + 3) & -4;
-
-			if (conn->req.ahssize) {
-				eprintf("FIXME: we cannot handle ahs\n");
-				conn->state = STATE_CLOSE;
-				break;
-			}
-
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_cmd_rx_start(conn);
-				if (res) {
-					conn->state = STATE_CLOSE;
-					break;
-				}
-			}
-
-			if (conn->rx_size) {
-				if (conn->state != STATE_SCSI) {
-					conn->rx_buffer = conn->req_buffer;
-					conn->req.ahs = conn->rx_buffer;
-				}
-				conn->req.data =
-					conn->rx_buffer + conn->req.ahssize;
-				goto read_again;
-			}
-
-		case IOSTATE_READ_AHS_DATA:
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_cmd_rx_done(conn);
-				if (!res)
-					conn_read_pdu(conn);
-			} else {
-				conn_write_pdu(conn);
-				tgt_event_modify(fd, EPOLLOUT);
-				res = cmnd_execute(conn);
-			}
-
-			if (res)
-				conn->state = STATE_CLOSE;
-			break;
-		}
-		break;
-	}
-}
-
-static void iscsi_tx_handler(int fd, struct connection *conn)
-{
-	int res, opt;
-
-	if (conn->state == STATE_SCSI && !conn->tx_ctask) {
-		res = iscsi_cmd_tx_start(conn);
-		if (res)
-			return;
-	}
-
-	switch (conn->tx_iostate) {
-	case IOSTATE_WRITE_BHS:
-	case IOSTATE_WRITE_AHS:
-	case IOSTATE_WRITE_DATA:
-	write_again:
-		opt = 1;
-		setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-		res = write(fd, conn->tx_buffer, conn->tx_size);
-		if (res < 0) {
-			if (errno != EINTR && errno != EAGAIN)
-				conn->state = STATE_CLOSE;
-			else if (errno == EINTR)
-				goto write_again;
-			break;
-		}
-
-		conn->tx_size -= res;
-		conn->tx_buffer += res;
-		if (conn->tx_size)
-			goto write_again;
-
-		switch (conn->tx_iostate) {
-		case IOSTATE_WRITE_BHS:
-			if (conn->rsp.ahssize) {
-				conn->tx_iostate = IOSTATE_WRITE_AHS;
-				conn->tx_buffer = conn->rsp.ahs;
-				conn->tx_size = conn->rsp.ahssize;
-				goto write_again;
-			}
-		case IOSTATE_WRITE_AHS:
-			if (conn->rsp.datasize) {
-				int pad;
-
-				conn->tx_iostate = IOSTATE_WRITE_DATA;
-				conn->tx_buffer = conn->rsp.data;
-				conn->tx_size = conn->rsp.datasize;
-				pad = conn->tx_size & (PAD_WORD_LEN - 1);
-				if (pad) {
-					memset(conn->tx_buffer + conn->tx_size,
-					       0, pad);
-					conn->tx_size += pad;
-				}
-				goto write_again;
-			}
-		case IOSTATE_WRITE_DATA:
-			opt = 0;
-			setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-			cmnd_finish(conn);
-
-			switch (conn->state) {
-			case STATE_KERNEL:
-				res = conn_take_fd(conn, fd);
-				if (res)
-					conn->state = STATE_CLOSE;
-				else {
-					conn->state = STATE_SCSI;
-					conn_read_pdu(conn);
-					tgt_event_modify(fd, EPOLLIN);
-				}
-				break;
-			case STATE_EXIT:
-			case STATE_CLOSE:
-				break;
-			case STATE_SCSI:
-				iscsi_cmd_tx_done(conn);
-				break;
-			default:
-				conn_read_pdu(conn);
-				tgt_event_modify(fd, EPOLLIN);
-				break;
-			}
-			break;
-		}
-
-		break;
-	default:
-		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
-			conn->tx_iostate);
-		conn->state = STATE_CLOSE;
-	}
-
-}
-
-static void iscsi_event_handler(int fd, int events, void *data)
-{
-	struct connection *conn = (struct connection *) data;
-
-	if (events & EPOLLIN)
-		iscsi_rx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE)
-		dprintf("connection closed\n");
-
-	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
-		iscsi_tx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE) {
-		dprintf("connection closed\n");
-		conn_free(conn);
-		tgt_event_del(fd);
-		close(fd);
-	}
-}
-
-static void accept_connection(int afd, int events, void *data)
-{
-	struct sockaddr_storage from;
-	socklen_t namesize;
-	struct connection *conn;
-	int fd, err;
-
-	eprintf("%d\n", afd);
-
-	namesize = sizeof(from);
-	fd = accept(afd, (struct sockaddr *) &from, &namesize);
-	if (fd < 0) {
-		eprintf("can't accept, %m\n");
-		return;
-	}
-
-	conn = conn_alloc();
-	if (!conn)
-		goto out;
-
-	conn->fd = fd;
-
-	conn_read_pdu(conn);
-	set_non_blocking(fd);
-
-	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
-	if (err)
-		goto free_conn;
-
-	return;
-free_conn:
-	free(conn);
-out:
-	close(fd);
-	return;
-}
-
-int iscsi_init(void)
-{
-	struct addrinfo hints, *res, *res0;
-	char servname[64];
-	int err, i, fd, opt, nr_sock = 0;
-
-	memset(servname, 0, sizeof(servname));
-	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_flags = AI_PASSIVE;
-
-	err = getaddrinfo(NULL, servname, &hints, &res0);
-	if (err) {
-		eprintf("unable to get address info, %m\n");
-		return -errno;
-	}
-
-	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
-		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-		if (fd < 0) {
-			eprintf("unable to create fdet %d %d %d, %m\n",
-				res->ai_family,	res->ai_socktype,
-				res->ai_protocol);
-			continue;
-		}
-
-		opt = 1;
-		err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt,
-				 sizeof(opt));
-		if (err)
-			dprintf("unable to set SO_REUSEADDR, %m\n");
-
-		opt = 1;
-		if (res->ai_family == AF_INET6) {
-			err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt,
-					 sizeof(opt));
-			if (err) {
-				close(fd);
-				continue;
-			}
-		}
-
-		err = bind(fd, res->ai_addr, res->ai_addrlen);
-		if (err) {
-			close(fd);
-			eprintf("unable to bind server socket, %m\n");
-			continue;
-		}
-
-		err = listen(fd, INCOMING_MAX);
-		if (err) {
-			eprintf("unable to listen to server socket, %m\n");
-			close(fd);
-			continue;
-		}
-
-		set_non_blocking(fd);
-		err = tgt_event_add(fd, EPOLLIN, accept_connection, NULL);
-		if (err)
-			close(fd);
-		else
-			nr_sock++;
-	}
-
-	freeaddrinfo(res0);
-
-	return !nr_sock;
-}



From tomo at mail.berlios.de  Thu Aug 31 14:26:09 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:26:09 +0200
Subject: [Stgt-svn] r569 - trunk/usr/iscsi
Message-ID: <200608311226.k7VCQ9PM013898@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:26:07 +0200 (Thu, 31 Aug 2006)
New Revision: 569

Modified:
   trunk/usr/iscsi/iscsid.h
Log:
Clean up iscsid.h

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-08-31 12:22:39 UTC (rev 568)
+++ trunk/usr/iscsi/iscsid.h	2006-08-31 12:26:07 UTC (rev 569)
@@ -207,11 +207,6 @@
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
 
-extern int iscsi_cmd_rx_start(struct connection *conn);
-extern int iscsi_cmd_rx_done(struct connection *conn);
-extern int iscsi_cmd_tx_start(struct connection *conn);
-extern int iscsi_cmd_tx_done(struct connection *conn);
-
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
 extern int session_create(struct connection *conn);
@@ -222,7 +217,6 @@
 extern int target_find_by_name(const char *name, int *tid);
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
-extern int target_bind(int tid, int hostno);
 
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);



From tomo at mail.berlios.de  Thu Aug 31 14:31:15 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:31:15 +0200
Subject: [Stgt-svn] r570 - trunk
Message-ID: <200608311231.k7VCVF5Y015494@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:31:13 +0200 (Thu, 31 Aug 2006)
New Revision: 570

Removed:
   trunk/ibmvstgt/
   trunk/kernel/
Modified:
   trunk/Makefile
Log:
Remove old kernel code. Please use the git tree instead.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-08-31 12:26:07 UTC (rev 569)
+++ trunk/Makefile	2006-08-31 12:31:13 UTC (rev 570)
@@ -2,7 +2,7 @@
 # Need to use some magic to select what target drivers will be complied
 #
 
-IBMVIO=1
+#IBMVIO=1
 ISCSI=1
 
 ifeq ($(KERNELSRC),)
@@ -15,8 +15,6 @@
 
 all:
 	make -C usr
-	make -C istgt
 
 clean:
 	make -C usr clean
-	make -C istgt clean



From tomo at mail.berlios.de  Thu Aug 31 14:48:32 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:48:32 +0200
Subject: [Stgt-svn] r571 - trunk/patchset
Message-ID: <200608311248.k7VCmWka020986@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:48:02 +0200 (Thu, 31 Aug 2006)
New Revision: 571

Removed:
   trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
   trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
   trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
   trunk/patchset/README
Log:
Remove the old patchset because they are in the git tree.

Deleted: trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,48 +0,0 @@
-From 44951054af3722883087e928979f1c89fdee918b Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:47:00 +0900
-Subject: [PATCH 1/9] block layer: kill length alignment test in bin_map_user
-
-The tgt project is mapping in bios using bio_map_user. The current targets
-do not need their len to be aligned with a queue limit so this check is
-causing some problems. Note: pointers passed into the kernel are properly
-aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
-
-The major user, blk_bio_map_user checks for the len before mapping
-so it is not affected by this patch.
-
-And the semi-newly added user blk_rq_map_user_iov has been failing
-out when the len is not aligned properly so maybe people have been
-good and not sending misaligned lens or that path is not used very
-often and this change will not be very dangerous. st and sg do not
-check the length and we have not seen any problem reports from those
-wider used paths so this patch should be fairly safe - for mm
-and wider testing at least.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- fs/bio.c |    5 ++---
- 1 files changed, 2 insertions(+), 3 deletions(-)
-
-diff --git a/fs/bio.c b/fs/bio.c
-index 6a0b9ad..6fe47ce 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
--- 
-1.4.1
-

Deleted: trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,154 +0,0 @@
-From 79acdaa1243aecedcd035c3219375a7cb9c9f786 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:48:58 +0900
-Subject: [PATCH 2/9] block layer: add partial mappings support to bio_map_user
-
-For target mode we could end up with the case where we get very large
-request from the initiator. The request could be so large that we
-cannot transfer all the data in one operation. For example the
-HBA's segment or max_sector limits might limit us to a 1 MB transfer.
-To send a 5 MB command then we need to transfer the command chunk by chunk.
-
-To do this, tgt core will map in as much data as possible into a bio,
-send this off, then when that transfer is completed we send off another
-request/bio. To be able to pack as much data into a bio as possible
-we need bio_map_user to support partially mapped bios.
-
-- bio_map_user_iov always allows partial mappings.
-
-- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
-if the bio is partially mapped.
-
-- Added a length argument to blk_rq_map_user_iov in order to avoid
-including sg.h in ll_rw_blk.c for struct sg_iovec.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
- block/scsi_ioctl.c     |    3 ++-
- fs/bio.c               |   14 +-------------
- include/linux/blkdev.h |    3 ++-
- 4 files changed, 23 insertions(+), 26 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index 61d6b3c..aee4f4b 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
--	if (!IS_ERR(bio)) {
--		rq->bio = rq->biotail = bio;
--		blk_rq_bio_prep(q, rq, bio);
-+	if (IS_ERR(bio))
-+		return PTR_ERR(bio);
- 
--		rq->buffer = rq->data = NULL;
--		rq->data_len = len;
--		return 0;
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
- 	}
- 
--	/*
--	 * bio is the err-ptr
--	 */
--	return PTR_ERR(bio);
-+	rq->bio = rq->biotail = bio;
-+	blk_rq_bio_prep(q, rq, bio);
-+	rq->buffer = rq->data = NULL;
-+	rq->data_len = len;
-+	return 0;
- }
- 
- EXPORT_SYMBOL(blk_rq_map_user);
-@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
-  *    unmapping.
-  */
- int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
--			struct sg_iovec *iov, int iov_count)
-+			struct sg_iovec *iov, int iov_count, unsigned int len)
- {
- 	struct bio *bio;
- 
-@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
-+	}
-+
- 	rq->bio = rq->biotail = bio;
- 	blk_rq_bio_prep(q, rq, bio);
- 	rq->buffer = rq->data = NULL;
-diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
-index b33eda2..b77e185 100644
---- a/block/scsi_ioctl.c
-+++ b/block/scsi_ioctl.c
-@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
- 			goto out;
- 		}
- 
--		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
-+		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
-+					  hdr->dxfer_len);
- 		kfree(iov);
- 	} else if (hdr->dxfer_len)
- 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
-diff --git a/fs/bio.c b/fs/bio.c
-index 6fe47ce..ade77bf 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
- 			     int write_to_vm)
- {
- 	struct bio *bio;
--	int len = 0, i;
- 
- 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
- 
-@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
- 	 */
- 	bio_get(bio);
- 
--	for (i = 0; i < iov_count; i++)
--		len += iov[i].iov_len;
--
--	if (bio->bi_size == len)
--		return bio;
--
--	/*
--	 * don't support partial mappings
--	 */
--	bio_endio(bio, bio->bi_size, 0);
--	bio_unmap_user(bio);
--	return ERR_PTR(-EINVAL);
-+	return bio;
- }
- 
- static void __bio_unmap_user(struct bio *bio)
-diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
-index aafe827..613a441 100644
---- a/include/linux/blkdev.h
-+++ b/include/linux/blkdev.h
-@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
- extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
- extern int blk_rq_unmap_user(struct bio *, unsigned int);
- extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
--extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
-+extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
-+			       struct sg_iovec *, int, unsigned int);
- extern int blk_execute_rq(request_queue_t *, struct gendisk *,
- 			  struct request *, int);
- extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
--- 
-1.4.1
-

Deleted: trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,54 +0,0 @@
-From 3f63e5e44b012927b6054f7025d3a5e7be6f7f09 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:52:17 +0900
-Subject: [PATCH 3/9] block layer: use blk_rq_bio_prep in init_request_from_bio
-
-Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
-blk_rq_bio_prep's flags copying. The first three bits have not been
-the same for some time so that has been broken. The user of
-blk_rq_bio_prep will setup the request flags so if it wanted failfast
-or to be a barrier it will set the correct flag itself.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c |   11 ++---------
- 1 files changed, 2 insertions(+), 9 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index aee4f4b..3f46356 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
- 
- 	req->errors = 0;
- 	req->hard_sector = req->sector = bio->bi_sector;
--	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
--	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
--	req->nr_phys_segments = bio_phys_segments(req->q, bio);
--	req->nr_hw_segments = bio_hw_segments(req->q, bio);
--	req->buffer = bio_data(bio);	/* see ->buffer comment above */
- 	req->waiting = NULL;
--	req->bio = req->biotail = bio;
- 	req->ioprio = bio_prio(bio);
- 	req->rq_disk = bio->bi_bdev->bd_disk;
- 	req->start_time = jiffies;
-+
-+	blk_rq_bio_prep(req->q, req, bio);
- }
- 
- static int __make_request(request_queue_t *q, struct bio *bio)
-@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
- 
- void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
- {
--	/* first two bits are identical in rq->flags and bio->bi_rw */
--	rq->flags |= (bio->bi_rw & 3);
--
- 	rq->nr_phys_segments = bio_phys_segments(q, bio);
- 	rq->nr_hw_segments = bio_hw_segments(q, bio);
- 	rq->current_nr_sectors = bio_cur_sectors(bio);
--- 
-1.4.1
-

Deleted: trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,330 +0,0 @@
-From 8f167fea740f5d82c70a2e9938e983b704baae67 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:56:41 +0900
-Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
-
-This patch contains the needed changes to the scsi-ml to support targets.
-
-Note, per the last review we moved almost all the fields we added
-to the scsi_cmnd to our internal data structure which we are going
-to try and kill off when we can replace it with support from other
-parts of the kernel.
-
-The one field we left on was the offset variable. This is needed to handle
-the case where the target gets request that is so large that it cannot
-execute it in one dma operation. So max_secotors or a segment limit may
-limit the size of the transfer. In this case our tgt core code will
-break up the command into managable transfers and send them to the
-LLD one at a time. The offset is then used to tell the LLD where in
-the command we are at. Is there another field on the scsi_cmd for
-that?
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/hosts.c     |    4 ++++
- drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
- drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
- include/scsi/scsi_cmnd.h |   10 ++++++++++
- include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
- 5 files changed, 107 insertions(+), 26 deletions(-)
-
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index dfcb96f..341c1ee 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
- 		kthread_stop(shost->ehandler);
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
- 
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index b332cad..08f8597 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
-+{
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(dev);
-+}
-+EXPORT_SYMBOL(__scsi_put_command);
-+
- /*
-  * Function:	scsi_put_command()
-  *
-@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
--
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 077c1c6..ea22612 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -734,7 +734,9 @@ #endif
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 58e6444..fe4455c 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@ #include <linux/timer.h>
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- 
- 
-@@ -72,6 +73,9 @@ #define MAX_COMMAND_SIZE	16
- 	unsigned short use_sg;	/* Number of pieces of scatter-gather */
- 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
- 
-+	/* offset in cmd we are at (for multi-transfer tgt cmds) */
-+	unsigned offset;
-+
- 	unsigned underflow;	/* Return error if less than
- 				   this amount is transferred */
- 
-@@ -133,7 +137,10 @@ #define SCSI_STATE_MLQUEUE         0x100
- 
- 
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
-@@ -142,4 +149,7 @@ extern void *scsi_kmap_atomic_sg(struct 
- 				 size_t *offset, size_t *len);
- extern void scsi_kunmap_atomic_sg(void *virt);
- 
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
-+
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index b3dd90f..1a393b6 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@ #include <linux/types.h>
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -122,6 +123,39 @@ #endif
- 	int (* queuecommand)(struct scsi_cmnd *,
- 			     void (*done)(struct scsi_cmnd *));
- 
-+ 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/* Used as callback for the completion of task management request. */
-+	int (* tsk_mgmt_response)(u64 mid, int result);
-+
- 	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
-@@ -561,6 +595,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+						void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
--- 
-1.4.1
-

Deleted: trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,789 +0,0 @@
-From 116f6f576a16fd7a2685916e4146930f90204d46 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Fri, 18 Aug 2006 11:55:41 +0900
-Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
-
-The core scsi target lib functions.
-
-TODO:
-- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
-do that weird include.
-- convert scsi_tgt_cmd's work struct to James's execute code. And try
-to kill our scsi_tgt_cmd.
-- add host state checking. We do refcouting so hotplug is partially
-supported, but we need to add state checking to make it easier on
-the LLD.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/scsi_tgt_lib.c  |  700 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   25 ++
- include/scsi/scsi_tgt.h      |   18 +
- 3 files changed, 743 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-new file mode 100644
-index 0000000..c515c27
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,700 @@
-+/*
-+ * SCSI target lib functions
-+ *
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/hash.h>
-+#include <linux/module.h>
-+#include <linux/pagemap.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <../drivers/md/dm-bio-list.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static struct workqueue_struct *scsi_tgtd;
-+static kmem_cache_t *scsi_tgt_cmd_cache;
-+
-+/*
-+ * TODO: this struct will be killed when the block layer supports large bios
-+ * and James's work struct code is in
-+ */
-+struct scsi_tgt_cmd {
-+	/* TODO replace work with James b's code */
-+	struct work_struct work;
-+	/* TODO replace the lists with a large bio */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
-+
-+	struct list_head hash_list;
-+	struct request *rq;
-+	u64 tag;
-+
-+	void *buffer;
-+	unsigned bufflen;
-+};
-+
-+#define TGT_HASH_ORDER	4
-+#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
-+
-+struct scsi_tgt_queuedata {
-+	struct Scsi_Host *shost;
-+	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
-+	spinlock_t cmd_hash_lock;
-+};
-+
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq->end_io_data = tcmd;
-+
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+	tcmd->rq = rq;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q->queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+
-+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-+{
-+	struct bio *bio;
-+
-+	/* must call bio_endio in case bio was bounced */
-+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+
-+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+}
-+
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_del(&tcmd->hash_list);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+static void scsi_tgt_cmd_destroy(void *data)
-+{
-+	struct scsi_cmnd *cmd = data;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
-+		rq_data_dir(cmd->request));
-+
-+	cmd_hashlist_del(cmd);
-+
-+	scsi_unmap_user_pages(tcmd);
-+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-+}
-+
-+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
-+			      u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
-+	unsigned long flags;
-+	struct list_head *head;
-+
-+	tcmd->tag = tag;
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	list_add(&tcmd->hash_list, head);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+/*
-+ * scsi_tgt_alloc_queue - setup queue used for message passing
-+ * shost: scsi host
-+ *
-+ * This should be called by the LLD after host allocation.
-+ * And will be released when the host is released.
-+ */
-+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-+{
-+	struct scsi_tgt_queuedata *queuedata;
-+	struct request_queue *q;
-+	int err, i;
-+
-+	/*
-+	 * Do we need to send a netlink event or should uspace
-+	 * just respond to the hotplug event?
-+	 */
-+	q = __scsi_alloc_queue(shost, NULL);
-+	if (!q)
-+		return -ENOMEM;
-+
-+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-+	if (!queuedata) {
-+		err = -ENOMEM;
-+		goto cleanup_queue;
-+	}
-+	queuedata->shost = shost;
-+	q->queuedata = queuedata;
-+
-+	/*
-+	 * this is a silly hack. We should probably just queue as many
-+	 * command as is recvd to userspace. uspace can then make
-+	 * sure we do not overload the HBA
-+	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	/*
-+	 * We currently only support software LLDs so this does
-+	 * not matter for now. Do we need this for the cards we support?
-+	 * If so we should make it a host template value.
-+	 */
-+	blk_queue_dma_alignment(q, 0);
-+	shost->uspace_req_q = q;
-+
-+	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
-+		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
-+	spin_lock_init(&queuedata->cmd_hash_lock);
-+
-+	return 0;
-+
-+cleanup_queue:
-+	blk_cleanup_queue(q);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-+
-+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-+	return queue->shost;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-+
-+/*
-+ * scsi_tgt_queue_command - queue command for userspace processing
-+ * @cmd:	scsi command
-+ * @scsilun:	scsi lun
-+ * @tag:	unique value to identify this command for tmf
-+ */
-+int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			   u64 tag)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	init_scsi_tgt_cmd(cmd->request, tcmd, tag);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-+
-+/*
-+ * This is run from a interrpt handler normally and the unmap
-+ * needs process context so we must queue
-+ */
-+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-+	queue_work(scsi_tgtd, &tcmd->work);
-+}
-+
-+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	int err;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-+	switch (err) {
-+	case SCSI_MLQUEUE_HOST_BUSY:
-+	case SCSI_MLQUEUE_DEVICE_BUSY:
-+		return -EAGAIN;
-+	}
-+
-+	return 0;
-+}
-+
-+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	err = __scsi_tgt_transfer_response(cmd);
-+	if (!err)
-+		return;
-+
-+	cmd->result = DID_BUS_BUSY << 16;
-+	err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	if (err <= 0)
-+		/* the eh will have to pick this up */
-+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+}
-+
-+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	int count;
-+
-+	cmd->use_sg = rq->nr_phys_segments;
-+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-+	if (!cmd->request_buffer)
-+		return -ENOMEM;
-+
-+	cmd->request_bufflen = rq->data_len;
-+
-+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
-+		rq_data_dir(rq));
-+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-+	if (likely(count <= cmd->use_sg)) {
-+		cmd->use_sg = count;
-+		return 0;
-+	}
-+
-+	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	return -EINVAL;
-+}
-+
-+/* TODO: test this crap and replace bio_map_user with new interface maybe */
-+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-+			       int rw)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct request *rq = cmd->request;
-+	void *uaddr = tcmd->buffer;
-+	unsigned int len = tcmd->bufflen;
-+	struct bio *bio;
-+	int err;
-+
-+	while (len > 0) {
-+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
-+		if (IS_ERR(bio)) {
-+			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u %d %x\n",
-+				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-+			goto unmap_bios;
-+		}
-+
-+		uaddr += bio->bi_size;
-+		len -= bio->bi_size;
-+
-+		/*
-+		 * The first bio is added and merged. We could probably
-+		 * try to add others using scsi_merge_bio() but for now
-+		 * we keep it simple. The first bio should be pretty large
-+		 * (either hitting the 1 MB bio pages limit or a queue limit)
-+		 * already but for really large IO we may want to try and
-+		 * merge these.
-+		 */
-+		if (!rq->bio) {
-+			blk_rq_bio_prep(q, rq, bio);
-+			rq->data_len = bio->bi_size;
-+		} else
-+			/* put list of bios to transfer in next go around */
-+			bio_list_add(&tcmd->xfer_list, bio);
-+	}
-+
-+	cmd->offset = 0;
-+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-+	if (err)
-+		goto unmap_bios;
-+
-+	return 0;
-+
-+unmap_bios:
-+	if (rq->bio) {
-+		bio_unmap_user(rq->bio);
-+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-+			bio_unmap_user(bio);
-+	}
-+
-+	return err;
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-+
-+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	struct bio *bio;
-+	int err;
-+
-+	/* should we free resources here on error ? */
-+	if (cmd->result) {
-+send_uspace_err:
-+		err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+		if (err <= 0)
-+			/* the tgt uspace eh will have to pick this up */
-+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-+
-+	tcmd->buffer += cmd->request_bufflen;
-+	cmd->offset += cmd->request_bufflen;
-+
-+	if (!tcmd->xfer_list.head) {
-+		scsi_tgt_transfer_response(cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	bio = bio_list_pop(&tcmd->xfer_list);
-+	BUG_ON(!bio);
-+
-+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-+	cmd->request->data_len = bio->bi_size;
-+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-+	if (err) {
-+		cmd->result = DID_ERROR << 16;
-+		goto send_uspace_err;
-+	}
-+
-+	if (scsi_tgt_transfer_data(cmd)) {
-+		cmd->result = DID_NO_CONNECT << 16;
-+		goto send_uspace_err;
-+	}
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-+
-+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-+	switch (err) {
-+		case SCSI_MLQUEUE_HOST_BUSY:
-+		case SCSI_MLQUEUE_DEVICE_BUSY:
-+			return -EAGAIN;
-+	default:
-+		return 0;
-+	}
-+}
-+
-+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-+				unsigned len)
-+{
-+	char __user *p = (char __user *) uaddr;
-+
-+	if (copy_from_user(cmd->sense_buffer, p,
-+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-+		printk(KERN_ERR "Could not copy the sense buffer\n");
-+		return -EIO;
-+	}
-+	return 0;
-+}
-+
-+static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = host->hostt->eh_abort_handler(cmd);
-+	if (err)
-+		eprintk("fail to abort %p\n", cmd);
-+
-+	scsi_tgt_cmd_destroy(cmd);
-+	return err;
-+}
-+
-+static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	struct request *rq = NULL;
-+	struct list_head *head;
-+	struct scsi_tgt_cmd *tcmd;
-+	unsigned long flags;
-+
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_for_each_entry(tcmd, head, hash_list) {
-+		if (tcmd->tag == tag) {
-+			rq = tcmd->rq;
-+			break;
-+		}
-+	}
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+
-+	return rq;
-+}
-+
-+int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+			 unsigned long uaddr, u8 rw)
-+{
-+	struct Scsi_Host *shost;
-+	struct scsi_cmnd *cmd;
-+	struct request *rq;
-+	struct scsi_tgt_cmd *tcmd;
-+	int err = 0;
-+
-+	dprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,
-+		result, len, uaddr, rw);
-+
-+	/* TODO: replace with a O(1) alg */
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+
-+	if (!shost->uspace_req_q) {
-+		printk(KERN_ERR "Not target scsi host %d\n", host_no);
-+		goto done;
-+	}
-+
-+	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
-+	if (!rq) {
-+		printk(KERN_ERR "Could not find tag %llu\n",
-+		       (unsigned long long) tag);
-+		err = -EINVAL;
-+		goto done;
-+	}
-+	cmd = rq->special;
-+
-+	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
-+		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
-+
-+	if (result == TASK_ABORTED) {
-+		scsi_tgt_abort_cmd(shost, cmd);
-+		goto done;
-+	}
-+	/*
-+	 * store the userspace values here, the working values are
-+	 * in the request_* values
-+	 */
-+	tcmd = cmd->request->end_io_data;
-+	tcmd->buffer = (void *)uaddr;
-+	tcmd->bufflen = len;
-+	cmd->result = result;
-+
-+	if (!tcmd->bufflen || cmd->request_buffer) {
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+
-+	/*
-+	 * TODO: Do we need to handle case where request does not
-+	 * align with LLD.
-+	 */
-+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-+	if (err) {
-+		eprintk("%p %d\n", cmd, err);
-+		err = -EAGAIN;
-+		goto done;
-+	}
-+
-+	/* userspace failure */
-+	if (cmd->result) {
-+		if (status_byte(cmd->result) == CHECK_CONDITION)
-+			scsi_tgt_copy_sense(cmd, uaddr, len);
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+	/* ask the target LLD to transfer the data to the buffer */
-+	err = scsi_tgt_transfer_data(cmd);
-+
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-+			      struct scsi_lun *scsilun, void *data)
-+{
-+	int err;
-+
-+	/* TODO: need to retry if this fails. */
-+	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
-+					    tag, scsilun, data);
-+	if (err < 0)
-+		eprintk("The task management request lost!\n");
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-+
-+int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-+{
-+	struct Scsi_Host *shost;
-+	int err = -EINVAL;
-+
-+	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
-+
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return err;
-+	}
-+
-+	if (!shost->uspace_req_q) {
-+		printk(KERN_ERR "Not target scsi host %d\n", host_no);
-+		goto done;
-+	}
-+
-+	err = shost->hostt->tsk_mgmt_response(mid, result);
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+static int __init scsi_tgt_init(void)
-+{
-+	int err;
-+
-+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-+					       sizeof(struct scsi_tgt_cmd),
-+					       0, 0, NULL, NULL);
-+	if (!scsi_tgt_cmd_cache)
-+		return -ENOMEM;
-+
-+	scsi_tgtd = create_workqueue("scsi_tgtd");
-+	if (!scsi_tgtd) {
-+		err = -ENOMEM;
-+		goto free_kmemcache;
-+	}
-+
-+	err = scsi_tgt_if_init();
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(scsi_tgtd);
-+free_kmemcache:
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+	return err;
-+}
-+
-+static void __exit scsi_tgt_exit(void)
-+{
-+	destroy_workqueue(scsi_tgtd);
-+	scsi_tgt_if_exit();
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+}
-+
-+module_init(scsi_tgt_init);
-+module_exit(scsi_tgt_exit);
-+
-+MODULE_DESCRIPTION("SCSI target core");
-+MODULE_LICENSE("GPL");
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-new file mode 100644
-index 0000000..84488c5
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,25 @@
-+struct scsi_cmnd;
-+struct scsi_lun;
-+struct Scsi_Host;
-+struct task_struct;
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+
-+#define dprintk(fmt, args...)
-+/* #define dprintk eprintk */
-+
-+extern void scsi_tgt_if_exit(void);
-+extern int scsi_tgt_if_init(void);
-+
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
-+extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+				unsigned long uaddr, u8 rw);
-+extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+					 struct scsi_lun *scsilun, void *data);
-+extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..1771151
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,18 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+#include <linux/dma-mapping.h>
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
-+extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
-+				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
-+extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
--- 
-1.4.1
-

Deleted: trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,481 +0,0 @@
-From 4f1934d63d45a88066061f460a7e57fdddba6bf6 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:32:41 +0900
-Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
-
-The user-space daemon and tgt kernel module need to exchange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch adds shared memory interface between kernel and user spaces
-like some other drivers do by using own character device. The
-user-space daemon and tgt kernel module creates shared memory via mmap
-and use it like ring buffer. poll (kernel to user) and write (user to
-kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
----
- drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/scsi_tgt_if.h |   93 ++++++++++++
- 2 files changed, 443 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-new file mode 100644
-index 0000000..09c4ab1
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,350 @@
-+/*
-+ * SCSI target kernel/user interface functions
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/miscdevice.h>
-+#include <linux/file.h>
-+#include <net/tcp.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/scsi_tgt_if.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+struct tgt_ring {
-+	u32 tr_idx;
-+	unsigned long tr_pages[TGT_RING_PAGES];
-+	spinlock_t tr_lock;
-+};
-+
-+/* tx_ring : kernel->user, rx_ring : user->kernel */
-+static struct tgt_ring tx_ring, rx_ring;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
-+
-+static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
-+{
-+	if (ring->tr_idx == TGT_MAX_EVENTS - 1)
-+		ring->tr_idx = 0;
-+	else
-+		ring->tr_idx++;
-+}
-+
-+static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
-+{
-+	u32 pidx, off;
-+
-+	pidx = idx / TGT_EVENT_PER_PAGE;
-+	off = idx % TGT_EVENT_PER_PAGE;
-+
-+	return (struct tgt_event *)
-+		(ring->tr_pages[pidx] + sizeof(struct tgt_event) * off);
-+}
-+
-+static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	ev = tgt_head_event(ring, ring->tr_idx);
-+	if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+		tgt_ring_idx_inc(ring);
-+	else
-+		err = -BUSY;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	if (err)
-+		return err;
-+
-+	memcpy(ev, p, sizeof(*ev));
-+	ev->type = type;
-+	ev->status = TGT_EVENT_STATUS_USED;
-+	mb();
-+
-+	flush_dcache_page(virt_to_page(ev));
-+
-+	wake_up_interruptible(&tgt_poll_wait);
-+
-+	return 0;
-+}
-+
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost->host_no;
-+	ev.k.cmd_req.data_len = cmd->request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd->tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_done.host_no = shost->host_no;
-+	ev.k.cmd_done.tag = tag;
-+	ev.k.cmd_done.result = cmd->result;
-+
-+	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
-+		(unsigned long long) ev.k.cmd_req.tag,
-+		ev.k.cmd_req.data_len, cmd->tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+				  struct scsi_lun *scsilun, void *data)
-+{
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.tsk_mgmt_req.host_no = host_no;
-+	ev.k.tsk_mgmt_req.function = function;
-+	ev.k.tsk_mgmt_req.tag = tag;
-+	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-+	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
-+
-+	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
-+		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+static int event_recv_msg(struct tgt_event *ev)
-+{
-+	int err = 0;
-+
-+	switch (ev->type) {
-+	case TGT_UEVENT_CMD_RSP:
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
-+					   ev->u.cmd_rsp.tag,
-+					   ev->u.cmd_rsp.result,
-+					   ev->u.cmd_rsp.len,
-+					   ev->u.cmd_rsp.uaddr,
-+					   ev->u.cmd_rsp.rw);
-+		break;
-+	case TGT_UEVENT_TSK_MGMT_RSP:
-+		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
-+					       ev->u.tsk_mgmt_rsp.mid,
-+					       ev->u.tsk_mgmt_rsp.result);
-+		break;
-+	default:
-+		eprintk("unknown type %d\n", ev->type);
-+		err = -EINVAL;
-+	}
-+
-+	return err;
-+}
-+
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &rx_ring;
-+
-+	while (1) {
-+		ev = tgt_head_event(ring, ring->tr_idx);
-+		if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+			break;
-+
-+		/* do we need this? */
-+		flush_dcache_page(virt_to_page(ev));
-+
-+		tgt_ring_idx_inc(ring);
-+		ev->status = TGT_EVENT_STATUS_EMPTY;
-+		event_recv_msg(ev);
-+	};
-+
-+	return count;
-+}
-+
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	unsigned int mask = 0;
-+	u32 idx;
-+
-+	poll_wait(file, &tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	idx = ring->tr_idx ? ring->tr_idx - 1 : TGT_MAX_EVENTS - 1;
-+	ev = tgt_head_event(ring, idx);
-+	if (ev->status == TGT_EVENT_STATUS_USED)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	return mask;
-+}
-+
-+static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
-+			   struct tgt_ring *ring)
-+{
-+	int i, err;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		struct page *page = virt_to_page(ring->tr_pages[i]);
-+		err = vm_insert_page(vma, addr, page);
-+		if (err)
-+			return err;
-+		addr += PAGE_SIZE;
-+	}
-+
-+	return 0;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long addr;
-+	int err;
-+
-+	if (vma->vm_pgoff)
-+		return -EINVAL;
-+
-+	if (vma->vm_end - vma->vm_start != TGT_RING_SIZE * 2) {
-+		eprintk("mmap size must be %lu, not %lu \n",
-+			TGT_RING_SIZE * 2, vma->vm_end - vma->vm_start);
-+		return -EINVAL;
-+	}
-+
-+	addr = vma->vm_start;
-+	err = uspace_ring_map(vma, addr, &tx_ring);
-+	if (err)
-+		return err;
-+	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &rx_ring);
-+
-+	return err;
-+}
-+
-+static int tgt_open(struct inode *inode, struct file *file)
-+{
-+	tx_ring.tr_idx = rx_ring.tr_idx = 0;
-+
-+	return 0;
-+}
-+
-+static struct file_operations tgt_fops = {
-+	.owner		= THIS_MODULE,
-+	.open		= tgt_open,
-+	.poll		= tgt_poll,
-+	.write		= tgt_write,
-+	.mmap		= tgt_mmap,
-+};
-+
-+static struct miscdevice tgt_miscdev = {
-+	.minor = MISC_DYNAMIC_MINOR,
-+	.name = "tgt",
-+	.fops = &tgt_fops,
-+};
-+
-+static void tgt_ring_exit(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++)
-+		free_page(ring->tr_pages[i]);
-+}
-+
-+static int tgt_ring_init(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	spin_lock_init(&ring->tr_lock);
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		ring->tr_pages[i] = get_zeroed_page(GFP_KERNEL);
-+		if (!ring->tr_pages[i]) {
-+			eprintk("out of memory\n");
-+			return -ENOMEM;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+void scsi_tgt_if_exit(void)
-+{
-+	tgt_ring_exit(&tx_ring);
-+	tgt_ring_exit(&rx_ring);
-+	misc_deregister(&tgt_miscdev);
-+}
-+
-+int scsi_tgt_if_init(void)
-+{
-+	int err;
-+
-+	err = tgt_ring_init(&tx_ring);
-+	if (err)
-+		return err;
-+
-+	err = tgt_ring_init(&rx_ring);
-+	if (err)
-+		goto free_tx_ring;
-+
-+	err = misc_register(&tgt_miscdev);
-+	if (err)
-+		goto free_rx_ring;
-+
-+	return 0;
-+free_rx_ring:
-+	tgt_ring_exit(&rx_ring);
-+free_tx_ring:
-+	tgt_ring_exit(&tx_ring);
-+
-+	return err;
-+}
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..5671920
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,93 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_status {
-+	TGT_EVENT_STATUS_EMPTY = 0,
-+	TGT_EVENT_STATUS_USED,
-+};
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_CMD_RSP,
-+	TGT_UEVENT_TSK_MGMT_RSP,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+	TGT_KEVENT_TSK_MGMT_REQ,
-+};
-+
-+struct tgt_event {
-+	uint32_t status;
-+	uint32_t type;
-+
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint8_t rw;
-+			uint64_t tag;
-+		} cmd_rsp;
-+		struct {
-+			int host_no;
-+			uint64_t mid;
-+			int result;
-+		} tsk_mgmt_rsp;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t data_len;
-+			uint8_t scb[16];
-+			uint8_t lun[8];
-+			int attribute;
-+			uint64_t tag;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint64_t tag;
-+			int result;
-+		} cmd_done;
-+		struct {
-+			int host_no;
-+			int function;
-+			uint64_t tag;
-+			uint8_t lun[8];
-+			uint64_t mid;
-+		} tsk_mgmt_req;
-+	} k;
-+
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RING_SIZE (1UL << 16)
-+#define TGT_RING_PAGES (TGT_RING_SIZE >> PAGE_SHIFT)
-+#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
-+#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
-+
-+#endif
--- 
-1.4.1
-

Deleted: trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
===================================================================
--- trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,57 +0,0 @@
-From 4d62965a2d1d43b05529bf2f26563d3ddbe449cb Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Fri, 18 Aug 2006 00:33:17 +0900
-Subject: [PATCH 7/9] scsi-ml: Makefile and Kconfig changes for tgt
-
-Makefile and Kconfig stuff.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    7 +++++++
- drivers/scsi/Makefile |    3 +++
- 2 files changed, 10 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 96a81cd..566626c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -27,6 +27,13 @@ config SCSI
- 	  However, do not compile this as a module if your root file system
- 	  (the one containing the directory /) is located on a SCSI device.
- 
-+config SCSI_TGT
-+	tristate "SCSI target support"
-+	depends on SCSI && EXPERIMENTAL
-+	---help---
-+	  If you want to use SCSI target mode drivers enable this option.
-+	  If you choose M, the module will be called scsi_tgt.
-+
- config SCSI_PROC_FS
- 	bool "legacy /proc/scsi/ support"
- 	depends on SCSI && PROC_FS
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ebd0cf0..ede0c45 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
- subdir-$(CONFIG_PCMCIA)		+= pcmcia
- 
- obj-$(CONFIG_SCSI)		+= scsi_mod.o
-+obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
- 
- obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
- 
-@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
- scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
- scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
- 
-+scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
-+
- sd_mod-objs	:= sd.o
- sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
- ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
--- 
-1.4.1
-

Deleted: trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
===================================================================
--- trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,591 +0,0 @@
-From b5ab4781574e70ed224a5dee7fe600880c98dda4 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:36:47 +0900
-Subject: [PATCH 8/9] scsi tgt: SCSI RDMA Protocol library functions
-
-libsrp provides helper functions for SRP target drivers.
-
-The next step would be to add initiator support to merge the two SRP
-initiator drivers (ibmvscsi and ib_srp) in mainline.
-
-Some SRP target drivers would be out of drivers/scsi/ so I added an
-entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
-it.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    9 +
- drivers/scsi/Makefile |    1 
- drivers/scsi/libsrp.c |  441 +++++++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/libsrp.h |   79 +++++++++
- 4 files changed, 530 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 566626c..e5098d3 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -1846,6 +1846,15 @@ config ZFCP
-           called zfcp. If you want to compile it as a module, say M here
-           and read <file:Documentation/modules.txt>.
- 
-+config SCSI_SRP
-+	tristate "SCSI RDMA Protocol helper library"
-+	depends on SCSI
-+	help
-+	  If you wish to use SRP target drivers, say Y.
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called libsrp.
-+
- endmenu
- 
- source "drivers/scsi/pcmcia/Kconfig"
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ede0c45..d71bb59 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
- obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
-+obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
-diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
-new file mode 100644
-index 0000000..86b7718
---- /dev/null
-+++ b/drivers/scsi/libsrp.c
-@@ -0,0 +1,441 @@
-+/*
-+ * SCSI RDAM Protocol lib functions
-+ *
-+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/err.h>
-+#include <linux/kfifo.h>
-+#include <linux/scatterlist.h>
-+#include <linux/dma-mapping.h>
-+#include <linux/pci.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_tcq.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/srp.h>
-+#include <scsi/libsrp.h>
-+
-+enum srp_task_attributes {
-+	SRP_SIMPLE_TASK = 0,
-+	SRP_HEAD_TASK = 1,
-+	SRP_ORDERED_TASK = 2,
-+	SRP_ACA_TASK = 4
-+};
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
-+			     struct srp_buf **ring)
-+{
-+	int i;
-+	struct iu_entry *iue;
-+
-+	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
-+	if (!q->pool)
-+		return -ENOMEM;
-+	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
-+	if (!q->items)
-+		goto free_pool;
-+
-+	spin_lock_init(&q->lock);
-+	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
-+			      GFP_KERNEL, &q->lock);
-+	if (IS_ERR(q->queue))
-+		goto free_item;
-+
-+	for (i = 0, iue = q->items; i < max; i++) {
-+		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
-+		iue->sbuf = ring[i];
-+		iue++;
-+	}
-+	return 0;
-+
-+free_item:
-+	kfree(q->items);
-+free_pool:
-+	kfree(q->pool);
-+	return -ENOMEM;
-+}
-+
-+static void srp_iu_pool_free(struct srp_queue *q)
-+{
-+	kfree(q->items);
-+	kfree(q->pool);
-+}
-+
-+static struct srp_buf **srp_ring_alloc(struct device *dev,
-+				       size_t max, size_t size)
-+{
-+	int i;
-+	struct srp_buf **ring;
-+
-+	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
-+	if (!ring)
-+		return NULL;
-+
-+	for (i = 0; i < max; i++) {
-+		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
-+		if (!ring[i])
-+			goto out;
-+		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
-+						  GFP_KERNEL);
-+		if (!ring[i]->buf)
-+			goto out;
-+	}
-+	return ring;
-+
-+out:
-+	for (i = 0; i < max && ring[i]; i++) {
-+		if (ring[i]->buf)
-+			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+	kfree(ring);
-+
-+	return NULL;
-+}
-+
-+static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
-+			  size_t size)
-+{
-+	int i;
-+
-+	for (i = 0; i < max; i++) {
-+		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+}
-+
-+int srp_target_alloc(struct srp_target *target, struct device *dev,
-+		     size_t nr, size_t iu_size)
-+{
-+	int err;
-+
-+	spin_lock_init(&target->lock);
-+	INIT_LIST_HEAD(&target->cmd_queue);
-+
-+	target->dev = dev;
-+	target->dev->driver_data = target;
-+
-+	target->srp_iu_size = iu_size;
-+	target->rx_ring_size = nr;
-+	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
-+	if (!target->rx_ring)
-+		return -ENOMEM;
-+	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
-+	if (err)
-+		goto free_ring;
-+
-+	return 0;
-+
-+free_ring:
-+	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
-+	return -ENOMEM;
-+}
-+EXPORT_SYMBOL_GPL(srp_target_alloc);
-+
-+void srp_target_free(struct srp_target *target)
-+{
-+	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
-+		      target->srp_iu_size);
-+	srp_iu_pool_free(&target->iu_queue);
-+}
-+EXPORT_SYMBOL_GPL(srp_target_free);
-+
-+struct iu_entry *srp_iu_get(struct srp_target *target)
-+{
-+	struct iu_entry *iue = NULL;
-+
-+	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+	BUG_ON(!iue);
-+
-+	iue->target = target;
-+	INIT_LIST_HEAD(&iue->ilist);
-+	iue->flags = 0;
-+	return iue;
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_get);
-+
-+void srp_iu_put(struct iu_entry *iue)
-+{
-+	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_put);
-+
-+static int srp_direct_data(struct scsi_cmnd *sc, struct srp_direct_buf *md,
-+			   enum dma_data_direction dir, srp_rdma_t rdma_io,
-+			   int dma_map, int ext_desc)
-+{
-+	struct iu_entry *iue = NULL;
-+	struct scatterlist *sg = NULL;
-+	int err, nsg = 0, len;
-+
-+	if (dma_map) {
-+		iue = (struct iu_entry *) sc->SCp.ptr;
-+		sg = sc->request_buffer;
-+
-+		dprintk("%p %u %u %d\n", iue, sc->request_bufflen,
-+			md->len, sc->use_sg);
-+
-+		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg,
-+				 DMA_BIDIRECTIONAL);
-+		if (!nsg) {
-+			printk("fail to map %p %d\n", iue, sc->use_sg);
-+			return 0;
-+		}
-+		len = min(sc->request_bufflen, md->len);
-+	} else
-+		len = md->len;
-+
-+	err = rdma_io(sc, sg, nsg, md, 1, dir, len);
-+
-+	if (dma_map)
-+		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+	return err;
-+}
-+
-+static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
-+			     struct srp_indirect_buf *id,
-+			     enum dma_data_direction dir, srp_rdma_t rdma_io,
-+			     int dma_map, int ext_desc)
-+{
-+	struct iu_entry *iue = NULL;
-+	struct srp_direct_buf *md = NULL;
-+	struct scatterlist dummy, *sg = NULL;
-+	dma_addr_t token = 0;
-+	long err;
-+	unsigned int done = 0;
-+	int nmd, nsg = 0, len;
-+
-+	if (dma_map || ext_desc) {
-+		iue = (struct iu_entry *) sc->SCp.ptr;
-+		sg = sc->request_buffer;
-+
-+		dprintk("%p %u %u %d %d\n",
-+			iue, sc->request_bufflen, id->len,
-+			cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
-+	}
-+
-+	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
-+
-+	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
-+	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
-+		md = &id->desc_list[0];
-+		goto rdma;
-+	}
-+
-+	if (ext_desc && dma_map) {
-+		md = dma_alloc_coherent(iue->target->dev, id->table_desc.len,
-+				&token, GFP_KERNEL);
-+		if (!md) {
-+			eprintk("Can't get dma memory %u\n", id->table_desc.len);
-+			return -ENOMEM;
-+		}
-+
-+		sg_init_one(&dummy, md, id->table_desc.len);
-+		sg_dma_address(&dummy) = token;
-+		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
-+			      id->table_desc.len);
-+		if (err < 0) {
-+			eprintk("Error copying indirect table %ld\n", err);
-+			goto free_mem;
-+		}
-+	} else {
-+		eprintk("This command uses external indirect buffer\n");
-+		return -EINVAL;
-+	}
-+
-+rdma:
-+	if (dma_map) {
-+		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
-+		if (!nsg) {
-+			eprintk("fail to map %p %d\n", iue, sc->use_sg);
-+			goto free_mem;
-+		}
-+		len = min(sc->request_bufflen, id->len);
-+	} else
-+		len = id->len;
-+
-+	err = rdma_io(sc, sg, nsg, md, nmd, dir, len);
-+
-+	if (dma_map)
-+		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+free_mem:
-+	if (token && dma_map)
-+		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
-+
-+	return done;
-+}
-+
-+static int data_out_desc_size(struct srp_cmd *cmd)
-+{
-+	int size = 0;
-+	u8 fmt = cmd->buf_fmt >> 4;
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		size = sizeof(struct srp_direct_buf);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		size = sizeof(struct srp_indirect_buf) +
-+			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
-+		break;
-+	default:
-+		eprintk("client error. Invalid data_out_format %x\n", fmt);
-+		break;
-+	}
-+	return size;
-+}
-+
-+/*
-+ * TODO: this can be called multiple times for a single command if it
-+ * has very long data.
-+ */
-+int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
-+		      srp_rdma_t rdma_io, int dma_map, int ext_desc)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	enum dma_data_direction dir;
-+	int offset, err = 0;
-+	u8 format;
-+
-+	offset = cmd->add_cdb_len * 4;
-+
-+	dir = srp_cmd_direction(cmd);
-+	if (dir == DMA_FROM_DEVICE)
-+		offset += data_out_desc_size(cmd);
-+
-+	if (dir == DMA_TO_DEVICE)
-+		format = cmd->buf_fmt >> 4;
-+	else
-+		format = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	switch (format) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *)
-+			(cmd->add_data + offset);
-+		err = srp_direct_data(sc, md, dir, rdma_io, dma_map, ext_desc);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *)
-+			(cmd->add_data + offset);
-+		err = srp_indirect_data(sc, cmd, id, dir, rdma_io, dma_map,
-+					ext_desc);
-+		break;
-+	default:
-+		eprintk("Unknown format %d %x\n", dir, format);
-+		break;
-+	}
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(srp_transfer_data);
-+
-+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int len = 0, offset = cmd->add_cdb_len * 4;
-+	u8 fmt;
-+
-+	if (dir == DMA_TO_DEVICE)
-+		fmt = cmd->buf_fmt >> 4;
-+	else {
-+		fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+		offset += data_out_desc_size(cmd);
-+	}
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *) (cmd->add_data + offset);
-+		len = md->len;
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
-+		len = id->len;
-+		break;
-+	default:
-+		eprintk("invalid data format %x\n", fmt);
-+		break;
-+	}
-+	return len;
-+}
-+
-+int srp_cmd_queue(struct Scsi_Host *shost, struct srp_cmd *cmd, void *info,
-+		  u64 addr)
-+{
-+	enum dma_data_direction dir;
-+	struct scsi_cmnd *sc;
-+	int tag, len, err;
-+
-+	switch (cmd->task_attr) {
-+	case SRP_SIMPLE_TASK:
-+		tag = MSG_SIMPLE_TAG;
-+		break;
-+	case SRP_ORDERED_TASK:
-+		tag = MSG_ORDERED_TAG;
-+		break;
-+	case SRP_HEAD_TASK:
-+		tag = MSG_HEAD_TAG;
-+		break;
-+	default:
-+		eprintk("Task attribute %d not supported\n", cmd->task_attr);
-+		tag = MSG_ORDERED_TAG;
-+	}
-+
-+	dir = srp_cmd_direction(cmd);
-+	len = vscsis_data_length(cmd, dir);
-+
-+	dprintk("%p %x %lx %d %d %d %llx\n", info, cmd->cdb[0],
-+		cmd->lun, dir, len, tag, (unsigned long long) cmd->tag);
-+
-+	sc = scsi_host_get_command(shost, dir, GFP_KERNEL);
-+	if (!sc)
-+		return -ENOMEM;
-+
-+	sc->SCp.ptr = info;
-+	memcpy(sc->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
-+	sc->request_bufflen = len;
-+	sc->request_buffer = (void *) (unsigned long) addr;
-+	sc->tag = tag;
-+	err = scsi_tgt_queue_command(sc, (struct scsi_lun *) &cmd->lun, cmd->tag);
-+	if (err)
-+		scsi_host_put_command(shost, sc);
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(srp_cmd_queue);
-+
-+MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
-+MODULE_AUTHOR("FUJITA Tomonori");
-+MODULE_LICENSE("GPL");
-diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
-new file mode 100644
-index 0000000..8ec13b9
---- /dev/null
-+++ b/include/scsi/libsrp.h
-@@ -0,0 +1,79 @@
-+#ifndef __LIBSRP_H__
-+#define __LIBSRP_H__
-+
-+#include <linux/list.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/srp.h>
-+
-+enum iue_flags {
-+	V_DIOVER,
-+	V_WRITE,
-+	V_LINKED,
-+	V_FLYING,
-+};
-+
-+struct srp_buf {
-+	dma_addr_t dma;
-+	void *buf;
-+};
-+
-+struct srp_queue {
-+	void *pool;
-+	void *items;
-+	struct kfifo *queue;
-+	spinlock_t lock;
-+};
-+
-+struct srp_target {
-+	struct Scsi_Host *shost;
-+	struct device *dev;
-+
-+	spinlock_t lock;
-+	struct list_head cmd_queue;
-+
-+	size_t srp_iu_size;
-+	struct srp_queue iu_queue;
-+	size_t rx_ring_size;
-+	struct srp_buf **rx_ring;
-+
-+	/* IB needs tx_ring too */
-+
-+	void *ldata;
-+};
-+
-+struct iu_entry {
-+	struct srp_target *target;
-+
-+	struct list_head ilist;
-+	dma_addr_t remote_token;
-+	unsigned long flags;
-+
-+	struct srp_buf *sbuf;
-+};
-+
-+typedef int (srp_rdma_t)(struct scsi_cmnd *, struct scatterlist *, int,
-+			 struct srp_direct_buf *, int,
-+			 enum dma_data_direction, unsigned int);
-+extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
-+extern void srp_target_free(struct srp_target *);
-+
-+extern struct iu_entry *srp_iu_get(struct srp_target *);
-+extern void srp_iu_put(struct iu_entry *);
-+
-+extern int srp_cmd_queue(struct Scsi_Host *, struct srp_cmd *, void *, u64);
-+extern int srp_transfer_data(struct scsi_cmnd *, struct srp_cmd *,
-+			     srp_rdma_t, int, int);
-+
-+
-+static inline struct srp_target *host_to_srp_target(struct Scsi_Host *host)
-+{
-+	return (struct srp_target *) host->hostdata;
-+}
-+
-+static inline int srp_cmd_direction(struct srp_cmd *cmd)
-+{
-+	return (cmd->buf_fmt >> 4) ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-+}
-+
-+#endif
--- 
-1.4.1
-

Deleted: trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
===================================================================
--- trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,1028 +0,0 @@
-From eed708a465130a096f3ce2892198ed77ef2504b8 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:41:02 +0900
-Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries virtual SCSI target driver
-
-This is IBM Virtual SCSI target driver for tgt. The driver is based on
-the original ibmvscsis driver:
-
-http://lkml.org/lkml/2005/10/17/99
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig             |   14 +
- drivers/scsi/Makefile            |    1 
- drivers/scsi/ibmvscsi/Makefile   |    2 
- drivers/scsi/ibmvscsi/ibmvstgt.c |  952 ++++++++++++++++++++++++++++++++++++++
- 4 files changed, 969 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index e5098d3..c25154c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
- 	  To compile this driver as a module, choose M here: the
- 	  module will be called ibmvscsic.
- 
-+config SCSI_IBMVSCSIS
-+	tristate "IBM Virtual SCSI Server support"
-+	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
-+	help
-+	  This is the SRP target driver for IBM pSeries virtual environments.
-+
-+	  The userspace component needed to initialize the driver and
-+	  documentation can be found:
-+
-+	  http://stgt.berlios.de/
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called ibmvstgt.
-+
- config SCSI_INITIO
- 	tristate "Initio 9100U(W) support"
- 	depends on PCI && SCSI
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index d71bb59..78544e3 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
- obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
- obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
-diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
-index 4e247b6..6ac0633 100644
---- a/drivers/scsi/ibmvscsi/Makefile
-+++ b/drivers/scsi/ibmvscsi/Makefile
-@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
- ibmvscsic-y			+= ibmvscsi.o
- ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
- ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
-+
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
-diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
-new file mode 100644
-index 0000000..7a98517
---- /dev/null
-+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
-@@ -0,0 +1,952 @@
-+/*
-+ * IBM eServer i/pSeries Virtual SCSI Target Driver
-+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
-+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
-+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
-+ *
-+ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-+ * USA
-+ */
-+#include <linux/interrupt.h>
-+#include <linux/module.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/libsrp.h>
-+#include <asm/hvcall.h>
-+#include <asm/iommu.h>
-+#include <asm/prom.h>
-+#include <asm/vio.h>
-+
-+#include "ibmvscsi.h"
-+
-+#define	INITIAL_SRP_LIMIT	16
-+#define	DEFAULT_MAX_SECTORS	512
-+
-+#define	TGT_NAME	"ibmvstgt"
-+
-+/*
-+ * Hypervisor calls.
-+ */
-+#define h_copy_rdma(l, sa, sb, da, db) \
-+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
-+#define h_send_crq(ua, l, h) \
-+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
-+#define h_reg_crq(ua, tok, sz)\
-+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
-+#define h_free_crq(ua) \
-+			plpar_hcall_norets(H_FREE_CRQ, ua);
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+struct vio_port {
-+	struct vio_dev *dma_dev;
-+
-+	struct crq_queue crq_queue;
-+	struct work_struct crq_work;
-+
-+	unsigned long liobn;
-+	unsigned long riobn;
-+};
-+
-+static struct workqueue_struct *vtgtd;
-+
-+/*
-+ * These are fixed for the system and come from the Open Firmware device tree.
-+ * We just store them here to save getting them every time.
-+ */
-+static char system_id[64] = "";
-+static char partition_name[97] = "UNKNOWN";
-+static unsigned int partition_number = -1;
-+
-+static struct vio_port *target_to_port(struct srp_target *target)
-+{
-+	return (struct vio_port *) target->ldata;
-+}
-+
-+static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
-+{
-+	return (union viosrp_iu *) (iue->sbuf->buf);
-+}
-+
-+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	long rc, rc1;
-+	union {
-+		struct viosrp_crq cooked;
-+		uint64_t raw[2];
-+	} crq;
-+
-+	/* First copy the SRP */
-+	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
-+			 vport->riobn, iue->remote_token);
-+
-+	if (rc)
-+		eprintk("Error %ld transferring data\n", rc);
-+
-+	crq.cooked.valid = 0x80;
-+	crq.cooked.format = format;
-+	crq.cooked.reserved = 0x00;
-+	crq.cooked.timeout = 0x00;
-+	crq.cooked.IU_length = length;
-+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
-+
-+	if (rc == 0)
-+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
-+	else
-+		crq.cooked.status = 0x00;
-+
-+	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
-+
-+	if (rc1) {
-+		eprintk("%ld sending response\n", rc1);
-+		return rc1;
-+	}
-+
-+	return rc;
-+}
-+
-+#define SRP_RSP_SENSE_DATA_LEN	18
-+
-+static int send_rsp(struct iu_entry *iue, struct scsi_cmnd *sc,
-+		    unsigned char status, unsigned char asc)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* If the linked bit is on and status is good */
-+	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
-+		status = 0x10;
-+
-+	memset(iu, 0, sizeof(struct srp_rsp));
-+	iu->srp.rsp.opcode = SRP_RSP;
-+	iu->srp.rsp.req_lim_delta = 1;
-+	iu->srp.rsp.tag = tag;
-+
-+	if (test_bit(V_DIOVER, &iue->flags))
-+		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
-+
-+	iu->srp.rsp.data_in_res_cnt = 0;
-+	iu->srp.rsp.data_out_res_cnt = 0;
-+
-+	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
-+
-+	iu->srp.rsp.resp_data_len = 0;
-+	iu->srp.rsp.status = status;
-+	if (status) {
-+		uint8_t *sense = iu->srp.rsp.data;
-+
-+		if (sc) {
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
-+			memcpy(sense, sc->sense_buffer, SCSI_SENSE_BUFFERSIZE);
-+		} else {
-+			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
-+
-+			/* Valid bit and 'current errors' */
-+			sense[0] = (0x1 << 7 | 0x70);
-+			/* Sense key */
-+			sense[2] = status;
-+			/* Additional sense length */
-+			sense[7] = 0xa;	/* 10 bytes */
-+			/* Additional sense code */
-+			sense[12] = asc;
-+		}
-+	}
-+
-+	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
-+		VIOSRP_SRP_FORMAT);
-+
-+	return 0;
-+}
-+
-+static void handle_cmd_queue(struct srp_target *target)
-+{
-+	struct Scsi_Host *shost = target->shost;
-+	struct iu_entry *iue;
-+	struct srp_cmd *cmd;
-+	unsigned long flags;
-+	int err;
-+
-+retry:
-+	spin_lock_irqsave(&target->lock, flags);
-+
-+	list_for_each_entry(iue, &target->cmd_queue, ilist) {
-+		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
-+			spin_unlock_irqrestore(&target->lock, flags);
-+			cmd = iue->sbuf->buf;
-+			err = srp_cmd_queue(shost, cmd, iue, 0);
-+			if (err) {
-+				eprintk("cannot queue cmd %p %d\n", cmd, err);
-+				srp_iu_put(iue);
-+			}
-+			goto retry;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
-+			 struct srp_direct_buf *md, int nmd,
-+			 enum dma_data_direction dir, unsigned int rest)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	dma_addr_t token;
-+	long err;
-+	unsigned int done = 0;
-+	int i, sidx, soff;
-+
-+	sidx = soff = 0;
-+	token = sg_dma_address(sg + sidx);
-+
-+	for (i = 0; i < nmd && rest; i++) {
-+		unsigned int mdone, mlen;
-+
-+		mlen = min(rest, md[i].len);
-+		for (mdone = 0; mlen;) {
-+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
-+
-+			if (dir == DMA_TO_DEVICE)
-+				err = h_copy_rdma(slen,
-+						  vport->riobn,
-+						  md[i].va + mdone,
-+						  vport->liobn,
-+						  token + soff);
-+			else
-+				err = h_copy_rdma(slen,
-+						  vport->liobn,
-+						  token + soff,
-+						  vport->riobn,
-+						  md[i].va + mdone);
-+
-+			if (err != H_SUCCESS) {
-+				eprintk("rdma error %d %d\n", dir, slen);
-+				goto out;
-+			}
-+
-+			mlen -= slen;
-+			mdone += slen;
-+			soff += slen;
-+			done += slen;
-+
-+			if (soff == sg_dma_len(sg + sidx)) {
-+				sidx++;
-+				soff = 0;
-+				token = sg_dma_address(sg + sidx);
-+
-+				if (sidx > nsg) {
-+					eprintk("out of sg %p %d %d\n",
-+						iue, sidx, nsg);
-+					goto out;
-+				}
-+			}
-+		};
-+
-+		rest -= mlen;
-+	}
-+out:
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_transfer_data(struct scsi_cmnd *sc,
-+				  void (*done)(struct scsi_cmnd *))
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) sc->SCp.ptr;
-+	int err;
-+
-+	err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
-+
-+	done(sc);
-+
-+	return err;
-+}
-+
-+static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
-+			     void (*done)(struct scsi_cmnd *))
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	if (sc->result != SAM_STAT_GOOD) {
-+		eprintk("operation failed %p %d %x\n",
-+			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
-+		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
-+	} else
-+		send_rsp(iue, sc, NO_SENSE, 0x00);
-+
-+	done(sc);
-+	srp_iu_put(iue);
-+	return 0;
-+}
-+
-+int send_adapter_info(struct iu_entry *iue,
-+		      dma_addr_t remote_buffer, uint16_t length)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	struct Scsi_Host *shost = target->shost;
-+	dma_addr_t data_token;
-+	struct mad_adapter_info_data *info;
-+	int err;
-+
-+	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
-+				  GFP_KERNEL);
-+	if (!info) {
-+		eprintk("bad dma_alloc_coherent %p\n", target);
-+		return 1;
-+	}
-+
-+	/* Get remote info */
-+	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
-+			  vport->liobn, data_token);
-+	if (err == H_SUCCESS) {
-+		dprintk("Client connect: %s (%d)\n",
-+			info->partition_name, info->partition_number);
-+	}
-+
-+	memset(info, 0, sizeof(*info));
-+
-+	strcpy(info->srp_version, "16.a");
-+	strncpy(info->partition_name, partition_name,
-+		sizeof(info->partition_name));
-+	info->partition_number = partition_number;
-+	info->mad_version = 1;
-+	info->os_type = 2;
-+	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
-+
-+	/* Send our info to remote */
-+	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
-+			  vport->riobn, remote_buffer);
-+
-+	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
-+
-+	if (err != H_SUCCESS) {
-+		eprintk("Error sending adapter info %d\n", err);
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static void process_login(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* TODO handle case that requested size is wrong and
-+	 * buffer format is wrong
-+	 */
-+	memset(iu, 0, sizeof(struct srp_login_rsp));
-+	rsp->opcode = SRP_LOGIN_RSP;
-+	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
-+	rsp->tag = tag;
-+	rsp->max_it_iu_len = sizeof(union srp_iu);
-+	rsp->max_ti_iu_len = sizeof(union srp_iu);
-+	/* direct and indirect */
-+	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
-+
-+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
-+}
-+
-+static inline void queue_cmd(struct iu_entry *iue)
-+{
-+	struct srp_target *target = iue->target;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_add_tail(&iue->ilist, &target->cmd_queue);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int process_tsk_mgmt(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int fn;
-+
-+	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		fn = ABORT_TASK;
-+		break;
-+	case SRP_TSK_ABORT_TASK_SET:
-+		fn = ABORT_TASK_SET;
-+		break;
-+	case SRP_TSK_CLEAR_TASK_SET:
-+		fn = CLEAR_TASK_SET;
-+		break;
-+	case SRP_TSK_LUN_RESET:
-+		fn = LOGICAL_UNIT_RESET;
-+		break;
-+	case SRP_TSK_CLEAR_ACA:
-+		fn = CLEAR_ACA;
-+		break;
-+	default:
-+		fn = 0;
-+	}
-+	if (fn)
-+		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
-+					  iu->srp.tsk_mgmt.task_tag,
-+					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
-+					  iue);
-+	else
-+		send_rsp(iue, NULL, ILLEGAL_REQUEST, 0x20);
-+
-+	return !fn;
-+}
-+
-+static int process_mad_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct viosrp_adapter_info *info;
-+	struct viosrp_host_config *conf;
-+
-+	switch (iu->mad.empty_iu.common.type) {
-+	case VIOSRP_EMPTY_IU_TYPE:
-+		eprintk("%s\n", "Unsupported EMPTY MAD IU");
-+		break;
-+	case VIOSRP_ERROR_LOG_TYPE:
-+		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
-+		iu->mad.error_log.common.status = 1;
-+		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_ADAPTER_INFO_TYPE:
-+		info = &iu->mad.adapter_info;
-+		info->common.status = send_adapter_info(iue, info->buffer,
-+							info->common.length);
-+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_HOST_CONFIG_TYPE:
-+		conf = &iu->mad.host_config;
-+		conf->common.status = 1;
-+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
-+	}
-+
-+	return 1;
-+}
-+
-+static int process_srp_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int done = 1;
-+	u8 opcode = iu->srp.rsp.opcode;
-+
-+	switch (opcode) {
-+	case SRP_LOGIN_REQ:
-+		process_login(iue);
-+		break;
-+	case SRP_TSK_MGMT:
-+		done = process_tsk_mgmt(iue);
-+		break;
-+	case SRP_CMD:
-+		queue_cmd(iue);
-+		done = 0;
-+		break;
-+	case SRP_LOGIN_RSP:
-+	case SRP_I_LOGOUT:
-+	case SRP_T_LOGOUT:
-+	case SRP_RSP:
-+	case SRP_CRED_REQ:
-+	case SRP_CRED_RSP:
-+	case SRP_AER_REQ:
-+	case SRP_AER_RSP:
-+		eprintk("Unsupported type %u\n", opcode);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", opcode);
-+	}
-+
-+	return done;
-+}
-+
-+static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct iu_entry *iue;
-+	long err, done;
-+
-+	iue = srp_iu_get(target);
-+	if (!iue) {
-+		eprintk("Error getting IU from pool, %p\n", target);
-+		return;
-+	}
-+
-+	iue->remote_token = crq->IU_data_ptr;
-+
-+	err = h_copy_rdma(crq->IU_length, vport->riobn,
-+			  iue->remote_token, vport->liobn, iue->sbuf->dma);
-+
-+	if (err != H_SUCCESS)
-+		eprintk("%ld transferring data error %p\n", err, iue);
-+
-+	if (crq->format == VIOSRP_MAD_FORMAT)
-+		done = process_mad_iu(iue);
-+	else
-+		done = process_srp_iu(iue);
-+
-+	if (done)
-+		srp_iu_put(iue);
-+}
-+
-+static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	vio_disable_interrupts(vport->dma_dev);
-+	queue_work(vtgtd, &vport->crq_work);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
-+{
-+	int err;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
-+	if (!queue->msgs)
-+		goto malloc_failed;
-+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
-+
-+	queue->msg_token = dma_map_single(target->dev, queue->msgs,
-+					  queue->size * sizeof(*queue->msgs),
-+					  DMA_BIDIRECTIONAL);
-+
-+	if (dma_mapping_error(queue->msg_token))
-+		goto map_failed;
-+
-+	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			PAGE_SIZE);
-+
-+	/* If the adapter was left active for some reason (like kexec)
-+	 * try freeing and re-registering
-+	 */
-+	if (err == H_RESOURCE) {
-+	    do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			    PAGE_SIZE);
-+	}
-+
-+	if (err != H_SUCCESS && err != 2) {
-+		eprintk("Error 0x%x opening virtual adapter\n", err);
-+		goto reg_crq_failed;
-+	}
-+
-+	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
-+			  SA_INTERRUPT, "ibmvstgt", target);
-+	if (err)
-+		goto req_irq_failed;
-+
-+	vio_enable_interrupts(vport->dma_dev);
-+
-+	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
-+
-+	queue->cur = 0;
-+	spin_lock_init(&queue->lock);
-+
-+	return 0;
-+
-+req_irq_failed:
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+reg_crq_failed:
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+map_failed:
-+	free_page((unsigned long) queue->msgs);
-+
-+malloc_failed:
-+	return -ENOMEM;
-+}
-+
-+static void crq_queue_destroy(struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct crq_queue *queue = &vport->crq_queue;
-+	int err;
-+
-+	free_irq(vport->dma_dev->irq, target);
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+
-+	free_page((unsigned long) queue->msgs);
-+}
-+
-+static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	dprintk("%x %x\n", crq->valid, crq->format);
-+
-+	switch (crq->valid) {
-+	case 0xC0:
-+		/* initialization */
-+		switch (crq->format) {
-+		case 0x01:
-+			h_send_crq(vport->dma_dev->unit_address,
-+				   0xC002000000000000, 0);
-+			break;
-+		case 0x02:
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	case 0xFF:
-+		/* transport event */
-+		break;
-+	case 0x80:
-+		/* real payload */
-+		switch (crq->format) {
-+		case VIOSRP_SRP_FORMAT:
-+		case VIOSRP_MAD_FORMAT:
-+			process_iu(crq, target);
-+			break;
-+		case VIOSRP_OS400_FORMAT:
-+		case VIOSRP_AIX_FORMAT:
-+		case VIOSRP_LINUX_FORMAT:
-+		case VIOSRP_INLINE_FORMAT:
-+			eprintk("Unsupported format %u\n", crq->format);
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	default:
-+		eprintk("unknown message type 0x%02x!?\n", crq->valid);
-+	}
-+}
-+
-+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
-+{
-+	struct viosrp_crq *crq;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&queue->lock, flags);
-+	crq = &queue->msgs[queue->cur];
-+	if (crq->valid & 0x80) {
-+		if (++queue->cur == queue->size)
-+			queue->cur = 0;
-+	} else
-+		crq = NULL;
-+	spin_unlock_irqrestore(&queue->lock, flags);
-+
-+	return crq;
-+}
-+
-+static void handle_crq(void *data)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+	struct viosrp_crq *crq;
-+	int done = 0;
-+
-+	while (!done) {
-+		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		}
-+
-+		vio_enable_interrupts(vport->dma_dev);
-+
-+		crq = next_crq(&vport->crq_queue);
-+		if (crq) {
-+			vio_disable_interrupts(vport->dma_dev);
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		} else
-+			done = 1;
-+	}
-+
-+	handle_cmd_queue(target);
-+}
-+
-+
-+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *sc)
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
-+	union viosrp_iu *iu = vio_iu(iue);
-+	unsigned char status, asc;
-+
-+	eprintk("%p %d\n", iue, result);
-+	status = NO_SENSE;
-+	asc = 0;
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		asc = 0x14;
-+		if (result)
-+			status = ABORTED_COMMAND;
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	send_rsp(iue, NULL, status, asc);
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static ssize_t system_id_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
-+}
-+
-+static ssize_t partition_number_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
-+}
-+
-+static ssize_t unit_address_show(struct class_device *cdev, char *buf)
-+{
-+	struct Scsi_Host *shost = class_to_shost(cdev);
-+	struct srp_target *target = host_to_srp_target(shost);
-+	struct vio_port *vport = target_to_port(target);
-+	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
-+}
-+
-+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
-+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
-+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
-+
-+static struct class_device_attribute *ibmvstgt_attrs[] = {
-+	&class_device_attr_system_id,
-+	&class_device_attr_partition_number,
-+	&class_device_attr_unit_address,
-+	NULL,
-+};
-+
-+static struct scsi_host_template ibmvstgt_sht = {
-+	.name			= TGT_NAME,
-+	.module			= THIS_MODULE,
-+	.can_queue		= INITIAL_SRP_LIMIT,
-+	.sg_tablesize		= SG_ALL,
-+	.use_clustering		= DISABLE_CLUSTERING,
-+	.max_sectors		= DEFAULT_MAX_SECTORS,
-+	.transfer_response	= ibmvstgt_cmd_done,
-+	.transfer_data		= ibmvstgt_transfer_data,
-+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
-+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
-+	.shost_attrs		= ibmvstgt_attrs,
-+	.proc_name		= TGT_NAME,
-+};
-+
-+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
-+{
-+	struct Scsi_Host *shost;
-+	struct srp_target *target;
-+	struct vio_port *vport;
-+	unsigned int *dma, dma_size;
-+	int err = -ENOMEM;
-+
-+	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
-+	if (!vport)
-+		return err;
-+	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
-+	if (!shost)
-+		goto free_vport;
-+	err = scsi_tgt_alloc_queue(shost);
-+	if (err)
-+		goto put_host;
-+
-+	target = host_to_srp_target(shost);
-+	target->shost = shost;
-+	vport->dma_dev = dev;
-+	target->ldata = vport;
-+	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
-+			       SRP_MAX_IU_LEN);
-+	if (err)
-+		goto put_host;
-+
-+	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
-+						 &dma_size);
-+	if (!dma || dma_size != 40) {
-+		eprintk("Couldn't get window property %d\n", dma_size);
-+		err = -EIO;
-+		goto free_srp_target;
-+	}
-+	vport->liobn = dma[0];
-+	vport->riobn = dma[5];
-+
-+	INIT_WORK(&vport->crq_work, handle_crq, target);
-+
-+	err = crq_queue_create(&vport->crq_queue, target);
-+	if (err)
-+		goto free_srp_target;
-+
-+	err = scsi_add_host(shost, target->dev);
-+	if (err)
-+		goto destroy_queue;
-+	return 0;
-+
-+destroy_queue:
-+	crq_queue_destroy(target);
-+free_srp_target:
-+	srp_target_free(target);
-+put_host:
-+	scsi_host_put(shost);
-+free_vport:
-+	kfree(vport);
-+	return err;
-+}
-+
-+static int ibmvstgt_remove(struct vio_dev *dev)
-+{
-+	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
-+	struct Scsi_Host *shost = target->shost;
-+
-+	srp_target_free(target);
-+	crq_queue_destroy(target);
-+	scsi_remove_host(shost);
-+	scsi_host_put(shost);
-+	return 0;
-+}
-+
-+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
-+	{"v-scsi-host", "IBM,v-scsi-host"},
-+	{"",""}
-+};
-+
-+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
-+
-+static struct vio_driver ibmvstgt_driver = {
-+	.id_table = ibmvstgt_device_table,
-+	.probe = ibmvstgt_probe,
-+	.remove = ibmvstgt_remove,
-+	.driver = {
-+		.name = "ibmvscsis",
-+		.owner = THIS_MODULE,
-+	}
-+};
-+
-+static int get_system_info(void)
-+{
-+	struct device_node *rootdn;
-+	char *id, *model, *name;
-+	unsigned int *num;
-+
-+	rootdn = find_path_device("/");
-+	if (!rootdn)
-+		return -ENOENT;
-+
-+	model = get_property(rootdn, "model", NULL);
-+	id = get_property(rootdn, "system-id", NULL);
-+	if (model && id)
-+		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
-+
-+	name = get_property(rootdn, "ibm,partition-name", NULL);
-+	if (name)
-+		strncpy(partition_name, name, sizeof(partition_name));
-+
-+	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
-+	if (num)
-+		partition_number = *num;
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_init(void)
-+{
-+	int err = -ENOMEM;
-+
-+	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
-+
-+	vtgtd = create_workqueue("ibmvtgtd");
-+	if (!vtgtd)
-+		return err;
-+
-+	err = get_system_info();
-+	if (err)
-+		goto destroy_wq;
-+
-+	err = vio_register_driver(&ibmvstgt_driver);
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(vtgtd);
-+	return err;
-+}
-+
-+static void ibmvstgt_exit(void)
-+{
-+	printk("Unregister IBM virtual SCSI driver\n");
-+
-+	destroy_workqueue(vtgtd);
-+	vio_unregister_driver(&ibmvstgt_driver);
-+}
-+
-+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
-+MODULE_AUTHOR("Dave Boutcher");
-+MODULE_LICENSE("GPL");
-+
-+module_init(ibmvstgt_init);
-+module_exit(ibmvstgt_exit);
--- 
-1.4.1
-

Deleted: trunk/patchset/README
===================================================================
--- trunk/patchset/README	2006-08-31 12:31:13 UTC (rev 570)
+++ trunk/patchset/README	2006-08-31 12:48:02 UTC (rev 571)
@@ -1,6 +0,0 @@
-This patchset for scsi-rc-fixes git tree:
-
-http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-rc-fixes-2.6.git;a=summary
-
-Get the tree and apply all the patches. Sorry for the
-inconvenience. We will create our own git tree shortly.



From tomo at mail.berlios.de  Thu Aug 31 14:51:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:51:18 +0200
Subject: [Stgt-svn] r572 - trunk
Message-ID: <200608311251.k7VCpIuZ022725@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:51:17 +0200 (Thu, 31 Aug 2006)
New Revision: 572

Added:
   trunk/patch/
Removed:
   trunk/patchset/
Log:
Just rename patchset dir.

Copied: trunk/patch (from rev 569, trunk/patchset)



From tomo at mail.berlios.de  Thu Aug 31 14:51:51 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:51:51 +0200
Subject: [Stgt-svn] r573 - trunk/patch
Message-ID: <200608311251.k7VCpphp023163@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:51:50 +0200 (Thu, 31 Aug 2006)
New Revision: 573

Added:
   trunk/patch/aiopoll-2.6.16.13.diff
   trunk/patch/aiopoll-2.6.18-rc4.diff
Log:
Add aio patches for iSCSI driver.

Added: trunk/patch/aiopoll-2.6.16.13.diff
===================================================================
--- trunk/patch/aiopoll-2.6.16.13.diff	2006-08-31 12:51:17 UTC (rev 572)
+++ trunk/patch/aiopoll-2.6.16.13.diff	2006-08-31 12:51:50 UTC (rev 573)
@@ -0,0 +1,297 @@
+diff -pruN ../pristine-linux-2.6.16-rc5/fs/aio.c ./fs/aio.c
+--- ../pristine-linux-2.6.16-rc5/fs/aio.c	2006-03-14 14:10:10.827401387 +0000
++++ ./fs/aio.c	2006-03-16 09:57:53.898316582 +0000
+@@ -34,6 +34,11 @@
+ #include <asm/uaccess.h>
+ #include <asm/mmu_context.h>
+ 
++#ifdef CONFIG_EPOLL
++#include <linux/poll.h>
++#include <linux/eventpoll.h>
++#endif
++
+ #if DEBUG > 1
+ #define dprintk		printk
+ #else
+@@ -1016,6 +1021,10 @@ put_rq:
+ 	if (waitqueue_active(&ctx->wait))
+ 		wake_up(&ctx->wait);
+ 
++#ifdef CONFIG_EPOLL
++	if (ctx->file && waitqueue_active(&ctx->poll_wait))
++		wake_up(&ctx->poll_wait);
++#endif
+ 	if (ret)
+ 		put_ioctx(ctx);
+ 
+@@ -1025,6 +1034,8 @@ put_rq:
+ /* aio_read_evt
+  *	Pull an event off of the ioctx's event ring.  Returns the number of 
+  *	events fetched (0 or 1 ;-)
++ *	If ent parameter is 0, just returns the number of events that would
++ *	be fetched.
+  *	FIXME: make this use cmpxchg.
+  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
+  */
+@@ -1047,13 +1058,18 @@ static int aio_read_evt(struct kioctx *i
+ 
+ 	head = ring->head % info->nr;
+ 	if (head != ring->tail) {
+-		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
+-		*ent = *evp;
+-		head = (head + 1) % info->nr;
+-		smp_mb(); /* finish reading the event before updatng the head */
+-		ring->head = head;
+-		ret = 1;
+-		put_aio_ring_event(evp, KM_USER1);
++		if (ent) { /* event requested */
++			struct io_event *evp =
++				aio_ring_event(info, head, KM_USER1);
++			*ent = *evp;
++			head = (head + 1) % info->nr;
++			/* finish reading the event before updatng the head */
++			smp_mb();
++			ring->head = head;
++			ret = 1;
++			put_aio_ring_event(evp, KM_USER1);
++		} else /* only need to know availability */
++			ret = 1;
+ 	}
+ 	spin_unlock(&info->ring_lock);
+ 
+@@ -1236,9 +1252,78 @@ static void io_destroy(struct kioctx *io
+ 
+ 	aio_cancel_all(ioctx);
+ 	wait_for_all_aios(ioctx);
++#ifdef CONFIG_EPOLL
++	/* forget the poll file, but it's up to the user to close it */
++	if (ioctx->file) {
++		ioctx->file->private_data = 0;
++		ioctx->file = 0;
++	}
++#endif
+ 	put_ioctx(ioctx);	/* once for the lookup */
+ }
+ 
++#ifdef CONFIG_EPOLL
++
++static int aio_queue_fd_close(struct inode *inode, struct file *file)
++{
++	struct kioctx *ioctx = file->private_data;
++	if (ioctx) {
++		file->private_data = 0;
++		spin_lock_irq(&ioctx->ctx_lock);
++		ioctx->file = 0;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++	return 0;
++}
++
++static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
++{	unsigned int pollflags = 0;
++	struct kioctx *ioctx = file->private_data;
++
++	if (ioctx) {
++
++		spin_lock_irq(&ioctx->ctx_lock);
++		/* Insert inside our poll wait queue */
++		poll_wait(file, &ioctx->poll_wait, wait);
++
++		/* Check our condition */
++		if (aio_read_evt(ioctx, 0))
++			pollflags = POLLIN | POLLRDNORM;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++
++	return pollflags;
++}
++
++static struct file_operations aioq_fops = {
++	.release	= aio_queue_fd_close,
++	.poll		= aio_queue_fd_poll
++};
++
++/* make_aio_fd:
++ *  Create a file descriptor that can be used to poll the event queue.
++ *  Based and piggybacked on the excellent epoll code.
++ */
++
++static int make_aio_fd(struct kioctx *ioctx)
++{
++	int error, fd;
++	struct inode *inode;
++	struct file *file;
++
++	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
++	if (error)
++		return error;
++
++	/* associate the file with the IO context */
++	file->private_data = ioctx;
++	ioctx->file = file;
++	init_waitqueue_head(&ioctx->poll_wait);
++	return fd;
++}
++#endif
++
++
+ /* sys_io_setup:
+  *	Create an aio_context capable of receiving at least nr_events.
+  *	ctxp must not point to an aio_context that already exists, and
+@@ -1251,18 +1336,30 @@ static void io_destroy(struct kioctx *io
+  *	resources are available.  May fail with -EFAULT if an invalid
+  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
+  *	implemented.
++ *
++ *	To request a selectable fd, the user context has to be initialized
++ *	to 1, instead of 0, and the return value is the fd.
++ *	This keeps the system call compatible, since a non-zero value
++ *	was not allowed so far.
+  */
+ asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
+ {
+ 	struct kioctx *ioctx = NULL;
+ 	unsigned long ctx;
+ 	long ret;
++	int make_fd = 0;
+ 
+ 	ret = get_user(ctx, ctxp);
+ 	if (unlikely(ret))
+ 		goto out;
+ 
+ 	ret = -EINVAL;
++#ifdef CONFIG_EPOLL
++	if (ctx == 1) {
++		make_fd = 1;
++		ctx = 0;
++	}
++#endif
+ 	if (unlikely(ctx || nr_events == 0)) {
+ 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
+ 		         ctx, nr_events);
+@@ -1273,8 +1370,12 @@ asmlinkage long sys_io_setup(unsigned nr
+ 	ret = PTR_ERR(ioctx);
+ 	if (!IS_ERR(ioctx)) {
+ 		ret = put_user(ioctx->user_id, ctxp);
+-		if (!ret)
+-			return 0;
++#ifdef CONFIG_EPOLL
++		if (make_fd && ret >= 0)
++			ret = make_aio_fd(ioctx);
++#endif
++		if (ret >= 0)
++			return ret;
+ 
+ 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
+ 		io_destroy(ioctx);
+
+diff -pruN ../pristine-linux-2.6.16-rc5/fs/eventpoll.c ./fs/eventpoll.c
+--- ../pristine-linux-2.6.16-rc5/fs/eventpoll.c	2006-01-03 03:21:10.000000000 +0000
++++ ./fs/eventpoll.c	2006-03-16 10:04:35.469956167 +0000
+@@ -235,8 +235,6 @@ struct ep_pqueue {
+ 
+ static void ep_poll_safewake_init(struct poll_safewake *psw);
+ static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep);
+ static int ep_alloc(struct eventpoll **pep);
+ static void ep_free(struct eventpoll *ep);
+ static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
+@@ -266,7 +264,7 @@ static int ep_events_transfer(struct eve
+ static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
+ 		   int maxevents, long timeout);
+ static int eventpollfs_delete_dentry(struct dentry *dentry);
+-static struct inode *ep_eventpoll_inode(void);
++static struct inode *ep_eventpoll_inode(struct file_operations *fops);
+ static struct super_block *eventpollfs_get_sb(struct file_system_type *fs_type,
+ 					      int flags, const char *dev_name,
+ 					      void *data);
+@@ -525,7 +523,7 @@ asmlinkage long sys_epoll_create(int siz
+ 	 * Creates all the items needed to setup an eventpoll file. That is,
+ 	 * a file structure, and inode and a free file descriptor.
+ 	 */
+-	error = ep_getfd(&fd, &inode, &file, ep);
++	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
+ 	if (error)
+ 		goto eexit_2;
+ 
+@@ -710,8 +708,8 @@ eexit_1:
+ /*
+  * Creates the file descriptor to be used by the epoll interface.
+  */
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep)
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++		    struct eventpoll *ep, struct file_operations *fops)
+ {
+ 	struct qstr this;
+ 	char name[32];
+@@ -727,7 +725,7 @@ static int ep_getfd(int *efd, struct ino
+ 		goto eexit_1;
+ 
+ 	/* Allocates an inode from the eventpoll file system */
+-	inode = ep_eventpoll_inode();
++	inode = ep_eventpoll_inode(fops);
+ 	error = PTR_ERR(inode);
+ 	if (IS_ERR(inode))
+ 		goto eexit_2;
+@@ -758,7 +756,7 @@ static int ep_getfd(int *efd, struct ino
+ 
+ 	file->f_pos = 0;
+ 	file->f_flags = O_RDONLY;
+-	file->f_op = &eventpoll_fops;
++	file->f_op = fops;
+ 	file->f_mode = FMODE_READ;
+ 	file->f_version = 0;
+ 	file->private_data = ep;
+@@ -1574,7 +1572,7 @@ static int eventpollfs_delete_dentry(str
+ }
+ 
+ 
+-static struct inode *ep_eventpoll_inode(void)
++static struct inode *ep_eventpoll_inode(struct file_operations *fops)
+ {
+ 	int error = -ENOMEM;
+ 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
+@@ -1582,7 +1580,7 @@ static struct inode *ep_eventpoll_inode(
+ 	if (!inode)
+ 		goto eexit_1;
+ 
+-	inode->i_fop = &eventpoll_fops;
++	inode->i_fop = fops;
+ 
+ 	/*
+ 	 * Mark the inode dirty from the very beginning,
+
+diff -pruN ../pristine-linux-2.6.16-rc5/include/linux/aio.h ./include/linux/aio.h
+--- ../pristine-linux-2.6.16-rc5/include/linux/aio.h	2006-03-14 14:10:21.597916731 +0000
++++ ./include/linux/aio.h	2006-03-16 10:05:39.848833028 +0000
+@@ -191,6 +191,11 @@ struct kioctx {
+ 	struct aio_ring_info	ring_info;
+ 
+ 	struct work_struct	wq;
++#ifdef CONFIG_EPOLL
++	// poll integration
++	wait_queue_head_t       poll_wait;
++	struct file		*file;
++#endif
+ };
+ 
+ /* prototypes */
+
+diff -pruN ../pristine-linux-2.6.16-rc5/include/linux/eventpoll.h ./include/linux/eventpoll.h
+--- ../pristine-linux-2.6.16-rc5/include/linux/eventpoll.h	2006-01-03 03:21:10.000000000 +0000
++++ ./include/linux/eventpoll.h	2006-03-16 10:08:51.577809317 +0000
+@@ -86,6 +86,12 @@ static inline void eventpoll_release(str
+ }
+ 
+ 
++/*
++ * called by aio code to create fd that can poll the  aio event queueQ
++ */
++struct eventpoll;
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++             struct eventpoll *ep, struct file_operations *fops);
+ #else
+ 
+ static inline void eventpoll_init_file(struct file *file) {}

Added: trunk/patch/aiopoll-2.6.18-rc4.diff
===================================================================
--- trunk/patch/aiopoll-2.6.18-rc4.diff	2006-08-31 12:51:17 UTC (rev 572)
+++ trunk/patch/aiopoll-2.6.18-rc4.diff	2006-08-31 12:51:50 UTC (rev 573)
@@ -0,0 +1,298 @@
+diff --git a/fs/aio.c b/fs/aio.c
+index 9506301..99c5eba 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -34,6 +34,11 @@ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+ #include <asm/mmu_context.h>
+ 
++#ifdef CONFIG_EPOLL
++#include <linux/poll.h>
++#include <linux/eventpoll.h>
++#endif
++
+ #if DEBUG > 1
+ #define dprintk		printk
+ #else
+@@ -1015,6 +1020,10 @@ put_rq:
+ 	if (waitqueue_active(&ctx->wait))
+ 		wake_up(&ctx->wait);
+ 
++#ifdef CONFIG_EPOLL
++	if (ctx->file && waitqueue_active(&ctx->poll_wait))
++		wake_up(&ctx->poll_wait);
++#endif
+ 	if (ret)
+ 		put_ioctx(ctx);
+ 
+@@ -1024,6 +1033,8 @@ put_rq:
+ /* aio_read_evt
+  *	Pull an event off of the ioctx's event ring.  Returns the number of 
+  *	events fetched (0 or 1 ;-)
++ *	If ent parameter is 0, just returns the number of events that would
++ *	be fetched.
+  *	FIXME: make this use cmpxchg.
+  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
+  */
+@@ -1046,13 +1057,18 @@ static int aio_read_evt(struct kioctx *i
+ 
+ 	head = ring->head % info->nr;
+ 	if (head != ring->tail) {
+-		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
+-		*ent = *evp;
+-		head = (head + 1) % info->nr;
+-		smp_mb(); /* finish reading the event before updatng the head */
+-		ring->head = head;
+-		ret = 1;
+-		put_aio_ring_event(evp, KM_USER1);
++		if (ent) { /* event requested */
++			struct io_event *evp =
++				aio_ring_event(info, head, KM_USER1);
++			*ent = *evp;
++			head = (head + 1) % info->nr;
++			/* finish reading the event before updatng the head */
++			smp_mb();
++			ring->head = head;
++			ret = 1;
++			put_aio_ring_event(evp, KM_USER1);
++		} else /* only need to know availability */
++			ret = 1;
+ 	}
+ 	spin_unlock(&info->ring_lock);
+ 
+@@ -1235,9 +1251,78 @@ static void io_destroy(struct kioctx *io
+ 
+ 	aio_cancel_all(ioctx);
+ 	wait_for_all_aios(ioctx);
++#ifdef CONFIG_EPOLL
++	/* forget the poll file, but it's up to the user to close it */
++	if (ioctx->file) {
++		ioctx->file->private_data = 0;
++		ioctx->file = 0;
++	}
++#endif
+ 	put_ioctx(ioctx);	/* once for the lookup */
+ }
+ 
++#ifdef CONFIG_EPOLL
++
++static int aio_queue_fd_close(struct inode *inode, struct file *file)
++{
++	struct kioctx *ioctx = file->private_data;
++	if (ioctx) {
++		file->private_data = 0;
++		spin_lock_irq(&ioctx->ctx_lock);
++		ioctx->file = 0;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++	return 0;
++}
++
++static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
++{	unsigned int pollflags = 0;
++	struct kioctx *ioctx = file->private_data;
++
++	if (ioctx) {
++
++		spin_lock_irq(&ioctx->ctx_lock);
++		/* Insert inside our poll wait queue */
++		poll_wait(file, &ioctx->poll_wait, wait);
++
++		/* Check our condition */
++		if (aio_read_evt(ioctx, 0))
++			pollflags = POLLIN | POLLRDNORM;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++
++	return pollflags;
++}
++
++static struct file_operations aioq_fops = {
++	.release	= aio_queue_fd_close,
++	.poll		= aio_queue_fd_poll
++};
++
++/* make_aio_fd:
++ *  Create a file descriptor that can be used to poll the event queue.
++ *  Based and piggybacked on the excellent epoll code.
++ */
++
++static int make_aio_fd(struct kioctx *ioctx)
++{
++	int error, fd;
++	struct inode *inode;
++	struct file *file;
++
++	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
++	if (error)
++		return error;
++
++	/* associate the file with the IO context */
++	file->private_data = ioctx;
++	ioctx->file = file;
++	init_waitqueue_head(&ioctx->poll_wait);
++	return fd;
++}
++#endif
++
++
+ /* sys_io_setup:
+  *	Create an aio_context capable of receiving at least nr_events.
+  *	ctxp must not point to an aio_context that already exists, and
+@@ -1250,18 +1335,30 @@ static void io_destroy(struct kioctx *io
+  *	resources are available.  May fail with -EFAULT if an invalid
+  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
+  *	implemented.
++ *
++ *	To request a selectable fd, the user context has to be initialized
++ *	to 1, instead of 0, and the return value is the fd.
++ *	This keeps the system call compatible, since a non-zero value
++ *	was not allowed so far.
+  */
+ asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
+ {
+ 	struct kioctx *ioctx = NULL;
+ 	unsigned long ctx;
+ 	long ret;
++	int make_fd = 0;
+ 
+ 	ret = get_user(ctx, ctxp);
+ 	if (unlikely(ret))
+ 		goto out;
+ 
+ 	ret = -EINVAL;
++#ifdef CONFIG_EPOLL
++	if (ctx == 1) {
++		make_fd = 1;
++		ctx = 0;
++	}
++#endif
+ 	if (unlikely(ctx || nr_events == 0)) {
+ 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
+ 		         ctx, nr_events);
+@@ -1272,8 +1369,12 @@ asmlinkage long sys_io_setup(unsigned nr
+ 	ret = PTR_ERR(ioctx);
+ 	if (!IS_ERR(ioctx)) {
+ 		ret = put_user(ioctx->user_id, ctxp);
+-		if (!ret)
+-			return 0;
++#ifdef CONFIG_EPOLL
++		if (make_fd && ret >= 0)
++			ret = make_aio_fd(ioctx);
++#endif
++		if (ret >= 0)
++			return ret;
+ 
+ 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
+ 		io_destroy(ioctx);
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index 19ffb04..3a6b872 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -236,8 +236,6 @@ struct ep_pqueue {
+ 
+ static void ep_poll_safewake_init(struct poll_safewake *psw);
+ static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep);
+ static int ep_alloc(struct eventpoll **pep);
+ static void ep_free(struct eventpoll *ep);
+ static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
+@@ -267,7 +265,7 @@ static int ep_events_transfer(struct eve
+ static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
+ 		   int maxevents, long timeout);
+ static int eventpollfs_delete_dentry(struct dentry *dentry);
+-static struct inode *ep_eventpoll_inode(void);
++static struct inode *ep_eventpoll_inode(struct file_operations *fops);
+ static int eventpollfs_get_sb(struct file_system_type *fs_type,
+ 			      int flags, const char *dev_name,
+ 			      void *data, struct vfsmount *mnt);
+@@ -517,7 +515,7 @@ asmlinkage long sys_epoll_create(int siz
+ 	 * Creates all the items needed to setup an eventpoll file. That is,
+ 	 * a file structure, and inode and a free file descriptor.
+ 	 */
+-	error = ep_getfd(&fd, &inode, &file, ep);
++	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
+ 	if (error)
+ 		goto eexit_2;
+ 
+@@ -702,8 +700,8 @@ eexit_1:
+ /*
+  * Creates the file descriptor to be used by the epoll interface.
+  */
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep)
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++		    struct eventpoll *ep, struct file_operations *fops)
+ {
+ 	struct qstr this;
+ 	char name[32];
+@@ -719,7 +717,7 @@ static int ep_getfd(int *efd, struct ino
+ 		goto eexit_1;
+ 
+ 	/* Allocates an inode from the eventpoll file system */
+-	inode = ep_eventpoll_inode();
++	inode = ep_eventpoll_inode(fops);
+ 	error = PTR_ERR(inode);
+ 	if (IS_ERR(inode))
+ 		goto eexit_2;
+@@ -750,7 +748,7 @@ static int ep_getfd(int *efd, struct ino
+ 
+ 	file->f_pos = 0;
+ 	file->f_flags = O_RDONLY;
+-	file->f_op = &eventpoll_fops;
++	file->f_op = fops;
+ 	file->f_mode = FMODE_READ;
+ 	file->f_version = 0;
+ 	file->private_data = ep;
+@@ -1569,7 +1567,7 @@ static int eventpollfs_delete_dentry(str
+ }
+ 
+ 
+-static struct inode *ep_eventpoll_inode(void)
++static struct inode *ep_eventpoll_inode(struct file_operations *fops)
+ {
+ 	int error = -ENOMEM;
+ 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
+@@ -1577,7 +1575,7 @@ static struct inode *ep_eventpoll_inode(
+ 	if (!inode)
+ 		goto eexit_1;
+ 
+-	inode->i_fop = &eventpoll_fops;
++	inode->i_fop = fops;
+ 
+ 	/*
+ 	 * Mark the inode dirty from the very beginning,
+diff --git a/include/linux/aio.h b/include/linux/aio.h
+index 00c8efa..cf8bb52 100644
+--- a/include/linux/aio.h
++++ b/include/linux/aio.h
+@@ -191,6 +191,11 @@ struct kioctx {
+ 	struct aio_ring_info	ring_info;
+ 
+ 	struct work_struct	wq;
++#ifdef CONFIG_EPOLL
++	// poll integration
++	wait_queue_head_t       poll_wait;
++	struct file		*file;
++#endif
+ };
+ 
+ /* prototypes */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..f2a22bc 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -90,6 +90,12 @@ static inline void eventpoll_release(str
+ 	eventpoll_release_file(file);
+ }
+ 
++/*
++ * called by aio code to create fd that can poll the  aio event queueQ
++ */
++struct eventpoll;
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++             struct eventpoll *ep, struct file_operations *fops);
+ #else
+ 
+ static inline void eventpoll_init_file(struct file *file) {}



From tomo at mail.berlios.de  Thu Aug 31 14:53:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 31 Aug 2006 14:53:43 +0200
Subject: [Stgt-svn] r574 - trunk
Message-ID: <200608311253.k7VCrhwQ023933@sheep.berlios.de>

Author: tomo
Date: 2006-08-31 14:53:33 +0200 (Thu, 31 Aug 2006)
New Revision: 574

Removed:
   trunk/initd
Modified:
   trunk/iscsi
Log:
Fix iscsi script and remove initd script.

Deleted: trunk/initd
===================================================================
--- trunk/initd	2006-08-31 12:51:50 UTC (rev 573)
+++ trunk/initd	2006-08-31 12:53:33 UTC (rev 574)
@@ -1,132 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start tgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-MEM_SIZE=1048576
-
-#
-# Need to select one
-#
-#TARGET=ibmvio
-TARGET=iscsi_tcp
-
-#
-# IBM pSeries VIO server
-#
-start_ibmvio()
-{
-	insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
-	insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
-}
-
-stop_ibmvio()
-{
-	rmmod libsrp
-	rmmod ibmvstgt
-}
-
-
-#
-# iSCSI stuff
-#
-start_iscsi_core()
-{
-	insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
-	insmod ${PWD}/istgt/kernel/libiscsi.ko
-}
-
-stop_iscsi_core()
-{
-	rmmod libiscsi
-	rmmod scsi_transport_iscsi
-}
-
-start_iscsi_tcp()
-{
-	modprobe -q crc32c
-
-	start_iscsi_core
-
-	insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
-	insmod ${PWD}/istgt/kernel/iscsi_tcp_target.ko
-}
-
-stop_iscsi_tcp()
-{
-	rmmod iscsi_tcp_target
-	rmmod iscsi_tcp
-}
-
-start_iscsi_iser()
-{
-    	start_iscsi_core
-}
-
-start_server()
-{
-	insmod ${PWD}/kernel/scsi_tgt.ko
-
-	case "$TARGET" in
-	    iscsi_tcp)
-		start_iscsi_tcp
-		;;
-	    ibmvio)
-		start_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	${PWD}/usr/tgtd -d8 --drivers iscsi
-
-	sleep 1
-}
-	
-stop_server()
-{
-	case "$TARGET" in
-	    iscsi_tcp)
-		${PWD}/usr/tgtadm --driver istgt --op delete
-		killall -9 istgtd
-		;;
-	    ibmvio)
-		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
-		;;
-	    *)
-		;;
-	esac
-
-	killall -9 tgtd
-
-	sleep 1
-
-	case "$TARGET" in
-	    iscsi_tcp)
-		stop_iscsi_tcp
-		;;
-	    ibmvio)
-		stop_ibmvio
-		;;
-	    *)
-		;;
-	esac
-
-	rmmod scsi_tgt
-}
-
-case "$1" in
-	start)
-		start_server
-		;;
-	stop)
-		stop_server
-		;;
-	*)
-		echo "Usage: {start|stop}" >&2
-		exit 1
-		;;
-esac
-
-exit 0

Modified: trunk/iscsi
===================================================================
--- trunk/iscsi	2006-08-31 12:51:50 UTC (rev 573)
+++ trunk/iscsi	2006-08-31 12:53:33 UTC (rev 574)
@@ -5,5 +5,5 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1



