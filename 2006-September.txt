From tomo at mail.berlios.de  Fri Sep  1 02:02:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 02:02:50 +0200
Subject: [Stgt-svn] r575 - in trunk/usr: . iscsi
Message-ID: <200609010002.k8102oB7019669@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 02:02:04 +0200 (Fri, 01 Sep 2006)
New Revision: 575

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/target.c
Log:
Minor cleanups.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-08-31 12:53:33 UTC (rev 574)
+++ trunk/usr/bd_aio.c	2006-09-01 00:02:04 UTC (rev 575)
@@ -103,9 +103,11 @@
 	}
 
 	/*
-	 * We use edge triggering because we want only one notification per task.
+	 * We use edge triggering because we want only one
+	 * notification per task.
 	 */
-	err = tgt_event_add(bai->aio_fd, EPOLLIN | EPOLLET, aio_event_handler, dev);
+	err = tgt_event_add(bai->aio_fd, EPOLLIN | EPOLLET,
+			    aio_event_handler, dev);
 	if (err)
 		goto aio_cb_destroy;
 

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-08-31 12:53:33 UTC (rev 574)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 00:02:04 UTC (rev 575)
@@ -438,7 +438,7 @@
 	memset(rsp, 0, BHS_SIZE);
 	if ((req->opcode & ISCSI_OPCODE_MASK) != ISCSI_OP_LOGIN ||
 	    !(req->opcode & ISCSI_OP_IMMEDIATE)) {
-		//reject
+		/* reject */
 	}
 
 	rsp->opcode = ISCSI_OP_LOGIN_RSP;
@@ -446,7 +446,7 @@
 	rsp->active_version = ISCSI_DRAFT20_VERSION;
 	rsp->itt = req->itt;
 
-	if (/*req->max_version < ISCSI_VERSION ||*/
+	if (/* req->max_version < ISCSI_VERSION || */
 	    req->min_version > ISCSI_DRAFT20_VERSION) {
 		rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 		rsp->status_detail = ISCSI_LOGIN_STATUS_NO_VERSION;
@@ -465,7 +465,7 @@
 			login_start(conn);
 			if (rsp->status_class)
 				return;
-			//else fall through
+			/* fall through */
 		case STATE_SECURITY:
 			text_scan_security(conn);
 			if (rsp->status_class)
@@ -648,7 +648,7 @@
 	}
 	rsp->opcode = ISCSI_OP_TEXT_RSP;
 	rsp->itt = req->itt;
-	//rsp->ttt = rsp->ttt;
+	/* rsp->ttt = rsp->ttt; */
 	rsp->ttt = 0xffffffff;
 	conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
 	if (!(req->opcode & ISCSI_OP_IMMEDIATE))
@@ -689,28 +689,25 @@
 
 	switch (conn->req.bhs.opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_LOGIN:
-		//if conn->state == STATE_FULL -> reject
 		cmnd_exec_login(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
 	case ISCSI_OP_TEXT:
-		//if conn->state != STATE_FULL -> reject
 		cmnd_exec_text(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
 	case ISCSI_OP_LOGOUT:
-		//if conn->state != STATE_FULL -> reject
 		cmnd_exec_logout(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
 		log_pdu(2, &conn->rsp);
 		break;
 	default:
-		//reject
+		/* reject */
 		res = 1;
 		break;
 	}
@@ -728,7 +725,7 @@
 		conn->state = STATE_LOGIN;
 		break;
 	case STATE_SECURITY_FULL:
-		//fall through
+		/* fall through */
 	case STATE_LOGIN_FULL:
 		if (conn->session_type == SESSION_NORMAL)
 			conn->state = STATE_KERNEL;
@@ -858,7 +855,7 @@
 	ctask->rw = rw;
 
 	list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
-	tgt_event_modify(ctask->conn->fd, EPOLLIN|EPOLLOUT);
+	tgt_event_modify(ctask->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -880,7 +877,6 @@
 		ctask->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
-/* 	conn->rx_buffer = (void *) (unsigned long) ctask->addr; */
 	conn->rx_buffer = (void *) (unsigned long) ctask->c_buffer;
 	conn->rx_buffer += be32_to_cpu(req->offset);
 	conn->rx_size = ntoh24(req->dlength);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-08-31 12:53:33 UTC (rev 574)
+++ trunk/usr/target.c	2006-09-01 00:02:04 UTC (rev 575)
@@ -496,7 +496,9 @@
 		return;
 	}
 
-	mreq = calloc(1, sizeof(*mreq));
+	mreq = zalloc(sizeof(*mreq));
+	if (!mreq)
+		return;
 	mreq->mid = req_id;
 	mreq->function = function;
 



From tomo at mail.berlios.de  Fri Sep  1 03:12:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 03:12:40 +0200
Subject: [Stgt-svn] r576 - in trunk: . usr/iscsi
Message-ID: <200609010112.k811Cevf005588@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 03:12:35 +0200 (Fri, 01 Sep 2006)
New Revision: 576

Removed:
   trunk/usr/iscsi/types.h
Modified:
   trunk/Makefile
   trunk/usr/iscsi/iscsid.h
Log:
Kill the old type define file.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-09-01 00:02:04 UTC (rev 575)
+++ trunk/Makefile	2006-09-01 01:12:35 UTC (rev 576)
@@ -3,7 +3,7 @@
 #
 
 #IBMVIO=1
-ISCSI=1
+#ISCSI=1
 
 ifeq ($(KERNELSRC),)
 	KERNELSRC ?= /lib/modules/$(shell uname -r)/build

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-01 00:02:04 UTC (rev 575)
+++ trunk/usr/iscsi/iscsid.h	2006-09-01 01:12:35 UTC (rev 576)
@@ -7,10 +7,12 @@
 #ifndef ISCSID_H
 #define ISCSID_H
 
+#include <stdint.h>
+#include <inttypes.h>
 #include <sys/types.h>
 #include <linux/types.h>
+#include <asm/byteorder.h>
 
-#include "types.h"
 #include "list.h"
 #include "param.h"
 #include "log.h"
@@ -18,6 +20,11 @@
 #include <scsi/iscsi_if.h>
 #include <scsi/iscsi_proto.h>
 
+#define cpu_to_be16(x)	__cpu_to_be16(x)
+#define cpu_to_be32(x)	__cpu_to_be32(x)
+#define be16_to_cpu(x)	__be16_to_cpu(x)
+#define be32_to_cpu(x)	__be32_to_cpu(x)
+
 #define ISCSI_NAME_LEN 256
 #define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
 

Deleted: trunk/usr/iscsi/types.h
===================================================================
--- trunk/usr/iscsi/types.h	2006-09-01 00:02:04 UTC (rev 575)
+++ trunk/usr/iscsi/types.h	2006-09-01 01:12:35 UTC (rev 576)
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef TYPES_H
-#define TYPES_H
-
-#include <sys/types.h>
-#include <byteswap.h>
-#include <endian.h>
-#include <stdint.h>
-#include <inttypes.h>
-
-#if __BYTE_ORDER == __BIG_ENDIAN
-#define cpu_to_be16(x)		(x)
-#define be16_to_cpu(x)		(x)
-#define cpu_to_be32(x)		(x)
-#define be32_to_cpu(x)		(x)
-#elif __BYTE_ORDER == __LITTLE_ENDIAN
-#define cpu_to_be16(x)		bswap_16(x)
-#define be16_to_cpu(x)		bswap_16(x)
-#define cpu_to_be32(x)		bswap_32(x)
-#define be32_to_cpu(x)		bswap_32(x)
-#else
-#error "unknown endianess!"
-#endif
-
-#endif	/* TYPES_H */



From tomo at mail.berlios.de  Fri Sep  1 04:39:54 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 04:39:54 +0200
Subject: [Stgt-svn] r577 - trunk/usr/iscsi
Message-ID: <200609010239.k812dsRM006689@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 04:39:52 +0200 (Fri, 01 Sep 2006)
New Revision: 577

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Minor cleanups again.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 01:12:35 UTC (rev 576)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 02:39:52 UTC (rev 577)
@@ -692,19 +692,16 @@
 		cmnd_exec_login(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
-		log_pdu(2, &conn->rsp);
 		break;
 	case ISCSI_OP_TEXT:
 		cmnd_exec_text(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
-		log_pdu(2, &conn->rsp);
 		break;
 	case ISCSI_OP_LOGOUT:
 		cmnd_exec_logout(conn);
 		conn->rsp.bhs.hlength = conn->rsp.ahssize / 4;
 		hton24(conn->rsp.bhs.dlength, conn->rsp.datasize);
-		log_pdu(2, &conn->rsp);
 		break;
 	default:
 		/* reject */

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-01 01:12:35 UTC (rev 576)
+++ trunk/usr/iscsi/iscsid.h	2006-09-01 02:39:52 UTC (rev 577)
@@ -9,7 +9,6 @@
 
 #include <stdint.h>
 #include <inttypes.h>
-#include <sys/types.h>
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
@@ -28,7 +27,7 @@
 #define ISCSI_NAME_LEN 256
 #define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
 
-#define DIGEST_ALL	(DIGEST_NONE | DIGEST_CRC32C)
+#define DIGEST_ALL		(DIGEST_NONE | DIGEST_CRC32C)
 #define DIGEST_NONE		(1 << 0)
 #define DIGEST_CRC32C           (1 << 1)
 
@@ -108,7 +107,6 @@
 	uint8_t isid[6];
 	uint16_t tsih;
 	uint16_t cid;
-	uint16_t pad;
 	int session_type;
 	int auth_method;
 
@@ -179,7 +177,7 @@
 #define AUTH_CHAP		1
 #define DIGEST_UNKNOWN		-1
 
-#define BHS_SIZE		48
+#define BHS_SIZE		sizeof(struct iscsi_hdr)
 
 #define INCOMING_BUFSIZE	8192
 
@@ -228,8 +226,4 @@
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 
-#define log_pdu(x, y)							\
-do {									\
-} while (0)
-
 #endif	/* ISCSID_H */



From tomo at mail.berlios.de  Fri Sep  1 05:32:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 05:32:57 +0200
Subject: [Stgt-svn] r578 - trunk/usr/iscsi
Message-ID: <200609010332.k813WvuE018868@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 05:32:55 +0200 (Fri, 01 Sep 2006)
New Revision: 578

Modified:
   trunk/usr/iscsi/conn.c
Log:
Clean up conn.c.

Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-09-01 02:39:52 UTC (rev 577)
+++ trunk/usr/iscsi/conn.c	2006-09-01 03:32:55 UTC (rev 578)
@@ -16,9 +16,6 @@
 #include "tgtd.h"
 #include "util.h"
 
-#define ISCSI_CONN_NEW		1
-#define ISCSI_CONN_EXIT		5
-
 void conn_add_to_session(struct connection *conn, struct session *session)
 {
 	if (!list_empty(&conn->clist)) {
@@ -91,10 +88,8 @@
 
 	conn->session->conn_cnt++;
 
-	/* FIXME */
-	tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
-
-	return 0;
+	/* FIXME: Use appropriate lid. */
+	return tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
 }
 
 void conn_read_pdu(struct connection *conn)



From tomo at mail.berlios.de  Fri Sep  1 06:27:55 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 06:27:55 +0200
Subject: [Stgt-svn] r579 - trunk/patch
Message-ID: <200609010427.k814RtFd025648@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 06:27:49 +0200 (Fri, 01 Sep 2006)
New Revision: 579

Removed:
   trunk/patch/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   trunk/patch/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   trunk/patch/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   trunk/patch/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   trunk/patch/0005-scsi-tgt-scsi-target-lib-functionality.txt
   trunk/patch/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
   trunk/patch/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
   trunk/patch/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
   trunk/patch/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
Log:
Remove old patchset. Please use the git tree.

Deleted: trunk/patch/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- trunk/patch/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,48 +0,0 @@
-From 44951054af3722883087e928979f1c89fdee918b Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:47:00 +0900
-Subject: [PATCH 1/9] block layer: kill length alignment test in bin_map_user
-
-The tgt project is mapping in bios using bio_map_user. The current targets
-do not need their len to be aligned with a queue limit so this check is
-causing some problems. Note: pointers passed into the kernel are properly
-aligned by usersapace tgt code so the uaddr check in bio_map_user is ok.
-
-The major user, blk_bio_map_user checks for the len before mapping
-so it is not affected by this patch.
-
-And the semi-newly added user blk_rq_map_user_iov has been failing
-out when the len is not aligned properly so maybe people have been
-good and not sending misaligned lens or that path is not used very
-often and this change will not be very dangerous. st and sg do not
-check the length and we have not seen any problem reports from those
-wider used paths so this patch should be fairly safe - for mm
-and wider testing at least.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- fs/bio.c |    5 ++---
- 1 files changed, 2 insertions(+), 3 deletions(-)
-
-diff --git a/fs/bio.c b/fs/bio.c
-index 6a0b9ad..6fe47ce 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
--- 
-1.4.1
-

Deleted: trunk/patch/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- trunk/patch/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,154 +0,0 @@
-From 79acdaa1243aecedcd035c3219375a7cb9c9f786 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:48:58 +0900
-Subject: [PATCH 2/9] block layer: add partial mappings support to bio_map_user
-
-For target mode we could end up with the case where we get very large
-request from the initiator. The request could be so large that we
-cannot transfer all the data in one operation. For example the
-HBA's segment or max_sector limits might limit us to a 1 MB transfer.
-To send a 5 MB command then we need to transfer the command chunk by chunk.
-
-To do this, tgt core will map in as much data as possible into a bio,
-send this off, then when that transfer is completed we send off another
-request/bio. To be able to pack as much data into a bio as possible
-we need bio_map_user to support partially mapped bios.
-
-- bio_map_user_iov always allows partial mappings.
-
-- The two users (blk_rq_map_user and blk_rq_map_user_iov) will fails
-if the bio is partially mapped.
-
-- Added a length argument to blk_rq_map_user_iov in order to avoid
-including sg.h in ll_rw_blk.c for struct sg_iovec.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c      |   29 ++++++++++++++++++-----------
- block/scsi_ioctl.c     |    3 ++-
- fs/bio.c               |   14 +-------------
- include/linux/blkdev.h |    3 ++-
- 4 files changed, 23 insertions(+), 26 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index 61d6b3c..aee4f4b 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2353,19 +2353,20 @@ int blk_rq_map_user(request_queue_t *q, 
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
--	if (!IS_ERR(bio)) {
--		rq->bio = rq->biotail = bio;
--		blk_rq_bio_prep(q, rq, bio);
-+	if (IS_ERR(bio))
-+		return PTR_ERR(bio);
- 
--		rq->buffer = rq->data = NULL;
--		rq->data_len = len;
--		return 0;
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
- 	}
- 
--	/*
--	 * bio is the err-ptr
--	 */
--	return PTR_ERR(bio);
-+	rq->bio = rq->biotail = bio;
-+	blk_rq_bio_prep(q, rq, bio);
-+	rq->buffer = rq->data = NULL;
-+	rq->data_len = len;
-+	return 0;
- }
- 
- EXPORT_SYMBOL(blk_rq_map_user);
-@@ -2391,7 +2392,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
-  *    unmapping.
-  */
- int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
--			struct sg_iovec *iov, int iov_count)
-+			struct sg_iovec *iov, int iov_count, unsigned int len)
- {
- 	struct bio *bio;
- 
-@@ -2405,6 +2406,12 @@ int blk_rq_map_user_iov(request_queue_t 
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
-+	}
-+
- 	rq->bio = rq->biotail = bio;
- 	blk_rq_bio_prep(q, rq, bio);
- 	rq->buffer = rq->data = NULL;
-diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
-index b33eda2..b77e185 100644
---- a/block/scsi_ioctl.c
-+++ b/block/scsi_ioctl.c
-@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
- 			goto out;
- 		}
- 
--		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
-+		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
-+					  hdr->dxfer_len);
- 		kfree(iov);
- 	} else if (hdr->dxfer_len)
- 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
-diff --git a/fs/bio.c b/fs/bio.c
-index 6fe47ce..ade77bf 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -749,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
- 			     int write_to_vm)
- {
- 	struct bio *bio;
--	int len = 0, i;
- 
- 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
- 
-@@ -764,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
- 	 */
- 	bio_get(bio);
- 
--	for (i = 0; i < iov_count; i++)
--		len += iov[i].iov_len;
--
--	if (bio->bi_size == len)
--		return bio;
--
--	/*
--	 * don't support partial mappings
--	 */
--	bio_endio(bio, bio->bi_size, 0);
--	bio_unmap_user(bio);
--	return ERR_PTR(-EINVAL);
-+	return bio;
- }
- 
- static void __bio_unmap_user(struct bio *bio)
-diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
-index aafe827..613a441 100644
---- a/include/linux/blkdev.h
-+++ b/include/linux/blkdev.h
-@@ -616,7 +616,8 @@ extern void blk_queue_activity_fn(reques
- extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
- extern int blk_rq_unmap_user(struct bio *, unsigned int);
- extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
--extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
-+extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
-+			       struct sg_iovec *, int, unsigned int);
- extern int blk_execute_rq(request_queue_t *, struct gendisk *,
- 			  struct request *, int);
- extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
--- 
-1.4.1
-

Deleted: trunk/patch/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- trunk/patch/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0003-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,54 +0,0 @@
-From 3f63e5e44b012927b6054f7025d3a5e7be6f7f09 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:52:17 +0900
-Subject: [PATCH 3/9] block layer: use blk_rq_bio_prep in init_request_from_bio
-
-Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
-blk_rq_bio_prep's flags copying. The first three bits have not been
-the same for some time so that has been broken. The user of
-blk_rq_bio_prep will setup the request flags so if it wanted failfast
-or to be a barrier it will set the correct flag itself.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- block/ll_rw_blk.c |   11 ++---------
- 1 files changed, 2 insertions(+), 9 deletions(-)
-
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index aee4f4b..3f46356 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2838,16 +2838,12 @@ static void init_request_from_bio(struct
- 
- 	req->errors = 0;
- 	req->hard_sector = req->sector = bio->bi_sector;
--	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
--	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
--	req->nr_phys_segments = bio_phys_segments(req->q, bio);
--	req->nr_hw_segments = bio_hw_segments(req->q, bio);
--	req->buffer = bio_data(bio);	/* see ->buffer comment above */
- 	req->waiting = NULL;
--	req->bio = req->biotail = bio;
- 	req->ioprio = bio_prio(bio);
- 	req->rq_disk = bio->bi_bdev->bd_disk;
- 	req->start_time = jiffies;
-+
-+	blk_rq_bio_prep(req->q, req, bio);
- }
- 
- static int __make_request(request_queue_t *q, struct bio *bio)
-@@ -3498,9 +3494,6 @@ EXPORT_SYMBOL(end_request);
- 
- void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
- {
--	/* first two bits are identical in rq->flags and bio->bi_rw */
--	rq->flags |= (bio->bi_rw & 3);
--
- 	rq->nr_phys_segments = bio_phys_segments(q, bio);
- 	rq->nr_hw_segments = bio_hw_segments(q, bio);
- 	rq->current_nr_sectors = bio_cur_sectors(bio);
--- 
-1.4.1
-

Deleted: trunk/patch/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- trunk/patch/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0004-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,330 +0,0 @@
-From 8f167fea740f5d82c70a2e9938e983b704baae67 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Thu, 17 Aug 2006 23:56:41 +0900
-Subject: [PATCH 4/9] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
-
-This patch contains the needed changes to the scsi-ml to support targets.
-
-Note, per the last review we moved almost all the fields we added
-to the scsi_cmnd to our internal data structure which we are going
-to try and kill off when we can replace it with support from other
-parts of the kernel.
-
-The one field we left on was the offset variable. This is needed to handle
-the case where the target gets request that is so large that it cannot
-execute it in one dma operation. So max_secotors or a segment limit may
-limit the size of the transfer. In this case our tgt core code will
-break up the command into managable transfers and send them to the
-LLD one at a time. The offset is then used to tell the LLD where in
-the command we are at. Is there another field on the scsi_cmd for
-that?
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/hosts.c     |    4 ++++
- drivers/scsi/scsi.c      |   43 ++++++++++++++++++++++++++-----------------
- drivers/scsi/scsi_lib.c  |   33 ++++++++++++++++++++++++---------
- include/scsi/scsi_cmnd.h |   10 ++++++++++
- include/scsi/scsi_host.h |   43 +++++++++++++++++++++++++++++++++++++++++++
- 5 files changed, 107 insertions(+), 26 deletions(-)
-
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index dfcb96f..341c1ee 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct
- 		kthread_stop(shost->ehandler);
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
- 
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index b332cad..08f8597 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -136,8 +136,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -158,6 +157,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -194,9 +194,29 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
-+{
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(dev);
-+}
-+EXPORT_SYMBOL(__scsi_put_command);
-+
- /*
-  * Function:	scsi_put_command()
-  *
-@@ -211,26 +231,15 @@ EXPORT_SYMBOL(scsi_get_command);
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
--
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index 077c1c6..ea22612 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -693,7 +693,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -734,7 +734,9 @@ #endif
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -744,6 +746,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1538,29 +1542,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 58e6444..fe4455c 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@ #include <linux/timer.h>
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- 
- 
-@@ -72,6 +73,9 @@ #define MAX_COMMAND_SIZE	16
- 	unsigned short use_sg;	/* Number of pieces of scatter-gather */
- 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
- 
-+	/* offset in cmd we are at (for multi-transfer tgt cmds) */
-+	unsigned offset;
-+
- 	unsigned underflow;	/* Return error if less than
- 				   this amount is transferred */
- 
-@@ -133,7 +137,10 @@ #define SCSI_STATE_MLQUEUE         0x100
- 
- 
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
- extern void scsi_req_abort_cmd(struct scsi_cmnd *cmd);
-@@ -142,4 +149,7 @@ extern void *scsi_kmap_atomic_sg(struct 
- 				 size_t *offset, size_t *len);
- extern void scsi_kunmap_atomic_sg(void *virt);
- 
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
-+
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index b3dd90f..1a393b6 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@ #include <linux/types.h>
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -122,6 +123,39 @@ #endif
- 	int (* queuecommand)(struct scsi_cmnd *,
- 			     void (*done)(struct scsi_cmnd *));
- 
-+ 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/* Used as callback for the completion of task management request. */
-+	int (* tsk_mgmt_response)(u64 mid, int result);
-+
- 	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
-@@ -561,6 +595,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -664,6 +704,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+						void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
--- 
-1.4.1
-

Deleted: trunk/patch/0005-scsi-tgt-scsi-target-lib-functionality.txt
===================================================================
--- trunk/patch/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0005-scsi-tgt-scsi-target-lib-functionality.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,789 +0,0 @@
-From 116f6f576a16fd7a2685916e4146930f90204d46 Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Fri, 18 Aug 2006 11:55:41 +0900
-Subject: [PATCH 5/9] scsi tgt: scsi target lib functionality
-
-The core scsi target lib functions.
-
-TODO:
-- mv md/dm-bio-list.h to linux/bio-list.h so md and us do not have to
-do that weird include.
-- convert scsi_tgt_cmd's work struct to James's execute code. And try
-to kill our scsi_tgt_cmd.
-- add host state checking. We do refcouting so hotplug is partially
-supported, but we need to add state checking to make it easier on
-the LLD.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/scsi_tgt_lib.c  |  700 ++++++++++++++++++++++++++++++++++++++++++
- drivers/scsi/scsi_tgt_priv.h |   25 ++
- include/scsi/scsi_tgt.h      |   18 +
- 3 files changed, 743 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-new file mode 100644
-index 0000000..c515c27
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -0,0 +1,700 @@
-+/*
-+ * SCSI target lib functions
-+ *
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/blkdev.h>
-+#include <linux/hash.h>
-+#include <linux/module.h>
-+#include <linux/pagemap.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <../drivers/md/dm-bio-list.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+static struct workqueue_struct *scsi_tgtd;
-+static kmem_cache_t *scsi_tgt_cmd_cache;
-+
-+/*
-+ * TODO: this struct will be killed when the block layer supports large bios
-+ * and James's work struct code is in
-+ */
-+struct scsi_tgt_cmd {
-+	/* TODO replace work with James b's code */
-+	struct work_struct work;
-+	/* TODO replace the lists with a large bio */
-+	struct bio_list xfer_done_list;
-+	struct bio_list xfer_list;
-+
-+	struct list_head hash_list;
-+	struct request *rq;
-+	u64 tag;
-+
-+	void *buffer;
-+	unsigned bufflen;
-+};
-+
-+#define TGT_HASH_ORDER	4
-+#define cmd_hashfn(tag)	hash_long((unsigned long) (tag), TGT_HASH_ORDER)
-+
-+struct scsi_tgt_queuedata {
-+	struct Scsi_Host *shost;
-+	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
-+	spinlock_t cmd_hash_lock;
-+};
-+
-+/*
-+ * Function:	scsi_host_get_command()
-+ *
-+ * Purpose:	Allocate and setup a scsi command block and blk request
-+ *
-+ * Arguments:	shost	- scsi host
-+ *		data_dir - dma data dir
-+ *		gfp_mask- allocator flags
-+ *
-+ * Returns:	The allocated scsi command structure.
-+ *
-+ * This should be called by target LLDs to get a command.
-+ */
-+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
-+					enum dma_data_direction data_dir,
-+					gfp_t gfp_mask)
-+{
-+	int write = (data_dir == DMA_TO_DEVICE);
-+	struct request *rq;
-+	struct scsi_cmnd *cmd;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/* Bail if we can't get a reference to the device */
-+	if (!get_device(&shost->shost_gendev))
-+		return NULL;
-+
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		goto put_dev;
-+
-+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
-+	if (!rq)
-+		goto free_tcmd;
-+
-+	cmd = __scsi_get_command(shost, gfp_mask);
-+	if (!cmd)
-+		goto release_rq;
-+
-+	memset(cmd, 0, sizeof(*cmd));
-+	cmd->sc_data_direction = data_dir;
-+	cmd->jiffies_at_alloc = jiffies;
-+	cmd->request = rq;
-+
-+	rq->special = cmd;
-+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
-+	rq->end_io_data = tcmd;
-+
-+	bio_list_init(&tcmd->xfer_list);
-+	bio_list_init(&tcmd->xfer_done_list);
-+	tcmd->rq = rq;
-+
-+	return cmd;
-+
-+release_rq:
-+	blk_put_request(rq);
-+free_tcmd:
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+put_dev:
-+	put_device(&shost->shost_gendev);
-+	return NULL;
-+
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_get_command);
-+
-+/*
-+ * Function:	scsi_host_put_command()
-+ *
-+ * Purpose:	Free a scsi command block
-+ *
-+ * Arguments:	shost	- scsi host
-+ * 		cmd	- command block to free
-+ *
-+ * Returns:	Nothing.
-+ *
-+ * Notes:	The command must not belong to any lists.
-+ */
-+void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = shost->uspace_req_q;
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	unsigned long flags;
-+
-+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
-+
-+	spin_lock_irqsave(q->queue_lock, flags);
-+	__blk_put_request(q, rq);
-+	spin_unlock_irqrestore(q->queue_lock, flags);
-+
-+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
-+}
-+EXPORT_SYMBOL_GPL(scsi_host_put_command);
-+
-+static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
-+{
-+	struct bio *bio;
-+
-+	/* must call bio_endio in case bio was bounced */
-+	while ((bio = bio_list_pop(&tcmd->xfer_done_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+
-+	while ((bio = bio_list_pop(&tcmd->xfer_list))) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+	}
-+}
-+
-+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_del(&tcmd->hash_list);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+static void scsi_tgt_cmd_destroy(void *data)
-+{
-+	struct scsi_cmnd *cmd = data;
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
-+		rq_data_dir(cmd->request));
-+
-+	cmd_hashlist_del(cmd);
-+
-+	scsi_unmap_user_pages(tcmd);
-+	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
-+}
-+
-+static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd,
-+			      u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = rq->q->queuedata;
-+	unsigned long flags;
-+	struct list_head *head;
-+
-+	tcmd->tag = tag;
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	list_add(&tcmd->hash_list, head);
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+}
-+
-+/*
-+ * scsi_tgt_alloc_queue - setup queue used for message passing
-+ * shost: scsi host
-+ *
-+ * This should be called by the LLD after host allocation.
-+ * And will be released when the host is released.
-+ */
-+int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
-+{
-+	struct scsi_tgt_queuedata *queuedata;
-+	struct request_queue *q;
-+	int err, i;
-+
-+	/*
-+	 * Do we need to send a netlink event or should uspace
-+	 * just respond to the hotplug event?
-+	 */
-+	q = __scsi_alloc_queue(shost, NULL);
-+	if (!q)
-+		return -ENOMEM;
-+
-+	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
-+	if (!queuedata) {
-+		err = -ENOMEM;
-+		goto cleanup_queue;
-+	}
-+	queuedata->shost = shost;
-+	q->queuedata = queuedata;
-+
-+	/*
-+	 * this is a silly hack. We should probably just queue as many
-+	 * command as is recvd to userspace. uspace can then make
-+	 * sure we do not overload the HBA
-+	 */
-+	q->nr_requests = shost->hostt->can_queue;
-+	/*
-+	 * We currently only support software LLDs so this does
-+	 * not matter for now. Do we need this for the cards we support?
-+	 * If so we should make it a host template value.
-+	 */
-+	blk_queue_dma_alignment(q, 0);
-+	shost->uspace_req_q = q;
-+
-+	for (i = 0; i < ARRAY_SIZE(queuedata->cmd_hash); i++)
-+		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
-+	spin_lock_init(&queuedata->cmd_hash_lock);
-+
-+	return 0;
-+
-+cleanup_queue:
-+	blk_cleanup_queue(q);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
-+
-+struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_queuedata *queue = cmd->request->q->queuedata;
-+	return queue->shost;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-+
-+/*
-+ * scsi_tgt_queue_command - queue command for userspace processing
-+ * @cmd:	scsi command
-+ * @scsilun:	scsi lun
-+ * @tag:	unique value to identify this command for tmf
-+ */
-+int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			   u64 tag)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	init_scsi_tgt_cmd(cmd->request, tcmd, tag);
-+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
-+	if (err)
-+		cmd_hashlist_del(cmd);
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
-+
-+/*
-+ * This is run from a interrpt handler normally and the unmap
-+ * needs process context so we must queue
-+ */
-+static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
-+	queue_work(scsi_tgtd, &tcmd->work);
-+}
-+
-+static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	int err;
-+
-+	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
-+
-+	err = shost->hostt->transfer_response(cmd, scsi_tgt_cmd_done);
-+	switch (err) {
-+	case SCSI_MLQUEUE_HOST_BUSY:
-+	case SCSI_MLQUEUE_DEVICE_BUSY:
-+		return -EAGAIN;
-+	}
-+
-+	return 0;
-+}
-+
-+static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	int err;
-+
-+	err = __scsi_tgt_transfer_response(cmd);
-+	if (!err)
-+		return;
-+
-+	cmd->result = DID_BUS_BUSY << 16;
-+	err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+	if (err <= 0)
-+		/* the eh will have to pick this up */
-+		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+}
-+
-+static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+{
-+	struct request *rq = cmd->request;
-+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
-+	int count;
-+
-+	cmd->use_sg = rq->nr_phys_segments;
-+	cmd->request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
-+	if (!cmd->request_buffer)
-+		return -ENOMEM;
-+
-+	cmd->request_bufflen = rq->data_len;
-+
-+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
-+		rq_data_dir(rq));
-+	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
-+	if (likely(count <= cmd->use_sg)) {
-+		cmd->use_sg = count;
-+		return 0;
-+	}
-+
-+	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	return -EINVAL;
-+}
-+
-+/* TODO: test this crap and replace bio_map_user with new interface maybe */
-+static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
-+			       int rw)
-+{
-+	struct request_queue *q = cmd->request->q;
-+	struct request *rq = cmd->request;
-+	void *uaddr = tcmd->buffer;
-+	unsigned int len = tcmd->bufflen;
-+	struct bio *bio;
-+	int err;
-+
-+	while (len > 0) {
-+		dprintk("%lx %u\n", (unsigned long) uaddr, len);
-+		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw);
-+		if (IS_ERR(bio)) {
-+			err = PTR_ERR(bio);
-+			dprintk("fail to map %lx %u %d %x\n",
-+				(unsigned long) uaddr, len, err, cmd->cmnd[0]);
-+			goto unmap_bios;
-+		}
-+
-+		uaddr += bio->bi_size;
-+		len -= bio->bi_size;
-+
-+		/*
-+		 * The first bio is added and merged. We could probably
-+		 * try to add others using scsi_merge_bio() but for now
-+		 * we keep it simple. The first bio should be pretty large
-+		 * (either hitting the 1 MB bio pages limit or a queue limit)
-+		 * already but for really large IO we may want to try and
-+		 * merge these.
-+		 */
-+		if (!rq->bio) {
-+			blk_rq_bio_prep(q, rq, bio);
-+			rq->data_len = bio->bi_size;
-+		} else
-+			/* put list of bios to transfer in next go around */
-+			bio_list_add(&tcmd->xfer_list, bio);
-+	}
-+
-+	cmd->offset = 0;
-+	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
-+	if (err)
-+		goto unmap_bios;
-+
-+	return 0;
-+
-+unmap_bios:
-+	if (rq->bio) {
-+		bio_unmap_user(rq->bio);
-+		while ((bio = bio_list_pop(&tcmd->xfer_list)))
-+			bio_unmap_user(bio);
-+	}
-+
-+	return err;
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *);
-+
-+static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
-+{
-+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-+	struct bio *bio;
-+	int err;
-+
-+	/* should we free resources here on error ? */
-+	if (cmd->result) {
-+send_uspace_err:
-+		err = scsi_tgt_uspace_send_status(cmd, tcmd->tag);
-+		if (err <= 0)
-+			/* the tgt uspace eh will have to pick this up */
-+			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
-+	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
-+
-+	tcmd->buffer += cmd->request_bufflen;
-+	cmd->offset += cmd->request_bufflen;
-+
-+	if (!tcmd->xfer_list.head) {
-+		scsi_tgt_transfer_response(cmd);
-+		return;
-+	}
-+
-+	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-+		cmd, cmd->request_bufflen, tcmd->bufflen);
-+
-+	bio = bio_list_pop(&tcmd->xfer_list);
-+	BUG_ON(!bio);
-+
-+	blk_rq_bio_prep(cmd->request->q, cmd->request, bio);
-+	cmd->request->data_len = bio->bi_size;
-+	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
-+	if (err) {
-+		cmd->result = DID_ERROR << 16;
-+		goto send_uspace_err;
-+	}
-+
-+	if (scsi_tgt_transfer_data(cmd)) {
-+		cmd->result = DID_NO_CONNECT << 16;
-+		goto send_uspace_err;
-+	}
-+}
-+
-+static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
-+{
-+	int err;
-+	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
-+
-+	err = host->hostt->transfer_data(cmd, scsi_tgt_data_transfer_done);
-+	switch (err) {
-+		case SCSI_MLQUEUE_HOST_BUSY:
-+		case SCSI_MLQUEUE_DEVICE_BUSY:
-+			return -EAGAIN;
-+	default:
-+		return 0;
-+	}
-+}
-+
-+static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
-+				unsigned len)
-+{
-+	char __user *p = (char __user *) uaddr;
-+
-+	if (copy_from_user(cmd->sense_buffer, p,
-+			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
-+		printk(KERN_ERR "Could not copy the sense buffer\n");
-+		return -EIO;
-+	}
-+	return 0;
-+}
-+
-+static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = host->hostt->eh_abort_handler(cmd);
-+	if (err)
-+		eprintk("fail to abort %p\n", cmd);
-+
-+	scsi_tgt_cmd_destroy(cmd);
-+	return err;
-+}
-+
-+static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u64 tag)
-+{
-+	struct scsi_tgt_queuedata *qdata = q->queuedata;
-+	struct request *rq = NULL;
-+	struct list_head *head;
-+	struct scsi_tgt_cmd *tcmd;
-+	unsigned long flags;
-+
-+	head = &qdata->cmd_hash[cmd_hashfn(tag)];
-+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-+	list_for_each_entry(tcmd, head, hash_list) {
-+		if (tcmd->tag == tag) {
-+			rq = tcmd->rq;
-+			break;
-+		}
-+	}
-+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
-+
-+	return rq;
-+}
-+
-+int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+			 unsigned long uaddr, u8 rw)
-+{
-+	struct Scsi_Host *shost;
-+	struct scsi_cmnd *cmd;
-+	struct request *rq;
-+	struct scsi_tgt_cmd *tcmd;
-+	int err = 0;
-+
-+	dprintk("%d %llu %d %u %lx %u\n", host_no, (unsigned long long) tag,
-+		result, len, uaddr, rw);
-+
-+	/* TODO: replace with a O(1) alg */
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return -EINVAL;
-+	}
-+
-+	if (!shost->uspace_req_q) {
-+		printk(KERN_ERR "Not target scsi host %d\n", host_no);
-+		goto done;
-+	}
-+
-+	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, tag);
-+	if (!rq) {
-+		printk(KERN_ERR "Could not find tag %llu\n",
-+		       (unsigned long long) tag);
-+		err = -EINVAL;
-+		goto done;
-+	}
-+	cmd = rq->special;
-+
-+	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
-+		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
-+
-+	if (result == TASK_ABORTED) {
-+		scsi_tgt_abort_cmd(shost, cmd);
-+		goto done;
-+	}
-+	/*
-+	 * store the userspace values here, the working values are
-+	 * in the request_* values
-+	 */
-+	tcmd = cmd->request->end_io_data;
-+	tcmd->buffer = (void *)uaddr;
-+	tcmd->bufflen = len;
-+	cmd->result = result;
-+
-+	if (!tcmd->bufflen || cmd->request_buffer) {
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+
-+	/*
-+	 * TODO: Do we need to handle case where request does not
-+	 * align with LLD.
-+	 */
-+	err = scsi_map_user_pages(rq->end_io_data, cmd, rw);
-+	if (err) {
-+		eprintk("%p %d\n", cmd, err);
-+		err = -EAGAIN;
-+		goto done;
-+	}
-+
-+	/* userspace failure */
-+	if (cmd->result) {
-+		if (status_byte(cmd->result) == CHECK_CONDITION)
-+			scsi_tgt_copy_sense(cmd, uaddr, len);
-+		err = __scsi_tgt_transfer_response(cmd);
-+		goto done;
-+	}
-+	/* ask the target LLD to transfer the data to the buffer */
-+	err = scsi_tgt_transfer_data(cmd);
-+
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-+			      struct scsi_lun *scsilun, void *data)
-+{
-+	int err;
-+
-+	/* TODO: need to retry if this fails. */
-+	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
-+					    tag, scsilun, data);
-+	if (err < 0)
-+		eprintk("The task management request lost!\n");
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-+
-+int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-+{
-+	struct Scsi_Host *shost;
-+	int err = -EINVAL;
-+
-+	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
-+
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR "Could not find host no %d\n", host_no);
-+		return err;
-+	}
-+
-+	if (!shost->uspace_req_q) {
-+		printk(KERN_ERR "Not target scsi host %d\n", host_no);
-+		goto done;
-+	}
-+
-+	err = shost->hostt->tsk_mgmt_response(mid, result);
-+done:
-+	scsi_host_put(shost);
-+	return err;
-+}
-+
-+static int __init scsi_tgt_init(void)
-+{
-+	int err;
-+
-+	scsi_tgt_cmd_cache = kmem_cache_create("scsi_tgt_cmd",
-+					       sizeof(struct scsi_tgt_cmd),
-+					       0, 0, NULL, NULL);
-+	if (!scsi_tgt_cmd_cache)
-+		return -ENOMEM;
-+
-+	scsi_tgtd = create_workqueue("scsi_tgtd");
-+	if (!scsi_tgtd) {
-+		err = -ENOMEM;
-+		goto free_kmemcache;
-+	}
-+
-+	err = scsi_tgt_if_init();
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(scsi_tgtd);
-+free_kmemcache:
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+	return err;
-+}
-+
-+static void __exit scsi_tgt_exit(void)
-+{
-+	destroy_workqueue(scsi_tgtd);
-+	scsi_tgt_if_exit();
-+	kmem_cache_destroy(scsi_tgt_cmd_cache);
-+}
-+
-+module_init(scsi_tgt_init);
-+module_exit(scsi_tgt_exit);
-+
-+MODULE_DESCRIPTION("SCSI target core");
-+MODULE_LICENSE("GPL");
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-new file mode 100644
-index 0000000..84488c5
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -0,0 +1,25 @@
-+struct scsi_cmnd;
-+struct scsi_lun;
-+struct Scsi_Host;
-+struct task_struct;
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+
-+#define dprintk(fmt, args...)
-+/* #define dprintk eprintk */
-+
-+extern void scsi_tgt_if_exit(void);
-+extern int scsi_tgt_if_init(void);
-+
-+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				    u64 tag);
-+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag);
-+extern int scsi_tgt_kspace_exec(int host_no, u64 tag, int result, u32 len,
-+				unsigned long uaddr, u8 rw);
-+extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+					 struct scsi_lun *scsilun, void *data);
-+extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..1771151
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,18 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+#include <linux/dma-mapping.h>
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
-+extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
-+				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
-+extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
--- 
-1.4.1
-

Deleted: trunk/patch/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt
===================================================================
--- trunk/patch/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0006-scsi-tgt-scsi-target-user-and-kernel-communication-interface.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,481 +0,0 @@
-From 4f1934d63d45a88066061f460a7e57fdddba6bf6 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:32:41 +0900
-Subject: [PATCH 6/9] scsi tgt: scsi target user and kernel communication interface
-
-The user-space daemon and tgt kernel module need to exchange mmapped
-addresses. netlink cannot do that. We need two-way kernel/user
-high-performance interface, however, mainline kernel provides no
-standard interface like that.
-
-This patch adds shared memory interface between kernel and user spaces
-like some other drivers do by using own character device. The
-user-space daemon and tgt kernel module creates shared memory via mmap
-and use it like ring buffer. poll (kernel to user) and write (user to
-kernel) system calls are used for notification.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
----
- drivers/scsi/scsi_tgt_if.c |  350 ++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/scsi_tgt_if.h |   93 ++++++++++++
- 2 files changed, 443 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-new file mode 100644
-index 0000000..09c4ab1
---- /dev/null
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -0,0 +1,350 @@
-+/*
-+ * SCSI target kernel/user interface functions
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/miscdevice.h>
-+#include <linux/file.h>
-+#include <net/tcp.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_device.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/scsi_tgt_if.h>
-+
-+#include "scsi_tgt_priv.h"
-+
-+struct tgt_ring {
-+	u32 tr_idx;
-+	unsigned long tr_pages[TGT_RING_PAGES];
-+	spinlock_t tr_lock;
-+};
-+
-+/* tx_ring : kernel->user, rx_ring : user->kernel */
-+static struct tgt_ring tx_ring, rx_ring;
-+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
-+
-+static inline void tgt_ring_idx_inc(struct tgt_ring *ring)
-+{
-+	if (ring->tr_idx == TGT_MAX_EVENTS - 1)
-+		ring->tr_idx = 0;
-+	else
-+		ring->tr_idx++;
-+}
-+
-+static struct tgt_event *tgt_head_event(struct tgt_ring *ring, u32 idx)
-+{
-+	u32 pidx, off;
-+
-+	pidx = idx / TGT_EVENT_PER_PAGE;
-+	off = idx % TGT_EVENT_PER_PAGE;
-+
-+	return (struct tgt_event *)
-+		(ring->tr_pages[pidx] + sizeof(struct tgt_event) * off);
-+}
-+
-+static int tgt_uspace_send_event(u32 type, struct tgt_event *p)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	int err = 0;
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	ev = tgt_head_event(ring, ring->tr_idx);
-+	if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+		tgt_ring_idx_inc(ring);
-+	else
-+		err = -BUSY;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	if (err)
-+		return err;
-+
-+	memcpy(ev, p, sizeof(*ev));
-+	ev->type = type;
-+	ev->status = TGT_EVENT_STATUS_USED;
-+	mb();
-+
-+	flush_dcache_page(virt_to_page(ev));
-+
-+	wake_up_interruptible(&tgt_poll_wait);
-+
-+	return 0;
-+}
-+
-+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_req.host_no = shost->host_no;
-+	ev.k.cmd_req.data_len = cmd->request_bufflen;
-+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
-+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
-+	ev.k.cmd_req.attribute = cmd->tag;
-+	ev.k.cmd_req.tag = tag;
-+
-+	dprintk("%p %d %u %x %llx\n", cmd, shost->host_no,
-+		ev.k.cmd_req.data_len, cmd->tag,
-+		(unsigned long long) ev.k.cmd_req.tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, u64 tag)
-+{
-+	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.cmd_done.host_no = shost->host_no;
-+	ev.k.cmd_done.tag = tag;
-+	ev.k.cmd_done.result = cmd->result;
-+
-+	dprintk("%p %d %llu %u %x\n", cmd, shost->host_no,
-+		(unsigned long long) ev.k.cmd_req.tag,
-+		ev.k.cmd_req.data_len, cmd->tag);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_CMD_DONE, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+				  struct scsi_lun *scsilun, void *data)
-+{
-+	struct tgt_event ev;
-+	int err;
-+
-+	memset(&ev, 0, sizeof(ev));
-+	ev.k.tsk_mgmt_req.host_no = host_no;
-+	ev.k.tsk_mgmt_req.function = function;
-+	ev.k.tsk_mgmt_req.tag = tag;
-+	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-+	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
-+
-+	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
-+		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-+
-+	err = tgt_uspace_send_event(TGT_KEVENT_TSK_MGMT_REQ, &ev);
-+	if (err)
-+		eprintk("tx buf is full, could not send\n");
-+
-+	return err;
-+}
-+
-+static int event_recv_msg(struct tgt_event *ev)
-+{
-+	int err = 0;
-+
-+	switch (ev->type) {
-+	case TGT_UEVENT_CMD_RSP:
-+		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
-+					   ev->u.cmd_rsp.tag,
-+					   ev->u.cmd_rsp.result,
-+					   ev->u.cmd_rsp.len,
-+					   ev->u.cmd_rsp.uaddr,
-+					   ev->u.cmd_rsp.rw);
-+		break;
-+	case TGT_UEVENT_TSK_MGMT_RSP:
-+		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
-+					       ev->u.tsk_mgmt_rsp.mid,
-+					       ev->u.tsk_mgmt_rsp.result);
-+		break;
-+	default:
-+		eprintk("unknown type %d\n", ev->type);
-+		err = -EINVAL;
-+	}
-+
-+	return err;
-+}
-+
-+static ssize_t tgt_write(struct file *file, const char __user * buffer,
-+			 size_t count, loff_t * ppos)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &rx_ring;
-+
-+	while (1) {
-+		ev = tgt_head_event(ring, ring->tr_idx);
-+		if (ev->status == TGT_EVENT_STATUS_EMPTY)
-+			break;
-+
-+		/* do we need this? */
-+		flush_dcache_page(virt_to_page(ev));
-+
-+		tgt_ring_idx_inc(ring);
-+		ev->status = TGT_EVENT_STATUS_EMPTY;
-+		event_recv_msg(ev);
-+	};
-+
-+	return count;
-+}
-+
-+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
-+{
-+	struct tgt_event *ev;
-+	struct tgt_ring *ring = &tx_ring;
-+	unsigned long flags;
-+	unsigned int mask = 0;
-+	u32 idx;
-+
-+	poll_wait(file, &tgt_poll_wait, wait);
-+
-+	spin_lock_irqsave(&ring->tr_lock, flags);
-+
-+	idx = ring->tr_idx ? ring->tr_idx - 1 : TGT_MAX_EVENTS - 1;
-+	ev = tgt_head_event(ring, idx);
-+	if (ev->status == TGT_EVENT_STATUS_USED)
-+		mask |= POLLIN | POLLRDNORM;
-+
-+	spin_unlock_irqrestore(&ring->tr_lock, flags);
-+
-+	return mask;
-+}
-+
-+static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,
-+			   struct tgt_ring *ring)
-+{
-+	int i, err;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		struct page *page = virt_to_page(ring->tr_pages[i]);
-+		err = vm_insert_page(vma, addr, page);
-+		if (err)
-+			return err;
-+		addr += PAGE_SIZE;
-+	}
-+
-+	return 0;
-+}
-+
-+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
-+{
-+	unsigned long addr;
-+	int err;
-+
-+	if (vma->vm_pgoff)
-+		return -EINVAL;
-+
-+	if (vma->vm_end - vma->vm_start != TGT_RING_SIZE * 2) {
-+		eprintk("mmap size must be %lu, not %lu \n",
-+			TGT_RING_SIZE * 2, vma->vm_end - vma->vm_start);
-+		return -EINVAL;
-+	}
-+
-+	addr = vma->vm_start;
-+	err = uspace_ring_map(vma, addr, &tx_ring);
-+	if (err)
-+		return err;
-+	err = uspace_ring_map(vma, addr + TGT_RING_SIZE, &rx_ring);
-+
-+	return err;
-+}
-+
-+static int tgt_open(struct inode *inode, struct file *file)
-+{
-+	tx_ring.tr_idx = rx_ring.tr_idx = 0;
-+
-+	return 0;
-+}
-+
-+static struct file_operations tgt_fops = {
-+	.owner		= THIS_MODULE,
-+	.open		= tgt_open,
-+	.poll		= tgt_poll,
-+	.write		= tgt_write,
-+	.mmap		= tgt_mmap,
-+};
-+
-+static struct miscdevice tgt_miscdev = {
-+	.minor = MISC_DYNAMIC_MINOR,
-+	.name = "tgt",
-+	.fops = &tgt_fops,
-+};
-+
-+static void tgt_ring_exit(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++)
-+		free_page(ring->tr_pages[i]);
-+}
-+
-+static int tgt_ring_init(struct tgt_ring *ring)
-+{
-+	int i;
-+
-+	spin_lock_init(&ring->tr_lock);
-+
-+	for (i = 0; i < TGT_RING_PAGES; i++) {
-+		ring->tr_pages[i] = get_zeroed_page(GFP_KERNEL);
-+		if (!ring->tr_pages[i]) {
-+			eprintk("out of memory\n");
-+			return -ENOMEM;
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+void scsi_tgt_if_exit(void)
-+{
-+	tgt_ring_exit(&tx_ring);
-+	tgt_ring_exit(&rx_ring);
-+	misc_deregister(&tgt_miscdev);
-+}
-+
-+int scsi_tgt_if_init(void)
-+{
-+	int err;
-+
-+	err = tgt_ring_init(&tx_ring);
-+	if (err)
-+		return err;
-+
-+	err = tgt_ring_init(&rx_ring);
-+	if (err)
-+		goto free_tx_ring;
-+
-+	err = misc_register(&tgt_miscdev);
-+	if (err)
-+		goto free_rx_ring;
-+
-+	return 0;
-+free_rx_ring:
-+	tgt_ring_exit(&rx_ring);
-+free_tx_ring:
-+	tgt_ring_exit(&tx_ring);
-+
-+	return err;
-+}
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..5671920
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,93 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_status {
-+	TGT_EVENT_STATUS_EMPTY = 0,
-+	TGT_EVENT_STATUS_USED,
-+};
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_CMD_RSP,
-+	TGT_UEVENT_TSK_MGMT_RSP,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+	TGT_KEVENT_TSK_MGMT_REQ,
-+};
-+
-+struct tgt_event {
-+	uint32_t status;
-+	uint32_t type;
-+
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint8_t rw;
-+			uint64_t tag;
-+		} cmd_rsp;
-+		struct {
-+			int host_no;
-+			uint64_t mid;
-+			int result;
-+		} tsk_mgmt_rsp;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int host_no;
-+			uint32_t data_len;
-+			uint8_t scb[16];
-+			uint8_t lun[8];
-+			int attribute;
-+			uint64_t tag;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint64_t tag;
-+			int result;
-+		} cmd_done;
-+		struct {
-+			int host_no;
-+			int function;
-+			uint64_t tag;
-+			uint8_t lun[8];
-+			uint64_t mid;
-+		} tsk_mgmt_req;
-+	} k;
-+
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+
-+#define TGT_RING_SIZE (1UL << 16)
-+#define TGT_RING_PAGES (TGT_RING_SIZE >> PAGE_SHIFT)
-+#define TGT_EVENT_PER_PAGE (PAGE_SIZE / sizeof(struct tgt_event))
-+#define TGT_MAX_EVENTS (TGT_EVENT_PER_PAGE * TGT_RING_PAGES)
-+
-+#endif
--- 
-1.4.1
-

Deleted: trunk/patch/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt
===================================================================
--- trunk/patch/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0007-scsi-ml-Makefile-and-Kconfig-changes-for-tgt.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,57 +0,0 @@
-From 4d62965a2d1d43b05529bf2f26563d3ddbe449cb Mon Sep 17 00:00:00 2001
-From: Mike Christie <michaelc at cs.wisc.edu>
-Date: Fri, 18 Aug 2006 00:33:17 +0900
-Subject: [PATCH 7/9] scsi-ml: Makefile and Kconfig changes for tgt
-
-Makefile and Kconfig stuff.
-
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    7 +++++++
- drivers/scsi/Makefile |    3 +++
- 2 files changed, 10 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 96a81cd..566626c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -27,6 +27,13 @@ config SCSI
- 	  However, do not compile this as a module if your root file system
- 	  (the one containing the directory /) is located on a SCSI device.
- 
-+config SCSI_TGT
-+	tristate "SCSI target support"
-+	depends on SCSI && EXPERIMENTAL
-+	---help---
-+	  If you want to use SCSI target mode drivers enable this option.
-+	  If you choose M, the module will be called scsi_tgt.
-+
- config SCSI_PROC_FS
- 	bool "legacy /proc/scsi/ support"
- 	depends on SCSI && PROC_FS
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ebd0cf0..ede0c45 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
- subdir-$(CONFIG_PCMCIA)		+= pcmcia
- 
- obj-$(CONFIG_SCSI)		+= scsi_mod.o
-+obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
- 
- obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
- 
-@@ -158,6 +159,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
- scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
- scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
- 
-+scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
-+
- sd_mod-objs	:= sd.o
- sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
- ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
--- 
-1.4.1
-

Deleted: trunk/patch/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt
===================================================================
--- trunk/patch/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0008-scsi-tgt-SCSI-RDMA-Protocol-library-functions.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,591 +0,0 @@
-From b5ab4781574e70ed224a5dee7fe600880c98dda4 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:36:47 +0900
-Subject: [PATCH 8/9] scsi tgt: SCSI RDMA Protocol library functions
-
-libsrp provides helper functions for SRP target drivers.
-
-The next step would be to add initiator support to merge the two SRP
-initiator drivers (ibmvscsi and ib_srp) in mainline.
-
-Some SRP target drivers would be out of drivers/scsi/ so I added an
-entry for libsrp in drivers/scsi/Kconfig, though I'm not sure about
-it.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig  |    9 +
- drivers/scsi/Makefile |    1 
- drivers/scsi/libsrp.c |  441 +++++++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/libsrp.h |   79 +++++++++
- 4 files changed, 530 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 566626c..e5098d3 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -1846,6 +1846,15 @@ config ZFCP
-           called zfcp. If you want to compile it as a module, say M here
-           and read <file:Documentation/modules.txt>.
- 
-+config SCSI_SRP
-+	tristate "SCSI RDMA Protocol helper library"
-+	depends on SCSI
-+	help
-+	  If you wish to use SRP target drivers, say Y.
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called libsrp.
-+
- endmenu
- 
- source "drivers/scsi/pcmcia/Kconfig"
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index ede0c45..d71bb59 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -122,6 +122,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
- obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
-+obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
-diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
-new file mode 100644
-index 0000000..86b7718
---- /dev/null
-+++ b/drivers/scsi/libsrp.c
-@@ -0,0 +1,441 @@
-+/*
-+ * SCSI RDAM Protocol lib functions
-+ *
-+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/err.h>
-+#include <linux/kfifo.h>
-+#include <linux/scatterlist.h>
-+#include <linux/dma-mapping.h>
-+#include <linux/pci.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_tcq.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/srp.h>
-+#include <scsi/libsrp.h>
-+
-+enum srp_task_attributes {
-+	SRP_SIMPLE_TASK = 0,
-+	SRP_HEAD_TASK = 1,
-+	SRP_ORDERED_TASK = 2,
-+	SRP_ACA_TASK = 4
-+};
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
-+			     struct srp_buf **ring)
-+{
-+	int i;
-+	struct iu_entry *iue;
-+
-+	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
-+	if (!q->pool)
-+		return -ENOMEM;
-+	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
-+	if (!q->items)
-+		goto free_pool;
-+
-+	spin_lock_init(&q->lock);
-+	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
-+			      GFP_KERNEL, &q->lock);
-+	if (IS_ERR(q->queue))
-+		goto free_item;
-+
-+	for (i = 0, iue = q->items; i < max; i++) {
-+		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
-+		iue->sbuf = ring[i];
-+		iue++;
-+	}
-+	return 0;
-+
-+free_item:
-+	kfree(q->items);
-+free_pool:
-+	kfree(q->pool);
-+	return -ENOMEM;
-+}
-+
-+static void srp_iu_pool_free(struct srp_queue *q)
-+{
-+	kfree(q->items);
-+	kfree(q->pool);
-+}
-+
-+static struct srp_buf **srp_ring_alloc(struct device *dev,
-+				       size_t max, size_t size)
-+{
-+	int i;
-+	struct srp_buf **ring;
-+
-+	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
-+	if (!ring)
-+		return NULL;
-+
-+	for (i = 0; i < max; i++) {
-+		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
-+		if (!ring[i])
-+			goto out;
-+		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
-+						  GFP_KERNEL);
-+		if (!ring[i]->buf)
-+			goto out;
-+	}
-+	return ring;
-+
-+out:
-+	for (i = 0; i < max && ring[i]; i++) {
-+		if (ring[i]->buf)
-+			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+	kfree(ring);
-+
-+	return NULL;
-+}
-+
-+static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
-+			  size_t size)
-+{
-+	int i;
-+
-+	for (i = 0; i < max; i++) {
-+		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+}
-+
-+int srp_target_alloc(struct srp_target *target, struct device *dev,
-+		     size_t nr, size_t iu_size)
-+{
-+	int err;
-+
-+	spin_lock_init(&target->lock);
-+	INIT_LIST_HEAD(&target->cmd_queue);
-+
-+	target->dev = dev;
-+	target->dev->driver_data = target;
-+
-+	target->srp_iu_size = iu_size;
-+	target->rx_ring_size = nr;
-+	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
-+	if (!target->rx_ring)
-+		return -ENOMEM;
-+	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
-+	if (err)
-+		goto free_ring;
-+
-+	return 0;
-+
-+free_ring:
-+	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
-+	return -ENOMEM;
-+}
-+EXPORT_SYMBOL_GPL(srp_target_alloc);
-+
-+void srp_target_free(struct srp_target *target)
-+{
-+	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
-+		      target->srp_iu_size);
-+	srp_iu_pool_free(&target->iu_queue);
-+}
-+EXPORT_SYMBOL_GPL(srp_target_free);
-+
-+struct iu_entry *srp_iu_get(struct srp_target *target)
-+{
-+	struct iu_entry *iue = NULL;
-+
-+	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+	BUG_ON(!iue);
-+
-+	iue->target = target;
-+	INIT_LIST_HEAD(&iue->ilist);
-+	iue->flags = 0;
-+	return iue;
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_get);
-+
-+void srp_iu_put(struct iu_entry *iue)
-+{
-+	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_put);
-+
-+static int srp_direct_data(struct scsi_cmnd *sc, struct srp_direct_buf *md,
-+			   enum dma_data_direction dir, srp_rdma_t rdma_io,
-+			   int dma_map, int ext_desc)
-+{
-+	struct iu_entry *iue = NULL;
-+	struct scatterlist *sg = NULL;
-+	int err, nsg = 0, len;
-+
-+	if (dma_map) {
-+		iue = (struct iu_entry *) sc->SCp.ptr;
-+		sg = sc->request_buffer;
-+
-+		dprintk("%p %u %u %d\n", iue, sc->request_bufflen,
-+			md->len, sc->use_sg);
-+
-+		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg,
-+				 DMA_BIDIRECTIONAL);
-+		if (!nsg) {
-+			printk("fail to map %p %d\n", iue, sc->use_sg);
-+			return 0;
-+		}
-+		len = min(sc->request_bufflen, md->len);
-+	} else
-+		len = md->len;
-+
-+	err = rdma_io(sc, sg, nsg, md, 1, dir, len);
-+
-+	if (dma_map)
-+		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+	return err;
-+}
-+
-+static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
-+			     struct srp_indirect_buf *id,
-+			     enum dma_data_direction dir, srp_rdma_t rdma_io,
-+			     int dma_map, int ext_desc)
-+{
-+	struct iu_entry *iue = NULL;
-+	struct srp_direct_buf *md = NULL;
-+	struct scatterlist dummy, *sg = NULL;
-+	dma_addr_t token = 0;
-+	long err;
-+	unsigned int done = 0;
-+	int nmd, nsg = 0, len;
-+
-+	if (dma_map || ext_desc) {
-+		iue = (struct iu_entry *) sc->SCp.ptr;
-+		sg = sc->request_buffer;
-+
-+		dprintk("%p %u %u %d %d\n",
-+			iue, sc->request_bufflen, id->len,
-+			cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
-+	}
-+
-+	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
-+
-+	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
-+	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
-+		md = &id->desc_list[0];
-+		goto rdma;
-+	}
-+
-+	if (ext_desc && dma_map) {
-+		md = dma_alloc_coherent(iue->target->dev, id->table_desc.len,
-+				&token, GFP_KERNEL);
-+		if (!md) {
-+			eprintk("Can't get dma memory %u\n", id->table_desc.len);
-+			return -ENOMEM;
-+		}
-+
-+		sg_init_one(&dummy, md, id->table_desc.len);
-+		sg_dma_address(&dummy) = token;
-+		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
-+			      id->table_desc.len);
-+		if (err < 0) {
-+			eprintk("Error copying indirect table %ld\n", err);
-+			goto free_mem;
-+		}
-+	} else {
-+		eprintk("This command uses external indirect buffer\n");
-+		return -EINVAL;
-+	}
-+
-+rdma:
-+	if (dma_map) {
-+		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
-+		if (!nsg) {
-+			eprintk("fail to map %p %d\n", iue, sc->use_sg);
-+			goto free_mem;
-+		}
-+		len = min(sc->request_bufflen, id->len);
-+	} else
-+		len = id->len;
-+
-+	err = rdma_io(sc, sg, nsg, md, nmd, dir, len);
-+
-+	if (dma_map)
-+		dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+free_mem:
-+	if (token && dma_map)
-+		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
-+
-+	return done;
-+}
-+
-+static int data_out_desc_size(struct srp_cmd *cmd)
-+{
-+	int size = 0;
-+	u8 fmt = cmd->buf_fmt >> 4;
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		size = sizeof(struct srp_direct_buf);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		size = sizeof(struct srp_indirect_buf) +
-+			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
-+		break;
-+	default:
-+		eprintk("client error. Invalid data_out_format %x\n", fmt);
-+		break;
-+	}
-+	return size;
-+}
-+
-+/*
-+ * TODO: this can be called multiple times for a single command if it
-+ * has very long data.
-+ */
-+int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
-+		      srp_rdma_t rdma_io, int dma_map, int ext_desc)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	enum dma_data_direction dir;
-+	int offset, err = 0;
-+	u8 format;
-+
-+	offset = cmd->add_cdb_len * 4;
-+
-+	dir = srp_cmd_direction(cmd);
-+	if (dir == DMA_FROM_DEVICE)
-+		offset += data_out_desc_size(cmd);
-+
-+	if (dir == DMA_TO_DEVICE)
-+		format = cmd->buf_fmt >> 4;
-+	else
-+		format = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	switch (format) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *)
-+			(cmd->add_data + offset);
-+		err = srp_direct_data(sc, md, dir, rdma_io, dma_map, ext_desc);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *)
-+			(cmd->add_data + offset);
-+		err = srp_indirect_data(sc, cmd, id, dir, rdma_io, dma_map,
-+					ext_desc);
-+		break;
-+	default:
-+		eprintk("Unknown format %d %x\n", dir, format);
-+		break;
-+	}
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(srp_transfer_data);
-+
-+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int len = 0, offset = cmd->add_cdb_len * 4;
-+	u8 fmt;
-+
-+	if (dir == DMA_TO_DEVICE)
-+		fmt = cmd->buf_fmt >> 4;
-+	else {
-+		fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+		offset += data_out_desc_size(cmd);
-+	}
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *) (cmd->add_data + offset);
-+		len = md->len;
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
-+		len = id->len;
-+		break;
-+	default:
-+		eprintk("invalid data format %x\n", fmt);
-+		break;
-+	}
-+	return len;
-+}
-+
-+int srp_cmd_queue(struct Scsi_Host *shost, struct srp_cmd *cmd, void *info,
-+		  u64 addr)
-+{
-+	enum dma_data_direction dir;
-+	struct scsi_cmnd *sc;
-+	int tag, len, err;
-+
-+	switch (cmd->task_attr) {
-+	case SRP_SIMPLE_TASK:
-+		tag = MSG_SIMPLE_TAG;
-+		break;
-+	case SRP_ORDERED_TASK:
-+		tag = MSG_ORDERED_TAG;
-+		break;
-+	case SRP_HEAD_TASK:
-+		tag = MSG_HEAD_TAG;
-+		break;
-+	default:
-+		eprintk("Task attribute %d not supported\n", cmd->task_attr);
-+		tag = MSG_ORDERED_TAG;
-+	}
-+
-+	dir = srp_cmd_direction(cmd);
-+	len = vscsis_data_length(cmd, dir);
-+
-+	dprintk("%p %x %lx %d %d %d %llx\n", info, cmd->cdb[0],
-+		cmd->lun, dir, len, tag, (unsigned long long) cmd->tag);
-+
-+	sc = scsi_host_get_command(shost, dir, GFP_KERNEL);
-+	if (!sc)
-+		return -ENOMEM;
-+
-+	sc->SCp.ptr = info;
-+	memcpy(sc->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
-+	sc->request_bufflen = len;
-+	sc->request_buffer = (void *) (unsigned long) addr;
-+	sc->tag = tag;
-+	err = scsi_tgt_queue_command(sc, (struct scsi_lun *) &cmd->lun, cmd->tag);
-+	if (err)
-+		scsi_host_put_command(shost, sc);
-+
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(srp_cmd_queue);
-+
-+MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
-+MODULE_AUTHOR("FUJITA Tomonori");
-+MODULE_LICENSE("GPL");
-diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
-new file mode 100644
-index 0000000..8ec13b9
---- /dev/null
-+++ b/include/scsi/libsrp.h
-@@ -0,0 +1,79 @@
-+#ifndef __LIBSRP_H__
-+#define __LIBSRP_H__
-+
-+#include <linux/list.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/srp.h>
-+
-+enum iue_flags {
-+	V_DIOVER,
-+	V_WRITE,
-+	V_LINKED,
-+	V_FLYING,
-+};
-+
-+struct srp_buf {
-+	dma_addr_t dma;
-+	void *buf;
-+};
-+
-+struct srp_queue {
-+	void *pool;
-+	void *items;
-+	struct kfifo *queue;
-+	spinlock_t lock;
-+};
-+
-+struct srp_target {
-+	struct Scsi_Host *shost;
-+	struct device *dev;
-+
-+	spinlock_t lock;
-+	struct list_head cmd_queue;
-+
-+	size_t srp_iu_size;
-+	struct srp_queue iu_queue;
-+	size_t rx_ring_size;
-+	struct srp_buf **rx_ring;
-+
-+	/* IB needs tx_ring too */
-+
-+	void *ldata;
-+};
-+
-+struct iu_entry {
-+	struct srp_target *target;
-+
-+	struct list_head ilist;
-+	dma_addr_t remote_token;
-+	unsigned long flags;
-+
-+	struct srp_buf *sbuf;
-+};
-+
-+typedef int (srp_rdma_t)(struct scsi_cmnd *, struct scatterlist *, int,
-+			 struct srp_direct_buf *, int,
-+			 enum dma_data_direction, unsigned int);
-+extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
-+extern void srp_target_free(struct srp_target *);
-+
-+extern struct iu_entry *srp_iu_get(struct srp_target *);
-+extern void srp_iu_put(struct iu_entry *);
-+
-+extern int srp_cmd_queue(struct Scsi_Host *, struct srp_cmd *, void *, u64);
-+extern int srp_transfer_data(struct scsi_cmnd *, struct srp_cmd *,
-+			     srp_rdma_t, int, int);
-+
-+
-+static inline struct srp_target *host_to_srp_target(struct Scsi_Host *host)
-+{
-+	return (struct srp_target *) host->hostdata;
-+}
-+
-+static inline int srp_cmd_direction(struct srp_cmd *cmd)
-+{
-+	return (cmd->buf_fmt >> 4) ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-+}
-+
-+#endif
--- 
-1.4.1
-

Deleted: trunk/patch/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt
===================================================================
--- trunk/patch/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-09-01 03:32:55 UTC (rev 578)
+++ trunk/patch/0009-scsi-tgt-IBM-eServer-i-pSeries-virtual-SCSI-target-driver.txt	2006-09-01 04:27:49 UTC (rev 579)
@@ -1,1028 +0,0 @@
-From eed708a465130a096f3ce2892198ed77ef2504b8 Mon Sep 17 00:00:00 2001
-From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Date: Fri, 18 Aug 2006 00:41:02 +0900
-Subject: [PATCH 9/9] scsi tgt: IBM eServer i/pSeries virtual SCSI target driver
-
-This is IBM Virtual SCSI target driver for tgt. The driver is based on
-the original ibmvscsis driver:
-
-http://lkml.org/lkml/2005/10/17/99
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-Signed-off-by: James Bottomley <James.Bottomley at SteelEye.com>
----
- drivers/scsi/Kconfig             |   14 +
- drivers/scsi/Makefile            |    1 
- drivers/scsi/ibmvscsi/Makefile   |    2 
- drivers/scsi/ibmvscsi/ibmvstgt.c |  952 ++++++++++++++++++++++++++++++++++++++
- 4 files changed, 969 insertions(+), 0 deletions(-)
-
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index e5098d3..c25154c 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -917,6 +917,20 @@ config SCSI_IBMVSCSI
- 	  To compile this driver as a module, choose M here: the
- 	  module will be called ibmvscsic.
- 
-+config SCSI_IBMVSCSIS
-+	tristate "IBM Virtual SCSI Server support"
-+	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
-+	help
-+	  This is the SRP target driver for IBM pSeries virtual environments.
-+
-+	  The userspace component needed to initialize the driver and
-+	  documentation can be found:
-+
-+	  http://stgt.berlios.de/
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called ibmvstgt.
-+
- config SCSI_INITIO
- 	tristate "Initio 9100U(W) support"
- 	depends on PCI && SCSI
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index d71bb59..78544e3 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
- obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
- obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
-diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
-index 4e247b6..6ac0633 100644
---- a/drivers/scsi/ibmvscsi/Makefile
-+++ b/drivers/scsi/ibmvscsi/Makefile
-@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
- ibmvscsic-y			+= ibmvscsi.o
- ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
- ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
-+
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
-diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
-new file mode 100644
-index 0000000..7a98517
---- /dev/null
-+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
-@@ -0,0 +1,952 @@
-+/*
-+ * IBM eServer i/pSeries Virtual SCSI Target Driver
-+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
-+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
-+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
-+ *
-+ * Copyright (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-+ * USA
-+ */
-+#include <linux/interrupt.h>
-+#include <linux/module.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/libsrp.h>
-+#include <asm/hvcall.h>
-+#include <asm/iommu.h>
-+#include <asm/prom.h>
-+#include <asm/vio.h>
-+
-+#include "ibmvscsi.h"
-+
-+#define	INITIAL_SRP_LIMIT	16
-+#define	DEFAULT_MAX_SECTORS	512
-+
-+#define	TGT_NAME	"ibmvstgt"
-+
-+/*
-+ * Hypervisor calls.
-+ */
-+#define h_copy_rdma(l, sa, sb, da, db) \
-+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
-+#define h_send_crq(ua, l, h) \
-+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
-+#define h_reg_crq(ua, tok, sz)\
-+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
-+#define h_free_crq(ua) \
-+			plpar_hcall_norets(H_FREE_CRQ, ua);
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+struct vio_port {
-+	struct vio_dev *dma_dev;
-+
-+	struct crq_queue crq_queue;
-+	struct work_struct crq_work;
-+
-+	unsigned long liobn;
-+	unsigned long riobn;
-+};
-+
-+static struct workqueue_struct *vtgtd;
-+
-+/*
-+ * These are fixed for the system and come from the Open Firmware device tree.
-+ * We just store them here to save getting them every time.
-+ */
-+static char system_id[64] = "";
-+static char partition_name[97] = "UNKNOWN";
-+static unsigned int partition_number = -1;
-+
-+static struct vio_port *target_to_port(struct srp_target *target)
-+{
-+	return (struct vio_port *) target->ldata;
-+}
-+
-+static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
-+{
-+	return (union viosrp_iu *) (iue->sbuf->buf);
-+}
-+
-+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	long rc, rc1;
-+	union {
-+		struct viosrp_crq cooked;
-+		uint64_t raw[2];
-+	} crq;
-+
-+	/* First copy the SRP */
-+	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
-+			 vport->riobn, iue->remote_token);
-+
-+	if (rc)
-+		eprintk("Error %ld transferring data\n", rc);
-+
-+	crq.cooked.valid = 0x80;
-+	crq.cooked.format = format;
-+	crq.cooked.reserved = 0x00;
-+	crq.cooked.timeout = 0x00;
-+	crq.cooked.IU_length = length;
-+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
-+
-+	if (rc == 0)
-+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
-+	else
-+		crq.cooked.status = 0x00;
-+
-+	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
-+
-+	if (rc1) {
-+		eprintk("%ld sending response\n", rc1);
-+		return rc1;
-+	}
-+
-+	return rc;
-+}
-+
-+#define SRP_RSP_SENSE_DATA_LEN	18
-+
-+static int send_rsp(struct iu_entry *iue, struct scsi_cmnd *sc,
-+		    unsigned char status, unsigned char asc)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* If the linked bit is on and status is good */
-+	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
-+		status = 0x10;
-+
-+	memset(iu, 0, sizeof(struct srp_rsp));
-+	iu->srp.rsp.opcode = SRP_RSP;
-+	iu->srp.rsp.req_lim_delta = 1;
-+	iu->srp.rsp.tag = tag;
-+
-+	if (test_bit(V_DIOVER, &iue->flags))
-+		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
-+
-+	iu->srp.rsp.data_in_res_cnt = 0;
-+	iu->srp.rsp.data_out_res_cnt = 0;
-+
-+	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
-+
-+	iu->srp.rsp.resp_data_len = 0;
-+	iu->srp.rsp.status = status;
-+	if (status) {
-+		uint8_t *sense = iu->srp.rsp.data;
-+
-+		if (sc) {
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
-+			memcpy(sense, sc->sense_buffer, SCSI_SENSE_BUFFERSIZE);
-+		} else {
-+			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
-+
-+			/* Valid bit and 'current errors' */
-+			sense[0] = (0x1 << 7 | 0x70);
-+			/* Sense key */
-+			sense[2] = status;
-+			/* Additional sense length */
-+			sense[7] = 0xa;	/* 10 bytes */
-+			/* Additional sense code */
-+			sense[12] = asc;
-+		}
-+	}
-+
-+	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
-+		VIOSRP_SRP_FORMAT);
-+
-+	return 0;
-+}
-+
-+static void handle_cmd_queue(struct srp_target *target)
-+{
-+	struct Scsi_Host *shost = target->shost;
-+	struct iu_entry *iue;
-+	struct srp_cmd *cmd;
-+	unsigned long flags;
-+	int err;
-+
-+retry:
-+	spin_lock_irqsave(&target->lock, flags);
-+
-+	list_for_each_entry(iue, &target->cmd_queue, ilist) {
-+		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
-+			spin_unlock_irqrestore(&target->lock, flags);
-+			cmd = iue->sbuf->buf;
-+			err = srp_cmd_queue(shost, cmd, iue, 0);
-+			if (err) {
-+				eprintk("cannot queue cmd %p %d\n", cmd, err);
-+				srp_iu_put(iue);
-+			}
-+			goto retry;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
-+			 struct srp_direct_buf *md, int nmd,
-+			 enum dma_data_direction dir, unsigned int rest)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	dma_addr_t token;
-+	long err;
-+	unsigned int done = 0;
-+	int i, sidx, soff;
-+
-+	sidx = soff = 0;
-+	token = sg_dma_address(sg + sidx);
-+
-+	for (i = 0; i < nmd && rest; i++) {
-+		unsigned int mdone, mlen;
-+
-+		mlen = min(rest, md[i].len);
-+		for (mdone = 0; mlen;) {
-+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
-+
-+			if (dir == DMA_TO_DEVICE)
-+				err = h_copy_rdma(slen,
-+						  vport->riobn,
-+						  md[i].va + mdone,
-+						  vport->liobn,
-+						  token + soff);
-+			else
-+				err = h_copy_rdma(slen,
-+						  vport->liobn,
-+						  token + soff,
-+						  vport->riobn,
-+						  md[i].va + mdone);
-+
-+			if (err != H_SUCCESS) {
-+				eprintk("rdma error %d %d\n", dir, slen);
-+				goto out;
-+			}
-+
-+			mlen -= slen;
-+			mdone += slen;
-+			soff += slen;
-+			done += slen;
-+
-+			if (soff == sg_dma_len(sg + sidx)) {
-+				sidx++;
-+				soff = 0;
-+				token = sg_dma_address(sg + sidx);
-+
-+				if (sidx > nsg) {
-+					eprintk("out of sg %p %d %d\n",
-+						iue, sidx, nsg);
-+					goto out;
-+				}
-+			}
-+		};
-+
-+		rest -= mlen;
-+	}
-+out:
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_transfer_data(struct scsi_cmnd *sc,
-+				  void (*done)(struct scsi_cmnd *))
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) sc->SCp.ptr;
-+	int err;
-+
-+	err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
-+
-+	done(sc);
-+
-+	return err;
-+}
-+
-+static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
-+			     void (*done)(struct scsi_cmnd *))
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	if (sc->result != SAM_STAT_GOOD) {
-+		eprintk("operation failed %p %d %x\n",
-+			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
-+		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
-+	} else
-+		send_rsp(iue, sc, NO_SENSE, 0x00);
-+
-+	done(sc);
-+	srp_iu_put(iue);
-+	return 0;
-+}
-+
-+int send_adapter_info(struct iu_entry *iue,
-+		      dma_addr_t remote_buffer, uint16_t length)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	struct Scsi_Host *shost = target->shost;
-+	dma_addr_t data_token;
-+	struct mad_adapter_info_data *info;
-+	int err;
-+
-+	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
-+				  GFP_KERNEL);
-+	if (!info) {
-+		eprintk("bad dma_alloc_coherent %p\n", target);
-+		return 1;
-+	}
-+
-+	/* Get remote info */
-+	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
-+			  vport->liobn, data_token);
-+	if (err == H_SUCCESS) {
-+		dprintk("Client connect: %s (%d)\n",
-+			info->partition_name, info->partition_number);
-+	}
-+
-+	memset(info, 0, sizeof(*info));
-+
-+	strcpy(info->srp_version, "16.a");
-+	strncpy(info->partition_name, partition_name,
-+		sizeof(info->partition_name));
-+	info->partition_number = partition_number;
-+	info->mad_version = 1;
-+	info->os_type = 2;
-+	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
-+
-+	/* Send our info to remote */
-+	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
-+			  vport->riobn, remote_buffer);
-+
-+	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
-+
-+	if (err != H_SUCCESS) {
-+		eprintk("Error sending adapter info %d\n", err);
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static void process_login(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* TODO handle case that requested size is wrong and
-+	 * buffer format is wrong
-+	 */
-+	memset(iu, 0, sizeof(struct srp_login_rsp));
-+	rsp->opcode = SRP_LOGIN_RSP;
-+	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
-+	rsp->tag = tag;
-+	rsp->max_it_iu_len = sizeof(union srp_iu);
-+	rsp->max_ti_iu_len = sizeof(union srp_iu);
-+	/* direct and indirect */
-+	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
-+
-+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
-+}
-+
-+static inline void queue_cmd(struct iu_entry *iue)
-+{
-+	struct srp_target *target = iue->target;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_add_tail(&iue->ilist, &target->cmd_queue);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int process_tsk_mgmt(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int fn;
-+
-+	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		fn = ABORT_TASK;
-+		break;
-+	case SRP_TSK_ABORT_TASK_SET:
-+		fn = ABORT_TASK_SET;
-+		break;
-+	case SRP_TSK_CLEAR_TASK_SET:
-+		fn = CLEAR_TASK_SET;
-+		break;
-+	case SRP_TSK_LUN_RESET:
-+		fn = LOGICAL_UNIT_RESET;
-+		break;
-+	case SRP_TSK_CLEAR_ACA:
-+		fn = CLEAR_ACA;
-+		break;
-+	default:
-+		fn = 0;
-+	}
-+	if (fn)
-+		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
-+					  iu->srp.tsk_mgmt.task_tag,
-+					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
-+					  iue);
-+	else
-+		send_rsp(iue, NULL, ILLEGAL_REQUEST, 0x20);
-+
-+	return !fn;
-+}
-+
-+static int process_mad_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct viosrp_adapter_info *info;
-+	struct viosrp_host_config *conf;
-+
-+	switch (iu->mad.empty_iu.common.type) {
-+	case VIOSRP_EMPTY_IU_TYPE:
-+		eprintk("%s\n", "Unsupported EMPTY MAD IU");
-+		break;
-+	case VIOSRP_ERROR_LOG_TYPE:
-+		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
-+		iu->mad.error_log.common.status = 1;
-+		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_ADAPTER_INFO_TYPE:
-+		info = &iu->mad.adapter_info;
-+		info->common.status = send_adapter_info(iue, info->buffer,
-+							info->common.length);
-+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_HOST_CONFIG_TYPE:
-+		conf = &iu->mad.host_config;
-+		conf->common.status = 1;
-+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
-+	}
-+
-+	return 1;
-+}
-+
-+static int process_srp_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int done = 1;
-+	u8 opcode = iu->srp.rsp.opcode;
-+
-+	switch (opcode) {
-+	case SRP_LOGIN_REQ:
-+		process_login(iue);
-+		break;
-+	case SRP_TSK_MGMT:
-+		done = process_tsk_mgmt(iue);
-+		break;
-+	case SRP_CMD:
-+		queue_cmd(iue);
-+		done = 0;
-+		break;
-+	case SRP_LOGIN_RSP:
-+	case SRP_I_LOGOUT:
-+	case SRP_T_LOGOUT:
-+	case SRP_RSP:
-+	case SRP_CRED_REQ:
-+	case SRP_CRED_RSP:
-+	case SRP_AER_REQ:
-+	case SRP_AER_RSP:
-+		eprintk("Unsupported type %u\n", opcode);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", opcode);
-+	}
-+
-+	return done;
-+}
-+
-+static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct iu_entry *iue;
-+	long err, done;
-+
-+	iue = srp_iu_get(target);
-+	if (!iue) {
-+		eprintk("Error getting IU from pool, %p\n", target);
-+		return;
-+	}
-+
-+	iue->remote_token = crq->IU_data_ptr;
-+
-+	err = h_copy_rdma(crq->IU_length, vport->riobn,
-+			  iue->remote_token, vport->liobn, iue->sbuf->dma);
-+
-+	if (err != H_SUCCESS)
-+		eprintk("%ld transferring data error %p\n", err, iue);
-+
-+	if (crq->format == VIOSRP_MAD_FORMAT)
-+		done = process_mad_iu(iue);
-+	else
-+		done = process_srp_iu(iue);
-+
-+	if (done)
-+		srp_iu_put(iue);
-+}
-+
-+static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	vio_disable_interrupts(vport->dma_dev);
-+	queue_work(vtgtd, &vport->crq_work);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
-+{
-+	int err;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
-+	if (!queue->msgs)
-+		goto malloc_failed;
-+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
-+
-+	queue->msg_token = dma_map_single(target->dev, queue->msgs,
-+					  queue->size * sizeof(*queue->msgs),
-+					  DMA_BIDIRECTIONAL);
-+
-+	if (dma_mapping_error(queue->msg_token))
-+		goto map_failed;
-+
-+	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			PAGE_SIZE);
-+
-+	/* If the adapter was left active for some reason (like kexec)
-+	 * try freeing and re-registering
-+	 */
-+	if (err == H_RESOURCE) {
-+	    do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	    } while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			    PAGE_SIZE);
-+	}
-+
-+	if (err != H_SUCCESS && err != 2) {
-+		eprintk("Error 0x%x opening virtual adapter\n", err);
-+		goto reg_crq_failed;
-+	}
-+
-+	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
-+			  SA_INTERRUPT, "ibmvstgt", target);
-+	if (err)
-+		goto req_irq_failed;
-+
-+	vio_enable_interrupts(vport->dma_dev);
-+
-+	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
-+
-+	queue->cur = 0;
-+	spin_lock_init(&queue->lock);
-+
-+	return 0;
-+
-+req_irq_failed:
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+reg_crq_failed:
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+map_failed:
-+	free_page((unsigned long) queue->msgs);
-+
-+malloc_failed:
-+	return -ENOMEM;
-+}
-+
-+static void crq_queue_destroy(struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct crq_queue *queue = &vport->crq_queue;
-+	int err;
-+
-+	free_irq(vport->dma_dev->irq, target);
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_BUSY || H_IS_LONG_BUSY(err));
-+
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+
-+	free_page((unsigned long) queue->msgs);
-+}
-+
-+static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	dprintk("%x %x\n", crq->valid, crq->format);
-+
-+	switch (crq->valid) {
-+	case 0xC0:
-+		/* initialization */
-+		switch (crq->format) {
-+		case 0x01:
-+			h_send_crq(vport->dma_dev->unit_address,
-+				   0xC002000000000000, 0);
-+			break;
-+		case 0x02:
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	case 0xFF:
-+		/* transport event */
-+		break;
-+	case 0x80:
-+		/* real payload */
-+		switch (crq->format) {
-+		case VIOSRP_SRP_FORMAT:
-+		case VIOSRP_MAD_FORMAT:
-+			process_iu(crq, target);
-+			break;
-+		case VIOSRP_OS400_FORMAT:
-+		case VIOSRP_AIX_FORMAT:
-+		case VIOSRP_LINUX_FORMAT:
-+		case VIOSRP_INLINE_FORMAT:
-+			eprintk("Unsupported format %u\n", crq->format);
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	default:
-+		eprintk("unknown message type 0x%02x!?\n", crq->valid);
-+	}
-+}
-+
-+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
-+{
-+	struct viosrp_crq *crq;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&queue->lock, flags);
-+	crq = &queue->msgs[queue->cur];
-+	if (crq->valid & 0x80) {
-+		if (++queue->cur == queue->size)
-+			queue->cur = 0;
-+	} else
-+		crq = NULL;
-+	spin_unlock_irqrestore(&queue->lock, flags);
-+
-+	return crq;
-+}
-+
-+static void handle_crq(void *data)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+	struct viosrp_crq *crq;
-+	int done = 0;
-+
-+	while (!done) {
-+		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		}
-+
-+		vio_enable_interrupts(vport->dma_dev);
-+
-+		crq = next_crq(&vport->crq_queue);
-+		if (crq) {
-+			vio_disable_interrupts(vport->dma_dev);
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		} else
-+			done = 1;
-+	}
-+
-+	handle_cmd_queue(target);
-+}
-+
-+
-+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *sc)
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
-+	union viosrp_iu *iu = vio_iu(iue);
-+	unsigned char status, asc;
-+
-+	eprintk("%p %d\n", iue, result);
-+	status = NO_SENSE;
-+	asc = 0;
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		asc = 0x14;
-+		if (result)
-+			status = ABORTED_COMMAND;
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	send_rsp(iue, NULL, status, asc);
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static ssize_t system_id_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
-+}
-+
-+static ssize_t partition_number_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
-+}
-+
-+static ssize_t unit_address_show(struct class_device *cdev, char *buf)
-+{
-+	struct Scsi_Host *shost = class_to_shost(cdev);
-+	struct srp_target *target = host_to_srp_target(shost);
-+	struct vio_port *vport = target_to_port(target);
-+	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
-+}
-+
-+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
-+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
-+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
-+
-+static struct class_device_attribute *ibmvstgt_attrs[] = {
-+	&class_device_attr_system_id,
-+	&class_device_attr_partition_number,
-+	&class_device_attr_unit_address,
-+	NULL,
-+};
-+
-+static struct scsi_host_template ibmvstgt_sht = {
-+	.name			= TGT_NAME,
-+	.module			= THIS_MODULE,
-+	.can_queue		= INITIAL_SRP_LIMIT,
-+	.sg_tablesize		= SG_ALL,
-+	.use_clustering		= DISABLE_CLUSTERING,
-+	.max_sectors		= DEFAULT_MAX_SECTORS,
-+	.transfer_response	= ibmvstgt_cmd_done,
-+	.transfer_data		= ibmvstgt_transfer_data,
-+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
-+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
-+	.shost_attrs		= ibmvstgt_attrs,
-+	.proc_name		= TGT_NAME,
-+};
-+
-+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
-+{
-+	struct Scsi_Host *shost;
-+	struct srp_target *target;
-+	struct vio_port *vport;
-+	unsigned int *dma, dma_size;
-+	int err = -ENOMEM;
-+
-+	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
-+	if (!vport)
-+		return err;
-+	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
-+	if (!shost)
-+		goto free_vport;
-+	err = scsi_tgt_alloc_queue(shost);
-+	if (err)
-+		goto put_host;
-+
-+	target = host_to_srp_target(shost);
-+	target->shost = shost;
-+	vport->dma_dev = dev;
-+	target->ldata = vport;
-+	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
-+			       SRP_MAX_IU_LEN);
-+	if (err)
-+		goto put_host;
-+
-+	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
-+						 &dma_size);
-+	if (!dma || dma_size != 40) {
-+		eprintk("Couldn't get window property %d\n", dma_size);
-+		err = -EIO;
-+		goto free_srp_target;
-+	}
-+	vport->liobn = dma[0];
-+	vport->riobn = dma[5];
-+
-+	INIT_WORK(&vport->crq_work, handle_crq, target);
-+
-+	err = crq_queue_create(&vport->crq_queue, target);
-+	if (err)
-+		goto free_srp_target;
-+
-+	err = scsi_add_host(shost, target->dev);
-+	if (err)
-+		goto destroy_queue;
-+	return 0;
-+
-+destroy_queue:
-+	crq_queue_destroy(target);
-+free_srp_target:
-+	srp_target_free(target);
-+put_host:
-+	scsi_host_put(shost);
-+free_vport:
-+	kfree(vport);
-+	return err;
-+}
-+
-+static int ibmvstgt_remove(struct vio_dev *dev)
-+{
-+	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
-+	struct Scsi_Host *shost = target->shost;
-+
-+	srp_target_free(target);
-+	crq_queue_destroy(target);
-+	scsi_remove_host(shost);
-+	scsi_host_put(shost);
-+	return 0;
-+}
-+
-+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
-+	{"v-scsi-host", "IBM,v-scsi-host"},
-+	{"",""}
-+};
-+
-+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
-+
-+static struct vio_driver ibmvstgt_driver = {
-+	.id_table = ibmvstgt_device_table,
-+	.probe = ibmvstgt_probe,
-+	.remove = ibmvstgt_remove,
-+	.driver = {
-+		.name = "ibmvscsis",
-+		.owner = THIS_MODULE,
-+	}
-+};
-+
-+static int get_system_info(void)
-+{
-+	struct device_node *rootdn;
-+	char *id, *model, *name;
-+	unsigned int *num;
-+
-+	rootdn = find_path_device("/");
-+	if (!rootdn)
-+		return -ENOENT;
-+
-+	model = get_property(rootdn, "model", NULL);
-+	id = get_property(rootdn, "system-id", NULL);
-+	if (model && id)
-+		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
-+
-+	name = get_property(rootdn, "ibm,partition-name", NULL);
-+	if (name)
-+		strncpy(partition_name, name, sizeof(partition_name));
-+
-+	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
-+	if (num)
-+		partition_number = *num;
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_init(void)
-+{
-+	int err = -ENOMEM;
-+
-+	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
-+
-+	vtgtd = create_workqueue("ibmvtgtd");
-+	if (!vtgtd)
-+		return err;
-+
-+	err = get_system_info();
-+	if (err)
-+		goto destroy_wq;
-+
-+	err = vio_register_driver(&ibmvstgt_driver);
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(vtgtd);
-+	return err;
-+}
-+
-+static void ibmvstgt_exit(void)
-+{
-+	printk("Unregister IBM virtual SCSI driver\n");
-+
-+	destroy_workqueue(vtgtd);
-+	vio_unregister_driver(&ibmvstgt_driver);
-+}
-+
-+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
-+MODULE_AUTHOR("Dave Boutcher");
-+MODULE_LICENSE("GPL");
-+
-+module_init(ibmvstgt_init);
-+module_exit(ibmvstgt_exit);
--- 
-1.4.1
-



From tomo at mail.berlios.de  Fri Sep  1 10:37:42 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 10:37:42 +0200
Subject: [Stgt-svn] r580 - in trunk/usr: . iscsi
Message-ID: <200609010837.k818bg2e017894@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 10:37:42 +0200 (Fri, 01 Sep 2006)
New Revision: 580

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/util.h
Log:
Honor iSCSI command sequence.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 04:27:49 UTC (rev 579)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 08:37:42 UTC (rev 580)
@@ -26,6 +26,8 @@
 #include "tgtd.h"
 #include "util.h"
 
+#define MAX_QUEUE_CMD	32
+
 static struct iscsi_key login_keys[] = {
 	{"InitiatorName",},
 	{"InitiatorAlias",},
@@ -744,8 +746,8 @@
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = ctask->result;
 	rsp->statsn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
-	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
 	return 0;
 }
@@ -789,8 +791,8 @@
 
 	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
 		rsp->statsn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmdsn = cpu_to_be32(conn->exp_cmd_sn);
-	rsp->max_cmdsn = cpu_to_be32(conn->exp_cmd_sn + 8);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
 	conn->rsp.datasize = datalen;
 	hton24(rsp->dlength, datalen);
@@ -851,7 +853,7 @@
 	ctask->len = len;
 	ctask->rw = rw;
 
-	list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+	list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
 	tgt_event_modify(ctask->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
@@ -914,9 +916,6 @@
 		dprintf("%p\n", ctask->c_buffer);
 	}
 
-	conn->exp_cmd_sn++;
-	conn->rx_ctask = ctask;
-
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		conn->rx_size = ntoh24(req->dlength);
 		conn->rx_buffer = ctask->c_buffer;
@@ -928,6 +927,8 @@
 			ctask->unsol_count, ctask->offset);
 	}
 
+	conn->rx_ctask = ctask;
+
 	return 0;
 }
 
@@ -963,7 +964,7 @@
 			if (ctask->unsol_count)
 				;
 			else
-				list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+				list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
 		} else
 			err = target_cmd_queue(conn->session->tsih, req->cdb,
 					       uaddr, req->lun,
@@ -980,6 +981,56 @@
 	return err;
 }
 
+int iscsi_task_queue(struct iscsi_ctask *ctask)
+{
+	struct session *session = ctask->conn->session;
+	struct iscsi_hdr *req = (struct iscsi_hdr *) &ctask->req;
+	uint32_t cmd_sn;
+	struct iscsi_ctask *ent;
+
+	if (req->opcode & ISCSI_OP_IMMEDIATE) {
+		__iscsi_cmd_rx_done(ctask);
+		return 0;
+	}
+
+	dprintf("%x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn);
+	cmd_sn = be32_to_cpu(req->statsn);
+	if (cmd_sn == session->exp_cmd_sn) {
+	retry:
+		session->exp_cmd_sn = ++cmd_sn;
+
+		__iscsi_cmd_rx_done(ctask);
+
+		if (list_empty(&session->pending_cmd_list))
+			return 0;
+		ctask = list_entry(session->pending_cmd_list.next,
+				   struct iscsi_ctask, c_list);
+		if (be32_to_cpu(ctask->req.statsn) != cmd_sn)
+			return 0;
+
+		list_del(&ctask->c_list);
+		clear_task_pending(ctask);
+		goto retry;
+	} else {
+		if (before(cmd_sn, session->exp_cmd_sn)) {
+			eprintf("unexpected cmd_sn (%u,%u)\n",
+				cmd_sn, session->exp_cmd_sn);
+			return -EINVAL;
+		}
+
+		/* TODO: check max cmd_sn */
+
+		list_for_each_entry(ent, &session->pending_cmd_list, c_list) {
+			if (before(cmd_sn, be32_to_cpu(ent->req.statsn)))
+				break;
+		}
+
+		list_add_tail(&ctask->c_list, &ent->c_list);
+		set_task_pending(ctask);
+	}
+	return 0;
+}
+
 int iscsi_cmd_rx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
@@ -991,12 +1042,12 @@
 	op = hdr->opcode & ISCSI_OPCODE_MASK;
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
-		__iscsi_cmd_rx_done(ctask);
+		err = iscsi_task_queue(ctask);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		if (ctask->r2t_count) {
 			dprintf("%x %d\n", hdr->itt, ctask->r2t_count);
-			list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+			list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
 			tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
 		} else
 			err = target_cmd_queue(conn->session->tsih, req->cdb,
@@ -1064,7 +1115,7 @@
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
 			dprintf("more data %x\n", hdr->itt);
-			list_add_tail(&ctask->c_txlist, &ctask->conn->tx_clist);
+			list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
 			goto out;
 		}
 	default:
@@ -1097,14 +1148,14 @@
 
 	conn_write_pdu(conn);
 
-	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_txlist);
+	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_list);
 	conn->tx_ctask = ctask;
 	dprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
 		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
 		ctask->offset,
 		ctask->r2t_count);
 
-	list_del(&ctask->c_txlist);
+	list_del(&ctask->c_list);
 
 	req = (struct iscsi_cmd *) &ctask->req;
 
@@ -1387,9 +1438,12 @@
 	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
 		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (fd < 0) {
-			eprintf("unable to create fdet %d %d %d, %m\n",
-				res->ai_family,	res->ai_socktype,
-				res->ai_protocol);
+			if (res->ai_family == AF_INET6)
+				dprintf("IPv6 support is disabled.\n");
+			else
+				eprintf("unable to create fdet %d %d %d, %m\n",
+					res->ai_family,	res->ai_socktype,
+					res->ai_protocol);
 			continue;
 		}
 

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-01 04:27:49 UTC (rev 579)
+++ trunk/usr/iscsi/iscsid.h	2006-09-01 08:37:42 UTC (rev 580)
@@ -52,7 +52,10 @@
 #define KEY_STATE_DONE		2
 
 struct session {
+	/* linked to target->sessions_list */
 	struct list_head slist;
+
+	/* linked to sessions_list */
 	struct list_head hlist;
 
 	char *initiator;
@@ -60,10 +63,17 @@
 	uint8_t isid[6];
 	uint16_t tsih;
 
+	/* links all connections (conn->clist) */
 	struct list_head conn_list;
 	int conn_cnt;
 
+	/* links all tasks (ctask->c_hlist) */
 	struct list_head cmd_list;
+
+	/* links pending tasks (ctask->c_list) */
+	struct list_head pending_cmd_list;
+
+	uint32_t exp_cmd_sn;
 };
 
 struct iscsi_ctask {
@@ -73,9 +83,14 @@
 	uint64_t tag;
 	struct connection *conn;
 
+	/* linked to session->cmd_list */
 	struct list_head c_hlist;
-	struct list_head c_txlist;
 
+	/* linked to conn->tx_clist or session->cmd_pending_list */
+	struct list_head c_list;
+
+	unsigned long flags;
+
 	uint64_t addr;
 	int result;
 	int len;
@@ -194,6 +209,14 @@
 	int nr_sessions;
 };
 
+enum task_flags {
+	TASK_pending,
+};
+
+#define set_task_pending(t)	((t)->flags |= (1 << TASK_pending))
+#define clear_task_pending(t)	((t)->flags &= ~(1 << TASK_pending))
+#define task_pending(t)		((t)->flags & (1 << TASK_pending))
+
 /* chap.c */
 extern int cmnd_exec_auth_chap(struct connection *conn);
 

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-09-01 04:27:49 UTC (rev 579)
+++ trunk/usr/iscsi/session.c	2006-09-01 08:37:42 UTC (rev 580)
@@ -78,6 +78,7 @@
 
 	INIT_LIST_HEAD(&session->conn_list);
 	INIT_LIST_HEAD(&session->cmd_list);
+	INIT_LIST_HEAD(&session->pending_cmd_list);
 
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = last_tsih = tsih;
@@ -88,6 +89,7 @@
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
 
 	list_add(&session->hlist, &sessions_list);
+	session->exp_cmd_sn = conn->exp_cmd_sn;
 
 	return 0;
 }

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-09-01 04:27:49 UTC (rev 579)
+++ trunk/usr/util.h	2006-09-01 08:37:42 UTC (rev 580)
@@ -47,4 +47,20 @@
 	ptr;				\
 })
 
+static inline int before(uint32_t seq1, uint32_t seq2)
+{
+        return (int32_t)(seq1 - seq2) < 0;
+}
+
+static inline int after(uint32_t seq1, uint32_t seq2)
+{
+	return (int32_t)(seq2 - seq1) < 0;
+}
+
+/* is s2<=s1<=s3 ? */
+static inline int between(uint32_t seq1, uint32_t seq2, uint32_t seq3)
+{
+	return seq3 - seq2 >= seq1 - seq2;
+}
+
 #endif



From tomo at mail.berlios.de  Fri Sep  1 11:13:03 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 11:13:03 +0200
Subject: [Stgt-svn] r581 - trunk/usr/iscsi
Message-ID: <200609010913.k819D3nj022634@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 11:13:02 +0200 (Fri, 01 Sep 2006)
New Revision: 581

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Rename __iscsi_cmd_rx_done iscsi_scsi_cmd_execute.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 08:37:42 UTC (rev 580)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 09:13:02 UTC (rev 581)
@@ -685,7 +685,7 @@
 	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 }
 
-int cmnd_execute(struct connection *conn)
+static int cmnd_execute(struct connection *conn)
 {
 	int res = 0;
 
@@ -714,7 +714,7 @@
 	return res;
 }
 
-void cmnd_finish(struct connection *conn)
+static void cmnd_finish(struct connection *conn)
 {
 	switch (conn->state) {
 	case STATE_EXIT:
@@ -932,7 +932,7 @@
 	return 0;
 }
 
-int cmd_attr(struct iscsi_ctask *ctask)
+static int cmd_attr(struct iscsi_ctask *ctask)
 {
 	int attr;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
@@ -952,7 +952,7 @@
 	return attr;
 }
 
-static int __iscsi_cmd_rx_done(struct iscsi_ctask *ctask)
+static int iscsi_scsi_cmd_execute(struct iscsi_ctask *ctask)
 {
 	struct connection *conn = ctask->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
@@ -981,16 +981,45 @@
 	return err;
 }
 
-int iscsi_task_queue(struct iscsi_ctask *ctask)
+static int iscsi_task_execute(struct iscsi_ctask *task)
 {
+	struct iscsi_hdr *hdr = (struct iscsi_hdr *) &task->req;
+	uint8_t op = hdr->opcode & ISCSI_OPCODE_MASK;
+	int err;
+
+	switch (op) {
+	case ISCSI_OP_NOOP_OUT:
+/* 		noop_out_exec(cmnd); */
+		break;
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_scsi_cmd_execute(task);
+		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+/* 		execute_task_management(cmnd); */
+		break;
+	case ISCSI_OP_LOGOUT:
+/* 		logout_exec(cmnd); */
+		break;
+	case ISCSI_OP_TEXT:
+	case ISCSI_OP_SNACK:
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int iscsi_task_queue(struct iscsi_ctask *ctask)
+{
 	struct session *session = ctask->conn->session;
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &ctask->req;
 	uint32_t cmd_sn;
 	struct iscsi_ctask *ent;
+	int err;
 
 	if (req->opcode & ISCSI_OP_IMMEDIATE) {
-		__iscsi_cmd_rx_done(ctask);
-		return 0;
+		return iscsi_task_execute(ctask);
 	}
 
 	dprintf("%x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn);
@@ -999,7 +1028,8 @@
 	retry:
 		session->exp_cmd_sn = ++cmd_sn;
 
-		__iscsi_cmd_rx_done(ctask);
+		/* Should we close the connection... */
+		err = iscsi_task_execute(ctask);
 
 		if (list_empty(&session->pending_cmd_list))
 			return 0;
@@ -1031,7 +1061,7 @@
 	return 0;
 }
 
-int iscsi_cmd_rx_done(struct connection *conn)
+static int iscsi_cmd_rx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	struct iscsi_ctask *ctask = conn->rx_ctask;
@@ -1070,7 +1100,7 @@
 	return err;
 }
 
-int iscsi_cmd_rx_start(struct connection *conn)
+static int iscsi_cmd_rx_start(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	uint8_t op;
@@ -1104,7 +1134,7 @@
 	return 0;
 }
 
-int iscsi_cmd_tx_done(struct connection *conn)
+static int iscsi_cmd_tx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
 	struct iscsi_ctask *ctask = conn->tx_ctask;
@@ -1134,7 +1164,7 @@
 	return 0;
 }
 
-int iscsi_cmd_tx_start(struct connection *conn)
+static int iscsi_cmd_tx_start(struct connection *conn)
 {
 	struct iscsi_ctask *ctask;
 	struct iscsi_cmd *req;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-01 08:37:42 UTC (rev 580)
+++ trunk/usr/iscsi/iscsid.h	2006-09-01 09:13:02 UTC (rev 581)
@@ -230,8 +230,6 @@
 extern void conn_add_to_session(struct connection *conn, struct session *session);
 
 /* iscsid.c */
-extern int cmnd_execute(struct connection *conn);
-extern void cmnd_finish(struct connection *conn);
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
 



From tomo at mail.berlios.de  Fri Sep  1 18:12:09 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 18:12:09 +0200
Subject: [Stgt-svn] r582 - trunk/usr/iscsi
Message-ID: <200609011612.k81GC9eB003242@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 18:12:09 +0200 (Fri, 01 Sep 2006)
New Revision: 582

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
Fix wrong padding bug.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 09:13:02 UTC (rev 581)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 16:12:09 UTC (rev 582)
@@ -859,79 +859,6 @@
 	return 0;
 }
 
-static int iscsi_data_out_rx_start(struct connection *conn)
-{
-	struct iscsi_ctask *ctask;
-	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
-
-	list_for_each_entry(ctask, &conn->session->cmd_list, c_hlist) {
-		if (ctask->tag == req->itt)
-			goto found;
-	}
-	return -EINVAL;
-found:
-	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
-		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
-		ctask->offset,
-		ctask->r2t_count,
-		ntoh24(req->dlength), be32_to_cpu(req->offset));
-
-	conn->rx_buffer = (void *) (unsigned long) ctask->c_buffer;
-	conn->rx_buffer += be32_to_cpu(req->offset);
-	conn->rx_size = ntoh24(req->dlength);
-
-	ctask->offset += ntoh24(req->dlength);
-
-	conn->rx_ctask = ctask;
-
-	return 0;
-}
-
-static int iscsi_cmd_init(struct connection *conn)
-{
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
-	struct iscsi_ctask *ctask;
-	int len;
-
-	ctask = zalloc(sizeof(*ctask));
-	if (!ctask)
-		return -ENOMEM;
-
-	memcpy(&ctask->req, req, sizeof(*req));
-	ctask->tag = req->itt;
-	ctask->conn = conn;
-	INIT_LIST_HEAD(&ctask->c_hlist);
-
-	list_add(&ctask->c_hlist, &conn->session->cmd_list);
-
-	dprintf("%u %x %d %d %x\n", conn->session->tsih,
-		req->cdb[0], ntohl(req->data_length),
-		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
-
-	len = ntohl(req->data_length);
-	if (len) {
-		ctask->c_buffer = malloc(len);
-		if (!ctask->c_buffer)
-			return -ENOMEM;
-		dprintf("%p\n", ctask->c_buffer);
-	}
-
-	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		conn->rx_size = ntoh24(req->dlength);
-		conn->rx_buffer = ctask->c_buffer;
-		ctask->r2t_count = ntohl(req->data_length) - conn->rx_size;
-		ctask->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		ctask->offset = conn->rx_size;
-
-		dprintf("%d %d %d %d\n", conn->rx_size, ctask->r2t_count,
-			ctask->unsol_count, ctask->offset);
-	}
-
-	conn->rx_ctask = ctask;
-
-	return 0;
-}
-
 static int cmd_attr(struct iscsi_ctask *ctask)
 {
 	int attr;
@@ -1061,11 +988,104 @@
 	return 0;
 }
 
+static int iscsi_data_out_rx_start(struct connection *conn)
+{
+	struct iscsi_ctask *ctask;
+	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
+
+	list_for_each_entry(ctask, &conn->session->cmd_list, c_hlist) {
+		if (ctask->tag == req->itt)
+			goto found;
+	}
+	return -EINVAL;
+found:
+	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
+		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
+		ctask->offset,
+		ctask->r2t_count,
+		ntoh24(req->dlength), be32_to_cpu(req->offset));
+
+	conn->rx_buffer = (void *) (unsigned long) ctask->c_buffer;
+	conn->rx_buffer += be32_to_cpu(req->offset);
+	conn->rx_size = ntoh24(req->dlength);
+
+	ctask->offset += ntoh24(req->dlength);
+
+	conn->rx_ctask = ctask;
+
+	return 0;
+}
+
+static int iscsi_data_out_rx_done(struct iscsi_ctask *task)
+{
+	struct iscsi_hdr *hdr = &task->conn->req.bhs;
+	int err = 0;
+
+	if (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+			task->unsol_count = 0;
+			if (!task_pending(task))
+				err = iscsi_scsi_cmd_execute(task);
+		}
+	} else {
+		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))
+			return err;
+
+		err = iscsi_scsi_cmd_execute(task);
+	}
+
+	return err;
+}
+
+static int iscsi_cmd_init(struct connection *conn)
+{
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
+	struct iscsi_ctask *ctask;
+	int len;
+
+	ctask = zalloc(sizeof(*ctask));
+	if (!ctask)
+		return -ENOMEM;
+
+	memcpy(&ctask->req, req, sizeof(*req));
+	ctask->tag = req->itt;
+	ctask->conn = conn;
+	INIT_LIST_HEAD(&ctask->c_hlist);
+
+	list_add(&ctask->c_hlist, &conn->session->cmd_list);
+
+	dprintf("%u %x %d %d %x\n", conn->session->tsih,
+		req->cdb[0], ntohl(req->data_length),
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
+
+	len = ntohl(req->data_length);
+	if (len) {
+		ctask->c_buffer = malloc(len);
+		if (!ctask->c_buffer)
+			return -ENOMEM;
+		dprintf("%p\n", ctask->c_buffer);
+	}
+
+	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
+		conn->rx_size = ntoh24(req->dlength);
+		conn->rx_buffer = ctask->c_buffer;
+		ctask->r2t_count = ntohl(req->data_length) - conn->rx_size;
+		ctask->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
+		ctask->offset = conn->rx_size;
+
+		dprintf("%d %d %d %d\n", conn->rx_size, ctask->r2t_count,
+			ctask->unsol_count, ctask->offset);
+	}
+
+	conn->rx_ctask = ctask;
+
+	return 0;
+}
+
 static int iscsi_cmd_rx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	struct iscsi_ctask *ctask = conn->rx_ctask;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
 	uint8_t op;
 	int err = 0;
 
@@ -1075,16 +1095,7 @@
 		err = iscsi_task_queue(ctask);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
-		if (ctask->r2t_count) {
-			dprintf("%x %d\n", hdr->itt, ctask->r2t_count);
-			list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
-			tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
-		} else
-			err = target_cmd_queue(conn->session->tsih, req->cdb,
-					       (unsigned long) ctask->c_buffer,
-					       req->lun,
-					       ntohl(req->data_length),
-					       cmd_attr(ctask), req->itt);
+		err = iscsi_data_out_rx_done(ctask);
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -1234,9 +1245,10 @@
 	read_again:
 		res = read(fd, conn->rx_buffer, conn->rx_size);
 		if (res <= 0) {
-			if (res == 0 || (errno != EINTR && errno != EAGAIN))
+			if (res == 0 || (errno != EINTR && errno != EAGAIN)) {
 				conn->state = STATE_CLOSE;
-			else if (errno == EINTR)
+				dprintf("%d %d, %m\n", res, errno);
+			} else if (errno == EINTR)
 				goto read_again;
 			break;
 		}
@@ -1343,6 +1355,7 @@
 				conn->tx_size = conn->rsp.datasize;
 				pad = conn->tx_size & (PAD_WORD_LEN - 1);
 				if (pad) {
+					pad = PAD_WORD_LEN - pad;
 					memset(conn->tx_buffer + conn->tx_size,
 					       0, pad);
 					conn->tx_size += pad;



From tomo at mail.berlios.de  Fri Sep  1 19:08:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 19:08:02 +0200
Subject: [Stgt-svn] r583 - trunk/usr/iscsi
Message-ID: <200609011708.k81H82HL017748@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 19:07:58 +0200 (Fri, 01 Sep 2006)
New Revision: 583

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
Fix InitialR2T=No support.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 16:12:09 UTC (rev 582)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 17:07:58 UTC (rev 583)
@@ -822,7 +822,6 @@
 	rsp->ttt = (unsigned long) ctask;
 	length = min(ctask->r2t_count, max_burst);
 	rsp->data_length = cpu_to_be32(length);
-	ctask->r2t_count -= length;
 
 	return 0;
 }
@@ -1010,6 +1009,7 @@
 	conn->rx_size = ntoh24(req->dlength);
 
 	ctask->offset += ntoh24(req->dlength);
+	ctask->r2t_count -= ntoh24(req->dlength);
 
 	conn->rx_ctask = ctask;
 



From tomo at mail.berlios.de  Fri Sep  1 19:25:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 1 Sep 2006 19:25:43 +0200
Subject: [Stgt-svn] r584 - trunk/usr/iscsi
Message-ID: <200609011725.k81HPhSG024660@sheep.berlios.de>

Author: tomo
Date: 2006-09-01 19:25:35 +0200 (Fri, 01 Sep 2006)
New Revision: 584

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Rename ctask task.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 17:07:58 UTC (rev 583)
+++ trunk/usr/iscsi/iscsid.c	2006-09-01 17:25:35 UTC (rev 584)
@@ -734,17 +734,17 @@
 	}
 }
 
-static int iscsi_cmd_rsp_build(struct iscsi_ctask *ctask)
+static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 {
-	struct connection *conn = ctask->conn;
+	struct connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp->itt = ctask->tag;
+	rsp->itt = task->tag;
 	rsp->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp->cmd_status = ctask->result;
+	rsp->cmd_status = task->result;
 	rsp->statsn = cpu_to_be32(conn->stat_sn++);
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
@@ -752,37 +752,37 @@
 	return 0;
 }
 
-static int iscsi_data_rsp_build(struct iscsi_ctask *ctask)
+static int iscsi_data_rsp_build(struct iscsi_task *task)
 {
-	struct connection *conn = ctask->conn;
+	struct connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	int residual, datalen, exp_datalen = ntohl(req->data_length);
 	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
-	rsp->itt = ctask->tag;
+	rsp->itt = task->tag;
 	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
 	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
 
-	rsp->offset = cpu_to_be32(ctask->offset);
-	rsp->datasn = cpu_to_be32(ctask->data_sn++);
-	rsp->cmd_status = ctask->result;
+	rsp->offset = cpu_to_be32(task->offset);
+	rsp->datasn = cpu_to_be32(task->data_sn++);
+	rsp->cmd_status = task->result;
 
-	datalen = min(exp_datalen, ctask->len);
-	datalen -= ctask->offset;
+	datalen = min(exp_datalen, task->len);
+	datalen -= task->offset;
 
-	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, ctask->len, max_burst, rsp->itt);
+	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, task->len, max_burst, rsp->itt);
 
 	if (datalen <= max_burst) {
 		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-		if (ctask->len < exp_datalen) {
+		if (task->len < exp_datalen) {
 			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - ctask->len;
-		} else if (ctask->len > exp_datalen) {
+			residual = exp_datalen - task->len;
+		} else if (task->len > exp_datalen) {
 			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = ctask->len - exp_datalen;
+			residual = task->len - exp_datalen;
 		} else
 			residual = 0;
 		rsp->residual_count = cpu_to_be32(residual);
@@ -796,17 +796,17 @@
 
 	conn->rsp.datasize = datalen;
 	hton24(rsp->dlength, datalen);
-	conn->rsp.data = (void *) (unsigned long) ctask->addr;
-	conn->rsp.data += ctask->offset;
+	conn->rsp.data = (void *) (unsigned long) task->addr;
+	conn->rsp.data += task->offset;
 
-	ctask->offset += datalen;
+	task->offset += datalen;
 
 	return 0;
 }
 
-static int iscsi_r2t_build(struct iscsi_ctask *ctask)
+static int iscsi_r2t_build(struct iscsi_task *task)
 {
-	struct connection *conn = ctask->conn;
+	struct connection *conn = task->conn;
 	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
 	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
@@ -814,13 +814,13 @@
 
 	rsp->opcode = ISCSI_OP_R2T;
 	rsp->flags = ISCSI_FLAG_CMD_FINAL;
-	memcpy(rsp->lun, ctask->req.lun, sizeof(rsp->lun));
+	memcpy(rsp->lun, task->req.lun, sizeof(rsp->lun));
 
-	rsp->itt = ctask->req.itt;
-	rsp->r2tsn = cpu_to_be32(ctask->exp_r2tsn++);
-	rsp->data_offset = cpu_to_be32(ctask->offset);
-	rsp->ttt = (unsigned long) ctask;
-	length = min(ctask->r2t_count, max_burst);
+	rsp->itt = task->req.itt;
+	rsp->r2tsn = cpu_to_be32(task->exp_r2tsn++);
+	rsp->data_offset = cpu_to_be32(task->offset);
+	rsp->ttt = (unsigned long) task;
+	length = min(task->r2t_count, max_burst);
 	rsp->data_length = cpu_to_be32(length);
 
 	return 0;
@@ -830,7 +830,7 @@
 		   uint64_t tag)
 {
 	struct session *session;
-	struct iscsi_ctask *ctask;
+	struct iscsi_task *task;
 
 	dprintf("%u %d %d %d %" PRIx64 " %" PRIx64 "\n", host_no, len, result,
 		rw, addr, tag);
@@ -838,8 +838,8 @@
 	if (!session)
 		return -EINVAL;
 
-	list_for_each_entry(ctask, &session->cmd_list, c_hlist) {
-		if (ctask->tag == tag)
+	list_for_each_entry(task, &session->cmd_list, c_hlist) {
+		if (task->tag == tag)
 			goto found;
 	}
 	eprintf("Cannot find a task %" PRIx64 "\n", tag);
@@ -847,21 +847,21 @@
 
 found:
 	dprintf("found a task %" PRIx64 "\n", tag);
-	ctask->addr = addr;
-	ctask->result = result;
-	ctask->len = len;
-	ctask->rw = rw;
+	task->addr = addr;
+	task->result = result;
+	task->len = len;
+	task->rw = rw;
 
-	list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
-	tgt_event_modify(ctask->conn->fd, EPOLLIN | EPOLLOUT);
+	list_add_tail(&task->c_list, &task->conn->tx_clist);
+	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
 
-static int cmd_attr(struct iscsi_ctask *ctask)
+static int cmd_attr(struct iscsi_task *task)
 {
 	int attr;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 
 	switch (req->flags & ISCSI_FLAG_CMD_ATTR_MASK) {
 	case ISCSI_ATTR_UNTAGGED:
@@ -878,36 +878,36 @@
 	return attr;
 }
 
-static int iscsi_scsi_cmd_execute(struct iscsi_ctask *ctask)
+static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
-	struct connection *conn = ctask->conn;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &ctask->req;
-	unsigned long uaddr = (unsigned long) ctask->c_buffer;
+	struct connection *conn = task->conn;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
+	unsigned long uaddr = (unsigned long) task->c_buffer;
 	int err = 0;
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		if (ctask->r2t_count) {
-			if (ctask->unsol_count)
+		if (task->r2t_count) {
+			if (task->unsol_count)
 				;
 			else
-				list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
+				list_add_tail(&task->c_list, &task->conn->tx_clist);
 		} else
 			err = target_cmd_queue(conn->session->tsih, req->cdb,
 					       uaddr, req->lun,
 					       ntohl(req->data_length),
-					       cmd_attr(ctask), req->itt);
+					       cmd_attr(task), req->itt);
 
 	} else
 		err = target_cmd_queue(conn->session->tsih, req->cdb,
 				       uaddr, req->lun, ntohl(req->data_length),
-				       cmd_attr(ctask), req->itt);
+				       cmd_attr(task), req->itt);
 
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
 
 	return err;
 }
 
-static int iscsi_task_execute(struct iscsi_ctask *task)
+static int iscsi_task_execute(struct iscsi_task *task)
 {
 	struct iscsi_hdr *hdr = (struct iscsi_hdr *) &task->req;
 	uint8_t op = hdr->opcode & ISCSI_OPCODE_MASK;
@@ -936,16 +936,16 @@
 	return 0;
 }
 
-static int iscsi_task_queue(struct iscsi_ctask *ctask)
+static int iscsi_task_queue(struct iscsi_task *task)
 {
-	struct session *session = ctask->conn->session;
-	struct iscsi_hdr *req = (struct iscsi_hdr *) &ctask->req;
+	struct session *session = task->conn->session;
+	struct iscsi_hdr *req = (struct iscsi_hdr *) &task->req;
 	uint32_t cmd_sn;
-	struct iscsi_ctask *ent;
+	struct iscsi_task *ent;
 	int err;
 
 	if (req->opcode & ISCSI_OP_IMMEDIATE) {
-		return iscsi_task_execute(ctask);
+		return iscsi_task_execute(task);
 	}
 
 	dprintf("%x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn);
@@ -955,17 +955,17 @@
 		session->exp_cmd_sn = ++cmd_sn;
 
 		/* Should we close the connection... */
-		err = iscsi_task_execute(ctask);
+		err = iscsi_task_execute(task);
 
 		if (list_empty(&session->pending_cmd_list))
 			return 0;
-		ctask = list_entry(session->pending_cmd_list.next,
-				   struct iscsi_ctask, c_list);
-		if (be32_to_cpu(ctask->req.statsn) != cmd_sn)
+		task = list_entry(session->pending_cmd_list.next,
+				   struct iscsi_task, c_list);
+		if (be32_to_cpu(task->req.statsn) != cmd_sn)
 			return 0;
 
-		list_del(&ctask->c_list);
-		clear_task_pending(ctask);
+		list_del(&task->c_list);
+		clear_task_pending(task);
 		goto retry;
 	} else {
 		if (before(cmd_sn, session->exp_cmd_sn)) {
@@ -981,42 +981,42 @@
 				break;
 		}
 
-		list_add_tail(&ctask->c_list, &ent->c_list);
-		set_task_pending(ctask);
+		list_add_tail(&task->c_list, &ent->c_list);
+		set_task_pending(task);
 	}
 	return 0;
 }
 
 static int iscsi_data_out_rx_start(struct connection *conn)
 {
-	struct iscsi_ctask *ctask;
+	struct iscsi_task *task;
 	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
 
-	list_for_each_entry(ctask, &conn->session->cmd_list, c_hlist) {
-		if (ctask->tag == req->itt)
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task->tag == req->itt)
 			goto found;
 	}
 	return -EINVAL;
 found:
-	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", ctask->tag,
-		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
-		ctask->offset,
-		ctask->r2t_count,
+	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", task->tag,
+		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
+		task->offset,
+		task->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
-	conn->rx_buffer = (void *) (unsigned long) ctask->c_buffer;
+	conn->rx_buffer = (void *) (unsigned long) task->c_buffer;
 	conn->rx_buffer += be32_to_cpu(req->offset);
 	conn->rx_size = ntoh24(req->dlength);
 
-	ctask->offset += ntoh24(req->dlength);
-	ctask->r2t_count -= ntoh24(req->dlength);
+	task->offset += ntoh24(req->dlength);
+	task->r2t_count -= ntoh24(req->dlength);
 
-	conn->rx_ctask = ctask;
+	conn->rx_task = task;
 
 	return 0;
 }
 
-static int iscsi_data_out_rx_done(struct iscsi_ctask *task)
+static int iscsi_data_out_rx_done(struct iscsi_task *task)
 {
 	struct iscsi_hdr *hdr = &task->conn->req.bhs;
 	int err = 0;
@@ -1040,19 +1040,19 @@
 static int iscsi_cmd_init(struct connection *conn)
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
-	struct iscsi_ctask *ctask;
+	struct iscsi_task *task;
 	int len;
 
-	ctask = zalloc(sizeof(*ctask));
-	if (!ctask)
+	task = zalloc(sizeof(*task));
+	if (!task)
 		return -ENOMEM;
 
-	memcpy(&ctask->req, req, sizeof(*req));
-	ctask->tag = req->itt;
-	ctask->conn = conn;
-	INIT_LIST_HEAD(&ctask->c_hlist);
+	memcpy(&task->req, req, sizeof(*req));
+	task->tag = req->itt;
+	task->conn = conn;
+	INIT_LIST_HEAD(&task->c_hlist);
 
-	list_add(&ctask->c_hlist, &conn->session->cmd_list);
+	list_add(&task->c_hlist, &conn->session->cmd_list);
 
 	dprintf("%u %x %d %d %x\n", conn->session->tsih,
 		req->cdb[0], ntohl(req->data_length),
@@ -1060,24 +1060,24 @@
 
 	len = ntohl(req->data_length);
 	if (len) {
-		ctask->c_buffer = malloc(len);
-		if (!ctask->c_buffer)
+		task->c_buffer = malloc(len);
+		if (!task->c_buffer)
 			return -ENOMEM;
-		dprintf("%p\n", ctask->c_buffer);
+		dprintf("%p\n", task->c_buffer);
 	}
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		conn->rx_size = ntoh24(req->dlength);
-		conn->rx_buffer = ctask->c_buffer;
-		ctask->r2t_count = ntohl(req->data_length) - conn->rx_size;
-		ctask->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		ctask->offset = conn->rx_size;
+		conn->rx_buffer = task->c_buffer;
+		task->r2t_count = ntohl(req->data_length) - conn->rx_size;
+		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
+		task->offset = conn->rx_size;
 
-		dprintf("%d %d %d %d\n", conn->rx_size, ctask->r2t_count,
-			ctask->unsol_count, ctask->offset);
+		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
+			task->unsol_count, task->offset);
 	}
 
-	conn->rx_ctask = ctask;
+	conn->rx_task = task;
 
 	return 0;
 }
@@ -1085,17 +1085,17 @@
 static int iscsi_cmd_rx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
-	struct iscsi_ctask *ctask = conn->rx_ctask;
+	struct iscsi_task *task = conn->rx_task;
 	uint8_t op;
 	int err = 0;
 
 	op = hdr->opcode & ISCSI_OPCODE_MASK;
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
-		err = iscsi_task_queue(ctask);
+		err = iscsi_task_queue(task);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
-		err = iscsi_data_out_rx_done(ctask);
+		err = iscsi_data_out_rx_done(task);
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -1107,7 +1107,7 @@
 		break;
 	}
 
-	conn->rx_ctask = NULL;
+	conn->rx_task = NULL;
 	return err;
 }
 
@@ -1148,7 +1148,7 @@
 static int iscsi_cmd_tx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
-	struct iscsi_ctask *ctask = conn->tx_ctask;
+	struct iscsi_task *task = conn->tx_task;
 
 	switch (hdr->opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_R2T:
@@ -1156,28 +1156,28 @@
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
 			dprintf("more data %x\n", hdr->itt);
-			list_add_tail(&ctask->c_list, &ctask->conn->tx_clist);
+			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			goto out;
 		}
 	default:
-		target_cmd_done(conn->session->tsih, ctask->tag);
-		list_del(&ctask->c_hlist);
-		if (ctask->c_buffer) {
-			if ((unsigned long) ctask->c_buffer != ctask->addr)
-				free((void *) (unsigned long) ctask->addr);
-			free(ctask->c_buffer);
+		target_cmd_done(conn->session->tsih, task->tag);
+		list_del(&task->c_hlist);
+		if (task->c_buffer) {
+			if ((unsigned long) task->c_buffer != task->addr)
+				free((void *) (unsigned long) task->addr);
+			free(task->c_buffer);
 		}
-		free(ctask);
+		free(task);
 	}
 
 out:
-	conn->tx_ctask = NULL;
+	conn->tx_task = NULL;
 	return 0;
 }
 
 static int iscsi_cmd_tx_start(struct connection *conn)
 {
-	struct iscsi_ctask *ctask;
+	struct iscsi_task *task;
 	struct iscsi_cmd *req;
 	int err = 0;
 
@@ -1189,27 +1189,27 @@
 
 	conn_write_pdu(conn);
 
-	ctask = list_entry(conn->tx_clist.next, struct iscsi_ctask, c_list);
-	conn->tx_ctask = ctask;
-	dprintf("found a task %" PRIx64 " %u %u %u\n", ctask->tag,
-		ntohl(((struct iscsi_cmd *) (&ctask->req))->data_length),
-		ctask->offset,
-		ctask->r2t_count);
+	task = list_entry(conn->tx_clist.next, struct iscsi_task, c_list);
+	conn->tx_task = task;
+	dprintf("found a task %" PRIx64 " %u %u %u\n", task->tag,
+		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
+		task->offset,
+		task->r2t_count);
 
-	list_del(&ctask->c_list);
+	list_del(&task->c_list);
 
-	req = (struct iscsi_cmd *) &ctask->req;
+	req = (struct iscsi_cmd *) &task->req;
 
-	if (ctask->r2t_count)
-		iscsi_r2t_build(ctask);
+	if (task->r2t_count)
+		iscsi_r2t_build(task);
 	else {
 		if (req->flags & ISCSI_FLAG_CMD_WRITE)
-			err = iscsi_cmd_rsp_build(ctask);
+			err = iscsi_cmd_rsp_build(task);
 		else {
-			if (ctask->len)
-				err = iscsi_data_rsp_build(ctask);
+			if (task->len)
+				err = iscsi_data_rsp_build(task);
 			else
-				err = iscsi_cmd_rsp_build(ctask);
+				err = iscsi_cmd_rsp_build(task);
 		}
 	}
 
@@ -1311,7 +1311,7 @@
 {
 	int res, opt;
 
-	if (conn->state == STATE_SCSI && !conn->tx_ctask) {
+	if (conn->state == STATE_SCSI && !conn->tx_task) {
 		res = iscsi_cmd_tx_start(conn);
 		if (res)
 			return;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-01 17:07:58 UTC (rev 583)
+++ trunk/usr/iscsi/iscsid.h	2006-09-01 17:25:35 UTC (rev 584)
@@ -67,16 +67,16 @@
 	struct list_head conn_list;
 	int conn_cnt;
 
-	/* links all tasks (ctask->c_hlist) */
+	/* links all tasks (task->c_hlist) */
 	struct list_head cmd_list;
 
-	/* links pending tasks (ctask->c_list) */
+	/* links pending tasks (task->c_list) */
 	struct list_head pending_cmd_list;
 
 	uint32_t exp_cmd_sn;
 };
 
-struct iscsi_ctask {
+struct iscsi_task {
 	struct iscsi_hdr req;
 	struct iscsi_hdr rsp;
 
@@ -141,8 +141,8 @@
 	int rx_size;
 	int tx_size;
 
-	struct iscsi_ctask *rx_ctask;
-	struct iscsi_ctask *tx_ctask;
+	struct iscsi_task *rx_task;
+	struct iscsi_task *tx_task;
 
 	struct list_head tx_clist;
 



From tomo at mail.berlios.de  Sun Sep  3 07:56:21 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 07:56:21 +0200
Subject: [Stgt-svn] r585 - trunk/usr/iscsi
Message-ID: <200609030556.k835uLZE013242@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 07:56:19 +0200 (Sun, 03 Sep 2006)
New Revision: 585

Modified:
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
Log:
Add noop support.

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-09-01 17:25:35 UTC (rev 584)
+++ trunk/usr/iscsi/iscsi.h	2006-09-03 05:56:19 UTC (rev 585)
@@ -1,14 +1,14 @@
 extern int iscsi_init(void);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
-extern int iscsi_cmd_done(int host_no, int len, int result, int rw,
-			  uint64_t addr, uint64_t tag);
+extern int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw,
+			       uint64_t addr, uint64_t tag);
 
 struct tgt_driver iscsi = {
 	.name		= "iscsi",
 	.init		= iscsi_init,
 	.target_create	= iscsi_target_create,
 	.target_destroy	= iscsi_target_destroy,
-	.cmd_end_notify	= iscsi_cmd_done,
+	.cmd_end_notify	= iscsi_scsi_cmd_done,
 	.bdt		= &aio_bdt,
 };

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-01 17:25:35 UTC (rev 584)
+++ trunk/usr/iscsi/iscsid.c	2006-09-03 05:56:19 UTC (rev 585)
@@ -826,8 +826,8 @@
 	return 0;
 }
 
-int iscsi_cmd_done(int host_no, int len, int result, int rw, uint64_t addr,
-		   uint64_t tag)
+int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw, uint64_t addr,
+			uint64_t tag)
 {
 	struct session *session;
 	struct iscsi_task *task;
@@ -915,7 +915,8 @@
 
 	switch (op) {
 	case ISCSI_OP_NOOP_OUT:
-/* 		noop_out_exec(cmnd); */
+		list_add_tail(&task->c_list, &task->conn->tx_clist);
+		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		err = iscsi_scsi_cmd_execute(task);
@@ -936,6 +937,56 @@
 	return 0;
 }
 
+static int iscsi_data_out_rx_done(struct iscsi_task *task)
+{
+	struct iscsi_hdr *hdr = &task->conn->req.bhs;
+	int err = 0;
+
+	if (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+			task->unsol_count = 0;
+			if (!task_pending(task))
+				err = iscsi_scsi_cmd_execute(task);
+		}
+	} else {
+		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))
+			return err;
+
+		err = iscsi_scsi_cmd_execute(task);
+	}
+
+	return err;
+}
+
+static int iscsi_data_out_rx_start(struct connection *conn)
+{
+	struct iscsi_task *task;
+	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
+
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task->tag == req->itt)
+			goto found;
+	}
+	return -EINVAL;
+found:
+	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", task->tag,
+		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
+		task->offset,
+		task->r2t_count,
+		ntoh24(req->dlength), be32_to_cpu(req->offset));
+
+	conn->rx_buffer = (void *) (unsigned long) task->c_buffer;
+	conn->rx_buffer += be32_to_cpu(req->offset);
+	conn->rx_size = ntoh24(req->dlength);
+
+	task->offset += ntoh24(req->dlength);
+	task->r2t_count -= ntoh24(req->dlength);
+
+	conn->rx_task = task;
+
+	return 0;
+}
+
 static int iscsi_task_queue(struct iscsi_task *task)
 {
 	struct session *session = task->conn->session;
@@ -944,11 +995,12 @@
 	struct iscsi_task *ent;
 	int err;
 
-	if (req->opcode & ISCSI_OP_IMMEDIATE) {
+	dprintf("%x %x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn,
+		req->opcode);
+
+	if (req->opcode & ISCSI_OP_IMMEDIATE)
 		return iscsi_task_execute(task);
-	}
 
-	dprintf("%x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn);
 	cmd_sn = be32_to_cpu(req->statsn);
 	if (cmd_sn == session->exp_cmd_sn) {
 	retry:
@@ -987,58 +1039,8 @@
 	return 0;
 }
 
-static int iscsi_data_out_rx_start(struct connection *conn)
+static int iscsi_scsi_cmd_rx_start(struct connection *conn)
 {
-	struct iscsi_task *task;
-	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
-
-	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
-		if (task->tag == req->itt)
-			goto found;
-	}
-	return -EINVAL;
-found:
-	dprintf("found a task %" PRIx64 " %u %u %u %u %u\n", task->tag,
-		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
-		task->offset,
-		task->r2t_count,
-		ntoh24(req->dlength), be32_to_cpu(req->offset));
-
-	conn->rx_buffer = (void *) (unsigned long) task->c_buffer;
-	conn->rx_buffer += be32_to_cpu(req->offset);
-	conn->rx_size = ntoh24(req->dlength);
-
-	task->offset += ntoh24(req->dlength);
-	task->r2t_count -= ntoh24(req->dlength);
-
-	conn->rx_task = task;
-
-	return 0;
-}
-
-static int iscsi_data_out_rx_done(struct iscsi_task *task)
-{
-	struct iscsi_hdr *hdr = &task->conn->req.bhs;
-	int err = 0;
-
-	if (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-			task->unsol_count = 0;
-			if (!task_pending(task))
-				err = iscsi_scsi_cmd_execute(task);
-		}
-	} else {
-		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))
-			return err;
-
-		err = iscsi_scsi_cmd_execute(task);
-	}
-
-	return err;
-}
-
-static int iscsi_cmd_init(struct connection *conn)
-{
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
 	int len;
@@ -1051,7 +1053,6 @@
 	task->tag = req->itt;
 	task->conn = conn;
 	INIT_LIST_HEAD(&task->c_hlist);
-
 	list_add(&task->c_hlist, &conn->session->cmd_list);
 
 	dprintf("%u %x %d %d %x\n", conn->session->tsih,
@@ -1082,8 +1083,60 @@
 	return 0;
 }
 
-static int iscsi_cmd_rx_done(struct connection *conn)
+static int iscsi_noop_out_rx_start(struct connection *conn)
 {
+	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
+	struct iscsi_task *task;
+	int len, err = -ENOMEM;
+
+	dprintf("%x %x %u\n", req->ttt, req->itt, ntoh24(req->dlength));
+	if (req->ttt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/*
+		 * We don't request a NOP-Out by sending a NOP-In.
+		 * See 10.18.2 in the draft 20.
+		 */
+		eprintf("initiator bug\n");
+		err = -ISCSI_REASON_PROTOCOL_ERROR;
+		goto out;
+	}
+
+	if (req->itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if (!(req->opcode & ISCSI_OP_IMMEDIATE)) {
+			eprintf("initiator bug\n");
+			err = -ISCSI_REASON_PROTOCOL_ERROR;
+			goto out;
+		}
+	}
+
+	conn->exp_stat_sn = be32_to_cpu(req->exp_statsn);
+
+	task = zalloc(sizeof(*task));
+	if (!task)
+		goto out;
+
+	memcpy(&task->req, req, sizeof(*req));
+	task->conn = conn;
+
+	len = ntoh24(req->dlength);
+	if (len) {
+		conn->rx_size = len;
+		task->len = len;
+		task->c_buffer = malloc(len);
+		if (!task->c_buffer) {
+			free(task);
+			goto out;
+		}
+
+		conn->rx_buffer = task->c_buffer;
+	}
+
+	conn->rx_task = task;
+out:
+	return err;
+}
+
+static int iscsi_task_rx_done(struct connection *conn)
+{
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	struct iscsi_task *task = conn->rx_task;
 	uint8_t op;
@@ -1092,12 +1145,12 @@
 	op = hdr->opcode & ISCSI_OPCODE_MASK;
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
+	case ISCSI_OP_NOOP_OUT:
 		err = iscsi_task_queue(task);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		err = iscsi_data_out_rx_done(task);
 		break;
-	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
 	case ISCSI_OP_TEXT:
@@ -1111,7 +1164,7 @@
 	return err;
 }
 
-static int iscsi_cmd_rx_start(struct connection *conn)
+static int iscsi_task_rx_start(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	uint8_t op;
@@ -1120,7 +1173,7 @@
 	op = hdr->opcode & ISCSI_OPCODE_MASK;
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
-		err = iscsi_cmd_init(conn);
+		err = iscsi_scsi_cmd_rx_start(conn);
 		if (!err)
 			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
 		break;
@@ -1130,6 +1183,8 @@
 			conn->exp_stat_sn = be32_to_cpu(hdr->exp_statsn);
 		break;
 	case ISCSI_OP_NOOP_OUT:
+		err = iscsi_noop_out_rx_start(conn);
+		break;
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
 	case ISCSI_OP_TEXT:
@@ -1145,8 +1200,58 @@
 	return 0;
 }
 
-static int iscsi_cmd_tx_done(struct connection *conn)
+static int iscsi_scsi_cmd_tx_start(struct iscsi_task *task)
 {
+	int err = 0;
+	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
+
+	if (task->r2t_count)
+		err = iscsi_r2t_build(task);
+	else {
+		if (req->flags & ISCSI_FLAG_CMD_WRITE)
+			err = iscsi_cmd_rsp_build(task);
+		else {
+			if (task->len)
+				err = iscsi_data_rsp_build(task);
+			else
+				err = iscsi_cmd_rsp_build(task);
+		}
+	}
+
+	return err;
+}
+
+static int iscsi_noop_out_tx_start(struct iscsi_task *task, int *is_rsp)
+{
+	struct connection *conn = task->conn;
+	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
+
+	if (task->req.itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		*is_rsp = 0;
+		free(task);
+	} else {
+		*is_rsp = 1;
+
+		memset(rsp, 0, sizeof(*rsp));
+		rsp->opcode = ISCSI_OP_NOOP_IN;
+		rsp->flags = ISCSI_FLAG_CMD_FINAL;
+		rsp->itt = task->req.itt;
+		rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+		rsp->statsn = cpu_to_be32(conn->stat_sn++);
+		rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+		rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+		/* TODO: honor max_burst */
+		conn->rsp.datasize = task->len;
+		hton24(rsp->dlength, task->len);
+		conn->rsp.data = task->c_buffer;
+	}
+
+	return 0;
+}
+
+static int iscsi_scsi_cmd_tx_done(struct connection *conn)
+{
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
 	struct iscsi_task *task = conn->tx_task;
 
@@ -1157,9 +1262,9 @@
 		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
 			dprintf("more data %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			goto out;
+			return 0;
 		}
-	default:
+	case ISCSI_OP_SCSI_CMD_RSP:
 		target_cmd_done(conn->session->tsih, task->tag);
 		list_del(&task->c_hlist);
 		if (task->c_buffer) {
@@ -1168,29 +1273,44 @@
 			free(task->c_buffer);
 		}
 		free(task);
+		break;
+	default:
+		eprintf("target bug %x\n", hdr->opcode & ISCSI_OPCODE_MASK);
 	}
 
-out:
+	return 0;
+}
+
+static int iscsi_task_tx_done(struct connection *conn)
+{
+	struct iscsi_task *task = conn->tx_task;
+	int err;
+
+	switch (task->req.opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_scsi_cmd_tx_done(conn);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+		if (task->c_buffer)
+			free(task->c_buffer);
+		free(task);
+	}
+
 	conn->tx_task = NULL;
 	return 0;
 }
 
-static int iscsi_cmd_tx_start(struct connection *conn)
+static int iscsi_task_tx_start(struct connection *conn)
 {
 	struct iscsi_task *task;
-	struct iscsi_cmd *req;
-	int err = 0;
+	int is_rsp, err = 0;
 
-	if (list_empty(&conn->tx_clist)) {
-		dprintf("no more data\n");
-		tgt_event_modify(conn->fd, EPOLLIN);
-		return -EAGAIN;
-	}
+	if (list_empty(&conn->tx_clist))
+		goto nodata;
 
 	conn_write_pdu(conn);
 
 	task = list_entry(conn->tx_clist.next, struct iscsi_task, c_list);
-	conn->tx_task = task;
 	dprintf("found a task %" PRIx64 " %u %u %u\n", task->tag,
 		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
 		task->offset,
@@ -1198,22 +1318,24 @@
 
 	list_del(&task->c_list);
 
-	req = (struct iscsi_cmd *) &task->req;
-
-	if (task->r2t_count)
-		iscsi_r2t_build(task);
-	else {
-		if (req->flags & ISCSI_FLAG_CMD_WRITE)
-			err = iscsi_cmd_rsp_build(task);
-		else {
-			if (task->len)
-				err = iscsi_data_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		}
+	switch (task->req.opcode & ISCSI_OPCODE_MASK) {
+	case ISCSI_OP_SCSI_CMD:
+		err = iscsi_scsi_cmd_tx_start(task);
+		break;
+	case ISCSI_OP_NOOP_OUT:
+		err = iscsi_noop_out_tx_start(task, &is_rsp);
+		if (!is_rsp)
+			goto nodata;
+		break;
 	}
 
+	conn->tx_task = task;
 	return err;
+
+nodata:
+	dprintf("no more data\n");
+	tgt_event_modify(conn->fd, EPOLLIN);
+	return -EAGAIN;
 }
 
 
@@ -1271,7 +1393,7 @@
 			}
 
 			if (conn->state == STATE_SCSI) {
-				res = iscsi_cmd_rx_start(conn);
+				res = iscsi_task_rx_start(conn);
 				if (res) {
 					conn->state = STATE_CLOSE;
 					break;
@@ -1290,7 +1412,7 @@
 
 		case IOSTATE_READ_AHS_DATA:
 			if (conn->state == STATE_SCSI) {
-				res = iscsi_cmd_rx_done(conn);
+				res = iscsi_task_rx_done(conn);
 				if (!res)
 					conn_read_pdu(conn);
 			} else {
@@ -1312,7 +1434,7 @@
 	int res, opt;
 
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
-		res = iscsi_cmd_tx_start(conn);
+		res = iscsi_task_tx_start(conn);
 		if (res)
 			return;
 	}
@@ -1382,7 +1504,7 @@
 			case STATE_CLOSE:
 				break;
 			case STATE_SCSI:
-				iscsi_cmd_tx_done(conn);
+				iscsi_task_tx_done(conn);
 				break;
 			default:
 				conn_read_pdu(conn);



From tomo at mail.berlios.de  Sun Sep  3 08:16:23 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 08:16:23 +0200
Subject: [Stgt-svn] r586 - trunk/usr/iscsi
Message-ID: <200609030616.k836GNm8018514@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 08:15:17 +0200 (Sun, 03 Sep 2006)
New Revision: 586

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
Add logout support (not tested).

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-03 05:56:19 UTC (rev 585)
+++ trunk/usr/iscsi/iscsid.c	2006-09-03 06:15:17 UTC (rev 586)
@@ -1083,6 +1083,22 @@
 	return 0;
 }
 
+static int iscsi_logout_rx_start(struct connection *conn)
+{
+	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
+	struct iscsi_task *task;
+
+	task = zalloc(sizeof(*task));
+	if (!task)
+		return -ENOMEM;
+
+	memcpy(&task->req, req, sizeof(*req));
+	task->conn = conn;
+
+	conn->rx_task = task;
+	return 0;
+}
+
 static int iscsi_noop_out_rx_start(struct connection *conn)
 {
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
@@ -1146,13 +1162,13 @@
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_LOGOUT:
 		err = iscsi_task_queue(task);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		err = iscsi_data_out_rx_done(task);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
-	case ISCSI_OP_LOGOUT:
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 	default:
@@ -1187,6 +1203,7 @@
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
+		err = iscsi_logout_rx_start(conn);
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 		eprintf("Cannot handle yet %x\n", op);
@@ -1221,6 +1238,22 @@
 	return err;
 }
 
+static int iscsi_logout_tx_start(struct iscsi_task *task)
+{
+	struct connection *conn = task->conn;
+	struct iscsi_logout_rsp *rsp =
+		(struct iscsi_logout_rsp *) &conn->rsp.bhs;
+
+	rsp->opcode = ISCSI_OP_LOGOUT_RSP;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp->itt = task->req.itt;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+	return 0;
+}
+
 static int iscsi_noop_out_tx_start(struct iscsi_task *task, int *is_rsp)
 {
 	struct connection *conn = task->conn;
@@ -1291,6 +1324,7 @@
 		err = iscsi_scsi_cmd_tx_done(conn);
 		break;
 	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_LOGOUT:
 		if (task->c_buffer)
 			free(task->c_buffer);
 		free(task);
@@ -1327,6 +1361,9 @@
 		if (!is_rsp)
 			goto nodata;
 		break;
+	case ISCSI_OP_LOGOUT:
+		err = iscsi_logout_tx_start(task);
+		break;
 	}
 
 	conn->tx_task = task;



From tomo at mail.berlios.de  Sun Sep  3 09:10:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 09:10:40 +0200
Subject: [Stgt-svn] r587 - in trunk/usr: . iscsi
Message-ID: <200609030710.k837AeZH017122@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 09:10:38 +0200 (Sun, 03 Sep 2006)
New Revision: 587

Modified:
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Add task management support (not tested).

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-09-03 06:15:17 UTC (rev 586)
+++ trunk/usr/iscsi/iscsi.h	2006-09-03 07:10:38 UTC (rev 587)
@@ -3,12 +3,14 @@
 extern int iscsi_target_destroy(int);
 extern int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw,
 			       uint64_t addr, uint64_t tag);
+extern int iscsi_tm_done(int host_no, uint64_t mid, int result);
 
 struct tgt_driver iscsi = {
-	.name		= "iscsi",
-	.init		= iscsi_init,
-	.target_create	= iscsi_target_create,
-	.target_destroy	= iscsi_target_destroy,
-	.cmd_end_notify	= iscsi_scsi_cmd_done,
-	.bdt		= &aio_bdt,
+	.name			= "iscsi",
+	.init			= iscsi_init,
+	.target_create		= iscsi_target_create,
+	.target_destroy		= iscsi_target_destroy,
+	.cmd_end_notify		= iscsi_scsi_cmd_done,
+	.mgmt_end_notify	= iscsi_tm_done,
+	.bdt			= &aio_bdt,
 };

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-03 06:15:17 UTC (rev 586)
+++ trunk/usr/iscsi/iscsid.c	2006-09-03 07:10:38 UTC (rev 587)
@@ -907,6 +907,58 @@
 	return err;
 }
 
+extern int iscsi_tm_done(int host_no, uint64_t mid, int result)
+{
+	struct iscsi_task *task = (struct iscsi_task *) (unsigned long) mid;
+
+	task->result = result;
+	list_add_tail(&task->c_list, &task->conn->tx_clist);
+	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	return 0;
+}
+
+static int iscsi_tm_execute(struct iscsi_task *task)
+{
+	struct connection *conn = task->conn;
+	struct iscsi_tm *req = (struct iscsi_tm *) &task->req;
+	int fn, err = 0;
+
+	switch (req->flags & ISCSI_FLAG_TM_FUNC_MASK) {
+	case ISCSI_TM_FUNC_ABORT_TASK:
+		fn = ABORT_TASK;
+		break;
+	case ISCSI_TM_FUNC_ABORT_TASK_SET:
+		fn = ABORT_TASK_SET;
+		break;
+	case ISCSI_TM_FUNC_CLEAR_ACA:
+		fn = CLEAR_TASK_SET;
+		break;
+	case ISCSI_TM_FUNC_CLEAR_TASK_SET:
+		fn = CLEAR_ACA;
+		break;
+	case ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:
+		fn = LOGICAL_UNIT_RESET;
+		break;
+	case ISCSI_TM_FUNC_TARGET_WARM_RESET:
+	case ISCSI_TM_FUNC_TARGET_COLD_RESET:
+	case ISCSI_TM_FUNC_TASK_REASSIGN:
+		err = ISCSI_TMF_RSP_NOT_SUPPORTED;
+		break;
+	default:
+		err = ISCSI_TMF_RSP_REJECTED;
+
+		eprintf("unknown task management function %d\n",
+			req->flags & ISCSI_FLAG_TM_FUNC_MASK);
+	}
+
+	if (err)
+		task->result = err;
+	else
+		target_mgmt_request(conn->session->tsih, (unsigned long) task,
+				    fn, req->lun, req->itt);
+	return err;
+}
+
 static int iscsi_task_execute(struct iscsi_task *task)
 {
 	struct iscsi_hdr *hdr = (struct iscsi_hdr *) &task->req;
@@ -915,6 +967,7 @@
 
 	switch (op) {
 	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
 		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 		break;
@@ -922,11 +975,12 @@
 		err = iscsi_scsi_cmd_execute(task);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
-/* 		execute_task_management(cmnd); */
+		err = iscsi_tm_execute(task);
+		if (err) {
+			list_add_tail(&task->c_list, &task->conn->tx_clist);
+			tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+		}
 		break;
-	case ISCSI_OP_LOGOUT:
-/* 		logout_exec(cmnd); */
-		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 		break;
@@ -1083,7 +1137,7 @@
 	return 0;
 }
 
-static int iscsi_logout_rx_start(struct connection *conn)
+static int iscsi_common_task_rx_start(struct connection *conn)
 {
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
@@ -1162,13 +1216,13 @@
 	switch (op) {
 	case ISCSI_OP_SCSI_CMD:
 	case ISCSI_OP_NOOP_OUT:
+	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
 		err = iscsi_task_queue(task);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		err = iscsi_data_out_rx_done(task);
 		break;
-	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 	default:
@@ -1203,11 +1257,13 @@
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
 	case ISCSI_OP_LOGOUT:
-		err = iscsi_logout_rx_start(conn);
+		err = iscsi_common_task_rx_start(conn);
+		break;
 	case ISCSI_OP_TEXT:
 	case ISCSI_OP_SNACK:
 		eprintf("Cannot handle yet %x\n", op);
 		err = -EINVAL;
+		break;
 	default:
 		eprintf("Unknown op %x\n", op);
 		err = -EINVAL;
@@ -1283,6 +1339,24 @@
 	return 0;
 }
 
+static int iscsi_tm_tx_start(struct iscsi_task *task)
+{
+	struct connection *conn = task->conn;
+	struct iscsi_tm_rsp *rsp = (struct iscsi_tm_rsp *) &conn->rsp.bhs;
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp->itt = task->req.itt;
+	rsp->response = task->result;
+
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+	return 0;
+}
+
 static int iscsi_scsi_cmd_tx_done(struct connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
@@ -1325,6 +1399,7 @@
 		break;
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
+	case ISCSI_OP_SCSI_TMFUNC:
 		if (task->c_buffer)
 			free(task->c_buffer);
 		free(task);
@@ -1364,6 +1439,9 @@
 	case ISCSI_OP_LOGOUT:
 		err = iscsi_logout_tx_start(task);
 		break;
+	case ISCSI_OP_SCSI_TMFUNC:
+		err = iscsi_tm_tx_start(task);
+		break;
 	}
 
 	conn->tx_task = task;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-09-03 06:15:17 UTC (rev 586)
+++ trunk/usr/target.c	2006-09-03 07:10:38 UTC (rev 587)
@@ -483,8 +483,8 @@
 	return count;
 }
 
-void target_mgmt_request(int host_no, int req_id, int function, uint8_t *lun,
-			 uint64_t tag)
+void target_mgmt_request(int host_no, uint64_t req_id, int function,
+			 uint8_t *lun, uint64_t tag)
 {
 	struct target *target;
 	struct mgmt_req *mreq;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-09-03 06:15:17 UTC (rev 586)
+++ trunk/usr/tgtd.h	2006-09-03 07:10:38 UTC (rev 587)
@@ -57,7 +57,7 @@
 			    uint8_t *lun, uint32_t data_len,
 			    int attribute, uint64_t tag);
 extern void target_cmd_done(int host_no, uint64_t tag);
-extern void target_mgmt_request(int host_no, int req_id, int function,
+extern void target_mgmt_request(int host_no, uint64_t req_id, int function,
 				uint8_t *lun, uint64_t tag);
 
 extern void target_cmd_io_done(void *key, int result);



From tomo at mail.berlios.de  Sun Sep  3 09:18:58 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 09:18:58 +0200
Subject: [Stgt-svn] r588 - trunk/usr/iscsi
Message-ID: <200609030718.k837IwX2021270@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 09:18:57 +0200 (Sun, 03 Sep 2006)
New Revision: 588

Modified:
   trunk/usr/iscsi/param.c
Log:
Now it's not easy to change iSCSI parameters, so tune up the defaults for high performance.

MaxRecvDataSegmentLength=262144
InitialR2T=No


Modified: trunk/usr/iscsi/param.c
===================================================================
--- trunk/usr/iscsi/param.c	2006-09-03 07:10:38 UTC (rev 587)
+++ trunk/usr/iscsi/param.c	2006-09-03 07:18:57 UTC (rev 588)
@@ -286,11 +286,11 @@
 #define	SET_KEY_VALUES(x)	DEFAULT_NR_##x,MIN_NR_##x, MAX_NR_##x
 
 struct iscsi_key session_keys[] = {
-	{"MaxRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	{"MaxRecvDataSegmentLength", 262144, 512, 16777215, &minimum_ops},
 	{"MaxXmitDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
 	{"HeaderDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
 	{"DataDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
-	{"InitialR2T", 1, 0, 1, &or_ops},
+	{"InitialR2T", 0, 0, 1, &or_ops},
 	{"MaxOutstandingR2T", 1, 1, 65535, &minimum_ops},
 	{"ImmediateData", 1, 0, 1, &and_ops},
 	{"FirstBurstLength", 65536, 512, 16777215, &minimum_ops},



From tomo at mail.berlios.de  Sun Sep  3 09:41:39 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 09:41:39 +0200
Subject: [Stgt-svn] r589 - trunk/doc
Message-ID: <200609030741.k837fdw1027866@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 09:41:38 +0200 (Sun, 03 Sep 2006)
New Revision: 589

Added:
   trunk/doc/README.iscsi
Log:
Add simple README for iSCSI.

Added: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-09-03 07:18:57 UTC (rev 588)
+++ trunk/doc/README.iscsi	2006-09-03 07:41:38 UTC (rev 589)
@@ -0,0 +1,42 @@
+Installation
+-------------
+This driver runs in user-space, however, you still need tgt header
+files and kernel modifications. So get the latest code from the
+linux-2.6-target git tree. Then, apply aiopoll-2.6.18-rc4.diff in the
+patch directory, rebuild the kernel, and reboot with the new kernel.
+After the reboot, compile the source code:
+
+make KSRC=<kernel-src>
+
+
+Starting
+-------------
+Try the following commands:
+
+host:~/tgt$ su
+host:~/tgt# ./usr/tgtd -l iscsi
+
+
+Configuration
+-------------
+Now there is no handy way for the configuration. Everyting is
+configured via the tgtadm management tool after you run tgt daemon.
+
+The following example creates a target with id 1 (the iqn is
+iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz) and adds a
+logical unit (backed by /dev/hdc1) with lun 0.
+
+host:~/tgt$ su
+host:~/tgt# ./usr/tgtadm -l iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm -l iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+
+iSCSI parameters were tuned for reasonable performance (InitialR2T=No
+and MaxRecvDataSegmentLength=262144).
+
+
+Status
+-------------
+It should work under normal circumstances (good initiator, no network
+problem, etc). However, don't play with important data.
+
+Probabaly, the current quality is similar to the IET 0.2.x.



From tomo at mail.berlios.de  Sun Sep  3 10:07:13 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 10:07:13 +0200
Subject: [Stgt-svn] r590 - trunk/doc
Message-ID: <200609030807.k8387DNn029403@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 10:07:13 +0200 (Sun, 03 Sep 2006)
New Revision: 590

Modified:
   trunk/doc/README.iscsi
Log:
Fix README.iSCSI.

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-09-03 07:41:38 UTC (rev 589)
+++ trunk/doc/README.iscsi	2006-09-03 08:07:13 UTC (rev 590)
@@ -6,7 +6,7 @@
 patch directory, rebuild the kernel, and reboot with the new kernel.
 After the reboot, compile the source code:
 
-make KSRC=<kernel-src>
+make KSRC=<kernel-src> ISCSI=1
 
 
 Starting



From tomo at mail.berlios.de  Sun Sep  3 10:08:30 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 10:08:30 +0200
Subject: [Stgt-svn] r591 - trunk/usr/iscsi
Message-ID: <200609030808.k8388UpL029447@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 10:08:30 +0200 (Sun, 03 Sep 2006)
New Revision: 591

Modified:
   trunk/usr/iscsi/param.c
Log:
Set MaxXmitDataSegmentLength to 262144. MaxRecvDataSegmentLength does not work now.


Modified: trunk/usr/iscsi/param.c
===================================================================
--- trunk/usr/iscsi/param.c	2006-09-03 08:07:13 UTC (rev 590)
+++ trunk/usr/iscsi/param.c	2006-09-03 08:08:30 UTC (rev 591)
@@ -287,7 +287,7 @@
 
 struct iscsi_key session_keys[] = {
 	{"MaxRecvDataSegmentLength", 262144, 512, 16777215, &minimum_ops},
-	{"MaxXmitDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	{"MaxXmitDataSegmentLength", 262144, 512, 16777215, &minimum_ops},
 	{"HeaderDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
 	{"DataDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
 	{"InitialR2T", 0, 0, 1, &or_ops},



From tomo at mail.berlios.de  Sun Sep  3 10:09:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 10:09:19 +0200
Subject: [Stgt-svn] r592 - trunk/doc
Message-ID: <200609030809.k8389JdM029518@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 10:09:19 +0200 (Sun, 03 Sep 2006)
New Revision: 592

Modified:
   trunk/doc/README.iscsi
Log:
Remove iSCSI param discription in READM since it does not work.

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-09-03 08:08:30 UTC (rev 591)
+++ trunk/doc/README.iscsi	2006-09-03 08:09:19 UTC (rev 592)
@@ -30,10 +30,7 @@
 host:~/tgt# ./usr/tgtadm -l iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 host:~/tgt# ./usr/tgtadm -l iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
 
-iSCSI parameters were tuned for reasonable performance (InitialR2T=No
-and MaxRecvDataSegmentLength=262144).
 
-
 Status
 -------------
 It should work under normal circumstances (good initiator, no network



From tomo at mail.berlios.de  Sun Sep  3 12:57:15 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 3 Sep 2006 12:57:15 +0200
Subject: [Stgt-svn] r593 - in trunk/usr: . iscsi
Message-ID: <200609031057.k83AvFOG016593@sheep.berlios.de>

Author: tomo
Date: 2006-09-03 12:57:13 +0200 (Sun, 03 Sep 2006)
New Revision: 593

Added:
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/iscsi/transport.c
   trunk/usr/iscsi/transport.h
Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
Log:
Add initial transport code (for iSER).

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/Makefile	2006-09-03 10:57:13 UTC (rev 593)
@@ -10,7 +10,8 @@
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o chap.o)
+TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o chap.o transport.o)
+TGTD_OBJS += $(addprefix iscsi/, iscsi_tcp.o)
 LIBS += -lcrypto
 BD_AIO=1
 endif

Added: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/iscsi/iscsi_tcp.c	2006-09-03 10:57:13 UTC (rev 593)
@@ -0,0 +1,199 @@
+/*
+ * Software iSCSI target over TCP/IP Data-Path
+ *
+ * (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/epoll.h>
+#include <sys/socket.h>
+
+#include "iscsid.h"
+#include "tgtd.h"
+#include "util.h"
+
+#define ISCSI_LISTEN_PORT	3260
+#define LISTEN_MAX		4
+#define INCOMING_MAX		32
+
+static void set_non_blocking(int fd)
+{
+	int err;
+
+	err = fcntl(fd, F_GETFL);
+	if (err < 0) {
+		eprintf("unable to get fd flags, %m\n");
+	} else {
+		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
+		if (err == -1)
+			eprintf("unable to set fd flags, %m\n");
+	}
+}
+
+static void accept_connection(int afd, int events, void *data)
+{
+	struct sockaddr_storage from;
+	socklen_t namesize;
+	struct connection *conn;
+	int fd, err;
+
+	eprintf("%d\n", afd);
+
+	namesize = sizeof(from);
+	fd = accept(afd, (struct sockaddr *) &from, &namesize);
+	if (fd < 0) {
+		eprintf("can't accept, %m\n");
+		return;
+	}
+
+	conn = conn_alloc();
+	if (!conn)
+		goto out;
+
+	conn->fd = fd;
+	conn->tp = &iscsi_tcp;
+
+	conn_read_pdu(conn);
+	set_non_blocking(fd);
+
+	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
+	if (err)
+		goto free_conn;
+
+	return;
+free_conn:
+	free(conn);
+out:
+	close(fd);
+	return;
+}
+
+static int iscsi_tcp_init(void)
+{
+	struct addrinfo hints, *res, *res0;
+	char servname[64];
+	int err, i, fd, opt, nr_sock = 0;
+
+	memset(servname, 0, sizeof(servname));
+	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_PASSIVE;
+
+	err = getaddrinfo(NULL, servname, &hints, &res0);
+	if (err) {
+		eprintf("unable to get address info, %m\n");
+		return -errno;
+	}
+
+	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
+		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+		if (fd < 0) {
+			if (res->ai_family == AF_INET6)
+				dprintf("IPv6 support is disabled.\n");
+			else
+				eprintf("unable to create fdet %d %d %d, %m\n",
+					res->ai_family,	res->ai_socktype,
+					res->ai_protocol);
+			continue;
+		}
+
+		opt = 1;
+		err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt,
+				 sizeof(opt));
+		if (err)
+			dprintf("unable to set SO_REUSEADDR, %m\n");
+
+		opt = 1;
+		if (res->ai_family == AF_INET6) {
+			err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt,
+					 sizeof(opt));
+			if (err) {
+				close(fd);
+				continue;
+			}
+		}
+
+		err = bind(fd, res->ai_addr, res->ai_addrlen);
+		if (err) {
+			close(fd);
+			eprintf("unable to bind server socket, %m\n");
+			continue;
+		}
+
+		err = listen(fd, INCOMING_MAX);
+		if (err) {
+			eprintf("unable to listen to server socket, %m\n");
+			close(fd);
+			continue;
+		}
+
+		set_non_blocking(fd);
+		err = tgt_event_add(fd, EPOLLIN, accept_connection, NULL);
+		if (err)
+			close(fd);
+		else
+			nr_sock++;
+	}
+
+	freeaddrinfo(res0);
+
+	return !nr_sock;
+}
+
+static size_t iscsi_tcp_read (int ep, void *buf, size_t nbytes)
+{
+	return read(ep, buf, nbytes);
+}
+
+static size_t iscsi_tcp_write_begin(int ep, void *buf, size_t nbytes)
+{
+	int opt = 1;
+	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+	return write(ep, buf, nbytes);
+}
+
+static void iscsi_tcp_write_end(int ep)
+{
+	int opt = 0;
+	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+}
+
+static size_t iscsi_tcp_close(int ep)
+{
+	return close(ep);
+}
+
+struct iscsi_transport iscsi_tcp = {
+	.name		= "iscsi",
+	.rdma		= 0,
+	.init		= iscsi_tcp_init,
+	.ep_read	= iscsi_tcp_read,
+	.ep_write_begin	= iscsi_tcp_write_begin,
+	.ep_write_end	= iscsi_tcp_write_end,
+	.ep_close	= iscsi_tcp_close,
+};

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/iscsi/iscsid.c	2006-09-03 10:57:13 UTC (rev 593)
@@ -16,11 +16,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
 #include <scsi/scsi.h>
 #include <sys/epoll.h>
-#include <sys/socket.h>
 
 #include "iscsid.h"
 #include "tgtd.h"
@@ -1453,25 +1450,6 @@
 	return -EAGAIN;
 }
 
-
-#define ISCSI_LISTEN_PORT	3260
-#define LISTEN_MAX		4
-#define INCOMING_MAX		32
-
-static void set_non_blocking(int fd)
-{
-	int err;
-
-	err = fcntl(fd, F_GETFL);
-	if (err < 0) {
-		eprintf("unable to get fd flags, %m\n");
-	} else {
-		err = fcntl(fd, F_SETFL, err | O_NONBLOCK);
-		if (err == -1)
-			eprintf("unable to set fd flags, %m\n");
-	}
-}
-
 static void iscsi_rx_handler(int fd, struct connection *conn)
 {
 	int res;
@@ -1480,7 +1458,7 @@
 	case IOSTATE_READ_BHS:
 	case IOSTATE_READ_AHS_DATA:
 	read_again:
-		res = read(fd, conn->rx_buffer, conn->rx_size);
+		res = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
 		if (res <= 0) {
 			if (res == 0 || (errno != EINTR && errno != EAGAIN)) {
 				conn->state = STATE_CLOSE;
@@ -1546,7 +1524,7 @@
 
 static void iscsi_tx_handler(int fd, struct connection *conn)
 {
-	int res, opt;
+	int res;
 
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
 		res = iscsi_task_tx_start(conn);
@@ -1559,9 +1537,8 @@
 	case IOSTATE_WRITE_AHS:
 	case IOSTATE_WRITE_DATA:
 	write_again:
-		opt = 1;
-		setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-		res = write(fd, conn->tx_buffer, conn->tx_size);
+		res = conn->tp->ep_write_begin(fd, conn->tx_buffer,
+					       conn->tx_size);
 		if (res < 0) {
 			if (errno != EINTR && errno != EAGAIN)
 				conn->state = STATE_CLOSE;
@@ -1600,8 +1577,7 @@
 				goto write_again;
 			}
 		case IOSTATE_WRITE_DATA:
-			opt = 0;
-			setsockopt(fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+			conn->tp->ep_write_end(fd);
 			cmnd_finish(conn);
 
 			switch (conn->state) {
@@ -1638,9 +1614,10 @@
 
 }
 
-static void iscsi_event_handler(int fd, int events, void *data)
+void iscsi_event_handler(int fd, int events, void *data)
 {
 	struct connection *conn = (struct connection *) data;
+	size_t (*ep_close) (int);
 
 	if (events & EPOLLIN)
 		iscsi_rx_handler(fd, conn);
@@ -1652,120 +1629,12 @@
 		iscsi_tx_handler(fd, conn);
 
 	if (conn->state == STATE_CLOSE) {
+		/* TODO: we cannot wait for ongoing tasks. */
+
 		dprintf("connection closed\n");
+		ep_close = conn->tp->ep_close;
 		conn_free(conn);
 		tgt_event_del(fd);
-		close(fd);
+		ep_close(fd);
 	}
 }
-
-static void accept_connection(int afd, int events, void *data)
-{
-	struct sockaddr_storage from;
-	socklen_t namesize;
-	struct connection *conn;
-	int fd, err;
-
-	eprintf("%d\n", afd);
-
-	namesize = sizeof(from);
-	fd = accept(afd, (struct sockaddr *) &from, &namesize);
-	if (fd < 0) {
-		eprintf("can't accept, %m\n");
-		return;
-	}
-
-	conn = conn_alloc();
-	if (!conn)
-		goto out;
-
-	conn->fd = fd;
-
-	conn_read_pdu(conn);
-	set_non_blocking(fd);
-
-	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
-	if (err)
-		goto free_conn;
-
-	return;
-free_conn:
-	free(conn);
-out:
-	close(fd);
-	return;
-}
-
-int iscsi_init(void)
-{
-	struct addrinfo hints, *res, *res0;
-	char servname[64];
-	int err, i, fd, opt, nr_sock = 0;
-
-	memset(servname, 0, sizeof(servname));
-	snprintf(servname, sizeof(servname), "%d", ISCSI_LISTEN_PORT);
-
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_flags = AI_PASSIVE;
-
-	err = getaddrinfo(NULL, servname, &hints, &res0);
-	if (err) {
-		eprintf("unable to get address info, %m\n");
-		return -errno;
-	}
-
-	for (i = 0, res = res0; res && i < LISTEN_MAX; i++, res = res->ai_next) {
-		fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-		if (fd < 0) {
-			if (res->ai_family == AF_INET6)
-				dprintf("IPv6 support is disabled.\n");
-			else
-				eprintf("unable to create fdet %d %d %d, %m\n",
-					res->ai_family,	res->ai_socktype,
-					res->ai_protocol);
-			continue;
-		}
-
-		opt = 1;
-		err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &opt,
-				 sizeof(opt));
-		if (err)
-			dprintf("unable to set SO_REUSEADDR, %m\n");
-
-		opt = 1;
-		if (res->ai_family == AF_INET6) {
-			err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt,
-					 sizeof(opt));
-			if (err) {
-				close(fd);
-				continue;
-			}
-		}
-
-		err = bind(fd, res->ai_addr, res->ai_addrlen);
-		if (err) {
-			close(fd);
-			eprintf("unable to bind server socket, %m\n");
-			continue;
-		}
-
-		err = listen(fd, INCOMING_MAX);
-		if (err) {
-			eprintf("unable to listen to server socket, %m\n");
-			close(fd);
-			continue;
-		}
-
-		set_non_blocking(fd);
-		err = tgt_event_add(fd, EPOLLIN, accept_connection, NULL);
-		if (err)
-			close(fd);
-		else
-			nr_sock++;
-	}
-
-	freeaddrinfo(res0);
-
-	return !nr_sock;
-}

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/iscsi/iscsid.h	2006-09-03 10:57:13 UTC (rev 593)
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 
+#include "transport.h"
 #include "list.h"
 #include "param.h"
 #include "log.h"
@@ -155,6 +156,8 @@
 			unsigned char *challenge;
 		} chap;
 	} auth;
+
+	struct iscsi_transport *tp;
 };
 
 #define IOSTATE_FREE		0
@@ -230,6 +233,7 @@
 extern void conn_add_to_session(struct connection *conn, struct session *session);
 
 /* iscsid.c */
+extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct connection *conn, char *searchKey);
 extern void text_key_add(struct connection *conn, char *key, char *value);
 

Added: trunk/usr/iscsi/transport.c
===================================================================
--- trunk/usr/iscsi/transport.c	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/iscsi/transport.c	2006-09-03 10:57:13 UTC (rev 593)
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <inttypes.h>
+#include <sys/types.h>
+
+#include "transport.h"
+
+struct iscsi_transport *iscsi_transports[] = {
+	&iscsi_tcp,
+	NULL,
+};
+
+int iscsi_init(void)
+{
+	int i, err, nr = 0;
+
+	for (i = 0; iscsi_transports[i]; i++) {
+		err = iscsi_transports[i]->init();
+		if (!err)
+			nr++;
+	}
+	return !nr;
+}

Added: trunk/usr/iscsi/transport.h
===================================================================
--- trunk/usr/iscsi/transport.h	2006-09-03 08:09:19 UTC (rev 592)
+++ trunk/usr/iscsi/transport.h	2006-09-03 10:57:13 UTC (rev 593)
@@ -0,0 +1,17 @@
+#ifndef __TRANSPORT_H
+#define __TRANSPORT_H
+
+struct iscsi_transport {
+	const char *name;
+	int rdma;
+
+	int (*init) (void);
+	size_t (*ep_read) (int ep, void *buf, size_t nbytes);
+	size_t (*ep_write_begin) (int ep, void *buf, size_t nbytes);
+	void (*ep_write_end)(int ep);
+	size_t (*ep_close) (int ep);
+};
+
+extern struct iscsi_transport iscsi_tcp;
+
+#endif



From tomo at mail.berlios.de  Tue Sep 19 14:32:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 19 Sep 2006 14:32:02 +0200
Subject: [Stgt-svn] r594 - trunk/usr
Message-ID: <200609191232.k8JCW2SL027983@sheep.berlios.de>

Author: tomo
Date: 2006-09-19 14:32:02 +0200 (Tue, 19 Sep 2006)
New Revision: 594

Modified:
   trunk/usr/tgtif.c
Log:
Add aligned_u64 define.

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-09-03 10:57:13 UTC (rev 593)
+++ trunk/usr/tgtif.c	2006-09-19 12:32:02 UTC (rev 594)
@@ -33,6 +33,7 @@
 #include <sys/mman.h>
 #include <sys/stat.h>
 
+#define aligned_u64 unsigned long long __attribute__((aligned(8)))
 #include <scsi/scsi_tgt_if.h>
 
 #include "list.h"



