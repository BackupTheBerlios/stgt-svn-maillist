From tomo at mail.berlios.de  Fri Nov  3 09:38:32 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 09:38:32 +0100
Subject: [Stgt-svn] r610 - trunk/usr/ibmvio
Message-ID: <200611030838.kA38cW15022052@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 09:38:32 +0100 (Fri, 03 Nov 2006)
New Revision: 610

Modified:
   trunk/usr/ibmvio/ibmvio.c
Log:
ibmvio.c does not need to include scsi_tgt_if.h

Modified: trunk/usr/ibmvio/ibmvio.c
===================================================================
--- trunk/usr/ibmvio/ibmvio.c	2006-10-31 14:48:40 UTC (rev 609)
+++ trunk/usr/ibmvio/ibmvio.c	2006-11-03 08:38:32 UTC (rev 610)
@@ -37,7 +37,6 @@
 #include <asm/byteorder.h>
 #include <linux/fs.h>
 #include <scsi/scsi.h>
-#include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
 
 #include "list.h"



From tomo at mail.berlios.de  Fri Nov  3 11:41:16 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 11:41:16 +0100
Subject: [Stgt-svn] r611 - trunk/usr
Message-ID: <200611031041.kA3AfGF1004317@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 11:41:15 +0100 (Fri, 03 Nov 2006)
New Revision: 611

Modified:
   trunk/usr/tgtif.c
Log:
The kernel/user interface changed


Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-11-03 08:38:32 UTC (rev 610)
+++ trunk/usr/tgtif.c	2006-11-03 10:41:15 UTC (rev 611)
@@ -68,12 +68,12 @@
 {
 	struct tgt_event *ev;
 	ev = head_ring_hdr(&ukring);
-	if (ev->status == TGT_EVENT_STATUS_USED)
+	if (ev->hdr.status)
 		return -ENOMEM;
 
 	memcpy(ev, p, sizeof(*p));
 	ring_index_inc(&ukring);
-	ev->status = TGT_EVENT_STATUS_USED;
+	ev->hdr.status = 1;
 
 	write(chrfd, ev, 1);
 
@@ -84,9 +84,9 @@
 {
 	struct tgt_event ev;
 
-	ev.u.tsk_mgmt_rsp.host_no = host_no;
-	ev.u.tsk_mgmt_rsp.mid = mid;
-	ev.u.tsk_mgmt_rsp.result = result;
+	ev.p.tsk_mgmt_rsp.host_no = host_no;
+	ev.p.tsk_mgmt_rsp.mid = mid;
+	ev.p.tsk_mgmt_rsp.result = result;
 
 	return kreq_send(&ev);
 }
@@ -96,13 +96,13 @@
 {
 	struct tgt_event ev;
 
-	ev.type = TGT_UEVENT_CMD_RSP;
-	ev.u.cmd_rsp.host_no = host_no;
-	ev.u.cmd_rsp.len = len;
-	ev.u.cmd_rsp.result = result;
-	ev.u.cmd_rsp.uaddr = addr;
-	ev.u.cmd_rsp.rw = rw;
-	ev.u.cmd_rsp.tag = tag;
+	ev.hdr.type = TGT_UEVENT_CMD_RSP;
+	ev.p.cmd_rsp.host_no = host_no;
+	ev.p.cmd_rsp.len = len;
+	ev.p.cmd_rsp.result = result;
+	ev.p.cmd_rsp.uaddr = addr;
+	ev.p.cmd_rsp.rw = rw;
+	ev.p.cmd_rsp.tag = tag;
 
 	return kreq_send(&ev);
 }
@@ -113,34 +113,34 @@
 
 retry:
 	ev = head_ring_hdr(&kuring);
-	if (ev->status == TGT_EVENT_STATUS_EMPTY)
+	if (!ev->hdr.status)
 		return;
 
-	dprintf("event %u %u\n", kuring.idx, ev->type);
+	dprintf("event %u %u\n", kuring.idx, ev->hdr.type);
 
-	switch (ev->type) {
+	switch (ev->hdr.type) {
 	case TGT_KEVENT_CMD_REQ:
-		target_cmd_queue(ev->k.cmd_req.host_no, ev->k.cmd_req.scb,
+		target_cmd_queue(ev->p.cmd_req.host_no, ev->p.cmd_req.scb,
 				 0,
 /* 				 ev->k.cmd_req.uaddr, */
-				 ev->k.cmd_req.lun, ev->k.cmd_req.data_len,
-				 ev->k.cmd_req.attribute, ev->k.cmd_req.tag);
+				 ev->p.cmd_req.lun, ev->p.cmd_req.data_len,
+				 ev->p.cmd_req.attribute, ev->p.cmd_req.tag);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		target_cmd_done(ev->k.cmd_done.host_no, ev->k.cmd_done.tag);
+		target_cmd_done(ev->p.cmd_done.host_no, ev->p.cmd_done.tag);
 		break;
 	case TGT_KEVENT_TSK_MGMT_REQ:
-		target_mgmt_request(ev->k.cmd_req.host_no,
-				    ev->k.tsk_mgmt_req.mid,
-				    ev->k.tsk_mgmt_req.function,
-				    ev->k.tsk_mgmt_req.lun,
-				    ev->k.tsk_mgmt_req.tag);
+		target_mgmt_request(ev->p.cmd_req.host_no,
+				    ev->p.tsk_mgmt_req.mid,
+				    ev->p.tsk_mgmt_req.function,
+				    ev->p.tsk_mgmt_req.lun,
+				    ev->p.tsk_mgmt_req.tag);
 		break;
 	default:
-		eprintf("unknown event %u\n", ev->type);
+		eprintf("unknown event %u\n", ev->hdr.type);
 	}
 
-	ev->status = TGT_EVENT_STATUS_EMPTY;
+	ev->hdr.status = 0;
 	ring_index_inc(&kuring);
 
 	goto retry;



From tomo at mail.berlios.de  Fri Nov  3 11:47:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 11:47:57 +0100
Subject: [Stgt-svn] r612 - trunk/patch
Message-ID: <200611031047.kA3AlvfB004829@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 11:47:57 +0100 (Fri, 03 Nov 2006)
New Revision: 612

Added:
   trunk/patch/aiopoll-git.diff
Log:
Add aiopoll patch for the target git tree


Added: trunk/patch/aiopoll-git.diff
===================================================================
--- trunk/patch/aiopoll-git.diff	2006-11-03 10:41:15 UTC (rev 611)
+++ trunk/patch/aiopoll-git.diff	2006-11-03 10:47:57 UTC (rev 612)
@@ -0,0 +1,10 @@
+#
+# Changed but not updated:
+#   (use git-update-index to mark for commit)
+#
+#	modified: fs/aio.c
+#	modified: fs/eventpoll.c
+#	modified: include/linux/aio.h
+#	modified: include/linux/eventpoll.h
+#
+nothing to commit



From tomo at mail.berlios.de  Fri Nov  3 12:09:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 12:09:33 +0100
Subject: [Stgt-svn] r613 - in trunk/usr: . iscsi
Message-ID: <200611031109.kA3B9Xam030018@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 12:09:32 +0100 (Fri, 03 Nov 2006)
New Revision: 613

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/sched.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/util.h
Log:
Remove the workaround for u8 and 32 bugs in scsi.h


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-03 10:47:57 UTC (rev 612)
+++ trunk/usr/iscsi/iscsid.c	2006-11-03 11:09:32 UTC (rev 613)
@@ -16,14 +16,13 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <scsi/scsi.h>
 #include <sys/epoll.h>
 
 #include "iscsid.h"
 #include "tgtd.h"
 #include "util.h"
 
-#include <scsi/scsi.h>
-
 #define MAX_QUEUE_CMD	32
 
 static struct iscsi_key login_keys[] = {

Modified: trunk/usr/sched.c
===================================================================
--- trunk/usr/sched.c	2006-11-03 10:47:57 UTC (rev 612)
+++ trunk/usr/sched.c	2006-11-03 11:09:32 UTC (rev 613)
@@ -21,6 +21,7 @@
  */
 
 #include <stdlib.h>
+#include <stdint.h>
 
 #include "list.h"
 #include "util.h"

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-11-03 10:47:57 UTC (rev 612)
+++ trunk/usr/scsi.c	2006-11-03 11:09:32 UTC (rev 613)
@@ -21,14 +21,13 @@
 #include <unistd.h>
 #include <asm/byteorder.h>
 #include <linux/fs.h>
+#include <scsi/scsi.h>
 
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
 #include "driver.h"
 
-#include <scsi/scsi.h>
-
 #define BLK_SHIFT	9
 
 int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-03 10:47:57 UTC (rev 612)
+++ trunk/usr/target.c	2006-11-03 11:09:32 UTC (rev 613)
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/socket.h>
+#include <scsi/scsi.h>
 
 #include "list.h"
 #include "util.h"
@@ -34,8 +35,6 @@
 #include "driver.h"
 #include "target.h"
 
-#include <scsi/scsi.h>
-
 static struct target *hostt[MAX_NR_HOST];
 static struct list_head target_hash_list[1 << HASH_ORDER];
 

Modified: trunk/usr/util.h
===================================================================
--- trunk/usr/util.h	2006-11-03 10:47:57 UTC (rev 612)
+++ trunk/usr/util.h	2006-11-03 11:09:32 UTC (rev 613)
@@ -1,13 +1,8 @@
 #ifndef __UTIL_H__
 #define __UTIL_H__
 
-#include <stdint.h>
 #include <sys/user.h>
 
-typedef uint8_t u8;
-typedef uint16_t u16;
-typedef uint32_t u32;
-
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 #define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
 



From tomo at mail.berlios.de  Fri Nov  3 16:52:09 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 16:52:09 +0100
Subject: [Stgt-svn] r614 - trunk/patch
Message-ID: <200611031552.kA3Fq9BN008825@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 16:52:09 +0100 (Fri, 03 Nov 2006)
New Revision: 614

Modified:
   trunk/patch/aiopoll-git.diff
Log:
Fix aiopoll patch for the git tree.


Modified: trunk/patch/aiopoll-git.diff
===================================================================
--- trunk/patch/aiopoll-git.diff	2006-11-03 11:09:32 UTC (rev 613)
+++ trunk/patch/aiopoll-git.diff	2006-11-03 15:52:09 UTC (rev 614)
@@ -1,10 +1,298 @@
-#
-# Changed but not updated:
-#   (use git-update-index to mark for commit)
-#
-#	modified: fs/aio.c
-#	modified: fs/eventpoll.c
-#	modified: include/linux/aio.h
-#	modified: include/linux/eventpoll.h
-#
-nothing to commit
+diff --git a/fs/aio.c b/fs/aio.c
+index 9476659..5edefed 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -35,6 +35,11 @@ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+ #include <asm/mmu_context.h>
+ 
++#ifdef CONFIG_EPOLL
++#include <linux/poll.h>
++#include <linux/eventpoll.h>
++#endif
++
+ #if DEBUG > 1
+ #define dprintk		printk
+ #else
+@@ -1019,6 +1024,10 @@ put_rq:
+ 	if (waitqueue_active(&ctx->wait))
+ 		wake_up(&ctx->wait);
+ 
++#ifdef CONFIG_EPOLL
++	if (ctx->file && waitqueue_active(&ctx->poll_wait))
++		wake_up(&ctx->poll_wait);
++#endif
+ 	if (ret)
+ 		put_ioctx(ctx);
+ 
+@@ -1028,6 +1037,8 @@ put_rq:
+ /* aio_read_evt
+  *	Pull an event off of the ioctx's event ring.  Returns the number of 
+  *	events fetched (0 or 1 ;-)
++ *	If ent parameter is 0, just returns the number of events that would
++ *	be fetched.
+  *	FIXME: make this use cmpxchg.
+  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
+  */
+@@ -1050,13 +1061,18 @@ static int aio_read_evt(struct kioctx *i
+ 
+ 	head = ring->head % info->nr;
+ 	if (head != ring->tail) {
+-		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
+-		*ent = *evp;
+-		head = (head + 1) % info->nr;
+-		smp_mb(); /* finish reading the event before updatng the head */
+-		ring->head = head;
+-		ret = 1;
+-		put_aio_ring_event(evp, KM_USER1);
++		if (ent) { /* event requested */
++			struct io_event *evp =
++				aio_ring_event(info, head, KM_USER1);
++			*ent = *evp;
++			head = (head + 1) % info->nr;
++			/* finish reading the event before updatng the head */
++			smp_mb();
++			ring->head = head;
++			ret = 1;
++			put_aio_ring_event(evp, KM_USER1);
++		} else /* only need to know availability */
++			ret = 1;
+ 	}
+ 	spin_unlock(&info->ring_lock);
+ 
+@@ -1239,9 +1255,78 @@ static void io_destroy(struct kioctx *io
+ 
+ 	aio_cancel_all(ioctx);
+ 	wait_for_all_aios(ioctx);
++#ifdef CONFIG_EPOLL
++	/* forget the poll file, but it's up to the user to close it */
++	if (ioctx->file) {
++		ioctx->file->private_data = 0;
++		ioctx->file = 0;
++	}
++#endif
+ 	put_ioctx(ioctx);	/* once for the lookup */
+ }
+ 
++#ifdef CONFIG_EPOLL
++
++static int aio_queue_fd_close(struct inode *inode, struct file *file)
++{
++	struct kioctx *ioctx = file->private_data;
++	if (ioctx) {
++		file->private_data = 0;
++		spin_lock_irq(&ioctx->ctx_lock);
++		ioctx->file = 0;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++	return 0;
++}
++
++static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
++{	unsigned int pollflags = 0;
++	struct kioctx *ioctx = file->private_data;
++
++	if (ioctx) {
++
++		spin_lock_irq(&ioctx->ctx_lock);
++		/* Insert inside our poll wait queue */
++		poll_wait(file, &ioctx->poll_wait, wait);
++
++		/* Check our condition */
++		if (aio_read_evt(ioctx, 0))
++			pollflags = POLLIN | POLLRDNORM;
++		spin_unlock_irq(&ioctx->ctx_lock);
++	}
++
++	return pollflags;
++}
++
++static struct file_operations aioq_fops = {
++	.release	= aio_queue_fd_close,
++	.poll		= aio_queue_fd_poll
++};
++
++/* make_aio_fd:
++ *  Create a file descriptor that can be used to poll the event queue.
++ *  Based and piggybacked on the excellent epoll code.
++ */
++
++static int make_aio_fd(struct kioctx *ioctx)
++{
++	int error, fd;
++	struct inode *inode;
++	struct file *file;
++
++	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
++	if (error)
++		return error;
++
++	/* associate the file with the IO context */
++	file->private_data = ioctx;
++	ioctx->file = file;
++	init_waitqueue_head(&ioctx->poll_wait);
++	return fd;
++}
++#endif
++
++
+ /* sys_io_setup:
+  *	Create an aio_context capable of receiving at least nr_events.
+  *	ctxp must not point to an aio_context that already exists, and
+@@ -1254,18 +1339,30 @@ static void io_destroy(struct kioctx *io
+  *	resources are available.  May fail with -EFAULT if an invalid
+  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
+  *	implemented.
++ *
++ *	To request a selectable fd, the user context has to be initialized
++ *	to 1, instead of 0, and the return value is the fd.
++ *	This keeps the system call compatible, since a non-zero value
++ *	was not allowed so far.
+  */
+ asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
+ {
+ 	struct kioctx *ioctx = NULL;
+ 	unsigned long ctx;
+ 	long ret;
++	int make_fd = 0;
+ 
+ 	ret = get_user(ctx, ctxp);
+ 	if (unlikely(ret))
+ 		goto out;
+ 
+ 	ret = -EINVAL;
++#ifdef CONFIG_EPOLL
++	if (ctx == 1) {
++		make_fd = 1;
++		ctx = 0;
++	}
++#endif
+ 	if (unlikely(ctx || nr_events == 0)) {
+ 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
+ 		         ctx, nr_events);
+@@ -1276,8 +1373,12 @@ asmlinkage long sys_io_setup(unsigned nr
+ 	ret = PTR_ERR(ioctx);
+ 	if (!IS_ERR(ioctx)) {
+ 		ret = put_user(ioctx->user_id, ctxp);
+-		if (!ret)
+-			return 0;
++#ifdef CONFIG_EPOLL
++		if (make_fd && ret >= 0)
++			ret = make_aio_fd(ioctx);
++#endif
++		if (ret >= 0)
++			return ret;
+ 
+ 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
+ 		io_destroy(ioctx);
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index ae228ec..fc3ff8d 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -238,8 +238,6 @@ struct ep_pqueue {
+ 
+ static void ep_poll_safewake_init(struct poll_safewake *psw);
+ static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep);
+ static int ep_alloc(struct eventpoll **pep);
+ static void ep_free(struct eventpoll *ep);
+ static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
+@@ -269,7 +267,7 @@ static int ep_events_transfer(struct eve
+ static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
+ 		   int maxevents, long timeout);
+ static int eventpollfs_delete_dentry(struct dentry *dentry);
+-static struct inode *ep_eventpoll_inode(void);
++static struct inode *ep_eventpoll_inode(struct file_operations *fops);
+ static int eventpollfs_get_sb(struct file_system_type *fs_type,
+ 			      int flags, const char *dev_name,
+ 			      void *data, struct vfsmount *mnt);
+@@ -519,7 +517,7 @@ asmlinkage long sys_epoll_create(int siz
+ 	 * Creates all the items needed to setup an eventpoll file. That is,
+ 	 * a file structure, and inode and a free file descriptor.
+ 	 */
+-	error = ep_getfd(&fd, &inode, &file, ep);
++	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
+ 	if (error)
+ 		goto eexit_2;
+ 
+@@ -752,8 +750,8 @@ #endif /* #ifdef TIF_RESTORE_SIGMASK */
+ /*
+  * Creates the file descriptor to be used by the epoll interface.
+  */
+-static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
+-		    struct eventpoll *ep)
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++		    struct eventpoll *ep, struct file_operations *fops)
+ {
+ 	struct qstr this;
+ 	char name[32];
+@@ -769,7 +767,7 @@ static int ep_getfd(int *efd, struct ino
+ 		goto eexit_1;
+ 
+ 	/* Allocates an inode from the eventpoll file system */
+-	inode = ep_eventpoll_inode();
++	inode = ep_eventpoll_inode(fops);
+ 	if (IS_ERR(inode)) {
+ 		error = PTR_ERR(inode);
+ 		goto eexit_2;
+@@ -801,7 +799,7 @@ static int ep_getfd(int *efd, struct ino
+ 
+ 	file->f_pos = 0;
+ 	file->f_flags = O_RDONLY;
+-	file->f_op = &eventpoll_fops;
++	file->f_op = fops;
+ 	file->f_mode = FMODE_READ;
+ 	file->f_version = 0;
+ 	file->private_data = ep;
+@@ -1620,7 +1618,7 @@ static int eventpollfs_delete_dentry(str
+ }
+ 
+ 
+-static struct inode *ep_eventpoll_inode(void)
++static struct inode *ep_eventpoll_inode(struct file_operations *fops)
+ {
+ 	int error = -ENOMEM;
+ 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
+@@ -1628,7 +1626,7 @@ static struct inode *ep_eventpoll_inode(
+ 	if (!inode)
+ 		goto eexit_1;
+ 
+-	inode->i_fop = &eventpoll_fops;
++	inode->i_fop = fops;
+ 
+ 	/*
+ 	 * Mark the inode dirty from the very beginning,
+diff --git a/include/linux/aio.h b/include/linux/aio.h
+index 0d71c00..71e8ac8 100644
+--- a/include/linux/aio.h
++++ b/include/linux/aio.h
+@@ -195,6 +195,11 @@ struct kioctx {
+ 	struct aio_ring_info	ring_info;
+ 
+ 	struct work_struct	wq;
++#ifdef CONFIG_EPOLL
++	// poll integration
++	wait_queue_head_t       poll_wait;
++	struct file		*file;
++#endif
+ };
+ 
+ /* prototypes */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..f2a22bc 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -90,6 +90,12 @@ static inline void eventpoll_release(str
+ 	eventpoll_release_file(file);
+ }
+ 
++/*
++ * called by aio code to create fd that can poll the  aio event queueQ
++ */
++struct eventpoll;
++int ep_getfd(int *efd, struct inode **einode, struct file **efile,
++             struct eventpoll *ep, struct file_operations *fops);
+ #else
+ 
+ static inline void eventpoll_init_file(struct file *file) {}



From tomo at mail.berlios.de  Fri Nov  3 17:02:52 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 3 Nov 2006 17:02:52 +0100
Subject: [Stgt-svn] r615 - trunk/usr
Message-ID: <200611031602.kA3G2qTi010009@sheep.berlios.de>

Author: tomo
Date: 2006-11-03 17:02:52 +0100 (Fri, 03 Nov 2006)
New Revision: 615

Modified:
   trunk/usr/bd_aio.c
Log:
Add some aio dprintf.

Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-03 15:52:09 UTC (rev 614)
+++ trunk/usr/bd_aio.c	2006-11-03 16:02:52 UTC (rev 615)
@@ -74,7 +74,7 @@
 
 	for (i = 0; i < nr; i++) {
 		iocb = bai->events[i].obj;
-		dprintf("%p\n", iocb->data);
+		dprintf("%p %p\n", iocb, iocb->data);
 		target_cmd_io_done(iocb->data, 0);
 	}
 }
@@ -148,7 +148,8 @@
 	io = &iocb;
 	memset(io, 0, sizeof(*io));
 
-	dprintf("%d %d %u %lx %" PRIx64 " %p\n", bai->fd, rw, datalen, *uaddr, offset, key);
+	dprintf("%d %d %u %lx %" PRIx64 " %p %p\n", bai->fd, rw, datalen, *uaddr, offset,
+		io, key);
 
 	if (rw == READ)
 		io_prep_pread(io, bai->fd, (void *) *uaddr, datalen, offset);



From tomo at mail.berlios.de  Sun Nov  5 16:44:42 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 5 Nov 2006 16:44:42 +0100
Subject: [Stgt-svn] r616 - trunk/usr
Message-ID: <200611051544.kA5Figku016805@sheep.berlios.de>

Author: tomo
Date: 2006-11-05 16:44:42 +0100 (Sun, 05 Nov 2006)
New Revision: 616

Modified:
   trunk/usr/bd_aio.c
Log:
From: Pete Wyckoff <pw at osc.edu>

io_submit uses iocb on the stack so io_getevents returns bogus values.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-03 16:02:52 UTC (rev 615)
+++ trunk/usr/bd_aio.c	2006-11-05 15:44:42 UTC (rev 616)
@@ -65,7 +65,7 @@
 	struct tgt_device *dev;
 	struct bd_aio_info *bai;
 	int i, nr;
-	struct iocb *iocb;
+/* 	struct iocb *iocb; */
 
 	dev = (struct tgt_device *) data;
 	bai = (struct bd_aio_info *) dev->bddata;
@@ -73,9 +73,11 @@
 	nr = io_getevents(bai->ctx, 0, MAX_AIO_REQS, bai->events, NULL);
 
 	for (i = 0; i < nr; i++) {
-		iocb = bai->events[i].obj;
-		dprintf("%p %p\n", iocb, iocb->data);
-		target_cmd_io_done(iocb->data, 0);
+/* 		iocb = bai->events[i].obj; */
+/* 		dprintf("%p %p\n", iocb, iocb->data); */
+/* 		target_cmd_io_done(iocb->data, 0); */
+		dprintf("%p\n", bai->events[i].data);
+		target_cmd_io_done(bai->events[i].data, 0);
 	}
 }
 



From tomo at mail.berlios.de  Wed Nov  8 10:05:22 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 10:05:22 +0100
Subject: [Stgt-svn] r617 - trunk/patch
Message-ID: <200611080905.kA895M3p003560@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 10:05:22 +0100 (Wed, 08 Nov 2006)
New Revision: 617

Added:
   trunk/patch/epoll-git.diff
Log:
Add IO_CMD_EPOLL_WAIT patch against the git tree.


Added: trunk/patch/epoll-git.diff
===================================================================
--- trunk/patch/epoll-git.diff	2006-11-05 15:44:42 UTC (rev 616)
+++ trunk/patch/epoll-git.diff	2006-11-08 09:05:22 UTC (rev 617)
@@ -0,0 +1,236 @@
+diff --git a/fs/aio.c b/fs/aio.c
+index 9476659..2da577c 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -30,6 +30,7 @@ #include <linux/aio.h>
+ #include <linux/highmem.h>
+ #include <linux/workqueue.h>
+ #include <linux/security.h>
++#include <linux/eventpoll.h>
+ 
+ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+@@ -869,7 +870,7 @@ static void aio_kick_handler(void *data)
+ 	use_mm(ctx->mm);
+ 	spin_lock_irq(&ctx->ctx_lock);
+ 	requeue =__aio_run_iocbs(ctx);
+- 	unuse_mm(ctx->mm);
++	unuse_mm(ctx->mm);
+ 	spin_unlock_irq(&ctx->ctx_lock);
+ 	set_fs(oldfs);
+ 	/*
+@@ -1504,6 +1505,9 @@ static ssize_t aio_setup_iocb(struct kio
+ 		if (file->f_op->aio_fsync)
+ 			kiocb->ki_retry = aio_fsync;
+ 		break;
++	case IOCB_CMD_EPOLL_WAIT:
++		kiocb->ki_retry = eventpoll_aio_wait;
++		break;
+ 	default:
+ 		dprintk("EINVAL: io_submit: no operation provided\n");
+ 		ret = -EINVAL;
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index ae228ec..d1fcbdf 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
+ #include <linux/mount.h>
+ #include <linux/bitops.h>
+ #include <linux/mutex.h>
++#include <linux/aio.h>
+ #include <asm/uaccess.h>
+ #include <asm/system.h>
+ #include <asm/io.h>
+@@ -642,6 +643,145 @@ eexit_1:
+ 	return error;
+ }
+ 
++static void eventpoll_aio_timer(unsigned long data)
++{
++	struct kiocb *iocb = (struct kiocb *)data;
++	struct timer_list *timer = (struct timer_list *)iocb->private;
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++
++	(void)del_timer(timer);
++	write_lock(&ep->lock);
++	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
++	write_unlock(&ep->lock);
++}
++
++static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
++{
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	int ret = -1;
++	struct list_head *list;
++	int seen = 0;
++
++	write_lock_irq(&ep->lock);
++
++	if (iocb->private)
++		del_timer((struct timer_list *)iocb->private);
++	/*
++	 *  We duplicate the code found in remove_wait_queue, since we
++	 *  can't call that function from here.  We can only call
++	 *  __remove_wait_queue (same as remove_wait_queue_locked) which
++	 *  does not check to see if the item was actually removed from the
++	 *  queue.
++	 */
++	list = &ep->wq.task_list;
++
++	do {
++		struct list_head *next;
++		if (list == &iocb->ki_wait.task_list)
++			seen++;
++		next = list->next;
++		if (next->prev != list) {
++			seen += 2;
++			break;
++		}
++		list = next;
++	} while (list != &ep->wq.task_list);
++
++	if (seen == 1) {
++		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
++		ret = 0;
++	}
++	write_unlock_irq(&ep->lock);
++
++	if (ret == 0) {
++		/* successfully cancelled request */
++		kfree(iocb->private);
++		iocb->private = NULL;
++		/* drop the i/o reference */
++		aio_put_req(iocb);
++	} else
++		ret = -EAGAIN;
++
++	event->res = event->res2 = 0;
++	/* drop the cancel reference */
++	aio_put_req(iocb);
++
++	return ret;
++}
++
++/*
++ * iocb->ki_nbytes -- number of events
++ * iocb->ki_pos    -- relative timeout in milliseconds
++ * iocb->private   -- NULL first go;  after that, it's set to the the
++ *                    absolute timeout in jiffies.
++ */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb)
++{
++	struct file *file = iocb->ki_filp;
++	ssize_t ret = -EINVAL;
++	int relative_ms;
++	unsigned long expires;
++	unsigned long now;
++	struct timer_list *timer;
++
++	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
++	    iocb->ki_nbytes <= 0)
++		return -EINVAL;
++
++	if (!iocb->private) {
++		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++		if (!timer)
++			return -ENOMEM;
++
++		if (iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++			expires = MAX_SCHEDULE_TIMEOUT;
++		else
++			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
++
++		init_timer(timer);
++		timer->function = eventpoll_aio_timer;
++		timer->data = (unsigned long)iocb;
++		timer->expires = expires;
++	} else {
++		timer = (struct timer_list *)iocb->private;
++		expires = timer->expires;
++	}
++
++	now = jiffies;
++	if (time_before(now, expires))
++		relative_ms =
++			jiffies_to_msecs(expires) - jiffies_to_msecs(now);
++	else
++		relative_ms = 0;
++
++	iocb->ki_cancel = aio_epoll_cancel;
++	ret = ep_poll(file->private_data,
++		      (struct epoll_event __user *)iocb->ki_buf,
++		      iocb->ki_nbytes, relative_ms);
++
++	/*
++	 *  If we've added ourselves to the wait queue, there is a timeout
++	 *  specified, and we didn't setup the timer yet, then go ahead and
++	 *  add the timer.
++	 */
++	if (ret == -EIOCBRETRY && !iocb->private) {
++		iocb->private = timer;
++		if (expires != MAX_SCHEDULE_TIMEOUT)
++			add_timer(timer);
++	}
++
++	/* Perform cleanup if the poll has finished */
++	if (ret > 0 || relative_ms == 0) {
++		iocb->ki_cancel = NULL;
++		iocb->private = NULL;
++		(void)del_timer(timer);
++		kfree(timer);
++	}
++
++	return ret;
++}
+ 
+ /*
+  * Implement the event wait interface for the eventpoll file. It is the kernel
+@@ -1564,6 +1704,12 @@ retry:
+ 
+ 	res = 0;
+ 	if (list_empty(&ep->rdllist)) {
++		if (in_aio() && jtimeout) {
++			__add_wait_queue(&ep->wq, current->io_wait);
++			res = -EIOCBRETRY;
++			write_unlock_irqrestore(&ep->lock, flags);
++			goto out;
++		}
+ 		/*
+ 		 * We don't have any available event to return to the caller.
+ 		 * We need to sleep here, and we will be wake up by
+@@ -1609,6 +1755,7 @@ retry:
+ 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
+ 		goto retry;
+ 
++out:
+ 	return res;
+ }
+ 
+diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
+index e3ca0a4..1b9ba18 100644
+--- a/include/linux/aio_abi.h
++++ b/include/linux/aio_abi.h
+@@ -43,6 +43,7 @@ enum {
+ 	IOCB_CMD_NOOP = 6,
+ 	IOCB_CMD_PREADV = 7,
+ 	IOCB_CMD_PWRITEV = 8,
++ 	IOCB_CMD_EPOLL_WAIT = 9,
+ };
+ 
+ /* read() from /dev/aio returns these structures. */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..ed04500 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
+ /* Used to release the epoll bits inside the "struct file" */
+ void eventpoll_release_file(struct file *file);
+ 
++/* Used to provide epoll_wait() to sys_io_submit() */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb);
++
+ /*
+  * This is called from inside fs/file_table.c:__fput() to unlink files
+  * from the eventpoll interface. We need to have this facility to cleanup



From tomo at mail.berlios.de  Wed Nov  8 10:16:23 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 10:16:23 +0100
Subject: [Stgt-svn] r618 - trunk/usr
Message-ID: <200611080916.kA89GNX8005050@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 10:16:23 +0100 (Wed, 08 Nov 2006)
New Revision: 618

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/tgtd.c
Log:
Move to IO_CMD_EPOLL_WAIT interface from aio event queue interface.


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-08 09:05:22 UTC (rev 617)
+++ trunk/usr/bd_aio.c	2006-11-08 09:16:23 UTC (rev 618)
@@ -44,48 +44,24 @@
  * IO_CMD_EPOLL_WAIT, looks more promising. kqueue is promising too.
  */
 
-#define REQUEST_ASYNC_FD 1
-
 /* FIXME */
 #define MAX_AIO_REQS 1024
 #define O_DIRECT 040000 /* who defines this?*/
 
 struct bd_aio_info {
 	int fd;
-	int aio_fd;
 
-	io_context_t ctx;
 	/* TODO: batch requests*/
 	struct iocb iocb[MAX_AIO_REQS];
 	struct io_event events[MAX_AIO_REQS];
 };
 
-static void aio_event_handler(int fd, int events, void *data)
-{
-	struct tgt_device *dev;
-	struct bd_aio_info *bai;
-	int i, nr;
-/* 	struct iocb *iocb; */
+extern io_context_t ctx;
 
-	dev = (struct tgt_device *) data;
-	bai = (struct bd_aio_info *) dev->bddata;
-
-	nr = io_getevents(bai->ctx, 0, MAX_AIO_REQS, bai->events, NULL);
-
-	for (i = 0; i < nr; i++) {
-/* 		iocb = bai->events[i].obj; */
-/* 		dprintf("%p %p\n", iocb, iocb->data); */
-/* 		target_cmd_io_done(iocb->data, 0); */
-		dprintf("%p\n", bai->events[i].data);
-		target_cmd_io_done(bai->events[i].data, 0);
-	}
-}
-
 static struct tgt_device *bd_aio_open(char *path, int *fd, uint64_t *size)
 {
 	struct tgt_device *dev;
 	struct bd_aio_info *bai;
-	int err;
 
 	dev = zalloc(sizeof(*dev) + sizeof(*bai));
 	if (!dev)
@@ -96,35 +72,11 @@
 		goto free_dev;
 
 	bai = (struct bd_aio_info *) dev->bddata;
-
-	bai->ctx = (io_context_t) REQUEST_ASYNC_FD;
-	bai->aio_fd = io_setup(MAX_AIO_REQS, &bai->ctx);
-	if (bai->aio_fd < 0) {
-		eprintf("Can't setup aio fd, %m\n");
-		goto close_fd;
-	}
-
-	/*
-	 * We use edge triggering because we want only one
-	 * notification per task.
-	 */
-	err = tgt_event_add(bai->aio_fd, EPOLLIN | EPOLLET,
-			    aio_event_handler, dev);
-	if (err)
-		goto aio_cb_destroy;
-
-	dprintf("Succeeded to setup aio fd, %s\n", path);
-
 	bai->fd = *fd;
-	return dev;
 
-aio_cb_destroy:
-	io_destroy(bai->ctx);
-close_fd:
-	close(*fd);
+	return dev;
 free_dev:
 	free(dev);
-
 	return NULL;
 }
 
@@ -133,7 +85,6 @@
 	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
 
 	tgt_event_del(bai->fd);
-	io_destroy(bai->ctx);
 	free(dev);
 }
 
@@ -159,7 +110,7 @@
 		io_prep_pwrite(io, bai->fd, (void *) *uaddr, datalen, offset);
 
 	io->data = key;
-	err = io_submit(bai->ctx, 1, &io);
+	err = io_submit(ctx, 1, &io);
 
 	return 0;
 }

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-08 09:05:22 UTC (rev 617)
+++ trunk/usr/tgtd.c	2006-11-08 09:16:23 UTC (rev 618)
@@ -23,6 +23,7 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
+#include <libaio.h>
 #include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -46,6 +47,8 @@
 	struct list_head e_list;
 };
 
+io_context_t ctx;
+
 static int ep_fd;
 static char program_name[] = "tgtd";
 static LIST_HEAD(tgt_events_list);
@@ -168,15 +171,44 @@
 	return epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &ev);
 }
 
+#define IOCB_CMD_EPOLL_WAIT 9
+
+static void io_prep_epoll_wait(struct iocb *iocb, int epfd,
+			       struct epoll_event *events, int maxevents,
+			       int timeout)
+{
+	memset(iocb, 0, sizeof(*iocb));
+	iocb->aio_fildes = epfd;
+	iocb->aio_lio_opcode = IOCB_CMD_EPOLL_WAIT;
+	iocb->aio_reqprio = 0;
+
+	iocb->u.c.nbytes = maxevents;
+	iocb->u.c.offset = timeout;
+	iocb->u.c.buf = events;
+}
+
 static void event_loop(void)
 {
-	int nevent, i;
-	static int timeout = 1000 / SCHED_HZ;
+	int nevent, i, err;
 	struct epoll_event events[1024];
 	struct tgt_event *tev;
+	struct iocb iocbs[1], *iocb;
+	struct io_event aioevents[2048];
+	struct timespec timeout = {1, 0};
 
+	err = io_queue_init(2048, &ctx);
+	if (err) {
+		eprintf("%m\n");
+		return;
+	}
+
+	iocb = iocbs;
+	io_prep_epoll_wait(iocb, ep_fd, events, ARRAY_SIZE(events), -1);
+	err = io_submit(ctx, 1, &iocb);
+
 retry:
-	nevent = epoll_wait(ep_fd, events, ARRAY_SIZE(events), timeout);
+	nevent = io_getevents(ctx, 1, ARRAY_SIZE(aioevents), aioevents, &timeout);
+
 	if (nevent < 0) {
 		if (errno != EINTR) {
 			eprintf("%m\n");
@@ -184,8 +216,18 @@
 		}
 	} else if (nevent) {
 		for (i = 0; i < nevent; i++) {
-			tev = (struct tgt_event *) events[i].data.ptr;
-			tev->handler(tev->fd, events[i].events, tev->data);
+			if (iocb == aioevents[i].obj) {
+				int j;
+				for (j = 0; j < aioevents[i].res; j++) {
+					tev = (struct tgt_event *) events[j].data.ptr;
+					tev->handler(tev->fd, events[j].events, tev->data);
+				}
+
+				err = io_submit(ctx, 1, &iocb);
+			} else {
+				/* FIXME */
+				target_cmd_io_done(aioevents[i].data, 0);
+			}
 		}
 	} else
 		schedule();



From tomo at mail.berlios.de  Wed Nov  8 10:21:28 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 10:21:28 +0100
Subject: [Stgt-svn] r619 - trunk/patch
Message-ID: <200611080921.kA89LSD2006243@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 10:21:28 +0100 (Wed, 08 Nov 2006)
New Revision: 619

Removed:
   trunk/patch/aiopoll-2.6.16.13.diff
   trunk/patch/aiopoll-2.6.18-rc4.diff
   trunk/patch/aiopoll-git.diff
Log:
Remove old patches for aio event queue interface.


Deleted: trunk/patch/aiopoll-2.6.16.13.diff
===================================================================
--- trunk/patch/aiopoll-2.6.16.13.diff	2006-11-08 09:16:23 UTC (rev 618)
+++ trunk/patch/aiopoll-2.6.16.13.diff	2006-11-08 09:21:28 UTC (rev 619)
@@ -1,297 +0,0 @@
-diff -pruN ../pristine-linux-2.6.16-rc5/fs/aio.c ./fs/aio.c
---- ../pristine-linux-2.6.16-rc5/fs/aio.c	2006-03-14 14:10:10.827401387 +0000
-+++ ./fs/aio.c	2006-03-16 09:57:53.898316582 +0000
-@@ -34,6 +34,11 @@
- #include <asm/uaccess.h>
- #include <asm/mmu_context.h>
- 
-+#ifdef CONFIG_EPOLL
-+#include <linux/poll.h>
-+#include <linux/eventpoll.h>
-+#endif
-+
- #if DEBUG > 1
- #define dprintk		printk
- #else
-@@ -1016,6 +1021,10 @@ put_rq:
- 	if (waitqueue_active(&ctx->wait))
- 		wake_up(&ctx->wait);
- 
-+#ifdef CONFIG_EPOLL
-+	if (ctx->file && waitqueue_active(&ctx->poll_wait))
-+		wake_up(&ctx->poll_wait);
-+#endif
- 	if (ret)
- 		put_ioctx(ctx);
- 
-@@ -1025,6 +1034,8 @@ put_rq:
- /* aio_read_evt
-  *	Pull an event off of the ioctx's event ring.  Returns the number of 
-  *	events fetched (0 or 1 ;-)
-+ *	If ent parameter is 0, just returns the number of events that would
-+ *	be fetched.
-  *	FIXME: make this use cmpxchg.
-  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
-  */
-@@ -1047,13 +1058,18 @@ static int aio_read_evt(struct kioctx *i
- 
- 	head = ring->head % info->nr;
- 	if (head != ring->tail) {
--		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
--		*ent = *evp;
--		head = (head + 1) % info->nr;
--		smp_mb(); /* finish reading the event before updatng the head */
--		ring->head = head;
--		ret = 1;
--		put_aio_ring_event(evp, KM_USER1);
-+		if (ent) { /* event requested */
-+			struct io_event *evp =
-+				aio_ring_event(info, head, KM_USER1);
-+			*ent = *evp;
-+			head = (head + 1) % info->nr;
-+			/* finish reading the event before updatng the head */
-+			smp_mb();
-+			ring->head = head;
-+			ret = 1;
-+			put_aio_ring_event(evp, KM_USER1);
-+		} else /* only need to know availability */
-+			ret = 1;
- 	}
- 	spin_unlock(&info->ring_lock);
- 
-@@ -1236,9 +1252,78 @@ static void io_destroy(struct kioctx *io
- 
- 	aio_cancel_all(ioctx);
- 	wait_for_all_aios(ioctx);
-+#ifdef CONFIG_EPOLL
-+	/* forget the poll file, but it's up to the user to close it */
-+	if (ioctx->file) {
-+		ioctx->file->private_data = 0;
-+		ioctx->file = 0;
-+	}
-+#endif
- 	put_ioctx(ioctx);	/* once for the lookup */
- }
- 
-+#ifdef CONFIG_EPOLL
-+
-+static int aio_queue_fd_close(struct inode *inode, struct file *file)
-+{
-+	struct kioctx *ioctx = file->private_data;
-+	if (ioctx) {
-+		file->private_data = 0;
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		ioctx->file = 0;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+	return 0;
-+}
-+
-+static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
-+{	unsigned int pollflags = 0;
-+	struct kioctx *ioctx = file->private_data;
-+
-+	if (ioctx) {
-+
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		/* Insert inside our poll wait queue */
-+		poll_wait(file, &ioctx->poll_wait, wait);
-+
-+		/* Check our condition */
-+		if (aio_read_evt(ioctx, 0))
-+			pollflags = POLLIN | POLLRDNORM;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+
-+	return pollflags;
-+}
-+
-+static struct file_operations aioq_fops = {
-+	.release	= aio_queue_fd_close,
-+	.poll		= aio_queue_fd_poll
-+};
-+
-+/* make_aio_fd:
-+ *  Create a file descriptor that can be used to poll the event queue.
-+ *  Based and piggybacked on the excellent epoll code.
-+ */
-+
-+static int make_aio_fd(struct kioctx *ioctx)
-+{
-+	int error, fd;
-+	struct inode *inode;
-+	struct file *file;
-+
-+	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
-+	if (error)
-+		return error;
-+
-+	/* associate the file with the IO context */
-+	file->private_data = ioctx;
-+	ioctx->file = file;
-+	init_waitqueue_head(&ioctx->poll_wait);
-+	return fd;
-+}
-+#endif
-+
-+
- /* sys_io_setup:
-  *	Create an aio_context capable of receiving at least nr_events.
-  *	ctxp must not point to an aio_context that already exists, and
-@@ -1251,18 +1336,30 @@ static void io_destroy(struct kioctx *io
-  *	resources are available.  May fail with -EFAULT if an invalid
-  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
-  *	implemented.
-+ *
-+ *	To request a selectable fd, the user context has to be initialized
-+ *	to 1, instead of 0, and the return value is the fd.
-+ *	This keeps the system call compatible, since a non-zero value
-+ *	was not allowed so far.
-  */
- asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
- {
- 	struct kioctx *ioctx = NULL;
- 	unsigned long ctx;
- 	long ret;
-+	int make_fd = 0;
- 
- 	ret = get_user(ctx, ctxp);
- 	if (unlikely(ret))
- 		goto out;
- 
- 	ret = -EINVAL;
-+#ifdef CONFIG_EPOLL
-+	if (ctx == 1) {
-+		make_fd = 1;
-+		ctx = 0;
-+	}
-+#endif
- 	if (unlikely(ctx || nr_events == 0)) {
- 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
- 		         ctx, nr_events);
-@@ -1273,8 +1370,12 @@ asmlinkage long sys_io_setup(unsigned nr
- 	ret = PTR_ERR(ioctx);
- 	if (!IS_ERR(ioctx)) {
- 		ret = put_user(ioctx->user_id, ctxp);
--		if (!ret)
--			return 0;
-+#ifdef CONFIG_EPOLL
-+		if (make_fd && ret >= 0)
-+			ret = make_aio_fd(ioctx);
-+#endif
-+		if (ret >= 0)
-+			return ret;
- 
- 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
- 		io_destroy(ioctx);
-
-diff -pruN ../pristine-linux-2.6.16-rc5/fs/eventpoll.c ./fs/eventpoll.c
---- ../pristine-linux-2.6.16-rc5/fs/eventpoll.c	2006-01-03 03:21:10.000000000 +0000
-+++ ./fs/eventpoll.c	2006-03-16 10:04:35.469956167 +0000
-@@ -235,8 +235,6 @@ struct ep_pqueue {
- 
- static void ep_poll_safewake_init(struct poll_safewake *psw);
- static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep);
- static int ep_alloc(struct eventpoll **pep);
- static void ep_free(struct eventpoll *ep);
- static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
-@@ -266,7 +264,7 @@ static int ep_events_transfer(struct eve
- static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
- 		   int maxevents, long timeout);
- static int eventpollfs_delete_dentry(struct dentry *dentry);
--static struct inode *ep_eventpoll_inode(void);
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops);
- static struct super_block *eventpollfs_get_sb(struct file_system_type *fs_type,
- 					      int flags, const char *dev_name,
- 					      void *data);
-@@ -525,7 +523,7 @@ asmlinkage long sys_epoll_create(int siz
- 	 * Creates all the items needed to setup an eventpoll file. That is,
- 	 * a file structure, and inode and a free file descriptor.
- 	 */
--	error = ep_getfd(&fd, &inode, &file, ep);
-+	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
- 	if (error)
- 		goto eexit_2;
- 
-@@ -710,8 +708,8 @@ eexit_1:
- /*
-  * Creates the file descriptor to be used by the epoll interface.
-  */
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep)
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+		    struct eventpoll *ep, struct file_operations *fops)
- {
- 	struct qstr this;
- 	char name[32];
-@@ -727,7 +725,7 @@ static int ep_getfd(int *efd, struct ino
- 		goto eexit_1;
- 
- 	/* Allocates an inode from the eventpoll file system */
--	inode = ep_eventpoll_inode();
-+	inode = ep_eventpoll_inode(fops);
- 	error = PTR_ERR(inode);
- 	if (IS_ERR(inode))
- 		goto eexit_2;
-@@ -758,7 +756,7 @@ static int ep_getfd(int *efd, struct ino
- 
- 	file->f_pos = 0;
- 	file->f_flags = O_RDONLY;
--	file->f_op = &eventpoll_fops;
-+	file->f_op = fops;
- 	file->f_mode = FMODE_READ;
- 	file->f_version = 0;
- 	file->private_data = ep;
-@@ -1574,7 +1572,7 @@ static int eventpollfs_delete_dentry(str
- }
- 
- 
--static struct inode *ep_eventpoll_inode(void)
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops)
- {
- 	int error = -ENOMEM;
- 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
-@@ -1582,7 +1580,7 @@ static struct inode *ep_eventpoll_inode(
- 	if (!inode)
- 		goto eexit_1;
- 
--	inode->i_fop = &eventpoll_fops;
-+	inode->i_fop = fops;
- 
- 	/*
- 	 * Mark the inode dirty from the very beginning,
-
-diff -pruN ../pristine-linux-2.6.16-rc5/include/linux/aio.h ./include/linux/aio.h
---- ../pristine-linux-2.6.16-rc5/include/linux/aio.h	2006-03-14 14:10:21.597916731 +0000
-+++ ./include/linux/aio.h	2006-03-16 10:05:39.848833028 +0000
-@@ -191,6 +191,11 @@ struct kioctx {
- 	struct aio_ring_info	ring_info;
- 
- 	struct work_struct	wq;
-+#ifdef CONFIG_EPOLL
-+	// poll integration
-+	wait_queue_head_t       poll_wait;
-+	struct file		*file;
-+#endif
- };
- 
- /* prototypes */
-
-diff -pruN ../pristine-linux-2.6.16-rc5/include/linux/eventpoll.h ./include/linux/eventpoll.h
---- ../pristine-linux-2.6.16-rc5/include/linux/eventpoll.h	2006-01-03 03:21:10.000000000 +0000
-+++ ./include/linux/eventpoll.h	2006-03-16 10:08:51.577809317 +0000
-@@ -86,6 +86,12 @@ static inline void eventpoll_release(str
- }
- 
- 
-+/*
-+ * called by aio code to create fd that can poll the  aio event queueQ
-+ */
-+struct eventpoll;
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+             struct eventpoll *ep, struct file_operations *fops);
- #else
- 
- static inline void eventpoll_init_file(struct file *file) {}

Deleted: trunk/patch/aiopoll-2.6.18-rc4.diff
===================================================================
--- trunk/patch/aiopoll-2.6.18-rc4.diff	2006-11-08 09:16:23 UTC (rev 618)
+++ trunk/patch/aiopoll-2.6.18-rc4.diff	2006-11-08 09:21:28 UTC (rev 619)
@@ -1,298 +0,0 @@
-diff --git a/fs/aio.c b/fs/aio.c
-index 9506301..99c5eba 100644
---- a/fs/aio.c
-+++ b/fs/aio.c
-@@ -34,6 +34,11 @@ #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
- #include <asm/mmu_context.h>
- 
-+#ifdef CONFIG_EPOLL
-+#include <linux/poll.h>
-+#include <linux/eventpoll.h>
-+#endif
-+
- #if DEBUG > 1
- #define dprintk		printk
- #else
-@@ -1015,6 +1020,10 @@ put_rq:
- 	if (waitqueue_active(&ctx->wait))
- 		wake_up(&ctx->wait);
- 
-+#ifdef CONFIG_EPOLL
-+	if (ctx->file && waitqueue_active(&ctx->poll_wait))
-+		wake_up(&ctx->poll_wait);
-+#endif
- 	if (ret)
- 		put_ioctx(ctx);
- 
-@@ -1024,6 +1033,8 @@ put_rq:
- /* aio_read_evt
-  *	Pull an event off of the ioctx's event ring.  Returns the number of 
-  *	events fetched (0 or 1 ;-)
-+ *	If ent parameter is 0, just returns the number of events that would
-+ *	be fetched.
-  *	FIXME: make this use cmpxchg.
-  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
-  */
-@@ -1046,13 +1057,18 @@ static int aio_read_evt(struct kioctx *i
- 
- 	head = ring->head % info->nr;
- 	if (head != ring->tail) {
--		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
--		*ent = *evp;
--		head = (head + 1) % info->nr;
--		smp_mb(); /* finish reading the event before updatng the head */
--		ring->head = head;
--		ret = 1;
--		put_aio_ring_event(evp, KM_USER1);
-+		if (ent) { /* event requested */
-+			struct io_event *evp =
-+				aio_ring_event(info, head, KM_USER1);
-+			*ent = *evp;
-+			head = (head + 1) % info->nr;
-+			/* finish reading the event before updatng the head */
-+			smp_mb();
-+			ring->head = head;
-+			ret = 1;
-+			put_aio_ring_event(evp, KM_USER1);
-+		} else /* only need to know availability */
-+			ret = 1;
- 	}
- 	spin_unlock(&info->ring_lock);
- 
-@@ -1235,9 +1251,78 @@ static void io_destroy(struct kioctx *io
- 
- 	aio_cancel_all(ioctx);
- 	wait_for_all_aios(ioctx);
-+#ifdef CONFIG_EPOLL
-+	/* forget the poll file, but it's up to the user to close it */
-+	if (ioctx->file) {
-+		ioctx->file->private_data = 0;
-+		ioctx->file = 0;
-+	}
-+#endif
- 	put_ioctx(ioctx);	/* once for the lookup */
- }
- 
-+#ifdef CONFIG_EPOLL
-+
-+static int aio_queue_fd_close(struct inode *inode, struct file *file)
-+{
-+	struct kioctx *ioctx = file->private_data;
-+	if (ioctx) {
-+		file->private_data = 0;
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		ioctx->file = 0;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+	return 0;
-+}
-+
-+static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
-+{	unsigned int pollflags = 0;
-+	struct kioctx *ioctx = file->private_data;
-+
-+	if (ioctx) {
-+
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		/* Insert inside our poll wait queue */
-+		poll_wait(file, &ioctx->poll_wait, wait);
-+
-+		/* Check our condition */
-+		if (aio_read_evt(ioctx, 0))
-+			pollflags = POLLIN | POLLRDNORM;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+
-+	return pollflags;
-+}
-+
-+static struct file_operations aioq_fops = {
-+	.release	= aio_queue_fd_close,
-+	.poll		= aio_queue_fd_poll
-+};
-+
-+/* make_aio_fd:
-+ *  Create a file descriptor that can be used to poll the event queue.
-+ *  Based and piggybacked on the excellent epoll code.
-+ */
-+
-+static int make_aio_fd(struct kioctx *ioctx)
-+{
-+	int error, fd;
-+	struct inode *inode;
-+	struct file *file;
-+
-+	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
-+	if (error)
-+		return error;
-+
-+	/* associate the file with the IO context */
-+	file->private_data = ioctx;
-+	ioctx->file = file;
-+	init_waitqueue_head(&ioctx->poll_wait);
-+	return fd;
-+}
-+#endif
-+
-+
- /* sys_io_setup:
-  *	Create an aio_context capable of receiving at least nr_events.
-  *	ctxp must not point to an aio_context that already exists, and
-@@ -1250,18 +1335,30 @@ static void io_destroy(struct kioctx *io
-  *	resources are available.  May fail with -EFAULT if an invalid
-  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
-  *	implemented.
-+ *
-+ *	To request a selectable fd, the user context has to be initialized
-+ *	to 1, instead of 0, and the return value is the fd.
-+ *	This keeps the system call compatible, since a non-zero value
-+ *	was not allowed so far.
-  */
- asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
- {
- 	struct kioctx *ioctx = NULL;
- 	unsigned long ctx;
- 	long ret;
-+	int make_fd = 0;
- 
- 	ret = get_user(ctx, ctxp);
- 	if (unlikely(ret))
- 		goto out;
- 
- 	ret = -EINVAL;
-+#ifdef CONFIG_EPOLL
-+	if (ctx == 1) {
-+		make_fd = 1;
-+		ctx = 0;
-+	}
-+#endif
- 	if (unlikely(ctx || nr_events == 0)) {
- 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
- 		         ctx, nr_events);
-@@ -1272,8 +1369,12 @@ asmlinkage long sys_io_setup(unsigned nr
- 	ret = PTR_ERR(ioctx);
- 	if (!IS_ERR(ioctx)) {
- 		ret = put_user(ioctx->user_id, ctxp);
--		if (!ret)
--			return 0;
-+#ifdef CONFIG_EPOLL
-+		if (make_fd && ret >= 0)
-+			ret = make_aio_fd(ioctx);
-+#endif
-+		if (ret >= 0)
-+			return ret;
- 
- 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
- 		io_destroy(ioctx);
-diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index 19ffb04..3a6b872 100644
---- a/fs/eventpoll.c
-+++ b/fs/eventpoll.c
-@@ -236,8 +236,6 @@ struct ep_pqueue {
- 
- static void ep_poll_safewake_init(struct poll_safewake *psw);
- static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep);
- static int ep_alloc(struct eventpoll **pep);
- static void ep_free(struct eventpoll *ep);
- static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
-@@ -267,7 +265,7 @@ static int ep_events_transfer(struct eve
- static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
- 		   int maxevents, long timeout);
- static int eventpollfs_delete_dentry(struct dentry *dentry);
--static struct inode *ep_eventpoll_inode(void);
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops);
- static int eventpollfs_get_sb(struct file_system_type *fs_type,
- 			      int flags, const char *dev_name,
- 			      void *data, struct vfsmount *mnt);
-@@ -517,7 +515,7 @@ asmlinkage long sys_epoll_create(int siz
- 	 * Creates all the items needed to setup an eventpoll file. That is,
- 	 * a file structure, and inode and a free file descriptor.
- 	 */
--	error = ep_getfd(&fd, &inode, &file, ep);
-+	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
- 	if (error)
- 		goto eexit_2;
- 
-@@ -702,8 +700,8 @@ eexit_1:
- /*
-  * Creates the file descriptor to be used by the epoll interface.
-  */
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep)
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+		    struct eventpoll *ep, struct file_operations *fops)
- {
- 	struct qstr this;
- 	char name[32];
-@@ -719,7 +717,7 @@ static int ep_getfd(int *efd, struct ino
- 		goto eexit_1;
- 
- 	/* Allocates an inode from the eventpoll file system */
--	inode = ep_eventpoll_inode();
-+	inode = ep_eventpoll_inode(fops);
- 	error = PTR_ERR(inode);
- 	if (IS_ERR(inode))
- 		goto eexit_2;
-@@ -750,7 +748,7 @@ static int ep_getfd(int *efd, struct ino
- 
- 	file->f_pos = 0;
- 	file->f_flags = O_RDONLY;
--	file->f_op = &eventpoll_fops;
-+	file->f_op = fops;
- 	file->f_mode = FMODE_READ;
- 	file->f_version = 0;
- 	file->private_data = ep;
-@@ -1569,7 +1567,7 @@ static int eventpollfs_delete_dentry(str
- }
- 
- 
--static struct inode *ep_eventpoll_inode(void)
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops)
- {
- 	int error = -ENOMEM;
- 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
-@@ -1577,7 +1575,7 @@ static struct inode *ep_eventpoll_inode(
- 	if (!inode)
- 		goto eexit_1;
- 
--	inode->i_fop = &eventpoll_fops;
-+	inode->i_fop = fops;
- 
- 	/*
- 	 * Mark the inode dirty from the very beginning,
-diff --git a/include/linux/aio.h b/include/linux/aio.h
-index 00c8efa..cf8bb52 100644
---- a/include/linux/aio.h
-+++ b/include/linux/aio.h
-@@ -191,6 +191,11 @@ struct kioctx {
- 	struct aio_ring_info	ring_info;
- 
- 	struct work_struct	wq;
-+#ifdef CONFIG_EPOLL
-+	// poll integration
-+	wait_queue_head_t       poll_wait;
-+	struct file		*file;
-+#endif
- };
- 
- /* prototypes */
-diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
-index 84cfa8b..f2a22bc 100644
---- a/include/linux/eventpoll.h
-+++ b/include/linux/eventpoll.h
-@@ -90,6 +90,12 @@ static inline void eventpoll_release(str
- 	eventpoll_release_file(file);
- }
- 
-+/*
-+ * called by aio code to create fd that can poll the  aio event queueQ
-+ */
-+struct eventpoll;
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+             struct eventpoll *ep, struct file_operations *fops);
- #else
- 
- static inline void eventpoll_init_file(struct file *file) {}

Deleted: trunk/patch/aiopoll-git.diff
===================================================================
--- trunk/patch/aiopoll-git.diff	2006-11-08 09:16:23 UTC (rev 618)
+++ trunk/patch/aiopoll-git.diff	2006-11-08 09:21:28 UTC (rev 619)
@@ -1,298 +0,0 @@
-diff --git a/fs/aio.c b/fs/aio.c
-index 9476659..5edefed 100644
---- a/fs/aio.c
-+++ b/fs/aio.c
-@@ -35,6 +35,11 @@ #include <asm/kmap_types.h>
- #include <asm/uaccess.h>
- #include <asm/mmu_context.h>
- 
-+#ifdef CONFIG_EPOLL
-+#include <linux/poll.h>
-+#include <linux/eventpoll.h>
-+#endif
-+
- #if DEBUG > 1
- #define dprintk		printk
- #else
-@@ -1019,6 +1024,10 @@ put_rq:
- 	if (waitqueue_active(&ctx->wait))
- 		wake_up(&ctx->wait);
- 
-+#ifdef CONFIG_EPOLL
-+	if (ctx->file && waitqueue_active(&ctx->poll_wait))
-+		wake_up(&ctx->poll_wait);
-+#endif
- 	if (ret)
- 		put_ioctx(ctx);
- 
-@@ -1028,6 +1037,8 @@ put_rq:
- /* aio_read_evt
-  *	Pull an event off of the ioctx's event ring.  Returns the number of 
-  *	events fetched (0 or 1 ;-)
-+ *	If ent parameter is 0, just returns the number of events that would
-+ *	be fetched.
-  *	FIXME: make this use cmpxchg.
-  *	TODO: make the ringbuffer user mmap()able (requires FIXME).
-  */
-@@ -1050,13 +1061,18 @@ static int aio_read_evt(struct kioctx *i
- 
- 	head = ring->head % info->nr;
- 	if (head != ring->tail) {
--		struct io_event *evp = aio_ring_event(info, head, KM_USER1);
--		*ent = *evp;
--		head = (head + 1) % info->nr;
--		smp_mb(); /* finish reading the event before updatng the head */
--		ring->head = head;
--		ret = 1;
--		put_aio_ring_event(evp, KM_USER1);
-+		if (ent) { /* event requested */
-+			struct io_event *evp =
-+				aio_ring_event(info, head, KM_USER1);
-+			*ent = *evp;
-+			head = (head + 1) % info->nr;
-+			/* finish reading the event before updatng the head */
-+			smp_mb();
-+			ring->head = head;
-+			ret = 1;
-+			put_aio_ring_event(evp, KM_USER1);
-+		} else /* only need to know availability */
-+			ret = 1;
- 	}
- 	spin_unlock(&info->ring_lock);
- 
-@@ -1239,9 +1255,78 @@ static void io_destroy(struct kioctx *io
- 
- 	aio_cancel_all(ioctx);
- 	wait_for_all_aios(ioctx);
-+#ifdef CONFIG_EPOLL
-+	/* forget the poll file, but it's up to the user to close it */
-+	if (ioctx->file) {
-+		ioctx->file->private_data = 0;
-+		ioctx->file = 0;
-+	}
-+#endif
- 	put_ioctx(ioctx);	/* once for the lookup */
- }
- 
-+#ifdef CONFIG_EPOLL
-+
-+static int aio_queue_fd_close(struct inode *inode, struct file *file)
-+{
-+	struct kioctx *ioctx = file->private_data;
-+	if (ioctx) {
-+		file->private_data = 0;
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		ioctx->file = 0;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+	return 0;
-+}
-+
-+static unsigned int aio_queue_fd_poll(struct file *file, poll_table *wait)
-+{	unsigned int pollflags = 0;
-+	struct kioctx *ioctx = file->private_data;
-+
-+	if (ioctx) {
-+
-+		spin_lock_irq(&ioctx->ctx_lock);
-+		/* Insert inside our poll wait queue */
-+		poll_wait(file, &ioctx->poll_wait, wait);
-+
-+		/* Check our condition */
-+		if (aio_read_evt(ioctx, 0))
-+			pollflags = POLLIN | POLLRDNORM;
-+		spin_unlock_irq(&ioctx->ctx_lock);
-+	}
-+
-+	return pollflags;
-+}
-+
-+static struct file_operations aioq_fops = {
-+	.release	= aio_queue_fd_close,
-+	.poll		= aio_queue_fd_poll
-+};
-+
-+/* make_aio_fd:
-+ *  Create a file descriptor that can be used to poll the event queue.
-+ *  Based and piggybacked on the excellent epoll code.
-+ */
-+
-+static int make_aio_fd(struct kioctx *ioctx)
-+{
-+	int error, fd;
-+	struct inode *inode;
-+	struct file *file;
-+
-+	error = ep_getfd(&fd, &inode, &file, NULL, &aioq_fops);
-+	if (error)
-+		return error;
-+
-+	/* associate the file with the IO context */
-+	file->private_data = ioctx;
-+	ioctx->file = file;
-+	init_waitqueue_head(&ioctx->poll_wait);
-+	return fd;
-+}
-+#endif
-+
-+
- /* sys_io_setup:
-  *	Create an aio_context capable of receiving at least nr_events.
-  *	ctxp must not point to an aio_context that already exists, and
-@@ -1254,18 +1339,30 @@ static void io_destroy(struct kioctx *io
-  *	resources are available.  May fail with -EFAULT if an invalid
-  *	pointer is passed for ctxp.  Will fail with -ENOSYS if not
-  *	implemented.
-+ *
-+ *	To request a selectable fd, the user context has to be initialized
-+ *	to 1, instead of 0, and the return value is the fd.
-+ *	This keeps the system call compatible, since a non-zero value
-+ *	was not allowed so far.
-  */
- asmlinkage long sys_io_setup(unsigned nr_events, aio_context_t __user *ctxp)
- {
- 	struct kioctx *ioctx = NULL;
- 	unsigned long ctx;
- 	long ret;
-+	int make_fd = 0;
- 
- 	ret = get_user(ctx, ctxp);
- 	if (unlikely(ret))
- 		goto out;
- 
- 	ret = -EINVAL;
-+#ifdef CONFIG_EPOLL
-+	if (ctx == 1) {
-+		make_fd = 1;
-+		ctx = 0;
-+	}
-+#endif
- 	if (unlikely(ctx || nr_events == 0)) {
- 		pr_debug("EINVAL: io_setup: ctx %lu nr_events %u\n",
- 		         ctx, nr_events);
-@@ -1276,8 +1373,12 @@ asmlinkage long sys_io_setup(unsigned nr
- 	ret = PTR_ERR(ioctx);
- 	if (!IS_ERR(ioctx)) {
- 		ret = put_user(ioctx->user_id, ctxp);
--		if (!ret)
--			return 0;
-+#ifdef CONFIG_EPOLL
-+		if (make_fd && ret >= 0)
-+			ret = make_aio_fd(ioctx);
-+#endif
-+		if (ret >= 0)
-+			return ret;
- 
- 		get_ioctx(ioctx); /* io_destroy() expects us to hold a ref */
- 		io_destroy(ioctx);
-diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index ae228ec..fc3ff8d 100644
---- a/fs/eventpoll.c
-+++ b/fs/eventpoll.c
-@@ -238,8 +238,6 @@ struct ep_pqueue {
- 
- static void ep_poll_safewake_init(struct poll_safewake *psw);
- static void ep_poll_safewake(struct poll_safewake *psw, wait_queue_head_t *wq);
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep);
- static int ep_alloc(struct eventpoll **pep);
- static void ep_free(struct eventpoll *ep);
- static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd);
-@@ -269,7 +267,7 @@ static int ep_events_transfer(struct eve
- static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,
- 		   int maxevents, long timeout);
- static int eventpollfs_delete_dentry(struct dentry *dentry);
--static struct inode *ep_eventpoll_inode(void);
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops);
- static int eventpollfs_get_sb(struct file_system_type *fs_type,
- 			      int flags, const char *dev_name,
- 			      void *data, struct vfsmount *mnt);
-@@ -519,7 +517,7 @@ asmlinkage long sys_epoll_create(int siz
- 	 * Creates all the items needed to setup an eventpoll file. That is,
- 	 * a file structure, and inode and a free file descriptor.
- 	 */
--	error = ep_getfd(&fd, &inode, &file, ep);
-+	error = ep_getfd(&fd, &inode, &file, ep, &eventpoll_fops);
- 	if (error)
- 		goto eexit_2;
- 
-@@ -752,8 +750,8 @@ #endif /* #ifdef TIF_RESTORE_SIGMASK */
- /*
-  * Creates the file descriptor to be used by the epoll interface.
-  */
--static int ep_getfd(int *efd, struct inode **einode, struct file **efile,
--		    struct eventpoll *ep)
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+		    struct eventpoll *ep, struct file_operations *fops)
- {
- 	struct qstr this;
- 	char name[32];
-@@ -769,7 +767,7 @@ static int ep_getfd(int *efd, struct ino
- 		goto eexit_1;
- 
- 	/* Allocates an inode from the eventpoll file system */
--	inode = ep_eventpoll_inode();
-+	inode = ep_eventpoll_inode(fops);
- 	if (IS_ERR(inode)) {
- 		error = PTR_ERR(inode);
- 		goto eexit_2;
-@@ -801,7 +799,7 @@ static int ep_getfd(int *efd, struct ino
- 
- 	file->f_pos = 0;
- 	file->f_flags = O_RDONLY;
--	file->f_op = &eventpoll_fops;
-+	file->f_op = fops;
- 	file->f_mode = FMODE_READ;
- 	file->f_version = 0;
- 	file->private_data = ep;
-@@ -1620,7 +1618,7 @@ static int eventpollfs_delete_dentry(str
- }
- 
- 
--static struct inode *ep_eventpoll_inode(void)
-+static struct inode *ep_eventpoll_inode(struct file_operations *fops)
- {
- 	int error = -ENOMEM;
- 	struct inode *inode = new_inode(eventpoll_mnt->mnt_sb);
-@@ -1628,7 +1626,7 @@ static struct inode *ep_eventpoll_inode(
- 	if (!inode)
- 		goto eexit_1;
- 
--	inode->i_fop = &eventpoll_fops;
-+	inode->i_fop = fops;
- 
- 	/*
- 	 * Mark the inode dirty from the very beginning,
-diff --git a/include/linux/aio.h b/include/linux/aio.h
-index 0d71c00..71e8ac8 100644
---- a/include/linux/aio.h
-+++ b/include/linux/aio.h
-@@ -195,6 +195,11 @@ struct kioctx {
- 	struct aio_ring_info	ring_info;
- 
- 	struct work_struct	wq;
-+#ifdef CONFIG_EPOLL
-+	// poll integration
-+	wait_queue_head_t       poll_wait;
-+	struct file		*file;
-+#endif
- };
- 
- /* prototypes */
-diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
-index 84cfa8b..f2a22bc 100644
---- a/include/linux/eventpoll.h
-+++ b/include/linux/eventpoll.h
-@@ -90,6 +90,12 @@ static inline void eventpoll_release(str
- 	eventpoll_release_file(file);
- }
- 
-+/*
-+ * called by aio code to create fd that can poll the  aio event queueQ
-+ */
-+struct eventpoll;
-+int ep_getfd(int *efd, struct inode **einode, struct file **efile,
-+             struct eventpoll *ep, struct file_operations *fops);
- #else
- 
- static inline void eventpoll_init_file(struct file *file) {}



From tomo at mail.berlios.de  Wed Nov  8 11:26:41 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 11:26:41 +0100
Subject: [Stgt-svn] r620 - in trunk: . doc
Message-ID: <200611081026.kA8AQfOe013048@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 11:26:40 +0100 (Wed, 08 Nov 2006)
New Revision: 620

Modified:
   trunk/README
   trunk/doc/README.iscsi
Log:
Update main and iSCSI documents


Modified: trunk/README
===================================================================
--- trunk/README	2006-11-08 09:21:28 UTC (rev 619)
+++ trunk/README	2006-11-08 10:26:40 UTC (rev 620)
@@ -1,83 +1,48 @@
 Introduction
 -------------
-Note that linux target framework (tgt) is under active
-development. Don't play with important data.
+Linux target framework (tgt) aims to simplify various SCSI target
+driver (iSCSI, Fibre Channel, SRP, etc) creation and maintenance.
 
-Currently, tgt supports only one low level driver, IBM VIO server
-(ibmvstgt).
+Tgt consists of kernel modules, user-space daemon, and user-space
+tools. Some target drivers uses all of them and some use only
+user-space daemon and tools (i.e. they completely runs in user space).
 
+Currently, tgt supports three target drivers:
 
-Starting
--------------
-The software consists of kernel modules and user-space tools (daemon,
-management tool, dynamic libraries).
+- IBM VIO server (ibmvstgt)
+- iSCSI
+- Xen vscsifront/back
 
-First, get kernel sources from James's scsi-rc-fixes-2.6 git tree:
+Note that tgt is under active development. Don't play with important
+data.
 
-master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-target-2.6.git
 
-Second, if you use ibmvstgt, apply scsi-target-2.6-tree.diff in the
-patchset directory. If not, you can skip this.
-
-Third, rebuild the kernel, and reboot with the new kernel.
-
-The compilation of the kernel modules require the path to above kernel
-source:
-
-host:~/use-scsi-ml$ make KERNELSRC=<kernel-src>
-
-Make sure that everything is built successfully. Now you can load the
-kernel modules by typing the followings.
-
-host:~/use-scsi-ml$ su
-host:~/use-scsi-ml# ./initd start
-
-See /var/log/kern.log (your Linux distributions may use the different
-log file name) to make sure that the kernel modules are loaded
-properly. You should see messages like the followings:
-
-Feb 27 19:37:52 lilac kernel: IBM eServer i/pSeries Virtual SCSI Target Driver
-Feb 27 19:37:52 lilac kernel: vio_register_driver: driver ibmvscsi registering
-Feb 27 19:37:52 lilac kernel: scsi1 : ibmvstgt
-
-You need the scsi host number (it is 1 in this example) in the next
-stage (configuration).
-
-
-Configuration
+Preparation
 -------------
+First, get kernel sources from linux-2.6-target git tree:
 
-Everyting is configured via the tgtadm management tool. Currenlty, tgt
-does not support persistent configurations. You can use a makeshift
-script, 'ibmv' to do the necessary job.
+master.kernel.org:/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
 
-Note that the ibmv script exports /dev/sdb1 to initiators as LUN 0 by
-defaults. You MUST change the device path if your /dev/sdb1 stores
-important data or your box does not have /dev/sdb1.
+Second, apply epoll-git.diff in the patchset directory.
 
-host:~/use-scsi-ml# ./ibmv 1
+Third, rebuild the kernel and reboot with the new kernel. Note if you
+plan to use the IBM VIO target driver, please enable SCSI_TGT,
+SCSI_SRP, and SCSI_IBMVSCSIS kernel options.
 
-You need to specify the scsi host number as the first argument.
+Now you are ready to build target drivers. If you like to use the
+iSCSI target driver:
 
-Please see /var/log/daemon.log (your Linux distributions may use the
-different log file name again) to make sure that everything is
-fine. You should see something like the followings:
+host:~/tgt$ make KERNELSRC=<kernel-src> ISCSI=1
 
-Feb 27 22:36:40 lilac tgtd: dl_init(71) istgt library is not loaded.
-Feb 27 22:36:40 lilac tgtd: dl_init(71) ibmvstgt library is not loaded.
-Feb 27 22:37:08 lilac tgtd: tgt_target_create(572) Succeed to create a new target 1
-Feb 27 22:37:08 lilac tgtd: tgt_target_bind(517) Succeed to bind the target 1 to the scsi host 1
-Feb 27 22:37:08 lilac tgtd: tgt_device_create(238) Succeed to add a logical unit 0 to the target 1
+Or if you like to use the IBM VIO target driver:
 
+host:~/tgt$ make KERNELSRC=<kernel-src> IBMVIO=1
 
-Now you are ready. Boot up VIO clients.
+Make sure that everything is built successfully.
 
-Note that the tgt kernel modules enable the debug option by
-defaults. We are not ready for improving performance.
+Now you can run tgt. Target drivers have their own ways for
+configuration. So find an appropriate documentation in the doc
+directory.
 
 
-Stopping
--------------
-Simply execute:
-
-host:~/use-scsi-ml# ./initd stop
+FUJITA Tomonori and Mike Christie

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-08 09:21:28 UTC (rev 619)
+++ trunk/doc/README.iscsi	2006-11-08 10:26:40 UTC (rev 620)
@@ -1,14 +1,3 @@
-Installation
--------------
-This driver runs in user-space, however, you still need tgt header
-files and kernel modifications. So get the latest code from the
-linux-2.6-target git tree. Then, apply aiopoll-2.6.18-rc4.diff in the
-patch directory, rebuild the kernel, and reboot with the new kernel.
-After the reboot, compile the source code:
-
-make KSRC=<kernel-src> ISCSI=1
-
-
 Starting
 -------------
 Try the following commands:
@@ -19,8 +8,7 @@
 
 Configuration
 -------------
-Now there is no handy way for the configuration. Everyting is
-configured via the tgtadm management tool after you run tgt daemon.
+Everyting is configured via the tgtadm management tool after you run tgt daemon.
 
 The following example creates a target with id 1 (the iqn is
 iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz) and adds a
@@ -30,7 +18,9 @@
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
 
+iSCSI parameters are not configurable yet.
 
+
 Status
 -------------
 It should work under normal circumstances (good initiator, no network



From tomo at mail.berlios.de  Wed Nov  8 11:39:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 11:39:43 +0100
Subject: [Stgt-svn] r621 - trunk/doc
Message-ID: <200611081039.kA8Adh6Y014448@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 11:39:43 +0100 (Wed, 08 Nov 2006)
New Revision: 621

Modified:
   trunk/doc/README.iscsi
Log:
Minor fix to iscsi doc.


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-08 10:26:40 UTC (rev 620)
+++ trunk/doc/README.iscsi	2006-11-08 10:39:43 UTC (rev 621)
@@ -8,7 +8,7 @@
 
 Configuration
 -------------
-Everyting is configured via the tgtadm management tool after you run tgt daemon.
+Everyting is configured via the tgtadm management tool.
 
 The following example creates a target with id 1 (the iqn is
 iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz) and adds a



From tomo at mail.berlios.de  Wed Nov  8 11:40:07 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 11:40:07 +0100
Subject: [Stgt-svn] r622 - trunk/doc
Message-ID: <200611081040.kA8Ae7LP014543@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 11:40:06 +0100 (Wed, 08 Nov 2006)
New Revision: 622

Modified:
   trunk/doc/README.ibmvstgt
Log:
Update IBMVIO doc.


Modified: trunk/doc/README.ibmvstgt
===================================================================
--- trunk/doc/README.ibmvstgt	2006-11-08 10:39:43 UTC (rev 621)
+++ trunk/doc/README.ibmvstgt	2006-11-08 10:40:06 UTC (rev 622)
@@ -1,3 +1,56 @@
+Starting
+-------------
+Try the following commands:
+
+host:~/tgt$ su
+host:~/tgt# modprobe scsi_tgt
+host:~/tgt# modprobe libsrp
+host:~/tgt# modprobe ibmvstgt
+host:~/tgt# ./usr/tgtd --lld ibmvio
+
+See /var/log/kern.log (your Linux distributions may use the different
+log file name) to make sure that the kernel modules are loaded
+properly. You should see messages like the followings:
+
+Feb 27 19:37:52 lilac kernel: IBM eServer i/pSeries Virtual SCSI Target Driver
+Feb 27 19:37:52 lilac kernel: vio_register_driver: driver ibmvscsi registering
+Feb 27 19:37:52 lilac kernel: scsi1 : ibmvstgt
+
+You need the scsi host number (it is 1 in this example) in the next
+stage (configuration).
+
+
+Configuration
+-------------
+Everyting is configured via the tgtadm management tool.
+
+The following example creates a target with id 1, adds a logical unit
+(backed by /dev/sdb1) with lun 0, and then bind the target with #1 scsi host.
+
+host:~/tgt# ./usr/tgtadm --lld ibmvio --op new --tid 1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --op bind --tid 1 --host 1
+
+Please see /var/log/daemon.log (your Linux distributions may use the
+different log file name again) to make sure that everything is
+fine. You should see something like the followings:
+
+Feb 27 22:36:40 lilac tgtd: dl_init(71) istgt library is not loaded.
+Feb 27 22:36:40 lilac tgtd: dl_init(71) ibmvstgt library is not loaded.
+Feb 27 22:37:08 lilac tgtd: tgt_target_create(572) Succeed to create a new target 1
+Feb 27 22:37:08 lilac tgtd: tgt_target_bind(517) Succeed to bind the target 1 to the scsi host 1
+Feb 27 22:37:08 lilac tgtd: tgt_device_create(238) Succeed to add a logical unit 0 to the target 1
+Now you are ready. Boot up VIO clients.
+
+
+History
+-------------
+The following description was taken from the original ibmvscsis
+driver:
+
+http://lkml.org/lkml/2005/10/17/99
+
+
 This driver is a SCSI target that interoperates according to the PAPR
 (POWER Architecture Platform Requirements) document.  Currently it is
 specific to POWER logical partitioning, however in the future it would



From tomo at mail.berlios.de  Wed Nov  8 11:45:15 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 11:45:15 +0100
Subject: [Stgt-svn] r623 - trunk
Message-ID: <200611081045.kA8AjFqf015758@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 11:45:14 +0100 (Wed, 08 Nov 2006)
New Revision: 623

Modified:
   trunk/ibmv
Log:
Update the makeshift ibmvio script


Modified: trunk/ibmv
===================================================================
--- trunk/ibmv	2006-11-08 10:40:06 UTC (rev 622)
+++ trunk/ibmv	2006-11-08 10:45:14 UTC (rev 623)
@@ -5,6 +5,6 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1
-${PWD}/usr/tgtadm --driver ibmvstgt --op bind --tid 1 --bus vio,30000003
-${PWD}/usr/tgtadm --driver ibmvstgt --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1
+${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+${PWD}/usr/tgtadm --lld ibmvio --op bind --tid 1 --host 1



From tomo at mail.berlios.de  Wed Nov  8 11:46:07 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 11:46:07 +0100
Subject: [Stgt-svn] r624 - trunk
Message-ID: <200611081046.kA8Ak7IX015803@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 11:46:06 +0100 (Wed, 08 Nov 2006)
New Revision: 624

Added:
   trunk/ibmvio
Removed:
   trunk/ibmv
Log:
Just rename.

Deleted: trunk/ibmv
===================================================================
--- trunk/ibmv	2006-11-08 10:45:14 UTC (rev 623)
+++ trunk/ibmv	2006-11-08 10:46:06 UTC (rev 624)
@@ -1,10 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start ibmvstgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-
-${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1
-${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1 --lun 0 --params Path=/dev/sdb1
-${PWD}/usr/tgtadm --lld ibmvio --op bind --tid 1 --host 1

Copied: trunk/ibmvio (from rev 623, trunk/ibmv)



From tomo at mail.berlios.de  Wed Nov  8 13:12:13 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 8 Nov 2006 13:12:13 +0100
Subject: [Stgt-svn] r625 - trunk/usr
Message-ID: <200611081212.kA8CCDU7014320@sheep.berlios.de>

Author: tomo
Date: 2006-11-08 13:12:12 +0100 (Wed, 08 Nov 2006)
New Revision: 625

Modified:
   trunk/usr/Makefile
Log:
Add libaio to ibmvio driver. Now it works again. In theory, ibmvio
driver does not need to use AIO since it uses mmap I/O. However, the
CMD_EPOLL_WAIT interface needs AIO. We want to maintain single source
code for all target drivers so just use aio at all times.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-08 10:46:06 UTC (rev 624)
+++ trunk/usr/Makefile	2006-11-08 12:12:12 UTC (rev 625)
@@ -1,6 +1,7 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE -I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
 TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o sched.o
+LIBS += -laio
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO
@@ -22,7 +23,6 @@
 
 ifneq ($(BD_AIO),)
 TGTD_OBJS += bd_aio.o
-LIBS += -laio
 endif
 
 all: $(PROGRAMS)



From tomo at mail.berlios.de  Thu Nov  9 06:09:33 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 9 Nov 2006 06:09:33 +0100
Subject: [Stgt-svn] r626 - trunk/usr
Message-ID: <200611090509.kA959Xnj022487@sheep.berlios.de>

Author: tomo
Date: 2006-11-09 06:09:33 +0100 (Thu, 09 Nov 2006)
New Revision: 626

Modified:
   trunk/usr/bd_mmap.c
Log:
Minor fix in bd_map.c


Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-11-08 12:12:12 UTC (rev 625)
+++ trunk/usr/bd_mmap.c	2006-11-09 05:09:33 UTC (rev 626)
@@ -76,7 +76,7 @@
 		}
 	}
 
-	printf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
+	dprintf("%lx %u %" PRIu64 "\n", *uaddr, datalen, offset);
 
 	return err;
 }



From tomo at mail.berlios.de  Fri Nov 10 12:02:13 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 10 Nov 2006 12:02:13 +0100
Subject: [Stgt-svn] r627 - trunk/usr/iscsi
Message-ID: <200611101102.kAAB2DEF030912@sheep.berlios.de>

Author: tomo
Date: 2006-11-10 12:02:12 +0100 (Fri, 10 Nov 2006)
New Revision: 627

Modified:
   trunk/usr/iscsi/iscsid.h
Log:
Remove unused define.

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-09 05:09:33 UTC (rev 626)
+++ trunk/usr/iscsi/iscsid.h	2006-11-10 11:02:12 UTC (rev 627)
@@ -26,7 +26,6 @@
 #define be32_to_cpu(x)	__be32_to_cpu(x)
 
 #define ISCSI_NAME_LEN 256
-#define ISTGT_NAMESPACE "ISTGT_ABSTRACT_NAMESPACE"
 
 #define DIGEST_ALL		(DIGEST_NONE | DIGEST_CRC32C)
 #define DIGEST_NONE		(1 << 0)



From tomo at mail.berlios.de  Fri Nov 10 15:00:29 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 10 Nov 2006 15:00:29 +0100
Subject: [Stgt-svn] r628 - trunk/usr/iscsi
Message-ID: <200611101400.kAAE0Tjs020471@sheep.berlios.de>

Author: tomo
Date: 2006-11-10 15:00:28 +0100 (Fri, 10 Nov 2006)
New Revision: 628

Modified:
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/target.c
Log:
Add iscsi_param to target.

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-10 11:02:12 UTC (rev 627)
+++ trunk/usr/iscsi/iscsid.c	2006-11-10 14:00:28 UTC (rev 628)
@@ -321,6 +321,7 @@
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	char *name, *alias, *session_type, *target_name;
+	struct target *target;
 
 	conn->cid = be16_to_cpu(req->cid);
 	memcpy(conn->isid, req->isid, sizeof(req->isid));
@@ -369,12 +370,15 @@
 
 /* 		if (target_find_by_name(target_name, &conn->tid) < 0 || */
 /* 		    cops->initiator_access(conn->tid, conn->fd) < 0) { */
-		if (target_find_by_name(target_name, &conn->tid) < 0) {
+
+		target = target_find_by_name(target_name);
+		if (!target) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
 			return;
 		}
+		conn->tid = target->tid;
 
 /* 		if (conn->target->max_sessions && */
 /* 		    (++conn->target->session_cnt > conn->target->max_sessions)) { */
@@ -385,7 +389,8 @@
 /* 			return; */
 /* 		} */
 
-/* 		ki->param_get(conn->tid, 0, conn->session_param); */
+		memcpy(conn->session_param, target->session_param,
+		       sizeof(conn->session_param));
 		conn->exp_cmd_sn = be32_to_cpu(req->cmdsn);
 		dprintf("exp_cmd_sn: %d,%d\n", conn->exp_cmd_sn, req->cmdsn);
 		conn->max_cmd_sn = conn->exp_cmd_sn;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-10 11:02:12 UTC (rev 627)
+++ trunk/usr/iscsi/iscsid.h	2006-11-10 14:00:28 UTC (rev 628)
@@ -206,6 +206,8 @@
 
 	struct list_head sessions_list;
 
+	struct param session_param[ISCSI_PARAM_MAX];
+
 	int tid;
 	char name[ISCSI_NAME_LEN];
 	char *alias;
@@ -253,7 +255,7 @@
 extern void session_put(struct session *session);
 
 /* target.c */
-extern int target_find_by_name(const char *name, int *tid);
+struct target * target_find_by_name(const char *name);
 struct target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-10 11:02:12 UTC (rev 627)
+++ trunk/usr/iscsi/target.c	2006-11-10 14:00:28 UTC (rev 628)
@@ -18,6 +18,28 @@
 #include "iscsid.h"
 #include "tgtadm.h"
 
+static struct param default_tgt_session_param[] = {
+	{0, 8192},
+	{0, 8192},
+	{0, DIGEST_NONE},
+	{0, DIGEST_NONE},
+	{0, 1},
+	{0, 1},
+	{0, 1},
+	{0, 65536},
+	{0, 262144},
+	{0, 1},
+	{0, 1},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 2},
+	{0, 20},
+	{0, 2048},
+	{0, 2048},
+	{0, 1},
+};
+
 static LIST_HEAD(targets_list);
 
 void target_list_build(struct connection *conn, char *addr, char *name)
@@ -35,18 +57,16 @@
 	}
 }
 
-int target_find_by_name(const char *name, int *tid)
+struct target *target_find_by_name(const char *name)
 {
 	struct target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
-		if (!strcmp(target->name, name)) {
-			*tid = target->tid;
-			return 0;
-		}
+		if (!strcmp(target->name, name))
+			return target;
 	}
 
-	return -ENOENT;
+	return NULL;
 }
 
 struct target* target_find_by_id(int tid)
@@ -98,6 +118,9 @@
 	memset(target, 0, sizeof(*target));
 	memcpy(target->name, name, sizeof(target->name) - 1);
 
+	memcpy(target->session_param, default_tgt_session_param,
+	       sizeof(target->session_param));
+
 	INIT_LIST_HEAD(&target->tlist);
 	INIT_LIST_HEAD(&target->sessions_list);
 	target->tid = tid;



From tomo at mail.berlios.de  Fri Nov 10 16:16:06 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 10 Nov 2006 16:16:06 +0100
Subject: [Stgt-svn] r629 - in trunk/usr: . iscsi
Message-ID: <200611101516.kAAFG67G028899@sheep.berlios.de>

Author: tomo
Date: 2006-11-10 16:16:05 +0100 (Fri, 10 Nov 2006)
New Revision: 629

Modified:
   trunk/usr/driver.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Now iSCSI param can be configurable. You can do something like this:

lily:/home/fujita# ./tgt/usr/tgtadm --op update --lld iscsi --tid 1 --name MaxRecvDataSegmentLength --value 2048



Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/driver.h	2006-11-10 15:16:05 UTC (rev 629)
@@ -8,6 +8,7 @@
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);
 	int (*target_show) (int, char *, int);
+	int (*target_update) (int, char *);
 
 	uint64_t (*scsi_get_lun)(uint8_t *);
 	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/iscsi/iscsi.h	2006-11-10 15:16:05 UTC (rev 629)
@@ -2,6 +2,7 @@
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
 extern int iscsi_target_show(int, char *, int);
+extern int iscsi_target_update(int, char *);
 extern int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw,
 			       uint64_t addr, uint64_t tag);
 extern int iscsi_tm_done(int host_no, uint64_t mid, int result);
@@ -12,6 +13,7 @@
 	.target_create		= iscsi_target_create,
 	.target_destroy		= iscsi_target_destroy,
 	.target_show		= iscsi_target_show,
+	.target_update		= iscsi_target_update,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
 	.bdt			= &aio_bdt,

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/iscsi/target.c	2006-11-10 15:16:05 UTC (rev 629)
@@ -129,6 +129,39 @@
 	return 0;
 }
 
+int iscsi_target_update(int tid, char *name)
+{
+	int idx, err;
+	unsigned int val;
+	char *str;
+	struct target* target;
+
+	target = target_find_by_id(tid);
+	if (!target)
+		return -ENOENT;
+
+	str = name + strlen(name) + 1;
+
+	idx = param_index_by_name(name, session_keys);
+	if (idx < 0)
+		return idx;
+
+	err = param_str_to_val(session_keys, idx, str, &val);
+	if (err)
+		return err;
+
+	err = param_check_val(session_keys, idx, &val);
+	if (err < 0)
+		return err;
+
+	target->session_param[idx].val = val;
+
+	dprintf("%s %s %u\n", name, str, val);
+
+	return 0;
+}
+
+
 int iscsi_target_show(int tid, char *buf, int rest)
 {
 	struct target* target;

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/mgmt.c	2006-11-10 15:16:05 UTC (rev 629)
@@ -85,6 +85,11 @@
 	case OP_BIND:
 		err = tgt_target_bind(req->tid, req->host_no, lld_no);
 		break;
+	case OP_UPDATE:
+		err = -EINVAL;
+		if (tgt_drivers[lld_no]->target_update)
+			err = tgt_drivers[lld_no]->target_update(req->tid, params);
+		break;
 	default:
 		break;
 	}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/tgtadm.c	2006-11-10 15:16:05 UTC (rev 629)
@@ -71,6 +71,8 @@
 	{"params", required_argument, NULL, 'p'},
 	{"user", no_argument, NULL, 'u'},
 	{"hostno", required_argument, NULL, 'i'},
+	{"name", required_argument, NULL, 'm'},
+	{"value", required_argument, NULL, 'a'},
 	{"debug", no_argument, NULL, 'd'},
 	{"version", no_argument, NULL, 'v'},
 	{"help", no_argument, NULL, 'h'},
@@ -156,9 +158,9 @@
 {
 	struct tgtadm_res *res;
 	char buf[BUFSIZE];
-	int err, len = (void *) res->data - (void *) res;
+	int err, len;
 
-	err = read(fd, buf, len);
+	err = read(fd, buf, sizeof(*res));
 	if (err < 0) {
 		eprintf("Cannot read from tgtd, %m\n");
 		return -1;
@@ -172,7 +174,7 @@
 
 	dprintf("got the response %d %d\n", res->err, res->len);
 
-	len = res->len - len;
+	len = res->len - sizeof(*res);
 	if (!len)
 		return 0;
 
@@ -245,6 +247,8 @@
 		op = OP_BIND;
 	else if (!strcmp("show", str))
 		op = OP_SHOW;
+	else if (!strcmp("update", str))
+		op = OP_UPDATE;
 	else
 		op = -1;
 
@@ -258,10 +262,13 @@
 	int tid = -1;
 	uint32_t cid = 0, set = 0, hostno = 0;
 	uint64_t sid = 0, lun = 0;
-	char *params = NULL, *lldname = NULL;
+	char *params, *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
+	char *name, *value;
 
+	params = lldname = name = value = NULL;
+
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvdh",
 				 long_options, &longindex)) >= 0) {
@@ -299,6 +306,12 @@
 		case 'u':
 			set |= (1 << MODE_USER);
 			break;
+		case 'a':
+			value = optarg;
+			break;
+		case 'm':
+			name = optarg;
+			break;
 		case 'd':
 			debug = 1;
 			break;
@@ -341,8 +354,18 @@
 		len = min(strlen(params), sizeof(buf) - len);
 		strncpy((char *) req->data, params, len);
 	}
-	req->len = ((char *) req->data - (char *) req) + len;
 
+	if (name && value) {
+		int rest = sizeof(buf) - sizeof(*req);
+		char *p = (char *) req->data;
+
+		len = snprintf(p, rest, "%s", name);
+		len += 1;
+		len += snprintf(p + len, rest - len, "%s", value);
+	}
+
+	req->len = sizeof(*req) + len;
+
 	err = ipc_mgmt_req(req);
 out:
 	return err;

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-11-10 14:00:28 UTC (rev 628)
+++ trunk/usr/tgtadm.h	2006-11-10 15:16:05 UTC (rev 629)
@@ -9,6 +9,7 @@
 	OP_DELETE,
 	OP_SHOW,
 	OP_BIND,
+	OP_UPDATE,
 };
 
 enum tgtadm_mode {



From tomo at mail.berlios.de  Fri Nov 10 17:41:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 10 Nov 2006 17:41:59 +0100
Subject: [Stgt-svn] r630 - trunk/usr/iscsi
Message-ID: <200611101641.kAAGfxqQ003439@sheep.berlios.de>

Author: tomo
Date: 2006-11-10 17:41:58 +0100 (Fri, 10 Nov 2006)
New Revision: 630

Modified:
   trunk/usr/iscsi/target.c
Log:
Minor cleanup.

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-10 15:16:05 UTC (rev 629)
+++ trunk/usr/iscsi/target.c	2006-11-10 16:41:58 UTC (rev 630)
@@ -18,28 +18,6 @@
 #include "iscsid.h"
 #include "tgtadm.h"
 
-static struct param default_tgt_session_param[] = {
-	{0, 8192},
-	{0, 8192},
-	{0, DIGEST_NONE},
-	{0, DIGEST_NONE},
-	{0, 1},
-	{0, 1},
-	{0, 1},
-	{0, 65536},
-	{0, 262144},
-	{0, 1},
-	{0, 1},
-	{0, 0},
-	{0, 0},
-	{0, 0},
-	{0, 2},
-	{0, 20},
-	{0, 2048},
-	{0, 2048},
-	{0, 1},
-};
-
 static LIST_HEAD(targets_list);
 
 void target_list_build(struct connection *conn, char *addr, char *name)
@@ -106,13 +84,35 @@
 int iscsi_target_create(int tid, char *name)
 {
 	struct target *target;
+	struct param default_tgt_session_param[] = {
+		{0, 8192},
+		{0, 8192},
+		{0, DIGEST_NONE},
+		{0, DIGEST_NONE},
+		{0, 1},
+		{0, 1},
+		{0, 1},
+		{0, 65536},
+		{0, 262144},
+		{0, 1},
+		{0, 1},
+		{0, 0},
+		{0, 0},
+		{0, 0},
+		{0, 2},
+		{0, 20},
+		{0, 2048},
+		{0, 2048},
+		{0, 1},
+	};
 
 	if (!name)
 		return -EINVAL;
 
 	dprintf("%d %s\n", tid, name);
 
-	if (!(target = malloc(sizeof(*target))))
+	target = malloc(sizeof(*target));
+	if (!target)
 		return -ENOMEM;
 
 	memset(target, 0, sizeof(*target));



From tomo at mail.berlios.de  Fri Nov 10 19:32:52 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 10 Nov 2006 19:32:52 +0100
Subject: [Stgt-svn] r631 - in trunk/usr: . iscsi
Message-ID: <200611101832.kAAIWqsS020083@sheep.berlios.de>

Author: tomo
Date: 2006-11-10 19:32:51 +0100 (Fri, 10 Nov 2006)
New Revision: 631

Modified:
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.h
Log:
Chage show interface. When you specify target id, you get the details (lld specific).

lily:/home/fujita# ./tgt/usr/tgtadm --op show --lld iscsi
tid 1: lld name iscsi
        lun 0: path /dev/hdc1

lily:/home/fujita# ./tgt/usr/tgtadm --op show --lld iscsi --tid 1
tid: 1 iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
MaxRecvDataSegmentLength=8192
MaxXmitDataSegmentLength=8192
HeaderDigest=None
DataDigest=None
InitialR2T=Yes
MaxOutstandingR2T=1
ImmediateData=Yes
FirstBurstLength=65536
MaxBurstLength=262144
DataPDUInOrder=Yes
DataSequenceInOrder=Yes
ErrorRecoveryLevel=0
IFMarker=No
OFMarker=No
DefaultTime2Wait=2
DefaultTime2Retain=20
OFMarkInt=Reject
IFMarkInt=Reject
MaxConnections=1



Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-10 16:41:58 UTC (rev 630)
+++ trunk/usr/iscsi/target.c	2006-11-10 18:32:51 UTC (rev 631)
@@ -161,13 +161,39 @@
 	return 0;
 }
 
+static int show_iscsi_param(char *buf, struct param *param, int rest)
+{
+	int i, len, total;
+	char value[64];
+	struct iscsi_key *keys = session_keys;
 
+	for (i = total = 0; session_keys[i].name; i++) {
+		param_val_to_str(keys, i, param[i].val, value);
+		len = snprintf(buf + total, rest, "%s=%s\n", keys[i].name, value);
+		total += len;
+		rest -= len;
+		if (!rest)
+			break;
+	}
+
+	return total;
+}
+
 int iscsi_target_show(int tid, char *buf, int rest)
 {
 	struct target* target;
+	int len;
 
-	if (!(target = target_find_by_id(tid)))
+	target = target_find_by_id(tid);
+	if (!target)
 		return 0;
 
-	return snprintf(buf, rest, ": %s\n", target->name);
+	len = snprintf(buf, rest, "tid: %d %s\n", target->tid, target->name);
+	rest -= len;
+	if (!rest)
+		goto out;
+
+	len += show_iscsi_param(buf + len, target->session_param, rest);
+out:
+	return len;
 }

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-10 16:41:58 UTC (rev 630)
+++ trunk/usr/mgmt.c	2006-11-10 18:32:51 UTC (rev 631)
@@ -139,9 +139,18 @@
 		req->tid, req->sid, req->lun, params, getpid());
 
 	if (req->op == OP_SHOW) {
-		err = tgt_target_show((char *)res->data, len - sizeof(*res));
-		res->err = 0;
-		res->len = len - err;
+		if (req->tid > 0)
+			err = tgt_target_show(req->tid, (char *)res->data,
+					      len - sizeof(*res));
+		else
+			err = tgt_target_show_all((char *)res->data,
+						  len - sizeof(*res));
+		if (err < 0)
+			res->err = err;
+		else {
+			res->err = 0;
+			res->len = err + sizeof(*res);
+		}
 		dprintf("%d %d\n", len, err);
 		return 0;
 	}

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-10 16:41:58 UTC (rev 630)
+++ trunk/usr/target.c	2006-11-10 18:32:51 UTC (rev 631)
@@ -620,35 +620,42 @@
 	return 0;
 }
 
-int tgt_target_show(char *buf, int rest)
+int tgt_target_show(int tid, char *buf, int rest)
 {
-	int i, len;
+	int len = 0;
 	struct target *target;
+
+	target  = target_lookup(tid);
+	if (!target)
+		goto out;
+
+	if (tgt_drivers[target->lid]->target_show)
+		len = tgt_drivers[target->lid]->target_show(target->tid, buf, rest);
+out:
+	return len;
+}
+
+int tgt_target_show_all(char *buf, int rest)
+{
+	int i, len, total;
+	struct target *target;
 	struct tgt_device *device;
-	int (*show)(int, char *, int);
 
-	for (i = 0; i < ARRAY_SIZE(target_hash_list); i++) {
+	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "tid %d: lld %s", target->tid,
-				       tgt_drivers[target->lid]->name);
+			len = snprintf(buf, rest, "tid %d: lld name %s\n",
+				       target->tid, tgt_drivers[target->lid]->name);
 			buf += len;
+			total += len;
 			rest -= len;
 			if (!rest)
 				goto out;
 
-			if (tgt_drivers[target->lid]->target_show) {
-				show = tgt_drivers[target->lid]->target_show;
-				len = show(target->tid, buf, rest);
-				buf += len;
-				rest -= len;
-				if (!rest)
-					goto out;
-			}
-
 			list_for_each_entry(device, &target->device_list, d_list) {
 				len = snprintf(buf, rest, "\tlun %" PRIu64 ": path %s\n",
 					       device->lun, device->path);
 				buf += len;
+				total += len;
 				rest -= len;
 				if (!rest)
 					goto out;
@@ -656,7 +663,7 @@
 		}
 	}
 out:
-	return rest;
+	return total;
 }
 
 __attribute__((constructor)) static void target_init(void)

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-11-10 16:41:58 UTC (rev 630)
+++ trunk/usr/tgtadm.h	2006-11-10 18:32:51 UTC (rev 631)
@@ -27,7 +27,7 @@
 	enum tgtadm_op op;
 	uint32_t len;
 
-	uint32_t tid;
+	int32_t tid;
 	uint64_t sid;
 	uint32_t cid;
 	uint64_t lun;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-10 16:41:58 UTC (rev 630)
+++ trunk/usr/tgtd.h	2006-11-10 18:32:51 UTC (rev 631)
@@ -48,7 +48,8 @@
 extern int tgt_target_create(int tid);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
-extern int tgt_target_show(char *buf, int rest);
+extern int tgt_target_show_all(char *buf, int rest);
+extern int tgt_target_show(int tid, char *buf, int rest);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);



From tomo at mail.berlios.de  Sat Nov 11 02:43:30 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 11 Nov 2006 02:43:30 +0100
Subject: [Stgt-svn] r632 - trunk/usr
Message-ID: <200611110143.kAB1hU8Q009672@sheep.berlios.de>

Author: tomo
Date: 2006-11-11 02:43:29 +0100 (Sat, 11 Nov 2006)
New Revision: 632

Modified:
   trunk/usr/tgtadm.c
Log:
Without specifying lld, tgtadm crashes.

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-10 18:32:51 UTC (rev 631)
+++ trunk/usr/tgtadm.c	2006-11-11 01:43:29 UTC (rev 632)
@@ -342,7 +342,8 @@
 	memset(buf, 0, sizeof(buf));
 
 	req = (struct tgtadm_req *) buf;
-	strncpy(req->lld, lldname, sizeof(req->lld));
+	if (lldname)
+		strncpy(req->lld, lldname, sizeof(req->lld));
 	req->mode = set_to_mode(set);
 	req->op = op;
 	req->tid = tid;



From tomo at mail.berlios.de  Sat Nov 11 05:20:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 11 Nov 2006 05:20:25 +0100
Subject: [Stgt-svn] r633 - trunk/usr
Message-ID: <200611110420.kAB4KP9O021984@sheep.berlios.de>

Author: tomo
Date: 2006-11-11 05:20:24 +0100 (Sat, 11 Nov 2006)
New Revision: 633

Modified:
   trunk/usr/tgtd.c
Log:
Enable all available llds on startup.


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-11 01:43:29 UTC (rev 632)
+++ trunk/usr/tgtd.c	2006-11-11 04:20:24 UTC (rev 633)
@@ -55,7 +55,6 @@
 
 static struct option const long_options[] =
 {
-	{"lld", required_argument, 0, 'l'},
 	{"foreground", no_argument, 0, 'f'},
 	{"debug", required_argument, 0, 'd'},
 	{"version", no_argument, 0, 'v'},
@@ -71,7 +70,6 @@
 		printf("Usage: %s [OPTION]\n", program_name);
 		printf("\
 Target framework daemon.\n\
-  -l, --lld               specify low level drivers to run\n\
   -f, --foreground        make the program run in the foreground\n\
   -d, --debug debuglevel  print debugging information\n\
   -h, --help              display this help and exit\n\
@@ -236,34 +234,21 @@
 		goto retry;
 }
 
-static int lld_init(char *data)
+static int lld_init(void)
 {
-	char *list, *p, *q;
-	int index, err, ndriver = 0;
+	int i, err, nr;
 
-	p = list = strdup(data);
-	if (!p)
-		return 0;
-
-	while (p) {
-		q = strchr(p, ',');
-		if (q)
-			*q++ = '\0';
-		index = get_driver_index(p);
-		p = q;
-		if (index >= 0) {
-			if (tgt_drivers[index]->init) {
-				err = tgt_drivers[index]->init();
-				if (err)
-					continue;
-			}
-			tgt_drivers[index]->enable = 1;
-			ndriver++;
+	for (i = nr = 0; tgt_drivers[i]; i++) {
+		if (tgt_drivers[i]->init) {
+			err = tgt_drivers[i]->init();
+			if (err)
+				continue;
+			tgt_drivers[i]->enable = 1;
+			nr++;
 		}
 	}
-	free(list);
 
-	return ndriver;
+	return nr;
 }
 
 int main(int argc, char **argv)
@@ -272,7 +257,6 @@
 	struct sigaction sa_new;
 	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS;
 	int is_daemon = 1, is_debug = 0;
-	char *modes = NULL;
 
 	/* do not allow ctrl-c for now... */
 	sa_new.sa_handler = signal_catch;
@@ -285,9 +269,6 @@
 	while ((ch = getopt_long(argc, argv, "l:fd:vh", long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
-		case 'l':
-			modes = optarg;
-			break;
 		case 'f':
 			is_daemon = 0;
 			break;
@@ -312,10 +293,10 @@
 		exit(1);
 	}
 
-	if (modes)
-		nr_lld = lld_init(modes);
+
+	nr_lld = lld_init();
 	if (!nr_lld) {
-		printf("No available low level driver!\n");
+		fprintf(stderr, "No available low level driver!\n");
 		exit(1);
 	}
 



From tomo at mail.berlios.de  Sat Nov 11 05:23:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 11 Nov 2006 05:23:10 +0100
Subject: [Stgt-svn] r634 - trunk/doc
Message-ID: <200611110423.kAB4NApE022101@sheep.berlios.de>

Author: tomo
Date: 2006-11-11 05:23:10 +0100 (Sat, 11 Nov 2006)
New Revision: 634

Modified:
   trunk/doc/README.ibmvstgt
   trunk/doc/README.iscsi
Log:
Update docs for the previous commit.


Modified: trunk/doc/README.ibmvstgt
===================================================================
--- trunk/doc/README.ibmvstgt	2006-11-11 04:20:24 UTC (rev 633)
+++ trunk/doc/README.ibmvstgt	2006-11-11 04:23:10 UTC (rev 634)
@@ -6,7 +6,7 @@
 host:~/tgt# modprobe scsi_tgt
 host:~/tgt# modprobe libsrp
 host:~/tgt# modprobe ibmvstgt
-host:~/tgt# ./usr/tgtd --lld ibmvio
+host:~/tgt# ./usr/tgtd
 
 See /var/log/kern.log (your Linux distributions may use the different
 log file name) to make sure that the kernel modules are loaded

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-11 04:20:24 UTC (rev 633)
+++ trunk/doc/README.iscsi	2006-11-11 04:23:10 UTC (rev 634)
@@ -3,7 +3,7 @@
 Try the following commands:
 
 host:~/tgt$ su
-host:~/tgt# ./usr/tgtd --lld iscsi
+host:~/tgt# ./usr/tgtd
 
 
 Configuration



From tomo at mail.berlios.de  Sat Nov 11 05:56:22 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 11 Nov 2006 05:56:22 +0100
Subject: [Stgt-svn] r635 - trunk/usr
Message-ID: <200611110456.kAB4uMH7023423@sheep.berlios.de>

Author: tomo
Date: 2006-11-11 05:56:21 +0100 (Sat, 11 Nov 2006)
New Revision: 635

Modified:
   trunk/usr/tgtd.c
Log:
Remove unused getopt


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-11 04:23:10 UTC (rev 634)
+++ trunk/usr/tgtd.c	2006-11-11 04:56:21 UTC (rev 635)
@@ -266,7 +266,7 @@
 	sigaction(SIGPIPE, &sa_new, &sa_old );
 	sigaction(SIGTERM, &sa_new, &sa_old );
 
-	while ((ch = getopt_long(argc, argv, "l:fd:vh", long_options,
+	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':



From tomo at mail.berlios.de  Sat Nov 11 06:02:13 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 11 Nov 2006 06:02:13 +0100
Subject: [Stgt-svn] r636 - in trunk/usr: . ibmvio iscsi
Message-ID: <200611110502.kAB52DOK023796@sheep.berlios.de>

Author: tomo
Date: 2006-11-11 06:02:13 +0100 (Sat, 11 Nov 2006)
New Revision: 636

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/tgtd.c
Log:
Add kernel interface check.

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-11 04:56:21 UTC (rev 635)
+++ trunk/usr/driver.h	2006-11-11 05:02:13 UTC (rev 636)
@@ -2,6 +2,7 @@
 
 struct tgt_driver {
 	const char *name;
+	int use_kernel;
 
 	int (*init) (void);
 
@@ -19,9 +20,6 @@
 			      uint64_t tag);
 	int (*mgmt_end_notify)(int host_no, uint64_t mid, int result);
 
-	int enable;
-	int pfd_index;
-
 	struct backedio_template *bdt;
 };
 

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-11-11 04:56:21 UTC (rev 635)
+++ trunk/usr/ibmvio/ibmvio.h	2006-11-11 05:02:13 UTC (rev 636)
@@ -7,6 +7,7 @@
 
 struct tgt_driver ibmvio = {
 	.name			= "ibmvio",
+	.use_kernel		= 1,
 	.scsi_get_lun		= scsi_lun_to_int,
 	.scsi_report_luns	= scsi_report_luns,
 	.scsi_inquiry		= scsi_inquiry,

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-11 04:56:21 UTC (rev 635)
+++ trunk/usr/iscsi/iscsi.h	2006-11-11 05:02:13 UTC (rev 636)
@@ -9,6 +9,7 @@
 
 struct tgt_driver iscsi = {
 	.name			= "iscsi",
+	.use_kernel		= 0,
 	.init			= iscsi_init,
 	.target_create		= iscsi_target_create,
 	.target_destroy		= iscsi_target_destroy,

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-11 04:56:21 UTC (rev 635)
+++ trunk/usr/tgtd.c	2006-11-11 05:02:13 UTC (rev 636)
@@ -234,7 +234,7 @@
 		goto retry;
 }
 
-static int lld_init(void)
+static int lld_init(int *use_kernel)
 {
 	int i, err, nr;
 
@@ -243,7 +243,8 @@
 			err = tgt_drivers[i]->init();
 			if (err)
 				continue;
-			tgt_drivers[i]->enable = 1;
+			if (tgt_drivers[i]->use_kernel)
+				*use_kernel++;
 			nr++;
 		}
 	}
@@ -257,6 +258,7 @@
 	struct sigaction sa_new;
 	int err, ch, longindex, nr_lld = 0, maxfds = MAX_FDS;
 	int is_daemon = 1, is_debug = 0;
+	int use_kernel = 0;
 
 	/* do not allow ctrl-c for now... */
 	sa_new.sa_handler = signal_catch;
@@ -293,8 +295,7 @@
 		exit(1);
 	}
 
-
-	nr_lld = lld_init();
+	nr_lld = lld_init(&use_kernel);
 	if (!nr_lld) {
 		fprintf(stderr, "No available low level driver!\n");
 		exit(1);
@@ -309,9 +310,13 @@
 	if (err)
 		exit(1);
 
-	err = kreq_init();
-	if (err)
-		eprintf("No kernel interface\n");
+	if (use_kernel) {
+		err = kreq_init();
+		if (err) {
+			eprintf("No kernel interface\n");
+			exit(1);
+		}
+	}
 
 	err = ipc_init();
 	if (err)



From tomo at mail.berlios.de  Sun Nov 12 10:16:21 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 12 Nov 2006 10:16:21 +0100
Subject: [Stgt-svn] r637 - in trunk/usr: . iscsi
Message-ID: <200611120916.kAC9GLkL005765@sheep.berlios.de>

Author: tomo
Date: 2006-11-12 10:16:20 +0100 (Sun, 12 Nov 2006)
New Revision: 637

Modified:
   trunk/usr/driver.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
   trunk/usr/iscsi/transport.c
   trunk/usr/iscsi/transport.h
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.h
Log:
Add various show options to iSCSI driver.


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/driver.h	2006-11-12 09:16:20 UTC (rev 637)
@@ -8,9 +8,10 @@
 
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);
-	int (*target_show) (int, char *, int);
 	int (*target_update) (int, char *);
 
+	int (*show) (int, int, uint64_t, uint32_t, uint64_t, char *, int);
+
 	uint64_t (*scsi_get_lun)(uint8_t *);
 	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,
 				uint8_t *, int *);

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/iscsi.h	2006-11-12 09:16:20 UTC (rev 637)
@@ -1,7 +1,8 @@
 extern int iscsi_init(void);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
-extern int iscsi_target_show(int, char *, int);
+extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
+			     uint64_t lun, char *buf, int rest);
 extern int iscsi_target_update(int, char *);
 extern int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw,
 			       uint64_t addr, uint64_t tag);
@@ -13,8 +14,8 @@
 	.init			= iscsi_init,
 	.target_create		= iscsi_target_create,
 	.target_destroy		= iscsi_target_destroy,
-	.target_show		= iscsi_target_show,
 	.target_update		= iscsi_target_update,
+	.show			= iscsi_target_show,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
 	.bdt			= &aio_bdt,

Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/iscsi_tcp.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <sys/epoll.h>
@@ -188,12 +189,39 @@
 	return close(ep);
 }
 
+static int iscsi_tcp_show(int ep, char *buf, int rest)
+{
+	int err, total = 0;
+	socklen_t slen;
+	char dst[INET6_ADDRSTRLEN];
+	struct sockaddr_storage from;
+
+	slen = sizeof(from);
+	err = getpeername(ep, (struct sockaddr *) &from, &slen);
+	if (err < 0) {
+		eprintf("%m\n");
+		return 0;
+	}
+
+	err = getnameinfo((struct sockaddr *)&from, sizeof(from), dst,
+			  sizeof(dst), NULL, 0, NI_NUMERICHOST);
+	if (err < 0) {
+		eprintf("%m\n");
+		return 0;
+	}
+
+	total = snprintf(buf, rest, " ip:%s\n", dst);
+
+	return total > 0 ? total : 0;
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name		= "iscsi",
 	.rdma		= 0,
-	.init		= iscsi_tcp_init,
+	.ep_init	= iscsi_tcp_init,
 	.ep_read	= iscsi_tcp_read,
 	.ep_write_begin	= iscsi_tcp_write_begin,
 	.ep_write_end	= iscsi_tcp_write_end,
 	.ep_close	= iscsi_tcp_close,
+	.ep_show	= iscsi_tcp_show,
 };

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/iscsid.h	2006-11-12 09:16:20 UTC (rev 637)
@@ -39,6 +39,8 @@
 	(uint64_t) tsih << 48;					\
 })
 
+#define sid_to_tsih(sid) ((sid) >> 48)
+
 struct PDU {
 	struct iscsi_hdr bhs;
 	void *ahs;
@@ -76,6 +78,8 @@
 	struct list_head pending_cmd_list;
 
 	uint32_t exp_cmd_sn;
+
+	struct param session_param[ISCSI_PARAM_MAX];
 };
 
 struct iscsi_task {

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/session.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -72,6 +72,12 @@
 	if (!session)
 		return -ENOMEM;
 
+	session->initiator = strdup(conn->initiator);
+	if (!session->initiator) {
+		free(session);
+		return -ENOMEM;
+	}
+
 	session->target = target;
 	INIT_LIST_HEAD(&session->slist);
 	list_add(&session->slist, &target->sessions_list);
@@ -84,13 +90,15 @@
 	session->tsih = last_tsih = tsih;
 
 	conn_add_to_session(conn, session);
-	conn->session->initiator = strdup(conn->initiator);
 
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
 
 	list_add(&session->hlist, &sessions_list);
 	session->exp_cmd_sn = conn->exp_cmd_sn;
 
+	memcpy(session->session_param, conn->session_param,
+	       sizeof(session->session_param));
+
 	return 0;
 }
 

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/target.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -161,6 +161,15 @@
 	return 0;
 }
 
+#define buffer_check(buf, total, len, rest)	\
+({						\
+	buf += len;				\
+	total += len;				\
+	rest -= len;				\
+	if (!rest)				\
+		break;				\
+})
+
 static int show_iscsi_param(char *buf, struct param *param, int rest)
 {
 	int i, len, total;
@@ -169,31 +178,102 @@
 
 	for (i = total = 0; session_keys[i].name; i++) {
 		param_val_to_str(keys, i, param[i].val, value);
-		len = snprintf(buf + total, rest, "%s=%s\n", keys[i].name, value);
-		total += len;
-		rest -= len;
-		if (!rest)
-			break;
+		len = snprintf(buf, rest, "%s=%s\n", keys[i].name, value);
+		buffer_check(buf, total, len, rest);
 	}
 
 	return total;
 }
 
-int iscsi_target_show(int tid, char *buf, int rest)
+static int iscsi_target_show_connection(struct target* target, uint64_t sid,
+					uint32_t cid, char *buf, int rest)
 {
+	int len, total = 0;
+	struct session *session;
+	struct connection *conn;
+
+	session = session_lookup(sid_to_tsih(sid));
+	if (!session)
+		return 0;
+
+	len = 0;
+	list_for_each_entry(conn, &session->conn_list, clist) {
+		if (conn->cid == cid || !cid) {
+			if (cid) {
+			} else {
+				len = snprintf(buf, rest, "cid:%u", conn->cid);
+				buffer_check(buf, total, len, rest);
+
+				len = 0;
+				if (conn->tp->ep_show) {
+					len = conn->tp->ep_show(conn->fd, buf, rest);
+					buffer_check(buf, total, len, rest);
+				}
+
+				if (!len) {
+					len = snprintf(buf, rest, "\n");
+					buffer_check(buf, total, len, rest);
+				}
+			}
+		}
+	}
+
+	return total;
+}
+
+static int iscsi_target_show_session(struct target* target, uint64_t sid,
+				     char *buf, int rest)
+{
+	int len, total = 0;
+	struct session *session;
+
+	list_for_each_entry(session, &target->sessions_list, slist) {
+		if (sid64(session->isid, session->tsih) == sid || !sid) {
+			if (sid)
+				len = show_iscsi_param(buf, session->session_param, rest);
+			else
+				len = snprintf(buf, rest, "sid:%" PRIu64 " initiator:%s\n",
+					       sid64(session->isid, session->tsih),
+					       session->initiator);
+			buffer_check(buf, total, len, rest);
+		}
+	}
+
+	return total;
+}
+
+int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid, uint64_t lun,
+		      char *buf, int rest)
+{
 	struct target* target;
-	int len;
+	int len, total = 0;
 
 	target = target_find_by_id(tid);
 	if (!target)
 		return 0;
 
-	len = snprintf(buf, rest, "tid: %d %s\n", target->tid, target->name);
-	rest -= len;
-	if (!rest)
-		goto out;
-
-	len += show_iscsi_param(buf + len, target->session_param, rest);
+	switch (mode) {
+	case MODE_TARGET:
+		len = snprintf(buf, rest, "iqn=%s\n", target->name);
+		buf += len;
+		total += len;
+		rest -= len;
+		if (!rest)
+			goto out;
+		len = show_iscsi_param(buf, target->session_param, rest);
+		total += len;
+		break;
+	case MODE_SESSION:
+		len = iscsi_target_show_session(target, sid, buf, rest);
+		total += len;
+		break;
+	case MODE_CONNECTION:
+		len = iscsi_target_show_connection(target, sid, cid, buf, rest);
+		total += len;
+		break;
+	default:
+		break;
+	}
 out:
-	return len;
+	return total;
 }

Modified: trunk/usr/iscsi/transport.c
===================================================================
--- trunk/usr/iscsi/transport.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/transport.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -15,7 +15,7 @@
 	int i, err, nr = 0;
 
 	for (i = 0; iscsi_transports[i]; i++) {
-		err = iscsi_transports[i]->init();
+		err = iscsi_transports[i]->ep_init();
 		if (!err)
 			nr++;
 	}

Modified: trunk/usr/iscsi/transport.h
===================================================================
--- trunk/usr/iscsi/transport.h	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/iscsi/transport.h	2006-11-12 09:16:20 UTC (rev 637)
@@ -5,11 +5,12 @@
 	const char *name;
 	int rdma;
 
-	int (*init) (void);
+	int (*ep_init) (void);
 	size_t (*ep_read) (int ep, void *buf, size_t nbytes);
 	size_t (*ep_write_begin) (int ep, void *buf, size_t nbytes);
 	void (*ep_write_end)(int ep);
 	size_t (*ep_close) (int ep);
+	int (*ep_show) (int ep, char *buf, int rest);
 };
 
 extern struct iscsi_transport iscsi_tcp;

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/mgmt.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -42,27 +42,13 @@
 
 #define BUFSIZE 4096
 
-static void device_create_parser(char *args, char **path, char **devtype)
+static void set_show_results(struct tgtadm_res *res, int err)
 {
-	char *p, *q;
-
-	if (isspace(*args))
-		args++;
-	if ((p = strchr(args, '\n')))
-		*p = '\0';
-
-	while ((p = strsep(&args, ","))) {
-		if (!p)
-			continue;
-
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-
-		if (!strcmp(p, "Path"))
-			*path = q;
-		else if (!strcmp(p, "Type"))
-			*devtype = q;
+	if (err < 0)
+		res->err = err;
+	else {
+		res->err = 0;
+		res->len = err + sizeof(*res);
 	}
 }
 
@@ -96,10 +82,33 @@
 
 	res->err = err;
 	res->len = (char *) res->data - (char *) res;
-
 	return err;
 }
 
+static void device_create_parser(char *args, char **path, char **devtype)
+{
+	char *p, *q;
+
+	if (isspace(*args))
+		args++;
+	if ((p = strchr(args, '\n')))
+		*p = '\0';
+
+	while ((p = strsep(&args, ","))) {
+		if (!p)
+			continue;
+
+		if (!(q = strchr(p, '=')))
+			continue;
+		*q++ = '\0';
+
+		if (!strcmp(p, "Path"))
+			*path = q;
+		else if (!strcmp(p, "Type"))
+			*devtype = q;
+	}
+}
+
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
 		       struct tgtadm_res *res, int *rlen)
 {
@@ -123,7 +132,7 @@
 	}
 
 	res->err = err;
-	res->len = (char *) res->data - (char *) res;
+	res->len = sizeof(*res);
 
 	return err;
 }
@@ -139,23 +148,25 @@
 		req->tid, req->sid, req->lun, params, getpid());
 
 	if (req->op == OP_SHOW) {
-		if (req->tid > 0)
-			err = tgt_target_show(req->tid, (char *)res->data,
-					      len - sizeof(*res));
-		else
+		if (req->mode == MODE_TARGET && req->tid < 0)
 			err = tgt_target_show_all((char *)res->data,
 						  len - sizeof(*res));
-		if (err < 0)
-			res->err = err;
 		else {
-			res->err = 0;
-			res->len = err + sizeof(*res);
+			if (tgt_drivers[lld_no]->show)
+			err = tgt_drivers[lld_no]->show(req->mode,
+							req->tid, req->sid,
+							req->cid, req->lun,
+							(char *)res->data,
+							len - sizeof(*res));
 		}
-		dprintf("%d %d\n", len, err);
+
+		set_show_results(res, err);
 		return 0;
 	}
 
 	switch (req->mode) {
+	case MODE_SYSTEM:
+		break;
 	case MODE_TARGET:
 		err = target_mgmt(lld_no, req, params, res, &len);
 		break;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/target.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -620,21 +620,6 @@
 	return 0;
 }
 
-int tgt_target_show(int tid, char *buf, int rest)
-{
-	int len = 0;
-	struct target *target;
-
-	target  = target_lookup(tid);
-	if (!target)
-		goto out;
-
-	if (tgt_drivers[target->lid]->target_show)
-		len = tgt_drivers[target->lid]->target_show(target->tid, buf, rest);
-out:
-	return len;
-}
-
 int tgt_target_show_all(char *buf, int rest)
 {
 	int i, len, total;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/tgtadm.c	2006-11-12 09:16:20 UTC (rev 637)
@@ -62,23 +62,25 @@
 
 static struct option const long_options[] =
 {
-	{"lld", required_argument, NULL, 'n'},
+	{"lld", required_argument, NULL, 'l'},
 	{"op", required_argument, NULL, 'o'},
+	{"mode", required_argument, NULL, 'm'},
 	{"tid", required_argument, NULL, 't'},
 	{"sid", required_argument, NULL, 's'},
 	{"cid", required_argument, NULL, 'c'},
-	{"lun", required_argument, NULL, 'l'},
-	{"params", required_argument, NULL, 'p'},
-	{"user", no_argument, NULL, 'u'},
+	{"lun", required_argument, NULL, 'u'},
 	{"hostno", required_argument, NULL, 'i'},
-	{"name", required_argument, NULL, 'm'},
-	{"value", required_argument, NULL, 'a'},
+	{"bus", required_argument, NULL, 'b'},
+	{"params", required_argument, NULL, 'p'},
+	{"name", required_argument, NULL, 'n'},
+	{"value", required_argument, NULL, 'v'},
 	{"debug", no_argument, NULL, 'd'},
-	{"version", no_argument, NULL, 'v'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
 };
 
+static char *short_options = "l:o:m:t:s:c:u:i:b:p:n:v:dh";
+
 static void usage(int status)
 {
 	if (status != 0)
@@ -217,20 +219,20 @@
 	return err;
 }
 
-static int set_to_mode(uint32_t set)
+static int str_to_mode(char *str)
 {
-	int mode = MODE_SYSTEM;
+	int mode = -1;
 
-	if (set & (1 << MODE_USER))
-		mode = MODE_USER;
-	else if (set & (1 << MODE_DEVICE))
+	if (!strcmp("target", str) || !strcmp("tgt", str))
+		mode = MODE_TARGET;
+	else if (!strcmp("logicalunit", str) || !strcmp("lu", str))
 		mode = MODE_DEVICE;
-	else if (set & (1 << MODE_CONNECTION))
-		mode = MODE_CONNECTION;
-	else if (set & (1 << MODE_SESSION))
+	else if (!strcmp("session", str) || !strcmp("sess", str))
 		mode = MODE_SESSION;
-	else if (set & (1 << MODE_TARGET))
-		mode = MODE_TARGET;
+	else if (!strcmp("connection", str) || !strcmp("conn", str))
+		mode = MODE_CONNECTION;
+	else if (!strcmp("user", str))
+		mode = MODE_USER;
 
 	return mode;
 }
@@ -260,40 +262,40 @@
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len = 0;
 	int tid = -1;
-	uint32_t cid = 0, set = 0, hostno = 0;
+	uint32_t cid = 0, hostno = 0;
 	uint64_t sid = 0, lun = 0;
 	char *params, *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
 	char *name, *value;
+	int mode = MODE_SYSTEM;
 
 	params = lldname = name = value = NULL;
 
 	optind = 1;
-	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvdh",
+	while ((ch = getopt_long(argc, argv, short_options,
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
-		case 'n':
+		case 'l':
 			lldname = optarg;
 			break;
 		case 'o':
 			op = str_to_op(optarg);
 			break;
+		case 'm':
+			mode = str_to_mode(optarg);
+			break;
 		case 't':
 			tid = strtol(optarg, NULL, 10);
-			set |= (1 << MODE_TARGET);
 			break;
 		case 's':
 			sid = strtoull(optarg, NULL, 10);
-			set |= (1 << MODE_SESSION);
 			break;
 		case 'c':
 			cid = strtoul(optarg, NULL, 10);
-			set |= (1 << MODE_CONNECTION);
 			break;
-		case 'l':
+		case 'u':
 			lun = strtoull(optarg, NULL, 10);
-			set |= (1 << MODE_DEVICE);
 			break;
 		case 'i':
 			hostno = strtol(optarg, NULL, 10);
@@ -303,22 +305,15 @@
 		case 'p':
 			params = optarg;
 			break;
-		case 'u':
-			set |= (1 << MODE_USER);
+		case 'n':
+			name = optarg;
 			break;
-		case 'a':
+		case 'v':
 			value = optarg;
 			break;
-		case 'm':
-			name = optarg;
-			break;
 		case 'd':
 			debug = 1;
 			break;
-		case 'v':
-			printf("%s\n", program_name);
-			exit(0);
-			break;
 		case 'h':
 			usage(0);
 			break;
@@ -344,7 +339,7 @@
 	req = (struct tgtadm_req *) buf;
 	if (lldname)
 		strncpy(req->lld, lldname, sizeof(req->lld));
-	req->mode = set_to_mode(set);
+	req->mode = mode;
 	req->op = op;
 	req->tid = tid;
 	req->sid = sid;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-11 05:02:13 UTC (rev 636)
+++ trunk/usr/tgtd.h	2006-11-12 09:16:20 UTC (rev 637)
@@ -49,7 +49,6 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 extern int tgt_target_show_all(char *buf, int rest);
-extern int tgt_target_show(int tid, char *buf, int rest);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);



From tomo at mail.berlios.de  Sun Nov 12 10:39:30 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 12 Nov 2006 10:39:30 +0100
Subject: [Stgt-svn] r638 - trunk/doc
Message-ID: <200611120939.kAC9dUop007142@sheep.berlios.de>

Author: tomo
Date: 2006-11-12 10:39:29 +0100 (Sun, 12 Nov 2006)
New Revision: 638

Modified:
   trunk/doc/README.iscsi
Log:
Add some command examples to README.iSCSI. 


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-12 09:16:20 UTC (rev 637)
+++ trunk/doc/README.iscsi	2006-11-12 09:39:29 UTC (rev 638)
@@ -14,16 +14,125 @@
 iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz) and adds a
 logical unit (backed by /dev/hdc1) with lun 0.
 
+Let's create one target devce and add a logical unit to it:
+
 host:~/tgt$ su
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 --params Path=/dev/hdc1
 
-iSCSI parameters are not configurable yet.
 
+You can get the current configuration:
 
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+tid 1: lld name iscsi
+        lun 0: path /dev/hdc1
+
+
+You can add lots of logical units:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 --params Path=/var/tmp/image
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+tid 1: lld name iscsi
+        lun 1: path /var/tmp/image
+        lun 0: path /dev/hdc1
+
+Now this target is ready to accept initiators.
+
+You can get iSCSI parameters of the target:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
+iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+MaxRecvDataSegmentLength=8192
+MaxXmitDataSegmentLength=8192
+HeaderDigest=None
+DataDigest=None
+InitialR2T=Yes
+MaxOutstandingR2T=1
+ImmediateData=Yes
+FirstBurstLength=65536
+MaxBurstLength=262144
+DataPDUInOrder=Yes
+DataSequenceInOrder=Yes
+ErrorRecoveryLevel=0
+IFMarker=No
+OFMarker=No
+DefaultTime2Wait=2
+DefaultTime2Retain=20
+OFMarkInt=Reject
+IFMarkInt=Reject
+MaxConnections=1
+
+
+You can chage iSCSI parameters like the folloing (e.g. set
+MaxRecvDataSegmentLength to 16384):
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
+
+
+You can get iSCSI parameters again to see it change:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
+iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+MaxRecvDataSegmentLength=16384
+MaxXmitDataSegmentLength=8192
+HeaderDigest=None
+DataDigest=None
+InitialR2T=Yes
+MaxOutstandingR2T=1
+ImmediateData=Yes
+FirstBurstLength=65536
+MaxBurstLength=262144
+DataPDUInOrder=Yes
+DataSequenceInOrder=Yes
+ErrorRecoveryLevel=0
+IFMarker=No
+OFMarker=No
+DefaultTime2Wait=2
+DefaultTime2Retain=20
+OFMarkInt=Reject
+IFMarkInt=Reject
+MaxConnections=1
+
+
+You can see the initiators that the target accepts:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1
+sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel
+sid:281474980708864 initiator:iqn.1987-05.com.cisco:01.4438aca09387
+
+
+You can see the negotiated iSCSI parameters between the target and the
+initiator:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1 --sid  281474980708864
+MaxRecvDataSegmentLength=8192
+MaxXmitDataSegmentLength=1024
+HeaderDigest=None
+DataDigest=None
+InitialR2T=Yes
+MaxOutstandingR2T=1
+ImmediateData=Yes
+FirstBurstLength=65536
+MaxBurstLength=262144
+DataPDUInOrder=Yes
+DataSequenceInOrder=Yes
+ErrorRecoveryLevel=0
+IFMarker=No
+OFMarker=No
+DefaultTime2Wait=2
+DefaultTime2Retain=0
+OFMarkInt=Reject
+IFMarkInt=Reject
+MaxConnections=1
+
+
+You can see the initiator information:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode connection --op show --tid 1 --sid  281474980708864
+cid:0 ip:192.168.11.5
+
+
 Status
 -------------
 It should work under normal circumstances (good initiator, no network
 problem, etc). However, don't play with important data.
-
-Probabaly, the current quality is similar to the IET 0.2.x.



From tomo at mail.berlios.de  Sun Nov 12 10:40:44 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 12 Nov 2006 10:40:44 +0100
Subject: [Stgt-svn] r639 - trunk/doc
Message-ID: <200611120940.kAC9eiMG007343@sheep.berlios.de>

Author: tomo
Date: 2006-11-12 10:40:44 +0100 (Sun, 12 Nov 2006)
New Revision: 639

Modified:
   trunk/doc/README.ibmvstgt
Log:
Update README.ibmvstgt


Modified: trunk/doc/README.ibmvstgt
===================================================================
--- trunk/doc/README.ibmvstgt	2006-11-12 09:39:29 UTC (rev 638)
+++ trunk/doc/README.ibmvstgt	2006-11-12 09:40:44 UTC (rev 639)
@@ -27,9 +27,9 @@
 The following example creates a target with id 1, adds a logical unit
 (backed by /dev/sdb1) with lun 0, and then bind the target with #1 scsi host.
 
-host:~/tgt# ./usr/tgtadm --lld ibmvio --op new --tid 1
-host:~/tgt# ./usr/tgtadm --lld ibmvio --op new --tid 1 --lun 0 --params Path=/dev/sdb1
-host:~/tgt# ./usr/tgtadm --lld ibmvio --op bind --tid 1 --host 1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op new --tid 1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode logicalunit --op new --tid 1 --lun 0 --params Path=/dev/sdb1
+host:~/tgt# ./usr/tgtadm --lld ibmvio --mode target --op bind --tid 1 --host 1
 
 Please see /var/log/daemon.log (your Linux distributions may use the
 different log file name again) to make sure that everything is



From tomo at mail.berlios.de  Mon Nov 13 14:28:52 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 13 Nov 2006 14:28:52 +0100
Subject: [Stgt-svn] r640 - in trunk: doc usr usr/iscsi
Message-ID: <200611131328.kADDSq35027297@sheep.berlios.de>

Author: tomo
Date: 2006-11-13 14:28:51 +0100 (Mon, 13 Nov 2006)
New Revision: 640

Added:
   trunk/usr/iscsi/account.c
   trunk/usr/iscsi/account.h
Modified:
   trunk/doc/README.iscsi
   trunk/usr/Makefile
   trunk/usr/driver.h
   trunk/usr/iscsi/chap.c
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
Log:
Add CHAP authentication support to the iSCSI driver.


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/doc/README.iscsi	2006-11-13 13:28:51 UTC (rev 640)
@@ -132,6 +132,45 @@
 cid:0 ip:192.168.11.5
 
 
+Security
+-------------
+Let's create a new account:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode account
+
+You need to set the user, passowrd, type of the account:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name User --value tomo
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Password --value hoge
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Type --value Incoming
+
+
+Just make sure what we have:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account
+aid:1 Type:Incoming User:tomo Password:hoge
+
+
+We have one account, however, this account does not be assigned to our target:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
+
+
+You can assign this account to your target:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1 --aid 1
+
+
+You can see the result:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
+aid:1 Type:Incoming User:tomo Password:hoge
+
+
+You can assign one account to lots of targets. Each target can have 16
+accounts. We don't support removing or unbinding accounts now.
+
+
 Status
 -------------
 It should work under normal circumstances (good initiator, no network

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/Makefile	2006-11-13 13:28:51 UTC (rev 640)
@@ -1,4 +1,5 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE -I$(KERNELSRC)/include -I../include -I.
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
+	-I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
 TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o sched.o
 LIBS += -laio
@@ -11,7 +12,8 @@
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o chap.o transport.o)
+TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
+	account.o chap.o transport.o)
 TGTD_OBJS += $(addprefix iscsi/, iscsi_tcp.o)
 LIBS += -lcrypto
 BD_AIO=1

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/driver.h	2006-11-13 13:28:51 UTC (rev 640)
@@ -11,6 +11,7 @@
 	int (*target_update) (int, char *);
 
 	int (*show) (int, int, uint64_t, uint32_t, uint64_t, char *, int);
+	int (*account) (uint32_t, int, uint32_t, char *, char *, int);
 
 	uint64_t (*scsi_get_lun)(uint8_t *);
 	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,

Added: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/account.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -0,0 +1,336 @@
+/*
+ * SCSI target account management functions
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "iscsid.h"
+#include "tgtadm.h"
+#include "util.h"
+
+enum {
+	ACCOUNT_INVALID,
+	ACCOUNT_INCOMING,
+	ACCOUNT_OUTGOING,
+};
+
+struct iscsi_account {
+	struct list_head ac_list;
+
+	char *user;
+	char *password;
+
+	int type;
+	uint32_t id;
+
+	struct ac_head ach;
+};
+
+static LIST_HEAD(accounts_list);
+
+static struct iscsi_account *iscsi_lookup_account(uint32_t id)
+{
+	struct iscsi_account *pos;
+
+	list_for_each_entry(pos, &accounts_list, ac_list) {
+		if (pos->id == id)
+			return pos;
+	}
+	return NULL;
+}
+
+static int iscsi_create_account(void)
+{
+	static uint32_t id;
+	uint32_t new_id;
+	struct iscsi_account *ac;
+
+	for (new_id = id + 1; iscsi_lookup_account(new_id) && new_id == id;
+	     new_id++)
+		;
+	if (new_id == id) {
+		eprintf("Too many accounts\n");
+		return EINVAL;
+	}
+
+	ac = zalloc(sizeof(*ac));
+	if (!ac)
+		return ENOMEM;
+
+	ac->id = id = new_id;
+	ac->type = ACCOUNT_INVALID;
+	ac->ach.first = NULL;
+
+	list_add(&ac->ac_list, &accounts_list);
+
+	return 0;
+}
+
+static int iscsi_account_update(uint32_t uid, char *name)
+{
+	int err = EINVAL;
+	char *str;
+	struct iscsi_account *ac;
+
+	ac = iscsi_lookup_account(uid);
+	if (!ac)
+		return ENOENT;
+
+	str = name + strlen(name) + 1;
+
+	if (!strcmp(name, "Type")) {
+		if (ac->type != ACCOUNT_INVALID)
+			return err;
+
+		if (!strcmp(str, "Incoming")) {
+			err = 0;
+			ac->type = ACCOUNT_INCOMING;
+		} else if (!strcmp(str, "Outgoing")) {
+			err = 0;
+			ac->type = ACCOUNT_OUTGOING;
+		}
+
+	} else if (!strcmp(name, "User")) {
+		if (ac->user)
+			free(ac->user);
+		ac->user = strdup(str);
+		if (ac->user)
+			err = 0;
+		else
+			err = ENOMEM;
+	} else if (!strcmp(name, "Password")) {
+		if (ac->password)
+			free(ac->password);
+		ac->password = strdup(str);
+		if (ac->password)
+			err = 0;
+		else
+			err = ENOMEM;
+	}
+
+	return err;
+}
+
+static void __account_bind(struct iscsi_account *ac, struct ac_node *acn)
+{
+	acn->head = &ac->ach;
+	acn->next = ac->ach.first;
+	ac->ach.first = acn;
+}
+
+static int iscsi_account_bind(int tid, uint32_t uid)
+{
+	int i, err;
+	struct target* target;
+	struct iscsi_account *ac, *tmp;
+	struct ac_node *acn;
+
+	target = target_find_by_id(tid);
+	if (!target)
+		return ENOENT;
+
+	ac = iscsi_lookup_account(uid);
+	if (!ac)
+		return ENOENT;
+
+	if (!ac->user || !ac->password) {
+		eprintf("You must set user and password first\n");
+		return EINVAL;
+	}
+
+	err = EINVAL;
+	if (ac->type == ACCOUNT_INCOMING) {
+		acn = target->incoming;
+		for (i = 0; i < ARRAY_SIZE(target->incoming); i++, acn++) {
+			if (acn->head) {
+				tmp = container_of(acn->head, struct iscsi_account, ach);
+				if (tmp->id == ac->id) {
+					eprintf("This target already has this account\n");
+					break;
+				}
+			} else {
+				__account_bind(ac, acn);
+				err = 0;
+				break;
+			}
+		}
+		if (err)
+			eprintf("This target cannot have any more account\n");
+
+	} else if (ac->type == ACCOUNT_OUTGOING) {
+		if (target->outgoing.head)
+			eprintf("This target already has the outgoing account\n");
+		else {
+			__account_bind(ac, &target->outgoing);
+			err = 0;
+		}
+	} else
+		eprintf("You must set account type first\n");
+
+	return err;
+}
+
+#define print_account(buf, rest, ac)				\
+snprintf(buf, rest, "aid:%u Type:%s User:%s Password:%s\n",	\
+	(ac)->id, ac_type[(ac)->type], (ac)->user ? : "Empty",	\
+	(ac)->password ? : "Empty")
+
+static int iscsi_show_account(int tid, uint32_t uid, char *buf, int rest)
+{
+	int len, i, total = 0;
+	char *ac_type[] = {"Invalid", "Incoming", "Outgoing"};
+	struct iscsi_account *ac;
+	struct ac_node *acn;
+
+	if (tid == -1) {
+		list_for_each_entry(ac, &accounts_list, ac_list) {
+			len = print_account(buf, rest, ac);
+			buffer_check(buf, total, len, rest);
+		}
+	} else {
+		struct target* target;
+
+		target = target_find_by_id(tid);
+		if (!target)
+			goto out;
+
+		acn = target->incoming;
+		for (i = 0; i < ARRAY_SIZE(target->incoming); i++, acn++) {
+			if (!acn->head)
+				continue;
+
+			ac = container_of(acn->head, struct iscsi_account, ach);
+			len = print_account(buf, rest, ac);
+			buffer_check(buf, total, len, rest);
+		}
+
+		acn = &target->outgoing;
+		if (!acn->head)
+			goto out;
+		ac = container_of(acn->head, struct iscsi_account, ach);
+		len = print_account(buf, rest, ac);
+		total += len;
+	}
+out:
+	return total;
+}
+
+int iscsi_mgmt_account(uint32_t op, int tid, uint32_t uid, char *param, char *buf, int len)
+{
+	int err = EINVAL;
+
+	switch (op) {
+	case OP_NEW:
+		err = iscsi_create_account();
+		break;
+	case OP_DELETE:
+		eprintf("Not implemented yet\n");
+		break;
+	case OP_UPDATE:
+		err = iscsi_account_update(uid, param);
+		break;
+	case OP_BIND:
+		err = iscsi_account_bind(tid, uid);
+		break;
+	case OP_UNBIND:
+		eprintf("Not implemented yet\n");
+		break;
+	case OP_SHOW:
+		err = iscsi_show_account(tid, uid, buf, len);
+		break;
+	default:
+		break;
+	}
+
+	eprintf("%d\n", err);
+
+	return err;
+}
+
+int iscsi_account_available(int tid, int dir)
+{
+	int err = 0;
+	struct target* target;
+	struct ac_node *acn;
+
+	target = target_find_by_id(tid);
+	if (!target)
+		return ENOENT;
+
+	if (dir == AUTH_DIR_INCOMING) {
+		int i;
+
+		acn = target->incoming;
+		for (i = 0;  i < ARRAY_SIZE(target->incoming); i++, acn++) {
+			if (acn->head) {
+				err = 1;
+				break;
+			}
+		}
+
+	} else if (dir == AUTH_DIR_OUTGOING) {
+		acn = &target->outgoing;
+		if (acn->head)
+			err = 1;
+	}
+
+	return err;
+}
+
+int iscsi_account_lookup(int tid, int dir, char *user, char *pass)
+{
+	int err = ENOENT;
+	struct target* target;
+	struct iscsi_account *ac;
+	struct ac_node *acn;
+
+	target = target_find_by_id(tid);
+	if (!target)
+		return err;
+
+	if (dir == AUTH_DIR_INCOMING) {
+		int i;
+
+		acn = target->incoming;
+		for (i = 0;  i < ARRAY_SIZE(target->incoming); i++, acn++) {
+			if (acn->head) {
+				ac = container_of(acn->head, struct iscsi_account, ach);
+				if (!strcmp(ac->user, user)) {
+					strncpy(pass, ac->password, ISCSI_NAME_LEN);
+					err = 0;
+				}
+			}
+		}
+	} else if (dir == AUTH_DIR_OUTGOING) {
+		acn = &target->outgoing;
+		if (acn->head) {
+			ac = container_of(acn->head, struct iscsi_account, ach);
+			strncpy(user, ac->user, ISCSI_NAME_LEN);
+			strncpy(pass, ac->password, ISCSI_NAME_LEN);
+			err = 0;
+		}
+	} else
+		eprintf("Invalid direction\n");
+
+	return err;
+}

Added: trunk/usr/iscsi/account.h
===================================================================
--- trunk/usr/iscsi/account.h	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/account.h	2006-11-13 13:28:51 UTC (rev 640)
@@ -0,0 +1,19 @@
+#ifndef ACCOUNT_H
+#define ACCOUNT_H
+
+struct ac_node;
+
+struct ac_head {
+	struct ac_node *first;
+};
+
+struct ac_node {
+	struct ac_node *next;
+	struct ac_head *head;
+};
+
+extern int iscsi_account_lookup(int tid, int dir, char *user, char *pass);
+extern int iscsi_account_available(int tid, int dir);
+
+#endif
+

Modified: trunk/usr/iscsi/chap.c
===================================================================
--- trunk/usr/iscsi/chap.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/chap.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -21,6 +21,7 @@
 #include <openssl/md5.h>
 
 #include "iscsid.h"
+#include "account.h"
 
 #define HEX_FORMAT    0x01
 #define BASE64_FORMAT 0x02
@@ -375,30 +376,31 @@
 {
 	char *value;
 	uint8_t *his_digest = NULL, *our_digest = NULL;
-	int digest_len = 0, retval = 0, encoding_format;
+	int digest_len = 0, retval = 0, encoding_format, err;
 	char pass[ISCSI_NAME_LEN];
 
 	memset(pass, 0, sizeof(pass));
-/* 	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, pass, pass) < 0) { */
-/* 		log_warning("CHAP initiator auth.: " */
-/* 			    "No CHAP credentials configured"); */
-/* 		retval = CHAP_TARGET_ERROR; */
-/* 		goto out; */
-/* 	} */
 
+	err = iscsi_account_available(conn->tid, AUTH_DIR_INCOMING);
+	if (!err) {
+		eprintf("No CHAP credentials configured\n");
+		retval = CHAP_TARGET_ERROR;
+		goto out;
+	}
+
 	if (!(value = text_key_find(conn, "CHAP_N"))) {
 		retval = CHAP_INITIATOR_ERROR;
 		goto out;
 	}
 
 	memset(pass, 0, sizeof(pass));
-/* 	if (cops->account_query(conn->tid, AUTH_DIR_INCOMING, value, pass) < 0) { */
-/* 		log_warning("CHAP initiator auth.: " */
-/* 			    "No valid user/pass combination for initiator %s " */
-/* 			    "found", conn->initiator); */
-/* 		retval = CHAP_AUTH_ERROR; */
-/* 		goto out; */
-/* 	} */
+	err = iscsi_account_lookup(conn->tid, AUTH_DIR_INCOMING, value, pass);
+	if (err) {
+		eprintf("No valid user/pass combination for initiator %s "
+			    "found\n", conn->initiator);
+		retval = CHAP_AUTH_ERROR;
+		goto out;
+	}
 
 	if (!(value = text_key_find(conn, "CHAP_R"))) {
 		retval = CHAP_INITIATOR_ERROR;
@@ -476,7 +478,7 @@
 	char chap_id, *value, *response = NULL;
 	uint8_t *challenge = NULL, *digest = NULL;
 	int encoding_format, response_len;
-	int challenge_len = 0, digest_len = 0, retval = 0;
+	int challenge_len = 0, digest_len = 0, retval = 0, err;
 	char pass[ISCSI_NAME_LEN], name[ISCSI_NAME_LEN];
 
 	if (!(value = text_key_find(conn, "CHAP_I"))) {
@@ -489,13 +491,14 @@
 
 	memset(pass, 0, sizeof(pass));
 	memset(name, 0, sizeof(name));
-/* 	if (cops->account_query(conn->tid, AUTH_DIR_OUTGOING, name, pass) < 0) { */
-/* 		log_warning("CHAP target auth.: " */
-/* 			    "no outgoing credentials configured%s", */
-/* 			    conn->tid ? "." : " for discovery."); */
-/* 		retval = CHAP_AUTH_ERROR; */
-/* 		goto out; */
-/* 	} */
+	err = iscsi_account_lookup(conn->tid, AUTH_DIR_OUTGOING, name, pass);
+	if (err) {
+		log_warning("CHAP target auth.: "
+			    "no outgoing credentials configured%s",
+			    conn->tid ? "." : " for discovery.");
+		retval = CHAP_AUTH_ERROR;
+		goto out;
+	}
 
 	if (!(value = text_key_find(conn, "CHAP_C"))) {
 		log_warning("CHAP target auth.: "

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/iscsi.h	2006-11-13 13:28:51 UTC (rev 640)
@@ -4,6 +4,8 @@
 extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
 			     uint64_t lun, char *buf, int rest);
 extern int iscsi_target_update(int, char *);
+extern int iscsi_mgmt_account(uint32_t op, int tid, uint32_t uid, char *param,
+			      char *buf, int len);
 extern int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw,
 			       uint64_t addr, uint64_t tag);
 extern int iscsi_tm_done(int host_no, uint64_t mid, int result);
@@ -16,6 +18,7 @@
 	.target_destroy		= iscsi_target_destroy,
 	.target_update		= iscsi_target_update,
 	.show			= iscsi_target_show,
+	.account		= iscsi_mgmt_account,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
 	.bdt			= &aio_bdt,

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/iscsid.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -21,6 +21,7 @@
 
 #include "iscsid.h"
 #include "tgtd.h"
+#include "account.h"
 #include "util.h"
 
 #define MAX_QUEUE_CMD	32
@@ -120,15 +121,6 @@
 	text_key_add(conn, key, "Reject");
 }
 
-static int account_empty(int tid, int dir)
-{
-	char pass[ISCSI_NAME_LEN];
-
-	memset(pass, 0, sizeof(pass));
-/* 	return cops->account_query(tid, dir, pass, pass) < 0 ? 1 : 0; */
-	return 1;
-}
-
 static void text_scan_security(struct connection *conn)
 {
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
@@ -148,13 +140,13 @@
 					*nextValue++ = 0;
 
 				if (!strcmp(value, "None")) {
-					if (!account_empty(conn->tid, AUTH_DIR_INCOMING))
+					if (iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
 						continue;
 					conn->auth_method = AUTH_NONE;
 					text_key_add(conn, key, "None");
 					break;
 				} else if (!strcmp(value, "CHAP")) {
-					if (account_empty(conn->tid, AUTH_DIR_INCOMING))
+					if (!iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
 						continue;
 					conn->auth_method = AUTH_CHAP;
 					text_key_add(conn, key, "CHAP");
@@ -505,7 +497,7 @@
 			conn->state = STATE_LOGIN;
 
 			login_start(conn);
-			if (!account_empty(conn->tid, AUTH_DIR_INCOMING))
+			if (iscsi_account_available(conn->tid, AUTH_DIR_INCOMING))
 				goto auth_err;
 			if (rsp->status_class)
 				return;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/iscsid.h	2006-11-13 13:28:51 UTC (rev 640)
@@ -15,6 +15,7 @@
 #include "transport.h"
 #include "list.h"
 #include "param.h"
+#include "account.h"
 #include "log.h"
 
 #include <scsi/iscsi_if.h>
@@ -218,6 +219,10 @@
 
 	int max_nr_sessions;
 	int nr_sessions;
+
+	/* TODO: support various account managements (like RADIUS) */
+	struct ac_node incoming[16];
+	struct ac_node outgoing;
 };
 
 enum task_flags {
@@ -266,4 +271,13 @@
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);
 
+#define buffer_check(buf, total, len, rest)	\
+({						\
+	buf += len;				\
+	total += len;				\
+	rest -= len;				\
+	if (!rest)				\
+		break;				\
+})
+
 #endif	/* ISCSID_H */

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/iscsi/target.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -161,15 +161,6 @@
 	return 0;
 }
 
-#define buffer_check(buf, total, len, rest)	\
-({						\
-	buf += len;				\
-	total += len;				\
-	rest -= len;				\
-	if (!rest)				\
-		break;				\
-})
-
 static int show_iscsi_param(char *buf, struct param *param, int rest)
 {
 	int i, len, total;

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/mgmt.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -147,7 +147,7 @@
 		req->len, lld_no, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
 
-	if (req->op == OP_SHOW) {
+	if (req->op == OP_SHOW && req->mode != MODE_ACCOUNT) {
 		if (req->mode == MODE_TARGET && req->tid < 0)
 			err = tgt_target_show_all((char *)res->data,
 						  len - sizeof(*res));
@@ -173,6 +173,20 @@
 	case MODE_DEVICE:
 		err = device_mgmt(lld_no, req, params, res, &len);
 		break;
+	case MODE_ACCOUNT:
+		if (tgt_drivers[lld_no]->account)
+			err = tgt_drivers[lld_no]->account(req->op, req->tid, req->aid,
+							   params,
+							   (char *)res->data,
+							   len - sizeof(*res));
+		if (req->op == OP_SHOW) {
+			set_show_results(res, err);
+			err = 0;
+		} else {
+			res->err = err;
+			res->len = sizeof(*res);
+		}
+		break;
 	default:
 		break;
 	}

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/tgtadm.c	2006-11-13 13:28:51 UTC (rev 640)
@@ -69,6 +69,7 @@
 	{"sid", required_argument, NULL, 's'},
 	{"cid", required_argument, NULL, 'c'},
 	{"lun", required_argument, NULL, 'u'},
+	{"aid", required_argument, NULL, 'a'},
 	{"hostno", required_argument, NULL, 'i'},
 	{"bus", required_argument, NULL, 'b'},
 	{"params", required_argument, NULL, 'p'},
@@ -79,7 +80,7 @@
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:b:p:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:b:p:n:v:dh";
 
 static void usage(int status)
 {
@@ -231,8 +232,8 @@
 		mode = MODE_SESSION;
 	else if (!strcmp("connection", str) || !strcmp("conn", str))
 		mode = MODE_CONNECTION;
-	else if (!strcmp("user", str))
-		mode = MODE_USER;
+	else if (!strcmp("account", str))
+		mode = MODE_ACCOUNT;
 
 	return mode;
 }
@@ -262,14 +263,15 @@
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len = 0;
 	int tid = -1;
-	uint32_t cid = 0, hostno = 0;
-	uint64_t sid = 0, lun = 0;
+	uint32_t cid, hostno, aid;
+	uint64_t sid, lun;
 	char *params, *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
 	char *name, *value;
 	int mode = MODE_SYSTEM;
 
+	cid = hostno = aid = sid = lun = 0;
 	params = lldname = name = value = NULL;
 
 	optind = 1;
@@ -297,6 +299,9 @@
 		case 'u':
 			lun = strtoull(optarg, NULL, 10);
 			break;
+		case 'a':
+			aid = strtol(optarg, NULL, 10);
+			break;
 		case 'i':
 			hostno = strtol(optarg, NULL, 10);
 			break;
@@ -334,6 +339,11 @@
 		usage(-1);
 	}
 
+	if (mode < 0) {
+		fprintf(stderr, "unknown mode\n");
+		usage(-1);
+	}
+
 	memset(buf, 0, sizeof(buf));
 
 	req = (struct tgtadm_req *) buf;
@@ -344,6 +354,7 @@
 	req->tid = tid;
 	req->sid = sid;
 	req->lun = lun;
+	req->aid = aid;
 	req->host_no = hostno;
 
 	if (params) {

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-11-12 09:40:44 UTC (rev 639)
+++ trunk/usr/tgtadm.h	2006-11-13 13:28:51 UTC (rev 640)
@@ -9,6 +9,7 @@
 	OP_DELETE,
 	OP_SHOW,
 	OP_BIND,
+	OP_UNBIND,
 	OP_UPDATE,
 };
 
@@ -19,7 +20,7 @@
 
 	MODE_SESSION,
 	MODE_CONNECTION,
-	MODE_USER,
+	MODE_ACCOUNT,
 };
 
 struct tgtadm_req {
@@ -31,6 +32,7 @@
 	uint64_t sid;
 	uint32_t cid;
 	uint64_t lun;
+	uint32_t aid;
 	char lld[TGT_LLD_NAME_LEN];
 	uint32_t host_no;
 	uint64_t data[0];



From tomo at mail.berlios.de  Mon Nov 13 14:32:19 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 13 Nov 2006 14:32:19 +0100
Subject: [Stgt-svn] r641 - trunk/doc
Message-ID: <200611131332.kADDWJWj027683@sheep.berlios.de>

Author: tomo
Date: 2006-11-13 14:32:19 +0100 (Mon, 13 Nov 2006)
New Revision: 641

Removed:
   trunk/doc/index.html
Log:
Remove index.html.

Deleted: trunk/doc/index.html
===================================================================
--- trunk/doc/index.html	2006-11-13 13:28:51 UTC (rev 640)
+++ trunk/doc/index.html	2006-11-13 13:32:19 UTC (rev 641)
@@ -1,130 +0,0 @@
-<?xml version="1.0" encoding="iso-8859-1"?>
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
-
-<head>
-<meta name="author" content="FUJITA Tomonori and Mike Christie" />
-<meta name="copyright" content="Copyright (C) 2006 FUJITA Tomonori and Mike Christie" />
-<meta name="description" content="Use all information at this site only at your own responsibility. I am not taking any responsibility for it on your behalf." />
-<meta name="robots" content="INDEX,FOLLOW" />
-<title>Linux SCSI target framework (tgt) project</title>
-<style type =" text/css">
-body { margin:20px; }
-a:link {
-text-decoration: none;
-}
-
-a:visited {
-text-decoration: none;
-}
-
-a:hover {
-text-decoration: none;
-}
-</style>
-</head>
-
-<body>
-
-<div class="header">
-<div class="title"><h1>Linux SCSI target framework (tgt) project</h1></div>
-</div>
-
-<div class="body">
-<div class="ex">
-<div>
-<p>
-Linux target framework (tgt) aims to simplify various SCSI target driver
-(iSCSI, Fibre Channel, RDMA, etc) creation and maintenance. Our key goal
-is implementing a great portion of tgt in user space.
-</p>
-
-<p>
-The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly. <a href="http://kernel.org/pub/linux/kernel/people/akpm/">The -mm tree</a> also includes tgt (since 2.6.16-rc6-mm1).
-</p>
-
-</div>
-
-
-<div>
-<p>
-<strong>Target drivers</strong>
-</p>
-
-<ul>
-
-<li>
-<p>
-Virtual SCSI target driver for <a href="http://www.ibm.com/systems/p/">IBM pSeries</a>
-</p>
-</li>
-
-<li>
-<p>
-<a href="http://www.qlogic.com/products/fc_san_hostadapers.asp">Qlogic qla2xxx</a> FC target driver (not yet)
-</p>
-</li>
-
-<li>
-<p>
-<a href="http://www.lsilogic.com">LSI logic</a> FC target driver (not yet)
-</p>
-</li>
-
-<li>
-<p>
-iSCSI software target driver for Ethernet NICs (not yet)
-</p>
-</li>
-
-<li>
-<p>
-<a href="http://www.qlogic.com/products/iscsi_products_hba.asp">Qlogic qla4xxx</a> iSCSI target driver (not yet)
-</p>
-</li>
-
-</ul>
-</div>
-
-
-<div>
-<p>
-<strong>TODO</strong>
-</p>
-
-<ul>
-
-<li>
-<p>
-Writing target drivers
-</p>
-</li>
-
-<li>
-<p>
-Fix out-of-memory bugs
-</p>
-</li>
-
-<li>
-<p>
-Implement Reserve/Release command support
-</p>
-</li>
-
-</ul>
-</div>
-
-
-<hr />
-
-<div>
-<img style="float:right; vertical-align:middle;" width="124px" height="32px" border="0" alt="BerliOS Developer Logo" src="http://developer.berlios.de/bslogo.php?group_id=3467">
-Linux target framework project was started and has been maintained by Mike Christie (michaelc at cs.wisc.edu) and FUJITA Tomonori (tomof at acm.org).
-<br />
-</div>
-
-</div>
-</div>
-</body>
-</html>



From tomo at mail.berlios.de  Mon Nov 13 14:37:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Mon, 13 Nov 2006 14:37:04 +0100
Subject: [Stgt-svn] r642 - trunk/doc
Message-ID: <200611131337.kADDb4X4028278@sheep.berlios.de>

Author: tomo
Date: 2006-11-13 14:37:04 +0100 (Mon, 13 Nov 2006)
New Revision: 642

Modified:
   trunk/doc/README.iscsi
Log:
Add shutdown description to iSCSI doc.

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-13 13:32:19 UTC (rev 641)
+++ trunk/doc/README.iscsi	2006-11-13 13:37:04 UTC (rev 642)
@@ -171,6 +171,14 @@
 accounts. We don't support removing or unbinding accounts now.
 
 
+Shutdown
+-------------
+host:~/tgt# killall -9 tgtd
+
+
+We will support better methods later.
+
+
 Status
 -------------
 It should work under normal circumstances (good initiator, no network



From tomo at mail.berlios.de  Tue Nov 14 10:40:45 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 14 Nov 2006 10:40:45 +0100
Subject: [Stgt-svn] r643 - trunk/usr
Message-ID: <200611140940.kAE9ej7C019705@sheep.berlios.de>

Author: tomo
Date: 2006-11-14 10:40:44 +0100 (Tue, 14 Nov 2006)
New Revision: 643

Modified:
   trunk/usr/tgtd.c
Log:
Fix lld initialization bugs. ibmvio driver is back now.


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-13 13:37:04 UTC (rev 642)
+++ trunk/usr/tgtd.c	2006-11-14 09:40:44 UTC (rev 643)
@@ -243,10 +243,11 @@
 			err = tgt_drivers[i]->init();
 			if (err)
 				continue;
-			if (tgt_drivers[i]->use_kernel)
-				*use_kernel++;
-			nr++;
 		}
+
+		if (tgt_drivers[i]->use_kernel)
+			(*use_kernel)++;
+		nr++;
 	}
 
 	return nr;



From tomo at mail.berlios.de  Wed Nov 15 00:47:05 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 00:47:05 +0100
Subject: [Stgt-svn] r644 - trunk/usr
Message-ID: <200611142347.kAENl5ZF022469@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 00:47:05 +0100 (Wed, 15 Nov 2006)
New Revision: 644

Modified:
   trunk/usr/tgtadm.c
Log:
revive tgtadm --bus option.

Examples:

tgtadm --lld ibmvio --op bind --mode target --tid 1 --bus vio,30000003

lilac:/sys/bus/vio/devices/30000003# ls
bus  devspec  driver  host1  name  uevent

host1 will be binded to target1.

You can do the following too:

tgtadm --lld ibmvio --op bind --mode target --tid 1 --host 1


We can do something like the following (after adding qla2xxx support):

tgtadm --lld qla2xxx --op bind --tid 1 --bus pci,0000:02:05.0

this goes to /sys/bus/pci/devices/0000:02:05.0

arras:/sys/bus/pci/devices/0000:02:05.0# ls
bus@    device   irq         power/     resource1  subsystem_device
class   driver@  local_cpus  resource   resource3  subsystem_vendor
config  host0/   modalias    resource0  rom        vendor

host0 will be binded to target1.




Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-14 09:40:44 UTC (rev 643)
+++ trunk/usr/tgtadm.c	2006-11-14 23:47:05 UTC (rev 644)
@@ -220,6 +220,42 @@
 	return err;
 }
 
+static int filter(const struct dirent *dir)
+{
+	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
+}
+
+static int bus_to_host(char *bus)
+{
+	int i, nr, host = -1;
+	char path[PATH_MAX], *p;
+	char key[] = "host";
+	struct dirent **namelist;
+
+	p = strchr(bus, ',');
+	if (!p)
+		return -EINVAL;
+	*(p++) = '\0';
+
+	snprintf(path, sizeof(path), "/sys/bus/%s/devices/%s", bus, p);
+	nr = scandir(path, &namelist, filter, alphasort);
+	if (!nr)
+		return -ENOENT;
+
+	for (i = 0; i < nr; i++) {
+		if (strncmp(namelist[i]->d_name, key, strlen(key)))
+			continue;
+		p = namelist[i]->d_name + strlen(key);
+		host = strtoull(p, NULL, 10);
+	}
+
+	for (i = 0; i < nr; i++)
+		free(namelist[i]);
+	free(namelist);
+
+	return host;
+}
+
 static int str_to_mode(char *str)
 {
 	int mode = -1;
@@ -306,6 +342,7 @@
 			hostno = strtol(optarg, NULL, 10);
 			break;
 		case 'b':
+			hostno = bus_to_host(optarg);
 			break;
 		case 'p':
 			params = optarg;



From tomo at mail.berlios.de  Wed Nov 15 03:37:10 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 03:37:10 +0100
Subject: [Stgt-svn] r645 - trunk/usr
Message-ID: <200611150237.kAF2bA11004751@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 03:37:09 +0100 (Wed, 15 Nov 2006)
New Revision: 645

Modified:
   trunk/usr/tgtif.c
Log:
Fix potential race bugs.


Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-11-14 23:47:05 UTC (rev 644)
+++ trunk/usr/tgtif.c	2006-11-15 02:37:09 UTC (rev 645)
@@ -32,6 +32,7 @@
 #include <sys/epoll.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <asm/system.h>
 
 #define aligned_u64 unsigned long long __attribute__((aligned(8)))
 #include <scsi/scsi_tgt_if.h>
@@ -67,12 +68,15 @@
 static int kreq_send(struct tgt_event *p)
 {
 	struct tgt_event *ev;
+
 	ev = head_ring_hdr(&ukring);
 	if (ev->hdr.status)
 		return -ENOMEM;
 
+	ring_index_inc(&ukring);
+
 	memcpy(ev, p, sizeof(*p));
-	ring_index_inc(&ukring);
+	mb();
 	ev->hdr.status = 1;
 
 	write(chrfd, ev, 1);
@@ -84,6 +88,9 @@
 {
 	struct tgt_event ev;
 
+	memset(&ev, 0, sizeof(ev));
+
+	ev.hdr.type = TGT_UEVENT_TSK_MGMT_RSP;
 	ev.p.tsk_mgmt_rsp.host_no = host_no;
 	ev.p.tsk_mgmt_rsp.mid = mid;
 	ev.p.tsk_mgmt_rsp.result = result;
@@ -96,6 +103,8 @@
 {
 	struct tgt_event ev;
 
+	memset(&ev, 0, sizeof(ev));
+
 	ev.hdr.type = TGT_UEVENT_CMD_RSP;
 	ev.p.cmd_rsp.host_no = host_no;
 	ev.p.cmd_rsp.len = len;



From tomo at mail.berlios.de  Wed Nov 15 04:04:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 04:04:43 +0100
Subject: [Stgt-svn] r646 - trunk/usr
Message-ID: <200611150304.kAF34hmS007058@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 04:04:42 +0100 (Wed, 15 Nov 2006)
New Revision: 646

Modified:
   trunk/usr/tgtif.c
Log:
Fix the previous commit.


Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-11-15 02:37:09 UTC (rev 645)
+++ trunk/usr/tgtif.c	2006-11-15 03:04:42 UTC (rev 646)
@@ -32,7 +32,6 @@
 #include <sys/epoll.h>
 #include <sys/mman.h>
 #include <sys/stat.h>
-#include <asm/system.h>
 
 #define aligned_u64 unsigned long long __attribute__((aligned(8)))
 #include <scsi/scsi_tgt_if.h>
@@ -41,6 +40,8 @@
 #include "util.h"
 #include "tgtd.h"
 
+#define barrier() __asm__ __volatile__("": : :"memory")
+
 struct uring {
 	uint32_t idx;
 	char *buf;
@@ -76,9 +77,8 @@
 	ring_index_inc(&ukring);
 
 	memcpy(ev, p, sizeof(*p));
-	mb();
+	barrier();
 	ev->hdr.status = 1;
-
 	write(chrfd, ev, 1);
 
 	return 0;



From tomo at mail.berlios.de  Wed Nov 15 04:38:48 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 04:38:48 +0100
Subject: [Stgt-svn] r647 - trunk/usr
Message-ID: <200611150338.kAF3cmqN009505@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 04:38:48 +0100 (Wed, 15 Nov 2006)
New Revision: 647

Modified:
   trunk/usr/tgtd.c
Log:
Minor cleanup


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-15 03:04:42 UTC (rev 646)
+++ trunk/usr/tgtd.c	2006-11-15 03:38:48 UTC (rev 647)
@@ -57,11 +57,12 @@
 {
 	{"foreground", no_argument, 0, 'f'},
 	{"debug", required_argument, 0, 'd'},
-	{"version", no_argument, 0, 'v'},
 	{"help", no_argument, 0, 'h'},
 	{0, 0, 0, 0},
 };
 
+static char *short_options = "fd:h";
+
 static void usage(int status)
 {
 	if (status)
@@ -269,7 +270,7 @@
 	sigaction(SIGPIPE, &sa_new, &sa_old );
 	sigaction(SIGTERM, &sa_new, &sa_old );
 
-	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
+	while ((ch = getopt_long(argc, argv, short_options, long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'f':



From tomo at mail.berlios.de  Wed Nov 15 09:14:05 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 09:14:05 +0100
Subject: [Stgt-svn] r648 - trunk/usr/iscsi
Message-ID: <200611150814.kAF8E5mH032309@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 09:14:04 +0100 (Wed, 15 Nov 2006)
New Revision: 648

Modified:
   trunk/usr/iscsi/account.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
Log:
Rename struct target struct iscsi_target


Modified: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-11-15 03:38:48 UTC (rev 647)
+++ trunk/usr/iscsi/account.c	2006-11-15 08:14:04 UTC (rev 648)
@@ -141,7 +141,7 @@
 static int iscsi_account_bind(int tid, uint32_t uid)
 {
 	int i, err;
-	struct target* target;
+	struct iscsi_target* target;
 	struct iscsi_account *ac, *tmp;
 	struct ac_node *acn;
 
@@ -208,7 +208,7 @@
 			buffer_check(buf, total, len, rest);
 		}
 	} else {
-		struct target* target;
+		struct iscsi_target* target;
 
 		target = target_find_by_id(tid);
 		if (!target)
@@ -270,7 +270,7 @@
 int iscsi_account_available(int tid, int dir)
 {
 	int err = 0;
-	struct target* target;
+	struct iscsi_target* target;
 	struct ac_node *acn;
 
 	target = target_find_by_id(tid);
@@ -300,7 +300,7 @@
 int iscsi_account_lookup(int tid, int dir, char *user, char *pass)
 {
 	int err = ENOENT;
-	struct target* target;
+	struct iscsi_target* target;
 	struct iscsi_account *ac;
 	struct ac_node *acn;
 

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-15 03:38:48 UTC (rev 647)
+++ trunk/usr/iscsi/iscsid.c	2006-11-15 08:14:04 UTC (rev 648)
@@ -313,7 +313,7 @@
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	char *name, *alias, *session_type, *target_name;
-	struct target *target;
+	struct iscsi_target *target;
 
 	conn->cid = be16_to_cpu(req->cid);
 	memcpy(conn->isid, req->isid, sizeof(req->isid));

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-15 03:38:48 UTC (rev 647)
+++ trunk/usr/iscsi/iscsid.h	2006-11-15 08:14:04 UTC (rev 648)
@@ -64,7 +64,7 @@
 	struct list_head hlist;
 
 	char *initiator;
-	struct target *target;
+	struct iscsi_target *target;
 	uint8_t isid[6];
 	uint16_t tsih;
 
@@ -206,7 +206,7 @@
 
 #define INCOMING_BUFSIZE	8192
 
-struct target {
+struct iscsi_target {
 	struct list_head tlist;
 
 	struct list_head sessions_list;
@@ -264,8 +264,8 @@
 extern void session_put(struct session *session);
 
 /* target.c */
-struct target * target_find_by_name(const char *name);
-struct target * target_find_by_id(int tid);
+struct iscsi_target * target_find_by_name(const char *name);
+struct iscsi_target * target_find_by_id(int tid);
 extern void target_list_build(struct connection *, char *, char *);
 
 /* param.c */

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-11-15 03:38:48 UTC (rev 647)
+++ trunk/usr/iscsi/session.c	2006-11-15 08:14:04 UTC (rev 648)
@@ -22,7 +22,7 @@
 struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
-	struct target *target;
+	struct iscsi_target *target;
 
 	if (!(target = target_find_by_id(tid)))
 		return NULL;
@@ -52,7 +52,7 @@
 {
 	struct session *session = NULL;
 	static uint16_t tsih, last_tsih = 0;
-	struct target *target;
+	struct iscsi_target *target;
 
 	target = target_find_by_id(conn->tid);
 	if (!target)

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-15 03:38:48 UTC (rev 647)
+++ trunk/usr/iscsi/target.c	2006-11-15 08:14:04 UTC (rev 648)
@@ -22,7 +22,7 @@
 
 void target_list_build(struct connection *conn, char *addr, char *name)
 {
-	struct target *target;
+	struct iscsi_target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
 		if (name && strcmp(target->name, name))
@@ -35,9 +35,9 @@
 	}
 }
 
-struct target *target_find_by_name(const char *name)
+struct iscsi_target *target_find_by_name(const char *name)
 {
-	struct target *target;
+	struct iscsi_target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
 		if (!strcmp(target->name, name))
@@ -47,9 +47,9 @@
 	return NULL;
 }
 
-struct target* target_find_by_id(int tid)
+struct iscsi_target* target_find_by_id(int tid)
 {
-	struct target *target;
+	struct iscsi_target *target;
 
 	list_for_each_entry(target, &targets_list, tlist) {
 		if (target->tid == tid)
@@ -61,7 +61,7 @@
 
 int iscsi_target_destroy(int tid)
 {
-	struct target* target;
+	struct iscsi_target* target;
 
 	if (!(target = target_find_by_id(tid)))
 		return -ENOENT;
@@ -83,7 +83,7 @@
 
 int iscsi_target_create(int tid, char *name)
 {
-	struct target *target;
+	struct iscsi_target *target;
 	struct param default_tgt_session_param[] = {
 		{0, 8192},
 		{0, 8192},
@@ -134,7 +134,7 @@
 	int idx, err;
 	unsigned int val;
 	char *str;
-	struct target* target;
+	struct iscsi_target* target;
 
 	target = target_find_by_id(tid);
 	if (!target)
@@ -176,7 +176,7 @@
 	return total;
 }
 
-static int iscsi_target_show_connection(struct target* target, uint64_t sid,
+static int iscsi_target_show_connection(struct iscsi_target* target, uint64_t sid,
 					uint32_t cid, char *buf, int rest)
 {
 	int len, total = 0;
@@ -212,7 +212,7 @@
 	return total;
 }
 
-static int iscsi_target_show_session(struct target* target, uint64_t sid,
+static int iscsi_target_show_session(struct iscsi_target* target, uint64_t sid,
 				     char *buf, int rest)
 {
 	int len, total = 0;
@@ -236,7 +236,7 @@
 int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid, uint64_t lun,
 		      char *buf, int rest)
 {
-	struct target* target;
+	struct iscsi_target* target;
 	int len, total = 0;
 
 	target = target_find_by_id(tid);



From tomo at mail.berlios.de  Wed Nov 15 12:37:02 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 15 Nov 2006 12:37:02 +0100
Subject: [Stgt-svn] r649 - trunk/usr
Message-ID: <200611151137.kAFBb2J5003201@sheep.berlios.de>

Author: tomo
Date: 2006-11-15 12:37:01 +0100 (Wed, 15 Nov 2006)
New Revision: 649

Modified:
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/target.c
Log:
Move close(fd) from tgt_device_destroy to bd_*_close for symmetry


Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-15 08:14:04 UTC (rev 648)
+++ trunk/usr/bd_aio.c	2006-11-15 11:37:01 UTC (rev 649)
@@ -85,6 +85,7 @@
 	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
 
 	tgt_event_del(bai->fd);
+	close(bai->fd);
 	free(dev);
 }
 

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-11-15 08:14:04 UTC (rev 648)
+++ trunk/usr/bd_mmap.c	2006-11-15 11:37:01 UTC (rev 649)
@@ -51,6 +51,7 @@
 
 static void bd_mmap_close(struct tgt_device *dev)
 {
+	close(dev->fd);
 	free(dev);
 }
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-15 08:14:04 UTC (rev 648)
+++ trunk/usr/target.c	2006-11-15 11:37:01 UTC (rev 649)
@@ -200,7 +200,6 @@
 		return -EBUSY;
 
 	free(device->path);
-	close(device->fd);
 	device_hlist_remove(device);
 	device_list_remove(device);
 



From tomo at mail.berlios.de  Thu Nov 16 14:53:37 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 16 Nov 2006 14:53:37 +0100
Subject: [Stgt-svn] r650 - trunk/usr
Message-ID: <200611161353.kAGDrbOj013701@sheep.berlios.de>

Author: tomo
Date: 2006-11-16 14:53:37 +0100 (Thu, 16 Nov 2006)
New Revision: 650

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
   trunk/usr/util.c
Log:
Add target_state operation, however, LLDs does not use it yet.

lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op show --mode target
tid 2: lld name iscsi: state suspended
        lun 0: path /dev/hdc2
tid 1: lld name iscsi: state suspended
        lun 1: path /var/tmp/image
        lun 0: path /dev/hdc1
lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op update --mode target --name state --value running --tid 1
lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op show --mode target
tid 2: lld name iscsi: state suspended
        lun 0: path /dev/hdc2
tid 1: lld name iscsi: state running
        lun 1: path /var/tmp/image
        lun 0: path /dev/hdc1



Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-15 11:37:01 UTC (rev 649)
+++ trunk/usr/mgmt.c	2006-11-16 13:53:37 UTC (rev 650)
@@ -73,7 +73,10 @@
 		break;
 	case OP_UPDATE:
 		err = -EINVAL;
-		if (tgt_drivers[lld_no]->target_update)
+		if (!strcmp(params, "state"))
+			err = tgt_set_target_state(req->tid,
+						   params + strlen(params) + 1);
+		else if (tgt_drivers[lld_no]->target_update)
 			err = tgt_drivers[lld_no]->target_update(req->tid, params);
 		break;
 	default:
@@ -153,11 +156,11 @@
 						  len - sizeof(*res));
 		else {
 			if (tgt_drivers[lld_no]->show)
-			err = tgt_drivers[lld_no]->show(req->mode,
-							req->tid, req->sid,
-							req->cid, req->lun,
-							(char *)res->data,
-							len - sizeof(*res));
+				err = tgt_drivers[lld_no]->show(req->mode,
+								req->tid, req->sid,
+								req->cid, req->lun,
+								(char *)res->data,
+								len - sizeof(*res));
 		}
 
 		set_show_results(res, err);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-15 11:37:01 UTC (rev 649)
+++ trunk/usr/target.c	2006-11-16 13:53:37 UTC (rev 650)
@@ -589,6 +589,8 @@
 	for (i = 0; i < ARRAY_SIZE(target->device_hash_list); i++)
 		INIT_LIST_HEAD(&target->device_hash_list[i]);
 
+	target->target_state = SCSI_TARGET_SUSPENDED;
+
 	tgt_cmd_queue_init(&target->cmd_queue);
 	target_hlist_insert(target);
 
@@ -619,6 +621,58 @@
 	return 0;
 }
 
+enum scsi_target_state tgt_get_target_state(int tid)
+{
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+	return target->target_state;
+}
+
+static struct {
+	enum scsi_target_state value;
+	char *name;
+} target_state[] = {
+	{SCSI_TARGET_SUSPENDED, "suspended"},
+	{SCSI_TARGET_RUNNING, "running"},
+};
+
+static char *target_state_state_name(enum scsi_target_state state)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(target_state); i++) {
+		if (target_state[i].value == state) {
+			name = target_state[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
+int tgt_set_target_state(int tid, char *str)
+{
+	int i, err = -EINVAL;
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	for (i = 0; i < ARRAY_SIZE(target_state); i++) {
+		if (!strcmp(target_state[i].name, str)) {
+			target->target_state = target_state[i].value;
+			err = 0;
+			break;
+		}
+	}
+
+	return err;
+}
+
 int tgt_target_show_all(char *buf, int rest)
 {
 	int i, len, total;
@@ -627,8 +681,9 @@
 
 	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "tid %d: lld name %s\n",
-				       target->tid, tgt_drivers[target->lid]->name);
+			len = snprintf(buf, rest, "tid %d: lld name %s: state %s\n",
+				       target->tid, tgt_drivers[target->lid]->name,
+				       target_state_state_name(target->target_state));
 			buf += len;
 			total += len;
 			rest -= len;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-11-15 11:37:01 UTC (rev 649)
+++ trunk/usr/target.h	2006-11-16 13:53:37 UTC (rev 650)
@@ -24,6 +24,8 @@
 	int tid;
 	int lid;
 
+	enum scsi_target_state target_state;
+
 	struct list_head t_hlist;
 
 	struct list_head device_hash_list[1 << HASH_ORDER];

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-15 11:37:01 UTC (rev 649)
+++ trunk/usr/tgtd.h	2006-11-16 13:53:37 UTC (rev 650)
@@ -5,6 +5,11 @@
 
 #define	SCSI_ID_LEN	24
 
+enum scsi_target_state {
+	SCSI_TARGET_SUSPENDED = 1,
+	SCSI_TARGET_RUNNING,
+};
+
 struct tgt_cmd_queue {
 	int active_cmd;
 	unsigned long state;
@@ -74,4 +79,7 @@
 extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq);
 
+extern enum scsi_target_state tgt_get_target_state(int tid);
+extern int tgt_set_target_state(int tid, char *str);
+
 #endif

Modified: trunk/usr/util.c
===================================================================
--- trunk/usr/util.c	2006-11-15 11:37:01 UTC (rev 649)
+++ trunk/usr/util.c	2006-11-16 13:53:37 UTC (rev 650)
@@ -96,3 +96,4 @@
 	close(fd);
 	return err;
 }
+



From tomo at mail.berlios.de  Fri Nov 17 02:49:00 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 02:49:00 +0100
Subject: [Stgt-svn] r651 - trunk/usr/iscsi
Message-ID: <200611170149.kAH1n0J8014861@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 02:48:59 +0100 (Fri, 17 Nov 2006)
New Revision: 651

Modified:
   trunk/usr/iscsi/iscsid.c
Log:
login_start to check the target state.


Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-16 13:53:37 UTC (rev 650)
+++ trunk/usr/iscsi/iscsid.c	2006-11-17 01:48:59 UTC (rev 651)
@@ -372,6 +372,13 @@
 		}
 		conn->tid = target->tid;
 
+		if (tgt_get_target_state(target->tid) != SCSI_TARGET_RUNNING) {
+			rsp->status_class = ISCSI_STATUS_CLS_TARGET_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_TARGET_ERROR;
+			conn->state = STATE_EXIT;
+			return;
+		}
+
 /* 		if (conn->target->max_sessions && */
 /* 		    (++conn->target->session_cnt > conn->target->max_sessions)) { */
 /* 			conn->target->session_cnt--; */



From tomo at mail.berlios.de  Fri Nov 17 02:49:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 02:49:25 +0100
Subject: [Stgt-svn] r652 - trunk/doc
Message-ID: <200611170149.kAH1nPei014894@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 02:49:25 +0100 (Fri, 17 Nov 2006)
New Revision: 652

Modified:
   trunk/doc/README.iscsi
Log:
Update iSCSI doc.

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-17 01:48:59 UTC (rev 651)
+++ trunk/doc/README.iscsi	2006-11-17 01:49:25 UTC (rev 652)
@@ -1,5 +1,16 @@
-Starting
+Preface
 -------------
+This document describes how to configure the iSCSI target driver with tgtadm.
+
+tgtadm is not so handly; you can need several commands to do one thing
+mainly because it must be generic to work for all the transport protocols.
+
+We plan to implement a frontend tool, iscsitgtadm, to wrap tgtadm and
+offer considerably more user friendly interface in the future.
+
+
+Starting the daemon
+-------------
 Try the following commands:
 
 host:~/tgt$ su
@@ -24,19 +35,23 @@
 You can get the current configuration:
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi
+tid 1: lld name iscsi: state suspended
         lun 0: path /dev/hdc1
 
 
+If you don't need no more configuration (iSCSI parameters, security,
+etc), you are ready to accept initiators. In this case, you can go to
+`accepting initiators` session.
+
+
 You can add lots of logical units:
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 --params Path=/var/tmp/image
 host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
-tid 1: lld name iscsi
+tid 1: lld name iscsi: state suspended
         lun 1: path /var/tmp/image
         lun 0: path /dev/hdc1
 
-Now this target is ready to accept initiators.
 
 You can get iSCSI parameters of the target:
 
@@ -171,6 +186,30 @@
 accounts. We don't support removing or unbinding accounts now.
 
 
+Accepting initiators
+-------------
+Now this target is ready to accept initiators. Make sure what you have
+now once again:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+tid 1: lld name iscsi: state suspended
+        lun 1: path /var/tmp/image
+        lun 0: path /dev/hdc1
+
+
+If you are happy about it:
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+tid 1: lld name iscsi: state running
+        lun 1: path /var/tmp/image
+        lun 0: path /dev/hdc1
+
+
+Now your target accepts initiators.
+
+
 Shutdown
 -------------
 host:~/tgt# killall -9 tgtd



From tomo at mail.berlios.de  Fri Nov 17 03:25:07 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 03:25:07 +0100
Subject: [Stgt-svn] r653 - trunk/usr/iscsi
Message-ID: <200611170225.kAH2P7nh017498@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 03:25:05 +0100 (Fri, 17 Nov 2006)
New Revision: 653

Modified:
   trunk/usr/iscsi/iscsid.h
Log:
Rename struct PDU iscsi_pdu.

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-17 01:49:25 UTC (rev 652)
+++ trunk/usr/iscsi/iscsid.h	2006-11-17 02:25:05 UTC (rev 653)
@@ -42,7 +42,7 @@
 
 #define sid_to_tsih(sid) ((sid) >> 48)
 
-struct PDU {
+struct iscsi_pdu {
 	struct iscsi_hdr bhs;
 	void *ahs;
 	unsigned int ahssize;
@@ -140,9 +140,9 @@
 	uint32_t exp_cmd_sn;
 	uint32_t max_cmd_sn;
 
-	struct PDU req;
+	struct iscsi_pdu req;
 	void *req_buffer;
-	struct PDU rsp;
+	struct iscsi_pdu rsp;
 	void *rsp_buffer;
 	unsigned char *rx_buffer;
 	unsigned char *tx_buffer;



From tomo at mail.berlios.de  Fri Nov 17 03:34:16 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 03:34:16 +0100
Subject: [Stgt-svn] r654 - trunk/usr/iscsi
Message-ID: <200611170234.kAH2YGvI018351@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 03:34:15 +0100 (Fri, 17 Nov 2006)
New Revision: 654

Modified:
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
Log:
Rename struct session iscsi_session.

Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-11-17 02:25:05 UTC (rev 653)
+++ trunk/usr/iscsi/conn.c	2006-11-17 02:34:15 UTC (rev 654)
@@ -16,7 +16,7 @@
 #include "tgtd.h"
 #include "util.h"
 
-void conn_add_to_session(struct connection *conn, struct session *session)
+void conn_add_to_session(struct connection *conn, struct iscsi_session *session)
 {
 	if (!list_empty(&conn->clist)) {
 		eprintf("%" PRIx64 " %u\n",
@@ -62,7 +62,7 @@
 
 static void conn_free(struct connection *conn)
 {
-	struct session *session = conn->session;
+	struct iscsi_session *session = conn->session;
 
 	dprintf("freeing connection\n");
 	list_del(&conn->clist);
@@ -142,7 +142,7 @@
 	return 0;
 }
 
-struct connection *conn_find(struct session *session, uint32_t cid)
+struct connection *conn_find(struct iscsi_session *session, uint32_t cid)
 {
 	struct connection *conn;
 

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-17 02:25:05 UTC (rev 653)
+++ trunk/usr/iscsi/iscsid.c	2006-11-17 02:34:15 UTC (rev 654)
@@ -170,7 +170,7 @@
 {
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
-	struct session *session;
+	struct iscsi_session *session;
 
 	if (!conn->tid)
 		return;
@@ -874,7 +874,7 @@
 int iscsi_scsi_cmd_done(int host_no, int len, int result, int rw, uint64_t addr,
 			uint64_t tag)
 {
-	struct session *session;
+	struct iscsi_session *session;
 	struct iscsi_task *task;
 
 	dprintf("%u %d %d %d %" PRIx64 " %" PRIx64 "\n", host_no, len, result,
@@ -1116,7 +1116,7 @@
 
 static int iscsi_task_queue(struct iscsi_task *task)
 {
-	struct session *session = task->conn->session;
+	struct iscsi_session *session = task->conn->session;
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &task->req;
 	uint32_t cmd_sn;
 	struct iscsi_task *ent;

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-17 02:25:05 UTC (rev 653)
+++ trunk/usr/iscsi/iscsid.h	2006-11-17 02:34:15 UTC (rev 654)
@@ -54,7 +54,7 @@
 #define KEY_STATE_REQUEST	1
 #define KEY_STATE_DONE		2
 
-struct session {
+struct iscsi_session {
 	int refcount;
 
 	/* linked to target->sessions_list */
@@ -121,7 +121,7 @@
 	int refcount;
 
 	struct list_head clist;
-	struct session *session;
+	struct iscsi_session *session;
 
 	int tid;
 	struct param session_param[ISCSI_PARAM_MAX];
@@ -241,11 +241,11 @@
 extern void conn_close(struct connection *conn, int fd);
 extern void conn_put(struct connection *conn);
 extern int conn_get(struct connection *conn);
-extern struct connection * conn_find(struct session *session, uint32_t cid);
+extern struct connection * conn_find(struct iscsi_session *session, uint32_t cid);
 extern int conn_take_fd(struct connection *conn, int fd);
 extern void conn_read_pdu(struct connection *conn);
 extern void conn_write_pdu(struct connection *conn);
-extern void conn_add_to_session(struct connection *conn, struct session *session);
+extern void conn_add_to_session(struct connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern void iscsi_event_handler(int fd, int events, void *data);
@@ -256,12 +256,12 @@
 extern void iscsi_free_task(struct iscsi_task *task);
 
 /* session.c */
-extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
+extern struct iscsi_session *session_find_name(int tid, const char *iname, uint8_t *isid);
 extern int session_create(struct connection *conn);
-extern void session_destroy(struct session *session);
-extern struct session *session_lookup(uint16_t tsih);
-extern void session_get(struct session *session);
-extern void session_put(struct session *session);
+extern void session_destroy(struct iscsi_session *session);
+extern struct iscsi_session *session_lookup(uint16_t tsih);
+extern void session_get(struct iscsi_session *session);
+extern void session_put(struct iscsi_session *session);
 
 /* target.c */
 struct iscsi_target * target_find_by_name(const char *name);

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-11-17 02:25:05 UTC (rev 653)
+++ trunk/usr/iscsi/session.c	2006-11-17 02:34:15 UTC (rev 654)
@@ -19,9 +19,9 @@
 
 static LIST_HEAD(sessions_list);
 
-struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
+struct iscsi_session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
-	struct session *session;
+	struct iscsi_session *session;
 	struct iscsi_target *target;
 
 	if (!(target = target_find_by_id(tid)))
@@ -38,9 +38,9 @@
 	return NULL;
 }
 
-struct session *session_lookup(uint16_t tsih)
+struct iscsi_session *session_lookup(uint16_t tsih)
 {
-	struct session *session;
+	struct iscsi_session *session;
 	list_for_each_entry(session, &sessions_list, hlist) {
 		if (session->tsih == tsih)
 			return session;
@@ -50,7 +50,7 @@
 
 int session_create(struct connection *conn)
 {
-	struct session *session = NULL;
+	struct iscsi_session *session = NULL;
 	static uint16_t tsih, last_tsih = 0;
 	struct iscsi_target *target;
 
@@ -102,7 +102,7 @@
 	return 0;
 }
 
-void session_destroy(struct session *session)
+void session_destroy(struct iscsi_session *session)
 {
 	eprintf("%d\n", session->tsih);
 
@@ -122,12 +122,12 @@
 	free(session);
 }
 
-void session_get(struct session *session)
+void session_get(struct iscsi_session *session)
 {
 	session->refcount++;
 }
 
-void session_put(struct session *session)
+void session_put(struct iscsi_session *session)
 {
 	session->refcount--;
 	if (session->refcount == 0)

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-17 02:25:05 UTC (rev 653)
+++ trunk/usr/iscsi/target.c	2006-11-17 02:34:15 UTC (rev 654)
@@ -180,7 +180,7 @@
 					uint32_t cid, char *buf, int rest)
 {
 	int len, total = 0;
-	struct session *session;
+	struct iscsi_session *session;
 	struct connection *conn;
 
 	session = session_lookup(sid_to_tsih(sid));
@@ -216,7 +216,7 @@
 				     char *buf, int rest)
 {
 	int len, total = 0;
-	struct session *session;
+	struct iscsi_session *session;
 
 	list_for_each_entry(session, &target->sessions_list, slist) {
 		if (sid64(session->isid, session->tsih) == sid || !sid) {



From tomo at mail.berlios.de  Fri Nov 17 03:42:53 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 03:42:53 +0100
Subject: [Stgt-svn] r655 - trunk/usr/iscsi
Message-ID: <200611170242.kAH2grbr018868@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 03:42:53 +0100 (Fri, 17 Nov 2006)
New Revision: 655

Modified:
   trunk/usr/iscsi/chap.c
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsi_tcp.c
   trunk/usr/iscsi/iscsid.c
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
Log:
Rename struct connection iscsi_connection


Modified: trunk/usr/iscsi/chap.c
===================================================================
--- trunk/usr/iscsi/chap.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/chap.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -319,7 +319,7 @@
 	SHA1_Final(digest, &ctx);
 }
 
-static int chap_initiator_auth_create_challenge(struct connection *conn)
+static int chap_initiator_auth_create_challenge(struct iscsi_connection *conn)
 {
 	char *value, *p;
 	char text[CHAP_CHALLENGE_MAX * 2 + 8];
@@ -372,7 +372,7 @@
 	return 0;
 }
 
-static int chap_initiator_auth_check_response(struct connection *conn)
+static int chap_initiator_auth_check_response(struct iscsi_connection *conn)
 {
 	char *value;
 	uint8_t *his_digest = NULL, *our_digest = NULL;
@@ -473,7 +473,7 @@
 	return retval;
 }
 
-static int chap_target_auth_create_response(struct connection *conn)
+static int chap_target_auth_create_response(struct iscsi_connection *conn)
 {
 	char chap_id, *value, *response = NULL;
 	uint8_t *challenge = NULL, *digest = NULL;
@@ -603,7 +603,7 @@
 	return retval;
 }
 
-int cmnd_exec_auth_chap(struct connection *conn)
+int cmnd_exec_auth_chap(struct iscsi_connection *conn)
 {
 	int res;
 

Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/conn.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -16,7 +16,7 @@
 #include "tgtd.h"
 #include "util.h"
 
-void conn_add_to_session(struct connection *conn, struct iscsi_session *session)
+void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session)
 {
 	if (!list_empty(&conn->clist)) {
 		eprintf("%" PRIx64 " %u\n",
@@ -30,9 +30,9 @@
 	list_add(&conn->clist, &session->conn_list);
 }
 
-struct connection *conn_alloc(void)
+struct iscsi_connection *conn_alloc(void)
 {
-	struct connection *conn;
+	struct iscsi_connection *conn;
 
 	conn = zalloc(sizeof(*conn));
 	if (!conn)
@@ -60,7 +60,7 @@
 	return conn;
 }
 
-static void conn_free(struct connection *conn)
+static void conn_free(struct iscsi_connection *conn)
 {
 	struct iscsi_session *session = conn->session;
 
@@ -75,7 +75,7 @@
 		session_put(session);
 }
 
-void conn_close(struct connection *conn, int fd)
+void conn_close(struct iscsi_connection *conn, int fd)
 {
 	struct iscsi_task *task, *tmp;
 
@@ -128,23 +128,23 @@
 	conn_put(conn);
 }
 
-void conn_put(struct connection *conn)
+void conn_put(struct iscsi_connection *conn)
 {
 	conn->refcount--;
 	if (conn->refcount == 0)
 		conn_free(conn);
 }
 
-int conn_get(struct connection *conn)
+int conn_get(struct iscsi_connection *conn)
 {
 	/* TODO: check state */
 	conn->refcount++;
 	return 0;
 }
 
-struct connection *conn_find(struct iscsi_session *session, uint32_t cid)
+struct iscsi_connection *conn_find(struct iscsi_session *session, uint32_t cid)
 {
-	struct connection *conn;
+	struct iscsi_connection *conn;
 
 	list_for_each_entry(conn, &session->conn_list, clist) {
 		if (conn->cid == cid)
@@ -154,7 +154,7 @@
 	return NULL;
 }
 
-int conn_take_fd(struct connection *conn, int fd)
+int conn_take_fd(struct iscsi_connection *conn, int fd)
 {
 	uint64_t sid = sid64(conn->isid, conn->tsih);
 
@@ -167,14 +167,14 @@
 	return tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
 }
 
-void conn_read_pdu(struct connection *conn)
+void conn_read_pdu(struct iscsi_connection *conn)
 {
 	conn->rx_iostate = IOSTATE_READ_BHS;
 	conn->rx_buffer = (void *)&conn->req.bhs;
 	conn->rx_size = BHS_SIZE;
 }
 
-void conn_write_pdu(struct connection *conn)
+void conn_write_pdu(struct iscsi_connection *conn)
 {
 	conn->tx_iostate = IOSTATE_WRITE_BHS;
 	memset(&conn->rsp, 0, sizeof(conn->rsp));

Modified: trunk/usr/iscsi/iscsi_tcp.c
===================================================================
--- trunk/usr/iscsi/iscsi_tcp.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/iscsi_tcp.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -58,7 +58,7 @@
 {
 	struct sockaddr_storage from;
 	socklen_t namesize;
-	struct connection *conn;
+	struct iscsi_connection *conn;
 	int fd, err;
 
 	eprintf("%d\n", afd);

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/iscsid.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -34,7 +34,7 @@
 	{NULL, 0, 0, 0, NULL},
 };
 
-char *text_key_find(struct connection *conn, char *searchKey)
+char *text_key_find(struct iscsi_connection *conn, char *searchKey)
 {
 	char *data, *key, *value;
 	int keylen, datasize;
@@ -91,7 +91,7 @@
 	return key;
 }
 
-void text_key_add(struct connection *conn, char *key, char *value)
+void text_key_add(struct iscsi_connection *conn, char *key, char *value)
 {
 	int keylen = strlen(key);
 	int valuelen = strlen(value);
@@ -116,12 +116,12 @@
 	strcpy(buffer, value);
 }
 
-static void text_key_add_reject(struct connection *conn, char *key)
+static void text_key_add_reject(struct iscsi_connection *conn, char *key)
 {
 	text_key_add(conn, key, "Reject");
 }
 
-static void text_scan_security(struct connection *conn)
+static void text_scan_security(struct iscsi_connection *conn)
 {
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 	char *key, *value, *data, *nextValue;
@@ -166,7 +166,7 @@
 	}
 }
 
-static void login_security_done(struct connection *conn)
+static void login_security_done(struct iscsi_connection *conn)
 {
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
@@ -208,7 +208,7 @@
 	}
 }
 
-static void text_scan_login(struct connection *conn)
+static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
 	int datasize, idx;
@@ -280,7 +280,7 @@
 	return;
 }
 
-static int text_check_param(struct connection *conn)
+static int text_check_param(struct iscsi_connection *conn)
 {
 	struct param *p = conn->session_param;
 	char buf[32];
@@ -308,7 +308,7 @@
 	return cnt;
 }
 
-static void login_start(struct connection *conn)
+static void login_start(struct iscsi_connection *conn)
 {
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
@@ -397,7 +397,7 @@
 	text_key_add(conn, "TargetPortalGroupTag", "1");
 }
 
-static void login_finish(struct connection *conn)
+static void login_finish(struct iscsi_connection *conn)
 {
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
@@ -413,7 +413,7 @@
 	}
 }
 
-static int cmnd_exec_auth(struct connection *conn)
+static int cmnd_exec_auth(struct iscsi_connection *conn)
 {
        int res;
 
@@ -432,7 +432,7 @@
         return res;
 }
 
-static void cmnd_exec_login(struct connection *conn)
+static void cmnd_exec_login(struct iscsi_connection *conn)
 {
 	struct iscsi_login *req = (struct iscsi_login *)&conn->req.bhs;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
@@ -595,7 +595,7 @@
 	return;
 }
 
-static void text_scan_text(struct connection *conn)
+static void text_scan_text(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
 	int datasize;
@@ -639,7 +639,7 @@
 	}
 }
 
-static void cmnd_exec_text(struct connection *conn)
+static void cmnd_exec_text(struct iscsi_connection *conn)
 {
 	struct iscsi_text *req = (struct iscsi_text *)&conn->req.bhs;
 	struct iscsi_text_rsp *rsp = (struct iscsi_text_rsp *)&conn->rsp.bhs;
@@ -668,7 +668,7 @@
 	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 }
 
-static void cmnd_exec_logout(struct connection *conn)
+static void cmnd_exec_logout(struct iscsi_connection *conn)
 {
 	struct iscsi_logout *req = (struct iscsi_logout *)&conn->req.bhs;
 	struct iscsi_logout_rsp *rsp = (struct iscsi_logout_rsp *)&conn->rsp.bhs;
@@ -686,7 +686,7 @@
 	rsp->max_cmdsn = cpu_to_be32(conn->max_cmd_sn);
 }
 
-static int cmnd_execute(struct connection *conn)
+static int cmnd_execute(struct iscsi_connection *conn)
 {
 	int res = 0;
 
@@ -715,7 +715,7 @@
 	return res;
 }
 
-static void cmnd_finish(struct connection *conn)
+static void cmnd_finish(struct iscsi_connection *conn)
 {
 	switch (conn->state) {
 	case STATE_EXIT:
@@ -737,7 +737,7 @@
 
 static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 
 	memset(rsp, 0, sizeof(*rsp));
@@ -755,7 +755,7 @@
 
 static int iscsi_data_rsp_build(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	int residual, datalen, exp_datalen = ntohl(req->data_length);
@@ -807,7 +807,7 @@
 
 static int iscsi_r2t_build(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
 	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
@@ -828,7 +828,7 @@
 }
 
 static inline struct iscsi_task *
-iscsi_alloc_task(struct connection *conn)
+iscsi_alloc_task(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
@@ -848,7 +848,7 @@
 
 void iscsi_free_task(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 
 	if (task->c_buffer)
 		free(task->c_buffer);
@@ -860,7 +860,7 @@
 
 static void iscsi_free_cmd_task(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 
 	target_cmd_done(conn->session->tsih, task->tag);
 	list_del(&task->c_hlist);
@@ -937,7 +937,7 @@
 
 static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	unsigned long uaddr = (unsigned long) task->c_buffer;
 	int err = 0;
@@ -992,7 +992,7 @@
 
 static int iscsi_tm_execute(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_tm *req = (struct iscsi_tm *) &task->req;
 	int fn, err = 0;
 
@@ -1085,7 +1085,7 @@
 	return err;
 }
 
-static int iscsi_data_out_rx_start(struct connection *conn)
+static int iscsi_data_out_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task;
 	struct iscsi_data *req = (struct iscsi_data *) &conn->req.bhs;
@@ -1166,7 +1166,7 @@
 	return 0;
 }
 
-static struct iscsi_task *__iscsi_task_rx_start(struct connection *conn)
+static struct iscsi_task *__iscsi_task_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task;
 
@@ -1177,7 +1177,7 @@
 	return task;
 }
 
-static int iscsi_scsi_cmd_rx_start(struct connection *conn)
+static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
@@ -1217,7 +1217,7 @@
 	return 0;
 }
 
-static int iscsi_noop_out_rx_start(struct connection *conn)
+static int iscsi_noop_out_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
@@ -1264,7 +1264,7 @@
 	return err;
 }
 
-static int iscsi_task_rx_done(struct connection *conn)
+static int iscsi_task_rx_done(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	struct iscsi_task *task = conn->rx_task;
@@ -1293,7 +1293,7 @@
 	return err;
 }
 
-static int iscsi_task_rx_start(struct connection *conn)
+static int iscsi_task_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->req.bhs;
 	uint8_t op;
@@ -1356,7 +1356,7 @@
 
 static int iscsi_logout_tx_start(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_logout_rsp *rsp =
 		(struct iscsi_logout_rsp *) &conn->rsp.bhs;
 
@@ -1372,7 +1372,7 @@
 
 static int iscsi_noop_out_tx_start(struct iscsi_task *task, int *is_rsp)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
 
 	if (task->req.itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
@@ -1401,7 +1401,7 @@
 
 static int iscsi_tm_tx_start(struct iscsi_task *task)
 {
-	struct connection *conn = task->conn;
+	struct iscsi_connection *conn = task->conn;
 	struct iscsi_tm_rsp *rsp = (struct iscsi_tm_rsp *) &conn->rsp.bhs;
 
 	memset(rsp, 0, sizeof(*rsp));
@@ -1417,7 +1417,7 @@
 	return 0;
 }
 
-static int iscsi_scsi_cmd_tx_done(struct connection *conn)
+static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
 	struct iscsi_task *task = conn->tx_task;
@@ -1441,7 +1441,7 @@
 	return 0;
 }
 
-static int iscsi_task_tx_done(struct connection *conn)
+static int iscsi_task_tx_done(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task = conn->tx_task;
 	int err;
@@ -1460,7 +1460,7 @@
 	return 0;
 }
 
-static int iscsi_task_tx_start(struct connection *conn)
+static int iscsi_task_tx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task;
 	int is_rsp, err = 0;
@@ -1504,7 +1504,7 @@
 	return -EAGAIN;
 }
 
-static void iscsi_rx_handler(int fd, struct connection *conn)
+static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
 	int res;
 
@@ -1576,7 +1576,7 @@
 	}
 }
 
-static void iscsi_tx_handler(int fd, struct connection *conn)
+static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
 	int res;
 
@@ -1670,7 +1670,7 @@
 
 void iscsi_event_handler(int fd, int events, void *data)
 {
-	struct connection *conn = (struct connection *) data;
+	struct iscsi_connection *conn = (struct iscsi_connection *) data;
 
 	if (events & EPOLLIN)
 		iscsi_rx_handler(fd, conn);

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/iscsid.h	2006-11-17 02:42:53 UTC (rev 655)
@@ -88,7 +88,7 @@
 	struct iscsi_hdr rsp;
 
 	uint64_t tag;
-	struct connection *conn;
+	struct iscsi_connection *conn;
 
 	/* linked to session->cmd_list */
 	struct list_head c_hlist;
@@ -113,7 +113,7 @@
 	void *c_buffer;
 };
 
-struct connection {
+struct iscsi_connection {
 	int state;
 	int rx_iostate;
 	int tx_iostate;
@@ -234,30 +234,30 @@
 #define task_pending(t)		((t)->flags & (1 << TASK_pending))
 
 /* chap.c */
-extern int cmnd_exec_auth_chap(struct connection *conn);
+extern int cmnd_exec_auth_chap(struct iscsi_connection *conn);
 
 /* conn.c */
-extern struct connection *conn_alloc(void);
-extern void conn_close(struct connection *conn, int fd);
-extern void conn_put(struct connection *conn);
-extern int conn_get(struct connection *conn);
-extern struct connection * conn_find(struct iscsi_session *session, uint32_t cid);
-extern int conn_take_fd(struct connection *conn, int fd);
-extern void conn_read_pdu(struct connection *conn);
-extern void conn_write_pdu(struct connection *conn);
-extern void conn_add_to_session(struct connection *conn, struct iscsi_session *session);
+extern struct iscsi_connection *conn_alloc(void);
+extern void conn_close(struct iscsi_connection *conn, int fd);
+extern void conn_put(struct iscsi_connection *conn);
+extern int conn_get(struct iscsi_connection *conn);
+extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
+extern int conn_take_fd(struct iscsi_connection *conn, int fd);
+extern void conn_read_pdu(struct iscsi_connection *conn);
+extern void conn_write_pdu(struct iscsi_connection *conn);
+extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern void iscsi_event_handler(int fd, int events, void *data);
-extern char *text_key_find(struct connection *conn, char *searchKey);
-extern void text_key_add(struct connection *conn, char *key, char *value);
+extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
+extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);
 
 /* session.c */
 extern struct iscsi_session *session_find_name(int tid, const char *iname, uint8_t *isid);
-extern int session_create(struct connection *conn);
+extern int session_create(struct iscsi_connection *conn);
 extern void session_destroy(struct iscsi_session *session);
 extern struct iscsi_session *session_lookup(uint16_t tsih);
 extern void session_get(struct iscsi_session *session);
@@ -266,7 +266,7 @@
 /* target.c */
 struct iscsi_target * target_find_by_name(const char *name);
 struct iscsi_target * target_find_by_id(int tid);
-extern void target_list_build(struct connection *, char *, char *);
+extern void target_list_build(struct iscsi_connection *, char *, char *);
 
 /* param.c */
 int param_index_by_name(char *name, struct iscsi_key *keys);

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/session.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -48,7 +48,7 @@
 	return NULL;
 }
 
-int session_create(struct connection *conn)
+int session_create(struct iscsi_connection *conn)
 {
 	struct iscsi_session *session = NULL;
 	static uint16_t tsih, last_tsih = 0;

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-17 02:34:15 UTC (rev 654)
+++ trunk/usr/iscsi/target.c	2006-11-17 02:42:53 UTC (rev 655)
@@ -20,7 +20,7 @@
 
 static LIST_HEAD(targets_list);
 
-void target_list_build(struct connection *conn, char *addr, char *name)
+void target_list_build(struct iscsi_connection *conn, char *addr, char *name)
 {
 	struct iscsi_target *target;
 
@@ -181,7 +181,7 @@
 {
 	int len, total = 0;
 	struct iscsi_session *session;
-	struct connection *conn;
+	struct iscsi_connection *conn;
 
 	session = session_lookup(sid_to_tsih(sid));
 	if (!session)



From tomo at mail.berlios.de  Fri Nov 17 04:11:16 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 04:11:16 +0100
Subject: [Stgt-svn] r656 - in trunk/usr: . iscsi
Message-ID: <200611170311.kAH3BGv7020918@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 04:11:15 +0100 (Fri, 17 Nov 2006)
New Revision: 656

Modified:
   trunk/usr/driver.h
   trunk/usr/iscsi/conn.c
   trunk/usr/iscsi/iscsi.h
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/transport.c
   trunk/usr/tgtd.c
Log:
Fix tgt_target_bind arg in conn_take_fd


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/driver.h	2006-11-17 03:11:15 UTC (rev 656)
@@ -4,7 +4,7 @@
 	const char *name;
 	int use_kernel;
 
-	int (*init) (void);
+	int (*init) (int);
 
 	int (*target_create) (int, char *);
 	int (*target_destroy) (int);

Modified: trunk/usr/iscsi/conn.c
===================================================================
--- trunk/usr/iscsi/conn.c	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/iscsi/conn.c	2006-11-17 03:11:15 UTC (rev 656)
@@ -157,14 +157,17 @@
 int conn_take_fd(struct iscsi_connection *conn, int fd)
 {
 	uint64_t sid = sid64(conn->isid, conn->tsih);
+	int err;
 
 	dprintf("conn_take_fd: %d %u %u %u %" PRIx64 "\n",
 		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
 
 	conn->session->conn_cnt++;
 
-	/* FIXME: Use appropriate lid. */
-	return tgt_target_bind(conn->session->target->tid, conn->tsih, 0);
+	err = tgt_target_bind(conn->session->target->tid, conn->tsih, lld_index);
+	if (err)
+		eprintf("fail to bind %d\n", err);
+	return err;
 }
 
 void conn_read_pdu(struct iscsi_connection *conn)

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/iscsi/iscsi.h	2006-11-17 03:11:15 UTC (rev 656)
@@ -1,4 +1,4 @@
-extern int iscsi_init(void);
+extern int iscsi_init(int);
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
 extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/iscsi/iscsid.h	2006-11-17 03:11:15 UTC (rev 656)
@@ -233,6 +233,8 @@
 #define clear_task_pending(t)	((t)->flags &= ~(1 << TASK_pending))
 #define task_pending(t)		((t)->flags & (1 << TASK_pending))
 
+extern int lld_index;
+
 /* chap.c */
 extern int cmnd_exec_auth_chap(struct iscsi_connection *conn);
 

Modified: trunk/usr/iscsi/transport.c
===================================================================
--- trunk/usr/iscsi/transport.c	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/iscsi/transport.c	2006-11-17 03:11:15 UTC (rev 656)
@@ -10,10 +10,14 @@
 	NULL,
 };
 
-int iscsi_init(void)
+int lld_index;
+
+int iscsi_init(int index)
 {
 	int i, err, nr = 0;
 
+	lld_index = index;
+
 	for (i = 0; iscsi_transports[i]; i++) {
 		err = iscsi_transports[i]->ep_init();
 		if (!err)

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-17 02:42:53 UTC (rev 655)
+++ trunk/usr/tgtd.c	2006-11-17 03:11:15 UTC (rev 656)
@@ -241,7 +241,7 @@
 
 	for (i = nr = 0; tgt_drivers[i]; i++) {
 		if (tgt_drivers[i]->init) {
-			err = tgt_drivers[i]->init();
+			err = tgt_drivers[i]->init(i);
 			if (err)
 				continue;
 		}



From tomo at mail.berlios.de  Fri Nov 17 04:49:37 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Fri, 17 Nov 2006 04:49:37 +0100
Subject: [Stgt-svn] r657 - trunk/usr/iscsi
Message-ID: <200611170349.kAH3nbQP023610@sheep.berlios.de>

Author: tomo
Date: 2006-11-17 04:49:36 +0100 (Fri, 17 Nov 2006)
New Revision: 657

Modified:
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/session.c
Log:
Just cleanups


Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/usr/iscsi/iscsid.h	2006-11-17 03:11:15 UTC (rev 656)
+++ trunk/usr/iscsi/iscsid.h	2006-11-17 03:49:36 UTC (rev 657)
@@ -260,7 +260,6 @@
 /* session.c */
 extern struct iscsi_session *session_find_name(int tid, const char *iname, uint8_t *isid);
 extern int session_create(struct iscsi_connection *conn);
-extern void session_destroy(struct iscsi_session *session);
 extern struct iscsi_session *session_lookup(uint16_t tsih);
 extern void session_get(struct iscsi_session *session);
 extern void session_put(struct iscsi_session *session);

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/usr/iscsi/session.c	2006-11-17 03:11:15 UTC (rev 656)
+++ trunk/usr/iscsi/session.c	2006-11-17 03:49:36 UTC (rev 657)
@@ -24,7 +24,8 @@
 	struct iscsi_session *session;
 	struct iscsi_target *target;
 
-	if (!(target = target_find_by_id(tid)))
+	target = target_find_by_id(tid);
+	if (!target)
 		return NULL;
 
 	dprintf("session_find_name: %s %x %x %x %x %x %x\n", iname,
@@ -102,10 +103,8 @@
 	return 0;
 }
 
-void session_destroy(struct iscsi_session *session)
+static void session_destroy(struct iscsi_session *session)
 {
-	eprintf("%d\n", session->tsih);
-
 	if (!list_empty(&session->conn_list)) {
 		eprintf("%d conn_list is not null\n", session->tsih);
 		return;
@@ -129,7 +128,6 @@
 
 void session_put(struct iscsi_session *session)
 {
-	session->refcount--;
-	if (session->refcount == 0)
+	if (!--session->refcount)
 		session_destroy(session);
 }



From tomo at mail.berlios.de  Sat Nov 18 08:41:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sat, 18 Nov 2006 08:41:04 +0100
Subject: [Stgt-svn] r658 - trunk/usr/iscsi
Message-ID: <200611180741.kAI7f4Os015611@sheep.berlios.de>

Author: tomo
Date: 2006-11-18 08:41:03 +0100 (Sat, 18 Nov 2006)
New Revision: 658

Modified:
   trunk/usr/iscsi/account.c
Log:
Fix SESSION_DISCOVERY authentication bugs


Modified: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-11-17 03:49:36 UTC (rev 657)
+++ trunk/usr/iscsi/account.c	2006-11-18 07:41:03 UTC (rev 658)
@@ -269,13 +269,13 @@
 
 int iscsi_account_available(int tid, int dir)
 {
-	int err = 0;
+	int found = 0;
 	struct iscsi_target* target;
 	struct ac_node *acn;
 
 	target = target_find_by_id(tid);
 	if (!target)
-		return ENOENT;
+		return 0;
 
 	if (dir == AUTH_DIR_INCOMING) {
 		int i;
@@ -283,7 +283,7 @@
 		acn = target->incoming;
 		for (i = 0;  i < ARRAY_SIZE(target->incoming); i++, acn++) {
 			if (acn->head) {
-				err = 1;
+				found = 1;
 				break;
 			}
 		}
@@ -291,10 +291,10 @@
 	} else if (dir == AUTH_DIR_OUTGOING) {
 		acn = &target->outgoing;
 		if (acn->head)
-			err = 1;
+			found = 1;
 	}
 
-	return err;
+	return found;
 }
 
 int iscsi_account_lookup(int tid, int dir, char *user, char *pass)



From tomo at mail.berlios.de  Tue Nov 21 17:56:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 21 Nov 2006 17:56:59 +0100
Subject: [Stgt-svn] r659 - trunk
Message-ID: <200611211656.kALGuxpe009255@sheep.berlios.de>

Author: tomo
Date: 2006-11-21 17:56:58 +0100 (Tue, 21 Nov 2006)
New Revision: 659

Modified:
   trunk/README
Log:
Small fix on README.

Modified: trunk/README
===================================================================
--- trunk/README	2006-11-18 07:41:03 UTC (rev 658)
+++ trunk/README	2006-11-21 16:56:58 UTC (rev 659)
@@ -32,11 +32,11 @@
 Now you are ready to build target drivers. If you like to use the
 iSCSI target driver:
 
-host:~/tgt$ make KERNELSRC=<kernel-src> ISCSI=1
+host:~/tgt$ make KERNELSRC=<kernel-src-directory> ISCSI=1
 
 Or if you like to use the IBM VIO target driver:
 
-host:~/tgt$ make KERNELSRC=<kernel-src> IBMVIO=1
+host:~/tgt$ make KERNELSRC=<kernel-src-directory> IBMVIO=1
 
 Make sure that everything is built successfully.
 



From tomo at mail.berlios.de  Tue Nov 21 17:58:22 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 21 Nov 2006 17:58:22 +0100
Subject: [Stgt-svn] r660 - trunk/usr
Message-ID: <200611211658.kALGwMrx010275@sheep.berlios.de>

Author: tomo
Date: 2006-11-21 17:58:22 +0100 (Tue, 21 Nov 2006)
New Revision: 660

Modified:
   trunk/usr/Makefile
   trunk/usr/tgtd.h
Log:
Now iscsi driver does not need tgtif. So it can work with EPOLL_WAIT + 2.6.18 kernel.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-21 16:56:58 UTC (rev 659)
+++ trunk/usr/Makefile	2006-11-21 16:58:22 UTC (rev 660)
@@ -1,11 +1,11 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
 	-I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o util.o sched.o
+TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o sched.o
 LIBS += -laio
 
 ifneq ($(IBMVIO),)
-CFLAGS += -DIBMVIO
+CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
 BD_MMAP=1
 endif
@@ -20,7 +20,7 @@
 endif
 
 ifneq ($(BD_MMAP),)
-TGTD_OBJS += bd_mmap.o
+TGTD_OBJS += bd_mmap.o tgtif.o
 endif
 
 ifneq ($(BD_AIO),)

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-21 16:56:58 UTC (rev 659)
+++ trunk/usr/tgtd.h	2006-11-21 16:58:22 UTC (rev 660)
@@ -41,13 +41,19 @@
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 };
 
+#ifdef USE_KERNEL
 extern int kreq_init(void);
+#else
+static inline int kreq_init(void)	\
+{					\
+	return 0;			\
+}
+#endif
+
 extern int kspace_send_tsk_mgmt_res(int host_no, uint64_t mid, int result);
 extern int kspace_send_cmd_res(int host_no, int len, int result,
 			       int rw, uint64_t addr, uint64_t tag);
-
 extern int ipc_init(void);
-
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_target_create(int tid);



From tomo at mail.berlios.de  Tue Nov 21 17:58:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Tue, 21 Nov 2006 17:58:50 +0100
Subject: [Stgt-svn] r661 - trunk/patch
Message-ID: <200611211658.kALGwoow010535@sheep.berlios.de>

Author: tomo
Date: 2006-11-21 17:58:50 +0100 (Tue, 21 Nov 2006)
New Revision: 661

Added:
   trunk/patch/epoll-2.6.18.diff
Log:
Add EPOLL_WAIT patch for 2.6.18


Added: trunk/patch/epoll-2.6.18.diff
===================================================================
--- trunk/patch/epoll-2.6.18.diff	2006-11-21 16:58:22 UTC (rev 660)
+++ trunk/patch/epoll-2.6.18.diff	2006-11-21 16:58:50 UTC (rev 661)
@@ -0,0 +1,236 @@
+diff --git a/fs/aio.c b/fs/aio.c
+index 9506301..f93d639 100644
+--- a/fs/aio.c
++++ b/fs/aio.c
+@@ -29,6 +29,7 @@ #include <linux/aio.h>
+ #include <linux/highmem.h>
+ #include <linux/workqueue.h>
+ #include <linux/security.h>
++#include <linux/eventpoll.h>
+ 
+ #include <asm/kmap_types.h>
+ #include <asm/uaccess.h>
+@@ -865,7 +866,7 @@ static void aio_kick_handler(void *data)
+ 	use_mm(ctx->mm);
+ 	spin_lock_irq(&ctx->ctx_lock);
+ 	requeue =__aio_run_iocbs(ctx);
+- 	unuse_mm(ctx->mm);
++	unuse_mm(ctx->mm);
+ 	spin_unlock_irq(&ctx->ctx_lock);
+ 	set_fs(oldfs);
+ 	/*
+@@ -1434,6 +1435,9 @@ static ssize_t aio_setup_iocb(struct kio
+ 		if (file->f_op->aio_fsync)
+ 			kiocb->ki_retry = aio_fsync;
+ 		break;
++	case IOCB_CMD_EPOLL_WAIT:
++		kiocb->ki_retry = eventpoll_aio_wait;
++		break;
+ 	default:
+ 		dprintk("EINVAL: io_submit: no operation provided\n");
+ 		ret = -EINVAL;
+diff --git a/fs/eventpoll.c b/fs/eventpoll.c
+index 3a35674..e1accf1 100644
+--- a/fs/eventpoll.c
++++ b/fs/eventpoll.c
+@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
+ #include <linux/mount.h>
+ #include <linux/bitops.h>
+ #include <linux/mutex.h>
++#include <linux/aio.h>
+ #include <asm/uaccess.h>
+ #include <asm/system.h>
+ #include <asm/io.h>
+@@ -698,6 +699,145 @@ eexit_1:
+ 	return error;
+ }
+ 
++static void eventpoll_aio_timer(unsigned long data)
++{
++	struct kiocb *iocb = (struct kiocb *)data;
++	struct timer_list *timer = (struct timer_list *)iocb->private;
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++
++	(void)del_timer(timer);
++	write_lock(&ep->lock);
++	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
++	write_unlock(&ep->lock);
++}
++
++static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
++{
++	struct file *file = iocb->ki_filp;
++	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	int ret = -1;
++	struct list_head *list;
++	int seen = 0;
++
++	write_lock_irq(&ep->lock);
++
++	if (iocb->private)
++		del_timer((struct timer_list *)iocb->private);
++	/*
++	 *  We duplicate the code found in remove_wait_queue, since we
++	 *  can't call that function from here.  We can only call
++	 *  __remove_wait_queue (same as remove_wait_queue_locked) which
++	 *  does not check to see if the item was actually removed from the
++	 *  queue.
++	 */
++	list = &ep->wq.task_list;
++
++	do {
++		struct list_head *next;
++		if (list == &iocb->ki_wait.task_list)
++			seen++;
++		next = list->next;
++		if (next->prev != list) {
++			seen += 2;
++			break;
++		}
++		list = next;
++	} while (list != &ep->wq.task_list);
++
++	if (seen == 1) {
++		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
++		ret = 0;
++	}
++	write_unlock_irq(&ep->lock);
++
++	if (ret == 0) {
++		/* successfully cancelled request */
++		kfree(iocb->private);
++		iocb->private = NULL;
++		/* drop the i/o reference */
++		aio_put_req(iocb);
++	} else
++		ret = -EAGAIN;
++
++	event->res = event->res2 = 0;
++	/* drop the cancel reference */
++	aio_put_req(iocb);
++
++	return ret;
++}
++
++/*
++ * iocb->ki_nbytes -- number of events
++ * iocb->ki_pos    -- relative timeout in milliseconds
++ * iocb->private   -- NULL first go;  after that, it's set to the the
++ *                    absolute timeout in jiffies.
++ */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb)
++{
++	struct file *file = iocb->ki_filp;
++	ssize_t ret = -EINVAL;
++	int relative_ms;
++	unsigned long expires;
++	unsigned long now;
++	struct timer_list *timer;
++
++	if (!is_file_epoll(file) || iocb->ki_nbytes > MAX_EVENTS ||
++	    iocb->ki_nbytes <= 0)
++		return -EINVAL;
++
++	if (!iocb->private) {
++		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
++		if (!timer)
++			return -ENOMEM;
++
++		if (iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++			expires = MAX_SCHEDULE_TIMEOUT;
++		else
++			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
++
++		init_timer(timer);
++		timer->function = eventpoll_aio_timer;
++		timer->data = (unsigned long)iocb;
++		timer->expires = expires;
++	} else {
++		timer = (struct timer_list *)iocb->private;
++		expires = timer->expires;
++	}
++
++	now = jiffies;
++	if (time_before(now, expires))
++		relative_ms =
++			jiffies_to_msecs(expires) - jiffies_to_msecs(now);
++	else
++		relative_ms = 0;
++
++	iocb->ki_cancel = aio_epoll_cancel;
++	ret = ep_poll(file->private_data,
++		      (struct epoll_event __user *)iocb->ki_buf,
++		      iocb->ki_nbytes, relative_ms);
++
++	/*
++	 *  If we've added ourselves to the wait queue, there is a timeout
++	 *  specified, and we didn't setup the timer yet, then go ahead and
++	 *  add the timer.
++	 */
++	if (ret == -EIOCBRETRY && !iocb->private) {
++		iocb->private = timer;
++		if (expires != MAX_SCHEDULE_TIMEOUT)
++			add_timer(timer);
++	}
++
++	/* Perform cleanup if the poll has finished */
++	if (ret > 0 || relative_ms == 0) {
++		iocb->ki_cancel = NULL;
++		iocb->private = NULL;
++		(void)del_timer(timer);
++		kfree(timer);
++	}
++
++	return ret;
++}
+ 
+ /*
+  * Creates the file descriptor to be used by the epoll interface.
+@@ -1513,6 +1653,12 @@ retry:
+ 
+ 	res = 0;
+ 	if (list_empty(&ep->rdllist)) {
++		if (in_aio() && jtimeout) {
++			__add_wait_queue(&ep->wq, current->io_wait);
++			res = -EIOCBRETRY;
++			write_unlock_irqrestore(&ep->lock, flags);
++			goto out;
++		}
+ 		/*
+ 		 * We don't have any available event to return to the caller.
+ 		 * We need to sleep here, and we will be wake up by
+@@ -1558,6 +1704,7 @@ retry:
+ 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
+ 		goto retry;
+ 
++out:
+ 	return res;
+ }
+ 
+diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
+index 30fdcc8..34a7412 100644
+--- a/include/linux/aio_abi.h
++++ b/include/linux/aio_abi.h
+@@ -41,6 +41,7 @@ enum {
+ 	 * IOCB_CMD_POLL = 5,
+ 	 */
+ 	IOCB_CMD_NOOP = 6,
++  	IOCB_CMD_EPOLL_WAIT = 9,
+ };
+ 
+ /* read() from /dev/aio returns these structures. */
+diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
+index 84cfa8b..ed04500 100644
+--- a/include/linux/eventpoll.h
++++ b/include/linux/eventpoll.h
+@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
+ /* Used to release the epoll bits inside the "struct file" */
+ void eventpoll_release_file(struct file *file);
+ 
++/* Used to provide epoll_wait() to sys_io_submit() */
++ssize_t eventpoll_aio_wait(struct kiocb *iocb);
++
+ /*
+  * This is called from inside fs/file_table.c:__fput() to unlink files
+  * from the eventpoll interface. We need to have this facility to cleanup



From tomo at mail.berlios.de  Wed Nov 22 07:01:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 07:01:59 +0100
Subject: [Stgt-svn] r662 - trunk/usr
Message-ID: <200611220601.kAM61xIe027900@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 07:01:57 +0100 (Wed, 22 Nov 2006)
New Revision: 662

Added:
   trunk/usr/work.c
   trunk/usr/work.h
Removed:
   trunk/usr/sched.c
   trunk/usr/sched.h
Modified:
   trunk/usr/Makefile
   trunk/usr/tgtd.c
Log:
sched.[hc] renamed to work.[hc] to avoid conflicting with sched.h


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-21 16:58:50 UTC (rev 661)
+++ trunk/usr/Makefile	2006-11-22 06:01:57 UTC (rev 662)
@@ -1,7 +1,7 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
 	-I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o sched.o
+TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o
 LIBS += -laio
 
 ifneq ($(IBMVIO),)

Deleted: trunk/usr/sched.c
===================================================================
--- trunk/usr/sched.c	2006-11-21 16:58:50 UTC (rev 661)
+++ trunk/usr/sched.c	2006-11-22 06:01:57 UTC (rev 662)
@@ -1,83 +0,0 @@
-/*
- * bogus scheduler
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-
-#include <stdlib.h>
-#include <stdint.h>
-
-#include "list.h"
-#include "util.h"
-#include "log.h"
-#include "sched.h"
-
-int stop_daemon;
-
-static unsigned int jiffies;
-static LIST_HEAD(active_work_list);
-static LIST_HEAD(inactive_work_list);
-
-void enqueue_work(struct tgt_work *work, unsigned int second)
-{
-	unsigned int when;
-	struct tgt_work *ent;
-
-	when = second * SCHED_HZ;
-
-	if (when) {
-
-		list_for_each_entry(ent, &inactive_work_list, entry) {
-			if (before(when, ent->when))
-				break;
-		}
-
-		list_add_tail(&work->entry, &ent->entry);
-	} else
-		list_add_tail(&work->entry, &active_work_list);
-}
-
-void dequeue_work(struct tgt_work *work)
-{
-	list_del(&work->entry);
-}
-
-/*
- * this function is called only when the system is idle. So this
- * scheduler is pretty bogus. Your job would be delayed unexpectedly.
- */
-void schedule(void)
-{
-	struct tgt_work *work;
-
-	jiffies++;
-
-	list_for_each_entry(work, &inactive_work_list, entry) {
-		if (after(work->when, jiffies)) {
-			list_del(&work->entry);
-			enqueue_work(work, 0);
-		} else
-			break;
-	}
-
-	while (!list_empty(&active_work_list)) {
-		work = list_entry(active_work_list.next, struct tgt_work, entry);
-		work->func(work->data);
-	}
-}

Deleted: trunk/usr/sched.h
===================================================================
--- trunk/usr/sched.h	2006-11-21 16:58:50 UTC (rev 661)
+++ trunk/usr/sched.h	2006-11-22 06:01:57 UTC (rev 662)
@@ -1,19 +0,0 @@
-#ifndef __SCHED_H
-#define __SCHED_H
-
-#define SCHED_HZ 5
-
-struct tgt_work {
-	struct list_head entry;
-	void (*func)(void *);
-	void *data;
-	unsigned int when;
-};
-
-extern void schedule(void);
-extern void enqueue_work(struct tgt_work *work, unsigned int second);
-extern void dequeue_work(struct tgt_work *work);
-
-extern int stop_daemon;
-
-#endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-21 16:58:50 UTC (rev 661)
+++ trunk/usr/tgtd.c	2006-11-22 06:01:57 UTC (rev 662)
@@ -35,7 +35,7 @@
 #include "list.h"
 #include "tgtd.h"
 #include "driver.h"
-#include "sched.h"
+#include "work.h"
 #include "util.h"
 
 #define MAX_FDS	4096

Copied: trunk/usr/work.c (from rev 661, trunk/usr/sched.c)
===================================================================
--- trunk/usr/sched.c	2006-11-21 16:58:50 UTC (rev 661)
+++ trunk/usr/work.c	2006-11-22 06:01:57 UTC (rev 662)
@@ -0,0 +1,83 @@
+/*
+ * bogus scheduler
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#include "list.h"
+#include "util.h"
+#include "log.h"
+#include "work.h"
+
+int stop_daemon;
+
+static unsigned int jiffies;
+static LIST_HEAD(active_work_list);
+static LIST_HEAD(inactive_work_list);
+
+void enqueue_work(struct tgt_work *work, unsigned int second)
+{
+	unsigned int when;
+	struct tgt_work *ent;
+
+	when = second * SCHED_HZ;
+
+	if (when) {
+
+		list_for_each_entry(ent, &inactive_work_list, entry) {
+			if (before(when, ent->when))
+				break;
+		}
+
+		list_add_tail(&work->entry, &ent->entry);
+	} else
+		list_add_tail(&work->entry, &active_work_list);
+}
+
+void dequeue_work(struct tgt_work *work)
+{
+	list_del(&work->entry);
+}
+
+/*
+ * this function is called only when the system is idle. So this
+ * scheduler is pretty bogus. Your job would be delayed unexpectedly.
+ */
+void schedule(void)
+{
+	struct tgt_work *work;
+
+	jiffies++;
+
+	list_for_each_entry(work, &inactive_work_list, entry) {
+		if (after(work->when, jiffies)) {
+			list_del(&work->entry);
+			enqueue_work(work, 0);
+		} else
+			break;
+	}
+
+	while (!list_empty(&active_work_list)) {
+		work = list_entry(active_work_list.next, struct tgt_work, entry);
+		work->func(work->data);
+	}
+}

Copied: trunk/usr/work.h (from rev 661, trunk/usr/sched.h)



From tomo at mail.berlios.de  Wed Nov 22 07:36:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 07:36:25 +0100
Subject: [Stgt-svn] r663 - trunk/usr
Message-ID: <200611220636.kAM6aPXJ020907@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 07:36:25 +0100 (Wed, 22 Nov 2006)
New Revision: 663

Modified:
   trunk/usr/tgtd.c
Log:
Use SCHED_FIFO


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-11-22 06:01:57 UTC (rev 662)
+++ trunk/usr/tgtd.c	2006-11-22 06:36:25 UTC (rev 663)
@@ -24,6 +24,7 @@
 #include <getopt.h>
 #include <inttypes.h>
 #include <libaio.h>
+#include <sched.h>
 #include <signal.h>
 #include <stdint.h>
 #include <stdio.h>
@@ -82,23 +83,33 @@
 static void signal_catch(int signo) {
 }
 
-static void oom_adjust(void)
+static int set_realtime(void)
 {
-	int fd;
+	struct sched_param sp;
+
+	sp.sched_priority = sched_get_priority_max(SCHED_FIFO);
+	return sched_setscheduler(0, SCHED_FIFO, &sp);
+}
+
+static int oom_adjust(void)
+{
+	int fd, err;
 	char path[64];
 
-	/* Should we use RT stuff? */
-	nice(-20);
-
 	/* Avoid oom-killer */
 	sprintf(path, "/proc/%d/oom_adj", getpid());
 	fd = open(path, O_WRONLY);
 	if (fd < 0) {
-		fprintf(stderr, "can not adjust oom-killer's pardon %s\n", path);
-		return;
+		fprintf(stderr, "can't adjust oom-killer's pardon %s, %m\n", path);
+		return errno;
 	}
-	write(fd, "-17\n", 4);
+	err = write(fd, "-17\n", 4);
+	if (err < 0) {
+		fprintf(stderr, "can't adjust oom-killer's pardon %s, %m\n", path);
+		return errno;
+	}
 	close(fd);
+	return 0;
 }
 
 int tgt_event_add(int fd, int events, event_handler_t handler, void *data)
@@ -306,8 +317,14 @@
 	if (is_daemon && daemon(0,0))
 		exit(1);
 
-	oom_adjust();
+	err = oom_adjust();
+	if (err)
+		exit(1);
 
+	err = set_realtime();
+	if (err)
+		eprintf("can't set SCHED_FIFO, %m\n");
+
 	err = log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug);
 	if (err)
 		exit(1);



From tomo at mail.berlios.de  Wed Nov 22 08:44:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 08:44:18 +0100
Subject: [Stgt-svn] r664 - trunk/usr
Message-ID: <200611220744.kAM7iIWa025839@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 08:44:17 +0100 (Wed, 22 Nov 2006)
New Revision: 664

Modified:
   trunk/usr/mgmt.c
Log:
slim tgt_mgmt()


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-22 06:36:25 UTC (rev 663)
+++ trunk/usr/mgmt.c	2006-11-22 07:44:17 UTC (rev 664)
@@ -42,13 +42,14 @@
 
 #define BUFSIZE 4096
 
-static void set_show_results(struct tgtadm_res *res, int err)
+static void set_show_results(struct tgtadm_res *res, int *err)
 {
 	if (err < 0)
-		res->err = err;
+		res->err = *err;
 	else {
 		res->err = 0;
-		res->len = err + sizeof(*res);
+		res->len = *err + sizeof(*res);
+		*err = 0;
 	}
 }
 
@@ -79,12 +80,27 @@
 		else if (tgt_drivers[lld_no]->target_update)
 			err = tgt_drivers[lld_no]->target_update(req->tid, params);
 		break;
+	case OP_SHOW:
+		if (req->tid < 0)
+			err = tgt_target_show_all((char *)res->data,
+						  *rlen - sizeof(*res));
+		else if (tgt_drivers[lld_no]->show)
+			err = tgt_drivers[lld_no]->show(req->mode,
+							req->tid, req->sid,
+							req->cid, req->lun,
+							(char *)res->data,
+							*rlen - sizeof(*res));
+		break;
 	default:
 		break;
 	}
 
-	res->err = err;
-	res->len = (char *) res->data - (char *) res;
+	if (req->op == OP_SHOW)
+		set_show_results(res, &err);
+	else {
+		res->err = err;
+		res->len = (char *) res->data - (char *) res;
+	}
 	return err;
 }
 
@@ -150,23 +166,6 @@
 		req->len, lld_no, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
 
-	if (req->op == OP_SHOW && req->mode != MODE_ACCOUNT) {
-		if (req->mode == MODE_TARGET && req->tid < 0)
-			err = tgt_target_show_all((char *)res->data,
-						  len - sizeof(*res));
-		else {
-			if (tgt_drivers[lld_no]->show)
-				err = tgt_drivers[lld_no]->show(req->mode,
-								req->tid, req->sid,
-								req->cid, req->lun,
-								(char *)res->data,
-								len - sizeof(*res));
-		}
-
-		set_show_results(res, err);
-		return 0;
-	}
-
 	switch (req->mode) {
 	case MODE_SYSTEM:
 		break;
@@ -183,7 +182,7 @@
 							   (char *)res->data,
 							   len - sizeof(*res));
 		if (req->op == OP_SHOW) {
-			set_show_results(res, err);
+			set_show_results(res, &err);
 			err = 0;
 		} else {
 			res->err = err;
@@ -191,6 +190,15 @@
 		}
 		break;
 	default:
+		if (req->op == OP_SHOW && tgt_drivers[lld_no]->show) {
+			err = tgt_drivers[lld_no]->show(req->mode,
+							req->tid, req->sid,
+							req->cid, req->lun,
+							(char *)res->data,
+							len - sizeof(*res));
+
+			set_show_results(res, &err);
+		}
 		break;
 	}
 



From tomo at mail.berlios.de  Wed Nov 22 08:58:31 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 08:58:31 +0100
Subject: [Stgt-svn] r665 - trunk/doc
Message-ID: <200611220758.kAM7wVXc026749@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 08:58:30 +0100 (Wed, 22 Nov 2006)
New Revision: 665

Modified:
   trunk/doc/README.iscsi
Log:
Fix README.iSCSI.

Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-22 07:44:17 UTC (rev 664)
+++ trunk/doc/README.iscsi	2006-11-22 07:58:30 UTC (rev 665)
@@ -109,7 +109,7 @@
 MaxConnections=1
 
 
-You can see the initiators that the target accepts:
+After the target the target accepted some initiators, you can see them:
 
 host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1
 sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel



From tomo at mail.berlios.de  Wed Nov 22 10:54:12 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 10:54:12 +0100
Subject: [Stgt-svn] r666 - in trunk/usr: . ibmvio iscsi
Message-ID: <200611220954.kAM9sCes005691@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 10:54:11 +0100 (Wed, 22 Nov 2006)
New Revision: 666

Modified:
   trunk/usr/driver.h
   trunk/usr/ibmvio/ibmvio.h
   trunk/usr/iscsi/iscsi.h
   trunk/usr/mgmt.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
Move bdt from driver to target because of raw mode support.

Now we link a LLD to a target, however, it's not right. Different LLDs
can share a target. Note that it is not always possible. If LLDs need
to use the same I/O type to share one target.


Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/driver.h	2006-11-22 09:54:11 UTC (rev 666)
@@ -22,7 +22,7 @@
 			      uint64_t tag);
 	int (*mgmt_end_notify)(int host_no, uint64_t mid, int result);
 
-	struct backedio_template *bdt;
+	struct backedio_template *default_bdt;
 };
 
 extern struct tgt_driver *tgt_drivers[];

Modified: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/ibmvio/ibmvio.h	2006-11-22 09:54:11 UTC (rev 666)
@@ -13,5 +13,5 @@
 	.scsi_inquiry		= scsi_inquiry,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
-	.bdt			= &mmap_bdt,
+	.default_bdt		= &mmap_bdt,
 };

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/iscsi/iscsi.h	2006-11-22 09:54:11 UTC (rev 666)
@@ -21,5 +21,5 @@
 	.account		= iscsi_mgmt_account,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
-	.bdt			= &aio_bdt,
+	.default_bdt		= &aio_bdt,
 };

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/mgmt.c	2006-11-22 09:54:11 UTC (rev 666)
@@ -60,7 +60,7 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(req->tid);
+		err = tgt_target_create(lld_no, req->tid);
 		if (!err && tgt_drivers[lld_no]->target_create)
 			tgt_drivers[lld_no]->target_create(req->tid, params);
 		break;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/scsi.c	2006-11-22 09:54:11 UTC (rev 666)
@@ -469,7 +469,7 @@
 		     int *len, uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
 		     struct tgt_device *dev, struct list_head *dev_list, int *async,
-		     void *key)
+		     void *key, bkio_submit_t *submit)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;
@@ -536,8 +536,7 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = tgt_drivers[lid]->bdt->bd_cmd_submit(dev, *rw, datalen,
-							      uaddr, *offset, async, key);
+		result = submit(dev, *rw, datalen, uaddr, *offset, async, key);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/target.c	2006-11-22 09:54:11 UTC (rev 666)
@@ -155,7 +155,7 @@
 	if (!p)
 		return -ENOMEM;
 
-	device = tgt_drivers[target->lid]->bdt->bd_open(path, &dev_fd, &size);
+	device = target->bdt->bd_open(path, &dev_fd, &size);
 	if (!device) {
 		free(p);
 		return -EINVAL;
@@ -203,7 +203,7 @@
 	device_hlist_remove(device);
 	device_list_remove(device);
 
-	tgt_drivers[target->lid]->bdt->bd_close(device);
+	target->bdt->bd_close(device);
 	return 0;
 }
 
@@ -298,7 +298,8 @@
 					  &len, data_len,
 					  &uaddr, &rw, &mmapped, &offset,
 					  lun, cmd->dev,
-					  &target->device_list, &async, (void *) cmd);
+					  &target->device_list, &async, (void *) cmd,
+					  target->bdt->bd_cmd_submit);
 
 		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
@@ -357,7 +358,8 @@
 						  &rw, &mmapped, &offset,
 						  cmd->lun, cmd->dev,
 						  &cmd->c_target->device_list,
-						  &async, (void *) cmd);
+						  &async, (void *) cmd,
+						  cmd->c_target->bdt->bd_cmd_submit);
 			cmd->rw = rw;
 			cmd_post_perform(q, cmd, cmd->uaddr, len, mmapped);
 			set_cmd_processed(cmd);
@@ -390,9 +392,9 @@
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = tgt_drivers[target->lid]->bdt->bd_cmd_done(do_munmap,
-							 !cmd->mmapped,
-							 cmd->uaddr, cmd->len);
+	err = target->bdt->bd_cmd_done(do_munmap,
+				       !cmd->mmapped,
+				       cmd->uaddr, cmd->len);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 
@@ -553,7 +555,6 @@
 		eprintf("target is not found %d\n", tid);
 		return -EINVAL;
 	}
-	target->lid = lid;
 
 	if (hostt[host_no]) {
 		eprintf("host is already binded %d %d\n", tid, host_no);
@@ -566,7 +567,7 @@
 	return 0;
 }
 
-int tgt_target_create(int tid)
+int tgt_target_create(int lld, int tid)
 {
 	int i;
 	struct target *target;
@@ -591,6 +592,9 @@
 
 	target->target_state = SCSI_TARGET_SUSPENDED;
 
+	target->bdt = tgt_drivers[lld]->default_bdt;
+	target->lid = lld;
+
 	tgt_cmd_queue_init(&target->cmd_queue);
 	target_hlist_insert(target);
 

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/target.h	2006-11-22 09:54:11 UTC (rev 666)
@@ -24,6 +24,7 @@
 	int tid;
 	int lid;
 
+	enum scsi_target_type target_type;
 	enum scsi_target_state target_state;
 
 	struct list_head t_hlist;
@@ -34,6 +35,8 @@
 	struct list_head cmd_hash_list[1 << HASH_ORDER];
 
 	struct tgt_cmd_queue cmd_queue;
+
+	struct backedio_template *bdt;
 };
 
 struct cmd {

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-22 07:58:30 UTC (rev 665)
+++ trunk/usr/tgtd.h	2006-11-22 09:54:11 UTC (rev 666)
@@ -5,6 +5,11 @@
 
 #define	SCSI_ID_LEN	24
 
+enum scsi_target_type {
+	SCSI_TARGET_FILE = 1,
+	SCSI_TARGET_RAW,
+};
+
 enum scsi_target_state {
 	SCSI_TARGET_SUSPENDED = 1,
 	SCSI_TARGET_RUNNING,
@@ -32,12 +37,14 @@
 	unsigned long bddata[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
+typedef int (bkio_submit_t) (struct tgt_device *dev, int rw, uint32_t datalen,
+			     unsigned long *uaddr, uint64_t offset, int *async,
+			     void *key);
+
 struct backedio_template {
 	struct tgt_device *(*bd_open)(char *path, int *fd, uint64_t *size);
 	void (*bd_close)(struct tgt_device *dev);
-	int (*bd_cmd_submit)(struct tgt_device *dev, int rw, uint32_t datalen,
-			     unsigned long *uaddr, uint64_t offset, int *async,
-			     void *key);
+	bkio_submit_t *bd_cmd_submit;
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
 };
 
@@ -56,9 +63,9 @@
 extern int ipc_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
-extern int tgt_target_create(int tid);
+extern int tgt_target_create(int lld, int tid);
 extern int tgt_target_destroy(int tid);
-extern int tgt_target_bind(int tid, int host_no, int lid);
+extern int tgt_target_bind(int tid, int host_no, int lld);
 extern int tgt_target_show_all(char *buf, int rest);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
@@ -80,7 +87,7 @@
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
 			    struct tgt_device *dev, struct list_head *dev_list,
-			    int *async, void *key);
+			    int *async, void *key, bkio_submit_t *submit);
 
 extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
 			    uint8_t ascode, uint8_t ascodeq);



From tomo at mail.berlios.de  Wed Nov 22 11:25:52 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 11:25:52 +0100
Subject: [Stgt-svn] r667 - trunk/usr
Message-ID: <200611221025.kAMAPqro008957@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 11:25:52 +0100 (Wed, 22 Nov 2006)
New Revision: 667

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/target.h
   trunk/usr/tgtd.h
Log:
Add another workaround code to support rawio mode...


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-22 09:54:11 UTC (rev 666)
+++ trunk/usr/mgmt.c	2006-11-22 10:25:52 UTC (rev 667)
@@ -77,6 +77,9 @@
 		if (!strcmp(params, "state"))
 			err = tgt_set_target_state(req->tid,
 						   params + strlen(params) + 1);
+		else if (!strcmp(params, "iotype"))
+			err = tgt_set_target_iotype(req->tid,
+						    params + strlen(params) + 1);
 		else if (tgt_drivers[lld_no]->target_update)
 			err = tgt_drivers[lld_no]->target_update(req->tid, params);
 		break;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-22 09:54:11 UTC (rev 666)
+++ trunk/usr/target.c	2006-11-22 10:25:52 UTC (rev 667)
@@ -590,6 +590,7 @@
 	for (i = 0; i < ARRAY_SIZE(target->device_hash_list); i++)
 		INIT_LIST_HEAD(&target->device_hash_list[i]);
 
+	target->target_iotype = SCSI_TARGET_FILEIO;
 	target->target_state = SCSI_TARGET_SUSPENDED;
 
 	target->bdt = tgt_drivers[lld]->default_bdt;
@@ -625,6 +626,28 @@
 	return 0;
 }
 
+static struct {
+	enum scsi_target_iotype value;
+	char *name;
+} target_iotype[] = {
+	{SCSI_TARGET_FILEIO, "fileio"},
+	{SCSI_TARGET_RAWIO, "rawio"},
+};
+
+static char *target_iotype_name(enum scsi_target_state state)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(target_iotype); i++) {
+		if (target_iotype[i].value == state) {
+			name = target_iotype[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
 enum scsi_target_state tgt_get_target_state(int tid)
 {
 	struct target *target;
@@ -635,6 +658,27 @@
 	return target->target_state;
 }
 
+int tgt_set_target_iotype(int tid, char *str)
+{
+	int i, err = -EINVAL;
+	struct target *target;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	for (i = 0; i < ARRAY_SIZE(target_iotype); i++) {
+		if (!strcmp(target_iotype[i].name, str)) {
+			target->target_iotype = target_iotype[i].value;
+			err = 0;
+			break;
+		}
+	}
+
+	return err;
+}
+
+
 static struct {
 	enum scsi_target_state value;
 	char *name;
@@ -643,7 +687,7 @@
 	{SCSI_TARGET_RUNNING, "running"},
 };
 
-static char *target_state_state_name(enum scsi_target_state state)
+static char *target_state_name(enum scsi_target_state state)
 {
 	int i;
 	char *name = NULL;
@@ -685,9 +729,10 @@
 
 	for (i = total = 0; i < ARRAY_SIZE(target_hash_list); i++) {
 		list_for_each_entry(target, &target_hash_list[i], t_hlist) {
-			len = snprintf(buf, rest, "tid %d: lld name %s: state %s\n",
+			len = snprintf(buf, rest, "tid %d: lld name %s: iotype %s: state %s\n",
 				       target->tid, tgt_drivers[target->lid]->name,
-				       target_state_state_name(target->target_state));
+				       target_iotype_name(target->target_iotype),
+				       target_state_name(target->target_state));
 			buf += len;
 			total += len;
 			rest -= len;

Modified: trunk/usr/target.h
===================================================================
--- trunk/usr/target.h	2006-11-22 09:54:11 UTC (rev 666)
+++ trunk/usr/target.h	2006-11-22 10:25:52 UTC (rev 667)
@@ -24,7 +24,7 @@
 	int tid;
 	int lid;
 
-	enum scsi_target_type target_type;
+	enum scsi_target_iotype target_iotype;
 	enum scsi_target_state target_state;
 
 	struct list_head t_hlist;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-22 09:54:11 UTC (rev 666)
+++ trunk/usr/tgtd.h	2006-11-22 10:25:52 UTC (rev 667)
@@ -5,9 +5,9 @@
 
 #define	SCSI_ID_LEN	24
 
-enum scsi_target_type {
-	SCSI_TARGET_FILE = 1,
-	SCSI_TARGET_RAW,
+enum scsi_target_iotype {
+	SCSI_TARGET_FILEIO = 1,
+	SCSI_TARGET_RAWIO,
 };
 
 enum scsi_target_state {
@@ -94,5 +94,6 @@
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);
+extern int tgt_set_target_iotype(int tid, char *str);
 
 #endif



From tomo at mail.berlios.de  Wed Nov 22 17:14:57 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 22 Nov 2006 17:14:57 +0100
Subject: [Stgt-svn] r668 - trunk/patch
Message-ID: <200611221614.kAMGEvGR021397@sheep.berlios.de>

Author: tomo
Date: 2006-11-22 17:14:56 +0100 (Wed, 22 Nov 2006)
New Revision: 668

Modified:
   trunk/patch/epoll-2.6.18.diff
   trunk/patch/epoll-git.diff
Log:
Update IO_CMD_EPOLL_WAIT patches.

http://marc.theaimsgroup.com/?l=linux-aio&m=116312942511145&w=2


Modified: trunk/patch/epoll-2.6.18.diff
===================================================================
--- trunk/patch/epoll-2.6.18.diff	2006-11-22 10:25:52 UTC (rev 667)
+++ trunk/patch/epoll-2.6.18.diff	2006-11-22 16:14:56 UTC (rev 668)
@@ -1,5 +1,5 @@
 diff --git a/fs/aio.c b/fs/aio.c
-index 9506301..f93d639 100644
+index 9506301..aacb38e 100644
 --- a/fs/aio.c
 +++ b/fs/aio.c
 @@ -29,6 +29,7 @@ #include <linux/aio.h>
@@ -10,15 +10,6 @@
  
  #include <asm/kmap_types.h>
  #include <asm/uaccess.h>
-@@ -865,7 +866,7 @@ static void aio_kick_handler(void *data)
- 	use_mm(ctx->mm);
- 	spin_lock_irq(&ctx->ctx_lock);
- 	requeue =__aio_run_iocbs(ctx);
-- 	unuse_mm(ctx->mm);
-+	unuse_mm(ctx->mm);
- 	spin_unlock_irq(&ctx->ctx_lock);
- 	set_fs(oldfs);
- 	/*
 @@ -1434,6 +1435,9 @@ static ssize_t aio_setup_iocb(struct kio
  		if (file->f_op->aio_fsync)
  			kiocb->ki_retry = aio_fsync;
@@ -30,7 +21,7 @@
  		dprintk("EINVAL: io_submit: no operation provided\n");
  		ret = -EINVAL;
 diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index 3a35674..e1accf1 100644
+index 3a35674..729a753 100644
 --- a/fs/eventpoll.c
 +++ b/fs/eventpoll.c
 @@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
@@ -41,7 +32,7 @@
  #include <asm/uaccess.h>
  #include <asm/system.h>
  #include <asm/io.h>
-@@ -698,6 +699,145 @@ eexit_1:
+@@ -698,6 +699,150 @@ eexit_1:
  	return error;
  }
  
@@ -51,11 +42,12 @@
 +	struct timer_list *timer = (struct timer_list *)iocb->private;
 +	struct file *file = iocb->ki_filp;
 +	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	unsigned long flags;
 +
 +	(void)del_timer(timer);
-+	write_lock(&ep->lock);
++	write_lock_irqsave(&ep->lock, flags);
 +	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
-+	write_unlock(&ep->lock);
++	write_unlock_irqrestore(&ep->lock, flags);
 +}
 +
 +static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
@@ -71,11 +63,9 @@
 +	if (iocb->private)
 +		del_timer((struct timer_list *)iocb->private);
 +	/*
-+	 *  We duplicate the code found in remove_wait_queue, since we
-+	 *  can't call that function from here.  We can only call
-+	 *  __remove_wait_queue (same as remove_wait_queue_locked) which
-+	 *  does not check to see if the item was actually removed from the
-+	 *  queue.
++	 *  We need to know whether the event was removed from the wait
++	 *  queue in order to return the proper status to the cancellation
++	 *  code.
 +	 */
 +	list = &ep->wq.task_list;
 +
@@ -133,11 +123,16 @@
 +		return -EINVAL;
 +
 +	if (!iocb->private) {
++		/*
++		 *  Note that we unconditionally allocate a timer, but we
++		 *  only use it if a timeout was specified.  Otherwise, it
++		 *  is just a holder for the "infinite" value.
++		 */
 +		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
 +		if (!timer)
 +			return -ENOMEM;
 +
-+		if (iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
 +			expires = MAX_SCHEDULE_TIMEOUT;
 +		else
 +			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
@@ -152,9 +147,10 @@
 +	}
 +
 +	now = jiffies;
-+	if (time_before(now, expires))
-+		relative_ms =
-+			jiffies_to_msecs(expires) - jiffies_to_msecs(now);
++	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
++		relative_ms = EP_MAX_MSTIMEO;
++	else if (time_before(now, expires))
++		relative_ms = jiffies_to_msecs(expires - now);
 +	else
 +		relative_ms = 0;
 +
@@ -164,22 +160,22 @@
 +		      iocb->ki_nbytes, relative_ms);
 +
 +	/*
-+	 *  If we've added ourselves to the wait queue, there is a timeout
-+	 *  specified, and we didn't setup the timer yet, then go ahead and
-+	 *  add the timer.
++	 *  If a timeout was specified, ep_poll returned retry, and we have
++	 *  not yet registered a timer, go ahead and register one.
 +	 */
 +	if (ret == -EIOCBRETRY && !iocb->private) {
 +		iocb->private = timer;
-+		if (expires != MAX_SCHEDULE_TIMEOUT)
-+			add_timer(timer);
++		add_timer(timer);
 +	}
 +
-+	/* Perform cleanup if the poll has finished */
-+	if (ret > 0 || relative_ms == 0) {
++	/*
++	 *  Did we get any events?
++	 */
++	if (ret >= 0) {
 +		iocb->ki_cancel = NULL;
-+		iocb->private = NULL;
 +		(void)del_timer(timer);
 +		kfree(timer);
++		iocb->private = NULL;
 +	}
 +
 +	return ret;
@@ -187,7 +183,7 @@
  
  /*
   * Creates the file descriptor to be used by the epoll interface.
-@@ -1513,6 +1653,12 @@ retry:
+@@ -1513,6 +1658,12 @@ retry:
  
  	res = 0;
  	if (list_empty(&ep->rdllist)) {
@@ -200,23 +196,24 @@
  		/*
  		 * We don't have any available event to return to the caller.
  		 * We need to sleep here, and we will be wake up by
-@@ -1558,6 +1704,7 @@ retry:
+@@ -1557,7 +1708,7 @@ retry:
+ 	if (!res && eavail &&
  	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
  		goto retry;
- 
+-
 +out:
  	return res;
  }
  
 diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
-index 30fdcc8..34a7412 100644
+index 30fdcc8..bb67d5b 100644
 --- a/include/linux/aio_abi.h
 +++ b/include/linux/aio_abi.h
 @@ -41,6 +41,7 @@ enum {
  	 * IOCB_CMD_POLL = 5,
  	 */
  	IOCB_CMD_NOOP = 6,
-+  	IOCB_CMD_EPOLL_WAIT = 9,
++ 	IOCB_CMD_EPOLL_WAIT = 9,
  };
  
  /* read() from /dev/aio returns these structures. */

Modified: trunk/patch/epoll-git.diff
===================================================================
--- trunk/patch/epoll-git.diff	2006-11-22 10:25:52 UTC (rev 667)
+++ trunk/patch/epoll-git.diff	2006-11-22 16:14:56 UTC (rev 668)
@@ -1,5 +1,5 @@
 diff --git a/fs/aio.c b/fs/aio.c
-index 9476659..2da577c 100644
+index 9476659..e2eec22 100644
 --- a/fs/aio.c
 +++ b/fs/aio.c
 @@ -30,6 +30,7 @@ #include <linux/aio.h>
@@ -10,15 +10,6 @@
  
  #include <asm/kmap_types.h>
  #include <asm/uaccess.h>
-@@ -869,7 +870,7 @@ static void aio_kick_handler(void *data)
- 	use_mm(ctx->mm);
- 	spin_lock_irq(&ctx->ctx_lock);
- 	requeue =__aio_run_iocbs(ctx);
-- 	unuse_mm(ctx->mm);
-+	unuse_mm(ctx->mm);
- 	spin_unlock_irq(&ctx->ctx_lock);
- 	set_fs(oldfs);
- 	/*
 @@ -1504,6 +1505,9 @@ static ssize_t aio_setup_iocb(struct kio
  		if (file->f_op->aio_fsync)
  			kiocb->ki_retry = aio_fsync;
@@ -30,7 +21,7 @@
  		dprintk("EINVAL: io_submit: no operation provided\n");
  		ret = -EINVAL;
 diff --git a/fs/eventpoll.c b/fs/eventpoll.c
-index ae228ec..d1fcbdf 100644
+index ae228ec..6269c9e 100644
 --- a/fs/eventpoll.c
 +++ b/fs/eventpoll.c
 @@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
@@ -41,7 +32,7 @@
  #include <asm/uaccess.h>
  #include <asm/system.h>
  #include <asm/io.h>
-@@ -642,6 +643,145 @@ eexit_1:
+@@ -642,6 +643,150 @@ eexit_1:
  	return error;
  }
  
@@ -51,11 +42,12 @@
 +	struct timer_list *timer = (struct timer_list *)iocb->private;
 +	struct file *file = iocb->ki_filp;
 +	struct eventpoll *ep = (struct eventpoll *)file->private_data;
++	unsigned long flags;
 +
 +	(void)del_timer(timer);
-+	write_lock(&ep->lock);
++	write_lock_irqsave(&ep->lock, flags);
 +	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
-+	write_unlock(&ep->lock);
++	write_unlock_irqrestore(&ep->lock, flags);
 +}
 +
 +static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
@@ -71,11 +63,9 @@
 +	if (iocb->private)
 +		del_timer((struct timer_list *)iocb->private);
 +	/*
-+	 *  We duplicate the code found in remove_wait_queue, since we
-+	 *  can't call that function from here.  We can only call
-+	 *  __remove_wait_queue (same as remove_wait_queue_locked) which
-+	 *  does not check to see if the item was actually removed from the
-+	 *  queue.
++	 *  We need to know whether the event was removed from the wait
++	 *  queue in order to return the proper status to the cancellation
++	 *  code.
 +	 */
 +	list = &ep->wq.task_list;
 +
@@ -133,11 +123,16 @@
 +		return -EINVAL;
 +
 +	if (!iocb->private) {
++		/*
++		 *  Note that we unconditionally allocate a timer, but we
++		 *  only use it if a timeout was specified.  Otherwise, it
++		 *  is just a holder for the "infinite" value.
++		 */
 +		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
 +		if (!timer)
 +			return -ENOMEM;
 +
-+		if (iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
++		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
 +			expires = MAX_SCHEDULE_TIMEOUT;
 +		else
 +			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
@@ -152,9 +147,10 @@
 +	}
 +
 +	now = jiffies;
-+	if (time_before(now, expires))
-+		relative_ms =
-+			jiffies_to_msecs(expires) - jiffies_to_msecs(now);
++	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
++		relative_ms = EP_MAX_MSTIMEO;
++	else if (time_before(now, expires))
++		relative_ms = jiffies_to_msecs(expires - now);
 +	else
 +		relative_ms = 0;
 +
@@ -164,22 +160,22 @@
 +		      iocb->ki_nbytes, relative_ms);
 +
 +	/*
-+	 *  If we've added ourselves to the wait queue, there is a timeout
-+	 *  specified, and we didn't setup the timer yet, then go ahead and
-+	 *  add the timer.
++	 *  If a timeout was specified, ep_poll returned retry, and we have
++	 *  not yet registered a timer, go ahead and register one.
 +	 */
 +	if (ret == -EIOCBRETRY && !iocb->private) {
 +		iocb->private = timer;
-+		if (expires != MAX_SCHEDULE_TIMEOUT)
-+			add_timer(timer);
++		add_timer(timer);
 +	}
 +
-+	/* Perform cleanup if the poll has finished */
-+	if (ret > 0 || relative_ms == 0) {
++	/*
++	 *  Did we get any events?
++	 */
++	if (ret >= 0) {
 +		iocb->ki_cancel = NULL;
-+		iocb->private = NULL;
 +		(void)del_timer(timer);
 +		kfree(timer);
++		iocb->private = NULL;
 +	}
 +
 +	return ret;
@@ -187,7 +183,7 @@
  
  /*
   * Implement the event wait interface for the eventpoll file. It is the kernel
-@@ -1564,6 +1704,12 @@ retry:
+@@ -1564,6 +1709,12 @@ retry:
  
  	res = 0;
  	if (list_empty(&ep->rdllist)) {
@@ -200,23 +196,24 @@
  		/*
  		 * We don't have any available event to return to the caller.
  		 * We need to sleep here, and we will be wake up by
-@@ -1609,6 +1755,7 @@ retry:
+@@ -1608,7 +1759,7 @@ retry:
+ 	if (!res && eavail &&
  	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
  		goto retry;
- 
+-
 +out:
  	return res;
  }
  
 diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
-index e3ca0a4..1b9ba18 100644
+index e3ca0a4..292c811 100644
 --- a/include/linux/aio_abi.h
 +++ b/include/linux/aio_abi.h
 @@ -43,6 +43,7 @@ enum {
  	IOCB_CMD_NOOP = 6,
  	IOCB_CMD_PREADV = 7,
  	IOCB_CMD_PWRITEV = 8,
-+ 	IOCB_CMD_EPOLL_WAIT = 9,
++  	IOCB_CMD_EPOLL_WAIT = 9,
  };
  
  /* read() from /dev/aio returns these structures. */



From tomo at mail.berlios.de  Thu Nov 23 10:29:29 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 23 Nov 2006 10:29:29 +0100
Subject: [Stgt-svn] r669 - in trunk/usr: . iscsi
Message-ID: <200611230929.kAN9TTvq016529@sheep.berlios.de>

Author: tomo
Date: 2006-11-23 10:29:28 +0100 (Thu, 23 Nov 2006)
New Revision: 669

Added:
   trunk/usr/bd_sg.c
Modified:
   trunk/usr/Makefile
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/driver.h
   trunk/usr/iscsi/iscsid.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Add passthrough mode support that uses the Jens' bsg tree. sg3 can't
handle transport commands so now it can handle only SCSI
commands. Needs to work on sg4.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/Makefile	2006-11-23 09:29:28 UTC (rev 669)
@@ -1,7 +1,7 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
 	-I$(KERNELSRC)/include -I../include -I.
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o
+TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o bd_sg.o
 LIBS += -laio
 
 ifneq ($(IBMVIO),)

Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/bd_aio.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -89,8 +89,8 @@
 	free(dev);
 }
 
-static int bd_aio_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
-			     unsigned long *uaddr,
+static int bd_aio_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
+			     uint32_t datalen, unsigned long *uaddr,
 			     uint64_t offset, int *async, void *key)
 {
 	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/bd_mmap.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -55,9 +55,9 @@
 	free(dev);
 }
 
-static int bd_mmap_cmd_submit(struct tgt_device *dev, int rw, uint32_t datalen,
-			      unsigned long *uaddr, uint64_t offset, int *async,
-			      void *key)
+static int bd_mmap_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
+			      uint32_t datalen, unsigned long *uaddr,
+			      uint64_t offset, int *async, void *key)
 {
 	int fd = dev->fd;
 	void *p;

Added: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/bd_sg.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -0,0 +1,207 @@
+/*
+ * rawio routine
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <scsi/sg.h>
+#include <sys/epoll.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+
+/*
+ * this uses sg4, so you need to Jens' bsg tree now.
+ */
+
+static void sg_handler(int fd, int events, void *data)
+{
+	int i, err;
+	struct sg_io_hdr hdrs[64];
+	struct tgt_device *dev = data;
+
+	err = read(dev->fd, hdrs, sizeof(hdrs));
+	if (err < 0)
+		return;
+
+	for (i = 0; i < err / sizeof(hdrs[0]); i++) {
+		struct cmd *cmd = (void *) hdrs[i].usr_ptr;
+		dprintf("%d %p %u %u %x\n", i, hdrs[i].usr_ptr,
+			hdrs[i].status, hdrs[i].resid,
+			hdrs[i].info);
+		if (hdrs[i].resid)
+			cmd->len = hdrs[i].resid;
+		target_cmd_io_done(hdrs[i].usr_ptr, 0);
+	}
+}
+
+static struct tgt_device *bd_sg_open(char *path, int *fd, uint64_t *size)
+{
+	int err, maj, min;
+	char *sd, *bsgdev, buf[128];
+	struct stat64 st;
+	struct tgt_device *dev;
+
+	/* we assume something like /dev/sda */
+
+	*fd = backed_file_open(path, 0, size);
+	if (*fd < 0)
+		return NULL;
+
+	err = fstat64(*fd, &st);
+	if (err < 0) {
+		eprintf("can't get stat %d, %m\n", *fd);
+		goto close_fd;
+	}
+
+	if(!S_ISBLK(st.st_mode)) {
+		eprintf("only scsi devices are supported %s\n", path);
+		goto close_fd;
+	}
+
+	close(*fd);
+
+	sd = strrchr(path, '/');
+	if (!sd) {
+		eprintf("invalid path %s\n", path);
+		return NULL;
+	}
+
+	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
+	*fd = open(buf, O_RDONLY);
+	if (*fd < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		return NULL;
+	}
+
+	err = read(*fd, buf, sizeof(buf));
+	if (err < 0) {
+		eprintf("can't open %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	err = sscanf(buf, "%u:%u", &maj, &min);
+	if (err < 0) {
+		eprintf("can't get bsg major/minor number %s, %m\n", buf);
+		goto close_fd;
+	}
+
+	dprintf("%s's bsg device number: %d %d\n", path, maj, min);
+	close(*fd);
+
+	bsgdev = tempnam("/tmp", NULL);
+	if (!bsgdev) {
+		eprintf("can't get temporary name for bsg device, %m\n");
+		return NULL;
+	}
+
+	err = mknod(bsgdev, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
+		    maj << 8 | min);
+	if (err < 0) {
+		eprintf("can't create the bsg device %s, %m\n", bsgdev);
+		return NULL;
+	}
+
+	*fd = open(bsgdev, O_RDWR | O_NONBLOCK);
+
+	dprintf("%d %s\n", *fd, bsgdev);
+	unlink(bsgdev);
+	free(bsgdev);
+
+	if (*fd < 0) {
+		eprintf("can't open the bsg device %s, %m\n", bsgdev);
+		return NULL;
+	}
+
+	dev = zalloc(sizeof(*dev));
+	if (!dev)
+		goto close_fd;
+
+	err = tgt_event_add(*fd, EPOLLIN, sg_handler, dev);
+	if (err) {
+		free(dev);
+		goto close_fd;
+	}
+
+	return dev;
+close_fd:
+	close(*fd);
+	return NULL;
+}
+
+static void bd_sg_close(struct tgt_device *dev)
+{
+	tgt_event_del(dev->fd);
+	close(dev->fd);
+	free(dev);
+}
+
+static int bd_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
+{
+	return 0;
+}
+
+static int bd_sg_cmd_submit(struct tgt_device *dev, uint8_t *scb,
+			    int rw, uint32_t datalen, unsigned long *uaddr,
+			    uint64_t offset, int *async, void *key)
+{
+	int err;
+	struct sg_io_hdr hdr;
+
+	/* TODO sense */
+
+	dprintf("%x %d %u %lx\n", scb[0], rw, datalen, *uaddr);
+	memset(&hdr, 0, sizeof(hdr));
+	hdr.interface_id = 'S';
+	hdr.cmd_len = 16;
+	hdr.cmdp = scb;
+	hdr.dxfer_direction = rw ? SG_DXFER_TO_DEV : SG_DXFER_FROM_DEV;
+	hdr.dxfer_len = datalen;
+	hdr.dxferp = (void *) *uaddr;
+/* 	hdr.mx_sb_len = sizeof(sense); */
+/* 	hdr.sbp = sense; */
+	hdr.timeout = 30000;
+	hdr.usr_ptr = key;
+
+	*async = 1;
+
+	err = write(dev->fd, &hdr, sizeof(hdr));
+	if (err != sizeof(hdr))
+		eprintf("%d %m\n", err);
+	else
+		err = 0;
+	return err;
+}
+
+struct backedio_template sg_bdt = {
+	.bd_open		= bd_sg_open,
+	.bd_close		= bd_sg_close,
+	.bd_cmd_submit		= bd_sg_cmd_submit,
+	.bd_cmd_done		= bd_sg_cmd_done,
+};

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/driver.h	2006-11-23 09:29:28 UTC (rev 669)
@@ -1,4 +1,4 @@
-extern struct backedio_template mmap_bdt, aio_bdt;
+extern struct backedio_template mmap_bdt, aio_bdt, sg_bdt;
 
 struct tgt_driver {
 	const char *name;

Modified: trunk/usr/iscsi/iscsid.c
===================================================================
--- trunk/usr/iscsi/iscsid.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/iscsi/iscsid.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -950,11 +950,13 @@
 				list_add_tail(&task->c_list, &task->conn->tx_clist);
 		} else
 			err = target_cmd_queue(conn->session->tsih, req->cdb,
+					       req->flags & ISCSI_FLAG_CMD_WRITE,
 					       uaddr, req->lun,
 					       ntohl(req->data_length),
 					       cmd_attr(task), req->itt);
 	} else
 		err = target_cmd_queue(conn->session->tsih, req->cdb,
+				       req->flags & ISCSI_FLAG_CMD_WRITE,
 				       uaddr, req->lun, ntohl(req->data_length),
 				       cmd_attr(task), req->itt);
 
@@ -1194,7 +1196,7 @@
 
 	len = ntohl(req->data_length);
 	if (len) {
-		task->c_buffer = malloc(len);
+		task->c_buffer = valloc(len);
 		if (!task->c_buffer) {
 			iscsi_free_task(task);
 			return -ENOMEM;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/scsi.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -536,7 +536,7 @@
 	case WRITE_16:
 	case WRITE_VERIFY:
 		*offset = scsi_cmd_data_offset(scb);
-		result = submit(dev, *rw, datalen, uaddr, *offset, async, key);
+		result = submit(dev, scb, *rw, datalen, uaddr, *offset, async, key);
 		if (result == SAM_STAT_GOOD) {
 			*len = datalen;
 			*try_map = 1;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/target.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -254,16 +254,17 @@
 	}
 }
 
-int target_cmd_queue(int host_no, uint8_t *scb, unsigned long uaddr,
+int target_cmd_queue(int host_no, uint8_t *scb, uint8_t rw,
+		     unsigned long uaddr,
 		     uint8_t *lun, uint32_t data_len,
 		     int attribute, uint64_t tag)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
 	struct cmd *cmd;
-	int result, enabled, async, len = 0;
+	int result, enabled = 0, async, len = 0;
 	uint64_t offset, dev_id;
-	uint8_t rw = 0, mmapped = 0;
+	uint8_t mmapped = 0;
 
 	target = host_to_target(host_no);
 	if (!target) {
@@ -286,12 +287,32 @@
 	dprintf("%x %" PRIx64 "\n", scb[0], dev_id);
 
 	cmd->dev = device_lookup(target, dev_id);
+
+	/* FIXME */
+	if (target->target_iotype == SCSI_TARGET_RAWIO) {
+		memcpy(cmd->scb, scb, sizeof(cmd->scb));
+		dprintf("%u %s\n", scb[0], cmd->dev ? "do sg" : "fake");
+
+		/* we can't pass through REPORT_LUNS. */
+		if (cmd->dev && scb[0] != REPORT_LUNS) {
+			target->bdt->bd_cmd_submit(cmd->dev, cmd->scb, rw,
+						   data_len, &uaddr, offset,
+						   &async, (void *) cmd);
+			cmd->len = data_len;
+			cmd->uaddr = uaddr;
+			goto out;
+		} else
+			enabled = 1;
+	}
+
 	if (cmd->dev)
 		q = &cmd->dev->cmd_queue;
 	else
 		q = &target->cmd_queue;
 
-	enabled = cmd_enabled(q, cmd);
+	if (!enabled)
+		enabled = cmd_enabled(q, cmd);
+
 	if (enabled) {
 		result = scsi_cmd_perform(target->lid,
 					  host_no, scb,
@@ -323,7 +344,7 @@
 		cmd->uaddr = uaddr;
 		list_add_tail(&cmd->qlist, &q->queue);
 	}
-
+out:
 	return 0;
 }
 
@@ -648,16 +669,6 @@
 	return name;
 }
 
-enum scsi_target_state tgt_get_target_state(int tid)
-{
-	struct target *target;
-
-	target = target_lookup(tid);
-	if (!target)
-		return -ENOENT;
-	return target->target_state;
-}
-
 int tgt_set_target_iotype(int tid, char *str)
 {
 	int i, err = -EINVAL;
@@ -671,6 +682,10 @@
 		if (!strcmp(target_iotype[i].name, str)) {
 			target->target_iotype = target_iotype[i].value;
 			err = 0;
+
+			/* FIXME */
+			if (target->target_iotype == SCSI_TARGET_RAWIO)
+				target->bdt = &sg_bdt;
 			break;
 		}
 	}
@@ -678,7 +693,16 @@
 	return err;
 }
 
+enum scsi_target_state tgt_get_target_state(int tid)
+{
+	struct target *target;
 
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+	return target->target_state;
+}
+
 static struct {
 	enum scsi_target_state value;
 	char *name;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/tgtd.h	2006-11-23 09:29:28 UTC (rev 669)
@@ -37,9 +37,9 @@
 	unsigned long bddata[0] __attribute__ ((aligned (sizeof(unsigned long))));
 };
 
-typedef int (bkio_submit_t) (struct tgt_device *dev, int rw, uint32_t datalen,
-			     unsigned long *uaddr, uint64_t offset, int *async,
-			     void *key);
+typedef int (bkio_submit_t) (struct tgt_device *dev, uint8_t *scb,
+			     int rw, uint32_t datalen, unsigned long *uaddr,
+			     uint64_t offset, int *async, void *key);
 
 struct backedio_template {
 	struct tgt_device *(*bd_open)(char *path, int *fd, uint64_t *size);
@@ -73,7 +73,8 @@
 extern void tgt_event_del(int fd);
 extern int tgt_event_modify(int fd, int events);
 
-extern int target_cmd_queue(int host_no, uint8_t *scb, unsigned long uaddr,
+extern int target_cmd_queue(int host_no, uint8_t *scb, uint8_t rw,
+			    unsigned long uaddr,
 			    uint8_t *lun, uint32_t data_len,
 			    int attribute, uint64_t tag);
 extern void target_cmd_done(int host_no, uint64_t tag);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-11-22 16:14:56 UTC (rev 668)
+++ trunk/usr/tgtif.c	2006-11-23 09:29:28 UTC (rev 669)
@@ -130,7 +130,7 @@
 	switch (ev->hdr.type) {
 	case TGT_KEVENT_CMD_REQ:
 		target_cmd_queue(ev->p.cmd_req.host_no, ev->p.cmd_req.scb,
-				 0,
+				 0, 0,
 /* 				 ev->k.cmd_req.uaddr, */
 				 ev->p.cmd_req.lun, ev->p.cmd_req.data_len,
 				 ev->p.cmd_req.attribute, ev->p.cmd_req.tag);



From tomo at mail.berlios.de  Thu Nov 23 10:50:51 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 23 Nov 2006 10:50:51 +0100
Subject: [Stgt-svn] r670 - trunk
Message-ID: <200611230950.kAN9opPJ026187@sheep.berlios.de>

Author: tomo
Date: 2006-11-23 10:50:51 +0100 (Thu, 23 Nov 2006)
New Revision: 670

Removed:
   trunk/ibmvio
   trunk/iscsi
Log:
Remove old scripts to avoid confusion.


Deleted: trunk/ibmvio
===================================================================
--- trunk/ibmvio	2006-11-23 09:29:28 UTC (rev 669)
+++ trunk/ibmvio	2006-11-23 09:50:51 UTC (rev 670)
@@ -1,10 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start ibmvstgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-
-${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1
-${PWD}/usr/tgtadm --lld ibmvio --op new --tid 1 --lun 0 --params Path=/dev/sdb1
-${PWD}/usr/tgtadm --lld ibmvio --op bind --tid 1 --host 1

Deleted: trunk/iscsi
===================================================================
--- trunk/iscsi	2006-11-23 09:29:28 UTC (rev 669)
+++ trunk/iscsi	2006-11-23 09:50:51 UTC (rev 670)
@@ -1,9 +0,0 @@
-#!/bin/bash
-#
-# Temporary script to start istgt
-#
-
-PATH=/sbin:/bin:/usr/sbin:/usr/bin
-
-${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-${PWD}/usr/tgtadm --lld iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1



From tomo at mail.berlios.de  Thu Nov 23 11:31:50 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 23 Nov 2006 11:31:50 +0100
Subject: [Stgt-svn] r671 - trunk/doc
Message-ID: <200611231031.kANAVok6006215@sheep.berlios.de>

Author: tomo
Date: 2006-11-23 11:31:49 +0100 (Thu, 23 Nov 2006)
New Revision: 671

Added:
   trunk/doc/README.passthrough
Log:
Add passthrough mode README.


Added: trunk/doc/README.passthrough
===================================================================
--- trunk/doc/README.passthrough	2006-11-23 09:50:51 UTC (rev 670)
+++ trunk/doc/README.passthrough	2006-11-23 10:31:49 UTC (rev 671)
@@ -0,0 +1,48 @@
+Introducation
+-------------
+This document describes how to configure the passthrough mode, which
+directly passes SCSI commands to real SCSI devices.
+
+By default, tgt provides disk devices to initiators by using a IDE,
+SATA, SCSI, Device Mapper (DM), or Multiple Device (MD) device or a
+file. That is, tgt emulates SCSI devices. This offers great
+flexibility.
+
+In some cases, you need to directly pass SCSI commands to real SCSI
+devices comming from the initiators. For example, you might want to
+use the passthrough mode to provide SCSI tape drives to the
+initiators. Another example is SAN bridge (called SAN router too), to
+bind different SAN protocols. For example, an iSCSI-FC bridge can
+connect the existing FC network with a new iSCSI network, that is,
+provides FC storages to the iSCSI initiators.
+
+The passthrough mode support is not finished yet. tgt can pass SCSI
+commands but transport-layer commands. So tgt cannot handle TMFs
+now. This is mainly because Linux kernel does not enable user space to
+send transport-layer commands to LLDs yet. The sg version 4 will
+support this. We need to wait for some time.
+
+
+Starting
+-------------
+The passthrough mode uses the bsg feature, which is supposed to
+implement sg4 in the future.
+
+First, get the Jens' block tree and switch to the bsg branch:
+
+http://www.kernel.org/git/?p=linux/kernel/git/axboe/linux-2.6-block.git;a=summary
+
+
+Secondly, if you want to the passthrough mode with the ibmvio driver,
+pick up the tgt patches in the tgt tree, and apply them. If you use
+the iscsi driver, you can skip this.
+
+Thirdly, apply the IOCB_CMD_EPOLL_WAIT patch in the patch directory.
+
+You are ready. The following example is to export /dev/sda via the
+iscsi driver. Good luck.
+
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iotype --value rawio
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 --params Path=/dev/sda
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running



From tomo at mail.berlios.de  Sun Nov 26 03:54:54 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 03:54:54 +0100
Subject: [Stgt-svn] r672 - trunk/usr
Message-ID: <200611260254.kAQ2ss4a007641@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 03:54:52 +0100 (Sun, 26 Nov 2006)
New Revision: 672

Modified:
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Add VPD page 0x80 support taken from IET code.


Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-11-23 10:31:49 UTC (rev 671)
+++ trunk/usr/scsi.c	2006-11-26 02:54:52 UTC (rev 672)
@@ -216,13 +216,25 @@
 			*len = 7;
 			result = SAM_STAT_GOOD;
 		} else if (scb[2] == 0x80) {
+			int tmp = SCSI_SN_LEN;
+
 			data[1] = 0x80;
-			data[3] = 4;
+			data[3] = SCSI_SN_LEN;
 			memset(data + 4, 0x20, 4);
-			*len = 8;
+			*len = 4 + SCSI_SN_LEN;
 			result = SAM_STAT_GOOD;
+
+			if (dev && strlen(dev->scsi_sn)) {
+				char *p, *q;
+
+				p = data + 4 + tmp - 1;
+				q = dev->scsi_sn + SCSI_SN_LEN - 1;
+
+				for (; tmp > 0; tmp--, q)
+					*(p--) = *q;
+			}
 		} else if (scb[2] == 0x83) {
-			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
+			int tmp = SCSI_ID_LEN;
 
 			data[1] = 0x83;
 			data[3] = tmp + 4;

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-23 10:31:49 UTC (rev 671)
+++ trunk/usr/target.c	2006-11-26 02:54:52 UTC (rev 672)
@@ -168,6 +168,7 @@
 	device->path = p;
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, dev_id);
+	memset(device->scsi_sn, 0, sizeof(device->scsi_sn));
 
 	tgt_cmd_queue_init(&device->cmd_queue);
 	device_hlist_insert(target, device);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-23 10:31:49 UTC (rev 671)
+++ trunk/usr/tgtd.h	2006-11-26 02:54:52 UTC (rev 672)
@@ -3,7 +3,8 @@
 
 #include "log.h"
 
-#define	SCSI_ID_LEN	24
+#define SCSI_ID_LEN	24
+#define SCSI_SN_LEN	8
 
 enum scsi_target_iotype {
 	SCSI_TARGET_FILEIO = 1,
@@ -27,6 +28,7 @@
 	uint64_t size;
 	uint64_t lun;
 	char scsi_id[SCSI_ID_LEN];
+	char scsi_sn[SCSI_SN_LEN];
 	char *path;
 
 	struct list_head d_hlist;



From tomo at mail.berlios.de  Sun Nov 26 05:15:12 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 05:15:12 +0100
Subject: [Stgt-svn] r673 - trunk/usr
Message-ID: <200611260415.kAQ4FCks013244@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 05:15:11 +0100 (Sun, 26 Nov 2006)
New Revision: 673

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
Log:
Add device show option:

lily:/home/fujita/tgt# ./usr/tgtadm --lld iscsi --op show --mode logicalunit --tid 1 --lun 0
path=/dev/hdc1
scsi_id=deadbeaf1:0
scsi_sn=


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-26 02:54:52 UTC (rev 672)
+++ trunk/usr/mgmt.c	2006-11-26 04:15:11 UTC (rev 673)
@@ -149,12 +149,20 @@
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
 		break;
+	case OP_SHOW:
+		err = tgt_device_show(req->tid, req->lun, (char *) res->data,
+				      *rlen - sizeof(*res));
+		break;
 	default:
 		break;
 	}
 
-	res->err = err;
-	res->len = sizeof(*res);
+	if (req->op == OP_SHOW)
+		set_show_results(res, &err);
+	else {
+		res->err = err;
+		res->len = sizeof(*res);
+	}
 
 	return err;
 }

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-26 02:54:52 UTC (rev 672)
+++ trunk/usr/target.c	2006-11-26 04:15:11 UTC (rev 673)
@@ -208,6 +208,43 @@
 	return 0;
 }
 
+#define buffer_check(buf, total, len, rest)	\
+({						\
+	buf += len;				\
+	total += len;				\
+	rest -= len;				\
+	!rest;					\
+})
+
+int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest)
+{
+	int len, total = 0;
+	struct target *target;
+	struct tgt_device *device;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	device = device_lookup(target, dev_id);
+	if (!device) {
+		eprintf("device %" PRIu64 " not found\n", dev_id);
+		return -EINVAL;
+	}
+
+	len = snprintf(buf, rest, "path=%s\n", device->path);
+	if (buffer_check(buf, total, len, rest))
+		goto out;
+	len = snprintf(buf, rest, "scsi_id=%s\n", device->scsi_id);
+	if (buffer_check(buf, total, len, rest))
+		goto out;
+	len = snprintf(buf, rest, "scsi_sn=%s\n", device->scsi_sn);
+	if (buffer_check(buf, total, len, rest))
+		goto out;
+out:
+	return rest;
+}
+
 static int cmd_enabled(struct tgt_cmd_queue *q, struct cmd *cmd)
 {
 	int enabled = 0;



From tomo at mail.berlios.de  Sun Nov 26 06:11:40 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 06:11:40 +0100
Subject: [Stgt-svn] r674 - trunk/usr
Message-ID: <200611260511.kAQ5Bedw017055@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 06:11:39 +0100 (Sun, 26 Nov 2006)
New Revision: 674

Modified:
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtd.h
Log:
Add device update option:

lily:/home/fujita/tgt# ./usr/tgtadm --lld iscsi --op show --mode logicalunit --t
id 1 --lun 0
path=/dev/hdc1
scsi_id=deadbeaf1:0
scsi_sn=

lily:/home/fujita/tgt# ./usr/tgtadm --lld iscsi --op update --mode logicalunit --tid 1 --lun 0 --name scsi_id --value jfieojifeojip

lily:/home/fujita/tgt# ./usr/tgtadm --lld iscsi --op show --mode logicalunit --tid 1 --lun 0
path=/dev/hdc1
scsi_id=jfieojifeojip
scsi_sn=



Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-26 04:15:11 UTC (rev 673)
+++ trunk/usr/mgmt.c	2006-11-26 05:11:39 UTC (rev 674)
@@ -149,6 +149,9 @@
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
 		break;
+	case OP_UPDATE:
+		err = tgt_device_update(req->tid, req->lun, params);
+		break;
 	case OP_SHOW:
 		err = tgt_device_show(req->tid, req->lun, (char *) res->data,
 				      *rlen - sizeof(*res));

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-26 04:15:11 UTC (rev 673)
+++ trunk/usr/target.c	2006-11-26 05:11:39 UTC (rev 674)
@@ -224,12 +224,12 @@
 
 	target = target_lookup(tid);
 	if (!target)
-		return -ENOENT;
+		return rest;
 
 	device = device_lookup(target, dev_id);
 	if (!device) {
 		eprintf("device %" PRIu64 " not found\n", dev_id);
-		return -EINVAL;
+		return rest;
 	}
 
 	len = snprintf(buf, rest, "path=%s\n", device->path);
@@ -245,6 +245,33 @@
 	return rest;
 }
 
+int tgt_device_update(int tid, uint64_t dev_id, char *name)
+{
+	int err = 0;
+	char *val = name + strlen(name) + 1;
+	struct target *target;
+	struct tgt_device *device;
+
+	target = target_lookup(tid);
+	if (!target)
+		return -ENOENT;
+
+	device = device_lookup(target, dev_id);
+	if (!device) {
+		eprintf("device %" PRIu64 " not found\n", dev_id);
+		return -EINVAL;
+	}
+
+	if (!strcmp(name, "scsi_id"))
+		memcpy(device->scsi_id, val, sizeof(device->scsi_id) - 1);
+	if (!strcmp(name, "scsi_sn"))
+		memcpy(device->scsi_sn, val, sizeof(device->scsi_sn) - 1);
+	else
+		err = -EINVAL;
+
+	return err;
+}
+
 static int cmd_enabled(struct tgt_cmd_queue *q, struct cmd *cmd)
 {
 	int enabled = 0;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-26 04:15:11 UTC (rev 673)
+++ trunk/usr/tgtd.h	2006-11-26 05:11:39 UTC (rev 674)
@@ -65,6 +65,8 @@
 extern int ipc_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
+extern int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest);
+extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int tgt_target_create(int lld, int tid);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);



From tomo at mail.berlios.de  Sun Nov 26 07:11:55 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 07:11:55 +0100
Subject: [Stgt-svn] r675 - in trunk: doc usr/iscsi
Message-ID: <200611260611.kAQ6Bt8h028326@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 07:11:51 +0100 (Sun, 26 Nov 2006)
New Revision: 675

Modified:
   trunk/doc/README.iscsi
   trunk/usr/iscsi/target.c
Log:
set iqn with name/value option:

host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1
host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iqn --value iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz

TODO: check iqn set when a target starts.


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-26 05:11:39 UTC (rev 674)
+++ trunk/doc/README.iscsi	2006-11-26 06:11:51 UTC (rev 675)
@@ -28,7 +28,8 @@
 Let's create one target devce and add a logical unit to it:
 
 host:~/tgt$ su
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iqn --value iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 --params Path=/dev/hdc1
 
 

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/usr/iscsi/target.c	2006-11-26 05:11:39 UTC (rev 674)
+++ trunk/usr/iscsi/target.c	2006-11-26 06:11:51 UTC (rev 675)
@@ -106,17 +106,11 @@
 		{0, 1},
 	};
 
-	if (!name)
-		return -EINVAL;
-
-	dprintf("%d %s\n", tid, name);
-
 	target = malloc(sizeof(*target));
 	if (!target)
 		return -ENOMEM;
 
 	memset(target, 0, sizeof(*target));
-	memcpy(target->name, name, sizeof(target->name) - 1);
 
 	memcpy(target->session_param, default_tgt_session_param,
 	       sizeof(target->session_param));
@@ -129,23 +123,11 @@
 	return 0;
 }
 
-int iscsi_target_update(int tid, char *name)
+static int iscsi_session_param_update(struct iscsi_target* target, int idx, char *str)
 {
-	int idx, err;
+	int err;
 	unsigned int val;
-	char *str;
-	struct iscsi_target* target;
 
-	target = target_find_by_id(tid);
-	if (!target)
-		return -ENOENT;
-
-	str = name + strlen(name) + 1;
-
-	idx = param_index_by_name(name, session_keys);
-	if (idx < 0)
-		return idx;
-
 	err = param_str_to_val(session_keys, idx, str, &val);
 	if (err)
 		return err;
@@ -156,11 +138,36 @@
 
 	target->session_param[idx].val = val;
 
-	dprintf("%s %s %u\n", name, str, val);
+	dprintf("%s %s %u\n", session_keys[idx].name, str, val);
 
 	return 0;
 }
 
+int iscsi_target_update(int tid, char *name)
+{
+	int idx, err = -EINVAL;
+	char *str;
+	struct iscsi_target* target;
+
+	target = target_find_by_id(tid);
+	if (!target)
+		return -ENOENT;
+
+	str = name + strlen(name) + 1;
+
+	idx = param_index_by_name(name, session_keys);
+	if (idx >= 0)
+		err = iscsi_session_param_update(target, idx, str);
+	else {
+		if (!strcmp(name, "iqn")) {
+			memcpy(target->name, str, sizeof(target->name) - 1);
+			err = 0;
+		}
+	}
+
+	return err;
+}
+
 static int show_iscsi_param(char *buf, struct param *param, int rest)
 {
 	int i, len, total;



From tomo at mail.berlios.de  Sun Nov 26 08:59:11 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 08:59:11 +0100
Subject: [Stgt-svn] r676 - in trunk: doc usr
Message-ID: <200611260759.kAQ7xB4Q003295@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 08:59:10 +0100 (Sun, 26 Nov 2006)
New Revision: 676

Modified:
   trunk/doc/README.iscsi
   trunk/usr/bd_aio.c
   trunk/usr/bd_mmap.c
   trunk/usr/bd_sg.c
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.h
Log:
Remove params option from tgtadm. Use name/value always.


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/doc/README.iscsi	2006-11-26 07:59:10 UTC (rev 676)
@@ -30,7 +30,8 @@
 host:~/tgt$ su
 host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1
 host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iqn --value iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 --params Path=/dev/hdc1
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0
+host:~/tgt# ./usr/tgtadm --lld iscsi --op new --update logicalunit --tid 1 --lun 0 --name path --value /dev/hdc1
 
 
 You can get the current configuration:

Modified: trunk/usr/bd_aio.c
===================================================================
--- trunk/usr/bd_aio.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/bd_aio.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -49,51 +49,30 @@
 #define O_DIRECT 040000 /* who defines this?*/
 
 struct bd_aio_info {
-	int fd;
-
-	/* TODO: batch requests*/
+	/* TODO: batch requests */
 	struct iocb iocb[MAX_AIO_REQS];
 	struct io_event events[MAX_AIO_REQS];
 };
 
 extern io_context_t ctx;
 
-static struct tgt_device *bd_aio_open(char *path, int *fd, uint64_t *size)
+static int bd_aio_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
 {
-	struct tgt_device *dev;
-	struct bd_aio_info *bai;
-
-	dev = zalloc(sizeof(*dev) + sizeof(*bai));
-	if (!dev)
-		return NULL;
-
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
-	if (*fd < 0)
-		goto free_dev;
 
-	bai = (struct bd_aio_info *) dev->bddata;
-	bai->fd = *fd;
-
-	return dev;
-free_dev:
-	free(dev);
-	return NULL;
+	return *fd >= 0 ? 0 : *fd;
 }
 
 static void bd_aio_close(struct tgt_device *dev)
 {
-	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
-
-	tgt_event_del(bai->fd);
-	close(bai->fd);
-	free(dev);
+	tgt_event_del(dev->fd);
+	close(dev->fd);
 }
 
 static int bd_aio_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,
 			     uint32_t datalen, unsigned long *uaddr,
 			     uint64_t offset, int *async, void *key)
 {
-	struct bd_aio_info *bai = (struct bd_aio_info *) dev->bddata;
 	struct iocb iocb, *io;
 	int err;
 
@@ -102,13 +81,13 @@
 	io = &iocb;
 	memset(io, 0, sizeof(*io));
 
-	dprintf("%d %d %u %lx %" PRIx64 " %p %p\n", bai->fd, rw, datalen, *uaddr, offset,
+	dprintf("%d %d %u %lx %" PRIx64 " %p %p\n", dev->fd, rw, datalen, *uaddr, offset,
 		io, key);
 
 	if (rw == READ)
-		io_prep_pread(io, bai->fd, (void *) *uaddr, datalen, offset);
+		io_prep_pread(io, dev->fd, (void *) *uaddr, datalen, offset);
 	else
-		io_prep_pwrite(io, bai->fd, (void *) *uaddr, datalen, offset);
+		io_prep_pwrite(io, dev->fd, (void *) *uaddr, datalen, offset);
 
 	io->data = key;
 	err = io_submit(ctx, 1, &io);
@@ -122,8 +101,9 @@
 }
 
 struct backedio_template aio_bdt = {
-	.bd_open	= bd_aio_open,
-	.bd_close	= bd_aio_close,
-	.bd_cmd_submit	= bd_aio_cmd_submit,
-	.bd_cmd_done	= bd_aio_cmd_done,
+	.bd_datasize		= sizeof(struct bd_aio_info),
+	.bd_open		= bd_aio_open,
+	.bd_close		= bd_aio_close,
+	.bd_cmd_submit		= bd_aio_cmd_submit,
+	.bd_cmd_done		= bd_aio_cmd_done,
 };

Modified: trunk/usr/bd_mmap.c
===================================================================
--- trunk/usr/bd_mmap.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/bd_mmap.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -32,27 +32,16 @@
 #include "util.h"
 #include "tgtd.h"
 
-static struct tgt_device *bd_mmap_open(char *path, int *fd, uint64_t *size)
+static int bd_mmap_open(struct tgt_device *dev, char *path, int *fd, uint64_t *size)
 {
-	struct tgt_device *dev;
-
-	dev = zalloc(sizeof(*dev));
-	if (!dev)
-		return NULL;
-
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
-	if (*fd < 0) {
-		free(dev);
-		dev = NULL;
-	}
 
-	return dev;
+	return *fd >= 0 ? 0 : *fd;
 }
 
 static void bd_mmap_close(struct tgt_device *dev)
 {
 	close(dev->fd);
-	free(dev);
 }
 
 static int bd_mmap_cmd_submit(struct tgt_device *dev, uint8_t *scb, int rw,

Modified: trunk/usr/bd_sg.c
===================================================================
--- trunk/usr/bd_sg.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/bd_sg.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <stdio.h>
@@ -61,18 +62,18 @@
 	}
 }
 
-static struct tgt_device *bd_sg_open(char *path, int *fd, uint64_t *size)
+static int bd_sg_open(struct tgt_device *dev,
+		      char *path, int *fd, uint64_t *size)
 {
 	int err, maj, min;
 	char *sd, *bsgdev, buf[128];
 	struct stat64 st;
-	struct tgt_device *dev;
 
 	/* we assume something like /dev/sda */
 
 	*fd = backed_file_open(path, 0, size);
 	if (*fd < 0)
-		return NULL;
+		return *fd;
 
 	err = fstat64(*fd, &st);
 	if (err < 0) {
@@ -90,14 +91,14 @@
 	sd = strrchr(path, '/');
 	if (!sd) {
 		eprintf("invalid path %s\n", path);
-		return NULL;
+		return -EINVAL;
 	}
 
 	snprintf(buf, sizeof(buf), "/sys/class/bsg%s/dev", sd);
 	*fd = open(buf, O_RDONLY);
 	if (*fd < 0) {
 		eprintf("can't open %s, %m\n", buf);
-		return NULL;
+		return -errno;
 	}
 
 	err = read(*fd, buf, sizeof(buf));
@@ -118,14 +119,14 @@
 	bsgdev = tempnam("/tmp", NULL);
 	if (!bsgdev) {
 		eprintf("can't get temporary name for bsg device, %m\n");
-		return NULL;
+		return -errno;
 	}
 
 	err = mknod(bsgdev, S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH,
 		    maj << 8 | min);
 	if (err < 0) {
 		eprintf("can't create the bsg device %s, %m\n", bsgdev);
-		return NULL;
+		return -errno;
 	}
 
 	*fd = open(bsgdev, O_RDWR | O_NONBLOCK);
@@ -136,30 +137,25 @@
 
 	if (*fd < 0) {
 		eprintf("can't open the bsg device %s, %m\n", bsgdev);
-		return NULL;
+		return -errno;
 	}
 
-	dev = zalloc(sizeof(*dev));
-	if (!dev)
-		goto close_fd;
-
 	err = tgt_event_add(*fd, EPOLLIN, sg_handler, dev);
 	if (err) {
 		free(dev);
 		goto close_fd;
 	}
 
-	return dev;
+	return 0;
 close_fd:
 	close(*fd);
-	return NULL;
+	return err;
 }
 
 static void bd_sg_close(struct tgt_device *dev)
 {
 	tgt_event_del(dev->fd);
 	close(dev->fd);
-	free(dev);
 }
 
 static int bd_sg_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/mgmt.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -107,44 +107,14 @@
 	return err;
 }
 
-static void device_create_parser(char *args, char **path, char **devtype)
-{
-	char *p, *q;
-
-	if (isspace(*args))
-		args++;
-	if ((p = strchr(args, '\n')))
-		*p = '\0';
-
-	while ((p = strsep(&args, ","))) {
-		if (!p)
-			continue;
-
-		if (!(q = strchr(p, '=')))
-			continue;
-		*q++ = '\0';
-
-		if (!strcmp(p, "Path"))
-			*path = q;
-		else if (!strcmp(p, "Type"))
-			*devtype = q;
-	}
-}
-
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
 		       struct tgtadm_res *res, int *rlen)
 {
 	int err = -EINVAL;
-	char *path, *devtype;
 
 	switch (req->op) {
 	case OP_NEW:
-		path = devtype = NULL;
-		device_create_parser(params, &path, &devtype);
-		if (!path)
-			eprintf("Invalid path\n");
-		else
-			err = tgt_device_create(req->tid, req->lun, path);
+		err = tgt_device_create(req->tid, req->lun);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/target.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -131,52 +131,36 @@
 	INIT_LIST_HEAD(&q->queue);
 }
 
-int tgt_device_create(int tid, uint64_t dev_id, char *path)
+int tgt_device_create(int tid, uint64_t lun)
 {
 	struct target *target;
 	struct tgt_device *device;
-	char *p;
-	int dev_fd;
-	uint64_t size;
 
-	dprintf("%d %" PRIu64 " %s\n", tid, dev_id, path);
+	dprintf("%d %" PRIu64 "\n", tid, lun);
 
 	target = target_lookup(tid);
 	if (!target)
 		return -ENOENT;
 
-	device = device_lookup(target, dev_id);
+	device = device_lookup(target, lun);
 	if (device) {
-		eprintf("device %" PRIu64 " already exists\n", dev_id);
+		eprintf("device %" PRIu64 " already exists\n", lun);
 		return -EINVAL;
 	}
 
-	p = strdup(path);
-	if (!p)
+	device = zalloc(sizeof(*device) + target->bdt->bd_datasize);
+	if (!device)
 		return -ENOMEM;
 
-	device = target->bdt->bd_open(path, &dev_fd, &size);
-	if (!device) {
-		free(p);
-		return -EINVAL;
-	}
-
-	device->fd = dev_fd;
-	device->addr = 0;
-	device->size = size;
-	device->lun = dev_id;
-	device->path = p;
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
-		 "deadbeaf%d:%" PRIu64, tid, dev_id);
+		 "deadbeaf%d:%" PRIu64, tid, lun);
 	memset(device->scsi_sn, 0, sizeof(device->scsi_sn));
 
 	tgt_cmd_queue_init(&device->cmd_queue);
 	device_hlist_insert(target, device);
 	device_list_insert(target, device);
 
-	eprintf("Succeed to add a logical unit %" PRIu64 " to the target %d\n",
-		dev_id, tid);
-
+	eprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
 	return 0;
 }
 
@@ -205,6 +189,7 @@
 	device_list_remove(device);
 
 	target->bdt->bd_close(device);
+	free(device);
 	return 0;
 }
 
@@ -245,6 +230,36 @@
 	return rest;
 }
 
+static int tgt_device_path_update(struct target *target,
+				  struct tgt_device *device, char *path)
+{
+	char *p;
+	int err, dev_fd;
+	uint64_t size;
+
+	if (device->path) {
+		eprintf("path is already set %p\n", device->path);
+		return -EINVAL;
+	}
+
+	p = strdup(path);
+	if (!p)
+		return -ENOMEM;
+
+	err = target->bdt->bd_open(device, path, &dev_fd, &size);
+	if (err) {
+		free(p);
+		return -EINVAL;
+	}
+
+	device->fd = dev_fd;
+	device->addr = 0;
+	device->size = size;
+	device->path = p;
+
+	return 0;
+}
+
 int tgt_device_update(int tid, uint64_t dev_id, char *name)
 {
 	int err = 0;
@@ -262,9 +277,11 @@
 		return -EINVAL;
 	}
 
-	if (!strcmp(name, "scsi_id"))
+	if (!strcmp(name, "path"))
+		err = tgt_device_path_update(target, device, val);
+	else if (!strcmp(name, "scsi_id"))
 		memcpy(device->scsi_id, val, sizeof(device->scsi_id) - 1);
-	if (!strcmp(name, "scsi_sn"))
+	else if (!strcmp(name, "scsi_sn"))
 		memcpy(device->scsi_sn, val, sizeof(device->scsi_sn) - 1);
 	else
 		err = -EINVAL;

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/tgtadm.c	2006-11-26 07:59:10 UTC (rev 676)
@@ -72,7 +72,6 @@
 	{"aid", required_argument, NULL, 'a'},
 	{"hostno", required_argument, NULL, 'i'},
 	{"bus", required_argument, NULL, 'b'},
-	{"params", required_argument, NULL, 'p'},
 	{"name", required_argument, NULL, 'n'},
 	{"value", required_argument, NULL, 'v'},
 	{"debug", no_argument, NULL, 'd'},
@@ -80,7 +79,7 @@
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "l:o:m:t:s:c:u:i:a:b:p:n:v:dh";
+static char *short_options = "l:o:m:t:s:c:u:i:a:b:n:v:dh";
 
 static void usage(int status)
 {
@@ -301,14 +300,14 @@
 	int tid = -1;
 	uint32_t cid, hostno, aid;
 	uint64_t sid, lun;
-	char *params, *lldname;
+	char *lldname;
 	struct tgtadm_req *req;
 	char buf[BUFSIZE];
 	char *name, *value;
 	int mode = MODE_SYSTEM;
 
 	cid = hostno = aid = sid = lun = 0;
-	params = lldname = name = value = NULL;
+	lldname = name = value = NULL;
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, short_options,
@@ -344,9 +343,6 @@
 		case 'b':
 			hostno = bus_to_host(optarg);
 			break;
-		case 'p':
-			params = optarg;
-			break;
 		case 'n':
 			name = optarg;
 			break;
@@ -394,11 +390,6 @@
 	req->aid = aid;
 	req->host_no = hostno;
 
-	if (params) {
-		len = min(strlen(params), sizeof(buf) - len);
-		strncpy((char *) req->data, params, len);
-	}
-
 	if (name && value) {
 		int rest = sizeof(buf) - sizeof(*req);
 		char *p = (char *) req->data;

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-11-26 06:11:51 UTC (rev 675)
+++ trunk/usr/tgtd.h	2006-11-26 07:59:10 UTC (rev 676)
@@ -44,7 +44,8 @@
 			     uint64_t offset, int *async, void *key);
 
 struct backedio_template {
-	struct tgt_device *(*bd_open)(char *path, int *fd, uint64_t *size);
+	int bd_datasize;
+	int (*bd_open)(struct tgt_device *dev, char *path, int *fd, uint64_t *size);
 	void (*bd_close)(struct tgt_device *dev);
 	bkio_submit_t *bd_cmd_submit;
 	int (*bd_cmd_done) (int do_munmap, int do_free, uint64_t uaddr, int len);
@@ -63,7 +64,7 @@
 extern int kspace_send_cmd_res(int host_no, int len, int result,
 			       int rw, uint64_t addr, uint64_t tag);
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *path);
+extern int tgt_device_create(int tid, uint64_t lun);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_show(int tid, uint64_t dev_id, char *buf, int rest);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);



From tomo at mail.berlios.de  Sun Nov 26 09:00:32 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 09:00:32 +0100
Subject: [Stgt-svn] r677 - trunk
Message-ID: <200611260800.kAQ80WNo003570@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 09:00:32 +0100 (Sun, 26 Nov 2006)
New Revision: 677

Removed:
   trunk/Makefile
Log:
Remove Makefile on the top directory. We have tgt kernel code in the git tree.


Deleted: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-11-26 07:59:10 UTC (rev 676)
+++ trunk/Makefile	2006-11-26 08:00:32 UTC (rev 677)
@@ -1,20 +0,0 @@
-#
-# Need to use some magic to select what target drivers will be complied
-#
-
-#IBMVIO=1
-#ISCSI=1
-
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-export IBMVIO
-export ISCSI
-export KERNELSRC
-
-all:
-	make -C usr
-
-clean:
-	make -C usr clean



From tomo at mail.berlios.de  Sun Nov 26 15:58:59 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 15:58:59 +0100
Subject: [Stgt-svn] r678 - in trunk/usr: . iscsi
Message-ID: <200611261458.kAQEwxbX029382@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 15:58:59 +0100 (Sun, 26 Nov 2006)
New Revision: 678

Added:
   trunk/usr/tgtadm-iscsi.c
Modified:
   trunk/usr/Makefile
   trunk/usr/iscsi/account.c
Log:
Add tgtadm-iscsi, a wrapper of tgtadm.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-11-26 08:00:32 UTC (rev 677)
+++ trunk/usr/Makefile	2006-11-26 14:58:59 UTC (rev 678)
@@ -1,6 +1,7 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -g -D_LARGEFILE64_SOURCE \
 	-I$(KERNELSRC)/include -I../include -I.
-PROGRAMS = tgtd tgtadm
+
+PROGRAMS = tgtd tgtadm tgtadm-iscsi
 TGTD_OBJS = tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o bd_sg.o
 LIBS += -laio
 
@@ -35,5 +36,8 @@
 tgtadm: tgtadm.o
 	$(CC) $^ -o $@
 
+tgtadm-iscsi: tgtadm-iscsi.o
+	$(CC) $^ -o $@
+
 clean:
 	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o

Modified: trunk/usr/iscsi/account.c
===================================================================
--- trunk/usr/iscsi/account.c	2006-11-26 08:00:32 UTC (rev 677)
+++ trunk/usr/iscsi/account.c	2006-11-26 14:58:59 UTC (rev 678)
@@ -59,17 +59,12 @@
 	return NULL;
 }
 
-static int iscsi_create_account(void)
+static int iscsi_create_account(uint32_t uid)
 {
-	static uint32_t id;
-	uint32_t new_id;
 	struct iscsi_account *ac;
 
-	for (new_id = id + 1; iscsi_lookup_account(new_id) && new_id == id;
-	     new_id++)
-		;
-	if (new_id == id) {
-		eprintf("Too many accounts\n");
+	if (iscsi_lookup_account(uid)) {
+		eprintf("aid %u already exists\n", uid);
 		return EINVAL;
 	}
 
@@ -77,7 +72,7 @@
 	if (!ac)
 		return ENOMEM;
 
-	ac->id = id = new_id;
+	ac->id = uid;
 	ac->type = ACCOUNT_INVALID;
 	ac->ach.first = NULL;
 
@@ -241,7 +236,7 @@
 
 	switch (op) {
 	case OP_NEW:
-		err = iscsi_create_account();
+		err = iscsi_create_account(uid);
 		break;
 	case OP_DELETE:
 		eprintf("Not implemented yet\n");

Added: trunk/usr/tgtadm-iscsi.c
===================================================================
--- trunk/usr/tgtadm-iscsi.c	2006-11-26 08:00:32 UTC (rev 677)
+++ trunk/usr/tgtadm-iscsi.c	2006-11-26 14:58:59 UTC (rev 678)
@@ -0,0 +1,479 @@
+/*
+ * iSCSI target management interface
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <ctype.h>
+#include <dirent.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "util.h"
+#include "list.h"
+#include "tgtd.h"
+#include "tgtadm.h"
+#include "driver.h"
+
+/*
+ * This program is just a wrapper of tgtadm. Maybe it would be better
+ * to implement this program by using Python or Perl.
+ */
+
+static char cmdstr[] = "tgtadm --lld iscsi";
+static char cmdline[2048];
+
+static struct option const long_options[] =
+{
+	{"op", required_argument, NULL, 'o'},
+	{"tid", required_argument, NULL, 't'},
+	{"sid", required_argument, NULL, 's'},
+	{"cid", required_argument, NULL, 'c'},
+	{"lun", required_argument, NULL, 'u'},
+	{"aid", required_argument, NULL, 'a'},
+	{"iqn", required_argument, NULL, 'i'},
+	{"path", required_argument, NULL, 'p'},
+	{"name", required_argument, NULL, 'n'},
+	{"value", required_argument, NULL, 'v'},
+	{"start", no_argument, NULL, 'S'},
+	{"stop", no_argument, NULL, 'P'},
+	{"user", required_argument, NULL, 'r'},
+	{"password", required_argument, NULL, 'w'},
+	{"in", no_argument, NULL, 'I'},
+	{"out", no_argument, NULL, 'O'},
+	{"debug", no_argument, NULL, 'd'},
+	{"help", no_argument, NULL, 'h'},
+	{NULL, 0, NULL, 0},
+};
+
+static char *short_options = "o:t:s:c:u:a:n:i:p:v:SPr:w:IOdh";
+
+static void usage(int status)
+{
+}
+
+static int target_op(int op, int tid, char *iqn, char *name, char *value,
+		     int start, int stop)
+{
+	int err = -EINVAL;
+	FILE *fp;
+
+	if (start && stop) {
+		fprintf(stderr,
+			"Cannot start and stop a target at the same time\n");
+		exit(1);
+	}
+
+	if (start || stop)
+		op = OP_UPDATE;
+
+	switch (op) {
+	case OP_NEW:
+		if (!iqn) {
+			fprintf(stderr, "specifiy target's iqn\n");
+			exit(1);
+		}
+
+		snprintf(cmdline, sizeof(cmdline), "%s -o new -m tgt -t %d",
+			 cmdstr, tid);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to create a new target\n");
+			exit(1);
+		}
+
+		snprintf(cmdline, sizeof(cmdline), "%s -o update -m tgt -t %d"
+			 " -n iqn -v %s", cmdstr, tid, iqn);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+			/* remove the target. */
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to create a new target\n");
+			exit(1);
+			/* remove the target. */
+		}
+		break;
+	case OP_SHOW:
+		if (tid == -1)
+			snprintf(cmdline, sizeof(cmdline), "%s -o show -m tgt",
+				 cmdstr);
+		else
+			snprintf(cmdline, sizeof(cmdline),
+				 "%s -o show -m tgt -t %d", cmdstr, tid);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		while (fgets(cmdline, sizeof(cmdline), fp))
+			fputs(cmdline, stdout);
+
+		err = pclose(fp);
+
+		break;
+	case OP_UPDATE:
+		if (start || stop)
+			snprintf(cmdline, sizeof(cmdline),
+				 "%s -o update -m tgt -t %d -n state -v %s",
+				 cmdstr, tid, start ? "running" : "suspended");
+		else
+			snprintf(cmdline, sizeof(cmdline),
+				 "%s -o update -m tgt -t %d -n %s -v %s",
+				 cmdstr, tid, name, value);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to change the state\n");
+			exit(1);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int session_op(int op, int tid, uint64_t sid, char *name, char *value)
+{
+	int err = -EINVAL;
+	FILE *fp;
+
+	switch (op) {
+	case OP_SHOW:
+		if (sid)
+			snprintf(cmdline, sizeof(cmdline),
+				 "%s -o show -m sess -t %d -s %" PRIu64,
+				 cmdstr, tid, sid);
+		else
+			snprintf(cmdline, sizeof(cmdline),
+				 "%s -o show -m sess -t %d", cmdstr, tid);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		while (fgets(cmdline, sizeof(cmdline), fp))
+			fputs(cmdline, stdout);
+
+		err = pclose(fp);
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+
+static int logicalunit_op(int op, int tid, uint64_t lun, char *path,
+			  char *name, char *value)
+{
+	int err = -EINVAL;
+	FILE *fp;
+
+	switch (op) {
+	case OP_NEW:
+		if (!path) {
+			fprintf(stderr, "specifiy logical unit's path\n");
+			exit(1);
+		}
+
+		snprintf(cmdline, sizeof(cmdline), "%s -o new -m lu -t %d -u %" PRIu64,
+			 cmdstr, tid, lun);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to create a logical unit\n");
+			exit(1);
+			/* remove the lu. */
+		}
+
+		snprintf(cmdline, sizeof(cmdline), "%s -o update -m lu -t %d -u %" PRIu64
+			 " -n path -v %s", cmdstr, tid, lun, path);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+
+			/* remove the lu */
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to create a logical unit\n");
+			exit(1);
+			/* remove the lu. */
+		}
+		break;
+	case OP_SHOW:
+		snprintf(cmdline, sizeof(cmdline),
+			 "%s -o show -m lu -t %d -u %" PRIu64,
+			 cmdstr, tid, lun);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		while (fgets(cmdline, sizeof(cmdline), fp))
+			fputs(cmdline, stdout);
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to show a logical unit\n");
+			exit(1);
+			/* remove the lu. */
+		}
+	}
+
+	return err;
+}
+
+static int account_op(int op, int tid, int in, int out, int aid,
+		      char *user, char *password, char *name, char *value)
+{
+	int err = -EINVAL;
+	FILE *fp;
+
+	switch (op) {
+	case OP_NEW:
+		/* TODO: error handling */
+
+		if ((!in && !out) || (in && out)) {
+			fprintf(stderr, "specify incoming or outgoing\n");
+			exit(1);
+		}
+
+		snprintf(cmdline, sizeof(cmdline), "%s -o new -m account -a %u",
+			 cmdstr, aid);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		err = pclose(fp);
+		if (err) {
+			fprintf(stderr, "fail to create a logical unit\n");
+			exit(1);
+		}
+
+		snprintf(cmdline, sizeof(cmdline),
+			 "%s -o update -m account -a %u -n User -v %s",
+			 cmdstr, aid, user);
+
+		fp = popen(cmdline, "r");
+		if (!fp)
+			exit(1);
+
+		err = pclose(fp);
+		if (err)
+			exit(1);
+
+		snprintf(cmdline, sizeof(cmdline),
+			 "%s -o update -m account -a %u -n Password -v %s",
+			 cmdstr, aid, password);
+		fp = popen(cmdline, "r");
+		if (!fp)
+			exit(1);
+
+		err = pclose(fp);
+		if (err)
+			exit(1);
+
+		snprintf(cmdline, sizeof(cmdline),
+			 "%s -o update -m account -a %u -n Type -v %s",
+			 cmdstr, aid, in ? "Incoming" : "Outgoing");
+		fp = popen(cmdline, "r");
+		if (!fp)
+			exit(1);
+
+		err = pclose(fp);
+		if (err)
+			exit(1);
+
+		snprintf(cmdline, sizeof(cmdline),
+			 "%s -o bind -m account -t %d -a %u",
+			 cmdstr, tid, aid);
+		fp = popen(cmdline, "r");
+		if (!fp)
+			exit(1);
+
+		err = pclose(fp);
+		if (err)
+			exit(1);
+		break;
+	case OP_SHOW:
+		snprintf(cmdline, sizeof(cmdline), "%s -o show -m account -t %d",
+			 cmdstr, tid);
+		fp = popen(cmdline, "r");
+		if (!fp) {
+			fprintf(stderr, "fail to exec %s\n", cmdstr);
+			exit(1);
+		}
+
+		while (fgets(cmdline, sizeof(cmdline), fp))
+			fputs(cmdline, stdout);
+
+		err = pclose(fp);
+		if (err)
+			exit(1);
+	}
+
+	return err;
+}
+
+static int str_to_op(char *str)
+{
+	int op;
+
+	if (!strcmp("new", str))
+		op = OP_NEW;
+	else if (!strcmp("delete", str))
+		op = OP_DELETE;
+	else if (!strcmp("bind", str))
+		op = OP_BIND;
+	else if (!strcmp("show", str))
+		op = OP_SHOW;
+	else if (!strcmp("update", str))
+		op = OP_UPDATE;
+	else
+		op = -1;
+
+	return op;
+}
+
+int main(int argc, char **argv)
+{
+	int ch, longindex;
+	char *name, *value, *iqn, *path, *user, *password;
+	int err = -EINVAL, op = -1, tid = -1, mode = 0;
+	uint32_t cid, aid = 0;
+	uint64_t sid = 0, lun = -1;
+	int start, stop, in, out;
+
+	start = stop = in = out = 0;
+	name = value = iqn = path = user = password = NULL;
+
+	while ((ch = getopt_long(argc, argv, short_options,
+				 long_options, &longindex)) >= 0) {
+		switch (ch) {
+		case 'o':
+			op = str_to_op(optarg);
+			break;
+		case 't':
+			tid = strtol(optarg, NULL, 10);
+			mode |= (1 << MODE_TARGET);
+			break;
+		case 's':
+			sid = strtoull(optarg, NULL, 10);
+			mode |= (1 << MODE_SESSION);
+			break;
+		case 'c':
+			cid = strtoul(optarg, NULL, 10);
+			mode |= (1 << MODE_CONNECTION);
+			break;
+		case 'u':
+			lun = strtoull(optarg, NULL, 10);
+			mode |= (1 << MODE_DEVICE);
+			break;
+		case 'a':
+			aid = strtol(optarg, NULL, 10);
+			mode |= (1 << MODE_ACCOUNT);
+			break;
+		case 'i':
+			iqn = optarg;
+			break;
+		case 'p':
+			path = optarg;
+			break;
+		case 'n':
+			name = optarg;
+			break;
+		case 'v':
+			value = optarg;
+			break;
+		case 'S':
+			start = 1;
+			break;
+		case 'P':
+			stop = 1;
+			break;
+		case 'r':
+			user = optarg;
+			break;
+		case 'w':
+			password = optarg;
+			break;
+		case 'I':
+			in = 1;
+			break;
+		case 'O':
+			out = 1;
+			break;
+		case 'h':
+			usage(0);
+			break;
+		default:
+			usage(-1);
+		}
+	}
+
+	if (mode & (1 << MODE_ACCOUNT))
+		account_op(op, tid, in, out, aid, user, password, name, value);
+	else if (mode & (1 << MODE_DEVICE))
+		err = logicalunit_op(op, tid, lun, path, name, value);
+	else if (mode & (1 << MODE_CONNECTION))
+		;
+	else if (mode & (1 << MODE_SESSION))
+		err = session_op(op, tid, sid, name, value);
+	else
+		err = target_op(op, tid, iqn, name, value, start, stop);
+
+	return err;
+}



From tomo at mail.berlios.de  Sun Nov 26 16:57:55 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 16:57:55 +0100
Subject: [Stgt-svn] r679 - trunk/usr
Message-ID: <200611261557.kAQFvtZG003617@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 16:57:54 +0100 (Sun, 26 Nov 2006)
New Revision: 679

Modified:
   trunk/usr/tgtadm-iscsi.c
Log:
Add PATH workaround


Modified: trunk/usr/tgtadm-iscsi.c
===================================================================
--- trunk/usr/tgtadm-iscsi.c	2006-11-26 14:58:59 UTC (rev 678)
+++ trunk/usr/tgtadm-iscsi.c	2006-11-26 15:57:54 UTC (rev 679)
@@ -42,7 +42,8 @@
  * to implement this program by using Python or Perl.
  */
 
-static char cmdstr[] = "tgtadm --lld iscsi";
+/* static char cmdstr[] = "tgtadm --lld iscsi"; */
+static char cmdstr[256];
 static char cmdline[2048];
 
 static struct option const long_options[] =
@@ -400,6 +401,20 @@
 	start = stop = in = out = 0;
 	name = value = iqn = path = user = password = NULL;
 
+	/* workaround */
+	{
+		char *p;
+
+		if (*argv[0] == '.') {
+			getcwd(cmdstr, sizeof(cmdstr));
+			sprintf(cmdstr + strlen(cmdstr), "/%s", argv[0] + 1);
+		} else
+			strcpy(cmdstr, argv[0]);
+
+		p = strstr(cmdstr, "tgtadm-iscsi");
+		sprintf(p, "tgtadm --lld iscsi");
+	}
+
 	while ((ch = getopt_long(argc, argv, short_options,
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {



From tomo at mail.berlios.de  Sun Nov 26 17:35:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 17:35:25 +0100
Subject: [Stgt-svn] r680 - trunk/usr
Message-ID: <200611261635.kAQGZPD2009326@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 17:35:25 +0100 (Sun, 26 Nov 2006)
New Revision: 680

Modified:
   trunk/usr/target.c
Log:
Fix device creation bug.


Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-11-26 15:57:54 UTC (rev 679)
+++ trunk/usr/target.c	2006-11-26 16:35:25 UTC (rev 680)
@@ -152,6 +152,8 @@
 	if (!device)
 		return -ENOMEM;
 
+	device->lun = lun;
+
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, lun);
 	memset(device->scsi_sn, 0, sizeof(device->scsi_sn));



From tomo at mail.berlios.de  Sun Nov 26 17:53:25 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Sun, 26 Nov 2006 17:53:25 +0100
Subject: [Stgt-svn] r681 - trunk/doc
Message-ID: <200611261653.kAQGrP1I012883@sheep.berlios.de>

Author: tomo
Date: 2006-11-26 17:53:24 +0100 (Sun, 26 Nov 2006)
New Revision: 681

Added:
   trunk/doc/README.iscsi-advance
Modified:
   trunk/doc/README.iscsi
Log:
Add tgtadm-iscsi howto


Modified: trunk/doc/README.iscsi
===================================================================
--- trunk/doc/README.iscsi	2006-11-26 16:35:25 UTC (rev 680)
+++ trunk/doc/README.iscsi	2006-11-26 16:53:24 UTC (rev 681)
@@ -1,14 +1,13 @@
 Preface
 -------------
-This document describes how to configure the iSCSI target driver with tgtadm.
+This document describes how to configure the iSCSI target driver with
+tgtadm-iscsi, which is a wrapper of tgtadm, protocol-independent
+management tool.
 
-tgtadm is not so handly; you can need several commands to do one thing
-mainly because it must be generic to work for all the transport protocols.
+If you are interested in management with tgtadm, refer to
+README.iscsi.advance.
 
-We plan to implement a frontend tool, iscsitgtadm, to wrap tgtadm and
-offer considerably more user friendly interface in the future.
 
-
 Starting the daemon
 -------------
 Try the following commands:
@@ -28,15 +27,13 @@
 Let's create one target devce and add a logical unit to it:
 
 host:~/tgt$ su
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode target --tid 1
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name iqn --value iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --update logicalunit --tid 1 --lun 0 --name path --value /dev/hdc1
+host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --iqn iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --lun 0 --path /dev/hdc1
 
 
 You can get the current configuration:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+host:~/tgt# ./usr/tgtadm-iscsi --op show
 tid 1: lld name iscsi: state suspended
         lun 0: path /dev/hdc1
 
@@ -48,8 +45,8 @@
 
 You can add lots of logical units:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 --params Path=/var/tmp/image
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --lun 1 --path /var/tmp/image
+host:~/tgt# ./usr/tgtadm-iscsi --op show
 tid 1: lld name iscsi: state suspended
         lun 1: path /var/tmp/image
         lun 0: path /dev/hdc1
@@ -57,7 +54,7 @@
 
 You can get iSCSI parameters of the target:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
+host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1
 iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 MaxRecvDataSegmentLength=8192
 MaxXmitDataSegmentLength=8192
@@ -83,12 +80,11 @@
 You can chage iSCSI parameters like the folloing (e.g. set
 MaxRecvDataSegmentLength to 16384):
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
+host:~/tgt# ./usr/tgtadm-iscsi --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
 
-
 You can get iSCSI parameters again to see it change:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show --tid 1
+host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1
 iqn=iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
 MaxRecvDataSegmentLength=16384
 MaxXmitDataSegmentLength=8192
@@ -111,79 +107,27 @@
 MaxConnections=1
 
 
-After the target the target accepted some initiators, you can see them:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1
-sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel
-sid:281474980708864 initiator:iqn.1987-05.com.cisco:01.4438aca09387
-
-
-You can see the negotiated iSCSI parameters between the target and the
-initiator:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode session --op show --tid 1 --sid  281474980708864
-MaxRecvDataSegmentLength=8192
-MaxXmitDataSegmentLength=1024
-HeaderDigest=None
-DataDigest=None
-InitialR2T=Yes
-MaxOutstandingR2T=1
-ImmediateData=Yes
-FirstBurstLength=65536
-MaxBurstLength=262144
-DataPDUInOrder=Yes
-DataSequenceInOrder=Yes
-ErrorRecoveryLevel=0
-IFMarker=No
-OFMarker=No
-DefaultTime2Wait=2
-DefaultTime2Retain=0
-OFMarkInt=Reject
-IFMarkInt=Reject
-MaxConnections=1
-
-
-You can see the initiator information:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode connection --op show --tid 1 --sid  281474980708864
-cid:0 ip:192.168.11.5
-
-
 Security
 -------------
-Let's create a new account:
+Let's create a new incoming account:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op new --mode account
+host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --aid 0 --user tomo --password jfeo --in
 
-You need to set the user, passowrd, type of the account:
+Make another one:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name User --value tomo
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Password --value hoge
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode account --aid 1 --name Type --value Incoming
+host:~/tgt# ./usr/tgtadm-iscsi --op new --tid 1 --aid 1 --user apple --password orange --in
 
 
-Just make sure what we have:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account
-aid:1 Type:Incoming User:tomo Password:hoge
-
-
-We have one account, however, this account does not be assigned to our target:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
-
-
-You can assign this account to your target:
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --op bind --mode account --tid 1 --aid 1
-
-
 You can see the result:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op show --mode account --tid 1
-aid:1 Type:Incoming User:tomo Password:hoge
+host:~/tgt# ./usr/tgtadm-iscsi --op show --tid 1 --aid 0
+aid:0 Type:Incoming User:tomo Password:jfeo
+aid:1 Type:Incoming User:apple Password:orange
 
 
+Specifying aid (account id) to see all the accounts is a bit
+strange. Probably, this will be changed later on.
+
 You can assign one account to lots of targets. Each target can have 16
 accounts. We don't support removing or unbinding accounts now.
 
@@ -193,17 +137,16 @@
 Now this target is ready to accept initiators. Make sure what you have
 now once again:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+host:~/tgt# ./usr/tgtadm-iscsi --op show
 tid 1: lld name iscsi: state suspended
         lun 1: path /var/tmp/image
         lun 0: path /dev/hdc1
 
 
-If you are happy about it:
+If you've done the configuration:
 
-host:~/tgt# ./usr/tgtadm --lld iscsi --op update --mode target --tid 1 --name state --value running
-
-host:~/tgt# ./usr/tgtadm --lld iscsi --mode target --op show
+host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --start
+host:~/tgt# ./usr/tgtadm-iscsi --op show
 tid 1: lld name iscsi: state running
         lun 1: path /var/tmp/image
         lun 0: path /dev/hdc1
@@ -212,6 +155,38 @@
 Now your target accepts initiators.
 
 
+After the target the target accepted some initiators, you can see them:
+
+host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --sid 0
+sid:562950876233792 initiator:iqn.1991-05.com.microsoft:kernel
+sid:281474980708864 initiator:iqn.1987-05.com.cisco:01.4438aca09387
+
+
+You can see the negotiated iSCSI parameters between the target and the
+initiator by specifying sid:
+
+host:~/tgt# ./usr/tgtadm-iscsi --tid 1 --sid  281474980708864
+MaxRecvDataSegmentLength=8192
+MaxXmitDataSegmentLength=1024
+HeaderDigest=None
+DataDigest=None
+InitialR2T=Yes
+MaxOutstandingR2T=1
+ImmediateData=Yes
+FirstBurstLength=65536
+MaxBurstLength=262144
+DataPDUInOrder=Yes
+DataSequenceInOrder=Yes
+ErrorRecoveryLevel=0
+IFMarker=No
+OFMarker=No
+DefaultTime2Wait=2
+DefaultTime2Retain=0
+OFMarkInt=Reject
+IFMarkInt=Reject
+MaxConnections=1
+
+
 Shutdown
 -------------
 host:~/tgt# killall -9 tgtd

Copied: trunk/doc/README.iscsi-advance (from rev 677, trunk/doc/README.iscsi)



