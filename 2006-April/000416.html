<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r429 - branches/use-scsi-ml/istgt/kernel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r429%20-%20branches/use-scsi-ml/istgt/kernel&In-Reply-To=%3C200604291347.k3TDlQXL016983%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000415.html">
   <LINK REL="Next"  HREF="000417.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r429 - branches/use-scsi-ml/istgt/kernel</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r429%20-%20branches/use-scsi-ml/istgt/kernel&In-Reply-To=%3C200604291347.k3TDlQXL016983%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r429 - branches/use-scsi-ml/istgt/kernel">tomo at berlios.de
       </A><BR>
    <I>Sat Apr 29 15:47:26 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000415.html">[Stgt-svn] r428 - branches/use-scsi-ml/istgt/kernel
</A></li>
        <LI>Next message: <A HREF="000417.html">[Stgt-svn] r430 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#416">[ date ]</a>
              <a href="thread.html#416">[ thread ]</a>
              <a href="subject.html#416">[ subject ]</a>
              <a href="author.html#416">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-04-29 15:47:13 +0200 (Sat, 29 Apr 2006)
New Revision: 429

Removed:
   branches/use-scsi-ml/istgt/kernel/conn.c
   branches/use-scsi-ml/istgt/kernel/digest.c
   branches/use-scsi-ml/istgt/kernel/digest.h
   branches/use-scsi-ml/istgt/kernel/iscsi.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
   branches/use-scsi-ml/istgt/kernel/nthread.c
Log:
Remove old files

Deleted: branches/use-scsi-ml/istgt/kernel/conn.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/conn.c	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/conn.c	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">roman at ardistech.com</A>&gt;
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-#include &lt;linux/file.h&gt;
-#include &lt;linux/ip.h&gt;
-#include &lt;net/tcp.h&gt;
-#include &lt;scsi/scsi_host.h&gt;
-#include &lt;scsi/scsi_transport_iscsi.h&gt;
-
-#include &lt;iscsi.h&gt;
-#include &lt;digest.h&gt;
-
-int conn_close(struct iscsi_conn *conn)
-{
-	/* TODO: pass in error */
-	iscsi_conn_error(conn-&gt;cls_conn, ISCSI_ERR_CONN_FAILED);
-	return 0;
-}
-
-static void state_change(struct sock *sk)
-{
-	struct iscsi_conn *conn = sk-&gt;sk_user_data;
-	struct iscsi_session *session = conn-&gt;session;
-
-	if (sk-&gt;sk_state != TCP_ESTABLISHED)
-		conn_close(conn);
-	else
-		nthread_wakeup(session);
-
-	session-&gt;nthread_info.old_state_change(sk);
-}
-
-static void data_ready(struct sock *sk, int len)
-{
-	struct iscsi_conn *conn = sk-&gt;sk_user_data;
-	struct iscsi_session *session = conn-&gt;session;
-
-	nthread_wakeup(session);
-	session-&gt;nthread_info.old_data_ready(sk, len);
-}
-
-int
-istgt_conn_bind(struct iscsi_cls_session *cls_session,
-		struct iscsi_cls_conn *cls_conn, uint32_t transport_fd,
-		int is_leading)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	int opt = 1, err;
-	mm_segment_t oldfs;
-
-	dprintk(&quot;%llu\n&quot;, (unsigned long long) session-&gt;sid);
-
-	conn-&gt;file = fget(transport_fd);
-
-	conn-&gt;sock = sockfd_lookup(transport_fd, &amp;err);
-	conn-&gt;sock-&gt;sk-&gt;sk_user_data = conn;
-
-	write_lock(&amp;conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
-	session-&gt;nthread_info.old_state_change = conn-&gt;sock-&gt;sk-&gt;sk_state_change;
-	conn-&gt;sock-&gt;sk-&gt;sk_state_change = state_change;
-
-	session-&gt;nthread_info.old_data_ready = conn-&gt;sock-&gt;sk-&gt;sk_data_ready;
-	conn-&gt;sock-&gt;sk-&gt;sk_data_ready = data_ready;
-	write_unlock(&amp;conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	conn-&gt;sock-&gt;ops-&gt;setsockopt(conn-&gt;sock, SOL_TCP, TCP_NODELAY,
-				    (void *)&amp;opt, sizeof(opt));
-	set_fs(oldfs);
-	return 0;
-}
-
-int conn_free(struct iscsi_conn *conn)
-{
-	struct completion *wait = conn-&gt;free_done;
-
-	dprintk(&quot;%p %#Lx %u\n&quot;, conn-&gt;session,
-		(unsigned long long) conn-&gt;session-&gt;sid, conn-&gt;cid);
-
-	BUG_ON(atomic_read(&amp;conn-&gt;nr_cmnds));
-	BUG_ON(!list_empty(&amp;conn-&gt;pdu_list));
-	BUG_ON(!list_empty(&amp;conn-&gt;write_list));
-
-	list_del(&amp;conn-&gt;list);
-	list_del(&amp;conn-&gt;poll_list);
-
-	digest_cleanup(conn);
-
-	sock_release(conn-&gt;sock);
-
-	if (wait)
-		complete(wait);
-
-	return 0;
-}
-
-void istgt_conn_destroy(struct iscsi_cls_conn *cls_conn)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-	DECLARE_COMPLETION(wait);
-
-	conn-&gt;free_done = &wait;
-
-	if (test_and_clear_bit(CONN_ACTIVE, &amp;conn-&gt;state))
-		set_bit(CONN_CLOSING, &amp;conn-&gt;state);
-
-	nthread_wakeup(session);
-	wait_for_completion(&amp;wait);
-}
-
-struct iscsi_cls_conn *istgt_conn_create(struct iscsi_cls_session *cls_session,
-					 uint32_t cid)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_cls_conn *cls_conn;
-	struct iscsi_conn *conn;
-
-	dprintk(&quot;%#Lx:%u\n&quot;, (unsigned long long) session-&gt;sid, cid);
-
-        cls_conn = iscsi_create_conn(cls_session, cid);
-	if (!cls_conn)
-		return NULL;
-
-	conn = cls_conn-&gt;dd_data;
-	memset(conn, 0, sizeof(*conn));
-
-	conn-&gt;cls_conn = cls_conn;
-	conn-&gt;session = session;
-	conn-&gt;cid = cid;
-//	conn-&gt;stat_sn = info-&gt;stat_sn;
-// mnc	conn-&gt;exp_stat_sn = info-&gt;exp_stat_sn;
-
-//	conn-&gt;hdigest_type = info-&gt;header_digest;
-//	conn-&gt;ddigest_type = info-&gt;data_digest;
-//	if (digest_init(conn) &lt; 0) {
-//		iscsi_destroy_conn(cls_conn);
-//		return NULL;
-//	}
-
-	spin_lock_init(&amp;conn-&gt;list_lock);
-	atomic_set(&amp;conn-&gt;nr_cmnds, 0);
-	atomic_set(&amp;conn-&gt;nr_busy_cmnds, 0);
-	INIT_LIST_HEAD(&amp;conn-&gt;pdu_list);
-	INIT_LIST_HEAD(&amp;conn-&gt;write_list);
-	INIT_LIST_HEAD(&amp;conn-&gt;poll_list);
-
-	list_add(&amp;conn-&gt;list, &amp;session-&gt;conn_list);
-	return cls_conn;
-}
-
-int istgt_conn_start(struct iscsi_cls_conn *cls_conn)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-
-	set_bit(CONN_ACTIVE, &amp;conn-&gt;state);
-	list_add(&amp;conn-&gt;poll_list, &amp;session-&gt;nthread_info.active_conns);
-	nthread_wakeup(conn-&gt;session);
-	return 0;
-}

Deleted: branches/use-scsi-ml/istgt/kernel/digest.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/digest.c	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/digest.c	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,168 +0,0 @@
-/*
- * iSCSI digest handling.
- * (C) 2004 Xiranet Communications GmbH &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">arne.redlich at xiranet.com</A>&gt;
- * This code is licensed under the GPL.
- */
-
-#include &lt;linux/mm.h&gt;
-#include &lt;asm/types.h&gt;
-#include &lt;asm/scatterlist.h&gt;
-#include &lt;linux/scatterlist.h&gt;
-
-#include &lt;iscsi.h&gt;
-#include &lt;digest.h&gt;
-
-void digest_alg_available(unsigned int *val)
-{
-	if (*val &amp; DIGEST_CRC32C &amp;&amp; !crypto_alg_available(&quot;crc32c&quot;, 0)) {
-		printk(&quot;CRC32C digest algorithm not available in kernel\n&quot;);
-		*val |= ~DIGEST_CRC32C;
-	}
-}
-
-int digest_init(struct iscsi_conn *conn)
-{
-	int err = 0;
-
-	if (!(conn-&gt;hdigest_type &amp; DIGEST_ALL))
-		conn-&gt;hdigest_type = DIGEST_NONE;
-
-	if (!(conn-&gt;ddigest_type &amp; DIGEST_ALL))
-		conn-&gt;ddigest_type = DIGEST_NONE;
-
-	if (conn-&gt;hdigest_type &amp; DIGEST_CRC32C || conn-&gt;ddigest_type &amp; DIGEST_CRC32C) {
-		conn-&gt;rx_digest_tfm = crypto_alloc_tfm(&quot;crc32c&quot;, 0);
-		if (!conn-&gt;rx_digest_tfm) {
-			err = -ENOMEM;
-			goto out;
-		}
-
-		conn-&gt;tx_digest_tfm = crypto_alloc_tfm(&quot;crc32c&quot;, 0);
-		if (!conn-&gt;tx_digest_tfm) {
-			err = -ENOMEM;
-			goto out;
-		}
-	}
-
-out:
-	if (err)
-		digest_cleanup(conn);
-
-	return err;
-}
-
-void digest_cleanup(struct iscsi_conn *conn)
-{
-	if (conn-&gt;tx_digest_tfm)
-		crypto_free_tfm(conn-&gt;tx_digest_tfm);
-	if (conn-&gt;rx_digest_tfm)
-		crypto_free_tfm(conn-&gt;rx_digest_tfm);
-}
-
-static void digest_header(struct crypto_tfm *tfm, struct iscsi_pdu *pdu,
-			  uint8_t *crc)
-{
-	struct scatterlist sg[2];
-	int i = 0;
-
-	sg_init_one(&amp;sg[i], (uint8_t *) &amp;pdu-&gt;bhs, sizeof(struct iscsi_hdr));
-	i++;
-	if (pdu-&gt;ahssize) {
-		sg_init_one(&amp;sg[i], pdu-&gt;ahs, pdu-&gt;ahssize);
-		i++;
-	}
-
-	crypto_digest_init(tfm);
-	crypto_digest_update(tfm, sg, i);
-	crypto_digest_final(tfm, crc);
-}
-
-int digest_rx_header(struct istgt_cmd *cmnd)
-{
-	uint32_t crc;
-
-	digest_header(cmnd-&gt;conn-&gt;rx_digest_tfm, &amp;cmnd-&gt;pdu, (uint8_t *) &amp;crc);
-	if (crc != cmnd-&gt;hdigest)
-		return -EIO;
-
-	return 0;
-}
-
-void digest_tx_header(struct istgt_cmd *cmnd)
-{
-	digest_header(cmnd-&gt;conn-&gt;tx_digest_tfm, &amp;cmnd-&gt;pdu,
-		      (uint8_t *) &amp;cmnd-&gt;hdigest);
-}
-
-static void digest_data(struct crypto_tfm *tfm, struct istgt_cmd *cmnd,
-			struct scatterlist *sgv, uint32_t offset, uint8_t *crc)
-{
-	struct scatterlist sg[ISCSI_CONN_IOV_MAX];
-	uint32_t size, length;
-	int i, idx, count;
-
-	size = cmnd-&gt;pdu.datasize;
-	size = (size + 3) &amp; ~3;
-
-	offset += sgv-&gt;offset;
-	idx = offset &gt;&gt; PAGE_CACHE_SHIFT;
-	offset &amp;= ~PAGE_CACHE_MASK;
-	count = get_pgcnt(size, offset);
-	BUG_ON(count &gt; ISCSI_CONN_IOV_MAX);
-/* 	assert(idx + count &lt;= tio-&gt;pg_cnt); */
-
-	crypto_digest_init(tfm);
-
-	for (i = 0; size; i++) {
-		if (offset + size &gt; PAGE_CACHE_SIZE)
-			length = PAGE_CACHE_SIZE - offset;
-		else
-			length = size;
-
-		sg[i].page = sgv[idx + i].page;
-		sg[i].offset = offset;
-		sg[i].length = length;
-		size -= length;
-		offset = 0;
-	}
-
-	crypto_digest_update(tfm, sg, count);
-	crypto_digest_final(tfm, crc);
-}
-
-int digest_rx_data(struct istgt_cmd *cmnd)
-{
-	struct scatterlist *sg;
-	uint32_t offset, crc;
-
-	if (cmd_opcode(cmnd) == ISCSI_OP_SCSI_DATA_OUT) {
-		struct istgt_cmd *scsi_cmnd = cmnd-&gt;req;
-		struct iscsi_data *req = (struct iscsi_data *) &amp;cmnd-&gt;pdu.bhs;
-
-		sg = scsi_cmnd-&gt;scmd-&gt;request_buffer;
-		offset = be32_to_cpu(req-&gt;offset);
-	} else {
-		sg = cmnd-&gt;scmd-&gt;request_buffer;
-		offset = 0;
-	}
-
-	BUG_ON(!sg);
-	digest_data(cmnd-&gt;conn-&gt;rx_digest_tfm, cmnd, sg, offset,
-		    (uint8_t *) &amp;crc);
-
-	if (!cmnd-&gt;conn-&gt;read_overflow &amp;&amp; (cmd_opcode(cmnd) != ISCSI_OP_PDU_REJECT)) {
-		if (crc != cmnd-&gt;ddigest)
-			return -EIO;
-	}
-
-	return 0;
-}
-
-void digest_tx_data(struct istgt_cmd *cmnd)
-{
-	struct iscsi_data *req = (struct iscsi_data *) &amp;cmnd-&gt;pdu.bhs;
-
-	BUG_ON(!cmnd-&gt;sg);
-	digest_data(cmnd-&gt;conn-&gt;tx_digest_tfm, cmnd, cmnd-&gt;sg,
-		    be32_to_cpu(req-&gt;offset), (uint8_t *) &amp;cmnd-&gt;ddigest);
-}

Deleted: branches/use-scsi-ml/istgt/kernel/digest.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/digest.h	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/digest.h	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,20 +0,0 @@
-/*
- * iSCSI digest handling.
- * (C) 2004 Xiranet Communications GmbH &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">arne.redlich at xiranet.com</A>&gt;
- * This code is licensed under the GPL.
- */
-
-#ifndef __IET_DIGEST_H__
-#define __IET_DIGEST_H__
-
-extern void digest_alg_available(unsigned int *val);
-extern int digest_init(struct iscsi_conn *conn);
-extern void digest_cleanup(struct iscsi_conn *conn);
-
-extern int digest_rx_header(struct istgt_cmd *cmnd);
-extern int digest_rx_data(struct istgt_cmd *cmnd);
-
-extern void digest_tx_header(struct istgt_cmd *cmnd);
-extern void digest_tx_data(struct istgt_cmd *cmnd);
-
-#endif /* __IET_DIGEST_H__ */

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi.h	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/iscsi.h	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,309 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">roman at ardistech.com</A>&gt;
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#ifndef __ISCSI_H__
-#define __ISCSI_H__
-
-#include &lt;linux/pagemap.h&gt;
-#include &lt;linux/mm.h&gt;
-#include &lt;linux/crypto.h&gt;
-#include &lt;net/sock.h&gt;
-#include &lt;asm/scatterlist.h&gt;
-#include &lt;linux/blkdev.h&gt;
-
-#include &lt;scsi/iscsi_proto.h&gt;
-#include &lt;scsi/scsi_cmnd.h&gt;
-#include &lt;istgt_u.h&gt;
-
-#include &lt;tgt.h&gt;
-#include &lt;tgt_target.h&gt;
-#include &lt;tgt_scsi.h&gt;
-#include &lt;tgt_protocol.h&gt;
-
-struct iscsi_sess_param {
-	int initial_r2t;
-	int immediate_data;
-	int max_connections;
-	int max_recv_data_length;
-	int max_xmit_data_length;
-	int max_burst_length;
-	int first_burst_length;
-	int default_wait_time;
-	int default_retain_time;
-	int max_outstanding_r2t;
-	int data_pdu_inorder;
-	int data_sequence_inorder;
-	int error_recovery_level;
-	int header_digest;
-	int data_digest;
-	int ofmarker;
-	int ifmarker;
-	int ofmarkint;
-	int ifmarkint;
-};
-
-struct iscsi_trgt_param {
-	int queued_cmnds;
-};
-
-struct network_thread_info {
-	struct task_struct *task;
-	unsigned long flags;
-	struct list_head active_conns;
-
-	spinlock_t nthread_lock;
-
-	void (*old_state_change)(struct sock *);
-	void (*old_data_ready)(struct sock *, int);
-};
-
-struct istgt_cmd;
-
-#define IET_HASH_ORDER		8
-#define	cmnd_hashfn(itt)	hash_long((itt), IET_HASH_ORDER)
-
-struct iscsi_session {
-	struct list_head list;
-
-	uint64_t sid;
-
-	uint32_t exp_cmd_sn;
-	uint32_t max_cmd_sn;
-
-	struct iscsi_sess_param param;
-	uint32_t max_queued_cmnds;
-
-	struct list_head conn_list;
-	struct list_head pending_list;
-
-	spinlock_t cmnd_hash_lock;
-	struct list_head cmnd_hash[1 &lt;&lt; IET_HASH_ORDER];
-
-	uint32_t next_ttt;
-
-	struct iscsi_trgt_param trgt_param;
-
-	struct list_head session_list;
-	struct network_thread_info nthread_info;
-	struct semaphore target_sem;
-
-	struct Scsi_Host *shost;
-};
-
-enum connection_state_bit {
-	CONN_ACTIVE,
-	CONN_CLOSING,
-};
-
-#define ISCSI_CONN_IOV_MAX	(((256 &lt;&lt; 10) &gt;&gt; PAGE_SHIFT) + 1)
-
-struct iscsi_cls_session;
-struct iscsi_cls_conn;
-struct completion;
-
-struct iscsi_conn {
-	struct list_head list;			/* list entry in session list */
-	struct iscsi_session *session;		/* owning session */
-	struct iscsi_cls_conn *cls_conn;
-	struct completion *free_done;
-
-	uint16_t cid;
-	unsigned long state;
-
-	uint32_t stat_sn;
-	uint32_t exp_stat_sn;
-
-	int hdigest_type;
-	int ddigest_type;
-
-	struct list_head poll_list;
-
-	struct file *file;
-	struct socket *sock;
-	spinlock_t list_lock;
-	atomic_t nr_cmnds;
-	atomic_t nr_busy_cmnds;
-	struct list_head pdu_list;		/* in/outcoming pdus */
-	struct list_head write_list;		/* list of data pdus to be sent */
-
-	struct istgt_cmd *read_cmnd;
-	struct msghdr read_msg;
-	struct iovec read_iov[ISCSI_CONN_IOV_MAX];
-	uint32_t read_size;
-	uint32_t read_overflow;
-	int read_state;
-
-	struct istgt_cmd *write_cmnd;
-	struct iovec write_iov[ISCSI_CONN_IOV_MAX];
-	struct iovec *write_iop;
-
-	struct scatterlist *write_sg;
-
-	uint32_t write_size;
-	uint32_t write_offset;
-	int write_state;
-
-	struct crypto_tfm *rx_digest_tfm;
-	struct crypto_tfm *tx_digest_tfm;
-};
-
-struct iscsi_pdu {
-	struct iscsi_hdr bhs;
-	void *ahs;
-	unsigned int ahssize;
-	unsigned int datasize;
-};
-
-struct iscsi_sense_data {
-	uint16_t length;
-	uint8_t sense_buff[SCSI_SENSE_BUFFERSIZE];
-} __attribute__((packed));
-
-struct istgt_cmd {
-	struct list_head list;
-	struct list_head conn_list;
-	unsigned long flags;
-	struct iscsi_conn *conn;
-
-	struct iscsi_pdu pdu;
-	struct list_head pdu_list;
-
-	struct list_head hash_list;
-
-	struct scatterlist *sg, sense_sg;
-
-	uint32_t r2t_sn;
-	uint32_t r2t_length;
-	uint32_t is_unsolicited_data;
-	uint32_t target_task_tag;
-	uint32_t outstanding_r2t;
-
-	uint32_t hdigest;
-	uint32_t ddigest;
-
-	struct work_struct work;
-	struct completion event;
-
-	struct iscsi_sense_data sense;
-
-	struct istgt_cmd *req;
-
-	struct scsi_cmnd *scmd;
-	void (*done)(struct scsi_cmnd *);
-};
-
-#define ISCSI_OP_SCSI_REJECT	ISCSI_OP_VENDOR1_CMD
-#define ISCSI_OP_PDU_REJECT	ISCSI_OP_VENDOR2_CMD
-#define ISCSI_OP_DATA_REJECT	ISCSI_OP_VENDOR3_CMD
-#define ISCSI_OP_SCSI_ABORT	ISCSI_OP_VENDOR4_CMD
-
-/* iscsi.c */
-extern struct istgt_cmd *cmnd_alloc(struct iscsi_conn *, int);
-extern void cmnd_rx_start(struct istgt_cmd *);
-extern void cmnd_rx_end(struct istgt_cmd *);
-extern void cmnd_tx_start(struct istgt_cmd *);
-extern void cmnd_tx_end(struct istgt_cmd *);
-extern void cmnd_release(struct istgt_cmd *, int);
-
-/* conn.c */
-extern struct iscsi_cls_conn *istgt_conn_create(struct iscsi_cls_session *,
-						uint32_t cid);
-extern void istgt_conn_destroy(struct iscsi_cls_conn *);
-extern int istgt_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
-			   uint32_t, int);
-extern int istgt_conn_start(struct iscsi_cls_conn *);
-extern int conn_free(struct iscsi_conn *);
-extern int conn_close(struct iscsi_conn *conn);
-
-/* nthread.c */
-extern int nthread_init(struct iscsi_session *);
-extern int nthread_start(struct iscsi_session *);
-extern int nthread_stop(struct iscsi_session *);
-extern void nthread_wakeup(struct iscsi_session *);
-
-#define get_pgcnt(size, offset)	((((size) + ((offset) &amp; ~PAGE_CACHE_MASK)) + PAGE_CACHE_SIZE - 1) &gt;&gt; PAGE_CACHE_SHIFT)
-
-static inline void iscsi_cmnd_get_length(struct iscsi_pdu *pdu)
-{
-	pdu-&gt;ahssize = pdu-&gt;bhs.hlength * 4;
-	pdu-&gt;datasize = ntoh24(pdu-&gt;bhs.dlength);
-}
-
-static inline void iscsi_cmnd_set_length(struct iscsi_pdu *pdu)
-{
-	pdu-&gt;bhs.hlength = pdu-&gt;ahssize / 4;
-	hton24(pdu-&gt;bhs.dlength, pdu-&gt;datasize);
-}
-
-#define cmd_hdr(cmd)		((struct iscsi_cmd *) (&amp;((cmd)-&gt;pdu.bhs)))
-#define cmd_ttt(cmd)		cpu_to_be32((cmd)-&gt;pdu.bhs.ttt)
-#define cmd_itt(cmd)		cpu_to_be32((cmd)-&gt;pdu.bhs.itt)
-#define cmd_opcode(cmd)		((cmd)-&gt;pdu.bhs.opcode &amp; ISCSI_OPCODE_MASK)
-#define cmd_scsicode(cmd)	cmd_hdr(cmd)-&gt;cdb[0]
-
-#define	SECTOR_SIZE_BITS	9
-
-enum istgt_cmd_flags {
-	CMD_hashed,
-	CMD_final,
-	CMD_waitio,
-	CMD_close,
-	CMD_pending,
-};
-
-#define set_cmd_hashed(cmd)	set_bit(CMD_hashed, &amp;(cmd)-&gt;flags)
-#define cmd_hashed(cmd)		test_bit(CMD_hashed, &amp;(cmd)-&gt;flags)
-
-#define set_cmd_final(cmd)	set_bit(CMD_final, &amp;(cmd)-&gt;flags)
-#define cmd_final(cmd)		test_bit(CMD_final, &amp;(cmd)-&gt;flags)
-
-#define set_cmd_waitio(cmd)	set_bit(CMD_waitio, &amp;(cmd)-&gt;flags)
-#define cmd_waitio(cmd)		test_bit(CMD_waitio, &amp;(cmd)-&gt;flags)
-
-#define set_cmd_close(cmd)	set_bit(CMD_close, &amp;(cmd)-&gt;flags)
-#define cmd_close(cmd)		test_bit(CMD_close, &amp;(cmd)-&gt;flags)
-
-#define set_cmd_pending(cmd)	set_bit(CMD_pending, &amp;(cmd)-&gt;flags)
-#define clear_cmd_pending(cmd)	clear_bit(CMD_pending, &amp;(cmd)-&gt;flags)
-#define cmd_pending(cmd)	test_bit(CMD_pending, &amp;(cmd)-&gt;flags)
-
-/* We still use 'IET' id. Maybe someday, we get own id. */
-
-#define VENDOR_ID	&quot;IET&quot;
-#define PRODUCT_ID	&quot;VIRTUAL-DISK&quot;
-#define PRODUCT_REV	&quot;0&quot;
-
-#define show_param(param)\
-{\
-	eprintk(&quot;%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n&quot;,\
-		(param)-&gt;initial_r2t,\
-		(param)-&gt;immediate_data,\
-		(param)-&gt;max_connections,\
-		(param)-&gt;max_recv_data_length,\
-		(param)-&gt;max_xmit_data_length,\
-		(param)-&gt;max_burst_length,\
-		(param)-&gt;first_burst_length,\
-		(param)-&gt;default_wait_time,\
-		(param)-&gt;default_retain_time,\
-		(param)-&gt;max_outstanding_r2t,\
-		(param)-&gt;data_pdu_inorder,\
-		(param)-&gt;data_sequence_inorder,\
-		(param)-&gt;error_recovery_level,\
-		(param)-&gt;header_digest,\
-		(param)-&gt;data_digest);\
-}
-
-#undef dprintk
-
-#undef DEBUG_ISTGT
-
-#ifdef DEBUG_ISTGT
-#define dprintk eprintk
-#else
-#define dprintk(fmt, args...)
-#endif
-
-#endif	/* __ISCSI_H__ */

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,1935 +0,0 @@
-/*
- * (C) 2004 - 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * Copyright (C) 2002 - 2003 Ardis Technolgies &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">roman at ardistech.com</A>&gt;
- * Copyright (C) 2005 - 2006 Mike Christie
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include &lt;linux/module.h&gt;
-#include &lt;linux/hash.h&gt;
-#include &lt;linux/mempool.h&gt;
-#include &lt;net/tcp.h&gt;
-#include &lt;scsi/scsi.h&gt;
-#include &lt;scsi/scsi_tgt.h&gt;
-#include &lt;scsi/scsi_tcq.h&gt;
-#include &lt;scsi/scsi_transport.h&gt;
-#include &lt;scsi/scsi_transport_iscsi.h&gt;
-#include &lt;iscsi.h&gt;
-
-static kmem_cache_t *istgt_cmd_cache;
-static char dummy_data[1024];
-
-static uint32_t cmnd_write_size(struct istgt_cmd *cmnd)
-{
-	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
-
-	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)
-		return be32_to_cpu(hdr-&gt;data_length);
-	return 0;
-}
-
-static uint32_t cmnd_read_size(struct istgt_cmd *cmnd)
-{
-	struct iscsi_cmd *hdr = cmd_hdr(cmnd);
-
-	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
-		if (!(hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE))
-			return be32_to_cpu(hdr-&gt;data_length);
-		if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
-			struct iscsi_rlength_ahdr *ahdr =
-				(struct iscsi_rlength_ahdr *)cmnd-&gt;pdu.ahs;
-			if (ahdr &amp;&amp; ahdr-&gt;ahstype == ISCSI_AHSTYPE_RLENGTH)
-				return be32_to_cpu(ahdr-&gt;read_length);
-		}
-	}
-	return 0;
-}
-
-/*
- * create a new command.
- *
- * iscsi_cmnd_create - 
- * @conn: ptr to connection (for i/o)
- *
- * @return    ptr to command or NULL
- */
-
-struct istgt_cmd *cmnd_alloc(struct iscsi_conn *conn, int req)
-{
-	struct istgt_cmd *cmnd;
-
-	/* TODO: async interface is necessary ? */
-	cmnd = kmem_cache_alloc(istgt_cmd_cache, GFP_KERNEL | __GFP_NOFAIL);
-
-	memset(cmnd, 0, sizeof(*cmnd));
-	INIT_LIST_HEAD(&amp;cmnd-&gt;list);
-	INIT_LIST_HEAD(&amp;cmnd-&gt;pdu_list);
-	INIT_LIST_HEAD(&amp;cmnd-&gt;conn_list);
-	INIT_LIST_HEAD(&amp;cmnd-&gt;hash_list);
-	cmnd-&gt;conn = conn;
-	spin_lock(&amp;conn-&gt;list_lock);
-	atomic_inc(&amp;conn-&gt;nr_cmnds);
-	init_completion(&amp;cmnd-&gt;event);
-	if (req)
-		list_add_tail(&amp;cmnd-&gt;conn_list, &amp;conn-&gt;pdu_list);
-	spin_unlock(&amp;conn-&gt;list_lock);
-	cmnd-&gt;sg = NULL;
-
-	if (req)
-		BUG_ON(!conn-&gt;session);
-
-	dprintk(&quot;%p:%p\n&quot;, conn, cmnd);
-
-	return cmnd;
-}
-
-/**
- * create a new command used as response.
- *
- * iscsi_cmnd_create_rsp_cmnd - 
- * @cmnd: ptr to request command
- *
- * @return    ptr to response command or NULL
- */
-
-static struct istgt_cmd *iscsi_cmnd_create_rsp_cmnd(struct istgt_cmd *cmnd, int final)
-{
-	struct istgt_cmd *rsp = cmnd_alloc(cmnd-&gt;conn, 0);
-
-	if (final)
-		set_cmd_final(rsp);
-	list_add_tail(&amp;rsp-&gt;pdu_list, &amp;cmnd-&gt;pdu_list);
-	rsp-&gt;req = cmnd;
-	return rsp;
-}
-
-static struct istgt_cmd *get_rsp_cmnd(struct istgt_cmd *req)
-{
-	return list_entry(req-&gt;pdu_list.prev, struct istgt_cmd, pdu_list);
-}
-
-static void iscsi_cmnds_init_write(struct list_head *send)
-{
-	struct istgt_cmd *cmnd = list_entry(send-&gt;next, struct istgt_cmd, list);
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct list_head *pos, *next;
-
-	spin_lock(&amp;conn-&gt;list_lock);
-
-	list_for_each_safe(pos, next, send) {
-		cmnd = list_entry(pos, struct istgt_cmd, list);
-
-		dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
-
-		list_del_init(&amp;cmnd-&gt;list);
-		BUG_ON(conn != cmnd-&gt;conn);
-		list_add_tail(&amp;cmnd-&gt;list, &amp;conn-&gt;write_list);
-	}
-
-	spin_unlock(&amp;conn-&gt;list_lock);
-
-	nthread_wakeup(conn-&gt;session);
-}
-
-static void iscsi_cmnd_init_write(struct istgt_cmd *cmnd)
-{
-	LIST_HEAD(head);
-
-	if (!list_empty(&amp;cmnd-&gt;list)) {
-		eprintk(&quot;%x %x %x %x %lx %u %u %u %u %u %u %u %d %d\n&quot;,
-			cmd_itt(cmnd), cmd_ttt(cmnd), cmd_opcode(cmnd),
-			cmd_scsicode(cmnd), cmnd-&gt;flags,
-			cmnd-&gt;r2t_sn, cmnd-&gt;r2t_length, cmnd-&gt;is_unsolicited_data,
-			cmnd-&gt;target_task_tag, cmnd-&gt;outstanding_r2t,
-			cmnd-&gt;hdigest, cmnd-&gt;ddigest,
-			list_empty(&amp;cmnd-&gt;pdu_list), list_empty(&amp;cmnd-&gt;hash_list));
-
-		BUG_ON(!list_empty(&amp;cmnd-&gt;list));
-	}
-	list_add(&amp;cmnd-&gt;list, &amp;head);
-	iscsi_cmnds_init_write(&amp;head);
-}
-
-static void do_send_data_rsp(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct istgt_cmd *data_cmnd;
-	struct scatterlist *sg = cmnd-&gt;scmd-&gt;request_buffer;
-	struct iscsi_cmd *req = cmd_hdr(cmnd);
-	struct iscsi_data_rsp *rsp;
-	uint32_t pdusize, expsize, scsisize, size, offset, sn;
-	LIST_HEAD(send);
-
-	dprintk(&quot;%p\n&quot;, cmnd);
-	pdusize = conn-&gt;session-&gt;param.max_xmit_data_length;
-	expsize = cmnd_read_size(cmnd);
-	size = min(expsize, cmnd-&gt;scmd-&gt;request_bufflen);
-	dprintk(&quot;%u %u\n&quot;, expsize, cmnd-&gt;scmd-&gt;request_bufflen);
-	offset = 0;
-	sn = 0;
-
-	BUG_ON(!sg);
-
-	while (1) {
-		data_cmnd = iscsi_cmnd_create_rsp_cmnd(cmnd, size &lt;= pdusize);
-		data_cmnd-&gt;sg = sg;
-		rsp = (struct iscsi_data_rsp *)&amp;data_cmnd-&gt;pdu.bhs;
-
-		rsp-&gt;opcode = ISCSI_OP_SCSI_DATA_IN;
-		rsp-&gt;itt = req-&gt;itt;
-		rsp-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-		rsp-&gt;offset = offset;
-		rsp-&gt;datasn = cpu_to_be32(sn);
-
-		if (size &lt;= pdusize) {
-			data_cmnd-&gt;pdu.datasize = size;
-			rsp-&gt;flags = ISCSI_FLAG_CMD_FINAL |
-				     ISCSI_FLAG_DATA_STATUS;
-
-			scsisize = cmnd-&gt;scmd-&gt;request_bufflen;
-			if (scsisize &lt; expsize) {
-				rsp-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-				size = expsize - scsisize;
-			} else if (scsisize &gt; expsize) {
-				rsp-&gt;flags |= ISCSI_FLAG_CMD_OVERFLOW;
-				size = scsisize - expsize;
-			} else
-				size = 0;
-			rsp-&gt;residual_count = cpu_to_be32(size);
-			list_add_tail(&amp;data_cmnd-&gt;list, &amp;send);
-
-			break;
-		}
-
-		data_cmnd-&gt;pdu.datasize = pdusize;
-
-		size -= pdusize;
-		offset += pdusize;
-		sn++;
-
-		list_add_tail(&amp;data_cmnd-&gt;list, &amp;send);
-	}
-
-	iscsi_cmnds_init_write(&amp;send);
-}
-
-static struct istgt_cmd *create_scsi_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-	struct iscsi_cmd_rsp *rsp_hdr;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr-&gt;cmd_status = SAM_STAT_GOOD;
-	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
-
-	return rsp;
-}
-
-static void send_scsi_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	uint32_t size;
-
-	rsp = create_scsi_rsp(req);
-	rsp_hdr = (struct iscsi_cmd_rsp *) &amp;rsp-&gt;pdu.bhs;
-	if ((size = cmnd_read_size(req)) != 0) {
-		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
-	}
-
-	iscsi_cmnd_init_write(rsp);
-}
-
-static struct istgt_cmd *do_create_sense_rsp(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	struct iscsi_sense_data *sense = &amp;req-&gt;sense;
-	struct scatterlist *sg = &amp;req-&gt;sense_sg;
-	struct scatterlist *sg_data = req-&gt;scmd-&gt;request_buffer;
-	struct page *page;
-
-	page = sg_data[0].page;
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
-
-	memcpy(sense-&gt;sense_buff, req-&gt;scmd-&gt;sense_buffer,
-		sizeof(sense-&gt;sense_buff));
-	/*
-	 * this looks broken for ppc
-	 */
-	sense-&gt;length = cpu_to_be16(req-&gt;scmd-&gt;request_bufflen);
-
-	sg-&gt;page = virt_to_page(sense);
-	sg-&gt;offset = offset_in_page(sense);
-	sg-&gt;length = req-&gt;scmd-&gt;request_bufflen + sizeof(uint16_t);
-	rsp-&gt;pdu.datasize = sg-&gt;length;
-	rsp-&gt;sg = sg;
-
-	return rsp;
-}
-
-static struct istgt_cmd *create_sense_rsp(struct istgt_cmd *req,
-					   uint8_t sense_key, uint8_t asc, uint8_t ascq)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	struct scatterlist *sg = &amp;req-&gt;sense_sg;
-	struct iscsi_sense_data *sense = &amp;req-&gt;sense;
-	uint8_t *data = sense-&gt;sense_buff;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr-&gt;response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp_hdr-&gt;cmd_status = SAM_STAT_CHECK_CONDITION;
-	rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
-
-	sg-&gt;page = virt_to_page(sense);
-	sg-&gt;offset = offset_in_page(sense);
-
-	sense-&gt;length = cpu_to_be16(14);
-	data[0] = 0xf0;
-	data[2] = sense_key;
-	data[7] = 6;	// Additional sense length
-	data[12] = asc;
-	data[13] = ascq;
-
-	rsp-&gt;pdu.datasize = sizeof(uint16_t) + 14;
-	rsp-&gt;sg = sg;
-
-	sg-&gt;length = (rsp-&gt;pdu.datasize + 3) &amp; -4;
-
-	return rsp;
-}
-
-/**
- * Free a command.
- * Also frees the additional header.
- *
- * iscsi_cmnd_remove - 
- * @cmnd: ptr to command
- */
-
-void iscsi_cmnd_remove(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn;
-
-	if (!cmnd)
-		return;
-	dprintk(&quot;%p\n&quot;, cmnd);
-	conn = cmnd-&gt;conn;
-	kfree(cmnd-&gt;pdu.ahs);
-
-	if (!list_empty(&amp;cmnd-&gt;list)) {
-		struct iscsi_cmd *req = cmd_hdr(cmnd);
-
-		eprintk(&quot;cmnd %p still on some list?, %x %x %x %x %x %x %x %lx\n&quot;,
-			cmnd, req-&gt;opcode, req-&gt;cdb[0], req-&gt;flags, req-&gt;itt,
-			be32_to_cpu(req-&gt;data_length), req-&gt;cmdsn,
-			be32_to_cpu(cmnd-&gt;pdu.datasize), conn-&gt;state);
-
-		if (cmnd-&gt;req) {
-			struct iscsi_cmd *req = cmd_hdr(cmnd-&gt;req);
-			eprintk(&quot;%p %x %u\n&quot;, req, req-&gt;opcode, req-&gt;cdb[0]);
-		}
-		BUG();
-	}
-	list_del(&amp;cmnd-&gt;list);
-	spin_lock(&amp;conn-&gt;list_lock);
-	atomic_dec(&amp;conn-&gt;nr_cmnds);
-	list_del(&amp;cmnd-&gt;conn_list);
-	spin_unlock(&amp;conn-&gt;list_lock);
-
-	if (cmnd-&gt;scmd)
-		cmnd-&gt;done(cmnd-&gt;scmd);
-	kmem_cache_free(istgt_cmd_cache, cmnd);
-}
-
-static void cmnd_skip_pdu(struct istgt_cmd *cmnd)
-{
-/* 	struct iscsi_conn *conn = cmnd-&gt;conn; */
-/* 	struct tio *tio = cmnd-&gt;tio; */
-/* 	char *addr; */
-/* 	u32 size; */
-/* 	int i; */
-
-	BUG_ON(1);
-
-/* 	eprintk(&quot;%x %x %x %u\n&quot;, cmd_itt(cmnd), cmd_opcode(cmnd), */
-/* 		cmd_hdr(cmnd)-&gt;cdb[0], cmnd-&gt;pdu.datasize); */
-
-/* 	if (!(size = cmnd-&gt;pdu.datasize)) */
-/* 		return; */
-
-/* 	if (tio) */
-/* 		assert(tio-&gt;pg_cnt &gt; 0); */
-/* 	else */
-/* 		tio = cmnd-&gt;tio = tio_alloc(1); */
-
-/* 	addr = page_address(tio-&gt;pvec[0]); */
-/* 	assert(addr); */
-/* 	size = (size + 3) &amp; -4; */
-/* 	conn-&gt;read_size = size; */
-/* 	for (i = 0; size &gt; PAGE_CACHE_SIZE; i++, size -= PAGE_CACHE_SIZE) { */
-/* 		assert(i &lt; ISCSI_CONN_IOV_MAX); */
-/* 		conn-&gt;read_iov[i].iov_base = addr; */
-/* 		conn-&gt;read_iov[i].iov_len = PAGE_CACHE_SIZE; */
-/* 	} */
-/* 	conn-&gt;read_iov[i].iov_base = addr; */
-/* 	conn-&gt;read_iov[i].iov_len = size; */
-/* 	conn-&gt;read_msg.msg_iov = conn-&gt;read_iov; */
-/* 	conn-&gt;read_msg.msg_iovlen = ++i; */
-}
-
-static void iscsi_cmnd_reject(struct istgt_cmd *req, int reason)
-{
-/* 	struct istgt_cmd *rsp; */
-/* 	struct iscsi_reject_hdr *rsp_hdr; */
-/* 	struct tio *tio; */
-/* 	char *addr; */
-
-	BUG_ON(1);
-
-/* 	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1); */
-/* 	rsp_hdr = (struct iscsi_reject_hdr *)&amp;rsp-&gt;pdu.bhs; */
-
-/* 	rsp_hdr-&gt;opcode = ISCSI_OP_REJECT; */
-/* 	rsp_hdr-&gt;ffffffff = ISCSI_RESERVED_TAG; */
-/* 	rsp_hdr-&gt;reason = reason; */
-
-/* 	rsp-&gt;tio = tio = tio_alloc(1); */
-/* 	addr = page_address(tio-&gt;pvec[0]); */
-/* 	clear_page(addr); */
-/* 	memcpy(addr, &amp;req-&gt;pdu.bhs, sizeof(struct iscsi_hdr)); */
-/* 	tio-&gt;size = rsp-&gt;pdu.datasize = sizeof(struct iscsi_hdr); */
-/* 	cmnd_skip_pdu(req); */
-
-/* 	req-&gt;pdu.bhs.opcode = ISCSI_OP_PDU_REJECT; */
-}
-
-static void cmnd_set_sn(struct istgt_cmd *cmnd, int set_stat_sn)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct iscsi_session *sess = conn-&gt;session;
-
-	if (set_stat_sn)
-		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn++);
-	cmnd-&gt;pdu.bhs.exp_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn);
-	cmnd-&gt;pdu.bhs.max_statsn = cpu_to_be32(sess-&gt;exp_cmd_sn +
-						sess-&gt;max_queued_cmnds);
-}
-
-static void update_stat_sn(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	uint32_t exp_stat_sn;
-
-	cmnd-&gt;pdu.bhs.exp_statsn = exp_stat_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.exp_statsn);
-	dprintk(&quot;%x,%x\n&quot;, cmd_opcode(cmnd), exp_stat_sn);
-	if ((int32_t) (exp_stat_sn - conn-&gt;exp_stat_sn) &gt; 0 &amp;&amp;
-	    (int32_t) (exp_stat_sn - conn-&gt;stat_sn) &lt;= 0) {
-		// free pdu resources
-		cmnd-&gt;conn-&gt;exp_stat_sn = exp_stat_sn;
-	}
-}
-
-static int check_cmd_sn(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
-	uint32_t cmd_sn;
-
-	cmnd-&gt;pdu.bhs.statsn = cmd_sn = be32_to_cpu(cmnd-&gt;pdu.bhs.statsn);
-	dprintk(&quot;%d(%d)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
-	if ((int32_t) (cmd_sn - session-&gt;exp_cmd_sn) &gt;= 0)
-		return 0;
-	eprintk(&quot;sequence error (%x,%x)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
-	return -ISCSI_REASON_PROTOCOL_ERROR;
-}
-
-static struct istgt_cmd *__cmnd_find_hash(struct iscsi_session *session,
-					   uint32_t itt, uint32_t ttt)
-{
-	struct list_head *head;
-	struct istgt_cmd *cmnd;
-
-	head = &amp;session-&gt;cmnd_hash[cmnd_hashfn(itt)];
-
-	list_for_each_entry(cmnd, head, hash_list) {
-		if (cmnd-&gt;pdu.bhs.itt == itt) {
-			if ((ttt != ISCSI_RESERVED_TAG) &amp;&amp; (ttt != cmnd-&gt;target_task_tag))
-				continue;
-			return cmnd;
-		}
-	}
-
-	return NULL;
-}
-
-static struct istgt_cmd *cmnd_find_hash(struct iscsi_session *session,
-					 uint32_t itt, uint32_t ttt)
-{
-	struct istgt_cmd *cmnd;
-
-	spin_lock(&amp;session-&gt;cmnd_hash_lock);
-
-	cmnd = __cmnd_find_hash(session, itt, ttt);
-
-	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
-
-	return cmnd;
-}
-
-static int cmnd_insert_hash(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
-	struct istgt_cmd *tmp;
-	struct list_head *head;
-	int err = 0;
-	uint32_t itt = cmnd-&gt;pdu.bhs.itt;
-
-	dprintk(&quot;%p:%x\n&quot;, cmnd, itt);
-	if (itt == ISCSI_RESERVED_TAG) {
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
-		goto out;
-	}
-
-	head = &amp;session-&gt;cmnd_hash[cmnd_hashfn(cmnd-&gt;pdu.bhs.itt)];
-
-	spin_lock(&amp;session-&gt;cmnd_hash_lock);
-
-	tmp = __cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG);
-	if (!tmp) {
-		list_add_tail(&amp;cmnd-&gt;hash_list, head);
-		set_cmd_hashed(cmnd);
-	} else
-		err = -ISCSI_REASON_TASK_IN_PROGRESS;
-
-	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
-
-	if (!err) {
-		update_stat_sn(cmnd);
-		err = check_cmd_sn(cmnd);
-	}
-
-out:
-	return err;
-}
-
-static void __cmnd_remove_hash(struct istgt_cmd *cmnd)
-{
-	list_del(&amp;cmnd-&gt;hash_list);
-}
-
-static void cmnd_remove_hash(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
-	struct istgt_cmd *tmp;
-
-	spin_lock(&amp;session-&gt;cmnd_hash_lock);
-
-	tmp = __cmnd_find_hash(session, cmnd-&gt;pdu.bhs.itt, ISCSI_RESERVED_TAG);
-
-	if (tmp &amp;&amp; tmp == cmnd)
-		__cmnd_remove_hash(tmp);
-	else
-		eprintk(&quot;%p:%x not found\n&quot;, cmnd, cmd_itt(cmnd));
-
-	spin_unlock(&amp;session-&gt;cmnd_hash_lock);
-}
-
-static void cmnd_skip_data(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_cmd_rsp *rsp_hdr;
-	uint32_t size;
-
-	rsp = get_rsp_cmnd(req);
-	rsp_hdr = (struct iscsi_cmd_rsp *)&amp;rsp-&gt;pdu.bhs;
-	if (cmd_opcode(rsp) != ISCSI_OP_SCSI_CMD_RSP) {
-		eprintk(&quot;unexpected response command %u\n&quot;, cmd_opcode(rsp));
-		return;
-	}
-
-	size = cmnd_write_size(req);
-	if (size) {
-		rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-		rsp_hdr-&gt;residual_count = cpu_to_be32(size);
-	}
-	size = cmnd_read_size(req);
-	if (size) {
-		if (cmd_hdr(req)-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
-			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
-			rsp_hdr-&gt;bi_residual_count = cpu_to_be32(size);
-		} else {
-			rsp_hdr-&gt;flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
-			rsp_hdr-&gt;residual_count = cpu_to_be32(size);
-		}
-	}
-	req-&gt;pdu.bhs.opcode =
-		(req-&gt;pdu.bhs.opcode &amp; ~ISCSI_OPCODE_MASK) | ISCSI_OP_SCSI_REJECT;
-
-	cmnd_skip_pdu(req);
-}
-
-static int cmnd_recv_pdu(struct iscsi_conn *conn, struct scsi_cmnd *scmd,
-			 uint32_t offset, uint32_t size)
-{
-	int idx, i;
-	char *addr;
-	struct scatterlist *sg;
-
-	dprintk(&quot;%u,%u\n&quot;, offset, size);
-
-	BUG_ON(!scmd);
-	BUG_ON(!scmd-&gt;request_buffer);
-	sg = scmd-&gt;request_buffer;
-	offset += sg-&gt;offset;
-
-	if (!(offset &lt; sg-&gt;offset + scmd-&gt;request_bufflen) ||
-	    !(offset + size &lt;= sg-&gt;offset + scmd-&gt;request_bufflen)) {
-		eprintk(&quot;%u %u %u %u&quot;, offset, size, sg-&gt;offset,
-			scmd-&gt;request_bufflen);
-		return -EIO;
-	}
-	BUG_ON(!(offset &lt; sg-&gt;offset + scmd-&gt;request_bufflen));
-	BUG_ON(!(offset + size &lt;= sg-&gt;offset + scmd-&gt;request_bufflen));
-
-	idx = offset &gt;&gt; PAGE_CACHE_SHIFT;
-	offset &amp;= ~PAGE_CACHE_MASK;
-
-	conn-&gt;read_msg.msg_iov = conn-&gt;read_iov;
-	conn-&gt;read_size = (size + 3) &amp; -4;
-	conn-&gt;read_overflow = 0;
-
-	i = 0;
-	while (1) {
-		sg = scmd-&gt;request_buffer + idx;
-		BUG_ON(!sg);
-		BUG_ON(!sg-&gt;page);
-		addr = page_address(sg-&gt;page);
-		BUG_ON(!addr);
-
-		conn-&gt;read_iov[i].iov_base =  addr + offset;
-		if (offset + size &lt;= PAGE_CACHE_SIZE) {
-			conn-&gt;read_iov[i].iov_len = size;
-			conn-&gt;read_msg.msg_iovlen = ++i;
-			break;
-		}
-		conn-&gt;read_iov[i].iov_len = PAGE_CACHE_SIZE - offset;
-		size -= conn-&gt;read_iov[i].iov_len;
-		offset = 0;
-		if (++i &gt;= ISCSI_CONN_IOV_MAX) {
-			conn-&gt;read_msg.msg_iovlen = i;
-			conn-&gt;read_overflow = size;
-			conn-&gt;read_size -= size;
-			break;
-		}
-
-		idx++;
-	}
-
-	return 0;
-}
-
-static void send_r2t(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_r2t_rsp *rsp_hdr;
-	uint32_t length, offset, burst;
-	LIST_HEAD(send);
-
-	length = req-&gt;r2t_length;
-	burst = req-&gt;conn-&gt;session-&gt;param.max_burst_length;
-	offset = be32_to_cpu(cmd_hdr(req)-&gt;data_length) - length;
-
-	do {
-		rsp = iscsi_cmnd_create_rsp_cmnd(req, 0);
-		rsp-&gt;pdu.bhs.ttt = req-&gt;target_task_tag;
-
-		rsp_hdr = (struct iscsi_r2t_rsp *)&amp;rsp-&gt;pdu.bhs;
-		rsp_hdr-&gt;opcode = ISCSI_OP_R2T;
-		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-		memcpy(rsp_hdr-&gt;lun, cmd_hdr(req)-&gt;lun, 8);
-		rsp_hdr-&gt;itt = cmd_hdr(req)-&gt;itt;
-		rsp_hdr-&gt;r2tsn = cpu_to_be32(req-&gt;r2t_sn++);
-		rsp_hdr-&gt;data_offset = cpu_to_be32(offset);
-		if (length &gt; burst) {
-			rsp_hdr-&gt;data_length = cpu_to_be32(burst);
-			length -= burst;
-			offset += burst;
-		} else {
-			rsp_hdr-&gt;data_length = cpu_to_be32(length);
-			length = 0;
-		}
-
-		dprintk(&quot;%x %u %u %u %u\n&quot;, cmd_itt(req),
-			be32_to_cpu(rsp_hdr-&gt;data_length),
-			be32_to_cpu(rsp_hdr-&gt;data_offset),
-			be32_to_cpu(rsp_hdr-&gt;r2tsn), req-&gt;outstanding_r2t);
-
-		list_add_tail(&amp;rsp-&gt;list, &amp;send);
-
-		if (++req-&gt;outstanding_r2t &gt;= req-&gt;conn-&gt;session-&gt;param.max_outstanding_r2t)
-			break;
-
-	} while (length);
-
-	iscsi_cmnds_init_write(&amp;send);
-}
-
-static void __scsi_cmnd_done(void *data)
-{
-	struct scsi_cmnd *scmd = data;
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
-	struct iscsi_cmd *req = cmd_hdr(cmnd);
-
-	if (scmd-&gt;result) {
-		struct istgt_cmd *rsp;
-
-		rsp = do_create_sense_rsp(cmnd);
-		iscsi_cmnd_init_write(rsp);
-		return;
-	}
-
-	switch (req-&gt;cdb[0]) {
-	case INQUIRY:
-	case REPORT_LUNS:
-	case READ_CAPACITY:
-	case MODE_SENSE:
-	case REQUEST_SENSE:
-	case SERVICE_ACTION_IN:
-	case READ_6:
-	case READ_10:
-	case READ_16:
-		do_send_data_rsp(cmnd);
-		break;
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	case START_STOP:
-	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
-	case VERIFY:
-	case VERIFY_16:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-		send_scsi_rsp(cmnd);
-		break;
-	default:
-		BUG_ON(1);
-		break;
-	}
-}
-
-/* TODO : merge this with nthread. */
-static int scsi_cmnd_done(struct scsi_cmnd *scmd,
-			  void (*done)(struct scsi_cmnd *))
-{
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
-	int err;
-
-	cmnd-&gt;done = done;
-	INIT_WORK(&amp;cmnd-&gt;work, __scsi_cmnd_done, scmd);
-	err = schedule_work(&amp;cmnd-&gt;work);
-	BUG_ON(!err);
-
-	return TGT_CMD_XMIT_OK;
-}
-
-static void tgt_scsi_cmd_create(struct istgt_cmd *req)
-{
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-	struct scsi_cmnd *scmd;
-
-	scmd = scsi_host_get_command(req-&gt;conn-&gt;session-&gt;shost, GFP_KERNEL);
-	BUG_ON(!scmd);
-	req-&gt;scmd = scmd;
-
-	memcpy(scmd-&gt;data_cmnd, req_hdr-&gt;cdb, MAX_COMMAND_SIZE);
-	scmd-&gt;request_bufflen = be32_to_cpu(req_hdr-&gt;data_length);
-	scmd-&gt;SCp.ptr = (char *) req;
-
-	/*
-	 * handle bidi later
-	 */
-	if (req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)
-		scmd-&gt;sc_data_direction = DMA_TO_DEVICE;
-	else if (req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ)
-		scmd-&gt;sc_data_direction = DMA_FROM_DEVICE;
-	else
-		scmd-&gt;sc_data_direction = DMA_NONE;
-
-	switch (req-&gt;pdu.bhs.flags &amp; ISCSI_FLAG_CMD_ATTR_MASK) {
-	case ISCSI_ATTR_UNTAGGED:
-	case ISCSI_ATTR_SIMPLE:
-		scmd-&gt;tag = MSG_SIMPLE_TAG;
-		break;
-	case ISCSI_ATTR_ORDERED:
-		scmd-&gt;tag = MSG_ORDERED_TAG;
-		break;
-	case ISCSI_ATTR_HEAD_OF_QUEUE:
-		scmd-&gt;tag = MSG_HEAD_TAG;
-		break;
-	case ISCSI_ATTR_ACA:
-		scmd-&gt;tag = MSG_SIMPLE_TAG;
-		break;
-	default:
-		scmd-&gt;tag = MSG_SIMPLE_TAG;
-	}
-
-	if (scmd-&gt;sc_data_direction == DMA_TO_DEVICE &amp;&amp;
-	    be32_to_cpu(req_hdr-&gt;data_length)) {
-		switch (req_hdr-&gt;cdb[0]) {
-		case WRITE_6:
-		case WRITE_10:
-		case WRITE_16:
-		case WRITE_VERIFY:
-			break;
-		default:
-			eprintk(&quot;%x\n&quot;, req_hdr-&gt;cdb[0]);
-			break;
-		}
-	}
-
-	scsi_tgt_queue_command(scmd, (struct scsi_lun *)req_hdr-&gt;lun, 0);
-}
-
-static void scsi_cmnd_exec(struct istgt_cmd *cmnd)
-{
-	struct scsi_cmnd *scmd = cmnd-&gt;scmd;
-
-	if (cmnd-&gt;r2t_length) {
-		if (!cmnd-&gt;is_unsolicited_data)
-			send_r2t(cmnd);
-	} else {
-		set_cmd_waitio(cmnd);
-		if (scmd) {
-			if (!cmnd-&gt;done)
-				BUG();
-			else
-				cmnd-&gt;done(scmd);
-		} else
-			tgt_scsi_cmd_create(cmnd);
-	}
-}
-
-static int noop_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	uint32_t size, tmp;
-	int i = 0, err = 0;
-
-	if (cmd_ttt(cmnd) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		/*
-		 * We don't request a NOP-Out by sending a NOP-In.
-		 * See 10.18.2 in the draft 20.
-		 */
-		eprintk(&quot;initiator bug %x\n&quot;, cmd_itt(cmnd));
-		err = -ISCSI_REASON_PROTOCOL_ERROR;
-		goto out;
-	}
-
-	if (cmd_itt(cmnd) == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (!(cmnd-&gt;pdu.bhs.opcode &amp; ISCSI_OP_IMMEDIATE))
-			eprintk(&quot;%s\n&quot;,&quot;initiator bug!&quot;);
-		update_stat_sn(cmnd);
-		err = check_cmd_sn(cmnd);
-		goto out;
-	} else if ((err = cmnd_insert_hash(cmnd)) &lt; 0) {
-		eprintk(&quot;ignore this request %x\n&quot;, cmd_itt(cmnd));
-		goto out;
-	}
-
-	if ((size = cmnd-&gt;pdu.datasize)) {
-		size = (size + 3) &amp; -4;
-		conn-&gt;read_msg.msg_iov = conn-&gt;read_iov;
-		if (cmnd-&gt;pdu.bhs.itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-/* 			struct tio *tio; */
-			int pg_cnt = get_pgcnt(size, 0);
-
-			BUG_ON(pg_cnt &gt;= ISCSI_CONN_IOV_MAX);
-			BUG_ON(1);
-/* 			cmnd-&gt;tio = tio = tio_alloc(pg_cnt); */
-/* 			tio_set(tio, size, 0); */
-
-/* 			for (i = 0; i &lt; pg_cnt; i++) { */
-/* 				conn-&gt;read_iov[i].iov_base */
-/* 					= page_address(tio-&gt;pvec[i]); */
-/* 				tmp = min_t(u32, size, PAGE_CACHE_SIZE); */
-/* 				conn-&gt;read_iov[i].iov_len = tmp; */
-/* 				conn-&gt;read_size += tmp; */
-/* 				size -= tmp; */
-/* 			} */
-		} else {
-			for (i = 0; i &lt; ISCSI_CONN_IOV_MAX; i++) {
-				conn-&gt;read_iov[i].iov_base = dummy_data;
-				tmp = min_t(uint32_t, size, sizeof(dummy_data));
-				conn-&gt;read_iov[i].iov_len = tmp;
-				conn-&gt;read_size += tmp;
-				size -= tmp;
-			}
-		}
-		BUG_ON(size);
-		conn-&gt;read_overflow = size;
-		conn-&gt;read_msg.msg_iovlen = i;
-	}
-
-out:
-	return err;
-}
-
-static uint32_t get_next_ttt(struct iscsi_session *session)
-{
-	uint32_t ttt;
-
-	if (session-&gt;next_ttt == ISCSI_RESERVED_TAG)
-		session-&gt;next_ttt++;
-	ttt = session-&gt;next_ttt++;
-
-	return cpu_to_be32(ttt);
-}
-
-static void scsi_cmnd_start(struct iscsi_conn *conn, struct istgt_cmd *req)
-{
-	struct iscsi_cmd *req_hdr = cmd_hdr(req);
-
-	dprintk(&quot;scsi command: %02x\n&quot;, req_hdr-&gt;cdb[0]);
-
-	switch (req_hdr-&gt;cdb[0]) {
-	case SERVICE_ACTION_IN:
-		if ((req_hdr-&gt;cdb[1] &amp; 0x1f) != 0x10)
-			goto error;
-
-	case INQUIRY:
-	case REPORT_LUNS:
-	case TEST_UNIT_READY:
-	case SYNCHRONIZE_CACHE:
-	case VERIFY:
-	case VERIFY_16:
-	case START_STOP:
-	case READ_CAPACITY:
-	case MODE_SENSE:
-	case REQUEST_SENSE:
-	case RESERVE:
-	case RELEASE:
-	case RESERVE_10:
-	case RELEASE_10:
-	case READ_6:
-	case READ_10:
-	case READ_16:
-	{
-		if (!(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ||
-		      req-&gt;pdu.datasize) {
-			/* unexpected unsolicited data */
-			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
-			create_sense_rsp(req, ABORTED_COMMAND, 0xc, 0xc);
-			cmnd_skip_data(req);
-		}
-		break;
-	}
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-	{
-		struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
-
-		/*
-		 * We don't know this command arrives in order,
-		 * however we need to allocate buffer for immediate
-		 * and unsolicited data. tgt will not start to perform
-		 * this command until we call cmd-&gt;done so we don't
-		 * need to worry about the order of the command.
-		 */
-		tgt_scsi_cmd_create(req);
-		wait_for_completion(&amp;req-&gt;event);
-
-		req-&gt;r2t_length = be32_to_cpu(req_hdr-&gt;data_length) - req-&gt;pdu.datasize;
-		req-&gt;is_unsolicited_data = !(req_hdr-&gt;flags &amp;
-						ISCSI_FLAG_CMD_FINAL);
-		req-&gt;target_task_tag = get_next_ttt(conn-&gt;session);
-
-		if (!param-&gt;immediate_data &amp;&amp; req-&gt;pdu.datasize)
-			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
-
-		if (param-&gt;initial_r2t &amp;&amp;
-		    !(req_hdr-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
-			eprintk(&quot;%x %x\n&quot;, cmd_itt(req), req_hdr-&gt;cdb[0]);
-
-		if (req_hdr-&gt;cdb[0] == WRITE_VERIFY &amp;&amp; req_hdr-&gt;cdb[1] &amp; 0x02)
-			eprintk(&quot;Verification is ignored %x\n&quot;, cmd_itt(req));
-
-		if (req-&gt;pdu.datasize) {
-			if (cmnd_recv_pdu(conn, req-&gt;scmd, 0,
-					  req-&gt;pdu.datasize) &lt; 0)
-				BUG_ON(1);
-		}
-		break;
-	}
-	error:
-	default:
-		eprintk(&quot;Unsupported %x\n&quot;, req_hdr-&gt;cdb[0]);
-		create_sense_rsp(req, ILLEGAL_REQUEST, 0x20, 0x0);
-		cmnd_skip_data(req);
-		break;
-	}
-
-	return;
-}
-
-static void data_out_start(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	struct iscsi_data *req = (struct iscsi_data *)&amp;cmnd-&gt;pdu.bhs;
-	struct istgt_cmd *scsi_cmnd = NULL;
-	uint32_t offset = be32_to_cpu(req-&gt;offset);
-
-	update_stat_sn(cmnd);
-
-	cmnd-&gt;req = scsi_cmnd = cmnd_find_hash(conn-&gt;session, req-&gt;itt, req-&gt;ttt);
-	if (!scsi_cmnd) {
-		eprintk(&quot;unable to find scsi task %x %x\n&quot;,
-			cmd_itt(cmnd), cmd_ttt(cmnd));
-		goto skip_data;
-	}
-
-	if (scsi_cmnd-&gt;r2t_length &lt; cmnd-&gt;pdu.datasize) {
-		eprintk(&quot;invalid data len %x %u %u\n&quot;,
-			cmd_itt(scsi_cmnd), cmnd-&gt;pdu.datasize, scsi_cmnd-&gt;r2t_length);
-		goto skip_data;
-	}
-
-	if (scsi_cmnd-&gt;r2t_length + offset != cmnd_write_size(scsi_cmnd)) {
-		eprintk(&quot;%x %u %u %u\n&quot;, cmd_itt(scsi_cmnd), scsi_cmnd-&gt;r2t_length,
-			offset,	cmnd_write_size(scsi_cmnd));
-		goto skip_data;
-	}
-
-	scsi_cmnd-&gt;r2t_length -= cmnd-&gt;pdu.datasize;
-
-	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		/* unsolicited burst data */
-		if (scsi_cmnd-&gt;pdu.bhs.flags &amp; ISCSI_FLAG_CMD_FINAL) {
-			eprintk(&quot;unexpected data from %x %x\n&quot;,
-				cmd_itt(cmnd), cmd_ttt(cmnd));
-			goto skip_data;
-		}
-	}
-
-	dprintk(&quot;%u %p %p %u %u\n&quot;, req-&gt;ttt, cmnd, scsi_cmnd,
-		offset, cmnd-&gt;pdu.datasize);
-
-	if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;scmd, offset, cmnd-&gt;pdu.datasize) &lt; 0)
-		goto skip_data;
-	return;
-
-skip_data:
-	cmnd-&gt;pdu.bhs.opcode = ISCSI_OP_DATA_REJECT;
-	cmnd_skip_pdu(cmnd);
-	return;
-}
-
-static void data_out_end(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	struct iscsi_data *req = (struct iscsi_data *) &amp;cmnd-&gt;pdu.bhs;
-	struct istgt_cmd *scsi_cmnd;
-	uint32_t offset;
-
-	BUG_ON(!cmnd);
-	scsi_cmnd = cmnd-&gt;req;
-	BUG_ON(!scsi_cmnd);
-
-	if (conn-&gt;read_overflow) {
-		eprintk(&quot;%x %u\n&quot;, cmd_itt(cmnd), conn-&gt;read_overflow);
-		offset = be32_to_cpu(req-&gt;offset);
-		offset += cmnd-&gt;pdu.datasize - conn-&gt;read_overflow;
-		if (cmnd_recv_pdu(conn, scsi_cmnd-&gt;scmd, offset,
-				  conn-&gt;read_overflow) &lt; 0)
-			BUG_ON(1);
-		return;
-	}
-
-	if (req-&gt;ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if (req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) {
-			scsi_cmnd-&gt;is_unsolicited_data = 0;
-			if (!cmd_pending(scsi_cmnd))
-				scsi_cmnd_exec(scsi_cmnd);
-		}
-	} else {
-		/* TODO : proper error handling */
-		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) &amp;&amp;
-		    scsi_cmnd-&gt;r2t_length == 0)
-			eprintk(&quot;initiator error %x\n&quot;, cmd_itt(scsi_cmnd));
-
-		if (!(req-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL))
-			goto out;
-
-		scsi_cmnd-&gt;outstanding_r2t--;
-
-		if (scsi_cmnd-&gt;r2t_length == 0)
-			BUG_ON(!list_empty(&amp;scsi_cmnd-&gt;pdu_list));
-
-		scsi_cmnd_exec(scsi_cmnd);
-	}
-
-out:
-	iscsi_cmnd_remove(cmnd);
-	return;
-}
-
-/* static int __cmnd_abort(struct istgt_cmd *cmnd) */
-/* { */
-/* 	if (!cmnd_waitio(cmnd)) { */
-/* 		cmnd_release(cmnd, 1); */
-/* 		return 0; */
-/* 	} else */
-/* 		return -ISCSI_RESPONSE_UNKNOWN_TASK; */
-/* } */
-
-/* static int cmnd_abort(struct iscsi_session *session, u32 itt) */
-/* { */
-/* 	struct istgt_cmd *cmnd; */
-/* 	int err =  -ISCSI_RESPONSE_UNKNOWN_TASK; */
-
-/* 	if ((cmnd = cmnd_find_hash(session, itt, ISCSI_RESERVED_TAG))) { */
-/* 		eprintk(&quot;%x %x %x %u %u %u %u\n&quot;, cmd_itt(cmnd), cmd_opcode(cmnd), */
-/* 			cmnd-&gt;r2t_length, cmnd_scsicode(cmnd), */
-/* 			cmnd_write_size(cmnd), cmnd-&gt;is_unsolicited_data, */
-/* 			cmnd-&gt;outstanding_r2t); */
-/* 		err = __cmnd_abort(cmnd); */
-/* 	} */
-
-/* 	return err; */
-/* } */
-
-/* static int target_reset(struct istgt_cmd *req, u32 lun, int all) */
-/* { */
-/* 	struct iscsi_target *target = req-&gt;conn-&gt;session-&gt;target; */
-/* 	struct iscsi_session *session; */
-/* 	struct iscsi_conn *conn; */
-/* 	struct istgt_cmd *cmnd, *tmp; */
-
-/* 	list_for_each_entry(session, &amp;target-&gt;session_list, list) { */
-/* 		list_for_each_entry(conn, &amp;session-&gt;conn_list, list) { */
-/* 			list_for_each_entry_safe(cmnd, tmp, &amp;conn-&gt;pdu_list, conn_list) { */
-/* 				if (cmnd == req) */
-/* 					continue; */
-
-/* 				if (all) */
-/* 					__cmnd_abort(cmnd); */
-/* 				else if (translate_lun(cmd_hdr(cmnd)-&gt;lun) == lun) */
-/* 					__cmnd_abort(cmnd); */
-/* 			} */
-/* 		} */
-/* 	} */
-
-/* 	return 0; */
-/* } */
-
-/* static void task_set_abort(struct istgt_cmd *req) */
-/* { */
-/* 	struct iscsi_session *session = req-&gt;conn-&gt;session; */
-/* 	struct iscsi_conn *conn; */
-/* 	struct istgt_cmd *cmnd, *tmp; */
-
-/* 	list_for_each_entry(conn, &amp;session-&gt;conn_list, list) { */
-/* 		list_for_each_entry_safe(cmnd, tmp, &amp;conn-&gt;pdu_list, conn_list) { */
-/* 			if (cmnd != req) */
-/* 				__cmnd_abort(cmnd); */
-/* 		} */
-/* 	} */
-/* } */
-
-static void execute_task_management(struct istgt_cmd *req)
-{
-/* 	struct iscsi_conn *conn = req-&gt;conn; */
-/* 	struct iscsi_target *target = conn-&gt;session-&gt;target; */
-	struct istgt_cmd *rsp;
-	struct iscsi_tm *req_hdr = (struct iscsi_tm *)&amp;req-&gt;pdu.bhs;
-	struct iscsi_tm_rsp *rsp_hdr;
-	int function = req_hdr-&gt;flags &amp; ISCSI_FLAG_TM_FUNC_MASK;
-
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_tm_rsp *)&amp;rsp-&gt;pdu.bhs;
-
-	rsp_hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
-/* 	rsp_hdr-&gt;response = ISCSI_TMF_RSP_COMPLETE; */
-	rsp_hdr-&gt;response = ISCSI_TMF_RSP_REJECTED;
-
-	eprintk(&quot;%x %d %x\n&quot;, cmd_itt(req), function, req_hdr-&gt;rtt);
-
-/* 	switch (function) { */
-/* 	case ISCSI_FUNCTION_ABORT_TASK: */
-/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
-/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
-/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
-/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
-/* 		lun = translate_lun(req_hdr-&gt;lun); */
-/* 		if (!volume_lookup(target, lun)) { */
-/* 			rsp_hdr-&gt;response = ISCSI_RESPONSE_UNKNOWN_LUN; */
-/* 			goto out; */
-/* 		} */
-/* 	} */
-
-/* 	switch (function) { */
-/* 	case ISCSI_FUNCTION_ABORT_TASK: */
-/* 		if ((err = cmnd_abort(conn-&gt;session, req_hdr-&gt;rtt)) &lt; 0) */
-/* 			rsp_hdr-&gt;response = -err; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_ABORT_TASK_SET: */
-/* 		task_set_abort(req); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_CLEAR_ACA: */
-/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_CLEAR_TASK_SET: */
-/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_LOGICAL_UNIT_RESET: */
-/* 		target_reset(req, translate_lun(req_hdr-&gt;lun), 0); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_TARGET_WARM_RESET: */
-/* 	case ISCSI_FUNCTION_TARGET_COLD_RESET: */
-/* 		target_reset(req, 0, 1); */
-/* 		if (function == ISCSI_FUNCTION_TARGET_COLD_RESET) */
-/* 			set_cmnd_close(rsp); */
-/* 		break; */
-/* 	case ISCSI_FUNCTION_TASK_REASSIGN: */
-/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_UNSUPPORTED; */
-/* 		break; */
-/* 	default: */
-/* 		rsp_hdr-&gt;response = ISCSI_RESPONSE_FUNCTION_REJECTED; */
-/* 		break; */
-/* 	} */
-/* out: */
-	iscsi_cmnd_init_write(rsp);
-}
-
-static void noop_out_exec(struct istgt_cmd *req)
-{
-	struct istgt_cmd *rsp;
-	struct iscsi_nopin *rsp_hdr;
-
-	if (cmd_itt(req) != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-
-		rsp_hdr = (struct iscsi_nopin *)&amp;rsp-&gt;pdu.bhs;
-		rsp_hdr-&gt;opcode = ISCSI_OP_NOOP_IN;
-		rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-		rsp_hdr-&gt;itt = req-&gt;pdu.bhs.itt;
-		rsp_hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-
-/* 		if (req-&gt;pdu.datasize) */
-/* 			assert(req-&gt;tio); */
-/* 		else */
-/* 			assert(!req-&gt;tio); */
-
-/* 		if (req-&gt;tio) { */
-/* 			tio_get(req-&gt;tio); */
-/* 			rsp-&gt;tio = req-&gt;tio; */
-/* 		} */
-
-		BUG_ON(get_pgcnt(req-&gt;pdu.datasize, 0) &gt;= ISCSI_CONN_IOV_MAX);
-		rsp-&gt;pdu.datasize = req-&gt;pdu.datasize;
-		iscsi_cmnd_init_write(rsp);
-	} else
-		iscsi_cmnd_remove(req);
-}
-
-static void logout_exec(struct istgt_cmd *req)
-{
-	struct iscsi_logout *req_hdr;
-	struct istgt_cmd *rsp;
-	struct iscsi_logout_rsp *rsp_hdr;
-
-	req_hdr = (struct iscsi_logout *)&amp;req-&gt;pdu.bhs;
-	rsp = iscsi_cmnd_create_rsp_cmnd(req, 1);
-	rsp_hdr = (struct iscsi_logout_rsp *)&amp;rsp-&gt;pdu.bhs;
-	rsp_hdr-&gt;opcode = ISCSI_OP_LOGOUT_RSP;
-	rsp_hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	rsp_hdr-&gt;itt = req_hdr-&gt;itt;
-	set_cmd_close(rsp);
-	iscsi_cmnd_init_write(rsp);
-}
-
-static void iscsi_cmnd_exec(struct istgt_cmd *cmnd)
-{
-	dprintk(&quot;%p,%x,%u\n&quot;, cmnd, cmd_opcode(cmnd),
-		cmnd-&gt;pdu.bhs.statsn);
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_OUT:
-		noop_out_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD:
-		scsi_cmnd_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC:
-		execute_task_management(cmnd);
-		break;
-	case ISCSI_OP_LOGOUT:
-		logout_exec(cmnd);
-		break;
-	case ISCSI_OP_SCSI_REJECT:
-		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-		break;
-	default:
-		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
-		break;
-	}
-}
-
-static void __cmnd_send_pdu(struct iscsi_conn *conn, struct scatterlist *sg,
-			    uint32_t offset, uint32_t size)
-{
-/* 	dprintk(D_GENERIC, &quot;%p %u,%u\n&quot;, tio, offset, size); */
-	offset += sg-&gt;offset;
-
-/* 	assert(offset &lt;= sg-&gt;offset + tio-&gt;size); */
-/* 	assert(offset + size &lt;= tio-&gt;offset + tio-&gt;size); */
-
-	conn-&gt;write_sg = sg;
-	conn-&gt;write_offset = offset;
-	conn-&gt;write_size += size;
-}
-
-static void cmnd_send_pdu(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	uint32_t size;
-
-	if (!cmnd-&gt;pdu.datasize)
-		return;
-
-	size = (cmnd-&gt;pdu.datasize + 3) &amp; -4;
-	BUG_ON(!cmnd-&gt;sg);
-	__cmnd_send_pdu(conn, cmnd-&gt;sg, 0, size);
-}
-
-static void set_cork(struct socket *sock, int on)
-{
-	int opt = on;
-	mm_segment_t oldfs;
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	sock-&gt;ops-&gt;setsockopt(sock, SOL_TCP, TCP_CORK, (void *)&amp;opt, sizeof(opt));
-	set_fs(oldfs);
-}
-
-void cmnd_release(struct istgt_cmd *cmnd, int force)
-{
-	struct istgt_cmd *req, *rsp;
-	int is_last = 0;
-
-	if (!cmnd)
-		return;
-
-	req = cmnd-&gt;req;
-	is_last = cmd_final(cmnd);
-
-	if (force) {
-		while (!list_empty(&amp;cmnd-&gt;pdu_list)) {
-			rsp = list_entry(cmnd-&gt;pdu_list.next, struct istgt_cmd, pdu_list);
-			list_del_init(&amp;rsp-&gt;list);
-			list_del(&amp;rsp-&gt;pdu_list);
-			iscsi_cmnd_remove(rsp);
-		}
-		list_del_init(&amp;cmnd-&gt;list);
-	}
-
-	if (cmd_hashed(cmnd))
-		cmnd_remove_hash(cmnd);
-
-	list_del_init(&amp;cmnd-&gt;pdu_list);
-	iscsi_cmnd_remove(cmnd);
-
-	if (is_last) {
-		BUG_ON(force);
-		BUG_ON(!req);
-		cmnd_release(req, 0);
-	}
-
-	return;
-}
-
-void cmnd_tx_start(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct iovec *iop;
-
-	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
-	BUG_ON(!cmnd);
-	iscsi_cmnd_set_length(&amp;cmnd-&gt;pdu);
-
-	set_cork(conn-&gt;sock, 1);
-
-	conn-&gt;write_iop = iop = conn-&gt;write_iov;
-	iop-&gt;iov_base = &amp;cmnd-&gt;pdu.bhs;
-	iop-&gt;iov_len = sizeof(cmnd-&gt;pdu.bhs);
-	iop++;
-	conn-&gt;write_size = sizeof(cmnd-&gt;pdu.bhs);
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_IN:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD_RSP:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_TEXT_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_SCSI_DATA_IN:
-	{
-		struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *)&amp;cmnd-&gt;pdu.bhs;
-		uint32_t offset;
-
-		cmnd_set_sn(cmnd, (rsp-&gt;flags &amp; ISCSI_FLAG_CMD_FINAL) ? 1 : 0);
-		offset = rsp-&gt;offset;
-		rsp-&gt;offset = cpu_to_be32(offset);
-		BUG_ON(!cmnd-&gt;sg);
-		__cmnd_send_pdu(conn, cmnd-&gt;sg, offset, cmnd-&gt;pdu.datasize);
-		break;
-	}
-	case ISCSI_OP_LOGOUT_RSP:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_R2T:
-		cmnd_set_sn(cmnd, 0);
-		cmnd-&gt;pdu.bhs.statsn = cpu_to_be32(conn-&gt;stat_sn);
-		break;
-	case ISCSI_OP_ASYNC_EVENT:
-		cmnd_set_sn(cmnd, 1);
-		break;
-	case ISCSI_OP_REJECT:
-		cmnd_set_sn(cmnd, 1);
-		cmnd_send_pdu(conn, cmnd);
-		break;
-	default:
-		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
-		break;
-	}
-
-	iop-&gt;iov_len = 0;
-	// move this?
-	conn-&gt;write_size = (conn-&gt;write_size + 3) &amp; -4;
-}
-
-void cmnd_tx_end(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-
-	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_SCSI_CMD_RSP:
-	case ISCSI_OP_SCSI_TMFUNC_RSP:
-	case ISCSI_OP_TEXT_RSP:
-	case ISCSI_OP_R2T:
-	case ISCSI_OP_ASYNC_EVENT:
-	case ISCSI_OP_REJECT:
-	case ISCSI_OP_SCSI_DATA_IN:
-	case ISCSI_OP_LOGOUT_RSP:
-		break;
-	default:
-		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
-		BUG_ON(1);
-		break;
-	}
-
-	if (cmd_close(cmnd))
-		conn_close(conn);
-
-	list_del_init(&amp;cmnd-&gt;list);
-	set_cork(cmnd-&gt;conn-&gt;sock, 0);
-}
-
-/**
- * Push the command for execution.
- * This functions reorders the commands.
- * Called from the read thread.
- *
- * iscsi_session_push_cmnd - 
- * @cmnd: ptr to command
- */
-
-static void iscsi_session_push_cmnd(struct istgt_cmd *cmnd)
-{
-	struct iscsi_session *session = cmnd-&gt;conn-&gt;session;
-	struct list_head *entry;
-	uint32_t cmd_sn;
-
-	dprintk(&quot;%p:%x %u,%u\n&quot;,
-		cmnd, cmd_opcode(cmnd), cmnd-&gt;pdu.bhs.statsn,
-		session-&gt;exp_cmd_sn);
-
-	if (cmnd-&gt;pdu.bhs.opcode &amp; ISCSI_OP_IMMEDIATE) {
-		iscsi_cmnd_exec(cmnd);
-		return;
-	}
-
-	cmd_sn = cmnd-&gt;pdu.bhs.statsn;
-	if (cmd_sn == session-&gt;exp_cmd_sn) {
-		while (1) {
-			session-&gt;exp_cmd_sn = ++cmd_sn;
-			iscsi_cmnd_exec(cmnd);
-
-			if (list_empty(&amp;session-&gt;pending_list))
-				break;
-			cmnd = list_entry(session-&gt;pending_list.next, struct istgt_cmd, list);
-			if (cmnd-&gt;pdu.bhs.statsn != cmd_sn)
-				break;
-/* 			eprintk(&quot;find out-of-order %x %u %u\n&quot;, */
-/* 				cmd_itt(cmnd), cmd_sn, cmnd-&gt;pdu.bhs.statsn); */
-			list_del_init(&amp;cmnd-&gt;list);
-			clear_cmd_pending(cmnd);
-		}
-	} else {
-/* 		eprintk(&quot;out-of-order %x %u %u\n&quot;, */
-/* 			cmd_itt(cmnd), cmd_sn, session-&gt;exp_cmd_sn); */
-
-		set_cmd_pending(cmnd);
-		if (before(cmd_sn, session-&gt;exp_cmd_sn)) /* close the conn */
-			eprintk(&quot;unexpected cmd_sn (%u,%u)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
-
-		if (after(cmd_sn, session-&gt;exp_cmd_sn + session-&gt;max_queued_cmnds))
-			eprintk(&quot;too large cmd_sn (%u,%u)\n&quot;, cmd_sn, session-&gt;exp_cmd_sn);
-
-		list_for_each(entry, &amp;session-&gt;pending_list) {
-			struct istgt_cmd *tmp = list_entry(entry, struct istgt_cmd, list);
-			if (before(cmd_sn, tmp-&gt;pdu.bhs.statsn))
-				break;
-		}
-
-		BUG_ON(!list_empty(&amp;cmnd-&gt;list));
-
-		list_add_tail(&amp;cmnd-&gt;list, entry);
-	}
-}
-
-static int check_segment_length(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
-
-	if (cmnd-&gt;pdu.datasize &gt; param-&gt;max_recv_data_length) {
-		eprintk(&quot;too lond data %x %u %u\n&quot;, cmd_itt(cmnd),
-			cmnd-&gt;pdu.datasize, param-&gt;max_recv_data_length);
-
-		if (get_pgcnt(cmnd-&gt;pdu.datasize, 0) &gt; ISCSI_CONN_IOV_MAX) {
-			conn_close(conn);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-void cmnd_rx_start(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	int err = 0;
-
-	if (check_segment_length(cmnd) &lt; 0)
-		return;
-
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_NOOP_OUT:
-		err = noop_out_start(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_CMD:
-		if (!(err = cmnd_insert_hash(cmnd)))
-			scsi_cmnd_start(conn, cmnd);
-		break;
-	case ISCSI_OP_SCSI_TMFUNC:
-		err = cmnd_insert_hash(cmnd);
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		data_out_start(conn, cmnd);
-		break;
-	case ISCSI_OP_LOGOUT:
-		err = cmnd_insert_hash(cmnd);
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
-		break;
-	default:
-		err = -ISCSI_REASON_CMD_NOT_SUPPORTED;
-		break;
-	}
-
-	if (err &lt; 0) {
-		eprintk(&quot;%x %x %d\n&quot;, cmd_opcode(cmnd), cmd_itt(cmnd), err);
-		iscsi_cmnd_reject(cmnd, -err);
-	}
-}
-
-void cmnd_rx_end(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-
-	dprintk(&quot;%p:%x\n&quot;, cmnd, cmd_opcode(cmnd));
-	switch (cmd_opcode(cmnd)) {
-	case ISCSI_OP_SCSI_REJECT:
-	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_SCSI_CMD:
-	case ISCSI_OP_SCSI_TMFUNC:
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_LOGOUT:
-		iscsi_session_push_cmnd(cmnd);
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		data_out_end(conn, cmnd);
-		break;
-	case ISCSI_OP_SNACK:
-		break;
-	case ISCSI_OP_PDU_REJECT:
-		iscsi_cmnd_init_write(get_rsp_cmnd(cmnd));
-		break;
-	case ISCSI_OP_DATA_REJECT:
-		cmnd_release(cmnd, 0);
-		break;
-	default:
-		eprintk(&quot;unexpected cmnd op %x\n&quot;, cmd_opcode(cmnd));
-		BUG();
-		break;
-	}
-}
-
-static int buffer_ready(struct scsi_cmnd *scmd,
-			void (*done)(struct scsi_cmnd *))
-{
-	struct istgt_cmd *cmnd = (struct istgt_cmd *) scmd-&gt;SCp.ptr;
-
-	cmnd-&gt;done = done;
-	complete(&amp;cmnd-&gt;event);
-	return 0;
-}
-
-
-static struct iscsi_sess_param default_session_param = {
-	.initial_r2t = 1,
-	.immediate_data = 1,
-	.max_connections = 1,
-	.max_recv_data_length = 8192,
-	.max_xmit_data_length = 8192,
-	.max_burst_length = 262144,
-	.first_burst_length = 65536,
-	.default_wait_time = 2,
-	.default_retain_time = 20,
-	.max_outstanding_r2t = 1,
-	.data_pdu_inorder = 1,
-	.data_sequence_inorder = 1,
-	.error_recovery_level = 0,
-	.header_digest = DIGEST_NONE,
-	.data_digest = DIGEST_NONE,
-	.ofmarker = 0,
-	.ifmarker = 0,
-	.ofmarkint = 2048,
-	.ifmarkint = 2048,
-};
-
-static struct iscsi_trgt_param default_target_param = {
-	.queued_cmnds = DEFAULT_NR_QUEUED_CMNDS,
-};
-
-static struct iscsi_transport istgt_transport;
-
-static struct iscsi_cls_session *
-istgt_session_create(struct scsi_transport_template *scsit,
-		     uint32_t initial_cmdsn, uint32_t *sid)
-{
-	struct Scsi_Host *shost;
-	struct iscsi_session *session;
-	nt err, i;
-
-	shost = iscsi_transport_create_session(scsit, &amp;istgt_transport);
-	if (!shost)
-		return NULL;
-
-	session = iscsi_hostdata(shost-&gt;hostdata);
-	memset(session, 0, sizeof(*session));
-
-	dprintk(&quot;%p %u %&quot; PRIx64 &quot;\n&quot;, session, session-&gt;shost-&gt;host_no);
-
-	session-&gt;shost = shost;
-	*sid = session-&gt;sid = shost-&gt;host_no;
-	memcpy(&amp;session-&gt;param, &amp;default_session_param,
-	       sizeof(default_session_param));
-	memcpy(&amp;session-&gt;trgt_param, &amp;default_target_param,
-	       sizeof(default_target_param));
-	init_MUTEX(&amp;session-&gt;target_sem);
-	INIT_LIST_HEAD(&amp;session-&gt;session_list);
-
-	session-&gt;max_queued_cmnds = session-&gt;trgt_param.queued_cmnds;
-	session-&gt;exp_cmd_sn = initial_cmdsn + 1;
-	session-&gt;max_cmd_sn = initial_cmdsn + 1;
-
-	INIT_LIST_HEAD(&amp;session-&gt;conn_list);
-	INIT_LIST_HEAD(&amp;session-&gt;pending_list);
-
-	spin_lock_init(&amp;session-&gt;cmnd_hash_lock);
-	for (i = 0; i &lt; ARRAY_SIZE(session-&gt;cmnd_hash); i++)
-		INIT_LIST_HEAD(&amp;session-&gt;cmnd_hash[i]);
-
-	session-&gt;next_ttt = 1;
-
-	nthread_init(session);
-	err = nthread_start(session);
-	if (err)
-		goto destroy_session;
-
-	return hostdata_session(shost-&gt;hostdata);
-
-destroy_session:
-	iscsi_transport_destroy_session(shost);
-	return NULL;
-}
-
-static void istgt_session_destroy(struct iscsi_cls_session *cls_session)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	int i;
-
-	dprintk(&quot;%&quot; PRIx64 &quot;\n&quot;, session-&gt;sid);
-
-	if (!list_empty(&amp;session-&gt;conn_list)) {
-		eprintk(&quot;%&quot; PRIx64 &quot; still have connections\n&quot;, session-&gt;sid);
-		BUG();
-	}
-
-	BUG_ON(!list_empty(&amp;session-&gt;conn_list));
-
-	for (i = 0; i &lt; ARRAY_SIZE(session-&gt;cmnd_hash); i++)
-		BUG_ON(!list_empty(&amp;session-&gt;cmnd_hash[i]));
-
-	down(&amp;session-&gt;target_sem);
-	up(&amp;session-&gt;target_sem);
-
-	nthread_stop(session);
-	iscsi_transport_destroy_session(shost);
-}
-
-static int
-istgt_conn_get_param(struct iscsi_cls_conn *cls_conn,
-		     enum iscsi_param key, uint32_t *value)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_sess_param *param = &amp;conn-&gt;session-&gt;param;
-
-	switch(key) {
-	case ISCSI_PARAM_MAX_RECV_DLENGTH:
-		*value = param-&gt;max_recv_data_length;
-		break;
-	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
-		*value = param-&gt;max_xmit_data_length;
-		break;
-	case ISCSI_PARAM_HDRDGST_EN:
-		*value = param-&gt;header_digest;
-		break;
-	case ISCSI_PARAM_DATADGST_EN:
-		*value = param-&gt;data_digest;
-		break;
-	default:
-		return ISCSI_ERR_PARAM_NOT_FOUND;
-	}
-
-	return 0;
-}
-
-static int
-istgt_session_get_param(struct iscsi_cls_session *cls_session,
-			enum iscsi_param key, uint32_t *value)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_sess_param *param = &amp;session-&gt;param;
-
-	switch(key) {
-	case ISCSI_PARAM_INITIAL_R2T_EN:
-		*value = param-&gt;initial_r2t;
-		break;
-	case ISCSI_PARAM_MAX_R2T:
-		*value = param-&gt;max_outstanding_r2t;
-		break;
-	case ISCSI_PARAM_IMM_DATA_EN:
-		*value = param-&gt;immediate_data;
-		break;
-	case ISCSI_PARAM_FIRST_BURST:
-		*value = param-&gt;first_burst_length;
-		break;
-	case ISCSI_PARAM_MAX_BURST:
-		*value = param-&gt;max_burst_length;
-		break;
-	case ISCSI_PARAM_PDU_INORDER_EN:
-		*value = param-&gt;data_pdu_inorder;
-		break;
-	case ISCSI_PARAM_DATASEQ_INORDER_EN:
-		*value = param-&gt;data_sequence_inorder;
-		break;
-	case ISCSI_PARAM_ERL:
-		*value = param-&gt;error_recovery_level;
-		break;
-	case ISCSI_PARAM_IFMARKER_EN:
-		*value = param-&gt;ifmarker;
-		break;
-	case ISCSI_PARAM_OFMARKER_EN:
-		*value = param-&gt;ofmarker;
-		break;
-	default:
-		return ISCSI_ERR_PARAM_NOT_FOUND;
-	}
-
-	return 0;
-}
-
-static int
-istgt_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param key,
-		uint32_t value)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_sess_param *param = &amp;session-&gt;param;
-
-	switch(key) {
-	case ISCSI_PARAM_MAX_RECV_DLENGTH:
-		param-&gt;max_recv_data_length = value;
-		break;
-	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
-		param-&gt;max_xmit_data_length = value;
-		break;
-	case ISCSI_PARAM_HDRDGST_EN:
-		param-&gt;header_digest = value;
-		break;
-	case ISCSI_PARAM_DATADGST_EN:
-		param-&gt;data_digest = value;
-		break;
-	case ISCSI_PARAM_INITIAL_R2T_EN:
-		param-&gt;initial_r2t = value;
-		break;
-	case ISCSI_PARAM_MAX_R2T:
-		param-&gt;max_outstanding_r2t = value;
-		break;
-	case ISCSI_PARAM_IMM_DATA_EN:
-		param-&gt;immediate_data = value;
-		break;
-	case ISCSI_PARAM_FIRST_BURST:
-		param-&gt;first_burst_length = value;
-		break;
-	case ISCSI_PARAM_MAX_BURST:
-		param-&gt;max_burst_length = value;
-		break;
-	case ISCSI_PARAM_PDU_INORDER_EN:
-		param-&gt;data_pdu_inorder = value;
-		break;
-	case ISCSI_PARAM_DATASEQ_INORDER_EN:
-		param-&gt;data_sequence_inorder = value;
-		break;
-	case ISCSI_PARAM_ERL:
-		param-&gt;error_recovery_level = value;
-		break;
-	case ISCSI_PARAM_IFMARKER_EN:
-		param-&gt;ifmarker = value;
-		break;
-	case ISCSI_PARAM_OFMARKER_EN:
-		param-&gt;ofmarker = value;
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-static struct scsi_host_template istgt_sht = {
-	.name			= THIS_NAME,
-	.module			= THIS_MODULE,
-	.can_queue		= DEFAULT_NR_QUEUED_CMNDS,
-	.sg_tablesize		= SG_ALL,
-	.max_sectors		= 65536,	/* really no limit */
-	.use_clustering		= DISABLE_CLUSTERING, /* do we support this,  ihave to double check */
-	.transfer_response	= scsi_cmnd_done,
-	.transfer_data		= buffer_ready,
-};
-
-static struct iscsi_transport istgt_transport = {
-	.owner			= THIS_MODULE,
-	.name			= &quot;tcp_tgt&quot;,
-	.host_template		= &amp;istgt_sht,
-	.hostdata_size		= sizeof(struct iscsi_session),
-	.max_conn		= 1,
-	.max_cmd_len		= 16,
-	.create_session		= istgt_session_create,
-	.destroy_session	= istgt_session_destroy, 
-	.create_conn		= istgt_conn_create,
-	.destroy_conn		= istgt_conn_destroy,
-	.bind_conn		= istgt_conn_bind,
-	.start_conn		= istgt_conn_start,
-	.set_param		= istgt_set_param,
-	.get_session_param	= istgt_session_get_param,
-	.get_conn_param		= istgt_conn_get_param,
-
-};
-
-static void istgt_exit(void)
-{
-	kmem_cache_destroy(istgt_cmd_cache);
-	iscsi_unregister_transport(&amp;istgt_transport);
-}
-
-static int istgt_init(void)
-{
-	printk(&quot;iSCSI Target Software for Linux Target Framework %s\n&quot;,
-	       VERSION_STRING);
-
-	istgt_cmd_cache = kmem_cache_create(&quot;istgt_cmd&quot;,
-					    sizeof(struct istgt_cmd),
-					    0, 0, NULL, NULL);
-	if (!istgt_cmd_cache)
-		return -ENOMEM;
-
-	if (!iscsi_register_transport(&amp;istgt_transport))
-		goto free_cmd_cache;
-
-	return 0;
-
-free_cmd_cache:
-	kmem_cache_destroy(istgt_cmd_cache);
-	return -ENOMEM;
-
-}
-
-module_init(istgt_init);
-module_exit(istgt_exit);
-
-MODULE_LICENSE(&quot;GPL&quot;);

Deleted: branches/use-scsi-ml/istgt/kernel/nthread.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/nthread.c	2006-04-29 13:19:04 UTC (rev 428)
+++ branches/use-scsi-ml/istgt/kernel/nthread.c	2006-04-29 13:47:13 UTC (rev 429)
@@ -1,697 +0,0 @@
-/*
- * Network thread.
- * (C) 2004 - 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
- * This code is licenced under the GPL.
- */
-
-#include &lt;linux/sched.h&gt;
-#include &lt;linux/file.h&gt;
-#include &lt;linux/kthread.h&gt;
-#include &lt;asm/ioctls.h&gt;
-#include &lt;asm/scatterlist.h&gt;
-
-#include &lt;iscsi.h&gt;
-#include &lt;digest.h&gt;
-
-DECLARE_WAIT_QUEUE_HEAD(iscsi_ctl_wait);
-
-enum daemon_state_bit {
-	D_ACTIVE,
-	D_DATA_READY,
-};
-
-void nthread_wakeup(struct iscsi_session *session)
-{
-	struct network_thread_info *info = &amp;session-&gt;nthread_info;
-
-	spin_lock_bh(&amp;info-&gt;nthread_lock);
-	set_bit(D_DATA_READY, &amp;info-&gt;flags);
-	wake_up_process(info-&gt;task);
-	spin_unlock_bh(&amp;info-&gt;nthread_lock);
-}
-
-static inline void iscsi_conn_init_read(struct iscsi_conn *conn, void *data, size_t len)
-{
-	len = (len + 3) &amp; -4; // XXX ???
-	conn-&gt;read_iov[0].iov_base = data;
-	conn-&gt;read_iov[0].iov_len = len;
-	conn-&gt;read_msg.msg_iov = conn-&gt;read_iov;
-	conn-&gt;read_msg.msg_iovlen = 1;
-	conn-&gt;read_size = (len + 3) &amp; -4;
-}
-
-static void iscsi_conn_read_ahs(struct iscsi_conn *conn, struct istgt_cmd *cmnd)
-{
-	cmnd-&gt;pdu.ahs = kmalloc(cmnd-&gt;pdu.ahssize, __GFP_NOFAIL|GFP_KERNEL);
-	BUG_ON(!cmnd-&gt;pdu.ahs);
-	iscsi_conn_init_read(conn, cmnd-&gt;pdu.ahs, cmnd-&gt;pdu.ahssize);
-}
-
-static struct istgt_cmd * iscsi_get_send_cmnd(struct iscsi_conn *conn)
-{
-	struct istgt_cmd *cmnd = NULL;
-
-	spin_lock(&amp;conn-&gt;list_lock);
-	if (!list_empty(&amp;conn-&gt;write_list)) {
-		cmnd = list_entry(conn-&gt;write_list.next, struct istgt_cmd, list);
-		list_del_init(&amp;cmnd-&gt;list);
-	}
-	spin_unlock(&amp;conn-&gt;list_lock);
-
-	return cmnd;
-}
-
-static int is_data_available(struct iscsi_conn *conn)
-{
-	int avail, res;
-	mm_segment_t oldfs;
-	struct socket *sock = conn-&gt;sock;
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	res = sock-&gt;ops-&gt;ioctl(sock, SIOCINQ, (unsigned long) &amp;avail);
-	set_fs(oldfs);
-	return (res &gt;= 0) ? avail : res;
-}
-
-static void forward_iov(struct msghdr *msg, int len)
-{
-	while (msg-&gt;msg_iov-&gt;iov_len &lt;= len) {
-		len -= msg-&gt;msg_iov-&gt;iov_len;
-		msg-&gt;msg_iov++;
-		msg-&gt;msg_iovlen--;
-	}
-
-	msg-&gt;msg_iov-&gt;iov_base = (char *) msg-&gt;msg_iov-&gt;iov_base + len;
-	msg-&gt;msg_iov-&gt;iov_len -= len;
-}
-
-static int do_recv(struct iscsi_conn *conn, int state)
-{
-	mm_segment_t oldfs;
-	struct msghdr msg;
-	struct iovec iov[ISCSI_CONN_IOV_MAX];
-	int i, len, res;
-
-	if (!test_bit(CONN_ACTIVE, &amp;conn-&gt;state)) {
-		res = -EIO;
-		goto out;
-	}
-
-	if (is_data_available(conn) &lt;= 0) {
-		res = -EAGAIN;
-		goto out;
-	}
-
-	msg.msg_iov = iov;
-	msg.msg_iovlen = min_t(size_t, conn-&gt;read_msg.msg_iovlen, ISCSI_CONN_IOV_MAX);
-	for (i = 0, len = 0; i &lt; msg.msg_iovlen; i++) {
-		iov[i] = conn-&gt;read_msg.msg_iov[i];
-		len += iov[i].iov_len;
-	}
-
-	oldfs = get_fs();
-	set_fs(get_ds());
-	res = sock_recvmsg(conn-&gt;sock, &amp;msg, len, MSG_DONTWAIT | MSG_NOSIGNAL);
-	set_fs(oldfs);
-
-	if (res &lt;= 0) {
-		switch (res) {
-		case -EAGAIN:
-		case -ERESTARTSYS:
-			break;
-		default:
-			eprintk(&quot;%d\n&quot;, res);
-			conn_close(conn);
-			break;
-		}
-	} else {
-		conn-&gt;read_size -= res;
-		if (conn-&gt;read_size)
-			forward_iov(&amp;conn-&gt;read_msg, res);
-		else
-			conn-&gt;read_state = state;
-	}
-
-out:
-	dprintk(&quot;%d\n&quot;, res);
-
-	return res;
-}
-
-enum rx_state {
-	RX_INIT_BHS, /* Must be zero. */
-	RX_BHS,
-
-	RX_INIT_AHS,
-	RX_AHS,
-
-	RX_INIT_HDIGEST,
-	RX_HDIGEST,
-	RX_CHECK_HDIGEST,
-
-	RX_INIT_DATA,
-	RX_DATA,
-
-	RX_INIT_DDIGEST,
-	RX_DDIGEST,
-	RX_CHECK_DDIGEST,
-
-	RX_END,
-};
-
-static void rx_ddigest(struct iscsi_conn *conn, int state)
-{
-	struct istgt_cmd *cmnd = conn-&gt;read_cmnd;
-	int res = digest_rx_data(cmnd);
-
-	if (!res)
-		conn-&gt;read_state = state;
-	else
-		conn_close(conn);
-}
-
-static void rx_hdigest(struct iscsi_conn *conn, int state)
-{
-	struct istgt_cmd *cmnd = conn-&gt;read_cmnd;
-	int res = digest_rx_header(cmnd);
-
-	if (!res)
-		conn-&gt;read_state = state;
-	else
-		conn_close(conn);
-}
-
-static struct istgt_cmd *create_cmnd(struct iscsi_conn *conn)
-{
-	struct istgt_cmd *cmnd;
-
-	cmnd = cmnd_alloc(conn, 1);
-	iscsi_conn_init_read(cmnd-&gt;conn, &amp;cmnd-&gt;pdu.bhs, sizeof(cmnd-&gt;pdu.bhs));
-	conn-&gt;read_state = RX_BHS;
-
-	return cmnd;
-}
-
-static int recv(struct iscsi_conn *conn)
-{
-	struct istgt_cmd *cmnd = conn-&gt;read_cmnd;
-	int hdigest, ddigest, res = 1;
-
-	if (!test_bit(CONN_ACTIVE, &amp;conn-&gt;state))
-		return -EIO;
-
-	hdigest = conn-&gt;hdigest_type &amp; DIGEST_NONE ? 0 : 1;
-	ddigest = conn-&gt;ddigest_type &amp; DIGEST_NONE ? 0 : 1;
-
-	switch (conn-&gt;read_state) {
-	case RX_INIT_BHS:
-		BUG_ON(cmnd);
-		cmnd = conn-&gt;read_cmnd = create_cmnd(conn);
-	case RX_BHS:
-		res = do_recv(conn, RX_INIT_AHS);
-		if (res &lt;= 0 || conn-&gt;read_state != RX_INIT_AHS)
-			break;
-	case RX_INIT_AHS:
-		iscsi_cmnd_get_length(&amp;cmnd-&gt;pdu);
-		if (cmnd-&gt;pdu.ahssize) {
-			iscsi_conn_read_ahs(conn, cmnd);
-			conn-&gt;read_state = RX_AHS;
-		} else
-			conn-&gt;read_state = hdigest ? RX_INIT_HDIGEST : RX_INIT_DATA;
-
-		if (conn-&gt;read_state != RX_AHS)
-			break;
-	case RX_AHS:
-		res = do_recv(conn, hdigest ? RX_INIT_HDIGEST : RX_INIT_DATA);
-		if (res &lt;= 0 || conn-&gt;read_state != RX_INIT_HDIGEST)
-			break;
-	case RX_INIT_HDIGEST:
-		iscsi_conn_init_read(conn, &amp;cmnd-&gt;hdigest, sizeof(uint32_t));
-		conn-&gt;read_state = RX_HDIGEST;
-	case RX_HDIGEST:
-		res = do_recv(conn, RX_CHECK_HDIGEST);
-		if (res &lt;= 0 || conn-&gt;read_state != RX_CHECK_HDIGEST)
-			break;
-	case RX_CHECK_HDIGEST:
-		rx_hdigest(conn, RX_INIT_DATA);
-		if (conn-&gt;read_state != RX_INIT_DATA)
-			break;
-	case RX_INIT_DATA:
-		cmnd_rx_start(cmnd);
-		conn-&gt;read_state = cmnd-&gt;pdu.datasize ? RX_DATA : RX_END;
-		if (conn-&gt;read_state != RX_DATA)
-			break;
-	case RX_DATA:
-		res = do_recv(conn, ddigest ? RX_INIT_DDIGEST : RX_END);
-		if (res &lt;= 0 || conn-&gt;read_state != RX_INIT_DDIGEST)
-			break;
-	case RX_INIT_DDIGEST:
-		iscsi_conn_init_read(conn, &amp;cmnd-&gt;ddigest, sizeof(uint32_t));
-		conn-&gt;read_state = RX_DDIGEST;
-	case RX_DDIGEST:
-		res = do_recv(conn, RX_CHECK_DDIGEST);
-		if (res &lt;= 0 || conn-&gt;read_state != RX_CHECK_DDIGEST)
-			break;
-	case RX_CHECK_DDIGEST:
-		rx_ddigest(conn, RX_END);
-		break;
-	default:
-		eprintk(&quot;%d %d %x\n&quot;, res, conn-&gt;read_state, cmd_opcode(cmnd));
-		BUG_ON(1);
-	}
-
-	if (res &lt;= 0)
-		return res;
-
-	if (conn-&gt;read_state != RX_END)
-		return res;
-
-	if (conn-&gt;read_size) {
-		eprintk(&quot;%d %x %d\n&quot;, res, cmd_opcode(cmnd), conn-&gt;read_size);
-		BUG_ON(1);
-	}
-
-	cmnd_rx_end(cmnd);
-	if (conn-&gt;read_size) {
-		eprintk(&quot;%x %d\n&quot;, cmd_opcode(cmnd), conn-&gt;read_size);
-		conn-&gt;read_state = RX_DATA;
-		return 1;
-	}
-
-	conn-&gt;read_cmnd = NULL;
-	conn-&gt;read_state = RX_INIT_BHS;
-
-	return 0;
-}
-
-/* This is taken from the Ardis code. */
-static int write_data(struct iscsi_conn *conn)
-{
-	mm_segment_t oldfs;
-	struct file *file;
-	struct socket *sock;
-	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
-	struct scatterlist *sg;
-	struct iovec *iop;
-	int saved_size, size, sendsize;
-	int offset, idx;
-	int flags, res;
-
-	file = conn-&gt;file;
-	saved_size = size = conn-&gt;write_size;
-	iop = conn-&gt;write_iop;
-
-	if (iop) while (1) {
-		loff_t off = 0;
-		unsigned long count;
-		struct iovec *vec;
-		int rest;
-
-		vec = iop;
-		for (count = 0; vec-&gt;iov_len; count++, vec++)
-			;
-		oldfs = get_fs();
-		set_fs(KERNEL_DS);
-		res = vfs_writev(file, (struct iovec __user *) iop, count, &amp;off);
-		set_fs(oldfs);
-		dprintk(&quot;%#Lx:%u: %d(%ld)\n&quot;,
-			(unsigned long long) conn-&gt;session-&gt;sid, conn-&gt;cid,
-			res, (long) iop-&gt;iov_len);
-		if (unlikely(res &lt;= 0)) {
-			if (res == -EAGAIN || res == -EINTR) {
-				conn-&gt;write_iop = iop;
-				goto out_iov;
-			}
-			goto err;
-		}
-
-		rest = res;
-		size -= res;
-		while (iop-&gt;iov_len &lt;= rest &amp;&amp; rest) {
-			rest -= iop-&gt;iov_len;
-			iop++;
-		}
-		iop-&gt;iov_base += rest;
-		iop-&gt;iov_len -= rest;
-
-		if (!iop-&gt;iov_len) {
-			conn-&gt;write_iop = NULL;
-			if (size)
-				break;
-			goto out_iov;
-		}
-	}
-
-	sg = conn-&gt;write_sg;
-	if (!sg) {
-		eprintk(&quot;warning data missing!\n&quot;);
-		return 0;
-	}
-	offset = conn-&gt;write_offset;
-	idx = offset &gt;&gt; PAGE_CACHE_SHIFT;
-	offset &amp;= ~PAGE_CACHE_MASK;
-
-	sock = conn-&gt;sock;
-	sendpage = sock-&gt;ops-&gt;sendpage ? : sock_no_sendpage;
-	flags = MSG_DONTWAIT;
-
-	while (1) {
-		sendsize = PAGE_CACHE_SIZE - offset;
-		if (size &lt;= sendsize) {
-			res = sendpage(sock, sg[idx].page, offset, size, flags);
-			dprintk(&quot;%s %#Lx:%u: %d(%lu,%u,%u)\n&quot;,
-				sock-&gt;ops-&gt;sendpage ? &quot;sendpage&quot; : &quot;writepage&quot;,
-				(unsigned long long ) conn-&gt;session-&gt;sid, conn-&gt;cid,
-				res, sg[idx].page-&gt;index, offset, size);
-			if (unlikely(res &lt;= 0)) {
-				if (res == -EAGAIN || res == -EINTR) {
-					goto out;
-				}
-				goto err;
-			}
-			if (res == size) {
-				conn-&gt;write_sg = NULL;
-				conn-&gt;write_size = 0;
-				return saved_size;
-			}
-			offset += res;
-			size -= res;
-			continue;
-		}
-
-		res = sendpage(sock, sg[idx].page, offset, sendsize, flags | MSG_MORE);
-		dprintk(&quot;%s %#Lx:%u: %d(%lu,%u,%u)\n&quot;,
-			sock-&gt;ops-&gt;sendpage ? &quot;sendpage&quot; : &quot;writepage&quot;,
-			(unsigned long long ) conn-&gt;session-&gt;sid, conn-&gt;cid,
-			res, sg[idx].page-&gt;index, offset, sendsize);
-		if (unlikely(res &lt;= 0)) {
-			if (res == -EAGAIN || res == -EINTR) {
-				goto out;
-			}
-			goto err;
-		}
-		if (res == sendsize) {
-			idx++;
-			offset = 0;
-		} else
-			offset += res;
-		size -= res;
-	}
- out:
-	conn-&gt;write_offset = (idx &lt;&lt; PAGE_CACHE_SHIFT) + offset;
- out_iov:
-	conn-&gt;write_size = size;
-	if ((saved_size == size) &amp;&amp; res == -EAGAIN)
-		return res;
-
-	return saved_size - size;
-
- err:
-	eprintk(&quot;error %d at %#Lx:%u\n&quot;, res,
-		(unsigned long long) conn-&gt;session-&gt;sid, conn-&gt;cid);
-	return res;
-}
-
-static void exit_tx(struct iscsi_conn *conn, int res)
-{
-	if (res &gt; 0)
-		return;
-
-	switch (res) {
-	case -EAGAIN:
-	case -ERESTARTSYS:
-		break;
-	default:
-		eprintk(&quot;%d %d %d\n&quot;, conn-&gt;write_size, conn-&gt;write_state, res);
-		conn_close(conn);
-		break;
-	}
-}
-
-static int tx_ddigest(struct istgt_cmd *cmnd, int state)
-{
-	int res, rest = cmnd-&gt;conn-&gt;write_size;
-	struct msghdr msg = {.msg_flags = MSG_NOSIGNAL | MSG_DONTWAIT};
-	struct kvec iov;
-
-	iov.iov_base = (char *) (&amp;cmnd-&gt;ddigest) + (sizeof(uint32_t) - rest);
-	iov.iov_len = rest;
-
-	res = kernel_sendmsg(cmnd-&gt;conn-&gt;sock, &amp;msg, &amp;iov, 1, rest);
-
-	if (res &gt; 0) {
-		cmnd-&gt;conn-&gt;write_size -= res;
-		if (!cmnd-&gt;conn-&gt;write_size)
-			cmnd-&gt;conn-&gt;write_state = state;
-	} else
-		exit_tx(cmnd-&gt;conn, res);
-
-	return res;
-}
-
-static void init_tx_hdigest(struct istgt_cmd *cmnd)
-{
-	struct iscsi_conn *conn = cmnd-&gt;conn;
-	struct iovec *iop;
-
-	if (conn-&gt;hdigest_type &amp; DIGEST_NONE)
-		return;
-
-	digest_tx_header(cmnd);
-
-	for (iop = conn-&gt;write_iop; iop-&gt;iov_len; iop++)
-		;
-	iop-&gt;iov_base = &amp;(cmnd-&gt;hdigest);
-	iop-&gt;iov_len = sizeof(uint32_t);
-	conn-&gt;write_size += sizeof(uint32_t);
-	iop++;
-	iop-&gt;iov_len = 0;
-
-	return;
-}
-
-enum tx_state {
-	TX_INIT, /* Must be zero. */
-	TX_BHS_DATA,
-	TX_INIT_DDIGEST,
-	TX_DDIGEST,
-	TX_END,
-};
-
-static int do_send(struct iscsi_conn *conn, int state)
-{
-	int res;
-
-	res = write_data(conn);
-
-	if (res &gt; 0) {
-		if (!conn-&gt;write_size)
-			conn-&gt;write_state = state;
-	} else
-		exit_tx(conn, res);
-
-	return res;
-}
-
-static int send(struct iscsi_conn *conn)
-{
-	struct istgt_cmd *cmnd = conn-&gt;write_cmnd;
-	int ddigest, res = 0;
-
-	ddigest = conn-&gt;ddigest_type != DIGEST_NONE ? 1 : 0;
-
-	switch (conn-&gt;write_state) {
-	case TX_INIT:
-		BUG_ON(cmnd);
-		cmnd = conn-&gt;write_cmnd = iscsi_get_send_cmnd(conn);
-		if (!cmnd)
-			return 0;
-		cmnd_tx_start(cmnd);
-		init_tx_hdigest(cmnd);
-		conn-&gt;write_state = TX_BHS_DATA;
-	case TX_BHS_DATA:
-		res = do_send(conn, ddigest &amp;&amp; cmnd-&gt;pdu.datasize ? TX_INIT_DDIGEST : TX_END);
-		if (res &lt;= 0 || conn-&gt;write_state != TX_INIT_DDIGEST)
-			break;
-	case TX_INIT_DDIGEST:
-		digest_tx_data(cmnd);
-		BUG_ON(cmnd-&gt;conn-&gt;write_size);
-		cmnd-&gt;conn-&gt;write_size += sizeof(uint32_t);
-		conn-&gt;write_state = TX_DDIGEST;
-	case TX_DDIGEST:
-		res = tx_ddigest(cmnd, TX_END);
-		break;
-	default:
-		eprintk(&quot;%d %d %x\n&quot;, res, conn-&gt;write_state, cmd_opcode(cmnd));
-		BUG_ON(1);
-	}
-
-	if (res &lt;= 0)
-		return res;
-
-	if (conn-&gt;write_state != TX_END)
-		return res;
-
-	if (conn-&gt;write_size) {
-		eprintk(&quot;%d %x %u\n&quot;, res, cmd_opcode(cmnd), conn-&gt;write_size);
-		BUG_ON(conn-&gt;write_size);
-	}
-	cmnd_tx_end(cmnd);
-	cmnd_release(cmnd, 0);
-	conn-&gt;write_cmnd = NULL;
-	conn-&gt;write_state = TX_INIT;
-
-	return 0;
-}
-
-static void process_io(struct iscsi_conn *conn)
-{
-	int res, wakeup = 0;
-
-	res = recv(conn);
-
-	if (is_data_available(conn) &gt; 0 || res &gt; 0)
-		wakeup = 1;
-
-	if (!test_bit(CONN_ACTIVE, &amp;conn-&gt;state)) {
-		wakeup = 1;
-		goto out;
-	}
-
-	res = send(conn);
-
-	if (!list_empty(&amp;conn-&gt;write_list) || conn-&gt;write_cmnd)
-		wakeup = 1;
-
-out:
-	if (wakeup)
-		nthread_wakeup(conn-&gt;session);
-
-	return;
-}
-
-static void close_conn(struct iscsi_conn *conn)
-{
-	struct iscsi_session *session = conn-&gt;session;
-	struct istgt_cmd *cmnd;
-
-	conn-&gt;sock-&gt;ops-&gt;shutdown(conn-&gt;sock, 2);
-
-	write_lock(&amp;conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
-	conn-&gt;sock-&gt;sk-&gt;sk_state_change = session-&gt;nthread_info.old_state_change;
-	conn-&gt;sock-&gt;sk-&gt;sk_data_ready = session-&gt;nthread_info.old_data_ready;
-	write_unlock(&amp;conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
-
-	fput(conn-&gt;file);
-	conn-&gt;file = NULL;
-	conn-&gt;sock = NULL;
-
-	while (atomic_read(&amp;conn-&gt;nr_busy_cmnds))
-		yield();
-
-	while (!list_empty(&amp;conn-&gt;pdu_list)) {
-		cmnd = list_entry(conn-&gt;pdu_list.next, struct istgt_cmd, conn_list);
-
-		list_del_init(&amp;cmnd-&gt;list);
-		cmnd_release(cmnd, 1);
-	}
-
-	if (atomic_read(&amp;conn-&gt;nr_cmnds)) {
-		eprintk(&quot;%u\n&quot;, atomic_read(&amp;conn-&gt;nr_cmnds));
-		list_for_each_entry(cmnd, &amp;conn-&gt;pdu_list, conn_list)
-			eprintk(&quot;%x %x\n&quot;, cmd_opcode(cmnd), cmd_itt(cmnd));
-		BUG_ON(1);
-	}
-
-	eprintk(&quot;%llu %d\n&quot;, session-&gt;sid, conn-&gt;cid);
-	conn_free(conn);
-}
-
-static int istd(void *arg)
-{
-	struct iscsi_session *session = arg;
-	struct network_thread_info *info = &amp;session-&gt;nthread_info;
-	struct iscsi_conn *conn, *tmp;
-
-	__set_current_state(TASK_RUNNING);
-	do {
-		spin_lock_bh(&amp;info-&gt;nthread_lock);
-		__set_current_state(TASK_INTERRUPTIBLE);
-
-		if (!test_bit(D_DATA_READY, &amp;info-&gt;flags)) {
-			spin_unlock_bh(&amp;info-&gt;nthread_lock);
-			schedule();
-			spin_lock_bh(&amp;info-&gt;nthread_lock);
-		}
-		__set_current_state(TASK_RUNNING);
-		clear_bit(D_DATA_READY, &amp;info-&gt;flags);
-		spin_unlock_bh(&amp;info-&gt;nthread_lock);
-
-		down(&amp;session-&gt;target_sem);
-		list_for_each_entry_safe(conn, tmp, &amp;info-&gt;active_conns, poll_list) {
-			if (test_bit(CONN_ACTIVE, &amp;conn-&gt;state))
-				process_io(conn);
-			else
-				close_conn(conn);
-		}
-		up(&amp;session-&gt;target_sem);
-
-	} while (!kthread_should_stop());
-
-	return 0;
-}
-
-int nthread_init(struct iscsi_session *session)
-{
-	struct network_thread_info *info = &amp;session-&gt;nthread_info;
-
-	info-&gt;flags = 0;
-	info-&gt;task = NULL;
-
-	info-&gt;old_state_change = NULL;
-	info-&gt;old_data_ready = NULL;
-
-	INIT_LIST_HEAD(&amp;info-&gt;active_conns);
-
-	spin_lock_init(&amp;info-&gt;nthread_lock);
-
-	return 0;
-}
-
-int nthread_start(struct iscsi_session *session)
-{
-	int err = 0;
-	struct network_thread_info *info = &amp;session-&gt;nthread_info;
-	struct task_struct *task;
-
-	if (info-&gt;task) {
-		eprintk(&quot;Target (%llu) already runs\n&quot;, session-&gt;sid);
-		return -EALREADY;
-	}
-
-	task = kthread_run(istd, session, &quot;istd%llu&quot;, session-&gt;sid);
-
-	if (IS_ERR(task))
-		err = PTR_ERR(task);
-	else
-		info-&gt;task = task;
-
-	return err;
-}
-
-int nthread_stop(struct iscsi_session *session)
-{
-	int err;
-	struct network_thread_info *info = &amp;session-&gt;nthread_info;
-
-	if (!info-&gt;task)
-		return -ESRCH;
-
-	err = kthread_stop(info-&gt;task);
-
-	if (!err)
-		info-&gt;task = NULL;
-
-	return err;
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000415.html">[Stgt-svn] r428 - branches/use-scsi-ml/istgt/kernel
</A></li>
	<LI>Next message: <A HREF="000417.html">[Stgt-svn] r430 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#416">[ date ]</a>
              <a href="thread.html#416">[ thread ]</a>
              <a href="subject.html#416">[ subject ]</a>
              <a href="author.html#416">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
