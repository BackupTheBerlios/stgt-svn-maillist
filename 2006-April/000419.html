<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r432 - in branches/use-scsi-ml/istgt: include kernel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r432%20-%20in%20branches/use-scsi-ml/istgt%3A%20include%20kernel&In-Reply-To=%3C200604291403.k3TE3WMA005965%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000418.html">
   <LINK REL="Next"  HREF="000420.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r432 - in branches/use-scsi-ml/istgt: include kernel</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r432%20-%20in%20branches/use-scsi-ml/istgt%3A%20include%20kernel&In-Reply-To=%3C200604291403.k3TE3WMA005965%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r432 - in branches/use-scsi-ml/istgt: include kernel">tomo at berlios.de
       </A><BR>
    <I>Sat Apr 29 16:03:32 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000418.html">[Stgt-svn] r431 - branches/use-scsi-ml/istgt/include
</A></li>
        <LI>Next message: <A HREF="000420.html">[Stgt-svn] r433 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#419">[ date ]</a>
              <a href="thread.html#419">[ thread ]</a>
              <a href="subject.html#419">[ subject ]</a>
              <a href="author.html#419">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-04-29 16:03:22 +0200 (Sat, 29 Apr 2006)
New Revision: 432

Added:
   branches/use-scsi-ml/istgt/include/iscsi_if.h
   branches/use-scsi-ml/istgt/include/iscsi_proto.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
   branches/use-scsi-ml/istgt/kernel/libiscsi.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
   branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c
   branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
Modified:
   branches/use-scsi-ml/istgt/kernel/Makefile
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
For convenience, took open-iscsi rev561 files.


Added: branches/use-scsi-ml/istgt/include/iscsi_if.h
===================================================================
--- branches/use-scsi-ml/istgt/include/iscsi_if.h	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/include/iscsi_if.h	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,311 @@
+/*
+ * iSCSI User/Kernel Shares (Defines, Constants, Protocol definitions, etc)
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_IF_H
+#define ISCSI_IF_H
+
+#include &lt;iscsi_proto.h&gt;
+
+#define UEVENT_BASE			10
+#define KEVENT_BASE			100
+#define ISCSI_ERR_BASE			1000
+
+enum iscsi_uevent_e {
+	ISCSI_UEVENT_UNKNOWN		= 0,
+
+	/* down events */
+	ISCSI_UEVENT_CREATE_SESSION	= UEVENT_BASE + 1,
+	ISCSI_UEVENT_DESTROY_SESSION	= UEVENT_BASE + 2,
+	ISCSI_UEVENT_CREATE_CONN	= UEVENT_BASE + 3,
+	ISCSI_UEVENT_DESTROY_CONN	= UEVENT_BASE + 4,
+	ISCSI_UEVENT_BIND_CONN		= UEVENT_BASE + 5,
+	ISCSI_UEVENT_SET_PARAM		= UEVENT_BASE + 6,
+	ISCSI_UEVENT_START_CONN		= UEVENT_BASE + 7,
+	ISCSI_UEVENT_STOP_CONN		= UEVENT_BASE + 8,
+	ISCSI_UEVENT_SEND_PDU		= UEVENT_BASE + 9,
+	ISCSI_UEVENT_GET_STATS		= UEVENT_BASE + 10,
+	ISCSI_UEVENT_GET_PARAM		= UEVENT_BASE + 11,
+
+	ISCSI_UEVENT_TRANSPORT_EP_CONNECT	= UEVENT_BASE + 12,
+	ISCSI_UEVENT_TRANSPORT_EP_POLL		= UEVENT_BASE + 13,
+	ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT	= UEVENT_BASE + 14,
+
+	/* up events */
+	ISCSI_KEVENT_RECV_PDU		= KEVENT_BASE + 1,
+	ISCSI_KEVENT_CONN_ERROR		= KEVENT_BASE + 2,
+	ISCSI_KEVENT_IF_ERROR		= KEVENT_BASE + 3,
+};
+
+struct iscsi_uevent {
+	uint32_t type; /* k/u events type */
+	uint32_t iferror; /* carries interface or resource errors */
+	uint64_t transport_handle;
+
+	union {
+		/* messages u -&gt; k */
+		struct msg_create_session {
+			uint32_t	initial_cmdsn;
+		} c_session;
+		struct msg_destroy_session {
+			uint32_t	sid;
+		} d_session;
+		struct msg_create_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn;
+		struct msg_bind_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	transport_eph;
+			uint32_t	is_leading;
+		} b_conn;
+		struct msg_destroy_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} d_conn;
+		struct msg_send_pdu {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	hdr_size;
+			uint32_t	data_size;
+		} send_pdu;
+		struct msg_set_param {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	param; /* enum iscsi_param */
+			uint32_t	len;
+		} set_param;
+		struct msg_start_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+		} start_conn;
+		struct msg_stop_conn {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	conn_handle;
+			uint32_t	flag;
+		} stop_conn;
+		struct msg_get_stats {
+			uint32_t	sid;
+			uint32_t	cid;
+		} get_stats;
+		struct msg_transport_connect {
+			uint32_t	non_blocking;
+		} ep_connect;
+		struct msg_transport_poll {
+			uint64_t	ep_handle;
+			uint32_t	timeout_ms;
+		} ep_poll;
+		struct msg_transport_disconnect {
+			uint64_t	ep_handle;
+		} ep_disconnect;
+	} u;
+	union {
+		/* messages k -&gt; u */
+		int			retcode;
+		struct msg_create_session_ret {
+			uint32_t	sid;
+			uint32_t	host_no;
+		} c_session_ret;
+		struct msg_create_conn_ret {
+			uint32_t	sid;
+			uint32_t	cid;
+		} c_conn_ret;			
+		struct msg_recv_req {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint64_t	recv_handle;
+		} recv_req;
+		struct msg_conn_error {
+			uint32_t	sid;
+			uint32_t	cid;
+			uint32_t	error; /* enum iscsi_err */
+		} connerror;
+		struct msg_transport_connect_ret {
+			uint64_t	handle;
+		} ep_connect_ret;
+	} r;
+} __attribute__ ((aligned (sizeof(uint64_t))));
+
+/*
+ * Common error codes
+ */
+enum iscsi_err {
+	ISCSI_OK			= 0,
+
+	ISCSI_ERR_DATASN		= ISCSI_ERR_BASE + 1,
+	ISCSI_ERR_DATA_OFFSET		= ISCSI_ERR_BASE + 2,
+	ISCSI_ERR_MAX_CMDSN		= ISCSI_ERR_BASE + 3,
+	ISCSI_ERR_EXP_CMDSN		= ISCSI_ERR_BASE + 4,
+	ISCSI_ERR_BAD_OPCODE		= ISCSI_ERR_BASE + 5,
+	ISCSI_ERR_DATALEN		= ISCSI_ERR_BASE + 6,
+	ISCSI_ERR_AHSLEN		= ISCSI_ERR_BASE + 7,
+	ISCSI_ERR_PROTO			= ISCSI_ERR_BASE + 8,
+	ISCSI_ERR_LUN			= ISCSI_ERR_BASE + 9,
+	ISCSI_ERR_BAD_ITT		= ISCSI_ERR_BASE + 10,
+	ISCSI_ERR_CONN_FAILED		= ISCSI_ERR_BASE + 11,
+	ISCSI_ERR_R2TSN			= ISCSI_ERR_BASE + 12,
+	ISCSI_ERR_SESSION_FAILED	= ISCSI_ERR_BASE + 13,
+	ISCSI_ERR_HDR_DGST		= ISCSI_ERR_BASE + 14,
+	ISCSI_ERR_DATA_DGST		= ISCSI_ERR_BASE + 15,
+	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16,
+	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
+};
+
+/*
+ * iSCSI Parameters (RFC3720)
+ */
+enum iscsi_param {
+	/* passed in using netlink set param */
+	ISCSI_PARAM_MAX_RECV_DLENGTH,
+	ISCSI_PARAM_MAX_XMIT_DLENGTH,
+	ISCSI_PARAM_HDRDGST_EN,
+	ISCSI_PARAM_DATADGST_EN,
+	ISCSI_PARAM_INITIAL_R2T_EN,
+	ISCSI_PARAM_MAX_R2T,
+	ISCSI_PARAM_IMM_DATA_EN,
+	ISCSI_PARAM_FIRST_BURST,
+	ISCSI_PARAM_MAX_BURST,
+	ISCSI_PARAM_PDU_INORDER_EN,
+	ISCSI_PARAM_DATASEQ_INORDER_EN,
+	ISCSI_PARAM_ERL,
+	ISCSI_PARAM_IFMARKER_EN,
+	ISCSI_PARAM_OFMARKER_EN,
+	ISCSI_PARAM_EXP_STATSN,
+	ISCSI_PARAM_TARGET_NAME,
+	ISCSI_PARAM_TPGT,
+	ISCSI_PARAM_PERSISTENT_ADDRESS,
+	ISCSI_PARAM_PERSISTENT_PORT,
+	ISCSI_PARAM_SESS_RECOVERY_TMO,
+
+	/* pased in through bind conn using transport_fd */
+	ISCSI_PARAM_CONN_PORT,
+	ISCSI_PARAM_CONN_ADDRESS,
+
+	/* must always be last */
+	ISCSI_PARAM_MAX,
+};
+
+#define ISCSI_MAX_RECV_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_RECV_DLENGTH)
+#define ISCSI_MAX_XMIT_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_XMIT_DLENGTH)
+#define ISCSI_HDRDGST_EN		(1 &lt;&lt; ISCSI_PARAM_HDRDGST_EN)
+#define ISCSI_DATADGST_EN		(1 &lt;&lt; ISCSI_PARAM_DATADGST_EN)
+#define ISCSI_INITIAL_R2T_EN		(1 &lt;&lt; ISCSI_PARAM_INITIAL_R2T_EN)
+#define ISCSI_MAX_R2T			(1 &lt;&lt; ISCSI_PARAM_MAX_R2T)
+#define ISCSI_IMM_DATA_EN		(1 &lt;&lt; ISCSI_PARAM_IMM_DATA_EN)
+#define ISCSI_FIRST_BURST		(1 &lt;&lt; ISCSI_PARAM_FIRST_BURST)
+#define ISCSI_MAX_BURST			(1 &lt;&lt; ISCSI_PARAM_MAX_BURST)
+#define ISCSI_PDU_INORDER_EN		(1 &lt;&lt; ISCSI_PARAM_PDU_INORDER_EN)
+#define ISCSI_DATASEQ_INORDER_EN	(1 &lt;&lt; ISCSI_PARAM_DATASEQ_INORDER_EN)
+#define ISCSI_ERL			(1 &lt;&lt; ISCSI_PARAM_ERL)
+#define ISCSI_IFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_IFMARKER_EN)
+#define ISCSI_OFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_EXP_STATSN		(1 &lt;&lt; ISCSI_PARAM_EXP_STATSN)
+#define ISCSI_TARGET_NAME		(1 &lt;&lt; ISCSI_PARAM_TARGET_NAME)
+#define ISCSI_TPGT			(1 &lt;&lt; ISCSI_PARAM_TPGT)
+#define ISCSI_PERSISTENT_ADDRESS	(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)
+#define ISCSI_PERSISTENT_PORT		(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_SESS_RECOVERY_TMO		(1 &lt;&lt; ISCSI_PARAM_SESS_RECOVERY_TMO)
+#define ISCSI_CONN_PORT			(1 &lt;&lt; ISCSI_PARAM_CONN_PORT)
+#define ISCSI_CONN_ADDRESS		(1 &lt;&lt; ISCSI_PARAM_CONN_ADDRESS)
+
+#define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
+#define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_hostdata - get LLD hostdata from scsi_host
+ * @_hostdata: pointer to scsi host's hostdata
+ **/
+#define iscsi_hostdata(_hostdata) ((void*)_hostdata + sizeof(unsigned long))
+
+/*
+ * These flags presents iSCSI Data-Path capabilities.
+ */
+#define CAP_RECOVERY_L0		0x1
+#define CAP_RECOVERY_L1		0x2
+#define CAP_RECOVERY_L2		0x4
+#define CAP_MULTI_R2T		0x8
+#define CAP_HDRDGST		0x10
+#define CAP_DATADGST		0x20
+#define CAP_MULTI_CONN		0x40
+#define CAP_TEXT_NEGO		0x80
+#define CAP_MARKERS		0x100
+
+/*
+ * These flags describes reason of stop_conn() call
+ */
+#define STOP_CONN_TERM		0x1
+#define STOP_CONN_SUSPEND	0x2
+#define STOP_CONN_RECOVER	0x3
+
+#define ISCSI_STATS_CUSTOM_MAX		32
+#define ISCSI_STATS_CUSTOM_DESC_MAX	64
+struct iscsi_stats_custom {
+	char desc[ISCSI_STATS_CUSTOM_DESC_MAX];
+	uint64_t value;
+};
+
+/*
+ * struct iscsi_stats - iSCSI Statistics (iSCSI MIB)
+ *
+ * Note: this structure contains counters collected on per-connection basis.
+ */
+struct iscsi_stats {
+	/* octets */
+	uint64_t txdata_octets;
+	uint64_t rxdata_octets;
+
+	/* xmit pdus */
+	uint32_t noptx_pdus;
+	uint32_t scsicmd_pdus;
+	uint32_t tmfcmd_pdus;
+	uint32_t login_pdus;
+	uint32_t text_pdus;
+	uint32_t dataout_pdus;
+	uint32_t logout_pdus;
+	uint32_t snack_pdus;
+
+	/* recv pdus */
+	uint32_t noprx_pdus;
+	uint32_t scsirsp_pdus;
+	uint32_t tmfrsp_pdus;
+	uint32_t textrsp_pdus;
+	uint32_t datain_pdus;
+	uint32_t logoutrsp_pdus;
+	uint32_t r2t_pdus;
+	uint32_t async_pdus;
+	uint32_t rjt_pdus;
+
+	/* errors */
+	uint32_t digest_err;
+	uint32_t timeout_err;
+
+	/*
+	 * iSCSI Custom Statistics support, i.e. Transport could
+	 * extend existing MIB statistics with its own specific statistics
+	 * up to ISCSI_STATS_CUSTOM_MAX
+	 */
+	uint32_t custom_length;
+	struct iscsi_stats_custom custom[0]
+		__attribute__ ((aligned (sizeof(uint64_t))));
+};
+
+#endif

Added: branches/use-scsi-ml/istgt/include/iscsi_proto.h
===================================================================
--- branches/use-scsi-ml/istgt/include/iscsi_proto.h	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/include/iscsi_proto.h	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,589 @@
+/*
+ * RFC 3720 (iSCSI) protocol data types
+ *
+ * Copyright (C) 2005 Dmitry Yusupov
+ * Copyright (C) 2005 Alex Aizman
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_PROTO_H
+#define ISCSI_PROTO_H
+
+#define ISCSI_VERSION_STR	&quot;0.3&quot;
+#define ISCSI_DATE_STR		&quot;22-Apr-2005&quot;
+#define ISCSI_DRAFT20_VERSION	0x00
+
+/* default iSCSI listen port for incoming connections */
+#define ISCSI_LISTEN_PORT	3260
+
+/* Padding word length */
+#define PAD_WORD_LEN		4
+
+/*
+ * useful common(control and data pathes) macro
+ */
+#define ntoh24(p) (((p)[0] &lt;&lt; 16) | ((p)[1] &lt;&lt; 8) | ((p)[2]))
+#define hton24(p, v) { \
+        p[0] = (((v) &gt;&gt; 16) &amp; 0xFF); \
+        p[1] = (((v) &gt;&gt; 8) &amp; 0xFF); \
+        p[2] = ((v) &amp; 0xFF); \
+}
+#define zero_data(p) {p[0]=0;p[1]=0;p[2]=0;}
+
+/*
+ * iSCSI Template Message Header
+ */
+struct iscsi_hdr {
+	uint8_t		opcode;
+	uint8_t		flags;		/* Final bit */
+	uint8_t		rsvd2[2];
+	uint8_t		hlength;	/* AHSs total length */
+	uint8_t		dlength[3];	/* Data length */
+	uint8_t		lun[8];
+	__be32		itt;		/* Initiator Task Tag */
+	__be32		ttt;		/* Target Task Tag */
+	__be32		statsn;
+	__be32		exp_statsn;
+	__be32		max_statsn;
+	uint8_t		other[12];
+};
+
+/************************* RFC 3720 Begin *****************************/
+
+#define ISCSI_RESERVED_TAG		0xffffffff
+
+/* Opcode encoding bits */
+#define ISCSI_OP_RETRY			0x80
+#define ISCSI_OP_IMMEDIATE		0x40
+#define ISCSI_OPCODE_MASK		0x3F
+
+/* Initiator Opcode values */
+#define ISCSI_OP_NOOP_OUT		0x00
+#define ISCSI_OP_SCSI_CMD		0x01
+#define ISCSI_OP_SCSI_TMFUNC		0x02
+#define ISCSI_OP_LOGIN			0x03
+#define ISCSI_OP_TEXT			0x04
+#define ISCSI_OP_SCSI_DATA_OUT		0x05
+#define ISCSI_OP_LOGOUT			0x06
+#define ISCSI_OP_SNACK			0x10
+
+#define ISCSI_OP_VENDOR1_CMD		0x1c
+#define ISCSI_OP_VENDOR2_CMD		0x1d
+#define ISCSI_OP_VENDOR3_CMD		0x1e
+#define ISCSI_OP_VENDOR4_CMD		0x1f
+
+/* Target Opcode values */
+#define ISCSI_OP_NOOP_IN		0x20
+#define ISCSI_OP_SCSI_CMD_RSP		0x21
+#define ISCSI_OP_SCSI_TMFUNC_RSP	0x22
+#define ISCSI_OP_LOGIN_RSP		0x23
+#define ISCSI_OP_TEXT_RSP		0x24
+#define ISCSI_OP_SCSI_DATA_IN		0x25
+#define ISCSI_OP_LOGOUT_RSP		0x26
+#define ISCSI_OP_R2T			0x31
+#define ISCSI_OP_ASYNC_EVENT		0x32
+#define ISCSI_OP_REJECT			0x3f
+
+struct iscsi_ahs_hdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t ahspec[5];
+};
+
+#define ISCSI_AHSTYPE_CDB		1
+#define ISCSI_AHSTYPE_RLENGTH		2
+
+/* iSCSI PDU Header */
+struct iscsi_cmd {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16 rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32 itt;	/* Initiator Task Tag */
+	__be32 data_length;
+	__be32 cmdsn;
+	__be32 exp_statsn;
+	uint8_t cdb[16];	/* SCSI Command Block */
+	/* Additional Data (Command Dependent) */
+};
+
+/* Command PDU flags */
+#define ISCSI_FLAG_CMD_FINAL		0x80
+#define ISCSI_FLAG_CMD_READ		0x40
+#define ISCSI_FLAG_CMD_WRITE		0x20
+#define ISCSI_FLAG_CMD_ATTR_MASK	0x07	/* 3 bits */
+
+/* SCSI Command Attribute values */
+#define ISCSI_ATTR_UNTAGGED		0
+#define ISCSI_ATTR_SIMPLE		1
+#define ISCSI_ATTR_ORDERED		2
+#define ISCSI_ATTR_HEAD_OF_QUEUE	3
+#define ISCSI_ATTR_ACA			4
+
+struct iscsi_rlength_ahdr {
+	__be16 ahslength;
+	uint8_t ahstype;
+	uint8_t reserved;
+	__be32 read_length;
+};
+
+/* SCSI Response Header */
+struct iscsi_cmd_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd1;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	exp_datasn;
+	__be32	bi_residual_count;
+	__be32	residual_count;
+	/* Response or Sense Data (optional) */
+};
+
+/* Command Response PDU flags */
+#define ISCSI_FLAG_CMD_BIDI_OVERFLOW	0x10
+#define ISCSI_FLAG_CMD_BIDI_UNDERFLOW	0x08
+#define ISCSI_FLAG_CMD_OVERFLOW		0x04
+#define ISCSI_FLAG_CMD_UNDERFLOW	0x02
+
+/* iSCSI Status values. Valid if Rsp Selector bit is not set */
+#define ISCSI_STATUS_CMD_COMPLETED	0
+#define ISCSI_STATUS_TARGET_FAILURE	1
+#define ISCSI_STATUS_SUBSYS_FAILURE	2
+
+/* Asynchronous Event Header */
+struct iscsi_async {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	uint8_t rsvd4[8];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t async_event;
+	uint8_t async_vcode;
+	__be16	param1;
+	__be16	param2;
+	__be16	param3;
+	uint8_t rsvd5[4];
+};
+
+/* iSCSI Event Codes */
+#define ISCSI_ASYNC_MSG_SCSI_EVENT			0
+#define ISCSI_ASYNC_MSG_REQUEST_LOGOUT			1
+#define ISCSI_ASYNC_MSG_DROPPING_CONNECTION		2
+#define ISCSI_ASYNC_MSG_DROPPING_ALL_CONNECTIONS	3
+#define ISCSI_ASYNC_MSG_PARAM_NEGOTIATION		4
+#define ISCSI_ASYNC_MSG_VENDOR_SPECIFIC			255
+
+/* NOP-Out Message */
+struct iscsi_nopout {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* NOP-In Message */
+struct iscsi_nopin {
+	uint8_t opcode;
+	uint8_t flags;
+	__be16	rsvd2;
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd4[12];
+};
+
+/* SCSI Task Management Message Header */
+struct iscsi_tm {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	__be32	refcmdsn;
+	__be32	exp_datasn;
+	uint8_t rsvd2[8];
+};
+
+#define ISCSI_FLAG_TM_FUNC_MASK			0x7F
+
+/* Function values */
+#define ISCSI_TM_FUNC_ABORT_TASK		1
+#define ISCSI_TM_FUNC_ABORT_TASK_SET		2
+#define ISCSI_TM_FUNC_CLEAR_ACA			3
+#define ISCSI_TM_FUNC_CLEAR_TASK_SET		4
+#define ISCSI_TM_FUNC_LOGICAL_UNIT_RESET	5
+#define ISCSI_TM_FUNC_TARGET_WARM_RESET		6
+#define ISCSI_TM_FUNC_TARGET_COLD_RESET		7
+#define ISCSI_TM_FUNC_TASK_REASSIGN		8
+
+/* SCSI Task Management Response Header */
+struct iscsi_tm_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Response values below */
+	uint8_t qualifier;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rtt;	/* Reference Task Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd3[12];
+};
+
+/* Response values */
+#define ISCSI_TMF_RSP_COMPLETE		0x00
+#define ISCSI_TMF_RSP_NO_TASK		0x01
+#define ISCSI_TMF_RSP_NO_LUN		0x02
+#define ISCSI_TMF_RSP_TASK_ALLEGIANT	0x03
+#define ISCSI_TMF_RSP_NO_FAILOVER	0x04
+#define ISCSI_TMF_RSP_NOT_SUPPORTED	0x05
+#define ISCSI_TMF_RSP_AUTH_FAILED	0x06
+#define ISCSI_TMF_RSP_REJECTED		0xff
+
+/* Ready To Transfer Header */
+struct iscsi_r2t_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t	hlength;
+	uint8_t	dlength[3];
+	uint8_t lun[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	ttt;	/* Target Transfer Tag */
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	r2tsn;
+	__be32	data_offset;
+	__be32	data_length;
+};
+
+/* SCSI Data Hdr */
+struct iscsi_data {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t rsvd3;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	rsvd4;
+	__be32	exp_statsn;
+	__be32	rsvd5;
+	__be32	datasn;
+	__be32	offset;
+	__be32	rsvd6;
+	/* Payload */
+};
+
+/* SCSI Data Response Hdr */
+struct iscsi_data_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2;
+	uint8_t cmd_status;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t lun[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	__be32	offset;
+	__be32	residual_count;
+};
+
+/* Data Response PDU flags */
+#define ISCSI_FLAG_DATA_ACK		0x40
+#define ISCSI_FLAG_DATA_OVERFLOW	0x04
+#define ISCSI_FLAG_DATA_UNDERFLOW	0x02
+#define ISCSI_FLAG_DATA_STATUS		0x01
+
+/* Text Header */
+struct iscsi_text {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+	/* Text - key=value pairs */
+};
+
+#define ISCSI_FLAG_TEXT_CONTINUE	0x40
+
+/* Text Response Header */
+struct iscsi_text_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd4[8];
+	__be32	itt;
+	__be32	ttt;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t rsvd5[12];
+	/* Text Response - key:value pairs */
+};
+
+/* Login Header */
+struct iscsi_login {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t min_version;	/* Min. version supported */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	__be16	rsvd3;
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd5[16];
+};
+
+/* Login PDU flags */
+#define ISCSI_FLAG_LOGIN_TRANSIT		0x80
+#define ISCSI_FLAG_LOGIN_CONTINUE		0x40
+#define ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK	0x0C	/* 2 bits */
+#define ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK	0x03	/* 2 bits */
+
+#define ISCSI_LOGIN_CURRENT_STAGE(flags) \
+	((flags &amp; ISCSI_FLAG_LOGIN_CURRENT_STAGE_MASK) &gt;&gt; 2)
+#define ISCSI_LOGIN_NEXT_STAGE(flags) \
+	(flags &amp; ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK)
+
+/* Login Response Header */
+struct iscsi_login_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t max_version;	/* Max. version supported */
+	uint8_t active_version;	/* Active version */
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t isid[6];	/* Initiator Session ID */
+	__be16	tsih;	/* Target Session Handle */
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd3;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	uint8_t status_class;	/* see Login RSP ststus classes below */
+	uint8_t status_detail;	/* see Login RSP Status details below */
+	uint8_t rsvd4[10];
+};
+
+/* Login stage (phase) codes for CSG, NSG */
+#define ISCSI_INITIAL_LOGIN_STAGE		-1
+#define ISCSI_SECURITY_NEGOTIATION_STAGE	0
+#define ISCSI_OP_PARMS_NEGOTIATION_STAGE	1
+#define ISCSI_FULL_FEATURE_PHASE		3
+
+/* Login Status response classes */
+#define ISCSI_STATUS_CLS_SUCCESS		0x00
+#define ISCSI_STATUS_CLS_REDIRECT		0x01
+#define ISCSI_STATUS_CLS_INITIATOR_ERR		0x02
+#define ISCSI_STATUS_CLS_TARGET_ERR		0x03
+
+/* Login Status response detail codes */
+/* Class-0 (Success) */
+#define ISCSI_LOGIN_STATUS_ACCEPT		0x00
+
+/* Class-1 (Redirection) */
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_TEMP	0x01
+#define ISCSI_LOGIN_STATUS_TGT_MOVED_PERM	0x02
+
+/* Class-2 (Initiator Error) */
+#define ISCSI_LOGIN_STATUS_INIT_ERR		0x00
+#define ISCSI_LOGIN_STATUS_AUTH_FAILED		0x01
+#define ISCSI_LOGIN_STATUS_TGT_FORBIDDEN	0x02
+#define ISCSI_LOGIN_STATUS_TGT_NOT_FOUND	0x03
+#define ISCSI_LOGIN_STATUS_TGT_REMOVED		0x04
+#define ISCSI_LOGIN_STATUS_NO_VERSION		0x05
+#define ISCSI_LOGIN_STATUS_ISID_ERROR		0x06
+#define ISCSI_LOGIN_STATUS_MISSING_FIELDS	0x07
+#define ISCSI_LOGIN_STATUS_CONN_ADD_FAILED	0x08
+#define ISCSI_LOGIN_STATUS_NO_SESSION_TYPE	0x09
+#define ISCSI_LOGIN_STATUS_NO_SESSION		0x0a
+#define ISCSI_LOGIN_STATUS_INVALID_REQUEST	0x0b
+
+/* Class-3 (Target Error) */
+#define ISCSI_LOGIN_STATUS_TARGET_ERROR		0x00
+#define ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE	0x01
+#define ISCSI_LOGIN_STATUS_NO_RESOURCES		0x02
+
+/* Logout Header */
+struct iscsi_logout {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd1[2];
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd2[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be16	cid;
+	uint8_t rsvd3[2];
+	__be32	cmdsn;
+	__be32	exp_statsn;
+	uint8_t rsvd4[16];
+};
+
+/* Logout PDU flags */
+#define ISCSI_FLAG_LOGOUT_REASON_MASK	0x7F
+
+/* logout reason_code values */
+
+#define ISCSI_LOGOUT_REASON_CLOSE_SESSION	0
+#define ISCSI_LOGOUT_REASON_CLOSE_CONNECTION	1
+#define ISCSI_LOGOUT_REASON_RECOVERY		2
+#define ISCSI_LOGOUT_REASON_AEN_REQUEST		3
+
+/* Logout Response Header */
+struct iscsi_logout_rsp {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t response;	/* see Logout response values below */
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32	itt;	/* Initiator Task Tag */
+	__be32	rsvd4;
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	rsvd5;
+	__be16	t2wait;
+	__be16	t2retain;
+	__be32	rsvd6;
+};
+
+/* logout response status values */
+
+#define ISCSI_LOGOUT_SUCCESS			0
+#define ISCSI_LOGOUT_CID_NOT_FOUND		1
+#define ISCSI_LOGOUT_RECOVERY_UNSUPPORTED	2
+#define ISCSI_LOGOUT_CLEANUP_FAILED		3
+
+/* SNACK Header */
+struct iscsi_snack {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t rsvd2[14];
+	__be32	itt;
+	__be32	begrun;
+	__be32	runlength;
+	__be32	exp_statsn;
+	__be32	rsvd3;
+	__be32	exp_datasn;
+	uint8_t rsvd6[8];
+};
+
+/* SNACK PDU flags */
+#define ISCSI_FLAG_SNACK_TYPE_MASK	0x0F	/* 4 bits */
+
+/* Reject Message Header */
+struct iscsi_reject {
+	uint8_t opcode;
+	uint8_t flags;
+	uint8_t reason;
+	uint8_t rsvd2;
+	uint8_t hlength;
+	uint8_t dlength[3];
+	uint8_t rsvd3[8];
+	__be32  ffffffff;
+	uint8_t rsvd4[4];
+	__be32	statsn;
+	__be32	exp_cmdsn;
+	__be32	max_cmdsn;
+	__be32	datasn;
+	uint8_t rsvd5[8];
+	/* Text - Rejected hdr */
+};
+
+/* Reason for Reject */
+#define ISCSI_REASON_CMD_BEFORE_LOGIN	1
+#define ISCSI_REASON_DATA_DIGEST_ERROR	2
+#define ISCSI_REASON_DATA_SNACK_REJECT	3
+#define ISCSI_REASON_PROTOCOL_ERROR	4
+#define ISCSI_REASON_CMD_NOT_SUPPORTED	5
+#define ISCSI_REASON_IMM_CMD_REJECT		6
+#define ISCSI_REASON_TASK_IN_PROGRESS	7
+#define ISCSI_REASON_INVALID_SNACK		8
+#define ISCSI_REASON_BOOKMARK_INVALID	9
+#define ISCSI_REASON_BOOKMARK_NO_RESOURCES	10
+#define ISCSI_REASON_NEGOTIATION_RESET	11
+
+/* Max. number of Key=Value pairs in a text message */
+#define MAX_KEY_VALUE_PAIRS	8192
+
+/* maximum length for text keys/values */
+#define KEY_MAXLEN		64
+#define VALUE_MAXLEN		255
+#define TARGET_NAME_MAXLEN	VALUE_MAXLEN
+
+#define DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH	8192
+
+/************************* RFC 3720 End *****************************/
+
+#endif /* ISCSI_PROTO_H */

Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-04-29 14:03:22 UTC (rev 432)
@@ -7,11 +7,13 @@
 #
 # Note 2! The CFLAGS definitions are now in the main makefile.
 
-EXTRA_CFLAGS += -I$(obj) -I$(KERNELSRC)/drivers/scsi/
+EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include
 
 ifneq ($(KERNELRELEASE),)
 obj-m		+= iscsi_tcp_tgt.o
-#obj-m		+= libistgt.o
+obj-m		+= scsi_transport_iscsi.o
+obj-m		+= libiscsi.o
+obj-m		+= iscsi_tcp.o
 else
 
 ifeq ($(KERNELSRC),)

Added: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,2620 @@
+/*
+ * iSCSI Initiator over TCP/IP Data-Path
+ *
+ * Copyright (C) 2004 Dmitry Yusupov
+ * Copyright (C) 2004 Alex Aizman
+ * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ *
+ * Credits:
+ *	Christoph Hellwig
+ *	FUJITA Tomonori
+ *	Arne Redlich
+ *	Zhenyu Wang
+ */
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/list.h&gt;
+#include &lt;linux/inet.h&gt;
+#include &lt;linux/blkdev.h&gt;
+#include &lt;linux/crypto.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/kfifo.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;net/tcp.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
+#include &lt;scsi/scsi_host.h&gt;
+#include &lt;scsi/scsi.h&gt;
+#include &quot;scsi_transport_iscsi.h&quot;
+
+#include &quot;iscsi_tcp.h&quot;
+
+MODULE_AUTHOR(&quot;Dmitry Yusupov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">dmitry_yus at yahoo.com</A>&gt;, &quot;
+	      &quot;Alex Aizman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">itn780 at yahoo.com</A>&gt;&quot;);
+MODULE_DESCRIPTION(&quot;iSCSI/TCP data-path&quot;);
+MODULE_LICENSE(&quot;GPL&quot;);
+MODULE_VERSION(&quot;0:4.445&quot;);
+/* #define DEBUG_TCP */
+#define DEBUG_ASSERT
+
+#ifdef DEBUG_TCP
+#define debug_tcp(fmt...) printk(KERN_INFO &quot;tcp: &quot; fmt)
+#else
+#define debug_tcp(fmt...)
+#endif
+
+#ifndef DEBUG_ASSERT
+#ifdef BUG_ON
+#undef BUG_ON
+#endif
+#define BUG_ON(expr)
+#endif
+
+static unsigned int iscsi_max_lun = 512;
+module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
+
+/* global data */
+static kmem_cache_t *taskcache;
+
+static inline void
+iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
+{
+	sg_init_one(&amp;ibuf-&gt;sg, (u8 *)vbuf, size);
+	ibuf-&gt;sent = 0;
+	ibuf-&gt;use_sendmsg = 0;
+}
+
+static inline void
+iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
+{
+	ibuf-&gt;sg.page = virt_to_page(vbuf);
+	ibuf-&gt;sg.offset = offset_in_page(vbuf);
+	ibuf-&gt;sg.length = size;
+	ibuf-&gt;sent = 0;
+	ibuf-&gt;use_sendmsg = 1;
+}
+
+static inline void
+iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
+{
+	ibuf-&gt;sg.page = sg-&gt;page;
+	ibuf-&gt;sg.offset = sg-&gt;offset;
+	ibuf-&gt;sg.length = sg-&gt;length;
+	/*
+	 * Fastpath: sg element fits into single page
+	 */
+	if (sg-&gt;length + sg-&gt;offset &lt;= PAGE_SIZE &amp;&amp; !PageSlab(sg-&gt;page))
+		ibuf-&gt;use_sendmsg = 0;
+	else
+		ibuf-&gt;use_sendmsg = 1;
+	ibuf-&gt;sent = 0;
+}
+
+static inline int
+iscsi_buf_left(struct iscsi_buf *ibuf)
+{
+	int rc;
+
+	rc = ibuf-&gt;sg.length - ibuf-&gt;sent;
+	BUG_ON(rc &lt; 0);
+	return rc;
+}
+
+static inline void
+iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
+		 u8* crc)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	crypto_digest_digest(tcp_conn-&gt;tx_tfm, &amp;buf-&gt;sg, 1, crc);
+	buf-&gt;sg.length += sizeof(uint32_t);
+}
+
+static inline int
+iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn)
+{
+	struct sk_buff *skb = tcp_conn-&gt;in.skb;
+
+	tcp_conn-&gt;in.zero_copy_hdr = 0;
+
+	if (tcp_conn-&gt;in.copy &gt;= tcp_conn-&gt;hdr_size &amp;&amp;
+	    tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER) {
+		/*
+		 * Zero-copy PDU Header: using connection context
+		 * to store header pointer.
+		 */
+		if (skb_shinfo(skb)-&gt;frag_list == NULL &amp;&amp;
+		    !skb_shinfo(skb)-&gt;nr_frags) {
+			tcp_conn-&gt;in.hdr = (struct iscsi_hdr *)
+				((char*)skb-&gt;data + tcp_conn-&gt;in.offset);
+			tcp_conn-&gt;in.zero_copy_hdr = 1;
+		} else {
+			/* ignoring return code since we checked
+			 * in.copy before */
+			skb_copy_bits(skb, tcp_conn-&gt;in.offset,
+				&amp;tcp_conn-&gt;hdr, tcp_conn-&gt;hdr_size);
+			tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
+		}
+		tcp_conn-&gt;in.offset += tcp_conn-&gt;hdr_size;
+		tcp_conn-&gt;in.copy -= tcp_conn-&gt;hdr_size;
+	} else {
+		int hdr_remains;
+		int copylen;
+
+		/*
+		 * PDU header scattered across SKB's,
+		 * copying it... This'll happen quite rarely.
+		 */
+
+		if (tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER)
+			tcp_conn-&gt;in.hdr_offset = 0;
+
+		hdr_remains = tcp_conn-&gt;hdr_size - tcp_conn-&gt;in.hdr_offset;
+		BUG_ON(hdr_remains &lt;= 0);
+
+		copylen = min(tcp_conn-&gt;in.copy, hdr_remains);
+		skb_copy_bits(skb, tcp_conn-&gt;in.offset,
+			(char*)&amp;tcp_conn-&gt;hdr + tcp_conn-&gt;in.hdr_offset,
+			copylen);
+
+		debug_tcp(&quot;PDU gather offset %d bytes %d in.offset %d &quot;
+		       &quot;in.copy %d\n&quot;, tcp_conn-&gt;in.hdr_offset, copylen,
+		       tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
+
+		tcp_conn-&gt;in.offset += copylen;
+		tcp_conn-&gt;in.copy -= copylen;
+		if (copylen &lt; hdr_remains)  {
+			tcp_conn-&gt;in_progress = IN_PROGRESS_HEADER_GATHER;
+			tcp_conn-&gt;in.hdr_offset += copylen;
+		        return -EAGAIN;
+		}
+		tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
+		tcp_conn-&gt;discontiguous_hdr_cnt++;
+	        tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+	}
+
+	return 0;
+}
+
+/*
+ * must be called with session lock
+ */
+static void
+__iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct scsi_cmnd *sc;
+
+	sc = ctask-&gt;sc;
+	if (unlikely(!sc))
+		return;
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		struct iscsi_data_task *dtask, *n;
+
+		/* WRITE: cleanup Data-Out's if any */
+		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
+					 item) {
+			list_del(&amp;dtask-&gt;item);
+			mempool_free(dtask, tcp_ctask-&gt;datapool);
+		}
+	}
+	tcp_ctask-&gt;xmstate = XMSTATE_IDLE;
+	tcp_ctask-&gt;r2t = NULL;
+}
+
+/**
+ * iscsi_data_rsp - SCSI Data-In Response processing
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ **/
+static int
+iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	int rc;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn-&gt;in.hdr;
+	struct iscsi_session *session = conn-&gt;session;
+	int datasn = be32_to_cpu(rhdr-&gt;datasn);
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc)
+		return rc;
+	/*
+	 * setup Data-In byte counter (gets decremented..)
+	 */
+	ctask-&gt;data_count = tcp_conn-&gt;in.datalen;
+
+	if (tcp_conn-&gt;in.datalen == 0)
+		return 0;
+
+	if (ctask-&gt;datasn != datasn)
+		return ISCSI_ERR_DATASN;
+
+	ctask-&gt;datasn++;
+
+	tcp_ctask-&gt;data_offset = be32_to_cpu(rhdr-&gt;offset);
+	if (tcp_ctask-&gt;data_offset + tcp_conn-&gt;in.datalen &gt; ctask-&gt;total_length)
+		return ISCSI_ERR_DATA_OFFSET;
+
+	if (rhdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
+		struct scsi_cmnd *sc = ctask-&gt;sc;
+
+		conn-&gt;exp_statsn = be32_to_cpu(rhdr-&gt;statsn) + 1;
+		if (rhdr-&gt;flags &amp; ISCSI_FLAG_DATA_UNDERFLOW) {
+			int res_count = be32_to_cpu(rhdr-&gt;residual_count);
+
+			if (res_count &gt; 0 &amp;&amp;
+			    res_count &lt;= sc-&gt;request_bufflen) {
+				sc-&gt;resid = res_count;
+				sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
+			} else
+				sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) |
+					rhdr-&gt;cmd_status;
+		} else if (rhdr-&gt;flags &amp; ISCSI_FLAG_DATA_OVERFLOW) {
+			sc-&gt;resid = be32_to_cpu(rhdr-&gt;residual_count);
+			sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
+		} else
+			sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
+	}
+
+	conn-&gt;datain_pdus_cnt++;
+	return 0;
+}
+
+/**
+ * iscsi_solicit_data_init - initialize first Data-Out
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ * @r2t: R2T info
+ *
+ * Notes:
+ *	Initialize first Data-Out within this R2T sequence and finds
+ *	proper data_offset within this SCSI command.
+ *
+ *	This function is called with connection lock taken.
+ **/
+static void
+iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			struct iscsi_r2t_info *r2t)
+{
+	struct iscsi_data *hdr;
+	struct iscsi_data_task *dtask;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
+	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
+	hdr = &amp;dtask-&gt;hdr;
+	memset(hdr, 0, sizeof(struct iscsi_data));
+	hdr-&gt;ttt = r2t-&gt;ttt;
+	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
+	r2t-&gt;solicit_datasn++;
+	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
+	hdr-&gt;offset = cpu_to_be32(r2t-&gt;data_offset);
+	if (r2t-&gt;data_length &gt; conn-&gt;max_xmit_dlength) {
+		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
+		r2t-&gt;data_count = conn-&gt;max_xmit_dlength;
+		hdr-&gt;flags = 0;
+	} else {
+		hton24(hdr-&gt;dlength, r2t-&gt;data_length);
+		r2t-&gt;data_count = r2t-&gt;data_length;
+		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	}
+	conn-&gt;dataout_pdus_cnt++;
+
+	r2t-&gt;sent = 0;
+
+	iscsi_buf_init_virt(&amp;r2t-&gt;headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
+
+	r2t-&gt;dtask = dtask;
+
+	if (sc-&gt;use_sg) {
+		int i, sg_count = 0;
+		struct scatterlist *sg = sc-&gt;request_buffer;
+
+		r2t-&gt;sg = NULL;
+		for (i = 0; i &lt; sc-&gt;use_sg; i++, sg += 1) {
+			/* FIXME: prefetch ? */
+			if (sg_count + sg-&gt;length &gt; r2t-&gt;data_offset) {
+				int page_offset;
+
+				/* sg page found! */
+
+				/* offset within this page */
+				page_offset = r2t-&gt;data_offset - sg_count;
+
+				/* fill in this buffer */
+				iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, sg);
+				r2t-&gt;sendbuf.sg.offset += page_offset;
+				r2t-&gt;sendbuf.sg.length -= page_offset;
+
+				/* xmit logic will continue with next one */
+				r2t-&gt;sg = sg + 1;
+				break;
+			}
+			sg_count += sg-&gt;length;
+		}
+		BUG_ON(r2t-&gt;sg == NULL);
+	} else
+		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
+			    (char*)sc-&gt;request_buffer + r2t-&gt;data_offset,
+			    r2t-&gt;data_count);
+
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
+}
+
+/**
+ * iscsi_r2t_rsp - iSCSI R2T Response processing
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ **/
+static int
+iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_r2t_info *r2t;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn-&gt;in.hdr;
+	int r2tsn = be32_to_cpu(rhdr-&gt;r2tsn);
+	int rc;
+
+	if (tcp_conn-&gt;in.datalen)
+		return ISCSI_ERR_DATALEN;
+
+	if (tcp_ctask-&gt;exp_r2tsn &amp;&amp; tcp_ctask-&gt;exp_r2tsn != r2tsn)
+		return ISCSI_ERR_R2TSN;
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc)
+		return rc;
+
+	/* FIXME: use R2TSN to detect missing R2T */
+
+	/* fill-in new R2T associated with the task */
+	spin_lock(&amp;session-&gt;lock);
+	if (!ctask-&gt;sc || ctask-&gt;mtask ||
+	     session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		printk(KERN_INFO &quot;iscsi_tcp: dropping R2T itt %d in &quot;
+		       &quot;recovery...\n&quot;, ctask-&gt;itt);
+		spin_unlock(&amp;session-&gt;lock);
+		return 0;
+	}
+	rc = __kfifo_get(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+	BUG_ON(!rc);
+
+	r2t-&gt;exp_statsn = rhdr-&gt;statsn;
+	r2t-&gt;data_length = be32_to_cpu(rhdr-&gt;data_length);
+	if (r2t-&gt;data_length == 0 ||
+	    r2t-&gt;data_length &gt; session-&gt;max_burst) {
+		spin_unlock(&amp;session-&gt;lock);
+		return ISCSI_ERR_DATALEN;
+	}
+
+	r2t-&gt;data_offset = be32_to_cpu(rhdr-&gt;data_offset);
+	if (r2t-&gt;data_offset + r2t-&gt;data_length &gt; ctask-&gt;total_length) {
+		spin_unlock(&amp;session-&gt;lock);
+		return ISCSI_ERR_DATALEN;
+	}
+
+	r2t-&gt;ttt = rhdr-&gt;ttt; /* no flip */
+	r2t-&gt;solicit_datasn = 0;
+
+	iscsi_solicit_data_init(conn, ctask, r2t);
+
+	tcp_ctask-&gt;exp_r2tsn = r2tsn + 1;
+	tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
+	__kfifo_put(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
+	__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*));
+
+	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
+	conn-&gt;r2t_pdus_cnt++;
+	spin_unlock(&amp;session-&gt;lock);
+
+	return 0;
+}
+
+static int
+iscsi_tcp_hdr_recv(struct iscsi_conn *conn)
+{
+	int rc = 0, opcode, ahslen;
+	struct iscsi_hdr *hdr;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	uint32_t cdgst, rdgst = 0, itt;
+
+	hdr = tcp_conn-&gt;in.hdr;
+
+	/* verify PDU length */
+	tcp_conn-&gt;in.datalen = ntoh24(hdr-&gt;dlength);
+	if (tcp_conn-&gt;in.datalen &gt; conn-&gt;max_recv_dlength) {
+		printk(KERN_ERR &quot;iscsi_tcp: datalen %d &gt; %d\n&quot;,
+		       tcp_conn-&gt;in.datalen, conn-&gt;max_recv_dlength);
+		return ISCSI_ERR_DATALEN;
+	}
+	tcp_conn-&gt;data_copied = 0;
+
+	/* read AHS */
+	ahslen = hdr-&gt;hlength &lt;&lt; 2;
+	tcp_conn-&gt;in.offset += ahslen;
+	tcp_conn-&gt;in.copy -= ahslen;
+	if (tcp_conn-&gt;in.copy &lt; 0) {
+		printk(KERN_ERR &quot;iscsi_tcp: can't handle AHS with length &quot;
+		       &quot;%d bytes\n&quot;, ahslen);
+		return ISCSI_ERR_AHSLEN;
+	}
+
+	/* calculate read padding */
+	tcp_conn-&gt;in.padding = tcp_conn-&gt;in.datalen &amp; (ISCSI_PAD_LEN-1);
+	if (tcp_conn-&gt;in.padding) {
+		tcp_conn-&gt;in.padding = ISCSI_PAD_LEN - tcp_conn-&gt;in.padding;
+		debug_scsi(&quot;read padding %d bytes\n&quot;, tcp_conn-&gt;in.padding);
+	}
+
+	if (conn-&gt;hdrdgst_en) {
+		struct scatterlist sg;
+
+		sg_init_one(&amp;sg, (u8 *)hdr,
+			    sizeof(struct iscsi_hdr) + ahslen);
+		crypto_digest_digest(tcp_conn-&gt;rx_tfm, &amp;sg, 1, (u8 *)&amp;cdgst);
+		rdgst = *(uint32_t*)((char*)hdr + sizeof(struct iscsi_hdr) +
+				     ahslen);
+		if (cdgst != rdgst) {
+			printk(KERN_ERR &quot;iscsi_tcp: hdrdgst error &quot;
+			       &quot;recv 0x%x calc 0x%x\n&quot;, rdgst, cdgst);
+			return ISCSI_ERR_HDR_DGST;
+		}
+	}
+
+	opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
+	/* verify itt (itt encoding: age+cid+itt) */
+	rc = iscsi_verify_itt(conn, hdr, &amp;itt);
+	if (rc == ISCSI_ERR_NO_SCSI_CMD) {
+		tcp_conn-&gt;in.datalen = 0; /* force drop */
+		return 0;
+	} else if (rc)
+		return rc;
+
+	debug_tcp(&quot;opcode 0x%x offset %d copy %d ahslen %d datalen %d\n&quot;,
+		  opcode, tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy,
+		  ahslen, tcp_conn-&gt;in.datalen);
+
+	switch(opcode) {
+	case ISCSI_OP_SCSI_DATA_IN:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		rc = iscsi_data_rsp(conn, tcp_conn-&gt;in.ctask);
+		/* fall through */
+	case ISCSI_OP_SCSI_CMD_RSP:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		if (tcp_conn-&gt;in.datalen)
+			goto copy_hdr;
+
+		spin_lock(&amp;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn-&gt;in.ctask);
+		rc = __iscsi_complete_pdu(conn, hdr, NULL, 0);
+		spin_unlock(&amp;session-&gt;lock);
+		break;
+	case ISCSI_OP_R2T:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		if (ahslen)
+			rc = ISCSI_ERR_AHSLEN;
+		else if (tcp_conn-&gt;in.ctask-&gt;sc-&gt;sc_data_direction ==
+								DMA_TO_DEVICE)
+			rc = iscsi_r2t_rsp(conn, tcp_conn-&gt;in.ctask);
+		else
+			rc = ISCSI_ERR_PROTO;
+		break;
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_LOGOUT_RSP:
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_REJECT:
+	case ISCSI_OP_ASYNC_EVENT:
+		if (tcp_conn-&gt;in.datalen)
+			goto copy_hdr;
+	/* fall through */
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
+		break;
+	default:
+		rc = ISCSI_ERR_BAD_OPCODE;
+		break;
+	}
+
+	return rc;
+
+copy_hdr:
+	/*
+	 * if we did zero copy for the header but we will need multiple
+	 * skbs to complete the command then we have to copy the header
+	 * for later use
+	 */
+	if (tcp_conn-&gt;in.zero_copy_hdr &amp;&amp; tcp_conn-&gt;in.copy &lt;
+	   (tcp_conn-&gt;in.datalen + tcp_conn-&gt;in.padding +
+	    (conn-&gt;datadgst_en ? 4 : 0))) {
+		debug_tcp(&quot;Copying header for later use. in.copy %d in.datalen&quot;
+			  &quot; %d\n&quot;, tcp_conn-&gt;in.copy, tcp_conn-&gt;in.datalen);
+		memcpy(&amp;tcp_conn-&gt;hdr, tcp_conn-&gt;in.hdr,
+		       sizeof(struct iscsi_hdr));
+		tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
+		tcp_conn-&gt;in.zero_copy_hdr = 0;
+	}
+	return 0;
+}
+
+/**
+ * iscsi_ctask_copy - copy skb bits to the destanation cmd task
+ * @conn: iscsi tcp connection
+ * @ctask: scsi command task
+ * @buf: buffer to copy to
+ * @buf_size: size of buffer
+ * @offset: offset within the buffer
+ *
+ * Notes:
+ *	The function calls skb_copy_bits() and updates per-connection and
+ *	per-cmd byte counters.
+ *
+ *	Read counters (in bytes):
+ *
+ *	conn-&gt;in.offset		offset within in progress SKB
+ *	conn-&gt;in.copy		left to copy from in progress SKB
+ *				including padding
+ *	conn-&gt;in.copied		copied already from in progress SKB
+ *	conn-&gt;data_copied	copied already from in progress buffer
+ *	ctask-&gt;sent		total bytes sent up to the MidLayer
+ *	ctask-&gt;data_count	left to copy from in progress Data-In
+ *	buf_left		left to copy from in progress buffer
+ **/
+static inline int
+iscsi_ctask_copy(struct iscsi_tcp_conn *tcp_conn, struct iscsi_cmd_task *ctask,
+		void *buf, int buf_size, int offset)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	int buf_left = buf_size - (tcp_conn-&gt;data_copied + offset);
+	int size = min(tcp_conn-&gt;in.copy, buf_left);
+	int rc;
+
+	size = min(size, ctask-&gt;data_count);
+
+	debug_tcp(&quot;ctask_copy %d bytes at offset %d copied %d\n&quot;,
+	       size, tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copied);
+
+	BUG_ON(size &lt;= 0);
+	BUG_ON(tcp_ctask-&gt;sent + size &gt; ctask-&gt;total_length);
+
+	rc = skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
+			   (char*)buf + (offset + tcp_conn-&gt;data_copied), size);
+	/* must fit into skb-&gt;len */
+	BUG_ON(rc);
+
+	tcp_conn-&gt;in.offset += size;
+	tcp_conn-&gt;in.copy -= size;
+	tcp_conn-&gt;in.copied += size;
+	tcp_conn-&gt;data_copied += size;
+	tcp_ctask-&gt;sent += size;
+	ctask-&gt;data_count -= size;
+
+	BUG_ON(tcp_conn-&gt;in.copy &lt; 0);
+	BUG_ON(ctask-&gt;data_count &lt; 0);
+
+	if (buf_size != (tcp_conn-&gt;data_copied + offset)) {
+		if (!ctask-&gt;data_count) {
+			BUG_ON(buf_size - tcp_conn-&gt;data_copied &lt; 0);
+			/* done with this PDU */
+			return buf_size - tcp_conn-&gt;data_copied;
+		}
+		return -EAGAIN;
+	}
+
+	/* done with this buffer or with both - PDU and buffer */
+	tcp_conn-&gt;data_copied = 0;
+	return 0;
+}
+
+/**
+ * iscsi_tcp_copy - copy skb bits to the destanation buffer
+ * @conn: iscsi tcp connection
+ *
+ * Notes:
+ *	The function calls skb_copy_bits() and updates per-connection
+ *	byte counters.
+ **/
+static inline int
+iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn)
+{
+	void *buf = tcp_conn-&gt;data;
+	int buf_size = tcp_conn-&gt;in.datalen;
+	int buf_left = buf_size - tcp_conn-&gt;data_copied;
+	int size = min(tcp_conn-&gt;in.copy, buf_left);
+	int rc;
+
+	debug_tcp(&quot;tcp_copy %d bytes at offset %d copied %d\n&quot;,
+	       size, tcp_conn-&gt;in.offset, tcp_conn-&gt;data_copied);
+	BUG_ON(size &lt;= 0);
+
+	rc = skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
+			   (char*)buf + tcp_conn-&gt;data_copied, size);
+	BUG_ON(rc);
+
+	tcp_conn-&gt;in.offset += size;
+	tcp_conn-&gt;in.copy -= size;
+	tcp_conn-&gt;in.copied += size;
+	tcp_conn-&gt;data_copied += size;
+
+	if (buf_size != tcp_conn-&gt;data_copied)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static inline void
+partial_sg_digest_update(struct iscsi_tcp_conn *tcp_conn,
+			 struct scatterlist *sg, int offset, int length)
+{
+	struct scatterlist temp;
+
+	memcpy(&amp;temp, sg, sizeof(struct scatterlist));
+	temp.offset = offset;
+	temp.length = length;
+	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;temp, 1);
+}
+
+static void
+iscsi_recv_digest_update(struct iscsi_tcp_conn *tcp_conn, char* buf, int len)
+{
+	struct scatterlist tmp;
+
+	sg_init_one(&amp;tmp, buf, len);
+	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;tmp, 1);
+}
+
+static int iscsi_scsi_data_in(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn-&gt;in.ctask;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct scatterlist *sg;
+	int i, offset, rc = 0;
+
+	BUG_ON((void*)ctask != sc-&gt;SCp.ptr);
+
+	/*
+	 * copying Data-In into the Scsi_Cmnd
+	 */
+	if (!sc-&gt;use_sg) {
+		i = ctask-&gt;data_count;
+		rc = iscsi_ctask_copy(tcp_conn, ctask, sc-&gt;request_buffer,
+				      sc-&gt;request_bufflen,
+				      tcp_ctask-&gt;data_offset);
+		if (rc == -EAGAIN)
+			return rc;
+		if (conn-&gt;datadgst_en)
+			iscsi_recv_digest_update(tcp_conn, sc-&gt;request_buffer,
+						 i);
+		rc = 0;
+		goto done;
+	}
+
+	offset = tcp_ctask-&gt;data_offset;
+	sg = sc-&gt;request_buffer;
+
+	if (tcp_ctask-&gt;data_offset)
+		for (i = 0; i &lt; tcp_ctask-&gt;sg_count; i++)
+			offset -= sg[i].length;
+	/* we've passed through partial sg*/
+	if (offset &lt; 0)
+		offset = 0;
+
+	for (i = tcp_ctask-&gt;sg_count; i &lt; sc-&gt;use_sg; i++) {
+		char *dest;
+
+		dest = kmap_atomic(sg[i].page, KM_SOFTIRQ0);
+		rc = iscsi_ctask_copy(tcp_conn, ctask, dest + sg[i].offset,
+				      sg[i].length, offset);
+		kunmap_atomic(dest, KM_SOFTIRQ0);
+		if (rc == -EAGAIN)
+			/* continue with the next SKB/PDU */
+			return rc;
+		if (!rc) {
+			if (conn-&gt;datadgst_en) {
+				if (!offset)
+					crypto_digest_update(
+							tcp_conn-&gt;data_rx_tfm,
+							&amp;sg[i], 1);
+				else
+					partial_sg_digest_update(tcp_conn,
+							&amp;sg[i],
+							sg[i].offset + offset,
+							sg[i].length - offset);
+			}
+			offset = 0;
+			tcp_ctask-&gt;sg_count++;
+		}
+
+		if (!ctask-&gt;data_count) {
+			if (rc &amp;&amp; conn-&gt;datadgst_en)
+				/*
+				 * data-in is complete, but buffer not...
+				 */
+				partial_sg_digest_update(tcp_conn, &amp;sg[i],
+						sg[i].offset, sg[i].length-rc);
+			rc = 0;
+			break;
+		}
+
+		if (!tcp_conn-&gt;in.copy)
+			return -EAGAIN;
+	}
+	BUG_ON(ctask-&gt;data_count);
+
+done:
+	/* check for non-exceptional status */
+	if (tcp_conn-&gt;in.hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
+		debug_scsi(&quot;done [sc %lx res %d itt 0x%x]\n&quot;,
+			   (long)sc, sc-&gt;result, ctask-&gt;itt);
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, ctask);
+		__iscsi_complete_pdu(conn, tcp_conn-&gt;in.hdr, NULL, 0);
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
+	}
+
+	return rc;
+}
+
+static int
+iscsi_data_recv(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int rc = 0, opcode;
+
+	opcode = tcp_conn-&gt;in.hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
+	switch (opcode) {
+	case ISCSI_OP_SCSI_DATA_IN:
+		rc = iscsi_scsi_data_in(conn);
+		break;
+	case ISCSI_OP_SCSI_CMD_RSP:
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn-&gt;in.ctask);
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
+		/*
+		 * Collect data segment to the connection's data
+		 * placeholder
+		 */
+		if (iscsi_tcp_copy(tcp_conn)) {
+			rc = -EAGAIN;
+			goto exit;
+		}
+
+		rc = iscsi_complete_pdu(conn, tcp_conn-&gt;in.hdr, tcp_conn-&gt;data,
+					tcp_conn-&gt;in.datalen);
+		if (!rc &amp;&amp; conn-&gt;datadgst_en &amp;&amp; opcode != ISCSI_OP_LOGIN_RSP)
+			iscsi_recv_digest_update(tcp_conn, tcp_conn-&gt;data,
+			  			tcp_conn-&gt;in.datalen);
+		break;
+	default:
+		BUG_ON(1);
+	}
+exit:
+	return rc;
+}
+
+/**
+ * iscsi_tcp_data_recv - TCP receive in sendfile fashion
+ * @rd_desc: read descriptor
+ * @skb: socket buffer
+ * @offset: offset in skb
+ * @len: skb-&gt;len - offset
+ **/
+static int
+iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
+		unsigned int offset, size_t len)
+{
+	int rc;
+	struct iscsi_conn *conn = rd_desc-&gt;arg.data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int processed;
+	char pad[ISCSI_PAD_LEN];
+	struct scatterlist sg;
+
+	/*
+	 * Save current SKB and its offset in the corresponding
+	 * connection context.
+	 */
+	tcp_conn-&gt;in.copy = skb-&gt;len - offset;
+	tcp_conn-&gt;in.offset = offset;
+	tcp_conn-&gt;in.skb = skb;
+	tcp_conn-&gt;in.len = tcp_conn-&gt;in.copy;
+	BUG_ON(tcp_conn-&gt;in.copy &lt;= 0);
+	debug_tcp(&quot;in %d bytes\n&quot;, tcp_conn-&gt;in.copy);
+
+more:
+	tcp_conn-&gt;in.copied = 0;
+	rc = 0;
+
+	if (unlikely(conn-&gt;suspend_rx)) {
+		debug_tcp(&quot;conn %d Rx suspended!\n&quot;, conn-&gt;id);
+		return 0;
+	}
+
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER ||
+	    tcp_conn-&gt;in_progress == IN_PROGRESS_HEADER_GATHER) {
+		rc = iscsi_hdr_extract(tcp_conn);
+		if (rc) {
+		       if (rc == -EAGAIN)
+				goto nomore;
+		       else {
+				iscsi_conn_failure(conn, rc);
+				return 0;
+		       }
+		}
+
+		/*
+		 * Verify and process incoming PDU header.
+		 */
+		rc = iscsi_tcp_hdr_recv(conn);
+		if (!rc &amp;&amp; tcp_conn-&gt;in.datalen) {
+			if (conn-&gt;datadgst_en) {
+				BUG_ON(!tcp_conn-&gt;data_rx_tfm);
+				crypto_digest_init(tcp_conn-&gt;data_rx_tfm);
+			}
+			tcp_conn-&gt;in_progress = IN_PROGRESS_DATA_RECV;
+		} else if (rc) {
+			iscsi_conn_failure(conn, rc);
+			return 0;
+		}
+	}
+
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_DDIGEST_RECV) {
+		uint32_t recv_digest;
+
+		debug_tcp(&quot;extra data_recv offset %d copy %d\n&quot;,
+			  tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
+		skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
+				&amp;recv_digest, 4);
+		tcp_conn-&gt;in.offset += 4;
+		tcp_conn-&gt;in.copy -= 4;
+		if (recv_digest != tcp_conn-&gt;in.datadgst) {
+			debug_tcp(&quot;iscsi_tcp: data digest error!&quot;
+				  &quot;0x%x != 0x%x\n&quot;, recv_digest,
+				  tcp_conn-&gt;in.datadgst);
+			iscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);
+			return 0;
+		} else {
+			debug_tcp(&quot;iscsi_tcp: data digest match!&quot;
+				  &quot;0x%x == 0x%x\n&quot;, recv_digest,
+				  tcp_conn-&gt;in.datadgst);
+			tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+		}
+	}
+
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_DATA_RECV &amp;&amp;
+	   tcp_conn-&gt;in.copy) {
+
+		debug_tcp(&quot;data_recv offset %d copy %d\n&quot;,
+		       tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
+
+		rc = iscsi_data_recv(conn);
+		if (rc) {
+			if (rc == -EAGAIN) {
+				rd_desc-&gt;count = tcp_conn-&gt;in.datalen -
+						tcp_conn-&gt;in.ctask-&gt;data_count;
+				goto again;
+			}
+			iscsi_conn_failure(conn, rc);
+			return 0;
+		}
+		tcp_conn-&gt;in.copy -= tcp_conn-&gt;in.padding;
+		tcp_conn-&gt;in.offset += tcp_conn-&gt;in.padding;
+		if (conn-&gt;datadgst_en) {
+			if (tcp_conn-&gt;in.padding) {
+				debug_tcp(&quot;padding -&gt; %d\n&quot;,
+					  tcp_conn-&gt;in.padding);
+				memset(pad, 0, tcp_conn-&gt;in.padding);
+				sg_init_one(&amp;sg, pad, tcp_conn-&gt;in.padding);
+				crypto_digest_update(tcp_conn-&gt;data_rx_tfm,
+						     &amp;sg, 1);
+			}
+			crypto_digest_final(tcp_conn-&gt;data_rx_tfm,
+					    (u8 *) &amp; tcp_conn-&gt;in.datadgst);
+			debug_tcp(&quot;rx digest 0x%x\n&quot;, tcp_conn-&gt;in.datadgst);
+			tcp_conn-&gt;in_progress = IN_PROGRESS_DDIGEST_RECV;
+		} else
+			tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+	}
+
+	debug_tcp(&quot;f, processed %d from out of %d padding %d\n&quot;,
+	       tcp_conn-&gt;in.offset - offset, (int)len, tcp_conn-&gt;in.padding);
+	BUG_ON(tcp_conn-&gt;in.offset - offset &gt; len);
+
+	if (tcp_conn-&gt;in.offset - offset != len) {
+		debug_tcp(&quot;continue to process %d bytes\n&quot;,
+		       (int)len - (tcp_conn-&gt;in.offset - offset));
+		goto more;
+	}
+
+nomore:
+	processed = tcp_conn-&gt;in.offset - offset;
+	BUG_ON(processed == 0);
+	return processed;
+
+again:
+	processed = tcp_conn-&gt;in.offset - offset;
+	debug_tcp(&quot;c, processed %d from out of %d rd_desc_cnt %d\n&quot;,
+	          processed, (int)len, (int)rd_desc-&gt;count);
+	BUG_ON(processed == 0);
+	BUG_ON(processed &gt; len);
+
+	conn-&gt;rxdata_octets += processed;
+	return processed;
+}
+
+static void
+iscsi_tcp_data_ready(struct sock *sk, int flag)
+{
+	struct iscsi_conn *conn = sk-&gt;sk_user_data;
+	read_descriptor_t rd_desc;
+
+	read_lock(&amp;sk-&gt;sk_callback_lock);
+
+	/* use rd_desc to pass 'conn' to iscsi_tcp_data_recv */
+	rd_desc.arg.data = conn;
+	rd_desc.count = 0;
+	tcp_read_sock(sk, &amp;rd_desc, iscsi_tcp_data_recv);
+
+	read_unlock(&amp;sk-&gt;sk_callback_lock);
+}
+
+static void
+iscsi_tcp_state_change(struct sock *sk)
+{
+	struct iscsi_tcp_conn *tcp_conn;
+	struct iscsi_conn *conn;
+	struct iscsi_session *session;
+	void (*old_state_change)(struct sock *);
+
+	read_lock(&amp;sk-&gt;sk_callback_lock);
+
+	conn = (struct iscsi_conn*)sk-&gt;sk_user_data;
+	session = conn-&gt;session;
+
+	if ((sk-&gt;sk_state == TCP_CLOSE_WAIT ||
+	     sk-&gt;sk_state == TCP_CLOSE) &amp;&amp;
+	    !atomic_read(&amp;sk-&gt;sk_rmem_alloc)) {
+		debug_tcp(&quot;iscsi_tcp_state_change: TCP_CLOSE|TCP_CLOSE_WAIT\n&quot;);
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	}
+
+	tcp_conn = conn-&gt;dd_data;
+	old_state_change = tcp_conn-&gt;old_state_change;
+
+	read_unlock(&amp;sk-&gt;sk_callback_lock);
+
+	old_state_change(sk);
+}
+
+/**
+ * iscsi_write_space - Called when more output buffer space is available
+ * @sk: socket space is available for
+ **/
+static void
+iscsi_write_space(struct sock *sk)
+{
+	struct iscsi_conn *conn = (struct iscsi_conn*)sk-&gt;sk_user_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	tcp_conn-&gt;old_write_space(sk);
+	debug_tcp(&quot;iscsi_write_space: cid %d\n&quot;, conn-&gt;id);
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
+}
+
+static void
+iscsi_conn_set_callbacks(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk = tcp_conn-&gt;sock-&gt;sk;
+
+	/* assign new callbacks */
+	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
+	sk-&gt;sk_user_data = conn;
+	tcp_conn-&gt;old_data_ready = sk-&gt;sk_data_ready;
+	tcp_conn-&gt;old_state_change = sk-&gt;sk_state_change;
+	tcp_conn-&gt;old_write_space = sk-&gt;sk_write_space;
+	sk-&gt;sk_data_ready = iscsi_tcp_data_ready;
+	sk-&gt;sk_state_change = iscsi_tcp_state_change;
+	sk-&gt;sk_write_space = iscsi_write_space;
+	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
+}
+
+static void
+iscsi_conn_restore_callbacks(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk = tcp_conn-&gt;sock-&gt;sk;
+
+	/* restore socket callbacks, see also: iscsi_conn_set_callbacks() */
+	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
+	sk-&gt;sk_user_data    = NULL;
+	sk-&gt;sk_data_ready   = tcp_conn-&gt;old_data_ready;
+	sk-&gt;sk_state_change = tcp_conn-&gt;old_state_change;
+	sk-&gt;sk_write_space  = tcp_conn-&gt;old_write_space;
+	sk-&gt;sk_no_check	 = 0;
+	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
+}
+
+/**
+ * iscsi_send - generic send routine
+ * @sk: kernel's socket
+ * @buf: buffer to write from
+ * @size: actual size to write
+ * @flags: socket's flags
+ */
+static inline int
+iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct socket *sk = tcp_conn-&gt;sock;
+	int offset = buf-&gt;sg.offset + buf-&gt;sent;
+
+	/*
+	 * if we got use_sg=0 or are sending something we kmallocd
+	 * then we did not have to do kmap (kmap returns page_address)
+	 *
+	 * if we got use_sg &gt; 0, but had to drop down, we do not
+	 * set clustering so this should only happen for that
+	 * slab case.
+	 */
+	if (buf-&gt;use_sendmsg)
+		return sock_no_sendpage(sk, buf-&gt;sg.page, offset, size, flags);
+	else
+		return tcp_conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size,
+					  flags);
+}
+
+/**
+ * iscsi_sendhdr - send PDU Header via tcp_sendpage()
+ * @conn: iscsi connection
+ * @buf: buffer to write from
+ * @datalen: lenght of data to be sent after the header
+ *
+ * Notes:
+ *	(Tx, Fast Path)
+ **/
+static inline int
+iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
+{
+	struct iscsi_tcp_conn *tcp_conn;
+	int flags = 0; /* MSG_DONTWAIT; */
+	int res, size;
+
+	size = buf-&gt;sg.length - buf-&gt;sent;
+	BUG_ON(buf-&gt;sent + size &gt; buf-&gt;sg.length);
+	if (buf-&gt;sent + size != buf-&gt;sg.length || datalen)
+		flags |= MSG_MORE;
+
+	res = iscsi_send(conn, buf, size, flags);
+	debug_tcp(&quot;sendhdr %d bytes, sent %d res %d\n&quot;, size, buf-&gt;sent, res);
+	if (res &gt;= 0) {
+		conn-&gt;txdata_octets += res;
+		buf-&gt;sent += res;
+		if (size != res)
+			return -EAGAIN;
+		return 0;
+	} else if (res == -EAGAIN) {
+		tcp_conn = conn-&gt;dd_data;
+		tcp_conn-&gt;sendpage_failures_cnt++;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	} else if (res == -EPIPE)
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+
+	return res;
+}
+
+/**
+ * iscsi_sendpage - send one page of iSCSI Data-Out.
+ * @conn: iscsi connection
+ * @buf: buffer to write from
+ * @count: remaining data
+ * @sent: number of bytes sent
+ *
+ * Notes:
+ *	(Tx, Fast Path)
+ **/
+static inline int
+iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
+	       int *count, int *sent)
+{
+	struct iscsi_tcp_conn *tcp_conn;
+	int flags = 0; /* MSG_DONTWAIT; */
+	int res, size;
+
+	size = buf-&gt;sg.length - buf-&gt;sent;
+	BUG_ON(buf-&gt;sent + size &gt; buf-&gt;sg.length);
+	if (size &gt; *count)
+		size = *count;
+	if (buf-&gt;sent + size != buf-&gt;sg.length || *count != size)
+		flags |= MSG_MORE;
+
+	res = iscsi_send(conn, buf, size, flags);
+	debug_tcp(&quot;sendpage: %d bytes, sent %d left %d sent %d res %d\n&quot;,
+		  size, buf-&gt;sent, *count, *sent, res);
+	if (res &gt;= 0) {
+		conn-&gt;txdata_octets += res;
+		buf-&gt;sent += res;
+		*count -= res;
+		*sent += res;
+		if (size != res)
+			return -EAGAIN;
+		return 0;
+	} else if (res == -EAGAIN) {
+		tcp_conn = conn-&gt;dd_data;
+		tcp_conn-&gt;sendpage_failures_cnt++;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	} else if (res == -EPIPE)
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+
+	return res;
+}
+
+static inline void
+iscsi_data_digest_init(struct iscsi_tcp_conn *tcp_conn,
+		      struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	BUG_ON(!tcp_conn-&gt;data_tx_tfm);
+	crypto_digest_init(tcp_conn-&gt;data_tx_tfm);
+	tcp_ctask-&gt;digest_count = 4;
+}
+
+static int
+iscsi_digest_final_send(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			struct iscsi_buf *buf, uint32_t *digest, int final)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int rc = 0;
+	int sent = 0;
+
+	if (final)
+		crypto_digest_final(tcp_conn-&gt;data_tx_tfm, (u8*)digest);
+
+	iscsi_buf_init_virt(buf, (char*)digest, 4);
+	rc = iscsi_sendpage(conn, buf, &amp;tcp_ctask-&gt;digest_count, &amp;sent);
+	if (rc) {
+		tcp_ctask-&gt;datadigest = *digest;
+		tcp_ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
+	} else
+		tcp_ctask-&gt;digest_count = 4;
+	return rc;
+}
+
+/**
+ * iscsi_solicit_data_cont - initialize next Data-Out
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ * @r2t: R2T info
+ * @left: bytes left to transfer
+ *
+ * Notes:
+ *	Initialize next Data-Out within this R2T sequence and continue
+ *	to process next Scatter-Gather element(if any) of this SCSI command.
+ *
+ *	Called under connection lock.
+ **/
+static void
+iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			struct iscsi_r2t_info *r2t, int left)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data *hdr;
+	struct iscsi_data_task *dtask;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+	int new_offset;
+
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
+	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
+	hdr = &amp;dtask-&gt;hdr;
+	memset(hdr, 0, sizeof(struct iscsi_data));
+	hdr-&gt;ttt = r2t-&gt;ttt;
+	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
+	r2t-&gt;solicit_datasn++;
+	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
+	new_offset = r2t-&gt;data_offset + r2t-&gt;sent;
+	hdr-&gt;offset = cpu_to_be32(new_offset);
+	if (left &gt; conn-&gt;max_xmit_dlength) {
+		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
+		r2t-&gt;data_count = conn-&gt;max_xmit_dlength;
+	} else {
+		hton24(hdr-&gt;dlength, left);
+		r2t-&gt;data_count = left;
+		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	}
+	conn-&gt;dataout_pdus_cnt++;
+
+	iscsi_buf_init_virt(&amp;r2t-&gt;headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
+
+	r2t-&gt;dtask = dtask;
+
+	if (sc-&gt;use_sg &amp;&amp; !iscsi_buf_left(&amp;r2t-&gt;sendbuf)) {
+		BUG_ON(tcp_ctask-&gt;bad_sg == r2t-&gt;sg);
+		iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, r2t-&gt;sg);
+		r2t-&gt;sg += 1;
+	} else
+		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
+			    (char*)sc-&gt;request_buffer + new_offset,
+			    r2t-&gt;data_count);
+
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
+}
+
+static void
+iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_task *dtask;
+
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
+	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
+
+	iscsi_prep_unsolicit_data_pdu(ctask, &amp;dtask-&gt;hdr,
+				      tcp_ctask-&gt;r2t_data_count);
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)&amp;dtask-&gt;hdr,
+			   sizeof(struct iscsi_hdr));
+
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
+	tcp_ctask-&gt;dtask = dtask;
+}
+
+/**
+ * iscsi_tcp_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ * @sc: scsi command
+ **/
+static void
+iscsi_tcp_cmd_init(struct iscsi_cmd_task *ctask)
+{
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	BUG_ON(__kfifo_len(tcp_ctask-&gt;r2tqueue));
+
+	tcp_ctask-&gt;sent = 0;
+	tcp_ctask-&gt;sg_count = 0;
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		tcp_ctask-&gt;xmstate = XMSTATE_W_HDR;
+		tcp_ctask-&gt;exp_r2tsn = 0;
+		BUG_ON(ctask-&gt;total_length == 0);
+
+		if (sc-&gt;use_sg) {
+			struct scatterlist *sg = sc-&gt;request_buffer;
+
+			iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+					  &amp;sg[tcp_ctask-&gt;sg_count++]);
+			tcp_ctask-&gt;sg = sg;
+			tcp_ctask-&gt;bad_sg = sg + sc-&gt;use_sg;
+		} else
+			iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
+					   sc-&gt;request_buffer,
+					   sc-&gt;request_bufflen);
+
+		if (ctask-&gt;imm_count)
+			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
+
+		tcp_ctask-&gt;pad_count = ctask-&gt;total_length &amp; (ISCSI_PAD_LEN-1);
+		if (tcp_ctask-&gt;pad_count) {
+			tcp_ctask-&gt;pad_count = ISCSI_PAD_LEN -
+							tcp_ctask-&gt;pad_count;
+			debug_scsi(&quot;write padding %d bytes\n&quot;,
+				   tcp_ctask-&gt;pad_count);
+			tcp_ctask-&gt;xmstate |= XMSTATE_W_PAD;
+		}
+
+		if (ctask-&gt;unsol_count)
+			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_HDR |
+						XMSTATE_UNS_INIT;
+		tcp_ctask-&gt;r2t_data_count = ctask-&gt;total_length -
+				    ctask-&gt;imm_count -
+				    ctask-&gt;unsol_count;
+
+		debug_scsi(&quot;cmd [itt %x total %d imm %d imm_data %d &quot;
+			   &quot;r2t_data %d]\n&quot;,
+			   ctask-&gt;itt, ctask-&gt;total_length, ctask-&gt;imm_count,
+			   ctask-&gt;unsol_count, tcp_ctask-&gt;r2t_data_count);
+	} else
+		tcp_ctask-&gt;xmstate = XMSTATE_R_HDR;
+
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)ctask-&gt;hdr,
+			    sizeof(struct iscsi_hdr));
+}
+
+/**
+ * iscsi_tcp_mtask_xmit - xmit management(immediate) task
+ * @conn: iscsi connection
+ * @mtask: task management task
+ *
+ * Notes:
+ *	The function can return -EAGAIN in which case caller must
+ *	call it again later, or recover. '0' return code means successful
+ *	xmit.
+ *
+ *	Management xmit state machine consists of two states:
+ *		IN_PROGRESS_IMM_HEAD - PDU Header xmit in progress
+ *		IN_PROGRESS_IMM_DATA - PDU Data xmit in progress
+ **/
+static int
+iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
+{
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
+
+	debug_scsi(&quot;mtask deq [cid %d state %x itt 0x%x]\n&quot;,
+		conn-&gt;id, tcp_mtask-&gt;xmstate, mtask-&gt;itt);
+
+	if (tcp_mtask-&gt;xmstate &amp; XMSTATE_IMM_HDR) {
+		tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_HDR;
+		if (mtask-&gt;data_count)
+			tcp_mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
+		if (conn-&gt;c_stage != ISCSI_CONN_INITIAL_STAGE &amp;&amp;
+		    conn-&gt;stop_stage != STOP_CONN_RECOVER &amp;&amp;
+		    conn-&gt;hdrdgst_en)
+			iscsi_hdr_digest(conn, &amp;tcp_mtask-&gt;headbuf,
+					(u8*)tcp_mtask-&gt;hdrext);
+		if (iscsi_sendhdr(conn, &amp;tcp_mtask-&gt;headbuf,
+				  mtask-&gt;data_count)) {
+			tcp_mtask-&gt;xmstate |= XMSTATE_IMM_HDR;
+			if (mtask-&gt;data_count)
+				tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+			return -EAGAIN;
+		}
+	}
+
+	if (tcp_mtask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
+		BUG_ON(!mtask-&gt;data_count);
+		tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+		/* FIXME: implement.
+		 * Virtual buffer could be spreaded across multiple pages...
+		 */
+		do {
+			if (iscsi_sendpage(conn, &amp;tcp_mtask-&gt;sendbuf,
+				   &amp;mtask-&gt;data_count, &amp;tcp_mtask-&gt;sent)) {
+				tcp_mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
+				return -EAGAIN;
+			}
+		} while (mtask-&gt;data_count);
+	}
+
+	BUG_ON(tcp_mtask-&gt;xmstate != XMSTATE_IDLE);
+	if (mtask-&gt;hdr-&gt;itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		struct iscsi_session *session = conn-&gt;session;
+
+		spin_lock_bh(&amp;session-&gt;lock);
+		list_del(&amp;conn-&gt;mtask-&gt;running);
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
+			    sizeof(void*));
+		spin_unlock_bh(&amp;session-&gt;lock);
+	}
+	return 0;
+}
+
+static inline int
+handle_xmstate_r_hdr(struct iscsi_conn *conn,
+		     struct iscsi_tcp_cmd_task *tcp_ctask)
+{
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_R_HDR;
+	if (conn-&gt;hdrdgst_en)
+		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
+				 (u8*)tcp_ctask-&gt;hdrext);
+	if (!iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, 0)) {
+		BUG_ON(tcp_ctask-&gt;xmstate != XMSTATE_IDLE);
+		return 0; /* wait for Data-In */
+	}
+	tcp_ctask-&gt;xmstate |= XMSTATE_R_HDR;
+	return -EAGAIN;
+}
+
+static inline int
+handle_xmstate_w_hdr(struct iscsi_conn *conn,
+		     struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_HDR;
+	if (conn-&gt;hdrdgst_en)
+		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
+				 (u8*)tcp_ctask-&gt;hdrext);
+	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;imm_count)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_W_HDR;
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static inline int
+handle_xmstate_data_digest(struct iscsi_conn *conn,
+			   struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_DATA_DIGEST;
+	debug_tcp(&quot;resent data digest 0x%x\n&quot;, tcp_ctask-&gt;datadigest);
+	if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				    &amp;tcp_ctask-&gt;datadigest, 0)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
+		debug_tcp(&quot;resent data digest 0x%x fail!\n&quot;,
+			  tcp_ctask-&gt;datadigest);
+		return -EAGAIN;
+	}
+	return 0;
+}
+
+static inline int
+handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	BUG_ON(!ctask-&gt;imm_count);
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+
+	if (conn-&gt;datadgst_en) {
+		iscsi_data_digest_init(tcp_conn, ctask);
+		tcp_ctask-&gt;immdigest = 0;
+	}
+
+	for (;;) {
+		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;ctask-&gt;imm_count,
+				   &amp;tcp_ctask-&gt;sent)) {
+			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
+			if (conn-&gt;datadgst_en) {
+				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
+						(u8*)&amp;tcp_ctask-&gt;immdigest);
+				debug_tcp(&quot;tx imm sendpage fail 0x%x\n&quot;,
+					  tcp_ctask-&gt;datadigest);
+			}
+			return -EAGAIN;
+		}
+		if (conn-&gt;datadgst_en)
+			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+
+		if (!ctask-&gt;imm_count)
+			break;
+		iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+				  &amp;tcp_ctask-&gt;sg[tcp_ctask-&gt;sg_count++]);
+	}
+
+	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
+		if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				            &amp;tcp_ctask-&gt;immdigest, 1)) {
+			debug_tcp(&quot;sending imm digest 0x%x fail!\n&quot;,
+				  tcp_ctask-&gt;immdigest);
+			return -EAGAIN;
+		}
+		debug_tcp(&quot;sending imm digest 0x%x\n&quot;, tcp_ctask-&gt;immdigest);
+	}
+
+	return 0;
+}
+
+static inline int
+handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_task *dtask;
+
+	tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_INIT) {
+		iscsi_unsolicit_data_init(conn, ctask);
+		BUG_ON(!tcp_ctask-&gt;dtask);
+		dtask = tcp_ctask-&gt;dtask;
+		if (conn-&gt;hdrdgst_en)
+			iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
+					(u8*)dtask-&gt;hdrext);
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_INIT;
+	}
+	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;data_count)) {
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
+		tcp_ctask-&gt;xmstate |= XMSTATE_UNS_HDR;
+		return -EAGAIN;
+	}
+
+	debug_scsi(&quot;uns dout [itt 0x%x dlen %d sent %d]\n&quot;,
+		   ctask-&gt;itt, ctask-&gt;unsol_count, tcp_ctask-&gt;sent);
+	return 0;
+}
+
+static inline int
+handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	BUG_ON(!ctask-&gt;data_count);
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
+
+	if (conn-&gt;datadgst_en) {
+		iscsi_data_digest_init(tcp_conn, ctask);
+		dtask-&gt;digest = 0;
+	}
+
+	for (;;) {
+		int start = tcp_ctask-&gt;sent;
+
+		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf,
+				   &amp;ctask-&gt;data_count, &amp;tcp_ctask-&gt;sent)) {
+			ctask-&gt;unsol_count -= tcp_ctask-&gt;sent - start;
+			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
+			/* will continue with this ctask later.. */
+			if (conn-&gt;datadgst_en) {
+				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
+						(u8 *)&amp;dtask-&gt;digest);
+				debug_tcp(&quot;tx uns data fail 0x%x\n&quot;,
+					  dtask-&gt;digest);
+			}
+			return -EAGAIN;
+		}
+
+		BUG_ON(tcp_ctask-&gt;sent &gt; ctask-&gt;total_length);
+		ctask-&gt;unsol_count -= tcp_ctask-&gt;sent - start;
+
+		/*
+		 * XXX:we may run here with un-initial sendbuf.
+		 * so pass it
+		 */
+		if (conn-&gt;datadgst_en &amp;&amp; tcp_ctask-&gt;sent - start &gt; 0)
+			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+
+		if (!ctask-&gt;data_count)
+			break;
+		iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+				  &amp;tcp_ctask-&gt;sg[tcp_ctask-&gt;sg_count++]);
+	}
+	BUG_ON(ctask-&gt;unsol_count &lt; 0);
+
+	/*
+	 * Done with the Data-Out. Next, check if we need
+	 * to send another unsolicited Data-Out.
+	 */
+	if (ctask-&gt;unsol_count) {
+		if (conn-&gt;datadgst_en) {
+			if (iscsi_digest_final_send(conn, ctask,
+						    &amp;dtask-&gt;digestbuf,
+						    &amp;dtask-&gt;digest, 1)) {
+				debug_tcp(&quot;send uns digest 0x%x fail\n&quot;,
+					  dtask-&gt;digest);
+				return -EAGAIN;
+			}
+			debug_tcp(&quot;sending uns digest 0x%x, more uns\n&quot;,
+				  dtask-&gt;digest);
+		}
+		tcp_ctask-&gt;xmstate |= XMSTATE_UNS_INIT;
+		return 1;
+	}
+
+	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
+		if (iscsi_digest_final_send(conn, ctask,
+					    &amp;dtask-&gt;digestbuf,
+					    &amp;dtask-&gt;digest, 1)) {
+			debug_tcp(&quot;send last uns digest 0x%x fail\n&quot;,
+				   dtask-&gt;digest);
+			return -EAGAIN;
+		}
+		debug_tcp(&quot;sending uns digest 0x%x\n&quot;,dtask-&gt;digest);
+	}
+
+	return 0;
+}
+
+static inline int
+handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_r2t_info *r2t = tcp_ctask-&gt;r2t;
+	struct iscsi_data_task *dtask = r2t-&gt;dtask;
+	int left;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
+	tcp_ctask-&gt;dtask = dtask;
+
+	if (conn-&gt;datadgst_en) {
+		iscsi_data_digest_init(tcp_conn, ctask);
+		dtask-&gt;digest = 0;
+	}
+solicit_again:
+	/*
+	 * send Data-Out whitnin this R2T sequence.
+	 */
+	if (!r2t-&gt;data_count)
+		goto data_out_done;
+
+	if (iscsi_sendpage(conn, &amp;r2t-&gt;sendbuf, &amp;r2t-&gt;data_count, &amp;r2t-&gt;sent)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		/* will continue with this ctask later.. */
+		if (conn-&gt;datadgst_en) {
+			crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
+					  (u8 *)&amp;dtask-&gt;digest);
+			debug_tcp(&quot;r2t data send fail 0x%x\n&quot;, dtask-&gt;digest);
+		}
+		return -EAGAIN;
+	}
+
+	BUG_ON(r2t-&gt;data_count &lt; 0);
+	if (conn-&gt;datadgst_en)
+		crypto_digest_update(tcp_conn-&gt;data_tx_tfm, &amp;r2t-&gt;sendbuf.sg,
+				     1);
+
+	if (r2t-&gt;data_count) {
+		BUG_ON(ctask-&gt;sc-&gt;use_sg == 0);
+		if (!iscsi_buf_left(&amp;r2t-&gt;sendbuf)) {
+			BUG_ON(tcp_ctask-&gt;bad_sg == r2t-&gt;sg);
+			iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, r2t-&gt;sg);
+			r2t-&gt;sg += 1;
+		}
+		goto solicit_again;
+	}
+
+data_out_done:
+	/*
+	 * Done with this Data-Out. Next, check if we have
+	 * to send another Data-Out for this R2T.
+	 */
+	BUG_ON(r2t-&gt;data_length - r2t-&gt;sent &lt; 0);
+	left = r2t-&gt;data_length - r2t-&gt;sent;
+	if (left) {
+		if (conn-&gt;datadgst_en) {
+			if (iscsi_digest_final_send(conn, ctask,
+						    &amp;dtask-&gt;digestbuf,
+						    &amp;dtask-&gt;digest, 1)) {
+				debug_tcp(&quot;send r2t data digest 0x%x&quot;
+					  &quot;fail\n&quot;, dtask-&gt;digest);
+				return -EAGAIN;
+			}
+			debug_tcp(&quot;r2t data send digest 0x%x\n&quot;,
+				  dtask-&gt;digest);
+		}
+		iscsi_solicit_data_cont(conn, ctask, r2t, left);
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+		return 1;
+	}
+
+	/*
+	 * Done with this R2T. Check if there are more
+	 * outstanding R2Ts ready to be processed.
+	 */
+	BUG_ON(tcp_ctask-&gt;r2t_data_count - r2t-&gt;data_length &lt; 0);
+	if (conn-&gt;datadgst_en) {
+		if (iscsi_digest_final_send(conn, ctask, &amp;dtask-&gt;digestbuf,
+					    &amp;dtask-&gt;digest, 1)) {
+			debug_tcp(&quot;send last r2t data digest 0x%x&quot;
+				  &quot;fail\n&quot;, dtask-&gt;digest);
+			return -EAGAIN;
+		}
+		debug_tcp(&quot;r2t done dout digest 0x%x\n&quot;, dtask-&gt;digest);
+	}
+
+	tcp_ctask-&gt;r2t_data_count -= r2t-&gt;data_length;
+	tcp_ctask-&gt;r2t = NULL;
+	spin_lock_bh(&amp;session-&gt;lock);
+	__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+	spin_unlock_bh(&amp;session-&gt;lock);
+	if (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
+		tcp_ctask-&gt;r2t = r2t;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+		return 1;
+	}
+
+	return 0;
+}
+
+static inline int
+handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
+	int sent;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_PAD;
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;sendbuf, (char*)&amp;tcp_ctask-&gt;pad,
+			    tcp_ctask-&gt;pad_count);
+	if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;tcp_ctask-&gt;pad_count,
+			   &amp;sent)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_W_PAD;
+		return -EAGAIN;
+	}
+
+	if (conn-&gt;datadgst_en) {
+		crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+				     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
+		/* imm data? */
+		if (!dtask) {
+			if (iscsi_digest_final_send(conn, ctask,
+						    &amp;tcp_ctask-&gt;immbuf,
+						    &amp;tcp_ctask-&gt;immdigest, 1)) {
+				debug_tcp(&quot;send padding digest 0x%x&quot;
+					  &quot;fail!\n&quot;, tcp_ctask-&gt;immdigest);
+				return -EAGAIN;
+			}
+			debug_tcp(&quot;done with padding, digest 0x%x\n&quot;,
+				  tcp_ctask-&gt;datadigest);
+		} else {
+			if (iscsi_digest_final_send(conn, ctask,
+						    &amp;dtask-&gt;digestbuf,
+						    &amp;dtask-&gt;digest, 1)) {
+				debug_tcp(&quot;send padding digest 0x%x&quot;
+				          &quot;fail\n&quot;, dtask-&gt;digest);
+				return -EAGAIN;
+			}
+			debug_tcp(&quot;done with padding, digest 0x%x\n&quot;,
+				  dtask-&gt;digest);
+		}
+	}
+
+	return 0;
+}
+
+static int
+iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	int rc = 0;
+
+	debug_scsi(&quot;ctask deq [cid %d xmstate %x itt 0x%x]\n&quot;,
+		conn-&gt;id, tcp_ctask-&gt;xmstate, ctask-&gt;itt);
+
+	/*
+	 * serialize with TMF AbortTask
+	 */
+	if (ctask-&gt;mtask)
+		return rc;
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_R_HDR) {
+		rc = handle_xmstate_r_hdr(conn, tcp_ctask);
+		return rc;
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_W_HDR) {
+		rc = handle_xmstate_w_hdr(conn, ctask);
+		if (rc)
+			return rc;
+	}
+
+	/* XXX: for data digest xmit recover */
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_DATA_DIGEST) {
+		rc = handle_xmstate_data_digest(conn, ctask);
+		if (rc)
+			return rc;
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
+		rc = handle_xmstate_imm_data(conn, ctask);
+		if (rc)
+			return rc;
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_HDR) {
+		BUG_ON(!ctask-&gt;unsol_count);
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_HDR;
+unsolicit_head_again:
+		rc = handle_xmstate_uns_hdr(conn, ctask);
+		if (rc)
+			return rc;
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_DATA) {
+		rc = handle_xmstate_uns_data(conn, ctask);
+		if (rc == 1)
+			goto unsolicit_head_again;
+		else if (rc)
+			return rc;
+		goto done;
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_SOL_HDR) {
+		struct iscsi_r2t_info *r2t;
+
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		if (!tcp_ctask-&gt;r2t)
+			__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;tcp_ctask-&gt;r2t,
+				    sizeof(void*));
+solicit_head_again:
+		r2t = tcp_ctask-&gt;r2t;
+		if (conn-&gt;hdrdgst_en)
+			iscsi_hdr_digest(conn, &amp;r2t-&gt;headbuf,
+					(u8*)r2t-&gt;dtask-&gt;hdrext);
+		if (iscsi_sendhdr(conn, &amp;r2t-&gt;headbuf, r2t-&gt;data_count)) {
+			tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
+			tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
+			return -EAGAIN;
+		}
+
+		debug_scsi(&quot;sol dout [dsn %d itt 0x%x dlen %d sent %d]\n&quot;,
+			r2t-&gt;solicit_datasn - 1, ctask-&gt;itt, r2t-&gt;data_count,
+			r2t-&gt;sent);
+	}
+
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_SOL_DATA) {
+		rc = handle_xmstate_sol_data(conn, ctask);
+		if (rc == 1)
+			goto solicit_head_again;
+		if (rc)
+			return rc;
+	}
+
+done:
+	/*
+	 * Last thing to check is whether we need to send write
+	 * padding. Note that we check for xmstate equality, not just the bit.
+	 */
+	if (tcp_ctask-&gt;xmstate == XMSTATE_W_PAD)
+		rc = handle_xmstate_w_pad(conn, ctask);
+
+	return rc;
+}
+
+static struct iscsi_cls_conn *
+iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
+{
+	struct iscsi_conn *conn;
+	struct iscsi_cls_conn *cls_conn;
+	struct iscsi_tcp_conn *tcp_conn;
+
+	cls_conn = iscsi_conn_setup(cls_session, conn_idx);
+	if (!cls_conn)
+		return NULL;
+	conn = cls_conn-&gt;dd_data;
+	/*
+	 * due to strange issues with iser these are not set
+	 * in iscsi_conn_setup
+	 */
+	conn-&gt;max_recv_dlength = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
+
+	tcp_conn = kzalloc(sizeof(*tcp_conn), GFP_KERNEL);
+	if (!tcp_conn)
+		goto tcp_conn_alloc_fail;
+
+	conn-&gt;dd_data = tcp_conn;
+	tcp_conn-&gt;iscsi_conn = conn;
+	tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+	/* initial operational parameters */
+	tcp_conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
+	tcp_conn-&gt;data_size = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
+
+	/* allocate initial PDU receive place holder */
+	if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
+		tcp_conn-&gt;data = kmalloc(tcp_conn-&gt;data_size, GFP_KERNEL);
+	else
+		tcp_conn-&gt;data = (void*)__get_free_pages(GFP_KERNEL,
+					get_order(tcp_conn-&gt;data_size));
+	if (!tcp_conn-&gt;data)
+		goto max_recv_dlenght_alloc_fail;
+
+	return cls_conn;
+
+max_recv_dlenght_alloc_fail:
+	kfree(tcp_conn);
+tcp_conn_alloc_fail:
+	iscsi_conn_teardown(cls_conn);
+	return NULL;
+}
+
+static void
+iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int digest = 0;
+
+	if (conn-&gt;hdrdgst_en || conn-&gt;datadgst_en)
+		digest = 1;
+
+	iscsi_conn_teardown(cls_conn);
+
+	/* now free tcp_conn */
+	if (digest) {
+		if (tcp_conn-&gt;tx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+		if (tcp_conn-&gt;rx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;rx_tfm);
+		if (tcp_conn-&gt;data_tx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
+		if (tcp_conn-&gt;data_rx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
+	}
+
+	/* free conn-&gt;data, size = MaxRecvDataSegmentLength */
+	if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
+		kfree(tcp_conn-&gt;data);
+	else
+		free_pages((unsigned long)tcp_conn-&gt;data,
+			   get_order(tcp_conn-&gt;data_size));
+	kfree(tcp_conn);
+}
+
+static int
+iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
+		    struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
+		    int is_leading)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk;
+	struct socket *sock;
+	int err;
+
+	/* lookup for existing socket */
+	sock = sockfd_lookup((int)transport_eph, &amp;err);
+	if (!sock) {
+		printk(KERN_ERR &quot;iscsi_tcp: sockfd_lookup failed %d\n&quot;, err);
+		return -EEXIST;
+	}
+
+	err = iscsi_conn_bind(cls_session, cls_conn, is_leading);
+	if (err)
+		return err;
+
+	if (conn-&gt;stop_stage != STOP_CONN_SUSPEND) {
+		/* bind iSCSI connection and socket */
+		tcp_conn-&gt;sock = sock;
+
+		/* setup Socket parameters */
+		sk = sock-&gt;sk;
+		sk-&gt;sk_reuse = 1;
+		sk-&gt;sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
+		sk-&gt;sk_allocation = GFP_ATOMIC;
+
+		/* FIXME: disable Nagle's algorithm */
+
+		/*
+		 * Intercept TCP callbacks for sendfile like receive
+		 * processing.
+		 */
+		conn-&gt;recv_lock = &amp;sk-&gt;sk_callback_lock;
+		iscsi_conn_set_callbacks(conn);
+		tcp_conn-&gt;sendpage = tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
+		/*
+		 * set receive state machine into initial state
+		 */
+		tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+	}
+
+	return 0;
+}
+
+static void
+iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_r2t_info *r2t;
+
+	/* flush ctask's r2t queues */
+	while (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*)))
+		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
+			    sizeof(void*));
+
+	__iscsi_ctask_cleanup(conn, ctask);
+}
+
+static void
+iscsi_tcp_suspend_conn_rx(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk;
+
+	if (!tcp_conn-&gt;sock)
+		return;
+
+	sk = tcp_conn-&gt;sock-&gt;sk;
+	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
+}
+
+static void
+iscsi_tcp_terminate_conn(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	if (!tcp_conn-&gt;sock)
+		return;
+
+	sock_hold(tcp_conn-&gt;sock-&gt;sk);
+	iscsi_conn_restore_callbacks(conn);
+	sock_put(tcp_conn-&gt;sock-&gt;sk);
+
+	sock_release(tcp_conn-&gt;sock);
+	tcp_conn-&gt;sock = NULL;
+	conn-&gt;recv_lock = NULL;
+}
+
+/* called with host lock */
+static void 
+iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
+		    char *data, uint32_t data_size)
+{
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
+
+	iscsi_buf_init_virt(&amp;tcp_mtask-&gt;headbuf, (char*)mtask-&gt;hdr,
+				    sizeof(struct iscsi_hdr));
+	tcp_mtask-&gt;xmstate = XMSTATE_IMM_HDR;
+
+	if (mtask-&gt;data_count)
+		iscsi_buf_init_iov(&amp;tcp_mtask-&gt;sendbuf, (char*)mtask-&gt;data,
+				    mtask-&gt;data_count);
+}
+
+static int
+iscsi_r2tpool_alloc(struct iscsi_session *session)
+{
+	int i;
+	int cmd_i;
+
+	/*
+	 * initialize per-task: R2T pool and xmit queue
+	 */
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+	        struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		/*
+		 * pre-allocated x4 as much r2ts to handle race when
+		 * target acks DataOut faster than we data_xmit() queues
+		 * could replenish r2tqueue.
+		 */
+
+		/* R2T pool */
+		if (iscsi_pool_init(&amp;tcp_ctask-&gt;r2tpool, session-&gt;max_r2t * 4,
+				    (void***)&amp;tcp_ctask-&gt;r2ts,
+				    sizeof(struct iscsi_r2t_info))) {
+			goto r2t_alloc_fail;
+		}
+
+		/* R2T xmit queue */
+		tcp_ctask-&gt;r2tqueue = kfifo_alloc(
+		      session-&gt;max_r2t * 4 * sizeof(void*), GFP_KERNEL, NULL);
+		if (tcp_ctask-&gt;r2tqueue == ERR_PTR(-ENOMEM)) {
+			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+					(void**)tcp_ctask-&gt;r2ts);
+			goto r2t_alloc_fail;
+		}
+
+		/*
+		 * number of
+		 * Data-Out PDU's within R2T-sequence can be quite big;
+		 * using mempool
+		 */
+		tcp_ctask-&gt;datapool = mempool_create(ISCSI_DTASK_DEFAULT_MAX,
+			 mempool_alloc_slab, mempool_free_slab, taskcache);
+		if (tcp_ctask-&gt;datapool == NULL) {
+			kfifo_free(tcp_ctask-&gt;r2tqueue);
+			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+					(void**)tcp_ctask-&gt;r2ts);
+			goto r2t_alloc_fail;
+		}
+		INIT_LIST_HEAD(&amp;tcp_ctask-&gt;dataqueue);
+	}
+
+	return 0;
+
+r2t_alloc_fail:
+	for (i = 0; i &lt; cmd_i; i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		mempool_destroy(tcp_ctask-&gt;datapool);
+		kfifo_free(tcp_ctask-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+				(void**)tcp_ctask-&gt;r2ts);
+	}
+	return -ENOMEM;
+}
+
+static void
+iscsi_r2tpool_free(struct iscsi_session *session)
+{
+	int i;
+
+	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		mempool_destroy(tcp_ctask-&gt;datapool);
+		kfifo_free(tcp_ctask-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+				(void**)tcp_ctask-&gt;r2ts);
+	}
+}
+
+static int
+iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
+		     uint32_t value)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	switch(param) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH: {
+		char *saveptr = tcp_conn-&gt;data;
+		gfp_t flags = GFP_KERNEL;
+
+		if (tcp_conn-&gt;data_size &gt;= value) {
+			conn-&gt;max_recv_dlength = value;
+			break;
+		}
+
+		spin_lock_bh(&amp;session-&gt;lock);
+		if (conn-&gt;stop_stage == STOP_CONN_RECOVER)
+			flags = GFP_ATOMIC;
+		spin_unlock_bh(&amp;session-&gt;lock);
+
+		if (value &lt;= PAGE_SIZE)
+			tcp_conn-&gt;data = kmalloc(value, flags);
+		else
+			tcp_conn-&gt;data = (void*)__get_free_pages(flags,
+							     get_order(value));
+		if (tcp_conn-&gt;data == NULL) {
+			tcp_conn-&gt;data = saveptr;
+			return -ENOMEM;
+		}
+		if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
+			kfree(saveptr);
+		else
+			free_pages((unsigned long)saveptr,
+				   get_order(tcp_conn-&gt;data_size));
+		conn-&gt;max_recv_dlength = value;
+		tcp_conn-&gt;data_size = value;
+		}
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		conn-&gt;max_xmit_dlength =  value;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		conn-&gt;hdrdgst_en = value;
+		tcp_conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
+		if (conn-&gt;hdrdgst_en) {
+			tcp_conn-&gt;hdr_size += sizeof(__u32);
+			if (!tcp_conn-&gt;tx_tfm)
+				tcp_conn-&gt;tx_tfm = crypto_alloc_tfm(&quot;crc32c&quot;,
+								    0);
+			if (!tcp_conn-&gt;tx_tfm)
+				return -ENOMEM;
+			if (!tcp_conn-&gt;rx_tfm)
+				tcp_conn-&gt;rx_tfm = crypto_alloc_tfm(&quot;crc32c&quot;,
+								    0);
+			if (!tcp_conn-&gt;rx_tfm) {
+				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+				return -ENOMEM;
+			}
+		} else {
+			if (tcp_conn-&gt;tx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+			if (tcp_conn-&gt;rx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;rx_tfm);
+		}
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		conn-&gt;datadgst_en = value;
+		if (conn-&gt;datadgst_en) {
+			if (!tcp_conn-&gt;data_tx_tfm)
+				tcp_conn-&gt;data_tx_tfm =
+				    crypto_alloc_tfm(&quot;crc32c&quot;, 0);
+			if (!tcp_conn-&gt;data_tx_tfm)
+				return -ENOMEM;
+			if (!tcp_conn-&gt;data_rx_tfm)
+				tcp_conn-&gt;data_rx_tfm =
+				    crypto_alloc_tfm(&quot;crc32c&quot;, 0);
+			if (!tcp_conn-&gt;data_rx_tfm) {
+				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
+				return -ENOMEM;
+			}
+		} else {
+			if (tcp_conn-&gt;data_tx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
+			if (tcp_conn-&gt;data_rx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
+		}
+		tcp_conn-&gt;sendpage = conn-&gt;datadgst_en ?
+			sock_no_sendpage : tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
+		break;
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		session-&gt;initial_r2t_en = value;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		if (session-&gt;max_r2t == roundup_pow_of_two(value))
+			break;
+		iscsi_r2tpool_free(session);
+		session-&gt;max_r2t = value;
+		if (session-&gt;max_r2t &amp; (session-&gt;max_r2t - 1))
+			session-&gt;max_r2t = roundup_pow_of_two(session-&gt;max_r2t);
+		if (iscsi_r2tpool_alloc(session))
+			return -ENOMEM;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		session-&gt;imm_data_en = value;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		session-&gt;first_burst = value;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		session-&gt;max_burst = value;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		session-&gt;pdu_inorder_en = value;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		session-&gt;dataseq_inorder_en = value;
+		break;
+	case ISCSI_PARAM_ERL:
+		session-&gt;erl = value;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		BUG_ON(value);
+		session-&gt;ifmarker_en = value;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		BUG_ON(value);
+		session-&gt;ofmarker_en = value;
+		break;
+	case ISCSI_PARAM_EXP_STATSN:
+		conn-&gt;exp_statsn = value;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int
+iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+			enum iscsi_param param, uint32_t *value)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+
+	switch(param) {
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		*value = session-&gt;initial_r2t_en;
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		*value = session-&gt;max_r2t;
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		*value = session-&gt;imm_data_en;
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		*value = session-&gt;first_burst;
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		*value = session-&gt;max_burst;
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		*value = session-&gt;pdu_inorder_en;
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		*value = session-&gt;dataseq_inorder_en;
+		break;
+	case ISCSI_PARAM_ERL:
+		*value = session-&gt;erl;
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		*value = session-&gt;ifmarker_en;
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		*value = session-&gt;ofmarker_en;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param param, uint32_t *value)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct inet_sock *inet;
+
+	switch(param) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		*value = conn-&gt;max_recv_dlength;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		*value = conn-&gt;max_xmit_dlength;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		*value = conn-&gt;hdrdgst_en;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		*value = conn-&gt;datadgst_en;
+		break;
+	case ISCSI_PARAM_CONN_PORT:
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		if (!tcp_conn-&gt;sock) {
+			mutex_unlock(&amp;conn-&gt;xmitmutex);
+			return -EINVAL;
+		}
+
+		inet = inet_sk(tcp_conn-&gt;sock-&gt;sk);
+		*value = be16_to_cpu(inet-&gt;dport); 
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+	case ISCSI_PARAM_EXP_STATSN:
+		*value = conn-&gt;exp_statsn;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int
+iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
+			 enum iscsi_param param, char *buf)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk;
+	struct inet_sock *inet;
+	struct ipv6_pinfo *np;
+	int len = 0;
+
+	switch (param) {
+	case ISCSI_PARAM_CONN_ADDRESS:
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		if (!tcp_conn-&gt;sock) {
+			mutex_unlock(&amp;conn-&gt;xmitmutex);
+			return -EINVAL;
+		}
+
+		sk = tcp_conn-&gt;sock-&gt;sk;
+		if (sk-&gt;sk_family == PF_INET) {
+			inet = inet_sk(sk);
+			len = sprintf(buf, &quot;%u.%u.%u.%u\n&quot;,
+				      NIPQUAD(inet-&gt;daddr));
+		} else {
+			np = inet6_sk(sk);
+			len = sprintf(buf,
+				&quot;%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n&quot;,
+				NIP6(np-&gt;daddr));
+		}
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static void
+iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	stats-&gt;txdata_octets = conn-&gt;txdata_octets;
+	stats-&gt;rxdata_octets = conn-&gt;rxdata_octets;
+	stats-&gt;scsicmd_pdus = conn-&gt;scsicmd_pdus_cnt;
+	stats-&gt;dataout_pdus = conn-&gt;dataout_pdus_cnt;
+	stats-&gt;scsirsp_pdus = conn-&gt;scsirsp_pdus_cnt;
+	stats-&gt;datain_pdus = conn-&gt;datain_pdus_cnt;
+	stats-&gt;r2t_pdus = conn-&gt;r2t_pdus_cnt;
+	stats-&gt;tmfcmd_pdus = conn-&gt;tmfcmd_pdus_cnt;
+	stats-&gt;tmfrsp_pdus = conn-&gt;tmfrsp_pdus_cnt;
+	stats-&gt;custom_length = 3;
+	strcpy(stats-&gt;custom[0].desc, &quot;tx_sendpage_failures&quot;);
+	stats-&gt;custom[0].value = tcp_conn-&gt;sendpage_failures_cnt;
+	strcpy(stats-&gt;custom[1].desc, &quot;rx_discontiguous_hdr&quot;);
+	stats-&gt;custom[1].value = tcp_conn-&gt;discontiguous_hdr_cnt;
+	strcpy(stats-&gt;custom[2].desc, &quot;eh_abort_cnt&quot;);
+	stats-&gt;custom[2].value = conn-&gt;eh_abort_cnt;
+}
+
+static struct iscsi_cls_session *
+iscsi_tcp_session_create(struct iscsi_transport *iscsit,
+			 struct scsi_transport_template *scsit,
+			 uint32_t initial_cmdsn, uint32_t *hostno)
+{
+	struct iscsi_cls_session *cls_session;
+	struct iscsi_session *session;
+	uint32_t hn;
+	int cmd_i;
+
+	cls_session = iscsi_session_setup(iscsit, scsit,
+					 sizeof(struct iscsi_tcp_cmd_task),
+					 sizeof(struct iscsi_tcp_mgmt_task),
+					 initial_cmdsn, &amp;hn);
+	if (!cls_session)
+		return NULL;
+	*hostno = hn;
+
+	session = class_to_transport_session(cls_session);
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		ctask-&gt;hdr = &amp;tcp_ctask-&gt;hdr;
+	}
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
+		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
+		struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
+
+		mtask-&gt;hdr = &amp;tcp_mtask-&gt;hdr;
+	}
+
+	if (iscsi_r2tpool_alloc(class_to_transport_session(cls_session)))
+		goto r2tpool_alloc_fail;
+
+	return cls_session;
+
+r2tpool_alloc_fail:
+	iscsi_session_teardown(cls_session);
+	return NULL;
+}
+
+static void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_data_task *dtask, *n;
+	int cmd_i;
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
+					 item) {
+			list_del(&amp;dtask-&gt;item);
+			mempool_free(dtask, tcp_ctask-&gt;datapool);
+		}
+	}
+
+	iscsi_r2tpool_free(class_to_transport_session(cls_session));
+	iscsi_session_teardown(cls_session);
+}
+
+static struct scsi_host_template iscsi_sht = {
+	.name			= &quot;iSCSI Initiator over TCP/IP, v.&quot;
+				  ISCSI_VERSION_STR,
+	.queuecommand           = iscsi_queuecommand,
+	.change_queue_depth	= iscsi_change_queue_depth,
+	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
+	.sg_tablesize		= ISCSI_SG_TABLESIZE,
+	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
+	.eh_abort_handler       = iscsi_eh_abort,
+	.eh_host_reset_handler	= iscsi_eh_host_reset,
+	.use_clustering         = DISABLE_CLUSTERING,
+	.proc_name		= &quot;iscsi_tcp&quot;,
+	.this_id		= -1,
+};
+
+static struct iscsi_transport iscsi_tcp_transport = {
+	.owner			= THIS_MODULE,
+	.name			= &quot;tcp&quot;,
+	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
+				  | CAP_DATADGST,
+	.param_mask		= ISCSI_MAX_RECV_DLENGTH |
+				  ISCSI_MAX_XMIT_DLENGTH |
+				  ISCSI_HDRDGST_EN |
+				  ISCSI_DATADGST_EN |
+				  ISCSI_INITIAL_R2T_EN |
+				  ISCSI_MAX_R2T |
+				  ISCSI_IMM_DATA_EN |
+				  ISCSI_FIRST_BURST |
+				  ISCSI_MAX_BURST |
+				  ISCSI_PDU_INORDER_EN |
+				  ISCSI_DATASEQ_INORDER_EN |
+				  ISCSI_ERL |
+				  ISCSI_CONN_PORT |
+				  ISCSI_CONN_ADDRESS |
+				  ISCSI_EXP_STATSN,
+	.host_template		= &amp;iscsi_sht,
+	.conndata_size		= sizeof(struct iscsi_conn),
+	.max_conn		= 1,
+	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
+	/* session management */
+	.create_session		= iscsi_tcp_session_create,
+	.destroy_session	= iscsi_tcp_session_destroy,
+	/* connection management */
+	.create_conn		= iscsi_tcp_conn_create,
+	.bind_conn		= iscsi_tcp_conn_bind,
+	.destroy_conn		= iscsi_tcp_conn_destroy,
+	.set_param		= iscsi_conn_set_param,
+	.get_conn_param		= iscsi_conn_get_param,
+	.get_conn_str_param	= iscsi_conn_get_str_param,
+	.get_session_param	= iscsi_session_get_param,
+	.start_conn		= iscsi_conn_start,
+	.stop_conn		= iscsi_conn_stop,
+	/* these are called as part of conn recovery */
+	.suspend_conn_recv	= iscsi_tcp_suspend_conn_rx,
+	.terminate_conn		= iscsi_tcp_terminate_conn,
+	/* IO */
+	.send_pdu		= iscsi_conn_send_pdu,
+	.get_stats		= iscsi_conn_get_stats,
+	.init_cmd_task		= iscsi_tcp_cmd_init,
+	.init_mgmt_task		= iscsi_tcp_mgmt_init,
+	.xmit_cmd_task		= iscsi_tcp_ctask_xmit,
+	.xmit_mgmt_task		= iscsi_tcp_mtask_xmit,
+	.cleanup_cmd_task	= iscsi_tcp_cleanup_ctask,
+	/* recovery */
+	.session_recovery_timedout = iscsi_session_recovery_timedout,
+};
+
+static int __init
+iscsi_tcp_init(void)
+{
+	if (iscsi_max_lun &lt; 1) {
+		printk(KERN_ERR &quot;iscsi_tcp: Invalid max_lun value of %u\n&quot;, iscsi_max_lun);
+		return -EINVAL;
+	}
+	iscsi_tcp_transport.max_lun = iscsi_max_lun;
+
+	taskcache = kmem_cache_create(&quot;iscsi_taskcache&quot;,
+			sizeof(struct iscsi_data_task), 0,
+			SLAB_HWCACHE_ALIGN, NULL, NULL);
+	if (!taskcache)
+		return -ENOMEM;
+
+	if (!iscsi_register_transport(&amp;iscsi_tcp_transport))
+		kmem_cache_destroy(taskcache);
+
+	return 0;
+}
+
+static void __exit
+iscsi_tcp_exit(void)
+{
+	iscsi_unregister_transport(&amp;iscsi_tcp_transport);
+	kmem_cache_destroy(taskcache);
+}
+
+module_init(iscsi_tcp_init);
+module_exit(iscsi_tcp_exit);

Added: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,180 @@
+/*
+ * iSCSI Initiator TCP Transport
+ * Copyright (C) 2004 Dmitry Yusupov
+ * Copyright (C) 2004 Alex Aizman
+ * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef ISCSI_TCP_H
+#define ISCSI_TCP_H
+
+#include &quot;libiscsi.h&quot;
+
+/* Socket's Receive state machine */
+#define IN_PROGRESS_WAIT_HEADER		0x0
+#define IN_PROGRESS_HEADER_GATHER	0x1
+#define IN_PROGRESS_DATA_RECV		0x2
+#define IN_PROGRESS_DDIGEST_RECV	0x3
+
+/* xmit state machine */
+#define	XMSTATE_IDLE			0x0
+#define	XMSTATE_R_HDR			0x1
+#define	XMSTATE_W_HDR			0x2
+#define	XMSTATE_IMM_HDR			0x4
+#define	XMSTATE_IMM_DATA		0x8
+#define	XMSTATE_UNS_INIT		0x10
+#define	XMSTATE_UNS_HDR			0x20
+#define	XMSTATE_UNS_DATA		0x40
+#define	XMSTATE_SOL_HDR			0x80
+#define	XMSTATE_SOL_DATA		0x100
+#define	XMSTATE_W_PAD			0x200
+#define XMSTATE_DATA_DIGEST		0x400
+
+#define ISCSI_CONN_RCVBUF_MIN		262144
+#define ISCSI_CONN_SNDBUF_MIN		262144
+#define ISCSI_PAD_LEN			4
+#define ISCSI_R2T_MAX			16
+#define ISCSI_SG_TABLESIZE		SG_ALL
+#define ISCSI_TCP_MAX_CMD_LEN		16
+
+struct socket;
+
+/* Socket connection recieve helper */
+struct iscsi_tcp_recv {
+	struct iscsi_hdr	*hdr;
+	struct sk_buff		*skb;
+	int			offset;
+	int			len;
+	int			hdr_offset;
+	int			copy;
+	int			copied;
+	int			padding;
+	struct iscsi_cmd_task	*ctask;		/* current cmd in progress */
+
+	/* copied and flipped values */
+	int			datalen;
+	int			datadgst;
+	char			zero_copy_hdr;
+};
+
+struct iscsi_tcp_conn {
+	struct iscsi_conn	*iscsi_conn;
+	struct socket		*sock;
+	struct iscsi_hdr	hdr;		/* header placeholder */
+	char			hdrext[4*sizeof(__u16) +
+				    sizeof(__u32)];
+	int			data_copied;
+	char			*data;		/* data placeholder */
+	int			data_size;	/* actual recv_dlength */
+	int			stop_stage;	/* conn_stop() flag: *
+						 * stop to recover,  *
+						 * stop to terminate */
+	/* iSCSI connection-wide sequencing */
+	int			hdr_size;	/* PDU header size */
+
+	struct crypto_tfm	*rx_tfm;	/* CRC32C (Rx) */
+	struct crypto_tfm	*data_rx_tfm;	/* CRC32C (Rx) for data */
+
+	/* control data */
+	struct iscsi_tcp_recv	in;		/* TCP receive context */
+	int			in_progress;	/* connection state machine */
+
+	/* old values for socket callbacks */
+	void			(*old_data_ready)(struct sock *, int);
+	void			(*old_state_change)(struct sock *);
+	void			(*old_write_space)(struct sock *);
+
+	/* xmit */
+	struct crypto_tfm	*tx_tfm;	/* CRC32C (Tx) */
+	struct crypto_tfm	*data_tx_tfm;	/* CRC32C (Tx) for data */
+
+	/* MIB custom statistics */
+	uint32_t		sendpage_failures_cnt;
+	uint32_t		discontiguous_hdr_cnt;
+
+	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
+};
+
+struct iscsi_buf {
+	struct scatterlist	sg;
+	unsigned int		sent;
+	char			use_sendmsg;
+};
+
+struct iscsi_data_task {
+	struct iscsi_data	hdr;			/* PDU */
+	char			hdrext[sizeof(__u32)];	/* Header-Digest */
+	struct list_head	item;			/* data queue item */
+	struct iscsi_buf	digestbuf;		/* digest buffer */
+	uint32_t		digest;			/* data digest */
+};
+#define ISCSI_DTASK_DEFAULT_MAX	ISCSI_SG_TABLESIZE * PAGE_SIZE / 512
+
+struct iscsi_tcp_mgmt_task {
+	struct iscsi_hdr	hdr;
+	char			hdrext[sizeof(__u32)]; /* Header-Digest */
+	int			xmstate;	/* mgmt xmit progress */
+	struct iscsi_buf	headbuf;	/* header buffer */
+	struct iscsi_buf	sendbuf;	/* in progress buffer */
+	int			sent;
+};
+
+struct iscsi_r2t_info {
+	__be32			ttt;		/* copied from R2T */
+	__be32			exp_statsn;	/* copied from R2T */
+	uint32_t		data_length;	/* copied from R2T */
+	uint32_t		data_offset;	/* copied from R2T */
+	struct iscsi_buf	headbuf;	/* Data-Out Header Buffer */
+	struct iscsi_buf	sendbuf;	/* Data-Out in progress buffer*/
+	int			sent;		/* R2T sequence progress */
+	int			data_count;	/* DATA-Out payload progress */
+	struct scatterlist	*sg;		/* per-R2T SG list */
+	int			solicit_datasn;
+	struct iscsi_data_task   *dtask;        /* which data task */
+};
+
+struct iscsi_tcp_cmd_task {
+	struct iscsi_cmd	hdr;
+	char			hdrext[4*sizeof(__u16)+	/* AHS */
+				    sizeof(__u32)];	/* HeaderDigest */
+	char			pad[ISCSI_PAD_LEN];
+	int			pad_count;		/* padded bytes */
+	struct iscsi_buf	headbuf;		/* header buf (xmit) */
+	struct iscsi_buf	sendbuf;		/* in progress buffer*/
+	int			xmstate;		/* xmit xtate machine */
+	int			sent;
+	struct scatterlist	*sg;			/* per-cmd SG list  */
+	struct scatterlist	*bad_sg;		/* assert statement */
+	int			sg_count;		/* SG's to process  */
+	uint32_t		exp_r2tsn;
+	int			r2t_data_count;		/* R2T Data-Out bytes */
+	int			data_offset;
+	struct iscsi_r2t_info	*r2t;			/* in progress R2T    */
+	struct iscsi_queue	r2tpool;
+	struct kfifo		*r2tqueue;
+	struct iscsi_r2t_info	**r2ts;
+	struct list_head	dataqueue;		/* Data-Out dataqueue */
+	mempool_t		*datapool;
+	uint32_t		datadigest;		/* for recover digest */
+	int			digest_count;
+	uint32_t		immdigest;		/* for imm data */
+	struct iscsi_buf	immbuf;			/* for imm data digest */
+	struct iscsi_data_task   *dtask;		/* data task in progress*/
+	int			digest_offset;		/* for partial buff digest */
+};
+
+#endif /* ISCSI_H */

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-04-29 14:03:22 UTC (rev 432)
@@ -39,9 +39,9 @@
 #include &lt;scsi/scsi.h&gt;
 #include &lt;iscsi_tcp.h&gt;
 #include &lt;scsi/libiscsi.h&gt;
-#include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/scsi_tgt.h&gt;
 #include &lt;scsi/scsi_tcq.h&gt;
+#include &quot;scsi_transport_iscsi.h&quot;
 
 /* tmp - will replace with SCSI logging stuff */
 #define eprintk(fmt, args...)					\

Added: branches/use-scsi-ml/istgt/kernel/libiscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,1712 @@
+/*
+ * iSCSI lib functions
+ *
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004 - 2006 Mike Christie
+ * Copyright (C) 2004 - 2005 Dmitry Yusupov
+ * Copyright (C) 2004 - 2005 Alex Aizman
+ * maintained by <A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">open-iscsi at googlegroups.com</A>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include &lt;linux/types.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/kfifo.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;net/tcp.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
+#include &lt;scsi/scsi_device.h&gt;
+#include &lt;scsi/scsi_eh.h&gt;
+#include &lt;scsi/scsi_tcq.h&gt;
+#include &lt;scsi/scsi_host.h&gt;
+#include &lt;scsi/scsi.h&gt;
+#include &lt;scsi/iscsi_proto.h&gt;
+#include &lt;scsi/scsi_transport.h&gt;
+#include &quot;scsi_transport_iscsi.h&quot;
+#include &quot;libiscsi.h&quot;
+
+struct iscsi_session *
+class_to_transport_session(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	return iscsi_hostdata(shost-&gt;hostdata);
+}
+EXPORT_SYMBOL_GPL(class_to_transport_session);
+
+#define INVALID_SN_DELTA	0xffff
+
+int
+iscsi_check_assign_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
+{
+	uint32_t max_cmdsn = be32_to_cpu(hdr-&gt;max_cmdsn);
+	uint32_t exp_cmdsn = be32_to_cpu(hdr-&gt;exp_cmdsn);
+
+	if (max_cmdsn &lt; exp_cmdsn -1 &amp;&amp;
+	    max_cmdsn &gt; exp_cmdsn - INVALID_SN_DELTA)
+		return ISCSI_ERR_MAX_CMDSN;
+	if (max_cmdsn &gt; session-&gt;max_cmdsn ||
+	    max_cmdsn &lt; session-&gt;max_cmdsn - INVALID_SN_DELTA)
+		session-&gt;max_cmdsn = max_cmdsn;
+	if (exp_cmdsn &gt; session-&gt;exp_cmdsn ||
+	    exp_cmdsn &lt; session-&gt;exp_cmdsn - INVALID_SN_DELTA)
+		session-&gt;exp_cmdsn = exp_cmdsn;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_check_assign_cmdsn);
+
+void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *ctask,
+				   struct iscsi_data *hdr,
+				   int transport_data_cnt)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+
+	memset(hdr, 0, sizeof(struct iscsi_data));
+	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	hdr-&gt;datasn = cpu_to_be32(ctask-&gt;unsol_datasn);
+	ctask-&gt;unsol_datasn++;
+	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+
+	hdr-&gt;offset = cpu_to_be32(ctask-&gt;total_length -
+				  transport_data_cnt -
+				  ctask-&gt;unsol_count);
+
+	if (ctask-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
+		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
+		ctask-&gt;data_count = conn-&gt;max_xmit_dlength;
+		hdr-&gt;flags = 0;
+	} else {
+		hton24(hdr-&gt;dlength, ctask-&gt;unsol_count);
+		ctask-&gt;data_count = ctask-&gt;unsol_count;
+		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	}
+}
+EXPORT_SYMBOL_GPL(iscsi_prep_unsolicit_data_pdu);
+
+/**
+ * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu
+ * @ctask: iscsi cmd task
+ *
+ * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set
+ * fields like dlength or final based on how much data it sends
+ */
+static void iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd *hdr = ctask-&gt;hdr;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+        hdr-&gt;opcode = ISCSI_OP_SCSI_CMD;
+        hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
+        int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
+        hdr-&gt;itt = ctask-&gt;itt | (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT) |
+                         (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT);
+        hdr-&gt;data_length = cpu_to_be32(sc-&gt;request_bufflen);
+        hdr-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+        session-&gt;cmdsn++;
+        hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+        memcpy(hdr-&gt;cdb, sc-&gt;cmnd, sc-&gt;cmd_len);
+        memset(&amp;hdr-&gt;cdb[sc-&gt;cmd_len], 0, MAX_COMMAND_SIZE - sc-&gt;cmd_len);
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		hdr-&gt;flags |= ISCSI_FLAG_CMD_WRITE;
+		/*
+		 * Write counters:
+		 *
+		 *	imm_count	bytes to be sent right after
+		 *			SCSI PDU Header
+		 *
+		 *	unsol_count	bytes(as Data-Out) to be sent
+		 *			without	R2T ack right after
+		 *			immediate data
+		 *
+		 *	r2t_data_count	bytes to be sent via R2T ack's
+		 *
+		 *      pad_count       bytes to be sent as zero-padding
+		 */
+		ctask-&gt;imm_count = 0;
+		ctask-&gt;unsol_count = 0;
+		ctask-&gt;unsol_datasn = 0;
+
+		if (session-&gt;imm_data_en) {
+			if (ctask-&gt;total_length &gt;= session-&gt;first_burst)
+				ctask-&gt;imm_count = min(session-&gt;first_burst,
+							conn-&gt;max_xmit_dlength);
+			else
+				ctask-&gt;imm_count = min(ctask-&gt;total_length,
+							conn-&gt;max_xmit_dlength);
+			hton24(ctask-&gt;hdr-&gt;dlength, ctask-&gt;imm_count);
+		} else
+			zero_data(ctask-&gt;hdr-&gt;dlength);
+
+		if (!session-&gt;initial_r2t_en)
+			ctask-&gt;unsol_count = min(session-&gt;first_burst,
+				ctask-&gt;total_length) - ctask-&gt;imm_count;
+		if (!ctask-&gt;unsol_count)
+			/* No unsolicit Data-Out's */
+			ctask-&gt;hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+	} else {
+		ctask-&gt;datasn = 0;
+		hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+		zero_data(hdr-&gt;dlength);
+
+		if (sc-&gt;sc_data_direction == DMA_FROM_DEVICE)
+			hdr-&gt;flags |= ISCSI_FLAG_CMD_READ;
+	}
+
+	conn-&gt;scsicmd_pdus_cnt++;
+}
+EXPORT_SYMBOL_GPL(iscsi_prep_scsi_cmd_pdu);
+
+/**
+ * iscsi_complete_command - return command back to scsi-ml
+ * @session: iscsi session
+ * @ctask: iscsi cmd task
+ *
+ * Must be called with session lock.
+ * This function returns the scsi command to scsi-ml and returns
+ * the cmd task to the pool of available cmd tasks.
+ */
+static void iscsi_complete_command(struct iscsi_session *session,
+				   struct iscsi_cmd_task *ctask)
+{
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+	ctask-&gt;sc = NULL;
+	list_del_init(&amp;ctask-&gt;running);
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+	sc-&gt;scsi_done(sc);
+}
+
+/**
+ * iscsi_cmd_rsp - SCSI Command Response processing
+ * @conn: iscsi connection
+ * @hdr: iscsi header
+ * @ctask: scsi command task
+ * @data: cmd data buffer
+ * @datalen: len of buffer
+ *
+ * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and
+ * then completes the command and task.
+ **/
+static int iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			      struct iscsi_cmd_task *ctask, char *data,
+			      int datalen)
+{
+	int rc;
+	struct iscsi_cmd_rsp *rhdr = (struct iscsi_cmd_rsp *)hdr;
+	struct iscsi_session *session = conn-&gt;session;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc) {
+		sc-&gt;result = DID_ERROR &lt;&lt; 16;
+		goto out;
+	}
+
+	conn-&gt;exp_statsn = be32_to_cpu(rhdr-&gt;statsn) + 1;
+
+	sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
+
+	if (rhdr-&gt;response != ISCSI_STATUS_CMD_COMPLETED) {
+		sc-&gt;result = DID_ERROR &lt;&lt; 16;
+		goto out;
+	}
+
+	if (rhdr-&gt;cmd_status == SAM_STAT_CHECK_CONDITION) {
+		int senselen;
+
+		if (datalen &lt; 2) {
+invalid_datalen:
+			printk(KERN_ERR &quot;iscsi: Got CHECK_CONDITION but invalid &quot;
+			       &quot;data buffer size of %d\n&quot;, datalen);
+			sc-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+			goto out;
+		}
+
+		senselen = (data[0] &lt;&lt; 8) | data[1];
+		if (datalen &lt; senselen)
+			goto invalid_datalen;
+
+		memcpy(sc-&gt;sense_buffer, data + 2,
+		       min(senselen, SCSI_SENSE_BUFFERSIZE));
+		debug_scsi(&quot;copied %d bytes of sense\n&quot;,
+			   min(senselen, SCSI_SENSE_BUFFERSIZE));
+	}
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE)
+		goto out;
+
+	if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_UNDERFLOW) {
+		int res_count = be32_to_cpu(rhdr-&gt;residual_count);
+
+		if (res_count &gt; 0 &amp;&amp; res_count &lt;= sc-&gt;request_bufflen)
+			sc-&gt;resid = res_count;
+		else
+			sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
+	} else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_BIDI_UNDERFLOW)
+		sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
+	else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_OVERFLOW)
+		sc-&gt;resid = be32_to_cpu(rhdr-&gt;residual_count);
+
+out:
+	debug_scsi(&quot;done [sc %lx res %d itt 0x%x]\n&quot;,
+		   (long)sc, sc-&gt;result, ctask-&gt;itt);
+	conn-&gt;scsirsp_pdus_cnt++;
+
+	iscsi_complete_command(conn-&gt;session, ctask);
+	return rc;
+}
+
+/**
+ * __iscsi_complete_pdu - complete pdu
+ * @conn: iscsi conn
+ * @hdr: iscsi header
+ * @data: data buffer
+ * @datalen: len of data buffer
+ *
+ * Completes pdu processing by freeing any resources allocated at
+ * queuecommand or send generic. session lock must be held and verify
+ * itt must have been called.
+ */
+int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			 char *data, int datalen)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	int opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, rc = 0;
+	struct iscsi_cmd_task *ctask;
+	struct iscsi_mgmt_task *mtask;
+	uint32_t itt;
+
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG))
+		itt = hdr-&gt;itt &amp; ISCSI_ITT_MASK;
+	else
+		itt = hdr-&gt;itt;
+
+	if (itt &lt; session-&gt;cmds_max) {
+		ctask = session-&gt;cmds[itt];
+
+		debug_scsi(&quot;cmdrsp [op 0x%x cid %d itt 0x%x len %d]\n&quot;,
+			   opcode, conn-&gt;id, ctask-&gt;itt, datalen);
+
+		switch(opcode) {
+		case ISCSI_OP_SCSI_CMD_RSP:
+			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+			rc = iscsi_scsi_cmd_rsp(conn, hdr, ctask, data,
+						datalen);
+			break;
+		case ISCSI_OP_SCSI_DATA_IN:
+			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+			if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
+				conn-&gt;scsirsp_pdus_cnt++;
+				iscsi_complete_command(session, ctask);
+			}
+			break;
+		case ISCSI_OP_R2T:
+			/* LLD handles this for now */
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else if (itt &gt;= ISCSI_MGMT_ITT_OFFSET &amp;&amp;
+		   itt &lt; ISCSI_MGMT_ITT_OFFSET + session-&gt;mgmtpool_max) {
+		mtask = session-&gt;mgmt_cmds[itt - ISCSI_MGMT_ITT_OFFSET];
+
+		debug_scsi(&quot;immrsp [op 0x%x cid %d itt 0x%x len %d]\n&quot;,
+			   opcode, conn-&gt;id, mtask-&gt;itt, datalen);
+
+		rc = iscsi_check_assign_cmdsn(session,
+					      (struct iscsi_nopin*)hdr);
+		if (rc)
+			goto done;
+
+		switch(opcode) {
+		case ISCSI_OP_LOGOUT_RSP:
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+			/* fall through */
+		case ISCSI_OP_LOGIN_RSP:
+		case ISCSI_OP_TEXT_RSP:
+			/*
+			 * login related PDU's exp_statsn is handled in
+			 * userspace
+			 */
+			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
+			list_del(&amp;mtask-&gt;running);
+			if (conn-&gt;login_mtask != mtask)
+				__kfifo_put(session-&gt;mgmtpool.queue,
+					    (void*)&amp;mtask, sizeof(void*));
+			break;
+		case ISCSI_OP_SCSI_TMFUNC_RSP:
+			if (datalen) {
+				rc = ISCSI_ERR_PROTO;
+				break;
+			}
+
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+			conn-&gt;tmfrsp_pdus_cnt++;
+			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+				conn-&gt;tmabort_state =
+					((struct iscsi_tm_rsp *)hdr)-&gt;
+					response == ISCSI_TMF_RSP_COMPLETE ?
+						TMABORT_SUCCESS:TMABORT_FAILED;
+				/* unblock eh_abort() */
+				wake_up(&amp;conn-&gt;ehwait);
+			}
+			break;
+		case ISCSI_OP_NOOP_IN:
+			if (hdr-&gt;ttt != ISCSI_RESERVED_TAG) {
+				rc = ISCSI_ERR_PROTO;
+				break;
+			}
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+
+			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
+			list_del(&amp;mtask-&gt;running);
+			if (conn-&gt;login_mtask != mtask)
+				__kfifo_put(session-&gt;mgmtpool.queue,
+					    (void*)&amp;mtask, sizeof(void*));
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else if (itt == ISCSI_RESERVED_TAG) {
+		switch(opcode) {
+		case ISCSI_OP_NOOP_IN:
+			if (!datalen) {
+				rc = iscsi_check_assign_cmdsn(session,
+						 (struct iscsi_nopin*)hdr);
+				if (!rc &amp;&amp; hdr-&gt;ttt != ISCSI_RESERVED_TAG)
+					rc = iscsi_recv_pdu(conn-&gt;cls_conn,
+							    hdr, NULL, 0);
+			} else
+				rc = ISCSI_ERR_PROTO;
+			break;
+		case ISCSI_OP_REJECT:
+			/* we need sth like iscsi_reject_rsp()*/
+		case ISCSI_OP_ASYNC_EVENT:
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+			/* we need sth like iscsi_async_event_rsp() */
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else
+		rc = ISCSI_ERR_BAD_ITT;
+
+done:
+	return rc;
+}
+EXPORT_SYMBOL_GPL(__iscsi_complete_pdu);
+
+int iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+		       char *data, int datalen)
+{
+	int rc;
+
+	spin_lock(&amp;conn-&gt;session-&gt;lock);
+	rc = __iscsi_complete_pdu(conn, hdr, data, datalen);
+	spin_unlock(&amp;conn-&gt;session-&gt;lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(iscsi_complete_pdu);
+
+/* verify itt (itt encoding: age+cid+itt) */
+int iscsi_verify_itt(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+		     uint32_t *ret_itt)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd_task *ctask;
+	uint32_t itt;
+
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if ((hdr-&gt;itt &amp; ISCSI_AGE_MASK) !=
+		    (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT)) {
+			printk(KERN_ERR &quot;iscsi: received itt %x expected &quot;
+				&quot;session age (%x)\n&quot;, hdr-&gt;itt,
+				session-&gt;age &amp; ISCSI_AGE_MASK);
+			return ISCSI_ERR_BAD_ITT;
+		}
+
+		if ((hdr-&gt;itt &amp; ISCSI_CID_MASK) !=
+		    (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT)) {
+			printk(KERN_ERR &quot;iscsi: received itt %x, expected &quot;
+				&quot;CID (%x)\n&quot;, hdr-&gt;itt, conn-&gt;id);
+			return ISCSI_ERR_BAD_ITT;
+		}
+		itt = hdr-&gt;itt &amp; ISCSI_ITT_MASK;
+	} else
+		itt = hdr-&gt;itt;
+
+	if (itt &lt; session-&gt;cmds_max) {
+		ctask = session-&gt;cmds[itt];
+
+		if (!ctask-&gt;sc) {
+			printk(KERN_INFO &quot;iscsi: dropping ctask with &quot;
+			       &quot;itt 0x%x\n&quot;, ctask-&gt;itt);
+			/* force drop */
+			return ISCSI_ERR_NO_SCSI_CMD;
+		}
+
+		if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
+			printk(KERN_ERR &quot;iscsi: ctask's session age %d, &quot;
+				&quot;expected %d\n&quot;, ctask-&gt;sc-&gt;SCp.phase,
+				session-&gt;age);
+			return ISCSI_ERR_SESSION_FAILED;
+		}
+	}
+
+	*ret_itt = itt;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_verify_itt);
+
+void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;conn_cnt == 1 || session-&gt;leadconn == conn)
+		session-&gt;state = ISCSI_STATE_FAILED;
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	iscsi_conn_error(conn-&gt;cls_conn, err);
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_failure);
+
+/**
+ * iscsi_data_xmit - xmit any command into the scheduled connection
+ * @conn: iscsi connection
+ *
+ * Notes:
+ *	The function can return -EAGAIN in which case the caller must
+ *	re-schedule it again later or recover. '0' return code means
+ *	successful xmit.
+ **/
+static int iscsi_data_xmit(struct iscsi_conn *conn)
+{
+	struct iscsi_transport *tt;
+
+	if (unlikely(conn-&gt;suspend_tx)) {
+		debug_scsi(&quot;conn %d Tx suspended!\n&quot;, conn-&gt;id);
+		return 0;
+	}
+	tt = conn-&gt;session-&gt;tt;
+
+	/*
+	 * Transmit in the following order:
+	 *
+	 * 1) un-finished xmit (ctask or mtask)
+	 * 2) immediate control PDUs
+	 * 3) write data
+	 * 4) SCSI commands
+	 * 5) non-immediate control PDUs
+	 *
+	 * No need to lock around __kfifo_get as long as
+	 * there's one producer and one consumer.
+	 */
+
+	BUG_ON(conn-&gt;ctask &amp;&amp; conn-&gt;mtask);
+
+	if (conn-&gt;ctask) {
+		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+			goto again;
+		/* done with this in-progress ctask */
+		conn-&gt;ctask = NULL;
+	}
+	if (conn-&gt;mtask) {
+	        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+		        goto again;
+		/* done with this in-progress mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	/* process immediate first */
+        if (unlikely(__kfifo_len(conn-&gt;immqueue))) {
+	        while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;conn-&gt;mtask,
+			           sizeof(void*))) {
+			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
+				      &amp;conn-&gt;mgmt_run_list);
+		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+			        goto again;
+	        }
+		/* done with this mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	/* process command queue */
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;conn-&gt;ctask,
+			   sizeof(void*))) {
+		/*
+		 * iscsi tcp may readd the task to the xmitqueue to send
+		 * write data
+		 */
+		if (list_empty(&amp;conn-&gt;ctask-&gt;running))
+			list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
+		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+			goto again;
+	}
+	/* done with this ctask */
+	conn-&gt;ctask = NULL;
+
+	/* process the rest control plane PDUs, if any */
+        if (unlikely(__kfifo_len(conn-&gt;mgmtqueue))) {
+	        while (__kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;conn-&gt;mtask,
+			           sizeof(void*))) {
+			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
+				      &amp;conn-&gt;mgmt_run_list);
+		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+			        goto again;
+	        }
+		/* done with this mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	return 0;
+
+again:
+	if (unlikely(conn-&gt;suspend_tx))
+		return 0;
+
+	return -EAGAIN;
+}
+
+static void iscsi_xmitworker(void *data)
+{
+	struct iscsi_conn *conn = data;
+
+	/*
+	 * serialize Xmit worker on a per-connection basis.
+	 */
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	if (iscsi_data_xmit(conn))
+		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+}
+
+enum {
+	FAILURE_BAD_HOST = 1,
+	FAILURE_SESSION_FAILED,
+	FAILURE_SESSION_FREED,
+	FAILURE_WINDOW_CLOSED,
+	FAILURE_SESSION_TERMINATE,
+	FAILURE_SESSION_RECOVERY_TIMEOUT,
+};
+
+int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *host;
+	int reason = 0;
+	struct iscsi_session *session;
+	struct iscsi_conn *conn;
+	struct iscsi_cmd_task *ctask = NULL;
+
+	sc-&gt;scsi_done = done;
+	sc-&gt;result = 0;
+
+	host = sc-&gt;device-&gt;host;
+	session = iscsi_hostdata(host-&gt;hostdata);
+
+	spin_lock(&amp;session-&gt;lock);
+
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		if (session-&gt;recovery_failed) {
+			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
+			goto fault;
+		} else if (session-&gt;state == ISCSI_STATE_FAILED) {
+			reason = FAILURE_SESSION_FAILED;
+			goto reject;
+		} else if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+			reason = FAILURE_SESSION_TERMINATE;
+			goto fault;
+		}
+		reason = FAILURE_SESSION_FREED;
+		goto fault;
+	}
+
+	/*
+	 * Check for iSCSI window and take care of CmdSN wrap-around
+	 */
+	if ((int)(session-&gt;max_cmdsn - session-&gt;cmdsn) &lt; 0) {
+		reason = FAILURE_WINDOW_CLOSED;
+		goto reject;
+	}
+
+	conn = session-&gt;leadconn;
+
+	__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+	sc-&gt;SCp.phase = session-&gt;age;
+	sc-&gt;SCp.ptr = (char *)ctask;
+
+	ctask-&gt;mtask = NULL;
+	ctask-&gt;conn = conn;
+	ctask-&gt;sc = sc;
+	INIT_LIST_HEAD(&amp;ctask-&gt;running);
+	ctask-&gt;total_length = sc-&gt;request_bufflen;
+	iscsi_prep_scsi_cmd_pdu(ctask);
+
+	session-&gt;tt-&gt;init_cmd_task(ctask);
+
+	__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*));
+	debug_scsi(
+	       &quot;ctask enq [%s cid %d sc %lx itt 0x%x len %d cmdsn %d win %d]\n&quot;,
+		sc-&gt;sc_data_direction == DMA_TO_DEVICE ? &quot;write&quot; : &quot;read&quot;,
+		conn-&gt;id, (long)sc, ctask-&gt;itt, sc-&gt;request_bufflen,
+		session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
+	spin_unlock(&amp;session-&gt;lock);
+
+	scsi_queue_work(host, &amp;conn-&gt;xmitwork);
+	return 0;
+
+reject:
+	spin_unlock(&amp;session-&gt;lock);
+	debug_scsi(&quot;cmd 0x%x rejected (%d)\n&quot;, sc-&gt;cmnd[0], reason);
+	return SCSI_MLQUEUE_HOST_BUSY;
+
+fault:
+	spin_unlock(&amp;session-&gt;lock);
+	printk(KERN_ERR &quot;iscsi: cmd 0x%x is not queued (%d)\n&quot;,
+	       sc-&gt;cmnd[0], reason);
+	sc-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);
+	sc-&gt;resid = sc-&gt;request_bufflen;
+	sc-&gt;scsi_done(sc);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_queuecommand);
+
+int iscsi_change_queue_depth(struct scsi_device *sdev, int depth)
+{
+	if (depth &gt; ISCSI_MAX_CMD_PER_LUN)
+		depth = ISCSI_MAX_CMD_PER_LUN;
+	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+	return sdev-&gt;queue_depth;
+}
+EXPORT_SYMBOL_GPL(iscsi_change_queue_depth);
+
+static int
+iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			char *data, uint32_t data_size)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
+	struct iscsi_mgmt_task *mtask;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return -EPERM;
+	}
+	if (hdr-&gt;opcode == (ISCSI_OP_LOGIN | ISCSI_OP_IMMEDIATE) ||
+	    hdr-&gt;opcode == (ISCSI_OP_TEXT | ISCSI_OP_IMMEDIATE))
+		/*
+		 * Login and Text are sent serially, in
+		 * request-followed-by-response sequence.
+		 * Same mtask can be used. Same ITT must be used.
+		 * Note that login_mtask is preallocated at conn_create().
+		 */
+		mtask = conn-&gt;login_mtask;
+	else {
+	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
+	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
+
+		nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+		if (!__kfifo_get(session-&gt;mgmtpool.queue,
+				 (void*)&amp;mtask, sizeof(void*))) {
+			spin_unlock_bh(&amp;session-&gt;lock);
+			return -ENOSPC;
+		}
+	}
+
+	/*
+	 * pre-format CmdSN for outgoing PDU.
+	 */
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		hdr-&gt;itt = mtask-&gt;itt | (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT) |
+			   (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT);
+		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+		if (conn-&gt;c_stage == ISCSI_CONN_STARTED &amp;&amp;
+		    !(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE))
+			session-&gt;cmdsn++;
+	} else
+		/* do not advance CmdSN */
+		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+
+	if (data_size) {
+		memcpy(mtask-&gt;data, data, data_size);
+		mtask-&gt;data_count = data_size;
+	} else
+		mtask-&gt;data_count = 0;
+
+	INIT_LIST_HEAD(&amp;mtask-&gt;running);
+	memcpy(mtask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
+	if (session-&gt;tt-&gt;init_mgmt_task)
+		session-&gt;tt-&gt;init_mgmt_task(conn, mtask, data, data_size);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	debug_scsi(&quot;mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n&quot;,
+		   hdr-&gt;opcode, hdr-&gt;itt, data_size);
+
+	/*
+	 * since send_pdu() could be called at least from two contexts,
+	 * we need to serialize __kfifo_put, so we don't have to take
+	 * additional lock on fast data-path
+	 */
+        if (hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)
+	        __kfifo_put(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*));
+	else
+	        __kfifo_put(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*));
+
+	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
+	return 0;
+}
+
+int iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
+			char *data, uint32_t data_size)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	int rc;
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	rc = iscsi_conn_send_generic(conn, hdr, data, data_size);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_send_pdu);
+
+void iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		session-&gt;recovery_failed = 1;
+		if (conn)
+			wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+}
+EXPORT_SYMBOL_GPL(iscsi_session_recovery_timedout);
+
+int iscsi_eh_host_reset(struct scsi_cmnd *sc)
+{
+	struct Scsi_Host *host = sc-&gt;device-&gt;host;
+	struct iscsi_session *session = iscsi_hostdata(host-&gt;hostdata);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+	int fail_session = 0;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+failed:
+		debug_scsi(&quot;failing host reset: session terminated &quot;
+			   &quot;[CID %d age %d]&quot;, conn-&gt;id, session-&gt;age);
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return FAILED;
+	}
+
+	if (sc-&gt;SCp.phase == session-&gt;age) {
+		debug_scsi(&quot;failing connection CID %d due to SCSI host reset&quot;,
+			   conn-&gt;id);
+		fail_session = 1;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * we drop the lock here but the leadconn cannot be destoyed while
+	 * we are in the scsi eh
+	 */
+	if (fail_session) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		/*
+		 * if userspace cannot respond then we must kick this off
+		 * here for it
+		 */
+		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
+	}
+
+	debug_scsi(&quot;iscsi_eh_host_reset wait for relogin\n&quot;);
+	wait_event_interruptible(conn-&gt;ehwait,
+				 session-&gt;state == ISCSI_STATE_TERMINATE ||
+				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
+		printk(KERN_INFO &quot;iscsi: host reset succeeded\n&quot;);
+	else
+		goto failed;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL_GPL(iscsi_eh_host_reset);
+
+static void iscsi_tmabort_timedout(unsigned long data)
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)data;
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+
+	spin_lock(&amp;session-&gt;lock);
+	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+		conn-&gt;tmabort_state = TMABORT_TIMEDOUT;
+		debug_scsi(&quot;tmabort timedout [sc %p itt 0x%x]\n&quot;,
+			ctask-&gt;sc, ctask-&gt;itt);
+		/* unblock eh_abort() */
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock(&amp;session-&gt;lock);
+}
+
+/* must be called with the mutex lock */
+static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
+				 struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tm *hdr = &amp;conn-&gt;tmhdr;
+	int rc;
+
+	/*
+	 * ctask timed out but session is OK requests must be serialized.
+	 */
+	memset(hdr, 0, sizeof(struct iscsi_tm));
+	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
+	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK;
+	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;rtt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;refcmdsn = ctask-&gt;hdr-&gt;cmdsn;
+
+	rc = iscsi_conn_send_generic(conn, (struct iscsi_hdr *)hdr,
+				     NULL, 0);
+	if (rc) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		debug_scsi(&quot;abort sent failure [itt 0x%x] %d&quot;, ctask-&gt;itt, rc);
+		return rc;
+	}
+
+	debug_scsi(&quot;abort sent [itt 0x%x]\n&quot;, ctask-&gt;itt);
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	ctask-&gt;mtask = (struct iscsi_mgmt_task *)
+			session-&gt;mgmt_cmds[(hdr-&gt;itt &amp; ISCSI_ITT_MASK) -
+					ISCSI_MGMT_ITT_OFFSET];
+
+	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+		conn-&gt;tmfcmd_pdus_cnt++;
+		conn-&gt;tmabort_timer.expires = 10*HZ + jiffies;
+		conn-&gt;tmabort_timer.function = iscsi_tmabort_timedout;
+		conn-&gt;tmabort_timer.data = (unsigned long)ctask;
+		add_timer(&amp;conn-&gt;tmabort_timer);
+		debug_scsi(&quot;abort set timeout [itt 0x%x]&quot;, ctask-&gt;itt);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	/*
+	 * block eh thread until:
+	 *
+	 * 1) abort response
+	 * 2) abort timeout
+	 * 3) session is terminated or restarted or userspace has
+	 * given up on recovery
+	 */
+	wait_event_interruptible(conn-&gt;ehwait,
+				 sc-&gt;SCp.phase != session-&gt;age ||
+				 session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+				 conn-&gt;tmabort_state != TMABORT_INITIAL ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+	del_timer_sync(&amp;conn-&gt;tmabort_timer);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	return 0;
+}
+
+/*
+ * xmit mutex and session lock must be held
+ */
+#define iscsi_remove_task(tasktype)					\
+static struct iscsi_##tasktype *					\
+iscsi_remove_##tasktype(struct kfifo *fifo, uint32_t itt)		\
+{									\
+	int i, nr_tasks = __kfifo_len(fifo) / sizeof(void*);		\
+	struct iscsi_##tasktype *task;					\
+									\
+	debug_scsi(&quot;searching %d tasks\n&quot;, nr_tasks);			\
+									\
+	for (i = 0; i &lt; nr_tasks; i++) {				\
+		__kfifo_get(fifo, (void*)&amp;task, sizeof(void*));		\
+		debug_scsi(&quot;check task %u\n&quot;, task-&gt;itt);		\
+									\
+		if (task-&gt;itt == itt) {					\
+			debug_scsi(&quot;matched task\n&quot;);			\
+			break;						\
+		}							\
+									\
+		__kfifo_put(fifo, (void*)&amp;task, sizeof(void*));		\
+	}								\
+	return NULL;							\
+}
+
+iscsi_remove_task(mgmt_task);
+iscsi_remove_task(cmd_task);
+
+static int iscsi_ctask_mtask_cleanup(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+
+	if (!ctask-&gt;mtask)
+		return -EINVAL;
+
+	if (!iscsi_remove_mgmt_task(conn-&gt;immqueue, ctask-&gt;mtask-&gt;itt))
+		list_del(&amp;ctask-&gt;mtask-&gt;running);
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;ctask-&gt;mtask,
+		    sizeof(void*));
+	ctask-&gt;mtask = NULL;
+	return 0;
+}
+
+/*
+ * session lock and xmitmutex must be held
+ */
+static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			 int err)
+{
+	struct scsi_cmnd *sc;
+
+	conn-&gt;session-&gt;tt-&gt;cleanup_cmd_task(conn, ctask);
+	iscsi_ctask_mtask_cleanup(ctask);
+
+	sc = ctask-&gt;sc;
+	if (!sc)
+		return;
+	sc-&gt;result = err;
+	sc-&gt;resid = sc-&gt;request_bufflen;
+	iscsi_complete_command(conn-&gt;session, ctask);
+}
+
+int iscsi_eh_abort(struct scsi_cmnd *sc)
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd_task *pending_ctask;
+	int rc;
+
+	conn-&gt;eh_abort_cnt++;
+	debug_scsi(&quot;aborting [sc %p itt 0x%x]\n&quot;, sc, ctask-&gt;itt);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * If we are not logged in or we have started a new session
+	 * then let the host reset code handle this
+	 */
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+	    sc-&gt;SCp.phase != session-&gt;age)
+		goto failed;
+
+	/* ctask completed before time out */
+	if (!ctask-&gt;sc)
+		goto success;
+
+	/* what should we do here ? */
+	if (conn-&gt;ctask == ctask) {
+		printk(KERN_INFO &quot;iscsi: sc %p itt 0x%x partially sent. Failing &quot;
+		       &quot;abort\n&quot;, sc, ctask-&gt;itt);
+		goto failed;
+	}
+
+	/* check for the easy pending cmd abort */
+	pending_ctask = iscsi_remove_cmd_task(conn-&gt;xmitqueue, ctask-&gt;itt);
+	if (pending_ctask) {
+		/* iscsi_tcp queues write transfers on the xmitqueue */
+		if (list_empty(&amp;pending_ctask-&gt;running)) {
+			debug_scsi(&quot;found pending task\n&quot;);
+			goto success;
+		} else 
+			__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;pending_ctask,
+				    sizeof(void*));
+	}
+
+	conn-&gt;tmabort_state = TMABORT_INITIAL;
+
+	spin_unlock_bh(&amp;session-&gt;lock);
+	rc = iscsi_exec_abort_task(sc, ctask);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	iscsi_ctask_mtask_cleanup(ctask);
+	if (rc || sc-&gt;SCp.phase != session-&gt;age ||
+	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
+		goto failed;
+
+	/* ctask completed before tmf abort response */
+	if (!ctask-&gt;sc) {
+		debug_scsi(&quot;sc completed while abort in progress\n&quot;);
+		goto success;
+	}
+
+	if (conn-&gt;tmabort_state != TMABORT_SUCCESS) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		spin_lock_bh(&amp;session-&gt;lock);
+		goto failed;
+	}
+
+success:
+	debug_scsi(&quot;abort success [sc %lx itt 0x%x]\n&quot;, (long)sc, ctask-&gt;itt);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * clean up task if aborted. we have the xmitmutex so grab
+	 * the recv lock as a writer
+	 */
+	write_lock_bh(conn-&gt;recv_lock);
+	spin_lock(&amp;session-&gt;lock);
+	fail_command(conn, ctask, DID_ABORT &lt;&lt; 16);
+	spin_unlock(&amp;session-&gt;lock);
+	write_unlock_bh(conn-&gt;recv_lock);
+
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+	return SUCCESS;	
+
+failed:
+	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	debug_scsi(&quot;abort failed [sc %lx itt 0x%x]\n&quot;, (long)sc, ctask-&gt;itt);
+	return FAILED;
+}
+EXPORT_SYMBOL_GPL(iscsi_eh_abort);
+
+int
+iscsi_pool_init(struct iscsi_queue *q, int max, void ***items, int item_size)
+{
+	int i;
+
+	*items = kmalloc(max * sizeof(void*), GFP_KERNEL);
+	if (*items == NULL)
+		return -ENOMEM;
+
+	q-&gt;max = max;
+	q-&gt;pool = kmalloc(max * sizeof(void*), GFP_KERNEL);
+	if (q-&gt;pool == NULL) {
+		kfree(*items);
+		return -ENOMEM;
+	}
+
+	q-&gt;queue = kfifo_init((void*)q-&gt;pool, max * sizeof(void*),
+			      GFP_KERNEL, NULL);
+	if (q-&gt;queue == ERR_PTR(-ENOMEM)) {
+		kfree(q-&gt;pool);
+		kfree(*items);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i &lt; max; i++) {
+		q-&gt;pool[i] = kmalloc(item_size, GFP_KERNEL);
+		if (q-&gt;pool[i] == NULL) {
+			int j;
+
+			for (j = 0; j &lt; i; j++)
+				kfree(q-&gt;pool[j]);
+
+			kfifo_free(q-&gt;queue);
+			kfree(q-&gt;pool);
+			kfree(*items);
+			return -ENOMEM;
+		}
+		memset(q-&gt;pool[i], 0, item_size);
+		(*items)[i] = q-&gt;pool[i];
+		__kfifo_put(q-&gt;queue, (void*)&amp;q-&gt;pool[i], sizeof(void*));
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_pool_init);
+
+void iscsi_pool_free(struct iscsi_queue *q, void **items)
+{
+	int i;
+
+	for (i = 0; i &lt; q-&gt;max; i++)
+		kfree(items[i]);
+	kfree(q-&gt;pool);
+	kfree(items);
+}
+EXPORT_SYMBOL_GPL(iscsi_pool_free);
+
+/*
+ * iSCSI Session's hostdata organization:
+ *
+ *    *------------------* &lt;== hostdata_session(host-&gt;hostdata)
+ *    | ptr to class sess|
+ *    |------------------| &lt;== iscsi_hostdata(host-&gt;hostdata)
+ *    | iscsi_session    |
+ *    *------------------*
+ */
+
+#define hostdata_privsize(_sz)	(sizeof(unsigned long) + _sz + \
+				 _sz % sizeof(unsigned long))
+
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_session_setup - create iscsi cls session and host and session
+ * @scsit: scsi transport template
+ * @iscsit: iscsi transport template
+ * @initial_cmdsn: initial CmdSN
+ * @hostno: host no allocated
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+struct iscsi_cls_session *
+iscsi_session_setup(struct iscsi_transport *iscsit,
+		    struct scsi_transport_template *scsit,
+		    int cmd_task_size, int mgmt_task_size,
+		    uint32_t initial_cmdsn, uint32_t *hostno)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_session *session;
+	struct iscsi_cls_session *cls_session;
+	int cmd_i;
+
+	shost = scsi_host_alloc(iscsit-&gt;host_template,
+				hostdata_privsize(sizeof(*session)));
+	if (!shost)
+		return NULL;
+
+	shost-&gt;max_id = 1;
+	shost-&gt;max_channel = 0;
+	shost-&gt;max_lun = iscsit-&gt;max_lun;
+	shost-&gt;max_cmd_len = iscsit-&gt;max_cmd_len;
+	shost-&gt;transportt = scsit;
+	shost-&gt;transportt-&gt;create_work_queue = 1;
+	*hostno = shost-&gt;host_no;
+
+	session = iscsi_hostdata(shost-&gt;hostdata);
+	memset(session, 0, sizeof(struct iscsi_session));
+	session-&gt;host = shost;
+	session-&gt;state = ISCSI_STATE_FREE;
+	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
+	session-&gt;cmds_max = ISCSI_XMIT_CMDS_MAX;
+	session-&gt;cmdsn = initial_cmdsn;
+	session-&gt;exp_cmdsn = initial_cmdsn + 1;
+	session-&gt;max_cmdsn = initial_cmdsn + 1;
+	session-&gt;max_r2t = 1;
+	session-&gt;tt = iscsit;
+
+	/* initialize SCSI PDU commands pool */
+	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
+			    (void***)&amp;session-&gt;cmds,
+			    cmd_task_size + sizeof(struct iscsi_cmd_task)))
+		goto cmdpool_alloc_fail;
+
+	/* pre-format cmds pool with ITT */
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+
+		if (cmd_task_size)
+			ctask-&gt;dd_data = &amp;ctask[1];
+		ctask-&gt;itt = cmd_i;
+	}
+
+	spin_lock_init(&amp;session-&gt;lock);
+	INIT_LIST_HEAD(&amp;session-&gt;connections);
+
+	/* initialize immediate command pool */
+	if (iscsi_pool_init(&amp;session-&gt;mgmtpool, session-&gt;mgmtpool_max,
+			   (void***)&amp;session-&gt;mgmt_cmds,
+			   mgmt_task_size + sizeof(struct iscsi_mgmt_task)))
+		goto mgmtpool_alloc_fail;
+
+
+	/* pre-format immediate cmds pool with ITT */
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
+		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
+
+		if (mgmt_task_size)
+			mtask-&gt;dd_data = &amp;mtask[1];
+		mtask-&gt;itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
+		mtask-&gt;data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH,
+				     GFP_KERNEL);
+		if (!mtask-&gt;data) {
+			int j;
+
+			for (j = 0; j &lt; cmd_i; j++)
+				kfree(session-&gt;mgmt_cmds[j]-&gt;data);
+			goto immdata_alloc_fail;
+		}
+	}
+
+	if (scsi_add_host(shost, NULL))
+		goto add_host_fail;
+
+	cls_session = iscsi_create_session(shost, iscsit, 0);
+	if (!cls_session)
+		goto cls_session_fail;
+	*(unsigned long*)shost-&gt;hostdata = (unsigned long)cls_session;
+
+	return cls_session;
+
+cls_session_fail:
+	scsi_remove_host(shost);
+add_host_fail:
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
+		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
+immdata_alloc_fail:
+	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
+mgmtpool_alloc_fail:
+	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
+cmdpool_alloc_fail:
+	scsi_host_put(shost);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_session_setup);
+
+/**
+ * iscsi_session_teardown - destroy session, host, and cls_session
+ * shost: scsi host
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	int cmd_i;
+
+	scsi_remove_host(shost);
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
+		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
+
+	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
+	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
+
+	iscsi_destroy_session(cls_session);
+	scsi_host_put(shost);
+}
+EXPORT_SYMBOL_GPL(iscsi_session_teardown);
+
+/**
+ * iscsi_conn_setup - create iscsi_cls_conn and iscsi_conn
+ * @cls_session: iscsi_cls_session
+ * @conn_idx: cid
+ **/
+struct iscsi_cls_conn *
+iscsi_conn_setup(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *conn;
+	struct iscsi_cls_conn *cls_conn;
+
+	cls_conn = iscsi_create_conn(cls_session, conn_idx);
+	if (!cls_conn)
+		return NULL;
+	conn = cls_conn-&gt;dd_data;
+	memset(conn, 0, sizeof(*conn));
+
+	conn-&gt;session = session;
+	conn-&gt;cls_conn = cls_conn;
+	conn-&gt;c_stage = ISCSI_CONN_INITIAL_STAGE;
+	conn-&gt;id = conn_idx;
+	conn-&gt;exp_statsn = 0;
+	conn-&gt;tmabort_state = TMABORT_INITIAL;
+	INIT_LIST_HEAD(&amp;conn-&gt;run_list);
+	INIT_LIST_HEAD(&amp;conn-&gt;mgmt_run_list);
+
+	/* initialize general xmit PDU commands queue */
+	conn-&gt;xmitqueue = kfifo_alloc(session-&gt;cmds_max * sizeof(void*),
+					GFP_KERNEL, NULL);
+	if (conn-&gt;xmitqueue == ERR_PTR(-ENOMEM))
+		goto xmitqueue_alloc_fail;
+
+	/* initialize general immediate &amp; non-immediate PDU commands queue */
+	conn-&gt;immqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
+			                GFP_KERNEL, NULL);
+	if (conn-&gt;immqueue == ERR_PTR(-ENOMEM))
+		goto immqueue_alloc_fail;
+
+	conn-&gt;mgmtqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
+			                GFP_KERNEL, NULL);
+	if (conn-&gt;mgmtqueue == ERR_PTR(-ENOMEM))
+		goto mgmtqueue_alloc_fail;
+
+	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker, conn);
+
+	/* allocate login_mtask used for the login/text sequences */
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (!__kfifo_get(session-&gt;mgmtpool.queue,
+                         (void*)&amp;conn-&gt;login_mtask,
+			 sizeof(void*))) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		goto login_mtask_alloc_fail;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	init_timer(&amp;conn-&gt;tmabort_timer);
+	mutex_init(&amp;conn-&gt;xmitmutex);
+	init_waitqueue_head(&amp;conn-&gt;ehwait);
+
+	return cls_conn;
+
+login_mtask_alloc_fail:
+	kfifo_free(conn-&gt;mgmtqueue);
+mgmtqueue_alloc_fail:
+	kfifo_free(conn-&gt;immqueue);
+immqueue_alloc_fail:
+	kfifo_free(conn-&gt;xmitqueue);
+xmitqueue_alloc_fail:
+	iscsi_destroy_conn(cls_conn);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_setup);
+
+/**
+ * iscsi_conn_teardown - teardown iscsi connection
+ * cls_conn: iscsi class connection
+ *
+ * TODO: we may need to make this into a two step process
+ * like scsi-mls remove + put host
+ */
+void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+	unsigned long flags;
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	if (conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE) {
+		if (session-&gt;tt-&gt;suspend_conn_recv)
+			session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+		session-&gt;tt-&gt;terminate_conn(conn);
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_CLEANUP_WAIT;
+	if (session-&gt;leadconn == conn) {
+		/*
+		 * leading connection? then give up on recovery.
+		 */
+		session-&gt;state = ISCSI_STATE_TERMINATE;
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	/*
+	 * Block until all in-progress commands for this connection
+	 * time out or fail.
+	 */
+	for (;;) {
+		spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);
+		if (!session-&gt;host-&gt;host_busy) { /* OK for ERL == 0 */
+			spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
+		msleep_interruptible(500);
+		printk(KERN_INFO &quot;iscsi: scsi conn_destroy(): host_busy %d host_failed %d\n&quot;,
+			session-&gt;host-&gt;host_busy, session-&gt;host-&gt;host_failed);
+		/*
+		 * force eh_abort() to unblock
+		 */
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
+		    sizeof(void*));
+	list_del(&amp;conn-&gt;item);
+	if (list_empty(&amp;session-&gt;connections))
+		session-&gt;leadconn = NULL;
+	if (session-&gt;leadconn &amp;&amp; session-&gt;leadconn == conn)
+		session-&gt;leadconn = container_of(session-&gt;connections.next,
+			struct iscsi_conn, item);
+
+	if (session-&gt;leadconn == NULL)
+		/* no connections exits.. reset sequencing */
+		session-&gt;cmdsn = session-&gt;max_cmdsn = session-&gt;exp_cmdsn = 1;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	kfifo_free(conn-&gt;xmitqueue);
+	kfifo_free(conn-&gt;immqueue);
+	kfifo_free(conn-&gt;mgmtqueue);
+
+	iscsi_destroy_conn(cls_conn);
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_teardown);
+
+int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+
+	if (session == NULL) {
+		printk(KERN_ERR &quot;iscsi: can't start unbound connection\n&quot;);
+		return -EPERM;
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_STARTED;
+	session-&gt;state = ISCSI_STATE_LOGGED_IN;
+
+	switch(conn-&gt;stop_stage) {
+	case STOP_CONN_RECOVER:
+		/*
+		 * unblock eh_abort() if it is blocked. re-try all
+		 * commands after successful recovery
+		 */
+		session-&gt;conn_cnt++;
+		conn-&gt;stop_stage = 0;
+		conn-&gt;tmabort_state = TMABORT_INITIAL;
+		session-&gt;age++;
+		session-&gt;recovery_failed = 0;
+		spin_unlock_bh(&amp;session-&gt;lock);
+
+		iscsi_unblock_session(session_to_cls(session));
+		wake_up(&amp;conn-&gt;ehwait);
+		return 0;
+	case STOP_CONN_TERM:
+		session-&gt;conn_cnt++;
+		conn-&gt;stop_stage = 0;
+		break;
+	case STOP_CONN_SUSPEND:
+		conn-&gt;stop_stage = 0;
+		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_start);
+
+static void
+flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
+{
+	struct iscsi_mgmt_task *mtask, *tmp;
+
+	/* handle pending */
+	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*)) ||
+	       __kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*))) {
+		if (mtask == conn-&gt;login_mtask)
+			continue;
+		debug_scsi(&quot;flushing pending mgmt task itt 0x%x\n&quot;, mtask-&gt;itt);
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
+			    sizeof(void*));
+	}
+
+	/* handle running */
+	list_for_each_entry_safe(mtask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
+		debug_scsi(&quot;flushing running mgmt task itt 0x%x\n&quot;, mtask-&gt;itt);
+		list_del(&amp;mtask-&gt;running);
+
+		if (mtask == conn-&gt;login_mtask)
+			continue;
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
+			   sizeof(void*));
+	}
+
+	conn-&gt;mtask = NULL;
+}
+
+/* Fail commands. Mutex and session lock held and recv side suspended */
+static void fail_all_commands(struct iscsi_conn *conn)
+{
+	struct iscsi_cmd_task *ctask, *tmp;
+
+	/* flush pending */	
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*))) {
+		debug_scsi(&quot;failing pending sc %p itt 0x%x\n&quot;, ctask-&gt;sc,
+			   ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	/* fail all other running */
+	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;run_list, running) {
+		debug_scsi(&quot;failing in progress sc %p itt 0x%x\n&quot;,
+			   ctask-&gt;sc, ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	conn-&gt;ctask = NULL;
+}
+
+void iscsi_start_session_recovery(struct iscsi_session *session,
+				  struct iscsi_conn *conn, int flag)
+{
+	int old_stop_stage;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (conn-&gt;stop_stage == STOP_CONN_TERM) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return;
+	}
+
+	/*
+	 * When this is called for the in_login state, we only want to clean
+	 * up the login task and connection.
+	 */
+	if (conn-&gt;stop_stage != STOP_CONN_RECOVER)
+		session-&gt;conn_cnt--;
+
+	old_stop_stage = conn-&gt;stop_stage;
+	conn-&gt;stop_stage = flag;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	if (session-&gt;tt-&gt;suspend_conn_recv)
+		session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+
+	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
+		session-&gt;state = ISCSI_STATE_FAILED;
+
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	session-&gt;tt-&gt;terminate_conn(conn);
+	/*
+	 * flush queues.
+	 */
+	spin_lock_bh(&amp;session-&gt;lock);
+	fail_all_commands(conn);
+	flush_control_queues(session, conn);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * for connection level recovery we should not calculate
+	 * header digest. conn-&gt;hdr_size used for optimization
+	 * in hdr_extract() and will be re-negotiated at
+	 * set_param() time.
+	 */
+	if (flag == STOP_CONN_RECOVER) {
+		conn-&gt;hdrdgst_en = 0;
+		conn-&gt;datadgst_en = 0;
+
+		/*
+		 * if this is called from the eh and and from userspace
+		 * then we only need to block once.
+		 */
+		if (session-&gt;state == ISCSI_STATE_FAILED &amp;&amp;
+		    old_stop_stage != STOP_CONN_RECOVER)
+			iscsi_block_session(session_to_cls(session));
+	}
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+}
+EXPORT_SYMBOL_GPL(iscsi_start_session_recovery);
+
+void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+
+	switch (flag) {
+	case STOP_CONN_RECOVER:
+	case STOP_CONN_TERM:
+		iscsi_start_session_recovery(session, conn, flag);
+		break;
+	case STOP_CONN_SUSPEND:
+		if (session-&gt;tt-&gt;suspend_conn_recv)
+			session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		spin_lock_bh(&amp;session-&gt;lock);
+
+		conn-&gt;stop_stage = flag;
+		conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+
+		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+		break;
+	default:
+		printk(KERN_ERR &quot;iscsi: invalid stop flag %d\n&quot;, flag);
+	}
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_stop);
+
+int iscsi_conn_bind(struct iscsi_cls_session *cls_session,
+		    struct iscsi_cls_conn *cls_conn, int is_leading)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *tmp = ERR_PTR(-EEXIST), *conn = cls_conn-&gt;dd_data;
+
+	/* lookup for existing connection */
+	spin_lock_bh(&amp;session-&gt;lock);
+	list_for_each_entry(tmp, &amp;session-&gt;connections, item) {
+		if (tmp == conn) {
+			if (conn-&gt;c_stage != ISCSI_CONN_STOPPED ||
+			    conn-&gt;stop_stage == STOP_CONN_TERM) {
+				printk(KERN_ERR &quot;iscsi: can't bind &quot;
+				       &quot;non-stopped connection (%d:%d)\n&quot;,
+				       conn-&gt;c_stage, conn-&gt;stop_stage);
+				spin_unlock_bh(&amp;session-&gt;lock);
+				return -EIO;
+			}
+			break;
+		}
+	}
+	if (tmp != conn) {
+		/* bind new iSCSI connection to session */
+		conn-&gt;session = session;
+		list_add(&amp;conn-&gt;item, &amp;session-&gt;connections);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	if (is_leading)
+		session-&gt;leadconn = conn;
+
+	/*
+	 * Unblock xmitworker(), Login Phase will pass through.
+	 */
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_bind);
+
+MODULE_AUTHOR(&quot;Mike Christie&quot;);
+MODULE_DESCRIPTION(&quot;iSCSI library functions&quot;);
+MODULE_LICENSE(&quot;GPL&quot;);

Added: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,286 @@
+/*
+ * iSCSI lib definitions
+ *
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004 - 2006 Mike Christie
+ * Copyright (C) 2004 - 2005 Dmitry Yusupov
+ * Copyright (C) 2004 - 2005 Alex Aizman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef LIBISCSI_H
+#define LIBISCSI_H
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;scsi/iscsi_proto.h&gt;
+#include &lt;iscsi_if.h&gt;
+
+struct scsi_transport_template;
+struct scsi_device;
+struct Scsi_Host;
+struct scsi_cmnd;
+struct socket;
+struct iscsi_transport;
+struct iscsi_cls_session;
+struct iscsi_cls_conn;
+struct iscsi_session;
+struct iscsi_nopin;
+
+/* #define DEBUG_SCSI */
+#ifdef DEBUG_SCSI
+#define debug_scsi(fmt...) printk(KERN_INFO &quot;iscsi: &quot; fmt)
+#else
+#define debug_scsi(fmt...)
+#endif
+
+#define ISCSI_XMIT_CMDS_MAX	128	/* must be power of 2 */
+#define ISCSI_MGMT_CMDS_MAX	32	/* must be power of 2 */
+#define ISCSI_CONN_MAX			1
+
+#define ISCSI_MGMT_ITT_OFFSET	0xa00
+
+#define ISCSI_DEF_CMD_PER_LUN		32
+#define ISCSI_MAX_CMD_PER_LUN		128
+
+/* Task Mgmt states */
+#define TMABORT_INITIAL			0x0
+#define TMABORT_SUCCESS			0x1
+#define TMABORT_FAILED			0x2
+#define TMABORT_TIMEDOUT		0x3
+
+/* Connection suspend &quot;bit&quot; */
+#define ISCSI_SUSPEND_BIT		1
+
+#define ISCSI_ITT_MASK			(0xfff)
+#define ISCSI_CID_SHIFT			12
+#define ISCSI_CID_MASK			(0xffff &lt;&lt; ISCSI_CID_SHIFT)
+#define ISCSI_AGE_SHIFT			28
+#define ISCSI_AGE_MASK			(0xf &lt;&lt; ISCSI_AGE_SHIFT)
+
+struct iscsi_mgmt_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_hdr	*hdr; 
+	char			*data;		/* mgmt payload */
+	int			data_count;	/* counts data to be sent */
+	uint32_t		itt;		/* this ITT */
+	void			*dd_data;	/* driver/transport data */
+	struct list_head	running;
+};
+
+struct iscsi_cmd_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_cmd	*hdr;
+	int			itt;		/* this ITT */
+	int			datasn;		/* DataSN */
+
+	uint32_t		unsol_datasn;
+	int			imm_count;	/* imm-data (bytes)   */
+	int			unsol_count;	/* unsolicited (bytes)*/
+	int			data_count;	/* remaining Data-Out */
+	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
+	int			total_length;
+	struct iscsi_conn	*conn;		/* used connection    */
+	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
+
+	struct list_head	running;	/* running cmd list */
+	void			*dd_data;	/* driver/transport data */
+};
+
+struct iscsi_conn {
+	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
+	void			*dd_data;	/* iscsi_transport data */
+	struct iscsi_session	*session;	/* parent session */
+	/*
+	 * LLDs should set this lock. It protects the transport recv
+	 * code
+	 */
+	rwlock_t		*recv_lock;
+	/*
+	 * conn_stop() flag: stop to recover, stop to terminate
+	 */
+        int			stop_stage;
+
+	/* iSCSI connection-wide sequencing */
+	uint32_t		exp_statsn;
+
+	/* control data */
+	int			id;		/* CID */
+	struct list_head	item;		/* maintains list of conns */
+	int			c_stage;	/* connection state */
+	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
+	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
+	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
+
+	/* xmit */
+	struct kfifo		*immqueue;	/* immediate xmit queue */
+	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
+	struct list_head	mgmt_run_list;	/* list of control tasks */
+	struct kfifo		*xmitqueue;	/* data-path cmd queue */
+	struct list_head	run_list;	/* list of cmds in progress */
+	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
+	/*
+	 * serializes connection xmit, access to kfifos:
+	 * xmitqueue, immqueue, mgmtqueue
+	 */
+	struct mutex		xmitmutex;
+
+	unsigned long		suspend_tx;	/* suspend Tx */
+	unsigned long		suspend_rx;	/* suspend Rx */
+
+	/* abort */
+	wait_queue_head_t	ehwait;		/* used in eh_abort() */
+	struct iscsi_tm		tmhdr;
+	struct timer_list	tmabort_timer;
+	int			tmabort_state;	/* see TMABORT_INITIAL, etc.*/
+
+	/* negotiated params */
+	int			max_recv_dlength; /* initiator_max_recv_dsl*/
+	int			max_xmit_dlength; /* target_max_recv_dsl */
+	int			hdrdgst_en;
+	int			datadgst_en;
+
+	/* MIB-statistics */
+	uint64_t		txdata_octets;
+	uint64_t		rxdata_octets;
+	uint32_t		scsicmd_pdus_cnt;
+	uint32_t		dataout_pdus_cnt;
+	uint32_t		scsirsp_pdus_cnt;
+	uint32_t		datain_pdus_cnt;
+	uint32_t		r2t_pdus_cnt;
+	uint32_t		tmfcmd_pdus_cnt;
+	int32_t			tmfrsp_pdus_cnt;
+
+	/* custom statistics */
+	uint32_t		eh_abort_cnt;
+};
+
+struct iscsi_queue {
+	struct kfifo		*queue;		/* FIFO Queue */
+	void			**pool;		/* Pool of elements */
+	int			max;		/* Max number of elements */
+};
+
+struct iscsi_session {
+	/* iSCSI session-wide sequencing */
+	uint32_t		cmdsn;
+	uint32_t		exp_cmdsn;
+	uint32_t		max_cmdsn;
+
+	/* configuration */
+	int			initial_r2t_en;
+	int			max_r2t;
+	int			imm_data_en;
+	int			first_burst;
+	int			max_burst;
+	int			time2wait;
+	int			time2retain;
+	int			pdu_inorder_en;
+	int			dataseq_inorder_en;
+	int			erl;
+	int			ifmarker_en;
+	int			ofmarker_en;
+
+	/* control data */
+	struct iscsi_transport	*tt;
+	struct Scsi_Host	*host;
+	struct iscsi_conn	*leadconn;	/* leading connection */
+	spinlock_t		lock;		/* protects session state, *
+						 * sequence numbers,       *
+						 * session resources:      *
+						 * - cmdpool,		   *
+						 * - mgmtpool,		   *
+						 * - r2tpool		   */
+	int			state;		/* session state           */
+	int			recovery_failed;
+	struct list_head	item;
+	int			conn_cnt;
+	int			age;		/* counts session re-opens */
+
+	struct list_head	connections;	/* list of connections */
+	int			cmds_max;	/* size of cmds array */
+	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
+	struct iscsi_queue	cmdpool;	/* PDU's pool */
+	int			mgmtpool_max;	/* size of mgmt array */
+	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
+	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
+};
+
+/*
+ * scsi host template
+ */
+extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
+extern int iscsi_eh_abort(struct scsi_cmnd *sc);
+extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_queuecommand(struct scsi_cmnd *sc,
+			      void (*done)(struct scsi_cmnd *));
+
+/*
+ * session management
+ */
+extern struct iscsi_cls_session *
+iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
+		    int, int, uint32_t, uint32_t *);
+extern void iscsi_session_teardown(struct iscsi_cls_session *);
+extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
+extern void iscsi_start_session_recovery(struct iscsi_session *,
+					struct iscsi_conn *, int);
+extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
+
+#define session_to_cls(_sess) \
+	hostdata_session(_sess-&gt;host-&gt;hostdata)
+
+/*
+ * connection management
+ */
+extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session *,
+					       uint32_t);
+extern void iscsi_conn_teardown(struct iscsi_cls_conn *);
+extern int iscsi_conn_start(struct iscsi_cls_conn *);
+extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
+extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
+			   int);
+extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+
+/*
+ * pdu and task processing
+ */
+extern int iscsi_check_assign_cmdsn(struct iscsi_session *,
+				    struct iscsi_nopin *);
+extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
+					struct iscsi_data *hdr,
+					int transport_data_cnt);
+extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
+				char *, uint32_t);
+extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+			      char *, int);
+extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+				char *, int);
+extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
+			    uint32_t *);
+
+/*
+ * generic helpers
+ */
+extern void iscsi_pool_free(struct iscsi_queue *, void **);
+extern int iscsi_pool_init(struct iscsi_queue *, int, void ***, int);
+
+#endif

Added: branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.c	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,1592 @@
+/*
+ * iSCSI transport class definitions
+ *
+ * Copyright (C) IBM Corporation, 2004
+ * Copyright (C) Mike Christie, 2004 - 2005
+ * Copyright (C) Dmitry Yusupov, 2004 - 2005
+ * Copyright (C) Alex Aizman, 2004 - 2005
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include &lt;linux/module.h&gt;
+#include &lt;linux/mempool.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;net/tcp.h&gt;
+#include &lt;scsi/scsi.h&gt;
+#include &lt;scsi/scsi_host.h&gt;
+#include &lt;scsi/scsi_device.h&gt;
+#include &lt;scsi/scsi_transport.h&gt;
+#include &quot;scsi_transport_iscsi.h&quot;
+#include &quot;iscsi_if.h&quot;
+
+#define ISCSI_SESSION_ATTRS 11
+#define ISCSI_CONN_ATTRS 11
+#define ISCSI_HOST_ATTRS 0
+
+struct iscsi_internal {
+	struct scsi_transport_template t;
+	struct iscsi_transport *iscsi_transport;
+	struct list_head list;
+	struct class_device cdev;
+
+	struct class_device_attribute *host_attrs[ISCSI_HOST_ATTRS + 1];
+	struct transport_container conn_cont;
+	struct class_device_attribute *conn_attrs[ISCSI_CONN_ATTRS + 1];
+	struct transport_container session_cont;
+	struct class_device_attribute *session_attrs[ISCSI_SESSION_ATTRS + 1];
+};
+
+static int iscsi_session_nr;	/* sysfs session id for next new session */
+
+/*
+ * list of registered transports and lock that must
+ * be held while accessing list. The iscsi_transport_lock must
+ * be acquired after the rx_queue_mutex.
+ */
+static LIST_HEAD(iscsi_transports);
+static DEFINE_SPINLOCK(iscsi_transport_lock);
+
+#define to_iscsi_internal(tmpl) \
+	container_of(tmpl, struct iscsi_internal, t)
+
+#define cdev_to_iscsi_internal(_cdev) \
+	container_of(_cdev, struct iscsi_internal, cdev)
+
+static void iscsi_transport_release(struct class_device *cdev)
+{
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);
+	kfree(priv);
+}
+
+/*
+ * iscsi_transport_class represents the iscsi_transports that are
+ * registered.
+ */
+static struct class iscsi_transport_class = {
+	.name = &quot;iscsi_transport&quot;,
+	.release = iscsi_transport_release,
+};
+
+static ssize_t
+show_transport_handle(struct class_device *cdev, char *buf)
+{
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);
+	return sprintf(buf, &quot;%llu\n&quot;, (unsigned long long)iscsi_handle(priv-&gt;iscsi_transport));
+}
+static CLASS_DEVICE_ATTR(handle, S_IRUGO, show_transport_handle, NULL);
+
+#define show_transport_attr(name, format)				\
+static ssize_t								\
+show_transport_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct iscsi_internal *priv = cdev_to_iscsi_internal(cdev);	\
+	return sprintf(buf, format&quot;\n&quot;, priv-&gt;iscsi_transport-&gt;name);	\
+}									\
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_transport_##name, NULL);
+
+show_transport_attr(caps, &quot;0x%x&quot;);
+show_transport_attr(max_lun, &quot;%d&quot;);
+show_transport_attr(max_conn, &quot;%d&quot;);
+show_transport_attr(max_cmd_len, &quot;%d&quot;);
+
+static struct attribute *iscsi_transport_attrs[] = {
+	&amp;class_device_attr_handle.attr,
+	&amp;class_device_attr_caps.attr,
+	&amp;class_device_attr_max_lun.attr,
+	&amp;class_device_attr_max_conn.attr,
+	&amp;class_device_attr_max_cmd_len.attr,
+	NULL,
+};
+
+static struct attribute_group iscsi_transport_group = {
+	.attrs = iscsi_transport_attrs,
+};
+
+static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
+			    struct class_device *cdev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+
+	memset(ihost, 0, sizeof(*ihost));
+	INIT_LIST_HEAD(&amp;ihost-&gt;sessions);
+	mutex_init(&amp;ihost-&gt;mutex);
+	return 0;
+}
+
+static DECLARE_TRANSPORT_CLASS(iscsi_host_class,
+			       &quot;iscsi_host&quot;,
+			       iscsi_setup_host,
+			       NULL,
+			       NULL);
+
+static DECLARE_TRANSPORT_CLASS(iscsi_session_class,
+			       &quot;iscsi_session&quot;,
+			       NULL,
+			       NULL,
+			       NULL);
+
+static DECLARE_TRANSPORT_CLASS(iscsi_connection_class,
+			       &quot;iscsi_connection&quot;,
+			       NULL,
+			       NULL,
+			       NULL);
+
+static struct sock *nls;
+static int daemon_pid;
+static DEFINE_MUTEX(rx_queue_mutex);
+
+struct mempool_zone {
+	mempool_t *pool;
+	atomic_t allocated;
+	int size;
+	int hiwat;
+	struct list_head freequeue;
+	spinlock_t freelock;
+};
+
+static struct mempool_zone *z_reply;
+
+/*
+ * Z_MAX_* - actual mempool size allocated at the mempool_zone_init() time
+ * Z_HIWAT_* - zone's high watermark when if_error bit will be set to -ENOMEM
+ *             so daemon will notice OOM on NETLINK tranposrt level and will
+ *             be able to predict or change operational behavior
+ */
+#define Z_MAX_REPLY	8
+#define Z_HIWAT_REPLY	6
+#define Z_MAX_PDU	8
+#define Z_HIWAT_PDU	6
+#define Z_MAX_ERROR	16
+#define Z_HIWAT_ERROR	12
+
+static LIST_HEAD(sesslist);
+static DEFINE_SPINLOCK(sesslock);
+static LIST_HEAD(connlist);
+static DEFINE_SPINLOCK(connlock);
+
+static uint32_t iscsi_conn_get_sid(struct iscsi_cls_conn *conn)
+{
+	struct iscsi_cls_session *sess = iscsi_dev_to_session(conn-&gt;dev.parent);
+	return sess-&gt;sid;
+}
+
+/*
+ * Returns the matching session to a given sid
+ */
+static struct iscsi_cls_session *iscsi_session_lookup(uint32_t sid)
+{
+	unsigned long flags;
+	struct iscsi_cls_session *sess;
+
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_for_each_entry(sess, &amp;sesslist, sess_list) {
+		if (sess-&gt;sid == sid) {
+			spin_unlock_irqrestore(&amp;sesslock, flags);
+			return sess;
+		}
+	}
+	spin_unlock_irqrestore(&amp;sesslock, flags);
+	return NULL;
+}
+
+/*
+ * Returns the matching connection to a given sid / cid tuple
+ */
+static struct iscsi_cls_conn *iscsi_conn_lookup(uint32_t sid, uint32_t cid)
+{
+	unsigned long flags;
+	struct iscsi_cls_conn *conn;
+
+	spin_lock_irqsave(&amp;connlock, flags);
+	list_for_each_entry(conn, &amp;connlist, conn_list) {
+		if ((conn-&gt;cid == cid) &amp;&amp; (iscsi_conn_get_sid(conn) == sid)) {
+			spin_unlock_irqrestore(&amp;connlock, flags);
+			return conn;
+		}
+	}
+	spin_unlock_irqrestore(&amp;connlock, flags);
+	return NULL;
+}
+
+/*
+ * The following functions can be used by LLDs that allocate
+ * their own scsi_hosts or by software iscsi LLDs
+ */
+static void iscsi_session_release(struct device *dev)
+{
+	struct iscsi_cls_session *session = iscsi_dev_to_session(dev);
+	struct iscsi_transport *transport = session-&gt;transport;
+	struct Scsi_Host *shost;
+
+	shost = iscsi_session_to_shost(session);
+	scsi_host_put(shost);
+	kfree(session-&gt;targetname);
+	kfree(session);
+	module_put(transport-&gt;owner);
+}
+
+static int iscsi_is_session_dev(const struct device *dev)
+{
+	return dev-&gt;release == iscsi_session_release;
+}
+
+static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
+			   uint id, uint lun)
+{
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+	struct iscsi_cls_session *session;
+
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_for_each_entry(session, &amp;ihost-&gt;sessions, host_list) {
+		if ((channel == SCAN_WILD_CARD ||
+		     channel == session-&gt;channel) &amp;&amp;
+		    (id == SCAN_WILD_CARD || id == session-&gt;target_id))
+			scsi_scan_target(&amp;session-&gt;dev, session-&gt;channel,
+					 session-&gt;target_id, lun, 1);
+	}
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
+	return 0;
+}
+
+static void session_recovery_timedout(void *data)
+{
+	struct iscsi_cls_session *session = data;
+
+	dev_printk(KERN_INFO, &amp;session-&gt;dev, &quot;iscsi: session recovery timed out &quot;
+		  &quot;after %d secs\n&quot;, session-&gt;recovery_tmo);
+
+	if (session-&gt;transport-&gt;session_recovery_timedout)
+		session-&gt;transport-&gt;session_recovery_timedout(session);
+
+	scsi_target_unblock(&amp;session-&gt;dev);
+}
+
+void iscsi_unblock_session(struct iscsi_cls_session *session)
+{
+	if (!cancel_delayed_work(&amp;session-&gt;recovery_work))
+		flush_scheduled_work();
+	scsi_target_unblock(&amp;session-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(iscsi_unblock_session);
+
+void iscsi_block_session(struct iscsi_cls_session *session)
+{
+	scsi_target_block(&amp;session-&gt;dev);
+	schedule_delayed_work(&amp;session-&gt;recovery_work,
+			     session-&gt;recovery_tmo * HZ);
+}
+EXPORT_SYMBOL_GPL(iscsi_block_session);
+
+/**
+ * iscsi_create_session - create iscsi class session
+ * @shost: scsi host
+ * @transport: iscsi transport
+ *
+ * This can be called from a LLD or iscsi_transport.
+ **/
+struct iscsi_cls_session *
+iscsi_create_session(struct Scsi_Host *shost,
+		     struct iscsi_transport *transport, int channel)
+{
+	struct iscsi_host *ihost;
+	struct iscsi_cls_session *session;
+	int err;
+
+	if (!try_module_get(transport-&gt;owner))
+		return NULL;
+
+	session = kzalloc(sizeof(*session) + transport-&gt;sessiondata_size,
+			  GFP_KERNEL);
+	if (!session)
+		goto module_put;
+	session-&gt;transport = transport;
+	session-&gt;recovery_tmo = 120;
+	INIT_WORK(&amp;session-&gt;recovery_work, session_recovery_timedout, session);
+	INIT_LIST_HEAD(&amp;session-&gt;host_list);
+	INIT_LIST_HEAD(&amp;session-&gt;sess_list);
+
+	if (transport-&gt;sessiondata_size)
+		session-&gt;dd_data = &amp;session[1];
+
+	/* this is released in the dev's release function */
+	scsi_host_get(shost);
+	ihost = shost-&gt;shost_data;
+
+	session-&gt;sid = iscsi_session_nr++;
+	session-&gt;channel = channel;
+	session-&gt;target_id = ihost-&gt;next_target_id++;
+
+	snprintf(session-&gt;dev.bus_id, BUS_ID_SIZE, &quot;session%u&quot;,
+		 session-&gt;sid);
+	session-&gt;dev.parent = &amp;shost-&gt;shost_gendev;
+	session-&gt;dev.release = iscsi_session_release;
+	err = device_register(&amp;session-&gt;dev);
+	if (err) {
+		dev_printk(KERN_ERR, &amp;session-&gt;dev, &quot;iscsi: could not &quot;
+			   &quot;register session's dev\n&quot;);
+		goto free_session;
+	}
+	transport_register_device(&amp;session-&gt;dev);
+
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_add(&amp;session-&gt;host_list, &amp;ihost-&gt;sessions);
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
+	return session;
+
+free_session:
+	kfree(session);
+module_put:
+	module_put(transport-&gt;owner);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_create_session);
+
+/**
+ * iscsi_destroy_session - destroy iscsi session
+ * @session: iscsi_session
+ *
+ * Can be called by a LLD or iscsi_transport. There must not be
+ * any running connections.
+ **/
+int iscsi_destroy_session(struct iscsi_cls_session *session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+
+	if (!cancel_delayed_work(&amp;session-&gt;recovery_work))
+		flush_scheduled_work();
+
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_del(&amp;session-&gt;host_list);
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
+	transport_unregister_device(&amp;session-&gt;dev);
+	device_unregister(&amp;session-&gt;dev);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_destroy_session);
+
+static void iscsi_conn_release(struct device *dev)
+{
+	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);
+	struct device *parent = conn-&gt;dev.parent;
+
+	kfree(conn-&gt;persistent_address);
+	kfree(conn);
+	put_device(parent);
+}
+
+static int iscsi_is_conn_dev(const struct device *dev)
+{
+	return dev-&gt;release == iscsi_conn_release;
+}
+
+/**
+ * iscsi_create_conn - create iscsi class connection
+ * @session: iscsi cls session
+ * @cid: connection id
+ *
+ * This can be called from a LLD or iscsi_transport. The connection
+ * is child of the session so cid must be unique for all connections
+ * on the session.
+ *
+ * Since we do not support MCS, cid will normally be zero. In some cases
+ * for software iscsi we could be trying to preallocate a connection struct
+ * in which case there could be two connection structs and cid would be
+ * non-zero.
+ **/
+struct iscsi_cls_conn *
+iscsi_create_conn(struct iscsi_cls_session *session, uint32_t cid)
+{
+	struct iscsi_transport *transport = session-&gt;transport;
+	struct iscsi_cls_conn *conn;
+	int err;
+
+	conn = kzalloc(sizeof(*conn) + transport-&gt;conndata_size, GFP_KERNEL);
+	if (!conn)
+		return NULL;
+
+	if (transport-&gt;conndata_size)
+		conn-&gt;dd_data = &amp;conn[1];
+
+	INIT_LIST_HEAD(&amp;conn-&gt;conn_list);
+	conn-&gt;transport = transport;
+	conn-&gt;cid = cid;
+
+	/* this is released in the dev's release function */
+	if (!get_device(&amp;session-&gt;dev))
+		goto free_conn;
+
+	snprintf(conn-&gt;dev.bus_id, BUS_ID_SIZE, &quot;connection%d:%u&quot;,
+		 session-&gt;sid, cid);
+	conn-&gt;dev.parent = &amp;session-&gt;dev;
+	conn-&gt;dev.release = iscsi_conn_release;
+	err = device_register(&amp;conn-&gt;dev);
+	if (err) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: could not register &quot;
+			   &quot;connection's dev\n&quot;);
+		goto release_parent_ref;
+	}
+	transport_register_device(&amp;conn-&gt;dev);
+	return conn;
+
+release_parent_ref:
+	put_device(&amp;session-&gt;dev);
+free_conn:
+	kfree(conn);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_create_conn);
+
+/**
+ * iscsi_destroy_conn - destroy iscsi class connection
+ * @session: iscsi cls session
+ *
+ * This can be called from a LLD or iscsi_transport.
+ **/
+int iscsi_destroy_conn(struct iscsi_cls_conn *conn)
+{
+	transport_unregister_device(&amp;conn-&gt;dev);
+	device_unregister(&amp;conn-&gt;dev);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_destroy_conn);
+
+/*
+ * iscsi interface functions
+ */
+static struct iscsi_internal *
+iscsi_if_transport_lookup(struct iscsi_transport *tt)
+{
+	struct iscsi_internal *priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;iscsi_transport_lock, flags);
+	list_for_each_entry(priv, &amp;iscsi_transports, list) {
+		if (tt == priv-&gt;iscsi_transport) {
+			spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
+			return priv;
+		}
+	}
+	spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
+	return NULL;
+}
+
+static inline struct list_head *skb_to_lh(struct sk_buff *skb)
+{
+	return (struct list_head *)&amp;skb-&gt;cb;
+}
+
+static void*
+mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
+{
+	struct mempool_zone *zone = pool_data;
+
+	return alloc_skb(zone-&gt;size, gfp_mask);
+}
+
+static void
+mempool_zone_free_skb(void *element, void *pool_data)
+{
+	kfree_skb(element);
+}
+
+static void
+mempool_zone_complete(struct mempool_zone *zone)
+{
+	unsigned long flags;
+	struct list_head *lh, *n;
+
+	spin_lock_irqsave(&amp;zone-&gt;freelock, flags);
+	list_for_each_safe(lh, n, &amp;zone-&gt;freequeue) {
+		struct sk_buff *skb = (struct sk_buff *)((char *)lh -
+				offsetof(struct sk_buff, cb));
+		if (!skb_shared(skb)) {
+			list_del(skb_to_lh(skb));
+			mempool_free(skb, zone-&gt;pool);
+			atomic_dec(&amp;zone-&gt;allocated);
+		}
+	}
+	spin_unlock_irqrestore(&amp;zone-&gt;freelock, flags);
+}
+
+static struct mempool_zone *
+mempool_zone_init(unsigned max, unsigned size, unsigned hiwat)
+{
+	struct mempool_zone *zp;
+
+	zp = kzalloc(sizeof(*zp), GFP_KERNEL);
+	if (!zp)
+		return NULL;
+
+	zp-&gt;size = size;
+	zp-&gt;hiwat = hiwat;
+	INIT_LIST_HEAD(&amp;zp-&gt;freequeue);
+	spin_lock_init(&amp;zp-&gt;freelock);
+	atomic_set(&amp;zp-&gt;allocated, 0);
+
+	zp-&gt;pool = mempool_create(max, mempool_zone_alloc_skb,
+				  mempool_zone_free_skb, zp);
+	if (!zp-&gt;pool) {
+		kfree(zp);
+		return NULL;
+	}
+
+	return zp;
+}
+
+static void mempool_zone_destroy(struct mempool_zone *zp)
+{
+	mempool_destroy(zp-&gt;pool);
+	kfree(zp);
+}
+
+static struct sk_buff*
+mempool_zone_get_skb(struct mempool_zone *zone)
+{
+	struct sk_buff *skb;
+
+	skb = mempool_alloc(zone-&gt;pool, GFP_ATOMIC);
+	if (skb)
+		atomic_inc(&amp;zone-&gt;allocated);
+	return skb;
+}
+
+static int
+iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb)
+{
+	unsigned long flags;
+	int rc;
+
+	skb_get(skb);
+	rc = netlink_unicast(nls, skb, daemon_pid, MSG_DONTWAIT);
+	if (rc &lt; 0) {
+		mempool_free(skb, zone-&gt;pool);
+		printk(KERN_ERR &quot;iscsi: can not unicast skb (%d)\n&quot;, rc);
+		return rc;
+	}
+
+	spin_lock_irqsave(&amp;zone-&gt;freelock, flags);
+	INIT_LIST_HEAD(skb_to_lh(skb));
+	list_add(skb_to_lh(skb), &amp;zone-&gt;freequeue);
+	spin_unlock_irqrestore(&amp;zone-&gt;freelock, flags);
+
+	return 0;
+}
+
+int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
+		   char *data, uint32_t data_size)
+{
+	struct nlmsghdr	*nlh;
+	struct sk_buff *skb;
+	struct iscsi_uevent *ev;
+	char *pdu;
+	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +
+			      data_size);
+
+	mempool_zone_complete(conn-&gt;z_pdu);
+
+	skb = mempool_zone_get_skb(conn-&gt;z_pdu);
+	if (!skb) {
+		iscsi_conn_error(conn, ISCSI_ERR_CONN_FAILED);
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: can not deliver &quot;
+			   &quot;control PDU: OOM\n&quot;);
+		return -ENOMEM;
+	}
+
+	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	ev = NLMSG_DATA(nlh);
+	memset(ev, 0, sizeof(*ev));
+	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
+	ev-&gt;type = ISCSI_KEVENT_RECV_PDU;
+	if (atomic_read(&amp;conn-&gt;z_pdu-&gt;allocated) &gt;= conn-&gt;z_pdu-&gt;hiwat)
+		ev-&gt;iferror = -ENOMEM;
+	ev-&gt;r.recv_req.cid = conn-&gt;cid;
+	ev-&gt;r.recv_req.sid = iscsi_conn_get_sid(conn);
+	pdu = (char*)ev + sizeof(*ev);
+	memcpy(pdu, hdr, sizeof(struct iscsi_hdr));
+	memcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);
+
+	return iscsi_unicast_skb(conn-&gt;z_pdu, skb);
+}
+EXPORT_SYMBOL_GPL(iscsi_recv_pdu);
+
+void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
+{
+	struct nlmsghdr	*nlh;
+	struct sk_buff	*skb;
+	struct iscsi_uevent *ev;
+	int len = NLMSG_SPACE(sizeof(*ev));
+
+	mempool_zone_complete(conn-&gt;z_error);
+
+	skb = mempool_zone_get_skb(conn-&gt;z_error);
+	if (!skb) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: gracefully ignored &quot;
+			  &quot;conn error (%d)\n&quot;, error);
+		return;
+	}
+
+	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	ev = NLMSG_DATA(nlh);
+	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
+	ev-&gt;type = ISCSI_KEVENT_CONN_ERROR;
+	if (atomic_read(&amp;conn-&gt;z_error-&gt;allocated) &gt;= conn-&gt;z_error-&gt;hiwat)
+		ev-&gt;iferror = -ENOMEM;
+	ev-&gt;r.connerror.error = error;
+	ev-&gt;r.connerror.cid = conn-&gt;cid;
+	ev-&gt;r.connerror.sid = iscsi_conn_get_sid(conn);
+
+	iscsi_unicast_skb(conn-&gt;z_error, skb);
+
+	dev_printk(KERN_INFO, &amp;conn-&gt;dev, &quot;iscsi: detected conn error (%d)\n&quot;,
+		   error);
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_error);
+
+static int
+iscsi_if_send_reply(int pid, int seq, int type, int done, int multi,
+		      void *payload, int size)
+{
+	struct sk_buff	*skb;
+	struct nlmsghdr	*nlh;
+	int len = NLMSG_SPACE(size);
+	int flags = multi ? NLM_F_MULTI : 0;
+	int t = done ? NLMSG_DONE : type;
+
+	mempool_zone_complete(z_reply);
+
+	skb = mempool_zone_get_skb(z_reply);
+	/*
+	 * FIXME:
+	 * user is supposed to react on iferror == -ENOMEM;
+	 * see iscsi_if_rx().
+	 */
+	BUG_ON(!skb);
+
+	nlh = __nlmsg_put(skb, pid, seq, t, (len - sizeof(*nlh)), 0);
+	nlh-&gt;nlmsg_flags = flags;
+	memcpy(NLMSG_DATA(nlh), payload, size);
+	return iscsi_unicast_skb(z_reply, skb);
+}
+
+static int
+iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
+{
+	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
+	struct iscsi_stats *stats;
+	struct sk_buff *skbstat;
+	struct iscsi_cls_conn *conn;
+	struct nlmsghdr	*nlhstat;
+	struct iscsi_uevent *evstat;
+	int len = NLMSG_SPACE(sizeof(*ev) +
+			      sizeof(struct iscsi_stats) +
+			      sizeof(struct iscsi_stats_custom) *
+			      ISCSI_STATS_CUSTOM_MAX);
+	int err = 0;
+
+	conn = iscsi_conn_lookup(ev-&gt;u.get_stats.sid, ev-&gt;u.get_stats.cid);
+	if (!conn)
+		return -EEXIST;
+
+	do {
+		int actual_size;
+
+		mempool_zone_complete(conn-&gt;z_pdu);
+
+		skbstat = mempool_zone_get_skb(conn-&gt;z_pdu);
+		if (!skbstat) {
+			dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: can not &quot;
+				   &quot;deliver stats: OOM\n&quot;);
+			return -ENOMEM;
+		}
+
+		nlhstat = __nlmsg_put(skbstat, daemon_pid, 0, 0,
+				      (len - sizeof(*nlhstat)), 0);
+		evstat = NLMSG_DATA(nlhstat);
+		memset(evstat, 0, sizeof(*evstat));
+		evstat-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
+		evstat-&gt;type = nlh-&gt;nlmsg_type;
+		if (atomic_read(&amp;conn-&gt;z_pdu-&gt;allocated) &gt;= conn-&gt;z_pdu-&gt;hiwat)
+			evstat-&gt;iferror = -ENOMEM;
+		evstat-&gt;u.get_stats.cid =
+			ev-&gt;u.get_stats.cid;
+		evstat-&gt;u.get_stats.sid =
+			ev-&gt;u.get_stats.sid;
+		stats = (struct iscsi_stats *)
+			((char*)evstat + sizeof(*evstat));
+		memset(stats, 0, sizeof(*stats));
+
+		transport-&gt;get_stats(conn, stats);
+		actual_size = NLMSG_SPACE(sizeof(struct iscsi_uevent) +
+					  sizeof(struct iscsi_stats) +
+					  sizeof(struct iscsi_stats_custom) *
+					  stats-&gt;custom_length);
+		actual_size -= sizeof(*nlhstat);
+		actual_size = NLMSG_LENGTH(actual_size);
+		skb_trim(skbstat, NLMSG_ALIGN(actual_size));
+		nlhstat-&gt;nlmsg_len = actual_size;
+
+		err = iscsi_unicast_skb(conn-&gt;z_pdu, skbstat);
+	} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
+
+	return err;
+}
+
+static int
+iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
+{
+	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
+	struct iscsi_cls_session *session;
+	unsigned long flags;
+	uint32_t hostno;
+
+	session = transport-&gt;create_session(transport, &amp;priv-&gt;t,
+					    ev-&gt;u.c_session.initial_cmdsn,
+					    &amp;hostno);
+	if (!session)
+		return -ENOMEM;
+
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_add(&amp;session-&gt;sess_list, &amp;sesslist);
+	spin_unlock_irqrestore(&amp;sesslock, flags);
+
+	ev-&gt;r.c_session_ret.host_no = hostno;
+	ev-&gt;r.c_session_ret.sid = session-&gt;sid;
+	return 0;
+}
+
+static int
+iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
+{
+	struct iscsi_cls_conn *conn;
+	struct iscsi_cls_session *session;
+	unsigned long flags;
+
+	session = iscsi_session_lookup(ev-&gt;u.c_conn.sid);
+	if (!session) {
+		printk(KERN_ERR &quot;iscsi: invalid session %d\n&quot;,
+		       ev-&gt;u.c_conn.sid);
+		return -EINVAL;
+	}
+
+	conn = transport-&gt;create_conn(session, ev-&gt;u.c_conn.cid);
+	if (!conn) {
+		printk(KERN_ERR &quot;iscsi: couldn't create a new &quot;
+			   &quot;connection for session %d\n&quot;,
+			   session-&gt;sid);
+		return -ENOMEM;
+	}
+
+	conn-&gt;z_pdu = mempool_zone_init(Z_MAX_PDU,
+			NLMSG_SPACE(sizeof(struct iscsi_uevent) +
+				    sizeof(struct iscsi_hdr) +
+				    DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH),
+			Z_HIWAT_PDU);
+	if (!conn-&gt;z_pdu) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: can not allocate &quot;
+			   &quot;pdu zone for new conn\n&quot;);
+		goto destroy_conn;
+	}
+
+	conn-&gt;z_error = mempool_zone_init(Z_MAX_ERROR,
+			NLMSG_SPACE(sizeof(struct iscsi_uevent)),
+			Z_HIWAT_ERROR);
+	if (!conn-&gt;z_error) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, &quot;iscsi: can not allocate &quot;
+			   &quot;error zone for new conn\n&quot;);
+		goto free_pdu_pool;
+	}
+
+	ev-&gt;r.c_conn_ret.sid = session-&gt;sid;
+	ev-&gt;r.c_conn_ret.cid = conn-&gt;cid;
+
+	spin_lock_irqsave(&amp;connlock, flags);
+	list_add(&amp;conn-&gt;conn_list, &amp;connlist);
+	conn-&gt;active = 1;
+	spin_unlock_irqrestore(&amp;connlock, flags);
+
+	return 0;
+
+free_pdu_pool:
+	mempool_zone_destroy(conn-&gt;z_pdu);
+destroy_conn:
+	if (transport-&gt;destroy_conn)
+		transport-&gt;destroy_conn(conn-&gt;dd_data);
+	return -ENOMEM;
+}
+
+static int
+iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
+{
+	unsigned long flags;
+	struct iscsi_cls_conn *conn;
+	struct mempool_zone *z_error, *z_pdu;
+
+	conn = iscsi_conn_lookup(ev-&gt;u.d_conn.sid, ev-&gt;u.d_conn.cid);
+	if (!conn)
+		return -EINVAL;
+	spin_lock_irqsave(&amp;connlock, flags);
+	conn-&gt;active = 0;
+	list_del(&amp;conn-&gt;conn_list);
+	spin_unlock_irqrestore(&amp;connlock, flags);
+
+	z_pdu = conn-&gt;z_pdu;
+	z_error = conn-&gt;z_error;
+
+	if (transport-&gt;destroy_conn)
+		transport-&gt;destroy_conn(conn);
+
+	mempool_zone_destroy(z_pdu);
+	mempool_zone_destroy(z_error);
+
+	return 0;
+}
+
+static void
+iscsi_copy_param(struct iscsi_uevent *ev, uint32_t *value, char *data)
+{
+	if (ev-&gt;u.set_param.len != sizeof(uint32_t))
+		BUG();
+	memcpy(value, data, min_t(uint32_t, sizeof(uint32_t),
+		ev-&gt;u.set_param.len));
+}
+
+static int
+iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
+{
+	char *data = (char*)ev + sizeof(*ev);
+	struct iscsi_cls_conn *conn;
+	struct iscsi_cls_session *session;
+	int err = 0;
+	uint32_t value = 0;
+
+	session = iscsi_session_lookup(ev-&gt;u.set_param.sid);
+	conn = iscsi_conn_lookup(ev-&gt;u.set_param.sid, ev-&gt;u.set_param.cid);
+	if (!conn || !session)
+		return -EINVAL;
+
+	switch (ev-&gt;u.set_param.param) {
+	case ISCSI_PARAM_SESS_RECOVERY_TMO:
+		iscsi_copy_param(ev, &amp;value, data);
+		if (value != 0)
+			session-&gt;recovery_tmo = value;
+		break;
+	case ISCSI_PARAM_TARGET_NAME:
+		/* this should not change between logins */
+		if (session-&gt;targetname)
+			return 0;
+
+		session-&gt;targetname = kstrdup(data, GFP_KERNEL);
+		if (!session-&gt;targetname)
+			return -ENOMEM;
+		break;
+	case ISCSI_PARAM_TPGT:
+		iscsi_copy_param(ev, &amp;value, data);
+		session-&gt;tpgt = value;
+		break;
+	case ISCSI_PARAM_PERSISTENT_PORT:
+		iscsi_copy_param(ev, &amp;value, data);
+		conn-&gt;persistent_port = value;
+		break;
+	case ISCSI_PARAM_PERSISTENT_ADDRESS:
+		/*
+		 * this is the address returned in discovery so it should
+		 * not change between logins.
+		 */
+		if (conn-&gt;persistent_address)
+			return 0;
+
+		conn-&gt;persistent_address = kstrdup(data, GFP_KERNEL);
+		if (!conn-&gt;persistent_address)
+			return -ENOMEM;
+		break;
+	default:
+		iscsi_copy_param(ev, &amp;value, data);
+		err = transport-&gt;set_param(conn, ev-&gt;u.set_param.param, value);
+	}
+
+	return err;
+}
+
+static int
+iscsi_if_transport_ep(struct iscsi_transport *transport,
+		      struct iscsi_uevent *ev, int msg_type)
+{
+	struct sockaddr *dst_addr;
+	int rc = 0;
+
+	switch (msg_type) {
+	case ISCSI_UEVENT_TRANSPORT_EP_CONNECT:
+		if (!transport-&gt;ep_connect)
+			return -EINVAL;
+
+		dst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));
+		rc = transport-&gt;ep_connect(dst_addr,
+					   ev-&gt;u.ep_connect.non_blocking,
+					   &amp;ev-&gt;r.ep_connect_ret.handle);
+		break;
+	case ISCSI_UEVENT_TRANSPORT_EP_POLL:
+		if (!transport-&gt;ep_poll)
+			return -EINVAL;
+
+		ev-&gt;r.retcode = transport-&gt;ep_poll(ev-&gt;u.ep_poll.ep_handle,
+						   ev-&gt;u.ep_poll.timeout_ms);
+		break;
+	case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:
+		if (!transport-&gt;ep_disconnect)
+			return -EINVAL;
+
+		transport-&gt;ep_disconnect(ev-&gt;u.ep_disconnect.ep_handle);
+		break;
+	}
+	return rc;
+}
+
+static int
+iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+{
+	int err = 0;
+	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
+	struct iscsi_transport *transport = NULL;
+	struct iscsi_internal *priv;
+	struct iscsi_cls_session *session;
+	struct iscsi_cls_conn *conn;
+	unsigned long flags;
+
+	priv = iscsi_if_transport_lookup(iscsi_ptr(ev-&gt;transport_handle));
+	if (!priv)
+		return -EINVAL;
+	transport = priv-&gt;iscsi_transport;
+
+	if (!try_module_get(transport-&gt;owner))
+		return -EINVAL;
+
+	switch (nlh-&gt;nlmsg_type) {
+	case ISCSI_UEVENT_CREATE_SESSION:
+		err = iscsi_if_create_session(priv, ev);
+		break;
+	case ISCSI_UEVENT_DESTROY_SESSION:
+		session = iscsi_session_lookup(ev-&gt;u.d_session.sid);
+		if (session) {
+			spin_lock_irqsave(&amp;sesslock, flags);
+			list_del(&amp;session-&gt;sess_list);
+			spin_unlock_irqrestore(&amp;sesslock, flags);
+
+			transport-&gt;destroy_session(session);
+		} else
+			err = -EINVAL;
+		break;
+	case ISCSI_UEVENT_CREATE_CONN:
+		err = iscsi_if_create_conn(transport, ev);
+		break;
+	case ISCSI_UEVENT_DESTROY_CONN:
+		err = iscsi_if_destroy_conn(transport, ev);
+		break;
+	case ISCSI_UEVENT_BIND_CONN:
+		session = iscsi_session_lookup(ev-&gt;u.b_conn.sid);
+		conn = iscsi_conn_lookup(ev-&gt;u.b_conn.sid, ev-&gt;u.b_conn.cid);
+
+		if (session &amp;&amp; conn)
+			ev-&gt;r.retcode =	transport-&gt;bind_conn(session, conn,
+					ev-&gt;u.b_conn.transport_eph,
+					ev-&gt;u.b_conn.is_leading);
+		else
+			err = -EINVAL;
+		break;
+	case ISCSI_UEVENT_SET_PARAM:
+		err = iscsi_set_param(transport, ev);
+		break;
+	case ISCSI_UEVENT_START_CONN:
+		conn = iscsi_conn_lookup(ev-&gt;u.start_conn.sid, ev-&gt;u.start_conn.cid);
+		if (conn)
+			ev-&gt;r.retcode = transport-&gt;start_conn(conn);
+		else
+			err = -EINVAL;
+		break;
+	case ISCSI_UEVENT_STOP_CONN:
+		conn = iscsi_conn_lookup(ev-&gt;u.stop_conn.sid, ev-&gt;u.stop_conn.cid);
+		if (conn)
+			transport-&gt;stop_conn(conn, ev-&gt;u.stop_conn.flag);
+		else
+			err = -EINVAL;
+		break;
+	case ISCSI_UEVENT_SEND_PDU:
+		conn = iscsi_conn_lookup(ev-&gt;u.send_pdu.sid, ev-&gt;u.send_pdu.cid);
+		if (conn)
+			ev-&gt;r.retcode =	transport-&gt;send_pdu(conn,
+				(struct iscsi_hdr*)((char*)ev + sizeof(*ev)),
+				(char*)ev + sizeof(*ev) + ev-&gt;u.send_pdu.hdr_size,
+				ev-&gt;u.send_pdu.data_size);
+		else
+			err = -EINVAL;
+		break;
+	case ISCSI_UEVENT_GET_STATS:
+		err = iscsi_if_get_stats(transport, nlh);
+		break;
+	case ISCSI_UEVENT_TRANSPORT_EP_CONNECT:
+	case ISCSI_UEVENT_TRANSPORT_EP_POLL:
+	case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:
+		err = iscsi_if_transport_ep(transport, ev, nlh-&gt;nlmsg_type);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	module_put(transport-&gt;owner);
+	return err;
+}
+
+/*
+ * Get message from skb (based on rtnetlink_rcv_skb).  Each message is
+ * processed by iscsi_if_recv_msg.  Malformed skbs with wrong lengths or
+ * invalid creds are discarded silently.
+ */
+static void
+iscsi_if_rx(struct sock *sk, int len)
+{
+	struct sk_buff *skb;
+
+	mutex_lock(&amp;rx_queue_mutex);
+	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != NULL) {
+		if (NETLINK_CREDS(skb)-&gt;uid) {
+			skb_pull(skb, skb-&gt;len);
+			goto free_skb;
+		}
+		daemon_pid = NETLINK_CREDS(skb)-&gt;pid;
+
+		while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
+			int err;
+			uint32_t rlen;
+			struct nlmsghdr	*nlh;
+			struct iscsi_uevent *ev;
+
+			nlh = (struct nlmsghdr *)skb-&gt;data;
+			if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||
+			    skb-&gt;len &lt; nlh-&gt;nlmsg_len) {
+				break;
+			}
+
+			ev = NLMSG_DATA(nlh);
+			rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
+			if (rlen &gt; skb-&gt;len)
+				rlen = skb-&gt;len;
+
+			err = iscsi_if_recv_msg(skb, nlh);
+			if (err) {
+				ev-&gt;type = ISCSI_KEVENT_IF_ERROR;
+				ev-&gt;iferror = err;
+			}
+			do {
+				/*
+				 * special case for GET_STATS:
+				 * on success - sending reply and stats from
+				 * inside of if_recv_msg(),
+				 * on error - fall through.
+				 */
+				if (ev-&gt;type == ISCSI_UEVENT_GET_STATS &amp;&amp; !err)
+					break;
+				err = iscsi_if_send_reply(
+					NETLINK_CREDS(skb)-&gt;pid, nlh-&gt;nlmsg_seq,
+					nlh-&gt;nlmsg_type, 0, 0, ev, sizeof(*ev));
+				if (atomic_read(&amp;z_reply-&gt;allocated) &gt;=
+						z_reply-&gt;hiwat)
+					ev-&gt;iferror = -ENOMEM;
+			} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
+			skb_pull(skb, rlen);
+		}
+free_skb:
+		kfree_skb(skb);
+	}
+	mutex_unlock(&amp;rx_queue_mutex);
+}
+
+#define iscsi_cdev_to_conn(_cdev) \
+	iscsi_dev_to_conn(_cdev-&gt;dev)
+
+#define ISCSI_CLASS_ATTR(_prefix,_name,_mode,_show,_store)		\
+struct class_device_attribute class_device_attr_##_prefix##_##_name =	\
+	__ATTR(_name,_mode,_show,_store)
+
+/*
+ * iSCSI connection attrs
+ */
+#define iscsi_conn_int_attr_show(param, format)				\
+static ssize_t								\
+show_conn_int_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	uint32_t value = 0;						\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	struct iscsi_transport *t = conn-&gt;transport;			\
+									\
+	t-&gt;get_conn_param(conn, param, &amp;value);				\
+	return snprintf(buf, 20, format&quot;\n&quot;, value);			\
+}
+
+#define iscsi_conn_int_attr(field, param, format)			\
+	iscsi_conn_int_attr_show(param, format)				\
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_int_param_##param, \
+			NULL);
+
+iscsi_conn_int_attr(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH, &quot;%u&quot;);
+iscsi_conn_int_attr(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH, &quot;%u&quot;);
+iscsi_conn_int_attr(header_digest, ISCSI_PARAM_HDRDGST_EN, &quot;%d&quot;);
+iscsi_conn_int_attr(data_digest, ISCSI_PARAM_DATADGST_EN, &quot;%d&quot;);
+iscsi_conn_int_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN, &quot;%d&quot;);
+iscsi_conn_int_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN, &quot;%d&quot;);
+iscsi_conn_int_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT, &quot;%d&quot;);
+iscsi_conn_int_attr(port, ISCSI_PARAM_CONN_PORT, &quot;%d&quot;);
+iscsi_conn_int_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN, &quot;%u&quot;);
+
+#define iscsi_conn_str_attr_show(param)					\
+static ssize_t								\
+show_conn_str_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	struct iscsi_transport *t = conn-&gt;transport;			\
+	return t-&gt;get_conn_str_param(conn, param, buf);			\
+}
+
+#define iscsi_conn_str_attr(field, param)				\
+	iscsi_conn_str_attr_show(param)					\
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_str_param_##param, \
+			NULL);
+
+iscsi_conn_str_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);
+iscsi_conn_str_attr(address, ISCSI_PARAM_CONN_ADDRESS);
+
+#define iscsi_cdev_to_session(_cdev) \
+	iscsi_dev_to_session(_cdev-&gt;dev)
+
+/*
+ * iSCSI session attrs
+ */
+#define iscsi_session_int_attr_show(param, format)			\
+static ssize_t								\
+show_session_int_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	uint32_t value = 0;						\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);	\
+	struct iscsi_transport *t = session-&gt;transport;			\
+									\
+	t-&gt;get_session_param(session, param, &amp;value);			\
+	return snprintf(buf, 20, format&quot;\n&quot;, value);			\
+}
+
+#define iscsi_session_int_attr(field, param, format)			\
+	iscsi_session_int_attr_show(param, format)			\
+static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_int_param_##param, \
+			NULL);
+
+iscsi_session_int_attr(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN, &quot;%d&quot;);
+iscsi_session_int_attr(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T, &quot;%hu&quot;);
+iscsi_session_int_attr(immediate_data, ISCSI_PARAM_IMM_DATA_EN, &quot;%d&quot;);
+iscsi_session_int_attr(first_burst_len, ISCSI_PARAM_FIRST_BURST, &quot;%u&quot;);
+iscsi_session_int_attr(max_burst_len, ISCSI_PARAM_MAX_BURST, &quot;%u&quot;);
+iscsi_session_int_attr(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN, &quot;%d&quot;);
+iscsi_session_int_attr(data_seq_in_order, ISCSI_PARAM_DATASEQ_INORDER_EN, &quot;%d&quot;);
+iscsi_session_int_attr(erl, ISCSI_PARAM_ERL, &quot;%d&quot;);
+iscsi_session_int_attr(tpgt, ISCSI_PARAM_TPGT, &quot;%d&quot;);
+
+#define iscsi_session_str_attr_show(param)				\
+static ssize_t								\
+show_session_str_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
+	struct iscsi_transport *t = session-&gt;transport;			\
+	return t-&gt;get_session_str_param(session, param, buf);		\
+}
+
+#define iscsi_session_str_attr(field, param)				\
+	iscsi_session_str_attr_show(param)				\
+static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_str_param_##param, \
+			NULL);
+
+iscsi_session_str_attr(targetname, ISCSI_PARAM_TARGET_NAME);
+
+/*
+ * Private session and conn attrs. userspace uses several iscsi values
+ * to identify each session between reboots. Some of these values may not
+ * be present in the iscsi_transport/LLD driver becuase userspace handles
+ * login (and failback for login redirect) so for these type of drivers
+ * the class manages the attrs and values for the iscsi_transport/LLD
+ */ 
+#define iscsi_priv_session_attr_show(field, format)			\
+static ssize_t								\
+show_priv_session_##field(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
+	return sprintf(buf, format&quot;\n&quot;, session-&gt;field);		\
+}
+
+#define iscsi_priv_session_attr(field, format)				\
+	iscsi_priv_session_attr_show(field, format)			\
+static ISCSI_CLASS_ATTR(priv_sess, field, S_IRUGO, show_priv_session_##field, \
+			NULL)
+iscsi_priv_session_attr(targetname, &quot;%s&quot;);
+iscsi_priv_session_attr(tpgt, &quot;%d&quot;);
+iscsi_priv_session_attr(recovery_tmo, &quot;%d&quot;);
+
+#define iscsi_priv_conn_attr_show(field, format)			\
+static ssize_t								\
+show_priv_conn_##field(struct class_device *cdev, char *buf)		\
+{									\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	return sprintf(buf, format&quot;\n&quot;, conn-&gt;field);			\
+}
+
+#define iscsi_priv_conn_attr(field, format)				\
+	iscsi_priv_conn_attr_show(field, format)			\
+static ISCSI_CLASS_ATTR(priv_conn, field, S_IRUGO, show_priv_conn_##field, \
+			NULL)
+iscsi_priv_conn_attr(persistent_address, &quot;%s&quot;);
+iscsi_priv_conn_attr(persistent_port, &quot;%d&quot;);
+
+#define SETUP_PRIV_SESSION_RD_ATTR(field)				\
+do {									\
+	priv-&gt;session_attrs[count] = &amp;class_device_attr_priv_sess_##field; \
+	count++;							\
+} while (0)
+
+#define SETUP_SESSION_RD_ATTR(field, param_flag)			\
+do {									\
+	if (tt-&gt;param_mask &amp; param_flag) {				\
+		priv-&gt;session_attrs[count] = &amp;class_device_attr_sess_##field; \
+		count++;						\
+	}								\
+} while (0)
+
+#define SETUP_PRIV_CONN_RD_ATTR(field)					\
+do {									\
+	priv-&gt;conn_attrs[count] = &amp;class_device_attr_priv_conn_##field; \
+	count++;							\
+} while (0)
+
+#define SETUP_CONN_RD_ATTR(field, param_flag)				\
+do {									\
+	if (tt-&gt;param_mask &amp; param_flag) {				\
+		priv-&gt;conn_attrs[count] = &amp;class_device_attr_conn_##field; \
+		count++;						\
+	}								\
+} while (0)
+
+static int iscsi_session_match(struct attribute_container *cont,
+			   struct device *dev)
+{
+	struct iscsi_cls_session *session;
+	struct Scsi_Host *shost;
+	struct iscsi_internal *priv;
+
+	if (!iscsi_is_session_dev(dev))
+		return 0;
+
+	session = iscsi_dev_to_session(dev);
+	shost = iscsi_session_to_shost(session);
+	if (!shost-&gt;transportt)
+		return 0;
+
+	priv = to_iscsi_internal(shost-&gt;transportt);
+	if (priv-&gt;session_cont.ac.class != &amp;iscsi_session_class.class)
+		return 0;
+
+	return &amp;priv-&gt;session_cont.ac == cont;
+}
+
+static int iscsi_conn_match(struct attribute_container *cont,
+			   struct device *dev)
+{
+	struct iscsi_cls_session *session;
+	struct iscsi_cls_conn *conn;
+	struct Scsi_Host *shost;
+	struct iscsi_internal *priv;
+
+	if (!iscsi_is_conn_dev(dev))
+		return 0;
+
+	conn = iscsi_dev_to_conn(dev);
+	session = iscsi_dev_to_session(conn-&gt;dev.parent);
+	shost = iscsi_session_to_shost(session);
+
+	if (!shost-&gt;transportt)
+		return 0;
+
+	priv = to_iscsi_internal(shost-&gt;transportt);
+	if (priv-&gt;conn_cont.ac.class != &amp;iscsi_connection_class.class)
+		return 0;
+
+	return &amp;priv-&gt;conn_cont.ac == cont;
+}
+
+static int iscsi_host_match(struct attribute_container *cont,
+			    struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_internal *priv;
+
+	if (!scsi_is_host_device(dev))
+		return 0;
+
+	shost = dev_to_shost(dev);
+	if (!shost-&gt;transportt  ||
+	    shost-&gt;transportt-&gt;host_attrs.ac.class != &amp;iscsi_host_class.class)
+		return 0;
+
+        priv = to_iscsi_internal(shost-&gt;transportt);
+        return &amp;priv-&gt;t.host_attrs.ac == cont;
+}
+
+struct scsi_transport_template *
+iscsi_register_transport(struct iscsi_transport *tt)
+{
+	struct iscsi_internal *priv;
+	unsigned long flags;
+	int count = 0, err;
+
+	BUG_ON(!tt);
+
+	priv = iscsi_if_transport_lookup(tt);
+	if (priv)
+		return NULL;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+	INIT_LIST_HEAD(&amp;priv-&gt;list);
+	priv-&gt;iscsi_transport = tt;
+	priv-&gt;t.user_scan = iscsi_user_scan;
+
+	priv-&gt;cdev.class = &amp;iscsi_transport_class;
+	snprintf(priv-&gt;cdev.class_id, BUS_ID_SIZE, &quot;%s&quot;, tt-&gt;name);
+	err = class_device_register(&amp;priv-&gt;cdev);
+	if (err)
+		goto free_priv;
+
+	err = sysfs_create_group(&amp;priv-&gt;cdev.kobj, &amp;iscsi_transport_group);
+	if (err)
+		goto unregister_cdev;
+
+	/* host parameters */
+	priv-&gt;t.host_attrs.ac.attrs = &amp;priv-&gt;host_attrs[0];
+	priv-&gt;t.host_attrs.ac.class = &amp;iscsi_host_class.class;
+	priv-&gt;t.host_attrs.ac.match = iscsi_host_match;
+	priv-&gt;t.host_size = sizeof(struct iscsi_host);
+	priv-&gt;host_attrs[0] = NULL;
+	transport_container_register(&amp;priv-&gt;t.host_attrs);
+
+	/* connection parameters */
+	priv-&gt;conn_cont.ac.attrs = &amp;priv-&gt;conn_attrs[0];
+	priv-&gt;conn_cont.ac.class = &amp;iscsi_connection_class.class;
+	priv-&gt;conn_cont.ac.match = iscsi_conn_match;
+	transport_container_register(&amp;priv-&gt;conn_cont);
+
+	SETUP_CONN_RD_ATTR(max_recv_dlength, ISCSI_MAX_RECV_DLENGTH);
+	SETUP_CONN_RD_ATTR(max_xmit_dlength, ISCSI_MAX_XMIT_DLENGTH);
+	SETUP_CONN_RD_ATTR(header_digest, ISCSI_HDRDGST_EN);
+	SETUP_CONN_RD_ATTR(data_digest, ISCSI_DATADGST_EN);
+	SETUP_CONN_RD_ATTR(ifmarker, ISCSI_IFMARKER_EN);
+	SETUP_CONN_RD_ATTR(ofmarker, ISCSI_OFMARKER_EN);
+	SETUP_CONN_RD_ATTR(address, ISCSI_CONN_ADDRESS);
+	SETUP_CONN_RD_ATTR(port, ISCSI_CONN_PORT);
+	SETUP_CONN_RD_ATTR(exp_statsn, ISCSI_EXP_STATSN);
+
+	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_ADDRESS)
+		SETUP_CONN_RD_ATTR(persistent_address, ISCSI_PERSISTENT_ADDRESS);
+	else
+		SETUP_PRIV_CONN_RD_ATTR(persistent_address);
+
+	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_PORT)
+		SETUP_CONN_RD_ATTR(persistent_port, ISCSI_PERSISTENT_PORT);
+	else
+		SETUP_PRIV_CONN_RD_ATTR(persistent_port);
+
+	BUG_ON(count &gt; ISCSI_CONN_ATTRS);
+	priv-&gt;conn_attrs[count] = NULL;
+	count = 0;
+
+	/* session parameters */
+	priv-&gt;session_cont.ac.attrs = &amp;priv-&gt;session_attrs[0];
+	priv-&gt;session_cont.ac.class = &amp;iscsi_session_class.class;
+	priv-&gt;session_cont.ac.match = iscsi_session_match;
+	transport_container_register(&amp;priv-&gt;session_cont);
+
+	SETUP_SESSION_RD_ATTR(initial_r2t, ISCSI_INITIAL_R2T_EN);
+	SETUP_SESSION_RD_ATTR(max_outstanding_r2t, ISCSI_MAX_R2T);
+	SETUP_SESSION_RD_ATTR(immediate_data, ISCSI_IMM_DATA_EN);
+	SETUP_SESSION_RD_ATTR(first_burst_len, ISCSI_FIRST_BURST);
+	SETUP_SESSION_RD_ATTR(max_burst_len, ISCSI_MAX_BURST);
+	SETUP_SESSION_RD_ATTR(data_pdu_in_order, ISCSI_PDU_INORDER_EN);
+	SETUP_SESSION_RD_ATTR(data_seq_in_order, ISCSI_DATASEQ_INORDER_EN);
+	SETUP_SESSION_RD_ATTR(erl, ISCSI_ERL);
+	SETUP_PRIV_SESSION_RD_ATTR(recovery_tmo);
+
+	if (tt-&gt;param_mask &amp; ISCSI_TARGET_NAME)
+		SETUP_SESSION_RD_ATTR(targetname, ISCSI_TARGET_NAME);
+	else
+		SETUP_PRIV_SESSION_RD_ATTR(targetname);
+
+	if (tt-&gt;param_mask &amp; ISCSI_TPGT)
+		SETUP_SESSION_RD_ATTR(tpgt, ISCSI_TPGT);
+	else
+		SETUP_PRIV_SESSION_RD_ATTR(tpgt);
+
+	BUG_ON(count &gt; ISCSI_SESSION_ATTRS);
+	priv-&gt;session_attrs[count] = NULL;
+
+	spin_lock_irqsave(&amp;iscsi_transport_lock, flags);
+	list_add(&amp;priv-&gt;list, &amp;iscsi_transports);
+	spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
+
+	printk(KERN_NOTICE &quot;iscsi: registered transport (%s)\n&quot;, tt-&gt;name);
+	return &amp;priv-&gt;t;
+
+unregister_cdev:
+	class_device_unregister(&amp;priv-&gt;cdev);
+free_priv:
+	kfree(priv);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_register_transport);
+
+int iscsi_unregister_transport(struct iscsi_transport *tt)
+{
+	struct iscsi_internal *priv;
+	unsigned long flags;
+
+	BUG_ON(!tt);
+
+	mutex_lock(&amp;rx_queue_mutex);
+
+	priv = iscsi_if_transport_lookup(tt);
+	BUG_ON (!priv);
+
+	spin_lock_irqsave(&amp;iscsi_transport_lock, flags);
+	list_del(&amp;priv-&gt;list);
+	spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
+
+	transport_container_unregister(&amp;priv-&gt;conn_cont);
+	transport_container_unregister(&amp;priv-&gt;session_cont);
+	transport_container_unregister(&amp;priv-&gt;t.host_attrs);
+
+	sysfs_remove_group(&amp;priv-&gt;cdev.kobj, &amp;iscsi_transport_group);
+	class_device_unregister(&amp;priv-&gt;cdev);
+	mutex_unlock(&amp;rx_queue_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_unregister_transport);
+
+static int
+iscsi_rcv_nl_event(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct netlink_notify *n = ptr;
+
+	if (event == NETLINK_URELEASE &amp;&amp;
+	    n-&gt;protocol == NETLINK_ISCSI &amp;&amp; n-&gt;pid) {
+		struct iscsi_cls_conn *conn;
+		unsigned long flags;
+
+		mempool_zone_complete(z_reply);
+		spin_lock_irqsave(&amp;connlock, flags);
+		list_for_each_entry(conn, &amp;connlist, conn_list) {
+			mempool_zone_complete(conn-&gt;z_error);
+			mempool_zone_complete(conn-&gt;z_pdu);
+		}
+		spin_unlock_irqrestore(&amp;connlock, flags);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block iscsi_nl_notifier = {
+	.notifier_call	= iscsi_rcv_nl_event,
+};
+
+static __init int iscsi_transport_init(void)
+{
+	int err;
+
+	err = class_register(&amp;iscsi_transport_class);
+	if (err)
+		return err;
+
+	err = transport_class_register(&amp;iscsi_host_class);
+	if (err)
+		goto unregister_transport_class;
+
+	err = transport_class_register(&amp;iscsi_connection_class);
+	if (err)
+		goto unregister_host_class;
+
+	err = transport_class_register(&amp;iscsi_session_class);
+	if (err)
+		goto unregister_conn_class;
+
+	err = netlink_register_notifier(&amp;iscsi_nl_notifier);
+	if (err)
+		goto unregister_session_class;
+
+	nls = netlink_kernel_create(NETLINK_ISCSI, 1, iscsi_if_rx,
+			THIS_MODULE);
+	if (!nls) {
+		err = -ENOBUFS;
+		goto unregister_notifier;
+	}
+
+	z_reply = mempool_zone_init(Z_MAX_REPLY,
+		NLMSG_SPACE(sizeof(struct iscsi_uevent)), Z_HIWAT_REPLY);
+	if (z_reply)
+		return 0;
+
+	sock_release(nls-&gt;sk_socket);
+unregister_notifier:
+	netlink_unregister_notifier(&amp;iscsi_nl_notifier);
+unregister_session_class:
+	transport_class_unregister(&amp;iscsi_session_class);
+unregister_conn_class:
+	transport_class_unregister(&amp;iscsi_connection_class);
+unregister_host_class:
+	transport_class_unregister(&amp;iscsi_host_class);
+unregister_transport_class:
+	class_unregister(&amp;iscsi_transport_class);
+	return err;
+}
+
+static void __exit iscsi_transport_exit(void)
+{
+	mempool_zone_destroy(z_reply);
+	sock_release(nls-&gt;sk_socket);
+	netlink_unregister_notifier(&amp;iscsi_nl_notifier);
+	transport_class_unregister(&amp;iscsi_connection_class);
+	transport_class_unregister(&amp;iscsi_session_class);
+	transport_class_unregister(&amp;iscsi_host_class);
+	class_unregister(&amp;iscsi_transport_class);
+}
+
+module_init(iscsi_transport_init);
+module_exit(iscsi_transport_exit);
+
+MODULE_AUTHOR(&quot;Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;, &quot;
+	      &quot;Dmitry Yusupov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">dmitry_yus at yahoo.com</A>&gt;, &quot;
+	      &quot;Alex Aizman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">itn780 at yahoo.com</A>&gt;&quot;);
+MODULE_DESCRIPTION(&quot;iSCSI Transport Interface&quot;);
+MODULE_LICENSE(&quot;GPL&quot;);

Added: branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-04-29 13:54:19 UTC (rev 431)
+++ branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-04-29 14:03:22 UTC (rev 432)
@@ -0,0 +1,222 @@
+/*
+ * iSCSI transport class definitions
+ *
+ * Copyright (C) IBM Corporation, 2004
+ * Copyright (C) Mike Christie, 2004 - 2006
+ * Copyright (C) Dmitry Yusupov, 2004 - 2005
+ * Copyright (C) Alex Aizman, 2004 - 2005
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef SCSI_TRANSPORT_ISCSI_H
+#define SCSI_TRANSPORT_ISCSI_H
+
+#include &lt;linux/device.h&gt;
+#include &lt;iscsi_if.h&gt;
+
+struct scsi_transport_template;
+struct iscsi_transport;
+struct Scsi_Host;
+struct mempool_zone;
+struct iscsi_cls_conn;
+struct iscsi_conn;
+struct iscsi_cmd_task;
+struct iscsi_mgmt_task;
+
+/**
+ * struct iscsi_transport - iSCSI Transport template
+ *
+ * @name:		transport name
+ * @caps:		iSCSI Data-Path capabilities
+ * @create_session:	create new iSCSI session object
+ * @destroy_session:	destroy existing iSCSI session object
+ * @create_conn:	create new iSCSI connection
+ * @bind_conn:		associate this connection with existing iSCSI session
+ *			and specified transport descriptor
+ * @destroy_conn:	destroy inactive iSCSI connection
+ * @set_param:		set iSCSI Data-Path operational parameter
+ * @start_conn:		set connection to be operational
+ * @stop_conn:		suspend/recover/terminate connection
+ * @send_pdu:		send iSCSI PDU, Login, Logout, NOP-Out, Reject, Text.
+ * @session_recovery_timedout: notify LLD a block during recovery timed out
+ * @suspend_conn_recv:	susepend the recv side of the connection
+ * @termincate_conn:	destroy socket connection. Called with mutex lock.
+ * @init_cmd_task:	Initialize a iscsi_cmd_task and any internal structs.
+ *			Called from queuecommand with session lock held.
+ * @init_mgmt_task:	Initialize a iscsi_mgmt_task and any internal structs.
+ *			Called from iscsi_conn_send_generic with xmitmutex.
+ * @xmit_cmd_task:	requests LLD to transfer cmd task
+ * @xmit_mgmt_task:	requests LLD to transfer mgmt task
+ * @cleanup_cmd_task:	requests LLD to fail cmd task. Called with xmitmutex
+ *			and session-&gt;lock after the connection has been
+ *			suspended and terminated during recovery. If called
+ *			from abort task then connection is not suspended
+ *			or terminated but sk_callback_lock is held
+ *
+ * Template API provided by iSCSI Transport
+ */
+struct iscsi_transport {
+	struct module *owner;
+	char *name;
+	unsigned int caps;
+	/* LLD sets this to indicate what values it can export to sysfs */
+	unsigned int param_mask;
+	struct scsi_host_template *host_template;
+	/* LLD connection data size */
+	int conndata_size;
+	/* LLD session data size */
+	int sessiondata_size;
+	int max_lun;
+	unsigned int max_conn;
+	unsigned int max_cmd_len;
+	struct iscsi_cls_session *(*create_session) (struct iscsi_transport *it,
+		struct scsi_transport_template *t, uint32_t sn, uint32_t *hn);
+	void (*destroy_session) (struct iscsi_cls_session *session);
+	struct iscsi_cls_conn *(*create_conn) (struct iscsi_cls_session *sess,
+				uint32_t cid);
+	int (*bind_conn) (struct iscsi_cls_session *session,
+			  struct iscsi_cls_conn *cls_conn,
+			  uint64_t transport_eph, int is_leading);
+	int (*start_conn) (struct iscsi_cls_conn *conn);
+	void (*stop_conn) (struct iscsi_cls_conn *conn, int flag);
+	void (*destroy_conn) (struct iscsi_cls_conn *conn);
+	int (*set_param) (struct iscsi_cls_conn *conn, enum iscsi_param param,
+			  uint32_t value);
+	int (*get_conn_param) (struct iscsi_cls_conn *conn,
+			       enum iscsi_param param, uint32_t *value);
+	int (*get_session_param) (struct iscsi_cls_session *session,
+				  enum iscsi_param param, uint32_t *value);
+	int (*get_conn_str_param) (struct iscsi_cls_conn *conn,
+				   enum iscsi_param param, char *buf);
+	int (*get_session_str_param) (struct iscsi_cls_session *session,
+				      enum iscsi_param param, char *buf);
+	int (*send_pdu) (struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
+			 char *data, uint32_t data_size);
+	void (*get_stats) (struct iscsi_cls_conn *conn,
+			   struct iscsi_stats *stats);
+	void (*suspend_conn_recv) (struct iscsi_conn *conn);
+	void (*terminate_conn) (struct iscsi_conn *conn);
+	void (*init_cmd_task) (struct iscsi_cmd_task *ctask);
+	void (*init_mgmt_task) (struct iscsi_conn *conn,
+				struct iscsi_mgmt_task *mtask,
+				char *data, uint32_t data_size);
+	int (*xmit_cmd_task) (struct iscsi_conn *conn,
+			      struct iscsi_cmd_task *ctask);
+	void (*cleanup_cmd_task) (struct iscsi_conn *conn,
+				  struct iscsi_cmd_task *ctask);
+	int (*xmit_mgmt_task) (struct iscsi_conn *conn,
+			       struct iscsi_mgmt_task *mtask); 
+	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
+	int (*ep_connect) (struct sockaddr *dst_addr, int non_blocking,
+			   uint64_t *ep_handle);
+	int (*ep_poll) (uint64_t ep_handle, int timeout_ms);
+	void (*ep_disconnect) (uint64_t ep_handle);
+};
+
+/*
+ * transport registration upcalls
+ */
+extern struct scsi_transport_template *iscsi_register_transport(struct iscsi_transport *tt);
+extern int iscsi_unregister_transport(struct iscsi_transport *tt);
+
+/*
+ * control plane upcalls
+ */
+extern void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error);
+extern int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
+			  char *data, uint32_t data_size);
+
+
+/* Connection's states */
+#define ISCSI_CONN_INITIAL_STAGE	0
+#define ISCSI_CONN_STARTED		1
+#define ISCSI_CONN_STOPPED		2
+#define ISCSI_CONN_CLEANUP_WAIT		3
+
+struct iscsi_cls_conn {
+	struct list_head conn_list;	/* item in connlist */
+	void *dd_data;			/* LLD private data */
+	struct iscsi_transport *transport;
+	uint32_t cid;			/* connection id */
+
+	/* portal/group values we got during discovery */
+	char *persistent_address;
+	int persistent_port;
+	/* portal/group values we are currently using */
+	char *address;
+	int port;
+
+	int active;			/* must be accessed with the connlock */
+	struct device dev;		/* sysfs transport/container device */
+	struct mempool_zone *z_error;
+	struct mempool_zone *z_pdu;
+	struct list_head freequeue;
+};
+
+#define iscsi_dev_to_conn(_dev) \
+	container_of(_dev, struct iscsi_cls_conn, dev)
+
+/* Session's states */
+#define ISCSI_STATE_FREE		1
+#define ISCSI_STATE_LOGGED_IN		2
+#define ISCSI_STATE_FAILED		3
+#define ISCSI_STATE_TERMINATE		4
+
+struct iscsi_cls_session {
+	struct list_head sess_list;		/* item in session_list */
+	struct list_head host_list;
+	struct iscsi_transport *transport;
+
+	/* iSCSI values used as unique id by userspace. */
+	char *targetname;
+	int tpgt;
+
+	/* recovery fields */
+	int recovery_tmo;
+	struct work_struct recovery_work;
+
+	int target_id;
+	int channel;
+
+	int sid;				/* session id */
+	void *dd_data;				/* LLD private data */
+	struct device dev;	/* sysfs transport/container device */
+};
+
+#define iscsi_dev_to_session(_dev) \
+	container_of(_dev, struct iscsi_cls_session, dev)
+
+#define iscsi_session_to_shost(_session) \
+	dev_to_shost(_session-&gt;dev.parent)
+
+struct iscsi_host {
+	int next_target_id;
+	struct list_head sessions;
+	struct mutex mutex;
+};
+
+/*
+ * session and connection functions that can be used by HW iSCSI LLDs
+ */
+extern struct iscsi_cls_session *iscsi_create_session(struct Scsi_Host *shost,
+				struct iscsi_transport *t, int channel);
+extern int iscsi_destroy_session(struct iscsi_cls_session *session);
+extern struct iscsi_cls_conn *iscsi_create_conn(struct iscsi_cls_session *sess,
+					    uint32_t cid);
+extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
+extern void iscsi_unblock_session(struct iscsi_cls_session *session);
+extern void iscsi_block_session(struct iscsi_cls_session *session);
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000418.html">[Stgt-svn] r431 - branches/use-scsi-ml/istgt/include
</A></li>
	<LI>Next message: <A HREF="000420.html">[Stgt-svn] r433 - branches/use-scsi-ml/istgt/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#419">[ date ]</a>
              <a href="thread.html#419">[ thread ]</a>
              <a href="subject.html#419">[ subject ]</a>
              <a href="author.html#419">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
