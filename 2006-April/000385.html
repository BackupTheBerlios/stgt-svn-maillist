<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r398 - in branches/use-scsi-ml/patchset/broken-out: . srp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r398%20-%20in%20branches/use-scsi-ml/patchset/broken-out%3A%20.%20srp&In-Reply-To=%3C200604080123.k381N95r015970%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000384.html">
   <LINK REL="Next"  HREF="000386.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r398 - in branches/use-scsi-ml/patchset/broken-out: . srp</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r398%20-%20in%20branches/use-scsi-ml/patchset/broken-out%3A%20.%20srp&In-Reply-To=%3C200604080123.k381N95r015970%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r398 - in branches/use-scsi-ml/patchset/broken-out: . srp">tomo at berlios.de
       </A><BR>
    <I>Sat Apr  8 03:23:09 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000384.html">[Stgt-svn] r397 - branches/use-scsi-ml
</A></li>
        <LI>Next message: <A HREF="000386.html">[Stgt-svn] r399 - branches/use-scsi-ml/patchset/broken-out
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#385">[ date ]</a>
              <a href="thread.html#385">[ thread ]</a>
              <a href="subject.html#385">[ subject ]</a>
              <a href="author.html#385">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-04-08 03:22:48 +0200 (Sat, 08 Apr 2006)
New Revision: 398

Added:
   branches/use-scsi-ml/patchset/broken-out/0009-scsi-tgt-add-task-management-function-support.txt
   branches/use-scsi-ml/patchset/broken-out/0010-scsi-tgt-add-NET-dependence-to-Kconfig.txt
   branches/use-scsi-ml/patchset/broken-out/srp/
   branches/use-scsi-ml/patchset/broken-out/srp/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   branches/use-scsi-ml/patchset/broken-out/srp/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
Removed:
   branches/use-scsi-ml/patchset/broken-out/0009-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   branches/use-scsi-ml/patchset/broken-out/0010-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   branches/use-scsi-ml/patchset/broken-out/0011-scsi-tgt-add-task-management-function-support.txt
Modified:
   branches/use-scsi-ml/patchset/broken-out/0001-block-layer-revoke-the-original-patch-to-add-partial-mappings-support.txt
   branches/use-scsi-ml/patchset/broken-out/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
   branches/use-scsi-ml/patchset/broken-out/0003-scsi-tgt-use-the-original-bio_map_user-interface.txt
   branches/use-scsi-ml/patchset/broken-out/0004-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
   branches/use-scsi-ml/patchset/broken-out/0005-scsi-tgt-kernel-user-interface-changes.txt
   branches/use-scsi-ml/patchset/broken-out/0006-scsi-tgt-fix-double-lock-in-scsi_uspace_request_fn.txt
   branches/use-scsi-ml/patchset/broken-out/0007-scsi-tgt-remove-blk_queue_end_tag.txt
   branches/use-scsi-ml/patchset/broken-out/0008-scsi-tgt-replace-the-elevator-code.txt
Log:
Update the patchset for the submission.

Modified: branches/use-scsi-ml/patchset/broken-out/0001-block-layer-revoke-the-original-patch-to-add-partial-mappings-support.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0001-block-layer-revoke-the-original-patch-to-add-partial-mappings-support.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0001-block-layer-revoke-the-original-patch-to-add-partial-mappings-support.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] block layer: revoke the original patch to add partial mappings support
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 01/10] block layer: revoke the original patch to add partial mappings support
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409079 +0900
 
 For target mode we could end up with the case where we get very large
@@ -127,4 +127,4 @@
  extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
  				gfp_t);
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0002-block-layer-add-partial-mappings-support-to-bio_map_user.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] block layer: add partial mappings support to bio_map_user
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 02/10] block layer: add partial mappings support to bio_map_user
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409163 +0900
 
 This is the updated patch for partial mappings support.
@@ -146,4 +146,4 @@
  			  struct request *, int);
  extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0003-scsi-tgt-use-the-original-bio_map_user-interface.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0003-scsi-tgt-use-the-original-bio_map_user-interface.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0003-scsi-tgt-use-the-original-bio_map_user-interface.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] scsi tgt: use the original bio_map_user interface
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 03/10] scsi tgt: use the original bio_map_user interface
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409283 +0900
 
 Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
@@ -25,4 +25,4 @@
  			err = PTR_ERR(bio);
  			dprintk(&quot;fail to map %lx %u %d %x\n&quot;,
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0004-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0004-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0004-block-layer-use-blk_rq_bio_prep-in-init_request_from_bio.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] block layer: use blk_rq_bio_prep in init_request_from_bio
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 04/10] block layer: use blk_rq_bio_prep in init_request_from_bio
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409371 +0900
 
 Patch to use blk_rq_bio_prep in init_request_from_bio. And remove
@@ -51,4 +51,4 @@
  	rq-&gt;nr_hw_segments = bio_hw_segments(q, bio);
  	rq-&gt;current_nr_sectors = bio_cur_sectors(bio);
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0005-scsi-tgt-kernel-user-interface-changes.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0005-scsi-tgt-kernel-user-interface-changes.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0005-scsi-tgt-kernel-user-interface-changes.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] scsi tgt: kernel/user interface changes
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 05/10] scsi tgt: kernel/user interface changes
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409611 +0900
 
 - merge the tgt command structure with the the event structure for simplicity.
@@ -290,4 +290,4 @@
 -
  #endif
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0006-scsi-tgt-fix-double-lock-in-scsi_uspace_request_fn.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0006-scsi-tgt-fix-double-lock-in-scsi_uspace_request_fn.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0006-scsi-tgt-fix-double-lock-in-scsi_uspace_request_fn.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] scsi tgt: fix double lock in scsi_uspace_request_fn
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 06/10] scsi tgt: fix double lock in scsi_uspace_request_fn
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142409678 +0900
 
 Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
@@ -25,4 +25,4 @@
  
  /**
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0007-scsi-tgt-remove-blk_queue_end_tag.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0007-scsi-tgt-remove-blk_queue_end_tag.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0007-scsi-tgt-remove-blk_queue_end_tag.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,5 +1,5 @@
-Subject: [PATCH] scsi tgt: remove blk_queue_end_tag
-From: fujita &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita at albi.localdomain</A>&gt;
+Subject: [PATCH 07/10] scsi tgt: remove blk_queue_end_tag
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
 Date: 1142422083 +0900
 
 Remove blk_queue_end_tag() in scsi_host_put_command() because tgt
@@ -25,4 +25,4 @@
  	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
  
 -- 
-1.1.3
+1.1.5

Modified: branches/use-scsi-ml/patchset/broken-out/0008-scsi-tgt-replace-the-elevator-code.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0008-scsi-tgt-replace-the-elevator-code.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0008-scsi-tgt-replace-the-elevator-code.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,4 +1,6 @@
-Subject: [PATCH] scsi tgt: replace the elevator code
+Subject: [PATCH 08/10] scsi tgt: replace the elevator code
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: 1142464394 +0900
 
 tgt uses the elevator code to send SCSI commands to the user-space
 daemon (q-&gt;request_fn sends netlink packets including commands).
@@ -335,4 +337,4 @@
  extern int scsi_tgt_if_init(void);
  
 -- 
-1.1.3
+1.1.5

Deleted: branches/use-scsi-ml/patchset/broken-out/0009-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0009-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0009-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,583 +0,0 @@
-Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143376921 +0900
-
----
-
- drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
- drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
- drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
- drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
- 4 files changed, 142 insertions(+), 125 deletions(-)
-
-74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool-&gt;events[i].ext_list) {
- 			dma_free_coherent(hostdata-&gt;dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool-&gt;events[i].ext_list,
- 				  pool-&gt;events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_out_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd-&gt;data_in_count =
--				numbuf &lt; MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd-&gt;data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd-&gt;data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
-+	else
-+		srp_cmd-&gt;buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i &lt; num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i &lt; num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
--	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd-&gt;additional_data;
--		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd-&gt;add_data;
-+		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd-&gt;additional_data;
--		int num_mapped = indirect-&gt;head.length / 
--			sizeof(indirect-&gt;list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd-&gt;add_data;
-+		int num_mapped = indirect-&gt;table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
-+			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i &lt; num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &amp;sg[i];
--		descr-&gt;virtual_address = sg_dma_address(sg_entry);
--		descr-&gt;length = sg_dma_len(sg_entry);
--		descr-&gt;memory_handle = 0;
-+		descr-&gt;va = sg_dma_address(sg_entry);
-+		descr-&gt;len = sg_dma_len(sg_entry);
-+		descr-&gt;key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd-&gt;request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
--		data-&gt;length = sg_dma_len(&amp;sg[0]);
--		data-&gt;memory_handle = 0;
-+		data-&gt;va = sg_dma_address(&amp;sg[0]);
-+		data-&gt;len = sg_dma_len(&amp;sg[0]);
-+		data-&gt;key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect-&gt;head.virtual_address = 0;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	indirect-&gt;head.memory_handle = 0;
-+	indirect-&gt;table_desc.va = 0;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect-&gt;table_desc.key = 0;
- 
- 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
--		indirect-&gt;total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &amp;indirect-&gt;desc_list[0]);
-+		indirect-&gt;len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct-&gt;ext_list) {
--		evt_struct-&gt;ext_list =(struct memory_descriptor*)
-+		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&amp;evt_struct-&gt;ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &amp;evt_struct-&gt;ext_list_token, 0);
- 		if (!evt_struct-&gt;ext_list) {
--		    printk(KERN_ERR
--		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
-+			printk(KERN_ERR
-+			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
- 
--	indirect-&gt;total_length = total_length;
--	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
--	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
--	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect-&gt;len = total_length;
-+	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
-+	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
-+	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
- 
--	data-&gt;virtual_address =
-+	data-&gt;va =
- 		dma_map_single(dev, cmd-&gt;request_buffer,
- 			       cmd-&gt;request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data-&gt;virtual_address)) {
-+	if (dma_mapping_error(data-&gt;va)) {
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
- 		return 0;
- 	}
--	data-&gt;length = cmd-&gt;request_bufflen;
--	data-&gt;memory_handle = 0;
-+	data-&gt;len = cmd-&gt;request_bufflen;
-+	data-&gt;key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
--	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
-+	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
- 
--	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
--			       rsp-&gt;type);
-+			       rsp-&gt;opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd-&gt;result = rsp-&gt;status;
- 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd-&gt;sense_buffer,
--			       rsp-&gt;sense_and_response_data,
--			       rsp-&gt;sense_data_list_length);
-+			       rsp-&gt;data,
-+			       rsp-&gt;sense_data_len);
- 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct-&gt;hostdata-&gt;dev);
- 
--		if (rsp-&gt;doover)
--			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
--		else if (rsp-&gt;diover)
--			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
-+		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
-+		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
-+			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
- 	}
- 
- 	if (evt_struct-&gt;cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
- 	u16 lun = lun_from_dev(cmnd-&gt;device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd-&gt;type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd-&gt;opcode = SRP_CMD;
- 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
- 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct-&gt;cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
--	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
--	    (indirect-&gt;head.virtual_address == 0)) {
--		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
-+	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
-+	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
-+	    indirect-&gt;table_desc.va == 0) {
-+		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
--	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
- 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
--		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
-+		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
- 
--	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
-+	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
- 	    (max_requests - 2))
--		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
-+		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&amp;hostdata-&gt;request_limit,
--		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
-+		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
- 
- 	hostdata-&gt;host-&gt;can_queue =
--	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
- 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &amp;evt_struct-&gt;iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login-&gt;type = SRP_LOGIN_REQ_TYPE;
--	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login-&gt;required_buffer_formats = 0x0006;
-+	login-&gt;opcode = SRP_LOGIN_REQ;
-+	login-&gt;req_it_iu_len = sizeof(union srp_iu);
-+	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt-&gt;task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
- 
- 	evt-&gt;sync_srp = &amp;srp_rsp;
- 	init_completion(&amp;evt-&gt;comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
-+			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
- 			       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
- 		printk(KERN_INFO
- 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
--		       tsk_mgmt-&gt;managed_task_tag);
-+		       tsk_mgmt-&gt;task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
--	       tsk_mgmt-&gt;managed_task_tag);
-+	       tsk_mgmt-&gt;task_tag);
- 
- 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
- 	list_del(&amp;found_evt-&gt;list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
- 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
--	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
- 	       tsk_mgmt-&gt;lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&amp;evt-&gt;comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
--		       rsp_rc,
--			       tsk_mgmt-&gt;managed_task_tag);
-+			       rsp_rc, tsk_mgmt-&gt;task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
- 			   &amp;hostdata-&gt;request_limit);
- 
- 	if (evt_struct-&gt;done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include &lt;linux/dma-mapping.h&gt;
- #include &lt;linux/interrupt.h&gt;
- #include &quot;ibmvscsi.h&quot;
--#include &quot;srp.h&quot;
- 
- static char partition_name[97] = &quot;UNKNOWN&quot;;
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include &quot;srp.h&quot;
-+#include &lt;scsi/srp.h&gt;
-+
-+#define SRP_VERSION &quot;16.a&quot;
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/broken-out/0009-scsi-tgt-add-task-management-function-support.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0009-scsi-tgt-add-task-management-function-support.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0009-scsi-tgt-add-task-management-function-support.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -0,0 +1,463 @@
+Subject: [PATCH 09/10] scsi tgt: add task management function support
+From: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Date: 1144370959 +0900
+
+This patch addes task management function support to tgt. This
+assumes that all the previous patchsets are applied.
+
+- add callback to task management function to scsi_host_template
+structure. It is used notify LLDs of the completion of a TMF request.
+
+- this patch doesn't use a single queue for TMF requests and SCSI
+commands yet. We'll work on it later on.
+
+- when LLDs queue scsi commands to tgt (scsi_tgt_queue_command), they
+need to specify unique 'tag' for each command for ABORT_TASK.
+
+- when tgt aborts a command, it calls eh_abort_handler in
+scsi_host_template structure. Would be better to add
+tgt_eh_abort_handler for LLDs support target and initiator modes at
+the same time?
+
+tgt TMF works in the followings:
+
+- When LLDs queue scsi commands to tgt (scsi_tgt_queue_command), they
+need to specify unique 'tag' for each command.
+
+- LLDs call 'int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *host, int,
+u64 tag, struct scsi_lun *lun, void *data)'.
+
+- int (* tsk_mgmt_response)(u64 data, int result) is added to
+scsi_host_template.
+
+When an initiator sends a task management request, the LLD calls
+scsi_tgt_tsk_mgmt_request. the LLD can use whatever it wants for the
+data arg. The data arg is used later as the arg in the
+tsk_mgmt_response callback.
+
+tgt core just sends the task management request to user space
+(by using TGT_KEVENT_TSK_MGMT_REQ).
+
+In the case of ABORT_TASK, tgtd finds a single command to abort and
+sends TGT_UEVENT_CMD_RSP and TGT_UEVENT_TSK_MGMT_RSP events.
+
+tgt core calls eh_abort_handler for TGT_UEVENT_CMD_RSP and then
+tsk_mgmt_response for TGT_UEVENT_TSK_MGMT_RSP.
+
+If tgtd fails to find a command to abort, it sends only
+TGT_UEVENT_TSK_MGMT_RSP event (no TGT_UEVENT_CMD_RSP event).
+
+In the case of the rests task management function (like
+ABORT_TASK_SET), tgt needs to abort multiple commands. Thus, tgtd
+finds multiple commands to abort and sends multiple TGT_UEVENT_CMD_RSP
+events and a single TGT_UEVENT_TSK_MGMT_RSP event. tgt core calls
+eh_abort_handler multiple times and tsk_mgmt_response once.
+
+eh_abort_handler enables LLDs to safely free resource related with a
+command to abort.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+
+---
+
+ drivers/scsi/scsi_tgt_if.c   |   43 +++++++++++++++---
+ drivers/scsi/scsi_tgt_lib.c  |  103 +++++++++++++++++++++++++++++-------------
+ drivers/scsi/scsi_tgt_priv.h |   11 +++-
+ include/scsi/scsi_host.h     |    3 +
+ include/scsi/scsi_tgt.h      |    6 ++
+ include/scsi/scsi_tgt_if.h   |    7 ++-
+ 6 files changed, 125 insertions(+), 48 deletions(-)
+
+b9579b62f8d6309815a60da2e6f9a7638df074aa
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+index a31c8d5..ba1b75b 100644
+--- a/drivers/scsi/scsi_tgt_if.c
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -56,7 +56,8 @@ static int send_event_rsp(uint16_t type,
+ 	return netlink_unicast(nl_sk, skb, pid, 0);
+ }
+ 
+-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
++int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
++			 gfp_t flags)
+ {
+ 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
+ 	struct sk_buff *skb;
+@@ -71,7 +72,7 @@ int scsi_tgt_uspace_send(struct scsi_cmn
+ 	/*
+ 	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
+ 	 */
+-	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
++	skb = alloc_skb(NLMSG_SPACE(len), flags);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+@@ -85,9 +86,11 @@ int scsi_tgt_uspace_send(struct scsi_cmn
+ 	memcpy(ev-&gt;k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev-&gt;k.cmd_req.scb));
+ 	memcpy(ev-&gt;k.cmd_req.lun, lun, sizeof(ev-&gt;k.cmd_req.lun));
+ 	ev-&gt;k.cmd_req.attribute = cmd-&gt;tag;
++	ev-&gt;k.cmd_req.tag = tag;
+ 
+-	dprintk(&quot;%d %u %u\n&quot;, ev-&gt;k.cmd_req.host_no, ev-&gt;k.cmd_req.cid,
+-		ev-&gt;k.cmd_req.data_len);
++	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev-&gt;k.cmd_req.cid,
++		ev-&gt;k.cmd_req.data_len, cmd-&gt;tag,
++		(unsigned long long) ev-&gt;k.cmd_req.tag);
+ 
+ 	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
+ 	if (err &lt; 0)
+@@ -109,6 +112,24 @@ int scsi_tgt_uspace_send_status(struct s
+ 	return send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev, gfp_mask, tgtd_pid);
+ }
+ 
++int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++				  struct scsi_lun *scsilun, void *data)
++{
++	struct tgt_event ev;
++
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.tsk_mgmt_req.host_no = host_no;
++	ev.k.tsk_mgmt_req.function = function;
++	ev.k.tsk_mgmt_req.tag = tag;
++	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
++	ev.k.tsk_mgmt_req.mid = (u64) data;
++
++	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
++		(unsigned long long) ev.k.tsk_mgmt_req.mid);
++
++	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev, GFP_KERNEL, tgtd_pid);
++}
++
+ static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+ {
+ 	struct tgt_event *ev = NLMSG_DATA(nlh);
+@@ -130,6 +151,11 @@ static int event_recv_msg(struct sk_buff
+ 					   ev-&gt;u.cmd_rsp.uaddr,
+ 					   ev-&gt;u.cmd_rsp.rw);
+ 		break;
++	case TGT_UEVENT_TSK_MGMT_RSP:
++		err = scsi_tgt_kspace_tsk_mgmt(ev-&gt;u.tsk_mgmt_rsp.host_no,
++					       ev-&gt;u.tsk_mgmt_rsp.mid,
++					       ev-&gt;u.tsk_mgmt_rsp.result);
++		break;
+ 	default:
+ 		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
+ 		err = -EINVAL;
+@@ -143,6 +169,7 @@ static int event_recv_skb(struct sk_buff
+ 	int err;
+ 	uint32_t rlen;
+ 	struct nlmsghdr	*nlh;
++	struct tgt_event ev;
+ 
+ 	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
+ 		nlh = (struct nlmsghdr *) skb-&gt;data;
+@@ -158,9 +185,11 @@ static int event_recv_skb(struct sk_buff
+ 		 * TODO for passthru commands the lower level should
+ 		 * probably handle the result or we should modify this
+ 		 */
+-		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMD_RSP) {
+-			struct tgt_event ev;
+-
++		switch (nlh-&gt;nlmsg_type) {
++		case TGT_UEVENT_CMD_RSP:
++		case TGT_UEVENT_TSK_MGMT_RSP:
++			break;
++		default:
+ 			memset(&amp;ev, 0, sizeof(ev));
+ 			ev.k.event_rsp.err = err;
+ 			send_event_rsp(TGT_KEVENT_RSP, &amp;ev,
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index 2cbc749..5a98fc4 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -49,6 +49,7 @@ struct scsi_tgt_cmd {
+ 
+ 	struct list_head hash_list;
+ 	struct request *rq;
++	u64 tag;
+ };
+ 
+ #define TGT_HASH_ORDER	4
+@@ -106,7 +107,6 @@ static void scsi_tgt_cmd_destroy(void *d
+ 		cmd-&gt;request-&gt;flags &amp;= ~1UL;
+ 
+ 	scsi_unmap_user_pages(tcmd);
+-	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
+ 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+ 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
+ }
+@@ -118,19 +118,11 @@ static void init_scsi_tgt_cmd(struct req
+ 	struct list_head *head;
+ 	static u32 tag = 0;
+ 
+-	tcmd-&gt;lun = rq-&gt;end_io_data;
+-	bio_list_init(&amp;tcmd-&gt;xfer_list);
+-	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
+-
+ 	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
+ 	rq-&gt;tag = tag++;
+ 	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(rq-&gt;tag)];
+ 	list_add(&amp;tcmd-&gt;hash_list, head);
+ 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
+-
+-	tcmd-&gt;rq = rq;
+-	rq-&gt;end_io_data = tcmd;
+-	rq-&gt;flags |= REQ_DONTPREP;
+ }
+ 
+ static void scsi_tgt_uspace_send_fn(void *data)
+@@ -148,33 +140,22 @@ retry:
+ 	if (list_empty(&amp;qdata-&gt;cmd_req))
+ 		return;
+ 
+-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+-	if (!tcmd) {
+-		err = -ENOMEM;
+-		goto out;
+-	}
+-
+ 	mutex_lock(&amp;qdata-&gt;cmd_req_mutex);
+ 
+ 	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
+ 	if (list_empty(&amp;qdata-&gt;cmd_req)) {
+ 		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+ 		mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
+-		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+ 		goto out;
+ 	}
+ 	rq = list_entry_rq(qdata-&gt;cmd_req.next);
+ 	list_del_init(&amp;rq-&gt;queuelist);
+ 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+ 
+-	if ((rq-&gt;flags &amp; REQ_DONTPREP)) {
+-		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+-		tcmd = rq-&gt;end_io_data;
+-	} else
+-		init_scsi_tgt_cmd(rq, tcmd);
+-
++	tcmd = rq-&gt;end_io_data;
++	init_scsi_tgt_cmd(rq, tcmd);
+ 	cmd = rq-&gt;special;
+-	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, GFP_ATOMIC);
++	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, tcmd-&gt;tag, GFP_ATOMIC);
+ 	if (err &lt; 0) {
+ 		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
+ 
+@@ -266,20 +247,35 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+  * @scsilun:	scsi lun
+  * @noblock:	set to nonzero if the command should be queued
+  **/
+-void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+-			    int noblock)
++int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			   u64 tag)
+ {
+ 	struct request_queue *q = cmd-&gt;request-&gt;q;
+ 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
+ 	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd;
++
++	/*
++	 * It would be better to allocate scsi_tgt_cmd structure in
++	 * scsi_host_get_command and not to fail due to OOM.
++	 */
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		return -ENOMEM;
++	cmd-&gt;request-&gt;end_io_data = tcmd;
+ 
+-	cmd-&gt;request-&gt;end_io_data = scsilun;
++	bio_list_init(&amp;tcmd-&gt;xfer_list);
++	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
++	tcmd-&gt;lun = scsilun;
++	tcmd-&gt;tag = tag;
++	tcmd-&gt;rq = cmd-&gt;request;
+ 
+ 	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
+ 	list_add_tail(&amp;cmd-&gt;request-&gt;queuelist, &amp;qdata-&gt;cmd_req);
+ 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
+ 
+ 	queue_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work);
++	return 0;
+ }
+ EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
+ 
+@@ -293,12 +289,7 @@ static void scsi_tgt_cmd_done(struct scs
+ 
+ 	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
+ 
+-	/* don't we have to call this if result is set or not */
+-	if (cmd-&gt;result) {
+-		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
+-		return;
+-	}
+-
++	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
+ 	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
+ 	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
+ }
+@@ -495,6 +486,18 @@ static int scsi_tgt_copy_sense(struct sc
+ 	return 0;
+ }
+ 
++static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = host-&gt;hostt-&gt;eh_abort_handler(cmd);
++	if (err)
++		eprintk(&quot;fail to abort %p\n&quot;, cmd);
++
++	scsi_tgt_cmd_destroy(cmd);
++	return err;
++}
++
+ static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
+ {
+ 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
+@@ -545,6 +548,10 @@ int scsi_tgt_kspace_exec(int host_no, u3
+ 	dprintk(&quot;cmd %p result %d len %d bufflen %u %lu %x\n&quot;, cmd,
+ 		result, len, cmd-&gt;request_bufflen, rq_data_dir(rq), cmd-&gt;cmnd[0]);
+ 
++	if (result == TASK_ABORTED) {
++		scsi_tgt_abort_cmd(shost, cmd);
++		goto done;
++	}
+ 	/*
+ 	 * store the userspace values here, the working values are
+ 	 * in the request_* values
+@@ -585,6 +592,38 @@ done:
+ 	return err;
+ }
+ 
++int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
++			      struct scsi_lun *scsilun, void *data)
++{
++	int err;
++
++	/* TODO: need to retry if this fails. */
++	err = scsi_tgt_uspace_send_tsk_mgmt(shost-&gt;host_no, function,
++					    tag, scsilun, data);
++	if (err &lt; 0)
++		eprintk(&quot;The task management request lost!\n&quot;);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
++
++int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
++{
++	struct Scsi_Host *shost;
++	int err;
++
++	dprintk(&quot;%d %d %llx\n&quot;, host_no, result, (unsigned long long) mid);
++
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
++		return -EINVAL;
++	}
++	err = shost-&gt;hostt-&gt;tsk_mgmt_response(mid, result);
++	scsi_host_put(shost);
++
++	return err;
++}
++
+ static int __init scsi_tgt_init(void)
+ {
+ 	int err;
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+index 6fedcec..77a1d06 100644
+--- a/drivers/scsi/scsi_tgt_priv.h
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -4,18 +4,21 @@ struct Scsi_Host;
+ struct task_struct;
+ 
+ /* tmp - will replace with SCSI logging stuff */
+-#define dprintk(fmt, args...)					\
++#define eprintk(fmt, args...)					\
+ do {								\
+ 	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
+ } while (0)
+ 
+-#define eprintk dprintk
++#define dprintk eprintk
+ 
+ extern void scsi_tgt_if_exit(void);
+ extern int scsi_tgt_if_init(void);
+ 
+-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
++extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				u64 tag, gfp_t flags);
+ extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
+ extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
+ 				unsigned long uaddr, u8 rw);
+-
++extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
++					 struct scsi_lun *scsilun, void *data);
++extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8b799db..eca5721 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -153,6 +153,9 @@ struct scsi_host_template {
+ 	int (* transfer_data)(struct scsi_cmnd *,
+ 			      void (*done)(struct scsi_cmnd *));
+ 
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
+ 	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+index 91ad6bc..2d65be7 100644
+--- a/include/scsi/scsi_tgt.h
++++ b/include/scsi/scsi_tgt.h
+@@ -6,6 +6,8 @@ struct Scsi_Host;
+ struct scsi_cmnd;
+ struct scsi_lun;
+ 
+-extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
+ extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
+-extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
++extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+index ebca452..63b2e3a 100644
+--- a/include/scsi/scsi_tgt_if.h
++++ b/include/scsi/scsi_tgt_if.h
+@@ -52,7 +52,7 @@ struct tgt_event {
+ 		} cmd_rsp;
+ 		struct {
+ 			int host_no;
+-			int mid;
++			uint64_t mid;
+ 			int result;
+ 		} tsk_mgmt_rsp;
+ 	} u;
+@@ -69,6 +69,7 @@ struct tgt_event {
+ 			uint8_t scb[16];
+ 			uint8_t lun[8];
+ 			int attribute;
++			uint64_t tag;
+ 		} cmd_req;
+ 		struct {
+ 			int host_no;
+@@ -77,10 +78,10 @@ struct tgt_event {
+ 		} cmd_done;
+ 		struct {
+ 			int host_no;
+-			int mid;
++			int function;
+ 			uint64_t tag;
+ 			uint8_t lun[8];
+-			int function;
++			uint64_t mid;
+ 		} tsk_mgmt_req;
+ 	} k;
+ 
+-- 
+1.1.5

Deleted: branches/use-scsi-ml/patchset/broken-out/0010-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0010-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0010-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,246 +0,0 @@
-Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
-From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Date: 1143377151 +0900
-
----
-
- drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
- 1 files changed, 0 insertions(+), 227 deletions(-)
- delete mode 100644 drivers/scsi/ibmvscsi/srp.h
-
-acbd74e89dc7bcf4e2596800e46a19378db44641
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION &quot;16.a&quot;
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/broken-out/0010-scsi-tgt-add-NET-dependence-to-Kconfig.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0010-scsi-tgt-add-NET-dependence-to-Kconfig.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0010-scsi-tgt-add-NET-dependence-to-Kconfig.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -0,0 +1,32 @@
+Subject: [PATCH 10/10] scsi tgt: add NET dependence to Kconfig
+From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+
+&gt; From: &quot;Jun'ichi Nomura&quot; &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">j-nomura at ce.jp.nec.com</A>&gt;:
+
+scsi_tgt_if.c depends on CONFIG_NET for using netlink.
+So it would be nice if the Kconfig entry checks it.
+
+Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
+
+---
+
+ drivers/scsi/Kconfig |    2 +-
+ 1 files changed, 1 insertions(+), 1 deletions(-)
+
+731f4924dd33579ffa5ff45ad03b7b7e933f728b
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index d09c792..5b5eeb4 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -29,7 +29,7 @@ config SCSI
+ 
+ config SCSI_TGT
+ 	tristate &quot;SCSI target support&quot;
+-	depends on SCSI &amp;&amp; EXPERIMENTAL
++	depends on SCSI &amp;&amp; NET &amp;&amp; EXPERIMENTAL
+ 	---help---
+ 	  If you want to use SCSI target mode drivers enable this option.
+ 	  If you choose M, the module will be called scsi_tgt.
+-- 
+1.1.5

Deleted: branches/use-scsi-ml/patchset/broken-out/0011-scsi-tgt-add-task-management-function-support.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/0011-scsi-tgt-add-task-management-function-support.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/0011-scsi-tgt-add-task-management-function-support.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -1,461 +0,0 @@
-Subject: [PATCH] scsi tgt: add task management function support
-
-This patch addes task management function support to tgt. This
-assumes that all the previous patchsets are applied.
-
-- add callback to task management function to scsi_host_template
-structure. It is used notify LLDs of the completion of a TMF request.
-
-- this patch doesn't use a single queue for TMF requests and SCSI
-commands yet. We'll work on it later on.
-
-- when LLDs queue scsi commands to tgt (scsi_tgt_queue_command), they
-need to specify unique 'tag' for each command for ABORT_TASK.
-
-- when tgt aborts a command, it calls eh_abort_handler in
-scsi_host_template structure. Would be better to add
-tgt_eh_abort_handler for LLDs support target and initiator modes at
-the same time?
-
-tgt TMF works in the followings:
-
-- When LLDs queue scsi commands to tgt (scsi_tgt_queue_command), they
-need to specify unique 'tag' for each command.
-
-- LLDs call 'int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *host, int,
-u64 tag, struct scsi_lun *lun, void *data)'.
-
-- int (* tsk_mgmt_response)(u64 data, int result) is added to
-scsi_host_template.
-
-When an initiator sends a task management request, the LLD calls
-scsi_tgt_tsk_mgmt_request. the LLD can use whatever it wants for the
-data arg. The data arg is used later as the arg in the
-tsk_mgmt_response callback.
-
-tgt core just sends the task management request to user space
-(by using TGT_KEVENT_TSK_MGMT_REQ).
-
-In the case of ABORT_TASK, tgtd finds a single command to abort and
-sends TGT_UEVENT_CMD_RSP and TGT_UEVENT_TSK_MGMT_RSP events.
-
-tgt core calls eh_abort_handler for TGT_UEVENT_CMD_RSP and then
-tsk_mgmt_response for TGT_UEVENT_TSK_MGMT_RSP.
-
-If tgtd fails to find a command to abort, it sends only
-TGT_UEVENT_TSK_MGMT_RSP event (no TGT_UEVENT_CMD_RSP event).
-
-In the case of the rests task management function (like
-ABORT_TASK_SET), tgt needs to abort multiple commands. Thus, tgtd
-finds multiple commands to abort and sends multiple TGT_UEVENT_CMD_RSP
-events and a single TGT_UEVENT_TSK_MGMT_RSP event. tgt core calls
-eh_abort_handler multiple times and tsk_mgmt_response once.
-
-eh_abort_handler enables LLDs to safely free resource related with a
-command to abort.
-
-Signed-off-by: FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
-Signed-off-by: Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
-
----
-
- drivers/scsi/scsi_tgt_if.c   |   43 +++++++++++++++---
- drivers/scsi/scsi_tgt_lib.c  |  103 +++++++++++++++++++++++++++++-------------
- drivers/scsi/scsi_tgt_priv.h |   11 +++-
- include/scsi/scsi_host.h     |    3 +
- include/scsi/scsi_tgt.h      |    6 ++
- include/scsi/scsi_tgt_if.h   |    7 ++-
- 6 files changed, 125 insertions(+), 48 deletions(-)
-
-b9579b62f8d6309815a60da2e6f9a7638df074aa
-diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
-index a31c8d5..ba1b75b 100644
---- a/drivers/scsi/scsi_tgt_if.c
-+++ b/drivers/scsi/scsi_tgt_if.c
-@@ -56,7 +56,8 @@ static int send_event_rsp(uint16_t type,
- 	return netlink_unicast(nl_sk, skb, pid, 0);
- }
- 
--int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
-+int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
-+			 gfp_t flags)
- {
- 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
- 	struct sk_buff *skb;
-@@ -71,7 +72,7 @@ int scsi_tgt_uspace_send(struct scsi_cmn
- 	/*
- 	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
- 	 */
--	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
-+	skb = alloc_skb(NLMSG_SPACE(len), flags);
- 	if (!skb)
- 		return -ENOMEM;
- 
-@@ -85,9 +86,11 @@ int scsi_tgt_uspace_send(struct scsi_cmn
- 	memcpy(ev-&gt;k.cmd_req.scb, cmd-&gt;cmnd, sizeof(ev-&gt;k.cmd_req.scb));
- 	memcpy(ev-&gt;k.cmd_req.lun, lun, sizeof(ev-&gt;k.cmd_req.lun));
- 	ev-&gt;k.cmd_req.attribute = cmd-&gt;tag;
-+	ev-&gt;k.cmd_req.tag = tag;
- 
--	dprintk(&quot;%d %u %u\n&quot;, ev-&gt;k.cmd_req.host_no, ev-&gt;k.cmd_req.cid,
--		ev-&gt;k.cmd_req.data_len);
-+	dprintk(&quot;%p %d %u %u %x %llx\n&quot;, cmd, shost-&gt;host_no, ev-&gt;k.cmd_req.cid,
-+		ev-&gt;k.cmd_req.data_len, cmd-&gt;tag,
-+		(unsigned long long) ev-&gt;k.cmd_req.tag);
- 
- 	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
- 	if (err &lt; 0)
-@@ -109,6 +112,24 @@ int scsi_tgt_uspace_send_status(struct s
- 	return send_event_rsp(TGT_KEVENT_CMD_DONE, &amp;ev, gfp_mask, tgtd_pid);
- }
- 
-+int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+				  struct scsi_lun *scsilun, void *data)
-+{
-+	struct tgt_event ev;
-+
-+	memset(&amp;ev, 0, sizeof(ev));
-+	ev.k.tsk_mgmt_req.host_no = host_no;
-+	ev.k.tsk_mgmt_req.function = function;
-+	ev.k.tsk_mgmt_req.tag = tag;
-+	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-+	ev.k.tsk_mgmt_req.mid = (u64) data;
-+
-+	dprintk(&quot;%d %x %llx %llx\n&quot;, host_no, function, (unsigned long long) tag,
-+		(unsigned long long) ev.k.tsk_mgmt_req.mid);
-+
-+	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &amp;ev, GFP_KERNEL, tgtd_pid);
-+}
-+
- static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
- {
- 	struct tgt_event *ev = NLMSG_DATA(nlh);
-@@ -130,6 +151,11 @@ static int event_recv_msg(struct sk_buff
- 					   ev-&gt;u.cmd_rsp.uaddr,
- 					   ev-&gt;u.cmd_rsp.rw);
- 		break;
-+	case TGT_UEVENT_TSK_MGMT_RSP:
-+		err = scsi_tgt_kspace_tsk_mgmt(ev-&gt;u.tsk_mgmt_rsp.host_no,
-+					       ev-&gt;u.tsk_mgmt_rsp.mid,
-+					       ev-&gt;u.tsk_mgmt_rsp.result);
-+		break;
- 	default:
- 		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
- 		err = -EINVAL;
-@@ -143,6 +169,7 @@ static int event_recv_skb(struct sk_buff
- 	int err;
- 	uint32_t rlen;
- 	struct nlmsghdr	*nlh;
-+	struct tgt_event ev;
- 
- 	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
- 		nlh = (struct nlmsghdr *) skb-&gt;data;
-@@ -158,9 +185,11 @@ static int event_recv_skb(struct sk_buff
- 		 * TODO for passthru commands the lower level should
- 		 * probably handle the result or we should modify this
- 		 */
--		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMD_RSP) {
--			struct tgt_event ev;
--
-+		switch (nlh-&gt;nlmsg_type) {
-+		case TGT_UEVENT_CMD_RSP:
-+		case TGT_UEVENT_TSK_MGMT_RSP:
-+			break;
-+		default:
- 			memset(&amp;ev, 0, sizeof(ev));
- 			ev.k.event_rsp.err = err;
- 			send_event_rsp(TGT_KEVENT_RSP, &amp;ev,
-diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
-index 2cbc749..5a98fc4 100644
---- a/drivers/scsi/scsi_tgt_lib.c
-+++ b/drivers/scsi/scsi_tgt_lib.c
-@@ -49,6 +49,7 @@ struct scsi_tgt_cmd {
- 
- 	struct list_head hash_list;
- 	struct request *rq;
-+	u64 tag;
- };
- 
- #define TGT_HASH_ORDER	4
-@@ -106,7 +107,6 @@ static void scsi_tgt_cmd_destroy(void *d
- 		cmd-&gt;request-&gt;flags &amp;= ~1UL;
- 
- 	scsi_unmap_user_pages(tcmd);
--	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
- 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
- }
-@@ -118,19 +118,11 @@ static void init_scsi_tgt_cmd(struct req
- 	struct list_head *head;
- 	static u32 tag = 0;
- 
--	tcmd-&gt;lun = rq-&gt;end_io_data;
--	bio_list_init(&amp;tcmd-&gt;xfer_list);
--	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
--
- 	spin_lock_irqsave(&amp;qdata-&gt;cmd_hash_lock, flags);
- 	rq-&gt;tag = tag++;
- 	head = &amp;qdata-&gt;cmd_hash[cmd_hashfn(rq-&gt;tag)];
- 	list_add(&amp;tcmd-&gt;hash_list, head);
- 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_hash_lock, flags);
--
--	tcmd-&gt;rq = rq;
--	rq-&gt;end_io_data = tcmd;
--	rq-&gt;flags |= REQ_DONTPREP;
- }
- 
- static void scsi_tgt_uspace_send_fn(void *data)
-@@ -148,33 +140,22 @@ retry:
- 	if (list_empty(&amp;qdata-&gt;cmd_req))
- 		return;
- 
--	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
--	if (!tcmd) {
--		err = -ENOMEM;
--		goto out;
--	}
--
- 	mutex_lock(&amp;qdata-&gt;cmd_req_mutex);
- 
- 	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
- 	if (list_empty(&amp;qdata-&gt;cmd_req)) {
- 		spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
- 		mutex_unlock(&amp;qdata-&gt;cmd_req_mutex);
--		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
- 		goto out;
- 	}
- 	rq = list_entry_rq(qdata-&gt;cmd_req.next);
- 	list_del_init(&amp;rq-&gt;queuelist);
- 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
- 
--	if ((rq-&gt;flags &amp; REQ_DONTPREP)) {
--		kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
--		tcmd = rq-&gt;end_io_data;
--	} else
--		init_scsi_tgt_cmd(rq, tcmd);
--
-+	tcmd = rq-&gt;end_io_data;
-+	init_scsi_tgt_cmd(rq, tcmd);
- 	cmd = rq-&gt;special;
--	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, GFP_ATOMIC);
-+	err = scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, tcmd-&gt;tag, GFP_ATOMIC);
- 	if (err &lt; 0) {
- 		eprintk(&quot;failed to send: %p %d\n&quot;, cmd, err);
- 
-@@ -266,20 +247,35 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
-  * @scsilun:	scsi lun
-  * @noblock:	set to nonzero if the command should be queued
-  **/
--void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
--			    int noblock)
-+int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-+			   u64 tag)
- {
- 	struct request_queue *q = cmd-&gt;request-&gt;q;
- 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
- 	unsigned long flags;
-+	struct scsi_tgt_cmd *tcmd;
-+
-+	/*
-+	 * It would be better to allocate scsi_tgt_cmd structure in
-+	 * scsi_host_get_command and not to fail due to OOM.
-+	 */
-+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-+	if (!tcmd)
-+		return -ENOMEM;
-+	cmd-&gt;request-&gt;end_io_data = tcmd;
- 
--	cmd-&gt;request-&gt;end_io_data = scsilun;
-+	bio_list_init(&amp;tcmd-&gt;xfer_list);
-+	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
-+	tcmd-&gt;lun = scsilun;
-+	tcmd-&gt;tag = tag;
-+	tcmd-&gt;rq = cmd-&gt;request;
- 
- 	spin_lock_irqsave(&amp;qdata-&gt;cmd_req_lock, flags);
- 	list_add_tail(&amp;cmd-&gt;request-&gt;queuelist, &amp;qdata-&gt;cmd_req);
- 	spin_unlock_irqrestore(&amp;qdata-&gt;cmd_req_lock, flags);
- 
- 	queue_work(scsi_tgtd, &amp;qdata-&gt;uspace_send_work);
-+	return 0;
- }
- EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
- 
-@@ -293,12 +289,7 @@ static void scsi_tgt_cmd_done(struct scs
- 
- 	dprintk(&quot;cmd %p %lu\n&quot;, cmd, rq_data_dir(cmd-&gt;request));
- 
--	/* don't we have to call this if result is set or not */
--	if (cmd-&gt;result) {
--		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
--		return;
--	}
--
-+	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
- 	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
- 	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
- }
-@@ -495,6 +486,18 @@ static int scsi_tgt_copy_sense(struct sc
- 	return 0;
- }
- 
-+static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
-+{
-+	int err;
-+
-+	err = host-&gt;hostt-&gt;eh_abort_handler(cmd);
-+	if (err)
-+		eprintk(&quot;fail to abort %p\n&quot;, cmd);
-+
-+	scsi_tgt_cmd_destroy(cmd);
-+	return err;
-+}
-+
- static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
- {
- 	struct scsi_tgt_queuedata *qdata = q-&gt;queuedata;
-@@ -545,6 +548,10 @@ int scsi_tgt_kspace_exec(int host_no, u3
- 	dprintk(&quot;cmd %p result %d len %d bufflen %u %lu %x\n&quot;, cmd,
- 		result, len, cmd-&gt;request_bufflen, rq_data_dir(rq), cmd-&gt;cmnd[0]);
- 
-+	if (result == TASK_ABORTED) {
-+		scsi_tgt_abort_cmd(shost, cmd);
-+		goto done;
-+	}
- 	/*
- 	 * store the userspace values here, the working values are
- 	 * in the request_* values
-@@ -585,6 +592,38 @@ done:
- 	return err;
- }
- 
-+int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
-+			      struct scsi_lun *scsilun, void *data)
-+{
-+	int err;
-+
-+	/* TODO: need to retry if this fails. */
-+	err = scsi_tgt_uspace_send_tsk_mgmt(shost-&gt;host_no, function,
-+					    tag, scsilun, data);
-+	if (err &lt; 0)
-+		eprintk(&quot;The task management request lost!\n&quot;);
-+	return err;
-+}
-+EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
-+
-+int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
-+{
-+	struct Scsi_Host *shost;
-+	int err;
-+
-+	dprintk(&quot;%d %d %llx\n&quot;, host_no, result, (unsigned long long) mid);
-+
-+	shost = scsi_host_lookup(host_no);
-+	if (IS_ERR(shost)) {
-+		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
-+		return -EINVAL;
-+	}
-+	err = shost-&gt;hostt-&gt;tsk_mgmt_response(mid, result);
-+	scsi_host_put(shost);
-+
-+	return err;
-+}
-+
- static int __init scsi_tgt_init(void)
- {
- 	int err;
-diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
-index 6fedcec..77a1d06 100644
---- a/drivers/scsi/scsi_tgt_priv.h
-+++ b/drivers/scsi/scsi_tgt_priv.h
-@@ -4,18 +4,21 @@ struct Scsi_Host;
- struct task_struct;
- 
- /* tmp - will replace with SCSI logging stuff */
--#define dprintk(fmt, args...)					\
-+#define eprintk(fmt, args...)					\
- do {								\
- 	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
- } while (0)
- 
--#define eprintk dprintk
-+#define dprintk eprintk
- 
- extern void scsi_tgt_if_exit(void);
- extern int scsi_tgt_if_init(void);
- 
--extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
-+extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-+				u64 tag, gfp_t flags);
- extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
- extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
- 				unsigned long uaddr, u8 rw);
--
-+extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
-+					 struct scsi_lun *scsilun, void *data);
-+extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index 8b799db..eca5721 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -153,6 +153,9 @@ struct scsi_host_template {
- 	int (* transfer_data)(struct scsi_cmnd *,
- 			      void (*done)(struct scsi_cmnd *));
- 
-+	/* Used as callback for the completion of task management request. */
-+	int (* tsk_mgmt_response)(u64 mid, int result);
-+
- 	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-index 91ad6bc..2d65be7 100644
---- a/include/scsi/scsi_tgt.h
-+++ b/include/scsi/scsi_tgt.h
-@@ -6,6 +6,8 @@ struct Scsi_Host;
- struct scsi_cmnd;
- struct scsi_lun;
- 
--extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
- extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
--extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
-+extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
-+extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
-+				     void *);
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-index ebca452..63b2e3a 100644
---- a/include/scsi/scsi_tgt_if.h
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -52,7 +52,7 @@ struct tgt_event {
- 		} cmd_rsp;
- 		struct {
- 			int host_no;
--			int mid;
-+			uint64_t mid;
- 			int result;
- 		} tsk_mgmt_rsp;
- 	} u;
-@@ -69,6 +69,7 @@ struct tgt_event {
- 			uint8_t scb[16];
- 			uint8_t lun[8];
- 			int attribute;
-+			uint64_t tag;
- 		} cmd_req;
- 		struct {
- 			int host_no;
-@@ -77,10 +78,10 @@ struct tgt_event {
- 		} cmd_done;
- 		struct {
- 			int host_no;
--			int mid;
-+			int function;
- 			uint64_t tag;
- 			uint8_t lun[8];
--			int function;
-+			uint64_t mid;
- 		} tsk_mgmt_req;
- 	} k;
- 
--- 
-1.1.3

Added: branches/use-scsi-ml/patchset/broken-out/srp/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/srp/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/srp/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -0,0 +1,582 @@
+Subject: [PATCH 1/2] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
+From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+
+---
+
+ drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
+ drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
+ drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
+ drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
+ 4 files changed, 142 insertions(+), 125 deletions(-)
+
+74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
+index eaefedd..e7bd028 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
+@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
+ 			++in_use;
+ 		if (pool-&gt;events[i].ext_list) {
+ 			dma_free_coherent(hostdata-&gt;dev,
+-				  SG_ALL * sizeof(struct memory_descriptor),
++				  SG_ALL * sizeof(struct srp_direct_buf),
+ 				  pool-&gt;events[i].ext_list,
+ 				  pool-&gt;events[i].ext_list_token);
+ 		}
+@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
+ 			      struct srp_cmd *srp_cmd, 
+ 			      int numbuf)
+ {
++	u8 fmt;
++
+ 	if (numbuf == 0)
+ 		return;
+ 	
+-	if (numbuf == 1) {
++	if (numbuf == 1)
++		fmt = SRP_DATA_DESC_DIRECT;
++	else {
++		fmt = SRP_DATA_DESC_INDIRECT;
++		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
++
+ 		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
+-			srp_cmd-&gt;data_out_format = SRP_DIRECT_BUFFER;
+-		else 
+-			srp_cmd-&gt;data_in_format = SRP_DIRECT_BUFFER;
+-	} else {
+-		if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE) {
+-			srp_cmd-&gt;data_out_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd-&gt;data_out_count =
+-				numbuf &lt; MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		} else {
+-			srp_cmd-&gt;data_in_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd-&gt;data_in_count =
+-				numbuf &lt; MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		}
++			srp_cmd-&gt;data_out_desc_cnt = numbuf;
++		else
++			srp_cmd-&gt;data_in_desc_cnt = numbuf;
+ 	}
++
++	if (cmd-&gt;sc_data_direction == DMA_TO_DEVICE)
++		srp_cmd-&gt;buf_fmt = fmt &lt;&lt; 4;
++	else
++		srp_cmd-&gt;buf_fmt = fmt;
+ }
+ 
+-static void unmap_sg_list(int num_entries, 
++static void unmap_sg_list(int num_entries,
+ 		struct device *dev,
+-		struct memory_descriptor *md)
+-{ 
++		struct srp_direct_buf *md)
++{
+ 	int i;
+ 
+-	for (i = 0; i &lt; num_entries; ++i) {
+-		dma_unmap_single(dev,
+-			md[i].virtual_address,
+-			md[i].length, DMA_BIDIRECTIONAL);
+-	}
++	for (i = 0; i &lt; num_entries; ++i)
++		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
+ }
+ 
+ /**
+@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
+ 			   struct srp_event_struct *evt_struct,
+ 			   struct device *dev)
+ {
+-	if ((cmd-&gt;data_out_format == SRP_NO_BUFFER) &amp;&amp;
+-	    (cmd-&gt;data_in_format == SRP_NO_BUFFER))
++	u8 out_fmt, in_fmt;
++
++	out_fmt = cmd-&gt;buf_fmt &gt;&gt; 4;
++	in_fmt = cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++
++	if (out_fmt == SRP_NO_DATA_DESC &amp;&amp; in_fmt == SRP_NO_DATA_DESC)
+ 		return;
+-	else if ((cmd-&gt;data_out_format == SRP_DIRECT_BUFFER) ||
+-		 (cmd-&gt;data_in_format == SRP_DIRECT_BUFFER)) {
+-		struct memory_descriptor *data =
+-			(struct memory_descriptor *)cmd-&gt;additional_data;
+-		dma_unmap_single(dev, data-&gt;virtual_address, data-&gt;length,
+-				 DMA_BIDIRECTIONAL);
++	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
++		 in_fmt == SRP_DATA_DESC_DIRECT) {
++		struct srp_direct_buf *data =
++			(struct srp_direct_buf *) cmd-&gt;add_data;
++		dma_unmap_single(dev, data-&gt;va, data-&gt;len, DMA_BIDIRECTIONAL);
+ 	} else {
+-		struct indirect_descriptor *indirect =
+-			(struct indirect_descriptor *)cmd-&gt;additional_data;
+-		int num_mapped = indirect-&gt;head.length / 
+-			sizeof(indirect-&gt;list[0]);
++		struct srp_indirect_buf *indirect =
++			(struct srp_indirect_buf *) cmd-&gt;add_data;
++		int num_mapped = indirect-&gt;table_desc.len /
++			sizeof(struct srp_direct_buf);
+ 
+ 		if (num_mapped &lt;= MAX_INDIRECT_BUFS) {
+-			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;list[0]);
++			unmap_sg_list(num_mapped, dev, &amp;indirect-&gt;desc_list[0]);
+ 			return;
+ 		}
+ 
+@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
+ 
+ static int map_sg_list(int num_entries, 
+ 		       struct scatterlist *sg,
+-		       struct memory_descriptor *md)
++		       struct srp_direct_buf *md)
+ {
+ 	int i;
+ 	u64 total_length = 0;
+ 
+ 	for (i = 0; i &lt; num_entries; ++i) {
+-		struct memory_descriptor *descr = md + i;
++		struct srp_direct_buf *descr = md + i;
+ 		struct scatterlist *sg_entry = &amp;sg[i];
+-		descr-&gt;virtual_address = sg_dma_address(sg_entry);
+-		descr-&gt;length = sg_dma_len(sg_entry);
+-		descr-&gt;memory_handle = 0;
++		descr-&gt;va = sg_dma_address(sg_entry);
++		descr-&gt;len = sg_dma_len(sg_entry);
++		descr-&gt;key = 0;
+ 		total_length += sg_dma_len(sg_entry);
+  	}
+ 	return total_length;
+@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
+ 	int sg_mapped;
+ 	u64 total_length = 0;
+ 	struct scatterlist *sg = cmd-&gt;request_buffer;
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
+-	struct indirect_descriptor *indirect =
+-	    (struct indirect_descriptor *)data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
++	struct srp_indirect_buf *indirect =
++		(struct srp_indirect_buf *) data;
+ 
+ 	sg_mapped = dma_map_sg(dev, sg, cmd-&gt;use_sg, DMA_BIDIRECTIONAL);
+ 
+@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	/* special case; we can use a single direct descriptor */
+ 	if (sg_mapped == 1) {
+-		data-&gt;virtual_address = sg_dma_address(&amp;sg[0]);
+-		data-&gt;length = sg_dma_len(&amp;sg[0]);
+-		data-&gt;memory_handle = 0;
++		data-&gt;va = sg_dma_address(&amp;sg[0]);
++		data-&gt;len = sg_dma_len(&amp;sg[0]);
++		data-&gt;key = 0;
+ 		return 1;
+ 	}
+ 
+@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
+ 		return 0;
+ 	}
+ 
+-	indirect-&gt;head.virtual_address = 0;
+-	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
+-	indirect-&gt;head.memory_handle = 0;
++	indirect-&gt;table_desc.va = 0;
++	indirect-&gt;table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
++	indirect-&gt;table_desc.key = 0;
+ 
+ 	if (sg_mapped &lt;= MAX_INDIRECT_BUFS) {
+-		total_length = map_sg_list(sg_mapped, sg, &amp;indirect-&gt;list[0]);
+-		indirect-&gt;total_length = total_length;
++		total_length = map_sg_list(sg_mapped, sg,
++					   &amp;indirect-&gt;desc_list[0]);
++		indirect-&gt;len = total_length;
+ 		return 1;
+ 	}
+ 
+ 	/* get indirect table */
+ 	if (!evt_struct-&gt;ext_list) {
+-		evt_struct-&gt;ext_list =(struct memory_descriptor*)
++		evt_struct-&gt;ext_list = (struct srp_direct_buf *)
+ 			dma_alloc_coherent(dev, 
+-				SG_ALL * sizeof(struct memory_descriptor),
+-				&amp;evt_struct-&gt;ext_list_token, 0);
++					   SG_ALL * sizeof(struct srp_direct_buf),
++					   &amp;evt_struct-&gt;ext_list_token, 0);
+ 		if (!evt_struct-&gt;ext_list) {
+-		    printk(KERN_ERR
+-		   	&quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
++			printk(KERN_ERR
++			       &quot;ibmvscsi: Can't allocate memory for indirect table\n&quot;);
+ 			return 0;
+ 			
+ 		}
+@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	total_length = map_sg_list(sg_mapped, sg, evt_struct-&gt;ext_list);	
+ 
+-	indirect-&gt;total_length = total_length;
+-	indirect-&gt;head.virtual_address = evt_struct-&gt;ext_list_token;
+-	indirect-&gt;head.length = sg_mapped * sizeof(indirect-&gt;list[0]);
+-	memcpy(indirect-&gt;list, evt_struct-&gt;ext_list,
+-		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
++	indirect-&gt;len = total_length;
++	indirect-&gt;table_desc.va = evt_struct-&gt;ext_list_token;
++	indirect-&gt;table_desc.len = sg_mapped * sizeof(indirect-&gt;desc_list[0]);
++	memcpy(indirect-&gt;desc_list, evt_struct-&gt;ext_list,
++	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
+ 	
+  	return 1;
+ }
+@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
+ static int map_single_data(struct scsi_cmnd *cmd,
+ 			   struct srp_cmd *srp_cmd, struct device *dev)
+ {
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd-&gt;additional_data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd-&gt;add_data;
+ 
+-	data-&gt;virtual_address =
++	data-&gt;va =
+ 		dma_map_single(dev, cmd-&gt;request_buffer,
+ 			       cmd-&gt;request_bufflen,
+ 			       DMA_BIDIRECTIONAL);
+-	if (dma_mapping_error(data-&gt;virtual_address)) {
++	if (dma_mapping_error(data-&gt;va)) {
+ 		printk(KERN_ERR
+ 		       &quot;ibmvscsi: Unable to map request_buffer for command!\n&quot;);
+ 		return 0;
+ 	}
+-	data-&gt;length = cmd-&gt;request_bufflen;
+-	data-&gt;memory_handle = 0;
++	data-&gt;len = cmd-&gt;request_bufflen;
++	data-&gt;key = 0;
+ 
+ 	set_srp_direction(cmd, srp_cmd, 1);
+ 
+@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
+ 
+ 	/* Copy the IU into the transfer area */
+ 	*evt_struct-&gt;xfer_iu = evt_struct-&gt;iu;
+-	evt_struct-&gt;xfer_iu-&gt;srp.generic.tag = (u64)evt_struct;
++	evt_struct-&gt;xfer_iu-&gt;srp.rsp.tag = (u64)evt_struct;
+ 
+ 	/* Add this to the sent list.  We need to do this 
+ 	 * before we actually send 
+@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
+ 	struct srp_rsp *rsp = &amp;evt_struct-&gt;xfer_iu-&gt;srp.rsp;
+ 	struct scsi_cmnd *cmnd = evt_struct-&gt;cmnd;
+ 
+-	if (unlikely(rsp-&gt;type != SRP_RSP_TYPE)) {
++	if (unlikely(rsp-&gt;opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: bad SRP RSP type %d\n&quot;,
+-			       rsp-&gt;type);
++			       rsp-&gt;opcode);
+ 	}
+ 	
+ 	if (cmnd) {
+ 		cmnd-&gt;result = rsp-&gt;status;
+ 		if (((cmnd-&gt;result &gt;&gt; 1) &amp; 0x1f) == CHECK_CONDITION)
+ 			memcpy(cmnd-&gt;sense_buffer,
+-			       rsp-&gt;sense_and_response_data,
+-			       rsp-&gt;sense_data_list_length);
++			       rsp-&gt;data,
++			       rsp-&gt;sense_data_len);
+ 		unmap_cmd_data(&amp;evt_struct-&gt;iu.srp.cmd, 
+ 			       evt_struct, 
+ 			       evt_struct-&gt;hostdata-&gt;dev);
+ 
+-		if (rsp-&gt;doover)
+-			cmnd-&gt;resid = rsp-&gt;data_out_residual_count;
+-		else if (rsp-&gt;diover)
+-			cmnd-&gt;resid = rsp-&gt;data_in_residual_count;
++		if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DOOVER)
++			cmnd-&gt;resid = rsp-&gt;data_out_res_cnt;
++		else if (rsp-&gt;flags &amp; SRP_RSP_FLAG_DIOVER)
++			cmnd-&gt;resid = rsp-&gt;data_in_res_cnt;
+ 	}
+ 
+ 	if (evt_struct-&gt;cmnd_done)
+@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
+ {
+ 	struct srp_cmd *srp_cmd;
+ 	struct srp_event_struct *evt_struct;
+-	struct indirect_descriptor *indirect;
++	struct srp_indirect_buf *indirect;
+ 	struct ibmvscsi_host_data *hostdata =
+ 		(struct ibmvscsi_host_data *)&amp;cmnd-&gt;device-&gt;host-&gt;hostdata;
+ 	u16 lun = lun_from_dev(cmnd-&gt;device);
++	u8 out_fmt, in_fmt;
+ 
+ 	evt_struct = get_event_struct(&amp;hostdata-&gt;pool);
+ 	if (!evt_struct)
+@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
+ 
+ 	/* Set up the actual SRP IU */
+ 	srp_cmd = &amp;evt_struct-&gt;iu.srp.cmd;
+-	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
+-	srp_cmd-&gt;type = SRP_CMD_TYPE;
++	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
++	srp_cmd-&gt;opcode = SRP_CMD;
+ 	memcpy(srp_cmd-&gt;cdb, cmnd-&gt;cmnd, sizeof(cmnd-&gt;cmnd));
+ 	srp_cmd-&gt;lun = ((u64) lun) &lt;&lt; 48;
+ 
+@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
+ 	evt_struct-&gt;cmnd_done = done;
+ 
+ 	/* Fix up dma address of the buffer itself */
+-	indirect = (struct indirect_descriptor *)srp_cmd-&gt;additional_data;
+-	if (((srp_cmd-&gt;data_out_format == SRP_INDIRECT_BUFFER) ||
+-	    (srp_cmd-&gt;data_in_format == SRP_INDIRECT_BUFFER)) &amp;&amp;
+-	    (indirect-&gt;head.virtual_address == 0)) {
+-		indirect-&gt;head.virtual_address = evt_struct-&gt;crq.IU_data_ptr +
+-		    offsetof(struct srp_cmd, additional_data) +
+-		    offsetof(struct indirect_descriptor, list);
++	indirect = (struct srp_indirect_buf *) srp_cmd-&gt;add_data;
++	out_fmt = srp_cmd-&gt;buf_fmt &gt;&gt; 4;
++	in_fmt = srp_cmd-&gt;buf_fmt &amp; ((1U &lt;&lt; 4) - 1);
++	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
++	     out_fmt == SRP_DATA_DESC_INDIRECT) &amp;&amp;
++	    indirect-&gt;table_desc.va == 0) {
++		indirect-&gt;table_desc.va = evt_struct-&gt;crq.IU_data_ptr +
++			offsetof(struct srp_cmd, add_data) +
++			offsetof(struct srp_indirect_buf, desc_list);
+ 	}
+ 
+ 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
+@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
+ static void login_rsp(struct srp_event_struct *evt_struct)
+ {
+ 	struct ibmvscsi_host_data *hostdata = evt_struct-&gt;hostdata;
+-	switch (evt_struct-&gt;xfer_iu-&gt;srp.generic.type) {
+-	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
++	switch (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode) {
++	case SRP_LOGIN_RSP:	/* it worked! */
+ 		break;
+-	case SRP_LOGIN_REJ_TYPE:	/* refused! */
++	case SRP_LOGIN_REJ:	/* refused! */
+ 		printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN_REJ reason %u\n&quot;,
+ 		       evt_struct-&gt;xfer_iu-&gt;srp.login_rej.reason);
+ 		/* Login failed.  */
+@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
+ 	default:
+ 		printk(KERN_ERR
+ 		       &quot;ibmvscsi: Invalid login response typecode 0x%02x!\n&quot;,
+-		       evt_struct-&gt;xfer_iu-&gt;srp.generic.type);
++		       evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.opcode);
+ 		/* Login failed.  */
+ 		atomic_set(&amp;hostdata-&gt;request_limit, -1);
+ 		return;
+@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: SRP_LOGIN succeeded\n&quot;);
+ 
+-	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta &gt;
++	if (evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta &gt;
+ 	    (max_requests - 2))
+-		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta =
++		evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta =
+ 		    max_requests - 2;
+ 
+ 	/* Now we know what the real request-limit is */
+ 	atomic_set(&amp;hostdata-&gt;request_limit,
+-		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta);
++		   evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta);
+ 
+ 	hostdata-&gt;host-&gt;can_queue =
+-	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.request_limit_delta - 2;
++	    evt_struct-&gt;xfer_iu-&gt;srp.login_rsp.req_lim_delta - 2;
+ 
+ 	if (hostdata-&gt;host-&gt;can_queue &lt; 1) {
+ 		printk(KERN_ERR &quot;ibmvscsi: Invalid request_limit_delta\n&quot;);
+@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
+ 
+ 	login = &amp;evt_struct-&gt;iu.srp.login_req;
+ 	memset(login, 0x00, sizeof(struct srp_login_req));
+-	login-&gt;type = SRP_LOGIN_REQ_TYPE;
+-	login-&gt;max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
+-	login-&gt;required_buffer_formats = 0x0006;
++	login-&gt;opcode = SRP_LOGIN_REQ;
++	login-&gt;req_it_iu_len = sizeof(union srp_iu);
++	login-&gt;req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
+ 	
+ 	/* Start out with a request limit of 1, since this is negotiated in
+ 	 * the login request we are just sending
+@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 	
+ 	/* Set up an abort SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
+-	tsk_mgmt-&gt;task_mgmt_flags = 0x01;	/* ABORT TASK */
+-	tsk_mgmt-&gt;managed_task_tag = (u64) found_evt;
++	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_ABORT_TASK;
++	tsk_mgmt-&gt;task_tag = (u64) found_evt;
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n&quot;,
+-	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;managed_task_tag);
++	       tsk_mgmt-&gt;lun, tsk_mgmt-&gt;task_tag);
+ 
+ 	evt-&gt;sync_srp = &amp;srp_rsp;
+ 	init_completion(&amp;evt-&gt;comp);
+@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
+ 	wait_for_completion(&amp;evt-&gt;comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: abort bad SRP RSP type %d\n&quot;,
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+ 	if (rsp_rc) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+-		       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
++			       &quot;ibmvscsi: abort code %d for task tag 0x%lx\n&quot;,
+ 			       rsp_rc,
+-			       tsk_mgmt-&gt;managed_task_tag);
++			       tsk_mgmt-&gt;task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 		spin_unlock_irqrestore(hostdata-&gt;host-&gt;host_lock, flags);
+ 		printk(KERN_INFO
+ 		       &quot;ibmvscsi: aborted task tag 0x%lx completed\n&quot;,
+-		       tsk_mgmt-&gt;managed_task_tag);
++		       tsk_mgmt-&gt;task_tag);
+ 		return SUCCESS;
+ 	}
+ 
+ 	printk(KERN_INFO
+ 	       &quot;ibmvscsi: successfully aborted task tag 0x%lx\n&quot;,
+-	       tsk_mgmt-&gt;managed_task_tag);
++	       tsk_mgmt-&gt;task_tag);
+ 
+ 	cmd-&gt;result = (DID_ABORT &lt;&lt; 16);
+ 	list_del(&amp;found_evt-&gt;list);
+@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
+ 
+ 	/* Set up a lun reset SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt-&gt;type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt-&gt;opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt-&gt;lun = ((u64) lun) &lt;&lt; 48;
+-	tsk_mgmt-&gt;task_mgmt_flags = 0x08;	/* LUN RESET */
++	tsk_mgmt-&gt;tsk_mgmt_func = SRP_TSK_LUN_RESET;
+ 
+ 	printk(KERN_INFO &quot;ibmvscsi: resetting device. lun 0x%lx\n&quot;,
+ 	       tsk_mgmt-&gt;lun);
+@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
+ 	wait_for_completion(&amp;evt-&gt;comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: reset bad SRP RSP type %d\n&quot;,
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags &amp; SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       &quot;ibmvscsi: reset code %d for task tag 0x%lx\n&quot;,
+-		       rsp_rc,
+-			       tsk_mgmt-&gt;managed_task_tag);
++			       rsp_rc, tsk_mgmt-&gt;task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
+ 	}
+ 
+ 	if (crq-&gt;format == VIOSRP_SRP_FORMAT)
+-		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.request_limit_delta,
++		atomic_add(evt_struct-&gt;xfer_iu-&gt;srp.rsp.req_lim_delta,
+ 			   &amp;hostdata-&gt;request_limit);
+ 
+ 	if (evt_struct-&gt;done)
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
+index 4550d71..5c6d935 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.h
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
+@@ -68,7 +68,7 @@ struct srp_event_struct {
+ 	void (*cmnd_done) (struct scsi_cmnd *);
+ 	struct completion comp;
+ 	union viosrp_iu *sync_srp;
+-	struct memory_descriptor *ext_list;
++	struct srp_direct_buf *ext_list;
+ 	dma_addr_t ext_list_token;
+ };
+ 
+diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+index f47dd87..58aa530 100644
+--- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
++++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+@@ -34,7 +34,6 @@
+ #include &lt;linux/dma-mapping.h&gt;
+ #include &lt;linux/interrupt.h&gt;
+ #include &quot;ibmvscsi.h&quot;
+-#include &quot;srp.h&quot;
+ 
+ static char partition_name[97] = &quot;UNKNOWN&quot;;
+ static unsigned int partition_number = -1;
+diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
+index 6a6bba8..90f1a61 100644
+--- a/drivers/scsi/ibmvscsi/viosrp.h
++++ b/drivers/scsi/ibmvscsi/viosrp.h
+@@ -33,7 +33,22 @@
+ /*****************************************************************************/
+ #ifndef VIOSRP_H
+ #define VIOSRP_H
+-#include &quot;srp.h&quot;
++#include &lt;scsi/srp.h&gt;
++
++#define SRP_VERSION &quot;16.a&quot;
++#define SRP_MAX_IU_LEN	256
++
++union srp_iu {
++	struct srp_login_req login_req;
++	struct srp_login_rsp login_rsp;
++	struct srp_login_rej login_rej;
++	struct srp_i_logout i_logout;
++	struct srp_t_logout t_logout;
++	struct srp_tsk_mgmt tsk_mgmt;
++	struct srp_cmd cmd;
++	struct srp_rsp rsp;
++	u8 reserved[SRP_MAX_IU_LEN];
++};
+ 
+ enum viosrp_crq_formats {
+ 	VIOSRP_SRP_FORMAT = 0x01,
+-- 
+1.1.5

Added: branches/use-scsi-ml/patchset/broken-out/srp/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- branches/use-scsi-ml/patchset/broken-out/srp/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-04-07 01:39:11 UTC (rev 397)
+++ branches/use-scsi-ml/patchset/broken-out/srp/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-04-08 01:22:48 UTC (rev 398)
@@ -0,0 +1,245 @@
+Subject: [PATCH 2/2] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
+From: FUJITA &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">fujita.tomonori at lab.ntt.co.jp</A>&gt;
+
+---
+
+ drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
+ 1 files changed, 0 insertions(+), 227 deletions(-)
+ delete mode 100644 drivers/scsi/ibmvscsi/srp.h
+
+acbd74e89dc7bcf4e2596800e46a19378db44641
+diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
+deleted file mode 100644
+index 7d8e4c4..0000000
+--- a/drivers/scsi/ibmvscsi/srp.h
++++ /dev/null
+@@ -1,227 +0,0 @@
+-/*****************************************************************************/
+-/* srp.h -- SCSI RDMA Protocol definitions                                   */
+-/*                                                                           */
+-/* Written By: Colin Devilbis, IBM Corporation                               */
+-/*                                                                           */
+-/* Copyright (C) 2003 IBM Corporation                                        */
+-/*                                                                           */
+-/* This program is free software; you can redistribute it and/or modify      */
+-/* it under the terms of the GNU General Public License as published by      */
+-/* the Free Software Foundation; either version 2 of the License, or         */
+-/* (at your option) any later version.                                       */
+-/*                                                                           */
+-/* This program is distributed in the hope that it will be useful,           */
+-/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
+-/* GNU General Public License for more details.                              */
+-/*                                                                           */
+-/* You should have received a copy of the GNU General Public License         */
+-/* along with this program; if not, write to the Free Software               */
+-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+-/*                                                                           */
+-/*                                                                           */
+-/* This file contains structures and definitions for the SCSI RDMA Protocol  */
+-/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
+-/* file was based on the 16a version of the standard                         */
+-/*                                                                           */
+-/*****************************************************************************/
+-#ifndef SRP_H
+-#define SRP_H
+-
+-#define SRP_VERSION &quot;16.a&quot;
+-
+-#define PACKED __attribute__((packed))
+-
+-enum srp_types {
+-	SRP_LOGIN_REQ_TYPE = 0x00,
+-	SRP_LOGIN_RSP_TYPE = 0xC0,
+-	SRP_LOGIN_REJ_TYPE = 0xC2,
+-	SRP_I_LOGOUT_TYPE = 0x03,
+-	SRP_T_LOGOUT_TYPE = 0x80,
+-	SRP_TSK_MGMT_TYPE = 0x01,
+-	SRP_CMD_TYPE = 0x02,
+-	SRP_RSP_TYPE = 0xC1,
+-	SRP_CRED_REQ_TYPE = 0x81,
+-	SRP_CRED_RSP_TYPE = 0x41,
+-	SRP_AER_REQ_TYPE = 0x82,
+-	SRP_AER_RSP_TYPE = 0x42
+-};
+-
+-enum srp_descriptor_formats {
+-	SRP_NO_BUFFER = 0x00,
+-	SRP_DIRECT_BUFFER = 0x01,
+-	SRP_INDIRECT_BUFFER = 0x02
+-};
+-
+-struct memory_descriptor {
+-	u64 virtual_address;
+-	u32 memory_handle;
+-	u32 length;
+-};
+-
+-struct indirect_descriptor {
+-	struct memory_descriptor head;
+-	u32 total_length;
+-	struct memory_descriptor list[1] PACKED;
+-};
+-
+-struct srp_generic {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_login_req {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 max_requested_initiator_to_target_iulen;
+-	u32 reserved2;
+-	u16 required_buffer_formats;
+-	u8 reserved3:6;
+-	u8 multi_channel_action:2;
+-	u8 reserved4;
+-	u32 reserved5;
+-	u8 initiator_port_identifier[16];
+-	u8 target_port_identifier[16];
+-};
+-
+-struct srp_login_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 max_initiator_to_target_iulen;
+-	u32 max_target_to_initiator_iulen;
+-	u16 supported_buffer_formats;
+-	u8 reserved2:6;
+-	u8 multi_channel_result:2;
+-	u8 reserved3;
+-	u8 reserved4[24];
+-};
+-
+-struct srp_login_rej {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-	u64 reserved2;
+-	u16 supported_buffer_formats;
+-	u8 reserved3[6];
+-};
+-
+-struct srp_i_logout {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_t_logout {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-};
+-
+-struct srp_tsk_mgmt {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4;
+-	u8 task_mgmt_flags;
+-	u8 reserved5;
+-	u64 managed_task_tag;
+-	u64 reserved6;
+-};
+-
+-struct srp_cmd {
+-	u8 type;
+-	u32 reserved1 PACKED;
+-	u8 data_out_format:4;
+-	u8 data_in_format:4;
+-	u8 data_out_count;
+-	u8 data_in_count;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4:5;
+-	u8 task_attribute:3;
+-	u8 reserved5;
+-	u8 additional_cdb_len;
+-	u8 cdb[16];
+-	u8 additional_data[0x100 - 0x30];
+-};
+-
+-struct srp_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u16 reserved2;
+-	u8 reserved3:2;
+-	u8 diunder:1;
+-	u8 diover:1;
+-	u8 dounder:1;
+-	u8 doover:1;
+-	u8 snsvalid:1;
+-	u8 rspvalid:1;
+-	u8 status;
+-	u32 data_in_residual_count;
+-	u32 data_out_residual_count;
+-	u32 sense_data_list_length;
+-	u32 response_data_list_length;
+-	u8 sense_and_response_data[18];
+-};
+-
+-struct srp_cred_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-};
+-
+-struct srp_cred_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_aer_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun;
+-	u32 sense_data_list_length;
+-	u32 reserved3;
+-	u8 sense_data[20];
+-};
+-
+-struct srp_aer_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-union srp_iu {
+-	struct srp_generic generic;
+-	struct srp_login_req login_req;
+-	struct srp_login_rsp login_rsp;
+-	struct srp_login_rej login_rej;
+-	struct srp_i_logout i_logout;
+-	struct srp_t_logout t_logout;
+-	struct srp_tsk_mgmt tsk_mgmt;
+-	struct srp_cmd cmd;
+-	struct srp_rsp rsp;
+-	struct srp_cred_req cred_req;
+-	struct srp_cred_rsp cred_rsp;
+-	struct srp_aer_req aer_req;
+-	struct srp_aer_rsp aer_rsp;
+-};
+-
+-#endif
+-- 
+1.1.5


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000384.html">[Stgt-svn] r397 - branches/use-scsi-ml
</A></li>
	<LI>Next message: <A HREF="000386.html">[Stgt-svn] r399 - branches/use-scsi-ml/patchset/broken-out
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#385">[ date ]</a>
              <a href="thread.html#385">[ thread ]</a>
              <a href="subject.html#385">[ subject ]</a>
              <a href="author.html#385">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
