From tomo at berlios.de  Thu Mar  2 00:41:31 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Mar 2006 00:41:31 +0100
Subject: [Stgt-svn] r348 - branches/use-scsi-ml/usr
Message-ID: <200603012341.k21NfVav020315@sheep.berlios.de>

Author: tomo
Date: 2006-03-02 00:41:28 +0100 (Thu, 02 Mar 2006)
New Revision: 348

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
   branches/use-scsi-ml/usr/util.h
Log:
Remove all the ancient code in scsi.c for target and device structures
in kernel space (that is, sysfs). We still use directories and files
to share information between tgtd and tgtadm. Should we replace it
with other mechanisms too?


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-02-28 12:28:01 UTC (rev 347)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:41:28 UTC (rev 348)
@@ -29,7 +29,6 @@
 #include <sys/types.h>
 
 #include "tgtd.h"
-#include "tgt_sysfs.h"
 
 #define cpu_to_be32 __cpu_to_be32
 #define be32_to_cpu __be32_to_cpu
@@ -59,26 +58,6 @@
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
 #define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
 
-static int device_info(int tid, uint64_t lun, uint64_t *size)
-{
-	int fd, err;
-	char path[PATH_MAX], buf[128];
-
-	sprintf(path, TGT_DEVICE_SYSFSDIR "/device%d:%" PRIu64 "/size",
-		tid, lun);
-
-	fd = open(path, O_RDONLY);
-	if (fd < 0)
-		return fd;
-	err = read(fd, buf, sizeof(buf));
-	if (err < 0)
-		return err;
-	*size = strtoull(buf, NULL, 10);
-
-	close(fd);
-	return 0;
-}
-
 static int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
 		      uint8_t ascode, uint8_t ascodeq)
 {
@@ -295,21 +274,19 @@
 	return sizeof(*id);
 }
 
-static int inquiry(int host_no, int tid, uint8_t *lun_buf,
+static int inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
 		   uint8_t *scb, uint8_t *data, int *len)
 {
-	uint64_t size, lun;
-	int err, result = SAM_STAT_CHECK_CONDITION;
+	uint64_t lun;
+	int result = SAM_STAT_CHECK_CONDITION;
 
 	lun = scsi_get_devid(lun_buf);
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
-	err = device_info(tid, lun, &size);
+	dprintf("%" PRIx64 " %x %x\n", lun, scb[1], scb[2]);
 
-	dprintf("%" PRIx64 " %d %x %x\n", lun, err, scb[1], scb[2]);
-
 	if (!(scb[1] & 0x3)) {
 		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
 #if 0
@@ -357,7 +334,6 @@
 			*len = 8;
 			result = SAM_STAT_GOOD;
 		} else if (scb[2] == 0x83) {
-#define SCSI_ID_LEN	24
 			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
 
 			data[1] = 0x83;
@@ -365,8 +341,8 @@
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = tmp;
-			if (err < 0)
-				sprintf(data + 8, "deadbeaf%d:%" PRIu64, tid, lun);
+			if (dev)
+				strncpy(data + 8, dev->scsi_id, SCSI_ID_LEN);
 			*len = tmp + 8;
 			result = SAM_STAT_GOOD;
 		}
@@ -377,7 +353,7 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (err < 0) {
+	if (!dev) {
 		dprintf("%" PRIu64 "\n", lun);
 		data[0] = TYPE_NO_LUN;
 	}
@@ -390,37 +366,28 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int report_luns(int tid, uint8_t *lun_buf, uint8_t *scb, uint8_t *p,
-		       int *len)
+static int report_luns(struct qelem *dev_list, uint8_t *lun_buf, uint8_t *scb,
+		       uint8_t *p, int *len)
 {
+	struct tgt_device *dev;
 	uint64_t lun, *data = (uint64_t *) p;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	DIR *dir;
-	struct dirent *ent;
-	char buf[128];
 	int result = SAM_STAT_GOOD;
 
 	memset(data, 0, rbuflen);
 
-	dir = opendir(TGT_DEVICE_SYSFSDIR);
-	if (!dir) {
-		eprintf("can't open %s %d\n", TGT_DEVICE_SYSFSDIR, errno);
-		exit(0);
-	}
-
 	alen = be32_to_cpu(*(uint32_t *)&scb[6]);
 	if (alen < 16) {
 		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
-		result = SAM_STAT_CHECK_CONDITION;
-		goto out;
+		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	alen &= ~(8 - 1);
 	oalen = alen;
 
 	if ((*((uint64_t *) lun_buf))) {
-		eprintf("Another sick hack for ibmvstgt\n");
+		dprintf("Another sick hack for ibmvstgt\n");
 		nr_luns = 1;
 		goto done;
 	}
@@ -434,30 +401,26 @@
 	idx = 2;
 	nr_luns = 1;
 
-	sprintf(buf, "device%d:", tid);
-	while ((ent = readdir(dir))) {
-		if (!strncmp(ent->d_name, buf, strlen(buf))) {
-			sscanf(ent->d_name, "device%d:%" SCNu64, &tid, &lun);
+	list_for_each_entry(dev, dev_list, dlist) {
+		lun = dev->lun;
 
-			lun = (0x8000 | (lun & 0x001f)) << 48;
-			dprintf("%d %" PRIx64 "\n", tid, lun);
-
-			data[idx++] = cpu_to_be64(lun);
-			if (!(alen -= 8))
-				break;
-			if (!(rbuflen -= 8)) {
-				fprintf(stderr, "FIXME: too many luns\n");
-				exit(-1);
-			}
-			nr_luns++;
+		/* ibmvstgt hack */
+		lun = (0x8000 | (lun & 0x001f)) << 48;
+		dprintf("%" PRIx64 "\n", lun);
+		data[idx++] = cpu_to_be64(lun);
+		if (!(alen -= 8))
+			break;
+		if (!(rbuflen -= 8)) {
+			fprintf(stderr, "FIXME: too many luns\n");
+			exit(-1);
 		}
+		nr_luns++;
 	}
 
 done:
 	*((uint32_t *) data) = cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
-out:
-	closedir(dir);
+
 	return result;
 }
 
@@ -639,10 +602,10 @@
 	return lun;
 }
 
-int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
+int scsi_cmd_process(int host_no, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
-		     struct tgt_device *dev)
+		     struct tgt_device *dev, struct qelem *dev_list)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;
@@ -650,7 +613,7 @@
 
 	lun = scsi_get_devid(lun_buf);
 
-	dprintf("%d %" PRIu64 " %x %u\n", tid, lun, scb[0], datalen);
+	dprintf("%" PRIu64 " %x %u\n", lun, scb[0], datalen);
 
 	*offset = 0;
 	if (!mmap_cmd_init(scb, rw))
@@ -674,10 +637,10 @@
 
 	switch (scb[0]) {
 	case INQUIRY:
-		result = inquiry(host_no, tid, lun_buf, scb, data, len);
+		result = inquiry(dev, host_no, lun_buf, scb, data, len);
 		break;
 	case REPORT_LUNS:
-		result = report_luns(tid, lun_buf, scb, data, len);
+		result = report_luns(dev_list, lun_buf, scb, data, len);
 		break;
 	case READ_CAPACITY:
 		result = read_capacity(dev, scb, data, len);

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-02-28 12:28:01 UTC (rev 347)
+++ branches/use-scsi-ml/usr/target.c	2006-03-01 23:41:28 UTC (rev 348)
@@ -58,8 +58,10 @@
 
 struct target {
 	int tid;
+
+	uint64_t max_device;
 	struct tgt_device **devt;
-	uint64_t max_device;
+	struct qelem device_list;
 
 	/* TODO: move to device */
 	struct qelem cqueue;
@@ -171,6 +173,19 @@
 	return 0;
 }
 
+static void tgt_device_link(struct target *target, struct tgt_device *dev)
+{
+	struct tgt_device *ent;
+	struct qelem *pos;
+
+	list_for_each(pos, &target->device_list) {
+		ent = list_entry(pos, struct tgt_device, dlist);
+		if (dev->lun < ent->lun)
+			break;
+	}
+	insque(&dev->dlist, pos);
+}
+
 int tgt_device_create(int tid, uint64_t dev_id, char *path)
 {
 	struct target *target;
@@ -217,6 +232,7 @@
 	device->state = 0;
 	device->addr = try_mmap_device(dev_fd, size);
 	device->size = size;
+	device->lun = dev_id;
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, dev_id);
 	target->devt[dev_id] = device;
@@ -225,6 +241,8 @@
 		eprintf("Succeed to mmap the device %" PRIx64 "\n",
 			device->addr);
 
+	tgt_device_link(target, device);
+
 	eprintf("Succeed to add a logical unit %" PRIu64 " to the target %d\n",
 		dev_id, tid);
 
@@ -299,6 +317,8 @@
 
 	device_dir_remove(tid, dev_id);
 
+	remque(&device->dlist);
+
 	free(device);
 	return err;
 }
@@ -361,10 +381,11 @@
 	if (device)
 		uaddr = target->devt[dev_id]->addr;
 
-	result = scsi_cmd_process(host_no, target->tid, ev_req->k.cmd_req.scb,
+	result = scsi_cmd_process(host_no, ev_req->k.cmd_req.scb,
 				  &len, ev_req->k.cmd_req.data_len,
 				  &uaddr, &rw, &try_map, &offset,
-				  ev_req->k.cmd_req.lun, device);
+				  ev_req->k.cmd_req.lun, device,
+				  &target->device_list);
 
 	dprintf("%u %x %lx %" PRIu64 " %d\n",
 		cid, ev_req->k.cmd_req.scb[0], uaddr, offset, result);
@@ -560,6 +581,8 @@
 	if (err < 0)
 		goto free_device_table;
 
+	INIT_LIST_HEAD(&target->device_list);
+
 	eprintf("Succeed to create a new target %d\n", tid);
 	tgtt[tid] = target;
 	return 0;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-02-28 12:28:01 UTC (rev 347)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-01 23:41:28 UTC (rev 348)
@@ -11,12 +11,12 @@
 	int fd;
 	uint64_t addr; /* persistent mapped address */
 	uint64_t size;
+	uint64_t lun;
 	unsigned long state;
 	char scsi_id[SCSI_ID_LEN];
+	struct qelem dlist;
 
-	struct qelem cmd_list;
-
-	struct tgt_device *next_device;
+	struct qelem cmd_queue;
 };
 
 /* makeshift */
@@ -38,9 +38,9 @@
 extern int tgt_target_bind(int tid, int host_no);
 
 extern uint64_t scsi_get_devid(uint8_t *pdu);
-extern int scsi_cmd_process(int host_no, int tid, uint8_t *pdu, int *len,
+extern int scsi_cmd_process(int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
-			    struct tgt_device *dev);
+			    struct tgt_device *dev, struct qelem *dev_list);
 
 #endif

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-02-28 12:28:01 UTC (rev 347)
+++ branches/use-scsi-ml/usr/util.h	2006-03-01 23:41:28 UTC (rev 348)
@@ -22,6 +22,9 @@
 #define list_entry(ptr, type, member) \
 	container_of(ptr, type, member)
 
+#define list_for_each(pos, head) \
+	for (pos = (head)->q_forw; pos != (head); pos = pos->q_forw)
+
 #define list_for_each_entry(pos, head, member)				\
 	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
 	     &pos->member != (head); 	\



From tomo at berlios.de  Thu Mar  2 00:47:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Mar 2006 00:47:28 +0100
Subject: [Stgt-svn] r349 - branches/use-scsi-ml/usr
Message-ID: <200603012347.k21NlSug027274@sheep.berlios.de>

Author: tomo
Date: 2006-03-02 00:47:13 +0100 (Thu, 02 Mar 2006)
New Revision: 349

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Stop faking sync_cache errors.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:41:28 UTC (rev 348)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:47:13 UTC (rev 349)
@@ -450,22 +450,16 @@
 	int err;
 
 	err = fsync(dev->fd);
-	if (err) {
-		eprintf("fd %d failed err %d", dev->fd, errno);
-		/*
-		 * this is what we should do but for now we lie.
-		 * err = errno;
-		 */
-		err = 0;
-	}
 
 	switch (err) {
 	case EROFS:
 	case EINVAL:
 	case EBADF:
 	case EIO:
-		/* is this the right sense code? */
-		/* what should I put for the asc/ascq? */
+		/*
+		 * is this the right sense code?
+		/* what should I put for the asc/ascq?
+		*/
 		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	default:



From tomo at berlios.de  Thu Mar  2 00:51:49 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Mar 2006 00:51:49 +0100
Subject: [Stgt-svn] r350 - branches/use-scsi-ml/usr
Message-ID: <200603012351.k21NpnSY031691@sheep.berlios.de>

Author: tomo
Date: 2006-03-02 00:51:47 +0100 (Thu, 02 Mar 2006)
New Revision: 350

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Kill unused headers.

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:47:13 UTC (rev 349)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:51:47 UTC (rev 350)
@@ -11,7 +11,6 @@
  */
 
 #include <errno.h>
-#include <dirent.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <stdio.h>
@@ -25,8 +24,6 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
-#include <sys/stat.h>
-#include <sys/types.h>
 
 #include "tgtd.h"
 
@@ -458,8 +455,8 @@
 	case EIO:
 		/*
 		 * is this the right sense code?
-		/* what should I put for the asc/ascq?
-		*/
+		 * what should I put for the asc/ascq?
+		 */
 		*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST, 0, 0);
 		return SAM_STAT_CHECK_CONDITION;
 	default:



From tomo at berlios.de  Thu Mar  2 07:09:32 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Mar 2006 07:09:32 +0100
Subject: [Stgt-svn] r351 - branches/use-scsi-ml/usr
Message-ID: <200603020609.k2269Wlf014000@sheep.berlios.de>

Author: tomo
Date: 2006-03-02 07:09:26 +0100 (Thu, 02 Mar 2006)
New Revision: 351

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Seems that ibmvscsi cannot handle lun so that we use their 'target'
concept for multiple devices. We will move hack for ibmvstgt to its
dynamic library or something later on.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-01 23:51:47 UTC (rev 350)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-02 06:09:26 UTC (rev 351)
@@ -363,6 +363,15 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
+{
+	uint16_t result = (0x8000 |
+			   ((target & 0x003f) << 8) |
+			   ((bus & 0x0007) << 5) |
+			   (lun & 0x001f));
+	return ((uint64_t) result) << 48;
+}
+
 static int report_luns(struct qelem *dev_list, uint8_t *lun_buf, uint8_t *scb,
 		       uint8_t *p, int *len)
 {
@@ -402,7 +411,7 @@
 		lun = dev->lun;
 
 		/* ibmvstgt hack */
-		lun = (0x8000 | (lun & 0x001f)) << 48;
+		lun = make_lun(0, lun & 0x003f, 0);
 		dprintf("%" PRIx64 "\n", lun);
 		data[idx++] = cpu_to_be64(lun);
 		if (!(alen -= 8))
@@ -572,10 +581,10 @@
 	lun = *((uint64_t *) p);
 	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
 
-	if (GETBUS(lun) || GETTARGET(lun))
+	if (GETBUS(lun) || GETLUN(lun))
 		return TGT_INVALID_DEV_ID;
 	else
-		return GETLUN(lun);
+		return GETTARGET(lun);
 
 	switch (*p >> 6) {
 	case 0:



From tomo at berlios.de  Thu Mar  2 08:46:58 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 2 Mar 2006 08:46:58 +0100
Subject: [Stgt-svn] r352 - branches/use-scsi-ml/usr
Message-ID: <200603020746.k227kwHs015255@sheep.berlios.de>

Author: tomo
Date: 2006-03-02 08:46:54 +0100 (Thu, 02 Mar 2006)
New Revision: 352

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Add proper report_lun code, however it is commented out for ibmvstgt hack right now.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-02 06:09:26 UTC (rev 351)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-02 07:46:54 UTC (rev 352)
@@ -411,8 +411,10 @@
 		lun = dev->lun;
 
 		/* ibmvstgt hack */
+/* 		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16); */
 		lun = make_lun(0, lun & 0x003f, 0);
 		dprintf("%" PRIx64 "\n", lun);
+/* 		data[idx++] = cpu_to_be64(lun << 32); */
 		data[idx++] = cpu_to_be64(lun);
 		if (!(alen -= 8))
 			break;



From tomo at berlios.de  Fri Mar  3 05:34:53 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 05:34:53 +0100
Subject: [Stgt-svn] r353 - branches/use-scsi-ml/usr
Message-ID: <200603030434.k234YrAh006380@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 05:34:51 +0100 (Fri, 03 Mar 2006)
New Revision: 353

Added:
   branches/use-scsi-ml/usr/tgt_sysfs.c
Modified:
   branches/use-scsi-ml/usr/Makefile
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgt_sysfs.h
Log:
Move file and directory stuff in target.c to tgt_sysfs.c


Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-03-02 07:46:54 UTC (rev 352)
+++ branches/use-scsi-ml/usr/Makefile	2006-03-03 04:34:51 UTC (rev 353)
@@ -3,7 +3,7 @@
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o dl.o mgmt.o target.o scsi.o log.o
+tgtd: tgtd.o netlink.o dl.o mgmt.o target.o scsi.o log.o tgt_sysfs.o
 	$(CC) -rdynamic -ldl $^ -o $@
 
 tgtadm: tgtadm.o

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-02 07:46:54 UTC (rev 352)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 04:34:51 UTC (rev 353)
@@ -126,53 +126,6 @@
 	return 0;
 }
 
-static int device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size)
-{
-	char path[PATH_MAX], buf[64];
-	int fd, err;
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64, tid, dev_id);
-
-	err = mkdir(path, dmode);
-	if (err < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%d", dev_fd);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64 "/size", tid, dev_id);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0) {
-		eprintf("Cannot create %s\n", path);
-		return err;
-	}
-	snprintf(buf, sizeof(buf), "%" PRIu64, size);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot write %s\n", path);
-		return err;
-	}
-
-	return 0;
-}
-
 static void tgt_device_link(struct target *target, struct tgt_device *dev)
 {
 	struct tgt_device *ent;
@@ -217,7 +170,7 @@
 		return err;
 	}
 
-	err = device_dir_create(tid, dev_id, dev_fd, size);
+	err = tgt_device_dir_create(tid, dev_id, dev_fd, size);
 	if (err < 0)
 		goto close_dev_fd;
 
@@ -252,36 +205,10 @@
 	return err;
 }
 
-static void device_dir_remove(int tid, uint64_t dev_id)
-{
-	int err;
-	char path[PATH_MAX];
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
-	err = unlink(path);
-	if (err < 0)
-		eprintf("Cannot unlink %s\n", path);
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64 "/size", tid, dev_id);
-	err = unlink(path);
-	if (err < 0)
-		eprintf("Cannot unlink %s\n", path);
-
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64, tid, dev_id);
-	err = rmdir(path);
-	if (err < 0)
-		eprintf("Cannot unlink %s\n", path);
-}
-
 int tgt_device_destroy(int tid, uint64_t dev_id)
 {
 	struct target *target;
 	struct tgt_device *device;
-	char path[PATH_MAX], buf[64];
-	int dev_fd, fd, err;
 
 	/* TODO: check whether the device has flying commands. */
 
@@ -301,26 +228,14 @@
 	if (device->addr)
 		munmap((void *) (unsigned long) device->addr, device->size);
 
-	snprintf(path, sizeof(path), TGT_DEVICE_SYSFSDIR
-		 "/device%d:%" PRIu64 "/fd", tid, dev_id);
-	fd = open(path, O_RDONLY);
-	if (fd < 0)
-		eprintf("%s %d\n", path, errno);
+	close(device->fd);
 
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0)
-		eprintf("%d\n", err);
+	tgt_device_dir_delete(tid, dev_id);
 
-	sscanf(buf, "%d\n", &dev_fd);
-	close(dev_fd);
-
-	device_dir_remove(tid, dev_id);
-
 	remque(&device->dlist);
 
 	free(device);
-	return err;
+	return 0;
 }
 
 int tgt_device_init(void)
@@ -531,20 +446,6 @@
 	return 0;
 }
 
-static int target_dir_create(int tid)
-{
-	char path[PATH_MAX];
-	int err;
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
-	err = mkdir(path, dmode);
-	if (err < 0) {
-		eprintf("Cannot create %s %d\n", path, errno);
-		return err;
-	}
-	return 0;
-}
-
 int tgt_target_create(int tid)
 {
 	int err;
@@ -577,7 +478,7 @@
 	}
 	target->max_device = DEFAULT_NR_DEVICE;
 
-	err = target_dir_create(tid);
+	err = tgt_target_dir_create(tid);
 	if (err < 0)
 		goto free_device_table;
 
@@ -596,6 +497,5 @@
 
 int tgt_target_destroy(int tid)
 {
-	/* TODO */
 	return 0;
 }

Added: branches/use-scsi-ml/usr/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-02 07:46:54 UTC (rev 352)
+++ branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 04:34:51 UTC (rev 353)
@@ -0,0 +1,176 @@
+/*
+ * SCSI file and directory handling functions
+ *
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <linux/limits.h>
+
+#include "tgt_sysfs.h"
+#include "tgtd.h"
+
+enum tgt_fs_op {
+	CREATE = 0,
+	DELETE,
+};
+
+static int tgt_set_string(char *buf, int size, const char *fmt, va_list ap)
+{
+	int err;
+
+	err = vsnprintf(buf, size, fmt, ap);
+	if (err > size)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tgt_dir(int op, const char *fmt, ...)
+{
+	int err;
+	char path[PATH_MAX];
+	mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
+
+	va_list ap;
+	va_start(ap, fmt);
+
+	err = tgt_set_string(path, sizeof(path), fmt, ap);
+	if (err)
+		goto out;
+
+	if (op)
+		err = unlink(path);
+	else
+		err = mkdir(path, dmode);
+
+	if (err < 0)
+		eprintf("fail to create %s %s\n",
+			op ? "delete" : "create", path);
+out:
+	va_end(ap);
+	return err;
+}
+
+static int tgt_file(int op, const char *fmt, ...)
+{
+	int err;
+	char path[PATH_MAX];
+	mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
+
+	va_list ap;
+	va_start(ap, fmt);
+
+	err = tgt_set_string(path, sizeof(path), fmt, ap);
+	if (err)
+		goto out;
+
+	if (op)
+		err = unlink(path);
+	else
+		err = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+
+	if (err < 0)
+		eprintf("fail to %s %s\n", op ? "delete" : "create", path);
+out:
+	va_end(ap);
+	return err;
+}
+
+static int tgt_write(int fd, const char *fmt, ...)
+{
+	int err;
+	char buf[PATH_MAX];
+	va_list ap;
+
+	va_start(ap, fmt);
+	err = tgt_set_string(buf, sizeof(buf), fmt, ap);
+	if (err)
+		goto out;
+
+	err = write(fd, buf, strlen(buf));
+	if (err < 0)
+		eprintf("fail to write %s\n", buf);
+out:
+	close(fd);
+	va_end(ap);
+	return err;
+}
+
+int tgt_target_dir_create(int tid)
+{
+	return tgt_dir(CREATE, TGT_TARGET_SYSFSDIR "/target%d", tid);
+}
+
+int tgt_target_dir_delete(int tid)
+{
+	return tgt_dir(DELETE, TGT_TARGET_SYSFSDIR "/target%d", tid);
+}
+
+int tgt_device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size)
+{
+	int err;
+
+	err = tgt_dir(CREATE, TGT_DEVICE_SYSFSDIR
+		      "/device%d:%" PRIu64, tid, dev_id);
+	if (err < 0)
+		return err;
+
+	err = tgt_file(CREATE, TGT_DEVICE_SYSFSDIR
+			    "/device%d:%" PRIu64 "/fd", tid, dev_id);
+	if (err < 0)
+		return err;
+	err = tgt_write(err, "%d", dev_fd);
+	if (err < 0)
+		return err;
+
+	err = tgt_file(CREATE, TGT_DEVICE_SYSFSDIR
+		       "/device%d:%" PRIu64 "/size", tid, dev_id);
+	if (err < 0)
+		return err;
+	err = write(err, "%" PRIu64, size);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int tgt_device_dir_delete(int tid, uint64_t dev_id)
+{
+	int err;
+
+	err = tgt_file(DELETE, TGT_DEVICE_SYSFSDIR
+		       "/device%d:%" PRIu64 "/fd", tid, dev_id);
+
+	err = tgt_file(DELETE, TGT_DEVICE_SYSFSDIR
+		       "/device%d:%" PRIu64 "/size", tid, dev_id);
+
+	err = tgt_dir(DELETE, TGT_DEVICE_SYSFSDIR
+		      "/device%d:%" PRIu64, tid, dev_id);
+
+	return 0;
+}

Modified: branches/use-scsi-ml/usr/tgt_sysfs.h
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-02 07:46:54 UTC (rev 352)
+++ branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 04:34:51 UTC (rev 353)
@@ -1,3 +1,5 @@
+#include <stdint.h>
+
 #ifndef	__TGT_SYSFS_H
 #define	__TGT_SYSFS_H
 
@@ -5,4 +7,11 @@
 #define	TGT_TARGET_SYSFSDIR	"/var/run/tgt_target"
 #define	TGT_DEVICE_SYSFSDIR	"/var/run/tgt_device"
 
+
+extern int tgt_target_dir_create(int tid);
+extern int tgt_target_dir_delete(int tid);
+
+extern int tgt_device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size);
+extern int tgt_device_dir_delete(int tid, uint64_t dev_id);
+
 #endif



From tomo at berlios.de  Fri Mar  3 06:03:04 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 06:03:04 +0100
Subject: [Stgt-svn] r354 - branches/use-scsi-ml/usr
Message-ID: <200603030503.k23534v6010606@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 06:02:56 +0100 (Fri, 03 Mar 2006)
New Revision: 354

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgt_sysfs.c
   branches/use-scsi-ml/usr/tgt_sysfs.h
Log:
Stop creating /device0/fd and /device0/size files because nobody uses them.


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 04:34:51 UTC (rev 353)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 05:02:56 UTC (rev 354)
@@ -170,7 +170,7 @@
 		return err;
 	}
 
-	err = tgt_device_dir_create(tid, dev_id, dev_fd, size);
+	err = tgt_device_dir_create(tid, dev_id);
 	if (err < 0)
 		goto close_dev_fd;
 

Modified: branches/use-scsi-ml/usr/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 04:34:51 UTC (rev 353)
+++ branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 05:02:56 UTC (rev 354)
@@ -131,46 +131,14 @@
 	return tgt_dir(DELETE, TGT_TARGET_SYSFSDIR "/target%d", tid);
 }
 
-int tgt_device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size)
+int tgt_device_dir_create(int tid, uint64_t dev_id)
 {
-	int err;
-
-	err = tgt_dir(CREATE, TGT_DEVICE_SYSFSDIR
-		      "/device%d:%" PRIu64, tid, dev_id);
-	if (err < 0)
-		return err;
-
-	err = tgt_file(CREATE, TGT_DEVICE_SYSFSDIR
-			    "/device%d:%" PRIu64 "/fd", tid, dev_id);
-	if (err < 0)
-		return err;
-	err = tgt_write(err, "%d", dev_fd);
-	if (err < 0)
-		return err;
-
-	err = tgt_file(CREATE, TGT_DEVICE_SYSFSDIR
-		       "/device%d:%" PRIu64 "/size", tid, dev_id);
-	if (err < 0)
-		return err;
-	err = write(err, "%" PRIu64, size);
-	if (err < 0)
-		return err;
-
-	return 0;
+	return tgt_dir(CREATE, TGT_DEVICE_SYSFSDIR
+		       "/device%d:%" PRIu64, tid, dev_id);
 }
 
 int tgt_device_dir_delete(int tid, uint64_t dev_id)
 {
-	int err;
-
-	err = tgt_file(DELETE, TGT_DEVICE_SYSFSDIR
-		       "/device%d:%" PRIu64 "/fd", tid, dev_id);
-
-	err = tgt_file(DELETE, TGT_DEVICE_SYSFSDIR
-		       "/device%d:%" PRIu64 "/size", tid, dev_id);
-
-	err = tgt_dir(DELETE, TGT_DEVICE_SYSFSDIR
-		      "/device%d:%" PRIu64, tid, dev_id);
-
-	return 0;
+	return tgt_dir(DELETE, TGT_DEVICE_SYSFSDIR
+		       "/device%d:%" PRIu64, tid, dev_id);
 }

Modified: branches/use-scsi-ml/usr/tgt_sysfs.h
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 04:34:51 UTC (rev 353)
+++ branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 05:02:56 UTC (rev 354)
@@ -11,7 +11,7 @@
 extern int tgt_target_dir_create(int tid);
 extern int tgt_target_dir_delete(int tid);
 
-extern int tgt_device_dir_create(int tid, uint64_t dev_id, int dev_fd, uint64_t size);
+extern int tgt_device_dir_create(int tid, uint64_t dev_id);
 extern int tgt_device_dir_delete(int tid, uint64_t dev_id);
 
 #endif



From tomo at berlios.de  Fri Mar  3 06:32:39 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 06:32:39 +0100
Subject: [Stgt-svn] r355 - branches/use-scsi-ml/usr
Message-ID: <200603030532.k235WdP9016163@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 06:32:34 +0100 (Fri, 03 Mar 2006)
New Revision: 355

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgt_sysfs.c
   branches/use-scsi-ml/usr/tgt_sysfs.h
   branches/use-scsi-ml/usr/tgtadm.c
   branches/use-scsi-ml/usr/tgtd.c
Log:
Kill TGT_DEVICE_SYSFSDIR.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 05:02:56 UTC (rev 354)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 05:32:34 UTC (rev 355)
@@ -70,7 +70,6 @@
 static struct target *tgtt[MAX_NR_TARGET];
 static struct target *hostt[MAX_NR_HOST];
 
-static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
 static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
 
 static struct target *target_get(int tid)
@@ -238,26 +237,6 @@
 	return 0;
 }
 
-int tgt_device_init(void)
-{
-	int err;
-
-	system("rm -rf " TGT_TARGET_SYSFSDIR);
-	system("rm -rf " TGT_DEVICE_SYSFSDIR);
-
-	err = mkdir(TGT_TARGET_SYSFSDIR, dmode);
-	if (err < 0) {
-		perror("Cannot create " TGT_TARGET_SYSFSDIR);
-		return err;
-	}
-
-	err = mkdir(TGT_DEVICE_SYSFSDIR, dmode);
-	if (err < 0)
-		perror("Cannot create " TGT_DEVICE_SYSFSDIR);
-
-	return err;
-}
-
 static struct cmd *find_cmd(struct target *target, uint32_t cid)
 {
 	struct cmd *cmd;

Modified: branches/use-scsi-ml/usr/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 05:02:56 UTC (rev 354)
+++ branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 05:32:34 UTC (rev 355)
@@ -39,6 +39,8 @@
 	DELETE,
 };
 
+static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
+
 static int tgt_set_string(char *buf, int size, const char *fmt, va_list ap)
 {
 	int err;
@@ -54,7 +56,6 @@
 {
 	int err;
 	char path[PATH_MAX];
-	mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
 
 	va_list ap;
 	va_start(ap, fmt);
@@ -133,12 +134,25 @@
 
 int tgt_device_dir_create(int tid, uint64_t dev_id)
 {
-	return tgt_dir(CREATE, TGT_DEVICE_SYSFSDIR
-		       "/device%d:%" PRIu64, tid, dev_id);
+	return tgt_dir(CREATE, TGT_TARGET_SYSFSDIR
+		       "/target%d/device%" PRIu64, tid, dev_id);
 }
 
 int tgt_device_dir_delete(int tid, uint64_t dev_id)
 {
-	return tgt_dir(DELETE, TGT_DEVICE_SYSFSDIR
-		       "/device%d:%" PRIu64, tid, dev_id);
+	return tgt_dir(DELETE, TGT_TARGET_SYSFSDIR
+		       "/target%d/device%" PRIu64, tid, dev_id);
 }
+
+int tgt_sysfs_init(void)
+{
+	int err;
+
+	system("rm -rf " TGT_TARGET_SYSFSDIR);
+
+	err = mkdir(TGT_TARGET_SYSFSDIR, dmode);
+	if (err < 0)
+		perror("Cannot create " TGT_TARGET_SYSFSDIR);
+
+	return err;
+}

Modified: branches/use-scsi-ml/usr/tgt_sysfs.h
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 05:02:56 UTC (rev 354)
+++ branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 05:32:34 UTC (rev 355)
@@ -5,7 +5,6 @@
 
 #define	TGT_LLD_SYSFSDIR	"/var/run/tgt_lld"
 #define	TGT_TARGET_SYSFSDIR	"/var/run/tgt_target"
-#define	TGT_DEVICE_SYSFSDIR	"/var/run/tgt_device"
 
 
 extern int tgt_target_dir_create(int tid);

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-03-03 05:02:56 UTC (rev 354)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-03-03 05:32:34 UTC (rev 355)
@@ -126,28 +126,23 @@
 static void all_devices_destroy(int tid)
 {
 	struct dirent **namelist;
-	char *p, cmd[1024];
+	char path[PATH_MAX], key[] = "device";
 	int i, nr, err;
-	uint64_t devid;
+	uint64_t dev_id;
 
-	nr = scandir(TGT_DEVICE_SYSFSDIR, &namelist, filter, alphasort);
+	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
+	nr = scandir(path, &namelist, filter, alphasort);
 	if (!nr)
 		return;
 
 	for (i = 0; i < nr; i++) {
-
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		if (tid != atoi(p))
+		if (strncmp(namelist[i]->d_name, key, strlen(key)))
 			continue;
-		p = strchr(p, ':');
-		if (!p)
-			continue;
-		devid = strtoull(++p, NULL, 10);
-		snprintf(cmd, sizeof(cmd),
-			 "./usr/tgtadm --driver %s --op delete --tid %d --lun %" PRIu64,
-			 driver, tid, devid);
-		err = system(cmd);
+		dev_id = strtoull(namelist[i]->d_name + strlen(key), NULL, 10);
+		snprintf(path, sizeof(path),
+			 "./usr/tgtadm --driver %s --op delete --tid %d --lun %"
+			 PRIu64, driver, tid, dev_id);
+		err = system(path);
 	}
 
 	for (i = 0; i < nr; i++)

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-03-03 05:02:56 UTC (rev 354)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-03-03 05:32:34 UTC (rev 355)
@@ -37,6 +37,7 @@
 
 #include "tgtd.h"
 
+extern int tgt_sysfs_init(void);
 
 enum {
 	POLL_NL, /* netlink socket between kernel and user space */
@@ -221,7 +222,7 @@
 	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
 		exit(1);
 
-	if (tgt_device_init())
+	if (tgt_sysfs_init())
 		exit(1);
 
 	nl_fd = nl_init();



From tomo at berlios.de  Fri Mar  3 08:34:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 08:34:43 +0100
Subject: [Stgt-svn] r356 - branches/use-scsi-ml/usr
Message-ID: <200603030734.k237Yhvx005787@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 08:34:34 +0100 (Fri, 03 Mar 2006)
New Revision: 356

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgt_sysfs.c
   branches/use-scsi-ml/usr/tgt_sysfs.h
Log:
Remove all file and dir stuff in target.c


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 05:32:34 UTC (rev 355)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 07:34:34 UTC (rev 356)
@@ -32,7 +32,6 @@
 #include <sys/mman.h>
 #include <sys/poll.h>
 #include <sys/socket.h>
-#include <sys/stat.h>
 
 #include <linux/fs.h>
 #include <linux/netlink.h>
@@ -70,8 +69,6 @@
 static struct target *tgtt[MAX_NR_TARGET];
 static struct target *hostt[MAX_NR_HOST];
 
-static mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
-
 static struct target *target_get(int tid)
 {
 	if (tid >= MAX_NR_TARGET) {
@@ -395,8 +392,7 @@
 
 int tgt_target_bind(int tid, int host_no)
 {
-	char path[PATH_MAX], buf[64];
-	int fd, err;
+	int err;
 
 	if (!tgtt[tid]) {
 		eprintf("target is not found %d\n", tid);
@@ -408,14 +404,7 @@
 		return -EINVAL;
 	}
 
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/hostno", tid);
-	fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
-	if (fd < 0)
-		return -EINVAL;
-
-	snprintf(buf, sizeof(buf), "%d", host_no);
-	err = write(fd, buf, strlen(buf));
-	close(fd);
+	err = tgt_target_dir_attr_create(tid, "hostno", "%d\n", host_no);
 	if (err < 0)
 		return -EINVAL;
 

Modified: branches/use-scsi-ml/usr/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 05:32:34 UTC (rev 355)
+++ branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-03 07:34:34 UTC (rev 356)
@@ -102,26 +102,6 @@
 	return err;
 }
 
-static int tgt_write(int fd, const char *fmt, ...)
-{
-	int err;
-	char buf[PATH_MAX];
-	va_list ap;
-
-	va_start(ap, fmt);
-	err = tgt_set_string(buf, sizeof(buf), fmt, ap);
-	if (err)
-		goto out;
-
-	err = write(fd, buf, strlen(buf));
-	if (err < 0)
-		eprintf("fail to write %s\n", buf);
-out:
-	close(fd);
-	va_end(ap);
-	return err;
-}
-
 int tgt_target_dir_create(int tid)
 {
 	return tgt_dir(CREATE, TGT_TARGET_SYSFSDIR "/target%d", tid);
@@ -156,3 +136,35 @@
 
 	return err;
 }
+
+int tgt_target_dir_attr_create(int tid, const char *name, const char *fmt, ...)
+{
+	int err, fd = 0;
+	char buf[PATH_MAX];
+	va_list ap;
+
+	va_start(ap, fmt);
+
+	err = tgt_set_string(buf, sizeof(buf), fmt, ap);
+	if (err)
+		goto out;
+
+	fd = tgt_file(CREATE, TGT_TARGET_SYSFSDIR "/target%d/%s", tid, name);
+	if (fd < 0) {
+		err = -errno;
+		goto out;
+	}
+	err = write(fd, buf, strlen(buf));
+	if (err < 0)
+		eprintf("fail to write %s\n", buf);
+out:
+	if (fd > 0)
+		close(fd);
+	va_end(ap);
+	return err;
+}
+
+int tgt_target_dir_attr_delete(int tid, char *name)
+{
+	return tgt_file(DELETE, TGT_TARGET_SYSFSDIR "/target%d/%s", tid, name);
+}

Modified: branches/use-scsi-ml/usr/tgt_sysfs.h
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 05:32:34 UTC (rev 355)
+++ branches/use-scsi-ml/usr/tgt_sysfs.h	2006-03-03 07:34:34 UTC (rev 356)
@@ -13,4 +13,7 @@
 extern int tgt_device_dir_create(int tid, uint64_t dev_id);
 extern int tgt_device_dir_delete(int tid, uint64_t dev_id);
 
+extern int tgt_target_dir_attr_create(int tid, const char *name, const char *fmt, ...);
+extern int tgt_target_dir_attr_delete(int tid, char *name);
+
 #endif



From tomo at berlios.de  Fri Mar  3 10:39:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 10:39:33 +0100
Subject: [Stgt-svn] r357 - branches/use-scsi-ml/usr
Message-ID: <200603030939.k239dX9V013847@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 10:39:33 +0100 (Fri, 03 Mar 2006)
New Revision: 357

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
   branches/use-scsi-ml/usr/util.h
Log:
Use hash list for commands instead of single list.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 07:34:34 UTC (rev 356)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 09:39:33 UTC (rev 357)
@@ -37,6 +37,9 @@
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>
 
+#define	BITS_PER_LONG 32
+#include <linux/hash.h>
+
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "tgt_sysfs.h"
@@ -46,13 +49,18 @@
 #define	DEFAULT_NR_DEVICE	64
 #define	MAX_NR_DEVICE		(1 << 20)
 
+#define	HASH_ORDER	4
+#define	cmd_hashfn(cid)	hash_long((cid), HASH_ORDER)
+
 struct cmd {
-	struct qelem clist;
+	struct qelem hlist;
+	struct qelem qlist;
 	uint32_t cid;
-	uint64_t dev_id;
 	uint64_t uaddr;
 	uint32_t len;
+	uint64_t dev_id;
 	int mmap;
+	struct tgt_cmd_queue *queue;
 };
 
 struct target {
@@ -62,8 +70,8 @@
 	struct tgt_device **devt;
 	struct qelem device_list;
 
-	/* TODO: move to device */
-	struct qelem cqueue;
+	struct qelem cmd_hash_list[1 << HASH_ORDER];
+	struct tgt_cmd_queue cmd_queue;
 };
 
 static struct target *tgtt[MAX_NR_TARGET];
@@ -178,7 +186,6 @@
 		goto close_dev_fd;
 
 	device->fd = dev_fd;
-	device->state = 0;
 	device->addr = try_mmap_device(dev_fd, size);
 	device->size = size;
 	device->lun = dev_id;
@@ -234,17 +241,6 @@
 	return 0;
 }
 
-static struct cmd *find_cmd(struct target *target, uint32_t cid)
-{
-	struct cmd *cmd;
-	list_for_each_entry(cmd, &target->cqueue, clist) {
-		if (cmd->cid == cid)
-			return cmd;
-	}
-	return NULL;
-}
-
-/* TODO: coalesce responses */
 static int cmd_queue(struct tgt_event *ev_req, int nl_fd)
 {
 	struct target *target;
@@ -289,7 +285,7 @@
 	cmd->len = len;
 	cmd->mmap = try_map;
 
-	insque(&cmd->clist, &target->cqueue);
+	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cid)]);
 
 	ev_res->u.cmd_rsp.host_no = host_no;
 	ev_res->u.cmd_rsp.cid = cid;
@@ -302,6 +298,18 @@
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
+static struct cmd *find_cmd(struct target *target, uint32_t cid)
+{
+	struct cmd *cmd;
+	struct qelem *head = &target->cmd_hash_list[cmd_hashfn(cid)];
+
+	list_for_each_entry(cmd, head, hlist) {
+		if (cmd->cid == cid)
+			return cmd;
+	}
+	return NULL;
+}
+
 static int scsi_cmd_done(int do_munmap, int do_free, uint64_t uaddr, int len)
 {
 	int err = 0;
@@ -339,7 +347,7 @@
 		eprintf("Cannot find cmd %d %u\n", host_no, cid);
 		return;
 	}
-	remque(&cmd->clist);
+	remque(&cmd->hlist);
 	do_munmap = cmd->mmap;
 
 	if (do_munmap) {
@@ -416,7 +424,7 @@
 
 int tgt_target_create(int tid)
 {
-	int err;
+	int err, i;
 	struct target *target;
 
 	if (tid >= MAX_NR_TARGET) {
@@ -436,8 +444,11 @@
 	}
 
 	target->tid = tid;
-	INIT_LIST_HEAD(&target->cqueue);
+	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
+		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
 
+	INIT_LIST_HEAD(&target->device_list);
+
 	target->devt = calloc(DEFAULT_NR_DEVICE, sizeof(struct tgt_device *));
 	if (!target->devt) {
 		eprintf("Out of memoryn\n");
@@ -450,8 +461,6 @@
 	if (err < 0)
 		goto free_device_table;
 
-	INIT_LIST_HEAD(&target->device_list);
-
 	eprintf("Succeed to create a new target %d\n", tid);
 	tgtt[tid] = target;
 	return 0;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-03 07:34:34 UTC (rev 356)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-03 09:39:33 UTC (rev 357)
@@ -7,16 +7,20 @@
 
 #define	SCSI_ID_LEN	24
 
+struct tgt_cmd_queue {
+	unsigned long state;
+	struct qelem cmd_queue;
+};
+
 struct tgt_device {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
 	uint64_t size;
 	uint64_t lun;
-	unsigned long state;
 	char scsi_id[SCSI_ID_LEN];
 	struct qelem dlist;
 
-	struct qelem cmd_queue;
+	struct tgt_cmd_queue cmd_queue;
 };
 
 /* makeshift */

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-03-03 07:34:34 UTC (rev 356)
+++ branches/use-scsi-ml/usr/util.h	2006-03-03 09:39:33 UTC (rev 357)
@@ -2,6 +2,8 @@
 
 /* taken from linux kernel */
 
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+
 #undef offsetof
 #ifdef __compiler_offsetof
 #define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)



From tomo at berlios.de  Fri Mar  3 10:54:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 10:54:48 +0100
Subject: [Stgt-svn] r358 - branches/use-scsi-ml/usr
Message-ID: <200603030954.k239sm1I015555@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 10:54:48 +0100 (Fri, 03 Mar 2006)
New Revision: 358

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Clean up include files.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 09:39:33 UTC (rev 357)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 09:54:48 UTC (rev 358)
@@ -22,7 +22,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -30,16 +29,14 @@
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
 #include <sys/socket.h>
 
 #include <linux/fs.h>
+#define	BITS_PER_LONG 32
+#include <linux/hash.h>
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>
 
-#define	BITS_PER_LONG 32
-#include <linux/hash.h>
-
 #include "tgtd.h"
 #include "tgtadm.h"
 #include "tgt_sysfs.h"



From tomo at berlios.de  Fri Mar  3 11:20:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 11:20:28 +0100
Subject: [Stgt-svn] r359 - branches/use-scsi-ml/usr
Message-ID: <200603031020.k23AKSVY019027@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 11:20:26 +0100 (Fri, 03 Mar 2006)
New Revision: 359

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Use tgt_device structure pointer in cmd struture.


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 09:54:48 UTC (rev 358)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 10:20:26 UTC (rev 359)
@@ -55,9 +55,8 @@
 	uint32_t cid;
 	uint64_t uaddr;
 	uint32_t len;
-	uint64_t dev_id;
-	int mmap;
-	struct tgt_cmd_queue *queue;
+	int mmapped;
+	struct tgt_device *dev;
 };
 
 struct target {
@@ -277,10 +276,10 @@
 	/* TODO: preallocate cmd */
 	cmd = malloc(sizeof(*cmd));
  	cmd->cid = cid;
-	cmd->dev_id = dev_id;
+	cmd->dev = device;
 	cmd->uaddr = uaddr;
 	cmd->len = len;
-	cmd->mmap = try_map;
+	cmd->mmapped = try_map;
 
 	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cid)]);
 
@@ -328,7 +327,6 @@
 static void cmd_done(struct tgt_event *ev)
 {
 	struct target *target;
-	struct tgt_device *device;
 	struct cmd *cmd;
 	int err, do_munmap, host_no = ev->k.cmd_done.host_no;
 	uint32_t cid = ev->k.cmd_done.cid;
@@ -345,21 +343,19 @@
 		return;
 	}
 	remque(&cmd->hlist);
-	do_munmap = cmd->mmap;
-
+	do_munmap = cmd->mmapped;
 	if (do_munmap) {
-		device = device_get(target, cmd->dev_id);
-		if (!device) {
-			eprintf("%" PRIu64 " is null\n", cmd->dev_id);
+		if (!cmd->dev) {
+			eprintf("device is null\n");
 			exit(1);
 		}
 
-		if (device->addr)
+		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = scsi_cmd_done(do_munmap, !cmd->mmap, cmd->uaddr, cmd->len);
+	err = scsi_cmd_done(do_munmap, !cmd->mmapped, cmd->uaddr, cmd->len);
 
-	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmap, cmd->uaddr, cmd->len, err);
+	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 
 	free(cmd);
 }



From tomo at berlios.de  Fri Mar  3 13:08:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 13:08:03 +0100
Subject: [Stgt-svn] r360 - branches/use-scsi-ml/usr
Message-ID: <200603031208.k23C83Or021543@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 13:07:51 +0100 (Fri, 03 Mar 2006)
New Revision: 360

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Some preparation code for ordering support.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-03 10:20:26 UTC (rev 359)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-03 12:07:51 UTC (rev 360)
@@ -604,7 +604,7 @@
 	return lun;
 }
 
-int scsi_cmd_process(int host_no, uint8_t *pdu, int *len,
+int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
 		     struct tgt_device *dev, struct qelem *dev_list)

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 10:20:26 UTC (rev 359)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 12:07:51 UTC (rev 360)
@@ -32,7 +32,7 @@
 #include <sys/socket.h>
 
 #include <linux/fs.h>
-#define	BITS_PER_LONG 32
+#define	BITS_PER_LONG	32
 #include <linux/hash.h>
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>
@@ -41,6 +41,11 @@
 #include "tgtadm.h"
 #include "tgt_sysfs.h"
 
+/* better if we can include the followings in kernel header files. */
+#define	MSG_SIMPLE_TAG	0x20
+#define	MSG_HEAD_TAG	0x21
+#define	MSG_ORDERED_TAG	0x22
+
 #define	MAX_NR_TARGET		1024
 #define	MAX_NR_HOST		1024
 #define	DEFAULT_NR_DEVICE	64
@@ -49,6 +54,10 @@
 #define	HASH_ORDER	4
 #define	cmd_hashfn(cid)	hash_long((cid), HASH_ORDER)
 
+enum {
+	TGT_QUEUE_BLOCKED,
+};
+
 struct cmd {
 	struct qelem hlist;
 	struct qelem qlist;
@@ -57,6 +66,13 @@
 	uint32_t len;
 	int mmapped;
 	struct tgt_device *dev;
+
+	/* Kill the followings when we use shared memory instead of netlink. */
+	int hostno;
+	uint32_t data_len;
+	uint8_t scb[16];
+	uint8_t lun[8];
+	int attribute;
 };
 
 struct target {
@@ -139,6 +155,13 @@
 	insque(&dev->dlist, pos);
 }
 
+void tgt_cmd_queue_init(struct tgt_cmd_queue *q)
+{
+	q->active_cmd = 0;
+	q->state = 0;
+	INIT_LIST_HEAD(&q->queue);
+}
+
 int tgt_device_create(int tid, uint64_t dev_id, char *path)
 {
 	struct target *target;
@@ -194,6 +217,7 @@
 			device->addr);
 
 	tgt_device_link(target, device);
+	tgt_cmd_queue_init(&device->cmd_queue);
 
 	eprintf("Succeed to add a logical unit %" PRIu64 " to the target %d\n",
 		dev_id, tid);
@@ -237,61 +261,92 @@
 	return 0;
 }
 
-static int cmd_queue(struct tgt_event *ev_req, int nl_fd)
+static int tgt_kspace_send_cmd(int nl_fd, struct cmd *cmd, int result, int rw)
 {
-	struct target *target;
-	struct tgt_device *device;
-	int result, len = 0;
 	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
 	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+
+	ev_res->u.cmd_rsp.host_no = cmd->hostno;
+	ev_res->u.cmd_rsp.cid = cmd->cid;
+	ev_res->u.cmd_rsp.len = cmd->len;
+	ev_res->u.cmd_rsp.result = result;
+	ev_res->u.cmd_rsp.uaddr = cmd->uaddr;
+	ev_res->u.cmd_rsp.rw = rw;
+
+	return __nl_write(nl_fd, TGT_UEVENT_CMD_RSP, resbuf,
+			  NLMSG_SPACE(sizeof(*ev_res)));
+}
+
+static int cmd_pre_perform(struct tgt_cmd_queue *queue, int attribute)
+{
+	return 1;
+}
+
+static void cmd_post_perform(struct cmd *cmd, unsigned long uaddr,
+			     int len, uint8_t mmapped)
+{
+	cmd->uaddr = uaddr;
+	cmd->len = len;
+	cmd->mmapped = mmapped;
+}
+
+static void cmd_queue(struct tgt_event *ev_req, int nl_fd)
+{
+	struct target *target;
+	struct tgt_cmd_queue *q;
+	struct cmd *cmd;
+	int result, enabled, len = 0;
 	uint64_t offset, dev_id;
-	uint32_t cid = ev_req->k.cmd_req.cid;
-	uint8_t rw = 0, try_map = 0;
+	uint8_t rw = 0, mmapped = 0;
 	unsigned long uaddr = 0;
-	int host_no = ev_req->k.cmd_req.host_no;
-	struct cmd *cmd;
 
-	target = host_to_target(host_no);
+	target = host_to_target(ev_req->k.cmd_req.host_no);
 	if (!target) {
-		eprintf("%d is not bind to any target\n", host_no);
-		return 0;
+		eprintf("%d is not bind to any target\n",
+			ev_req->k.cmd_req.host_no);
+		return;
 	}
 
+	/* TODO: preallocate cmd */
+	cmd = malloc(sizeof(*cmd));
+	cmd->hostno = ev_req->k.cmd_req.host_no;
+ 	cmd->cid = ev_req->k.cmd_req.cid;
+	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
+
 	dev_id = scsi_get_devid(ev_req->k.cmd_req.lun);
-	dprintf("%u %x %" PRIx64 "\n", cid, ev_req->k.cmd_req.scb[0], dev_id);
+	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
+		dev_id);
 
-	device = device_get(target, dev_id);
-	if (device)
+	cmd->dev = device_get(target, dev_id);
+	if (cmd->dev) {
 		uaddr = target->devt[dev_id]->addr;
+		q = &cmd->dev->cmd_queue;
+	} else
+		q = &target->cmd_queue;
 
-	result = scsi_cmd_process(host_no, ev_req->k.cmd_req.scb,
-				  &len, ev_req->k.cmd_req.data_len,
-				  &uaddr, &rw, &try_map, &offset,
-				  ev_req->k.cmd_req.lun, device,
-				  &target->device_list);
+	enabled = cmd_pre_perform(q, ev_req->k.cmd_req.attribute);
 
-	dprintf("%u %x %lx %" PRIu64 " %d\n",
-		cid, ev_req->k.cmd_req.scb[0], uaddr, offset, result);
+	if (enabled) {
+		result = scsi_cmd_perform(cmd->hostno, ev_req->k.cmd_req.scb,
+					  &len, ev_req->k.cmd_req.data_len,
+					  &uaddr, &rw, &mmapped, &offset,
+					  ev_req->k.cmd_req.lun, cmd->dev,
+					  &target->device_list);
 
-	/* TODO: preallocate cmd */
-	cmd = malloc(sizeof(*cmd));
- 	cmd->cid = cid;
-	cmd->dev = device;
-	cmd->uaddr = uaddr;
-	cmd->len = len;
-	cmd->mmapped = try_map;
+		cmd_post_perform(cmd, uaddr, len, mmapped);
+		q->active_cmd++;
 
-	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cid)]);
+		dprintf("%u %x %lx %" PRIu64 " %d\n",
+			cmd->cid, ev_req->k.cmd_req.scb[0], uaddr,
+			offset, result);
 
-	ev_res->u.cmd_rsp.host_no = host_no;
-	ev_res->u.cmd_rsp.cid = cid;
-	ev_res->u.cmd_rsp.len = len;
-	ev_res->u.cmd_rsp.result = result;
-	ev_res->u.cmd_rsp.uaddr = uaddr;
-	ev_res->u.cmd_rsp.rw = rw;
-
-	return __nl_write(nl_fd, TGT_UEVENT_CMD_RSP, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
+		tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
+	} else {
+		memcpy(cmd->scb, ev_req->k.cmd_req.scb, sizeof(cmd->scb));
+		memcpy(cmd->lun, ev_req->k.cmd_req.lun, sizeof(cmd->lun));
+		cmd->len = ev_req->k.cmd_req.data_len;
+		insque(&cmd->qlist, q);
+	}
 }
 
 static struct cmd *find_cmd(struct target *target, uint32_t cid)
@@ -327,6 +382,7 @@
 static void cmd_done(struct tgt_event *ev)
 {
 	struct target *target;
+	struct tgt_cmd_queue *q;
 	struct cmd *cmd;
 	int err, do_munmap, host_no = ev->k.cmd_done.host_no;
 	uint32_t cid = ev->k.cmd_done.cid;
@@ -343,6 +399,14 @@
 		return;
 	}
 	remque(&cmd->hlist);
+
+	if (cmd->dev)
+		q = &cmd->dev->cmd_queue;
+	else
+		q = &target->cmd_queue;
+
+	q->active_cmd--;
+
 	do_munmap = cmd->mmapped;
 	if (do_munmap) {
 		if (!cmd->dev) {
@@ -454,6 +518,8 @@
 	if (err < 0)
 		goto free_device_table;
 
+	tgt_cmd_queue_init(&target->cmd_queue);
+
 	eprintf("Succeed to create a new target %d\n", tid);
 	tgtt[tid] = target;
 	return 0;

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-03 10:20:26 UTC (rev 359)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-03 12:07:51 UTC (rev 360)
@@ -8,8 +8,9 @@
 #define	SCSI_ID_LEN	24
 
 struct tgt_cmd_queue {
+	int active_cmd;
 	unsigned long state;
-	struct qelem cmd_queue;
+	struct qelem queue;
 };
 
 struct tgt_device {
@@ -42,7 +43,7 @@
 extern int tgt_target_bind(int tid, int host_no);
 
 extern uint64_t scsi_get_devid(uint8_t *pdu);
-extern int scsi_cmd_process(int host_no, uint8_t *pdu, int *len,
+extern int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
 			    struct tgt_device *dev, struct qelem *dev_list);



From tomo at berlios.de  Fri Mar  3 13:41:41 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 13:41:41 +0100
Subject: [Stgt-svn] r361 - branches/use-scsi-ml/usr
Message-ID: <200603031241.k23Cff7v001689@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 13:41:36 +0100 (Fri, 03 Mar 2006)
New Revision: 361

Modified:
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/util.h
Log:
Some preparation code for ordering support again.


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 12:07:51 UTC (rev 360)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 12:41:36 UTC (rev 361)
@@ -277,17 +277,54 @@
 			  NLMSG_SPACE(sizeof(*ev_res)));
 }
 
-static int cmd_pre_perform(struct tgt_cmd_queue *queue, int attribute)
+static int cmd_pre_perform(struct tgt_cmd_queue *q, struct cmd *cmd)
 {
-	return 1;
+	int enabled = 0;
+
+	if (cmd->attribute != MSG_SIMPLE_TAG) {
+		eprintf("non simple attribute %u %x\n", cmd->cid, cmd->attribute);
+		cmd->attribute = MSG_SIMPLE_TAG;
+	}
+
+	switch (cmd->attribute) {
+	case MSG_SIMPLE_TAG:
+		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)))
+			enabled = 1;
+		break;
+	case MSG_ORDERED_TAG:
+		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)) &&
+		    !q->active_cmd)
+			enabled = 1;
+		break;
+	case MSG_HEAD_TAG:
+		enabled = 1;
+		break;
+	default:
+		eprintf("unknown command attribute %x\n", cmd->attribute);
+		cmd->attribute = MSG_HEAD_TAG;
+		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)) &&
+		    !q->active_cmd)
+			enabled = 1;
+	}
+
+	return enabled;
 }
 
-static void cmd_post_perform(struct cmd *cmd, unsigned long uaddr,
+static void cmd_post_perform(struct tgt_cmd_queue *q, struct cmd *cmd,
+			     unsigned long uaddr,
 			     int len, uint8_t mmapped)
 {
 	cmd->uaddr = uaddr;
 	cmd->len = len;
 	cmd->mmapped = mmapped;
+
+	q->active_cmd++;
+	switch(cmd->attribute) {
+	case MSG_ORDERED_TAG:
+	case MSG_HEAD_TAG:
+		q->state |= (1UL << TGT_QUEUE_BLOCKED);
+		break;
+	}
 }
 
 static void cmd_queue(struct tgt_event *ev_req, int nl_fd)
@@ -311,6 +348,7 @@
 	cmd = malloc(sizeof(*cmd));
 	cmd->hostno = ev_req->k.cmd_req.host_no;
  	cmd->cid = ev_req->k.cmd_req.cid;
+	cmd->attribute = ev_req->k.cmd_req.attribute;
 	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
 
 	dev_id = scsi_get_devid(ev_req->k.cmd_req.lun);
@@ -324,7 +362,7 @@
 	} else
 		q = &target->cmd_queue;
 
-	enabled = cmd_pre_perform(q, ev_req->k.cmd_req.attribute);
+	enabled = cmd_pre_perform(q, cmd);
 
 	if (enabled) {
 		result = scsi_cmd_perform(cmd->hostno, ev_req->k.cmd_req.scb,
@@ -333,8 +371,7 @@
 					  ev_req->k.cmd_req.lun, cmd->dev,
 					  &target->device_list);
 
-		cmd_post_perform(cmd, uaddr, len, mmapped);
-		q->active_cmd++;
+		cmd_post_perform(q, cmd, uaddr, len, mmapped);
 
 		dprintf("%u %x %lx %" PRIu64 " %d\n",
 			cmd->cid, ev_req->k.cmd_req.scb[0], uaddr,
@@ -345,7 +382,7 @@
 		memcpy(cmd->scb, ev_req->k.cmd_req.scb, sizeof(cmd->scb));
 		memcpy(cmd->lun, ev_req->k.cmd_req.lun, sizeof(cmd->lun));
 		cmd->len = ev_req->k.cmd_req.data_len;
-		insque(&cmd->qlist, q);
+		insque(&cmd->qlist, q->queue.q_back);
 	}
 }
 
@@ -400,13 +437,6 @@
 	}
 	remque(&cmd->hlist);
 
-	if (cmd->dev)
-		q = &cmd->dev->cmd_queue;
-	else
-		q = &target->cmd_queue;
-
-	q->active_cmd--;
-
 	do_munmap = cmd->mmapped;
 	if (do_munmap) {
 		if (!cmd->dev) {
@@ -421,6 +451,18 @@
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 
+	if (cmd->dev)
+		q = &cmd->dev->cmd_queue;
+	else
+		q = &target->cmd_queue;
+
+	q->active_cmd--;
+	switch (cmd->attribute) {
+	case MSG_ORDERED_TAG:
+	case MSG_HEAD_TAG:
+		q->state &= ~(1UL << TGT_QUEUE_BLOCKED);
+	}
+
 	free(cmd);
 }
 

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-03-03 12:07:51 UTC (rev 360)
+++ branches/use-scsi-ml/usr/util.h	2006-03-03 12:41:36 UTC (rev 361)
@@ -11,15 +11,25 @@
 #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
 #endif
 
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+struct qelem {
+	struct qelem *q_forw;
+	struct qelem *q_back;
+};
+
 #define LIST_HEAD_INIT(name) { &(name), &(name) }
 
 #define INIT_LIST_HEAD(ptr) do { \
 	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
 } while (0)
 
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
+static inline int list_empty(const struct qelem *head)
+{
+	return head->q_forw == head;
+}
 
 #define list_entry(ptr, type, member) \
 	container_of(ptr, type, member)
@@ -40,7 +50,3 @@
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 
-struct qelem {
-	struct qelem *q_forw;
-	struct qelem *q_back;
-};



From tomo at berlios.de  Fri Mar  3 15:18:12 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 15:18:12 +0100
Subject: [Stgt-svn] r362 - branches/use-scsi-ml/usr
Message-ID: <200603031418.k23EICoY014750@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 15:18:09 +0100 (Fri, 03 Mar 2006)
New Revision: 362

Added:
   branches/use-scsi-ml/usr/list.h
Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
   branches/use-scsi-ml/usr/util.h
Log:
Replace qelem with list_head that taken from kernel for type checking.


Added: branches/use-scsi-ml/usr/list.h
===================================================================
--- branches/use-scsi-ml/usr/list.h	2006-03-03 12:41:36 UTC (rev 361)
+++ branches/use-scsi-ml/usr/list.h	2006-03-03 14:18:09 UTC (rev 362)
@@ -0,0 +1,81 @@
+/* taken from linux kernel */
+
+#undef offsetof
+#ifdef __compiler_offsetof
+#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
+#else
+#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#endif
+
+#define container_of(ptr, type, member) ({			\
+        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+        (type *)( (char *)__mptr - offsetof(type,member) );})
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+static inline int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     &pos->member != (head);				 	\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_entry((head)->next, typeof(*pos), member),	\
+		n = list_entry(pos->member.next, typeof(*pos), member);	\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = entry->prev = NULL;
+}

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-03 12:41:36 UTC (rev 361)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-03 14:18:09 UTC (rev 362)
@@ -372,7 +372,7 @@
 	return ((uint64_t) result) << 48;
 }
 
-static int report_luns(struct qelem *dev_list, uint8_t *lun_buf, uint8_t *scb,
+static int report_luns(struct list_head *dev_list, uint8_t *lun_buf, uint8_t *scb,
 		       uint8_t *p, int *len)
 {
 	struct tgt_device *dev;
@@ -607,7 +607,7 @@
 int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
-		     struct tgt_device *dev, struct qelem *dev_list)
+		     struct tgt_device *dev, struct list_head *dev_list)
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 12:41:36 UTC (rev 361)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 14:18:09 UTC (rev 362)
@@ -25,7 +25,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <search.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
@@ -59,8 +58,8 @@
 };
 
 struct cmd {
-	struct qelem hlist;
-	struct qelem qlist;
+	struct list_head hlist;
+	struct list_head qlist;
 	uint32_t cid;
 	uint64_t uaddr;
 	uint32_t len;
@@ -80,9 +79,9 @@
 
 	uint64_t max_device;
 	struct tgt_device **devt;
-	struct qelem device_list;
+	struct list_head device_list;
 
-	struct qelem cmd_hash_list[1 << HASH_ORDER];
+	struct list_head cmd_hash_list[1 << HASH_ORDER];
 	struct tgt_cmd_queue cmd_queue;
 };
 
@@ -145,14 +144,14 @@
 static void tgt_device_link(struct target *target, struct tgt_device *dev)
 {
 	struct tgt_device *ent;
-	struct qelem *pos;
+	struct list_head *pos;
 
 	list_for_each(pos, &target->device_list) {
 		ent = list_entry(pos, struct tgt_device, dlist);
 		if (dev->lun < ent->lun)
 			break;
 	}
-	insque(&dev->dlist, pos);
+	list_add(&dev->dlist, pos);
 }
 
 void tgt_cmd_queue_init(struct tgt_cmd_queue *q)
@@ -255,7 +254,7 @@
 
 	tgt_device_dir_delete(tid, dev_id);
 
-	remque(&device->dlist);
+	list_del(&device->dlist);
 
 	free(device);
 	return 0;
@@ -349,7 +348,7 @@
 	cmd->hostno = ev_req->k.cmd_req.host_no;
  	cmd->cid = ev_req->k.cmd_req.cid;
 	cmd->attribute = ev_req->k.cmd_req.attribute;
-	insque(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
+	list_add(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
 
 	dev_id = scsi_get_devid(ev_req->k.cmd_req.lun);
 	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
@@ -382,14 +381,14 @@
 		memcpy(cmd->scb, ev_req->k.cmd_req.scb, sizeof(cmd->scb));
 		memcpy(cmd->lun, ev_req->k.cmd_req.lun, sizeof(cmd->lun));
 		cmd->len = ev_req->k.cmd_req.data_len;
-		insque(&cmd->qlist, q->queue.q_back);
+		list_add_tail(&cmd->qlist, &q->queue);
 	}
 }
 
 static struct cmd *find_cmd(struct target *target, uint32_t cid)
 {
 	struct cmd *cmd;
-	struct qelem *head = &target->cmd_hash_list[cmd_hashfn(cid)];
+	struct list_head *head = &target->cmd_hash_list[cmd_hashfn(cid)];
 
 	list_for_each_entry(cmd, head, hlist) {
 		if (cmd->cid == cid)
@@ -435,7 +434,7 @@
 		eprintf("Cannot find cmd %d %u\n", host_no, cid);
 		return;
 	}
-	remque(&cmd->hlist);
+	list_del(&cmd->hlist);
 
 	do_munmap = cmd->mmapped;
 	if (do_munmap) {

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-03 12:41:36 UTC (rev 361)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-03 14:18:09 UTC (rev 362)
@@ -10,7 +10,7 @@
 struct tgt_cmd_queue {
 	int active_cmd;
 	unsigned long state;
-	struct qelem queue;
+	struct list_head queue;
 };
 
 struct tgt_device {
@@ -19,7 +19,7 @@
 	uint64_t size;
 	uint64_t lun;
 	char scsi_id[SCSI_ID_LEN];
-	struct qelem dlist;
+	struct list_head dlist;
 
 	struct tgt_cmd_queue cmd_queue;
 };
@@ -46,6 +46,6 @@
 extern int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
-			    struct tgt_device *dev, struct qelem *dev_list);
+			    struct tgt_device *dev, struct list_head *dev_list);
 
 #endif

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-03-03 12:41:36 UTC (rev 361)
+++ branches/use-scsi-ml/usr/util.h	2006-03-03 14:18:09 UTC (rev 362)
@@ -1,47 +1,8 @@
 #include <sys/user.h>
+#include "list.h"
 
-/* taken from linux kernel */
-
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
 
-#undef offsetof
-#ifdef __compiler_offsetof
-#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
-#else
-#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
-#endif
-
-#define container_of(ptr, type, member) ({			\
-        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
-        (type *)( (char *)__mptr - offsetof(type,member) );})
-
-struct qelem {
-	struct qelem *q_forw;
-	struct qelem *q_back;
-};
-
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
-
-#define INIT_LIST_HEAD(ptr) do { \
-	(ptr)->q_forw = (ptr); (ptr)->q_back = (ptr); \
-} while (0)
-
-static inline int list_empty(const struct qelem *head)
-{
-	return head->q_forw == head;
-}
-
-#define list_entry(ptr, type, member) \
-	container_of(ptr, type, member)
-
-#define list_for_each(pos, head) \
-	for (pos = (head)->q_forw; pos != (head); pos = pos->q_forw)
-
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->q_forw, typeof(*pos), member);	\
-	     &pos->member != (head); 	\
-	     pos = list_entry(pos->member.q_forw, typeof(*pos), member))
-
 #ifndef PAGE_SHIFT
 #define	PAGE_SHIFT	12
 #define	PAGE_SIZE	(1UL << PAGE_SHIFT)



From tomo at berlios.de  Fri Mar  3 16:52:29 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 3 Mar 2006 16:52:29 +0100
Subject: [Stgt-svn] r363 - branches/use-scsi-ml/usr
Message-ID: <200603031552.k23FqTdh001179@sheep.berlios.de>

Author: tomo
Date: 2006-03-03 16:52:29 +0100 (Fri, 03 Mar 2006)
New Revision: 363

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Add command ordering support, though it is not tested yet.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 14:18:09 UTC (rev 362)
+++ branches/use-scsi-ml/usr/target.c	2006-03-03 15:52:29 UTC (rev 363)
@@ -280,10 +280,10 @@
 {
 	int enabled = 0;
 
-	if (cmd->attribute != MSG_SIMPLE_TAG) {
-		eprintf("non simple attribute %u %x\n", cmd->cid, cmd->attribute);
-		cmd->attribute = MSG_SIMPLE_TAG;
-	}
+	if (cmd->attribute != MSG_SIMPLE_TAG)
+		dprintf("non simple attribute %u %x %" PRIu64 " %d\n",
+			cmd->cid, cmd->attribute, cmd->dev ? cmd->dev->lun : ~0ULL,
+			q->active_cmd);
 
 	switch (cmd->attribute) {
 	case MSG_SIMPLE_TAG:
@@ -318,7 +318,7 @@
 	cmd->mmapped = mmapped;
 
 	q->active_cmd++;
-	switch(cmd->attribute) {
+	switch (cmd->attribute) {
 	case MSG_ORDERED_TAG:
 	case MSG_HEAD_TAG:
 		q->state |= (1UL << TGT_QUEUE_BLOCKED);
@@ -378,6 +378,11 @@
 
 		tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
 	} else {
+		dprintf("blocked %u %x %" PRIu64 " %d\n",
+			cmd->cid, ev_req->k.cmd_req.scb[0],
+			cmd->dev ? cmd->dev->lun : ~0ULL,
+			q->active_cmd);
+
 		memcpy(cmd->scb, ev_req->k.cmd_req.scb, sizeof(cmd->scb));
 		memcpy(cmd->lun, ev_req->k.cmd_req.lun, sizeof(cmd->lun));
 		cmd->len = ev_req->k.cmd_req.data_len;
@@ -385,6 +390,42 @@
 	}
 }
 
+static void post_cmd_done(int nl_fd, struct tgt_cmd_queue *q)
+{
+	struct cmd *cmd, *tmp;
+	int enabled, result, len = 0;
+	uint8_t rw = 0, mmapped = 0;
+	uint64_t offset;
+	unsigned long uaddr = 0;
+	struct target *target;
+
+	list_for_each_entry_safe(cmd, tmp, &q->queue, qlist) {
+		enabled = cmd_pre_perform(q, cmd);
+		if (enabled) {
+			list_del(&cmd->qlist);
+			target = host_to_target(cmd->hostno);
+			if (!target) {
+				eprintf("fail to find target!\n");
+				exit(1);
+			}
+			dprintf("perform %u %x\n", cmd->cid, cmd->attribute);
+			result = scsi_cmd_perform(cmd->hostno, cmd->scb,
+						  &len,
+						  cmd->len,
+						  &uaddr,
+						  &rw,
+						  &mmapped,
+						  &offset,
+						  cmd->lun,
+						  cmd->dev,
+						  &target->device_list);
+			cmd_post_perform(q, cmd, uaddr, len, mmapped);
+			tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
+		} else
+			break;
+	}
+}
+
 static struct cmd *find_cmd(struct target *target, uint32_t cid)
 {
 	struct cmd *cmd;
@@ -415,7 +456,7 @@
 	return err;
 }
 
-static void cmd_done(struct tgt_event *ev)
+static void cmd_done(struct tgt_event *ev, int nl_fd)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
@@ -463,6 +504,8 @@
 	}
 
 	free(cmd);
+
+	post_cmd_done(nl_fd, q);
 }
 
 void nl_event_handle(int nl_fd)
@@ -488,7 +531,7 @@
 		cmd_queue(ev, nl_fd);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		cmd_done(ev);
+		cmd_done(ev, nl_fd);
 		break;
 	default:
 		eprintf("unknown event %u\n", nlh->nlmsg_type);



From tomo at berlios.de  Sat Mar  4 00:44:46 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 00:44:46 +0100
Subject: [Stgt-svn] r364 - in branches/use-scsi-ml: . usr
Message-ID: <200603032344.k23Nik2p011975@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 00:44:43 +0100 (Sat, 04 Mar 2006)
New Revision: 364

Removed:
   branches/use-scsi-ml/include/
Modified:
   branches/use-scsi-ml/usr/Makefile
Log:
Kill empty include directroy.

Modified: branches/use-scsi-ml/usr/Makefile
===================================================================
--- branches/use-scsi-ml/usr/Makefile	2006-03-03 15:52:29 UTC (rev 363)
+++ branches/use-scsi-ml/usr/Makefile	2006-03-03 23:44:43 UTC (rev 364)
@@ -1,4 +1,4 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../include -D_LARGEFILE64_SOURCE
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
 
 all: $(PROGRAMS)



From tomo at berlios.de  Sat Mar  4 01:45:38 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 01:45:38 +0100
Subject: [Stgt-svn] r365 - branches/use-scsi-ml/usr
Message-ID: <200603040045.k240jcnd007078@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 01:45:16 +0100 (Sat, 04 Mar 2006)
New Revision: 365

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Better define BITS_PER_LONG.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-03 23:44:43 UTC (rev 364)
+++ branches/use-scsi-ml/usr/target.c	2006-03-04 00:45:16 UTC (rev 365)
@@ -31,7 +31,7 @@
 #include <sys/socket.h>
 
 #include <linux/fs.h>
-#define	BITS_PER_LONG	32
+#define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
 #include <linux/hash.h>
 #include <linux/netlink.h>
 #include <scsi/scsi_tgt_if.h>



From tomo at berlios.de  Sat Mar  4 03:15:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 03:15:47 +0100
Subject: [Stgt-svn] r366 - branches/use-scsi-ml/usr
Message-ID: <200603040215.k242Fl9o027709@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 03:15:18 +0100 (Sat, 04 Mar 2006)
New Revision: 366

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Clean up the queue state.

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-04 00:45:16 UTC (rev 365)
+++ branches/use-scsi-ml/usr/target.c	2006-03-04 02:15:18 UTC (rev 366)
@@ -55,6 +55,7 @@
 
 enum {
 	TGT_QUEUE_BLOCKED,
+	TGT_QUEUE_DELETED,
 };
 
 struct cmd {
@@ -88,6 +89,28 @@
 static struct target *tgtt[MAX_NR_TARGET];
 static struct target *hostt[MAX_NR_HOST];
 
+#define QUEUE_FNS(bit, name)						\
+static inline void set_queue_##name(struct tgt_cmd_queue *q)		\
+{									\
+	(q)->state |= (1UL << TGT_QUEUE_##bit);				\
+}									\
+static inline void clear_queue_##name(struct tgt_cmd_queue *q)		\
+{									\
+	(q)->state &= ~(1UL << TGT_QUEUE_##bit);			\
+}									\
+static inline int queue_##name(const struct tgt_cmd_queue *q)		\
+{									\
+	return ((q)->state & (1UL << TGT_QUEUE_##bit));			\
+}
+
+static inline int queue_active(const struct tgt_cmd_queue *q)		\
+{									\
+	return ((q)->active_cmd);					\
+}
+
+QUEUE_FNS(BLOCKED, blocked)
+QUEUE_FNS(DELETED, deleted)
+
 static struct target *target_get(int tid)
 {
 	if (tid >= MAX_NR_TARGET) {
@@ -287,12 +310,11 @@
 
 	switch (cmd->attribute) {
 	case MSG_SIMPLE_TAG:
-		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)))
+		if (!queue_blocked(q))
 			enabled = 1;
 		break;
 	case MSG_ORDERED_TAG:
-		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)) &&
-		    !q->active_cmd)
+		if (!queue_blocked(q) && !queue_active(q))
 			enabled = 1;
 		break;
 	case MSG_HEAD_TAG:
@@ -300,9 +322,8 @@
 		break;
 	default:
 		eprintf("unknown command attribute %x\n", cmd->attribute);
-		cmd->attribute = MSG_HEAD_TAG;
-		if (!(q->state & (1UL << TGT_QUEUE_BLOCKED)) &&
-		    !q->active_cmd)
+		cmd->attribute = MSG_ORDERED_TAG;
+		if (!queue_blocked(q) && !queue_active(q))
 			enabled = 1;
 	}
 
@@ -321,7 +342,7 @@
 	switch (cmd->attribute) {
 	case MSG_ORDERED_TAG:
 	case MSG_HEAD_TAG:
-		q->state |= (1UL << TGT_QUEUE_BLOCKED);
+		set_queue_blocked(q);
 		break;
 	}
 }
@@ -500,7 +521,8 @@
 	switch (cmd->attribute) {
 	case MSG_ORDERED_TAG:
 	case MSG_HEAD_TAG:
-		q->state &= ~(1UL << TGT_QUEUE_BLOCKED);
+		clear_queue_blocked(q);
+		break;
 	}
 
 	free(cmd);



From tomo at berlios.de  Sat Mar  4 07:55:57 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 07:55:57 +0100
Subject: [Stgt-svn] r367 - branches/use-scsi-ml/usr
Message-ID: <200603040655.k246tvqk023629@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 07:55:51 +0100 (Sat, 04 Mar 2006)
New Revision: 367

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Preventing a device having commands in its queue from being deleted. We need the proper refcount stuff later on.


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-04 02:15:18 UTC (rev 366)
+++ branches/use-scsi-ml/usr/target.c	2006-03-04 06:55:51 UTC (rev 367)
@@ -255,8 +255,6 @@
 	struct target *target;
 	struct tgt_device *device;
 
-	/* TODO: check whether the device has flying commands. */
-
 	dprintf("%u %" PRIu64 "\n", tid, dev_id);
 
 	target = target_get(tid);
@@ -269,6 +267,9 @@
 		return -EINVAL;
 	}
 
+	if (!list_empty(&device->cmd_queue.queue))
+		return -EBUSY;
+
 	target->devt[dev_id] = NULL;
 	if (device->addr)
 		munmap((void *) (unsigned long) device->addr, device->size);



From tomo at berlios.de  Sat Mar  4 08:35:07 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 08:35:07 +0100
Subject: [Stgt-svn] r368 - branches/use-scsi-ml/usr
Message-ID: <200603040735.k247Z7EH004445@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 08:34:47 +0100 (Sat, 04 Mar 2006)
New Revision: 368

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Finish tgt_target_destroy though it is still incomplete (unbind hosts binded to the target).


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-04 06:55:51 UTC (rev 367)
+++ branches/use-scsi-ml/usr/target.c	2006-03-04 07:34:47 UTC (rev 368)
@@ -640,5 +640,26 @@
 
 int tgt_target_destroy(int tid)
 {
+	struct target *target = target_get(tid);
+
+	if (!target)
+		return -ENOENT;
+
+	if (!list_empty(&target->device_list)) {
+		eprintf("target %d still has devices\n", tid);
+		return -EBUSY;
+	}
+
+	if (!list_empty(&target->cmd_queue.queue))
+		return -EBUSY;
+
+	free(target->devt);
+
+	tgt_target_dir_attr_delete(tid, "hostno");
+	tgt_target_dir_delete(tid);
+
+	tgtt[tid] = NULL;
+	free(target);
+
 	return 0;
 }



From tomo at berlios.de  Sat Mar  4 13:46:40 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 13:46:40 +0100
Subject: [Stgt-svn] r369 - branches/use-scsi-ml/kernel
Message-ID: <200603041246.k24CkeCJ032707@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 13:46:38 +0100 (Sat, 04 Mar 2006)
New Revision: 369

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
Call scsi_host_put() right after scsi_host_lookup() in scsi_tgt_kspace_exec() for simplicity. I guess that scsi_host_get/put_command() does ref-count stuff for us.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-04 07:34:47 UTC (rev 368)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-04 12:46:38 UTC (rev 369)
@@ -530,6 +530,7 @@
 		printk(KERN_ERR "Could not find host no %d\n", host_no);
 		return -EINVAL;
 	}
+	scsi_host_put(shost);
 
 	rq = tgt_cmd_hash_end(shost->uspace_req_q, cid);
 	if (!rq) {
@@ -578,7 +579,6 @@
 	err = scsi_tgt_transfer_data(cmd);
 
 done:
-	scsi_host_put(shost);
 	return err;
 }
 



From tomo at berlios.de  Sat Mar  4 14:48:31 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 14:48:31 +0100
Subject: [Stgt-svn] r370 - branches/use-scsi-ml/kernel
Message-ID: <200603041348.k24DmVBY030743@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 14:48:29 +0100 (Sat, 04 Mar 2006)
New Revision: 370

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
Log:
scsi_tgt_cmd_destroy() delete commands from hash lists instead of scsi_tgt_kspace_exec() because we possibly need to send back commands to tgtd.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-04 12:46:38 UTC (rev 369)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-04 13:48:29 UTC (rev 370)
@@ -87,9 +87,16 @@
 {
 	struct scsi_cmnd *cmd = data;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+	struct scsi_tgt_queuedata *qdata = cmd->request->q->queuedata;
+	unsigned long flags;
 
 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
 		rq_data_dir(cmd->request));
+
+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+	list_del(&tcmd->hash_list);
+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+
 	/*
 	 * We must set rq->flags here because bio_map_user and
 	 * blk_rq_bio_prep ruined ti.
@@ -491,7 +498,7 @@
 	return 0;
 }
 
-static struct request *tgt_cmd_hash_end(struct request_queue *q, u32 cid)
+static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
 {
 	struct scsi_tgt_queuedata *qdata = q->queuedata;
 	struct request *rq = NULL;
@@ -504,7 +511,6 @@
 	list_for_each_entry(tcmd, head, hash_list) {
 		if (tcmd->rq->tag == cid) {
 			rq = tcmd->rq;
-			list_del(&tcmd->hash_list);
 			break;
 		}
 	}
@@ -532,7 +538,7 @@
 	}
 	scsi_host_put(shost);
 
-	rq = tgt_cmd_hash_end(shost->uspace_req_q, cid);
+	rq = tgt_cmd_hash_lookup(shost->uspace_req_q, cid);
 	if (!rq) {
 		printk(KERN_ERR "Could not find cid %u\n", cid);
 		err = -EINVAL;



From tomo at berlios.de  Sat Mar  4 17:00:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 4 Mar 2006 17:00:33 +0100
Subject: [Stgt-svn] r371 - branches/use-scsi-ml/usr
Message-ID: <200603041600.k24G0Xs5024571@sheep.berlios.de>

Author: tomo
Date: 2006-03-04 17:00:26 +0100 (Sat, 04 Mar 2006)
New Revision: 371

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
tgtd needs to set rw to READ even with a WRITE command if it fails.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-04 13:48:29 UTC (rev 370)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-04 16:00:26 UTC (rev 371)
@@ -676,6 +676,7 @@
 		if (result == SAM_STAT_GOOD)
 			*try_map = 1;
 		else {
+			*rw = READ;
 			*offset = 0;
 			if (!data)
 				data = valloc(PAGE_SIZE);



From tomo at berlios.de  Mon Mar  6 09:47:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Mar 2006 09:47:28 +0100
Subject: [Stgt-svn] r372 - branches/use-scsi-ml/doc
Message-ID: <200603060847.k268lSsG017134@sheep.berlios.de>

Author: tomo
Date: 2006-03-06 09:47:21 +0100 (Mon, 06 Mar 2006)
New Revision: 372

Added:
   branches/use-scsi-ml/doc/index.html
Log:
Write simple index.html


Added: branches/use-scsi-ml/doc/index.html
===================================================================
--- branches/use-scsi-ml/doc/index.html	2006-03-04 16:00:26 UTC (rev 371)
+++ branches/use-scsi-ml/doc/index.html	2006-03-06 08:47:21 UTC (rev 372)
@@ -0,0 +1,137 @@
+<?xml version="1.0" encoding="iso-8859-1"?>
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
+
+<head>
+<meta name="author" content="FUJITA Tomonori and Mike Christie" />
+<meta name="copyright" content="Copyright (C) 2006 FUJITA Tomonori and Mike Christie" />
+<meta name="description" content="Use all information at this site only at your own responsibility. I am not taking any responsibility for it on your behalf." />
+<meta name="robots" content="INDEX,FOLLOW" />
+<title>Linux SCSI target framework (tgt) project</title>
+<style type =" text/css">
+body { margin:20px; }
+a:link {
+text-decoration: none;
+}
+
+a:visited {
+text-decoration: none;
+}
+
+a:hover {
+text-decoration: none;
+}
+</style>
+</head>
+
+<body>
+
+<div class="header">
+<div class="title"><h1>Linux SCSI target framework (tgt) project</h1></div>
+</div>
+
+<div class="body">
+<div class="ex">
+<div>
+<p>
+Linux target framework (tgt) aims to simplify various SCSI target driver
+(iSCSI, Fibre Channel, RDMA, etc) creation and maintenance. Our key goal
+is implementing a great portion of tgt in user space.
+</p>
+
+<p>
+The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly.
+</p>
+
+</div>
+
+
+<div>
+<p>
+<strong>Target drivers</strong>
+</p>
+
+<ul>
+
+<li>
+<p>
+Virtual SCSI target driver in IBM pSeries
+</p>
+</li>
+
+<li>
+<p>
+Qlogic qla2xxx FC target driver (not yet)
+</p>
+</li>
+
+<li>
+<p>
+LSI logic fusion FC target driver (not yet)
+</p>
+</li>
+
+<li>
+<p>
+iSCSI software target driver for Ethernet NICs (not yet)
+</p>
+</li>
+
+<li>
+<p>
+Qlogic qla4xxx iSCSI target driver (not yet)
+</p>
+</li>
+
+</ul>
+</div>
+
+
+<div>
+<p>
+<strong>TODO</strong>
+</p>
+
+<ul>
+
+<li>
+<p>
+Writing target drivers
+</p>
+</li>
+
+<li>
+<p>
+Fix out-of-memory bugs
+</p>
+</li>
+
+<li>
+<p>
+Implement TMF (task management function)
+</p>
+</li>
+
+<li>
+<p>
+Implement Reserve/Release command support
+</p>
+</li>
+
+</ul>
+</div>
+
+
+<hr />
+
+<div>
+<img style="float:right; vertical-align:middle;" width="124px" height="32px" border="0" alt="BerliOS Developer Logo" src="http://developer.berlios.de/bslogo.php?group_id=3467">
+Linux target framework project was started and has been maintained by Mike Christie (michaelc at cs.wisc.edu) and FUJITA Tomonori (tomof at acm.org).
+<br />
+$Date:$
+</div>
+
+</div>
+</div>
+</body>
+</html>



From tomo at berlios.de  Mon Mar  6 09:53:24 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 6 Mar 2006 09:53:24 +0100
Subject: [Stgt-svn] r373 - branches/use-scsi-ml/doc
Message-ID: <200603060853.k268rOxJ028142@sheep.berlios.de>

Author: tomo
Date: 2006-03-06 09:53:22 +0100 (Mon, 06 Mar 2006)
New Revision: 373

Modified:
   branches/use-scsi-ml/doc/index.html
Log:
Trivial change to index.html.

Modified: branches/use-scsi-ml/doc/index.html
===================================================================
--- branches/use-scsi-ml/doc/index.html	2006-03-06 08:47:21 UTC (rev 372)
+++ branches/use-scsi-ml/doc/index.html	2006-03-06 08:53:22 UTC (rev 373)
@@ -128,7 +128,6 @@
 <img style="float:right; vertical-align:middle;" width="124px" height="32px" border="0" alt="BerliOS Developer Logo" src="http://developer.berlios.de/bslogo.php?group_id=3467">
 Linux target framework project was started and has been maintained by Mike Christie (michaelc at cs.wisc.edu) and FUJITA Tomonori (tomof at acm.org).
 <br />
-$Date:$
 </div>
 
 </div>



From tomo at berlios.de  Mon Mar 13 12:39:15 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 12:39:15 +0100
Subject: [Stgt-svn] r374 - branches/use-scsi-ml/usr
Message-ID: <200603131139.k2DBdFHj009934@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 12:38:55 +0100 (Mon, 13 Mar 2006)
New Revision: 374

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Now scsi.c does not use scsi_get_devid().

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-06 08:53:22 UTC (rev 373)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-13 11:38:55 UTC (rev 374)
@@ -274,15 +274,12 @@
 static int inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
 		   uint8_t *scb, uint8_t *data, int *len)
 {
-	uint64_t lun;
 	int result = SAM_STAT_CHECK_CONDITION;
 
-	lun = scsi_get_devid(lun_buf);
-
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto err;
 
-	dprintf("%" PRIx64 " %x %x\n", lun, scb[1], scb[2]);
+	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
 		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
@@ -350,10 +347,8 @@
 
 	*len = min_t(int, *len, scb[4]);
 
-	if (!dev) {
-		dprintf("%" PRIu64 "\n", lun);
+	if (!dev)
 		data[0] = TYPE_NO_LUN;
-	}
 
 	return SAM_STAT_GOOD;
 
@@ -611,12 +606,9 @@
 {
 	int result = SAM_STAT_GOOD;
 	uint8_t *data = NULL, *scb = pdu;
-	uint64_t lun;
 
-	lun = scsi_get_devid(lun_buf);
+	dprintf("%x %u\n", scb[0], datalen);
 
-	dprintf("%" PRIu64 " %x %u\n", lun, scb[0], datalen);
-
 	*offset = 0;
 	if (!mmap_cmd_init(scb, rw))
 		data = valloc(PAGE_SIZE);
@@ -689,7 +681,7 @@
 	case RESERVE_10:
 	case RELEASE_10:
 	default:
-		eprintf("BUG? %u %" PRIu64 "\n", scb[0], lun);
+		eprintf("unknown command %x %u\n", scb[0], datalen);
 		*len = 0;
 		break;
 	}



From tomo at berlios.de  Mon Mar 13 15:02:59 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 15:02:59 +0100
Subject: [Stgt-svn] r375 - branches/use-scsi-ml/usr
Message-ID: <200603131402.k2DE2xPn011992@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 15:02:45 +0100 (Mon, 13 Mar 2006)
New Revision: 375

Modified:
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/dl.h
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/tgt_sysfs.c
   branches/use-scsi-ml/usr/tgtd.c
   branches/use-scsi-ml/usr/util.h
Log:
Clean up the dynamic library code.


Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/dl.c	2006-03-13 14:02:45 UTC (rev 375)
@@ -33,6 +33,7 @@
 
 #include "log.h"
 #include "dl.h"
+#include "util.h"
 #include "tgt_sysfs.h"
 
 /*
@@ -46,69 +47,53 @@
 	{"istgt", }, {"ibmvstgt",},
 };
 
-#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+/* Bah, any better way? */
+static char *dl_fn_table[] = {
+	"poll_init",
+	"poll_event",
+	"ipc_mgmt",
+	"scsi_inquiry",
+	"scsi_report_lun",
+	"scsi_lun_to_int",
+};
 
 int dl_init(struct driver_info *dinfo)
 {
-	int i, fd, err;
+	int i, j, fd, err;
 	char path[PATH_MAX];
-	mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
-	mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
 
 	system("rm -rf " TGT_LLD_SYSFSDIR);
-	err = mkdir(TGT_LLD_SYSFSDIR, dmode);
+	err = mkdir(TGT_LLD_SYSFSDIR, DEFDMODE);
 	if (err < 0) {
 		perror("Cannot create " TGT_LLD_SYSFSDIR);
 		return err;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(dlinfo); i++) {
-		snprintf(path, sizeof(path), "%s.so", dlinfo[i].name);
+		snprintf(path, sizeof(path), "lib%s.so", dlinfo[i].name);
 		dlinfo[i].dl = dlopen(path, RTLD_LAZY);
-		if (dlinfo[i].dl)
+		if (dlinfo[i].dl) {
 			eprintf("%s library was loaded.\n", dlinfo[i].name);
-		else
+			for (j = 0; j < ARRAY_SIZE(dl_fn_table); j++)
+				dlinfo[i].fn[j] =
+					dlsym(dlinfo[i].dl, dl_fn_table[j]);
+		} else
 			eprintf("%s library is not loaded.\n", dlinfo[i].name);
 
 		snprintf(path, sizeof(path), TGT_LLD_SYSFSDIR "/%d-%s",
 			 i, dlinfo[i].name);
 
-		fd = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+		fd = open(path, O_RDWR|O_CREAT|O_EXCL, DEFFMODE);
 		if (fd < 0) {
 			eprintf("Cannot create %s.\n", path);
-			exit(-1);
+			exit(1);
 		}
 	}
 
 	return ARRAY_SIZE(dlinfo);
 }
 
-void *dl_poll_init_fn(struct driver_info *dinfo, int idx)
+void *dl_fn(struct driver_info *dinfo, int idx, int function)
 {
-	if (dinfo[idx].dl)
-		return dlsym(dinfo[idx].dl, "poll_init");
-	return NULL;
+	return dinfo[idx].fn[function];
 }
-
-void *dl_poll_fn(struct driver_info *dinfo, int idx)
-{
-	if (dinfo[idx].dl)
-		return dlsym(dinfo[idx].dl, "poll_event");
-	return NULL;
-}
-
-void *dl_ipc_fn(struct driver_info *dinfo, int typeid)
-{
-	if (dinfo[typeid].dl)
-		return dlsym(dinfo[typeid].dl, "ipc_mgmt");
-
-	return NULL;
-}
-
-void *dl_event_fn(struct driver_info *dinfo, int tid, int typeid)
-{
-	if (dinfo[typeid].dl)
-		return dlsym(dinfo[typeid].dl, "async_event");
-
-	return NULL;
-}

Modified: branches/use-scsi-ml/usr/dl.h
===================================================================
--- branches/use-scsi-ml/usr/dl.h	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/dl.h	2006-03-13 14:02:45 UTC (rev 375)
@@ -3,19 +3,22 @@
 
 #define	MAX_DL_HANDLES	16
 
+#define	DL_FN_POLL_INIT		0
+#define	DL_FN_POLL_EVENT	1
+#define	DL_FN_IPC_MGMT		2
+#define	DL_FN_SCSI_INQUIRY	3
+#define	DL_FN_SCSI_REPORT_LUN	4
+#define	DL_FN_SCSI_LUN_TO_INT	5
+#define	DL_FN_END		6
+
 struct driver_info {
 	char *name;
 	void *dl;
+	void *fn[DL_FN_END];
 };
 
 extern struct driver_info dlinfo[];
 
 extern int dl_init(struct driver_info *);
-extern struct pollfd * dl_poll_init(struct driver_info *, int *nr);
-
-extern void *dl_poll_init_fn(struct driver_info *, int idx);
-extern void *dl_poll_fn(struct driver_info *, int idx);
-extern void *dl_ipc_fn(struct driver_info *, int typeid);
-extern void *dl_event_fn(struct driver_info *, int tid, int typeid);
-
+extern void *dl_fn(struct driver_info *, int, int);
 #endif

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-03-13 14:02:45 UTC (rev 375)
@@ -224,7 +224,7 @@
 	req = NLMSG_DATA(nlh);
 	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
 
-	fn = dl_ipc_fn(dinfo, req->typeid);
+	fn = dl_fn(dinfo, req->typeid, DL_FN_IPC_MGMT);
 	if (fn)
 		err = fn((char *) nlh, rbuf);
 	else

Modified: branches/use-scsi-ml/usr/tgt_sysfs.c
===================================================================
--- branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/tgt_sysfs.c	2006-03-13 14:02:45 UTC (rev 375)
@@ -39,8 +39,6 @@
 	DELETE,
 };
 
-static mode_t dmode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
-
 static int tgt_set_string(char *buf, int size, const char *fmt, va_list ap)
 {
 	int err;
@@ -67,7 +65,7 @@
 	if (op)
 		err = unlink(path);
 	else
-		err = mkdir(path, dmode);
+		err = mkdir(path, DEFDMODE);
 
 	if (err < 0)
 		eprintf("fail to create %s %s\n",
@@ -81,7 +79,6 @@
 {
 	int err;
 	char path[PATH_MAX];
-	mode_t fmode = S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
 
 	va_list ap;
 	va_start(ap, fmt);
@@ -93,7 +90,7 @@
 	if (op)
 		err = unlink(path);
 	else
-		err = open(path, O_RDWR|O_CREAT|O_EXCL, fmode);
+		err = open(path, O_RDWR|O_CREAT|O_EXCL, DEFFMODE);
 
 	if (err < 0)
 		eprintf("fail to %s %s\n", op ? "delete" : "create", path);
@@ -130,7 +127,7 @@
 
 	system("rm -rf " TGT_TARGET_SYSFSDIR);
 
-	err = mkdir(TGT_TARGET_SYSFSDIR, dmode);
+	err = mkdir(TGT_TARGET_SYSFSDIR, DEFDMODE);
 	if (err < 0)
 		perror("Cannot create " TGT_TARGET_SYSFSDIR);
 

Modified: branches/use-scsi-ml/usr/tgtd.c
===================================================================
--- branches/use-scsi-ml/usr/tgtd.c	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/tgtd.c	2006-03-13 14:02:45 UTC (rev 375)
@@ -153,7 +153,7 @@
 			continue;
 
 		for (i = 0; i < nr_dls; i++) {
-			fn = dl_poll_fn(dlinfo, i);
+			fn = dl_fn(dlinfo, i, DL_FN_POLL_EVENT);
 			if (fn)
 				fn(pfd + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
 		}
@@ -178,7 +178,7 @@
 	pfd[POLL_UD].events = POLLIN;
 
 	for (i = 0; i < nr; i++) {
-		fn = dl_poll_init_fn(dlinfo, i);
+		fn = dl_fn(dlinfo, i, DL_FN_POLL_INIT);
 		if (fn)
 			fn(pfd + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
 	}

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-03-13 11:38:55 UTC (rev 374)
+++ branches/use-scsi-ml/usr/util.h	2006-03-13 14:02:45 UTC (rev 375)
@@ -11,3 +11,5 @@
 
 #define pgcnt(size, offset)	((((size) + ((offset) & ~PAGE_MASK)) + PAGE_SIZE - 1) >> PAGE_SHIFT)
 
+#define	DEFDMODE	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
+#define	DEFFMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)



From tomo at berlios.de  Mon Mar 13 15:30:41 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 15:30:41 +0100
Subject: [Stgt-svn] r376 - branches/use-scsi-ml/usr
Message-ID: <200603131430.k2DEUfbM024596@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 15:30:37 +0100 (Mon, 13 Mar 2006)
New Revision: 376

Modified:
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/util.h
Log:
Move min/max from scsi.c to util.h since libibmvstgt needs it.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-13 14:02:45 UTC (rev 375)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-13 14:30:37 UTC (rev 376)
@@ -34,23 +34,6 @@
 
 #define BLK_SHIFT	9
 
-#define min(x,y) ({ \
-	typeof(x) _x = (x);	\
-	typeof(y) _y = (y);	\
-	(void) (&_x == &_y);		\
-	_x < _y ? _x : _y; })
-
-#define max(x,y) ({ \
-	typeof(x) _x = (x);	\
-	typeof(y) _y = (y);	\
-	(void) (&_x == &_y);		\
-	_x > _y ? _x : _y; })
-
-#define min_t(type,x,y) \
-	({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
-#define max_t(type,x,y) \
-	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
-
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
 #define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))

Modified: branches/use-scsi-ml/usr/util.h
===================================================================
--- branches/use-scsi-ml/usr/util.h	2006-03-13 14:02:45 UTC (rev 375)
+++ branches/use-scsi-ml/usr/util.h	2006-03-13 14:30:37 UTC (rev 376)
@@ -13,3 +13,21 @@
 
 #define	DEFDMODE	(S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
 #define	DEFFMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)
+
+#define min(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#define max(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+#define min_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x < __y ? __x: __y; })
+#define max_t(type,x,y) \
+	({ type __x = (x); type __y = (y); __x > __y ? __x: __y; })
+



From tomo at berlios.de  Mon Mar 13 15:37:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 15:37:28 +0100
Subject: [Stgt-svn] r377 - branches/use-scsi-ml/usr
Message-ID: <200603131437.k2DEbS2N027476@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 15:37:22 +0100 (Mon, 13 Mar 2006)
New Revision: 377

Modified:
   branches/use-scsi-ml/usr/scsi.c
Log:
Kill cpu_to_* and *_to_cpu macro.


Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-13 14:30:37 UTC (rev 376)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-13 14:37:22 UTC (rev 377)
@@ -27,11 +27,6 @@
 
 #include "tgtd.h"
 
-#define cpu_to_be32 __cpu_to_be32
-#define be32_to_cpu __be32_to_cpu
-#define cpu_to_be64 __cpu_to_be64
-#define be64_to_cpu __be64_to_cpu
-
 #define BLK_SHIFT	9
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
@@ -109,7 +104,7 @@
 	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
 	ncyl = sec >> 14; /* 256 * 64 */
 	p = (uint32_t *)(ptr + 1);
-	*p = *p | cpu_to_be32(ncyl);
+	*p = *p | __cpu_to_be32(ncyl);
 	return sizeof(geo_m_pg);
 }
 
@@ -128,8 +123,8 @@
 		data[3] = 8;
 		*len += 8;
 		*(uint32_t *)(data + 4) = (size >> 32) ?
-			cpu_to_be32(0xffffffff) : cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = cpu_to_be32(1 << BLK_SHIFT);
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
 	}
 
 	switch (pcode) {
@@ -360,7 +355,7 @@
 
 	memset(data, 0, rbuflen);
 
-	alen = be32_to_cpu(*(uint32_t *)&scb[6]);
+	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
 	if (alen < 16) {
 		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
 					0x24, 0);
@@ -392,8 +387,8 @@
 /* 		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16); */
 		lun = make_lun(0, lun & 0x003f, 0);
 		dprintf("%" PRIx64 "\n", lun);
-/* 		data[idx++] = cpu_to_be64(lun << 32); */
-		data[idx++] = cpu_to_be64(lun);
+/* 		data[idx++] = __cpu_to_be64(lun << 32); */
+		data[idx++] = __cpu_to_be64(lun);
 		if (!(alen -= 8))
 			break;
 		if (!(rbuflen -= 8)) {
@@ -404,7 +399,7 @@
 	}
 
 done:
-	*((uint32_t *) data) = cpu_to_be32(nr_luns * 8);
+	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
 
 	return result;
@@ -424,8 +419,8 @@
 	size = dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
-		cpu_to_be32(0xffffffff) : cpu_to_be32(size - 1);
-	data[1] = cpu_to_be32(1U << BLK_SHIFT);
+		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
+	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
 	*len = 8;
 
 	return SAM_STAT_GOOD;
@@ -472,8 +467,8 @@
 	size = dev->size >> BLK_SHIFT;
 
 	data64 = (uint64_t *) data;
-	data64[0] = cpu_to_be64(size - 1);
-	data[2] = cpu_to_be32(1UL << BLK_SHIFT);
+	data64[0] = __cpu_to_be64(size - 1);
+	data[2] = __cpu_to_be32(1UL << BLK_SHIFT);
 
 	*len = 32;
 
@@ -496,11 +491,11 @@
 	case READ_10:
 	case WRITE_10:
 	case WRITE_VERIFY:
-		off = be32_to_cpu(*(uint32_t *) &scb[2]);
+		off = __be32_to_cpu(*(uint32_t *) &scb[2]);
 		break;
 	case READ_16:
 	case WRITE_16:
-		off = be64_to_cpu(*(uint64_t *) &scb[2]);
+		off = __be64_to_cpu(*(uint64_t *) &scb[2]);
 		break;
 	default:
 		off = 0;



From tomo at berlios.de  Mon Mar 13 15:50:14 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 15:50:14 +0100
Subject: [Stgt-svn] r378 - branches/use-scsi-ml/usr
Message-ID: <200603131450.k2DEoEMY003582@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 15:49:52 +0100 (Mon, 13 Mar 2006)
New Revision: 378

Modified:
   branches/use-scsi-ml/usr/mgmt.c
Log:
We need to use tid instead of typeid with tgt_target_create().

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-03-13 14:37:22 UTC (rev 377)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-03-13 14:49:52 UTC (rev 378)
@@ -72,7 +72,7 @@
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(req->typeid);
+		err = tgt_target_create(req->tid);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);



From tomo at berlios.de  Mon Mar 13 15:54:01 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 15:54:01 +0100
Subject: [Stgt-svn] r379 - branches/use-scsi-ml/usr
Message-ID: <200603131454.k2DEs1Yt005569@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 15:53:58 +0100 (Mon, 13 Mar 2006)
New Revision: 379

Modified:
   branches/use-scsi-ml/usr/mgmt.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Add lld_id to target structure. tgt_target_bind() sets it.

Modified: branches/use-scsi-ml/usr/mgmt.c
===================================================================
--- branches/use-scsi-ml/usr/mgmt.c	2006-03-13 14:49:52 UTC (rev 378)
+++ branches/use-scsi-ml/usr/mgmt.c	2006-03-13 14:53:58 UTC (rev 379)
@@ -78,7 +78,7 @@
 		err = tgt_target_destroy(req->tid);
 		break;
 	case OP_BIND:
-		err = tgt_target_bind(req->tid, req->host_no);
+		err = tgt_target_bind(req->tid, req->host_no, req->typeid);
 		break;
 	default:
 		break;

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-13 14:49:52 UTC (rev 378)
+++ branches/use-scsi-ml/usr/target.c	2006-03-13 14:53:58 UTC (rev 379)
@@ -77,6 +77,7 @@
 
 struct target {
 	int tid;
+	int lid;
 
 	uint64_t max_device;
 	struct tgt_device **devt;
@@ -562,7 +563,7 @@
 	}
 }
 
-int tgt_target_bind(int tid, int host_no)
+int tgt_target_bind(int tid, int host_no, int lid)
 {
 	int err;
 
@@ -570,6 +571,7 @@
 		eprintf("target is not found %d\n", tid);
 		return -EINVAL;
 	}
+	tgtt[tid]->lid = lid;
 
 	if (hostt[host_no]) {
 		eprintf("host is already binded %d %d\n", tid, host_no);

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-13 14:49:52 UTC (rev 378)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-13 14:53:58 UTC (rev 379)
@@ -40,7 +40,7 @@
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_target_create(int tid);
 extern int tgt_target_destroy(int tid);
-extern int tgt_target_bind(int tid, int host_no);
+extern int tgt_target_bind(int tid, int host_no, int lid);
 
 extern uint64_t scsi_get_devid(uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,



From tomo at berlios.de  Mon Mar 13 23:34:22 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 13 Mar 2006 23:34:22 +0100
Subject: [Stgt-svn] r380 - branches/use-scsi-ml/usr
Message-ID: <200603132234.k2DMYMnH028985@sheep.berlios.de>

Author: tomo
Date: 2006-03-13 23:34:21 +0100 (Mon, 13 Mar 2006)
New Revision: 380

Modified:
   branches/use-scsi-ml/usr/dl.h
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/target.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Add dynamic library support to scsi.c


Modified: branches/use-scsi-ml/usr/dl.h
===================================================================
--- branches/use-scsi-ml/usr/dl.h	2006-03-13 14:53:58 UTC (rev 379)
+++ branches/use-scsi-ml/usr/dl.h	2006-03-13 22:34:21 UTC (rev 380)
@@ -7,7 +7,7 @@
 #define	DL_FN_POLL_EVENT	1
 #define	DL_FN_IPC_MGMT		2
 #define	DL_FN_SCSI_INQUIRY	3
-#define	DL_FN_SCSI_REPORT_LUN	4
+#define	DL_FN_SCSI_REPORT_LUNS	4
 #define	DL_FN_SCSI_LUN_TO_INT	5
 #define	DL_FN_END		6
 

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-13 14:53:58 UTC (rev 379)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-13 22:34:21 UTC (rev 380)
@@ -249,8 +249,8 @@
 	return sizeof(*id);
 }
 
-static int inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
-		   uint8_t *scb, uint8_t *data, int *len)
+static int __inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
+		     uint8_t *scb, uint8_t *data, int *len)
 {
 	int result = SAM_STAT_CHECK_CONDITION;
 
@@ -336,6 +336,14 @@
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+static int inquiry(int lid, struct tgt_device *dev, int host_no,
+		   uint8_t *lun_buf, uint8_t *scb, uint8_t *data, int *len)
+{
+	typeof(__inquiry) *fn;
+	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_INQUIRY) ? : __inquiry;
+	return fn(dev, host_no, lun_buf, scb, data, len);
+}
+
 uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
 {
 	uint16_t result = (0x8000 |
@@ -345,8 +353,8 @@
 	return ((uint64_t) result) << 48;
 }
 
-static int report_luns(struct list_head *dev_list, uint8_t *lun_buf, uint8_t *scb,
-		       uint8_t *p, int *len)
+static int __report_luns(struct list_head *dev_list, uint8_t *lun_buf,
+			 uint8_t *scb, uint8_t *p, int *len)
 {
 	struct tgt_device *dev;
 	uint64_t lun, *data = (uint64_t *) p;
@@ -405,6 +413,14 @@
 	return result;
 }
 
+static int report_luns(int lid, struct list_head *dev_list, uint8_t *lun_buf,
+		       uint8_t *scb, uint8_t *p, int *len)
+{
+	typeof(__report_luns) *fn;
+	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_REPORT_LUNS) ? : __report_luns;
+	return fn(dev_list, lun_buf, scb, p, len);
+}
+
 static int read_capacity(struct tgt_device *dev, uint8_t *scb, uint8_t *p, int *len)
 {
 	uint32_t *data = (uint32_t *) p;
@@ -548,7 +564,7 @@
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
 
-uint64_t scsi_get_devid(uint8_t *p)
+static uint64_t __scsi_get_devid(uint8_t *p)
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
@@ -577,7 +593,14 @@
 	return lun;
 }
 
-int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
+uint64_t scsi_get_devid(int lid, uint8_t *p)
+{
+	typeof(__scsi_get_devid) *fn;
+	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_LUN_TO_INT) ? : __scsi_get_devid;
+	return fn(p);
+}
+
+int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
 		     uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 		     uint8_t *try_map, uint64_t *offset, uint8_t *lun_buf,
 		     struct tgt_device *dev, struct list_head *dev_list)
@@ -609,10 +632,10 @@
 
 	switch (scb[0]) {
 	case INQUIRY:
-		result = inquiry(dev, host_no, lun_buf, scb, data, len);
+		result = inquiry(lid, dev, host_no, lun_buf, scb, data, len);
 		break;
 	case REPORT_LUNS:
-		result = report_luns(dev_list, lun_buf, scb, data, len);
+		result = report_luns(lid, dev_list, lun_buf, scb, data, len);
 		break;
 	case READ_CAPACITY:
 		result = read_capacity(dev, scb, data, len);

Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-13 14:53:58 UTC (rev 379)
+++ branches/use-scsi-ml/usr/target.c	2006-03-13 22:34:21 UTC (rev 380)
@@ -373,7 +373,7 @@
 	cmd->attribute = ev_req->k.cmd_req.attribute;
 	list_add(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
 
-	dev_id = scsi_get_devid(ev_req->k.cmd_req.lun);
+	dev_id = scsi_get_devid(target->lid, ev_req->k.cmd_req.lun);
 	dprintf("%u %x %" PRIx64 "\n", cmd->cid, ev_req->k.cmd_req.scb[0],
 		dev_id);
 
@@ -387,7 +387,8 @@
 	enabled = cmd_pre_perform(q, cmd);
 
 	if (enabled) {
-		result = scsi_cmd_perform(cmd->hostno, ev_req->k.cmd_req.scb,
+		result = scsi_cmd_perform(target->lid,
+					  cmd->hostno, ev_req->k.cmd_req.scb,
 					  &len, ev_req->k.cmd_req.data_len,
 					  &uaddr, &rw, &mmapped, &offset,
 					  ev_req->k.cmd_req.lun, cmd->dev,
@@ -432,7 +433,8 @@
 				exit(1);
 			}
 			dprintf("perform %u %x\n", cmd->cid, cmd->attribute);
-			result = scsi_cmd_perform(cmd->hostno, cmd->scb,
+			result = scsi_cmd_perform(target->lid,
+						  cmd->hostno, cmd->scb,
 						  &len,
 						  cmd->len,
 						  &uaddr,

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-13 14:53:58 UTC (rev 379)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-13 22:34:21 UTC (rev 380)
@@ -42,8 +42,8 @@
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lid);
 
-extern uint64_t scsi_get_devid(uint8_t *pdu);
-extern int scsi_cmd_perform(int host_no, uint8_t *pdu, int *len,
+extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
+extern int scsi_cmd_perform(int lid, int host_no, uint8_t *pdu, int *len,
 			    uint32_t datalen, unsigned long *uaddr, uint8_t *rw,
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
 			    struct tgt_device *dev, struct list_head *dev_list);



From tomo at berlios.de  Tue Mar 14 00:12:45 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 00:12:45 +0100
Subject: [Stgt-svn] r381 - in branches/use-scsi-ml: . ibmvstgt ibmvstgt/usr usr
Message-ID: <200603132312.k2DNCjkf032415@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 00:12:45 +0100 (Tue, 14 Mar 2006)
New Revision: 381

Added:
   branches/use-scsi-ml/ibmvstgt/usr/
   branches/use-scsi-ml/ibmvstgt/usr/Makefile
   branches/use-scsi-ml/ibmvstgt/usr/libibmvstgt.c
Modified:
   branches/use-scsi-ml/ibmvstgt/Makefile
   branches/use-scsi-ml/initd
   branches/use-scsi-ml/usr/dl.c
   branches/use-scsi-ml/usr/scsi.c
   branches/use-scsi-ml/usr/tgtd.h
Log:
Move some dirty hacks in SCSI command processing specific to ibmvstgt to ibmvstgt dynamic library.


Modified: branches/use-scsi-ml/ibmvstgt/Makefile
===================================================================
--- branches/use-scsi-ml/ibmvstgt/Makefile	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/ibmvstgt/Makefile	2006-03-13 23:12:45 UTC (rev 381)
@@ -4,7 +4,7 @@
 	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
 endif
 
-all: mods
+all: mods usr
 
 mods:
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
@@ -13,5 +13,5 @@
 	$(MAKE) -C usr
 
 clean:
-#	$(MAKE) -C usr clean
+	$(MAKE) -C usr clean
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Added: branches/use-scsi-ml/ibmvstgt/usr/Makefile
===================================================================
--- branches/use-scsi-ml/ibmvstgt/usr/Makefile	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/ibmvstgt/usr/Makefile	2006-03-13 23:12:45 UTC (rev 381)
@@ -0,0 +1,9 @@
+CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../usr
+OBJS = libibmvstgt.o
+SHAREDLIB = libibmvstgt.so
+
+$(SHAREDLIB): $(OBJS)
+	$(CC) -shared -o $@ $(OBJS)
+
+clean:
+	rm -f *.o $(PROGRAMS) $(SHAREDLIB)

Added: branches/use-scsi-ml/ibmvstgt/usr/libibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/usr/libibmvstgt.c	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/ibmvstgt/usr/libibmvstgt.c	2006-03-13 23:12:45 UTC (rev 381)
@@ -0,0 +1,267 @@
+/*
+ * SCSI command processing specific to IBM Virtual SCSI target Driver
+ *
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ *
+ * Based on:
+ *
+ * IBM eServer i/pSeries Virtual SCSI Target Driver
+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <asm/byteorder.h>
+#include <linux/fs.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tgt_if.h>
+#include <sys/mman.h>
+
+#include "tgtd.h"
+
+#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
+#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
+#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
+
+struct inquiry_data {
+	uint8_t qual_type;
+	uint8_t rmb_reserve;
+	uint8_t version;
+	uint8_t aerc_naca_hisup_format;
+	uint8_t addl_len;
+	uint8_t sccs_reserved;
+	uint8_t bque_encserv_vs_multip_mchngr_reserved;
+	uint8_t reladr_reserved_linked_cmdqueue_vs;
+	char vendor[8];
+	char product[16];
+	char revision[4];
+	char vendor_specific[20];
+	char reserved1[2];
+	char version_descriptor[16];
+	char reserved2[22];
+	char unique[158];
+};
+
+#define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
+
+static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
+{
+	struct inquiry_data *id = (struct inquiry_data *) data;
+	char system_id[256], path[256], buf[32];
+	int fd, err, partition_number;
+	unsigned int unit_address;
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
+	fd = open(path, O_RDONLY);
+	memset(system_id, 0, sizeof(system_id));
+	err = read(fd, system_id, sizeof(system_id));
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/partition_number",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	partition_number = strtoul(buf, NULL, 10);
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/unit_address",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	unit_address = strtoul(buf, NULL, 0);
+	close(fd);
+
+	dprintf("%d %s %d %x %" PRIx64 "\n",
+		host_no, system_id, partition_number, unit_address, lun);
+
+	id->qual_type = TYPE_DISK;
+	id->rmb_reserve = 0x00;
+	id->version = 0x84;	/* ISO/IE		  */
+	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
+	id->addl_len = sizeof(*id) - 4;
+	id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
+	id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
+	memcpy(id->vendor, "IBM	    ", 8);
+	/* Don't even ask about the next bit.  AIX uses
+	 * hardcoded device naming to recognize device types
+	 * and their client won't  work unless we use VOPTA and
+	 * VDASD.
+	 */
+	memcpy(id->product, "VDASD blkdev    ", 16);
+	memcpy(id->revision, "0001", 4);
+	snprintf(id->unique,sizeof(id->unique),
+		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
+		 system_id,
+		 partition_number,
+		 unit_address,
+		 GETBUS(lun),
+		 GETTARGET(lun),
+		 GETLUN(lun));
+
+	return sizeof(*id);
+}
+
+int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
+		 uint8_t *scb, uint8_t *data, int *len)
+{
+	int result = SAM_STAT_CHECK_CONDITION;
+
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto err;
+
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (!(scb[1] & 0x3)) {
+		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
+		result = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x2) {
+		/* CmdDt bit is set */
+		/* We do not support it now. */
+		data[1] = 0x1;
+		data[5] = 0;
+		*len = 6;
+		result = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x1) {
+		/* EVPD bit set */
+		if (scb[2] == 0x0) {
+			data[1] = 0x0;
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			*len = 7;
+			result = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			data[1] = 0x80;
+			data[3] = 4;
+			memset(data + 4, 0x20, 4);
+			*len = 8;
+			result = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x83) {
+			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
+
+			data[1] = 0x83;
+			data[3] = tmp + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = tmp;
+			if (dev)
+				strncpy(data + 8, dev->scsi_id, SCSI_ID_LEN);
+			*len = tmp + 8;
+			result = SAM_STAT_GOOD;
+		}
+	}
+
+	if (result != SAM_STAT_GOOD)
+		goto err;
+
+	*len = min_t(int, *len, scb[4]);
+
+	if (!dev)
+		data[0] = TYPE_NO_LUN;
+
+	return SAM_STAT_GOOD;
+
+err:
+	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
+				0x24, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
+{
+	uint16_t result = (0x8000 |
+			   ((target & 0x003f) << 8) |
+			   ((bus & 0x0007) << 5) |
+			   (lun & 0x001f));
+	return ((uint64_t) result) << 48;
+}
+
+int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
+		     uint8_t *scb, uint8_t *p, int *len)
+{
+	struct tgt_device *dev;
+	uint64_t lun, *data = (uint64_t *) p;
+	int idx, alen, oalen, nr_luns, rbuflen = 4096;
+	int result = SAM_STAT_GOOD;
+
+	memset(data, 0, rbuflen);
+
+	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
+	if (alen < 16) {
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
+					0x24, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	alen &= ~(8 - 1);
+	oalen = alen;
+
+	if ((*((uint64_t *) lun_buf))) {
+		nr_luns = 1;
+		goto done;
+	}
+
+	alen -= 8;
+	rbuflen -= 8; /* FIXME */
+	idx = 2;
+	nr_luns = 1;
+
+	list_for_each_entry(dev, dev_list, dlist) {
+		lun = dev->lun;
+		lun = make_lun(0, lun & 0x003f, 0);
+		data[idx++] = __cpu_to_be64(lun);
+		if (!(alen -= 8))
+			break;
+		if (!(rbuflen -= 8)) {
+			fprintf(stderr, "FIXME: too many luns\n");
+			exit(-1);
+		}
+		nr_luns++;
+	}
+
+done:
+	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
+	*len = min(oalen, nr_luns * 8 + 8);
+
+	return result;
+}
+
+#define        TGT_INVALID_DEV_ID      ~0ULL
+
+uint64_t scsi_lun_to_int(uint8_t *p)
+{
+	uint64_t lun = TGT_INVALID_DEV_ID;
+
+	lun = *((uint64_t *) p);
+	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
+
+	if (GETBUS(lun) || GETLUN(lun))
+		return TGT_INVALID_DEV_ID;
+	else
+		return GETTARGET(lun);
+}
+

Modified: branches/use-scsi-ml/initd
===================================================================
--- branches/use-scsi-ml/initd	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/initd	2006-03-13 23:12:45 UTC (rev 381)
@@ -5,7 +5,7 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 MEM_SIZE=1048576
-export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${LD_LIBRARY_PATH}
+export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${PWD}/ibmvstgt/usr:${LD_LIBRARY_PATH}
 
 if [ -f ${PWD}/istgt/kernel/istgt.ko ] ; then
 	TARGET=istgt

Modified: branches/use-scsi-ml/usr/dl.c
===================================================================
--- branches/use-scsi-ml/usr/dl.c	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/usr/dl.c	2006-03-13 23:12:45 UTC (rev 381)
@@ -53,7 +53,7 @@
 	"poll_event",
 	"ipc_mgmt",
 	"scsi_inquiry",
-	"scsi_report_lun",
+	"scsi_report_luns",
 	"scsi_lun_to_int",
 };
 

Modified: branches/use-scsi-ml/usr/scsi.c
===================================================================
--- branches/use-scsi-ml/usr/scsi.c	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/usr/scsi.c	2006-03-13 23:12:45 UTC (rev 381)
@@ -29,12 +29,8 @@
 
 #define BLK_SHIFT	9
 
-#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
-#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
-#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
-
-static int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
-		      uint8_t ascode, uint8_t ascodeq)
+int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
+		     uint8_t ascode, uint8_t ascodeq)
 {
 	int len = 6;
 
@@ -171,84 +167,6 @@
 #define PRODUCT_ID	"VIRTUAL-DISK"
 #define PRODUCT_REV	"0"
 
-struct inquiry_data {
-	uint8_t qual_type;
-	uint8_t rmb_reserve;
-	uint8_t version;
-	uint8_t aerc_naca_hisup_format;
-	uint8_t addl_len;
-	uint8_t sccs_reserved;
-	uint8_t bque_encserv_vs_multip_mchngr_reserved;
-	uint8_t reladr_reserved_linked_cmdqueue_vs;
-	char vendor[8];
-	char product[16];
-	char revision[4];
-	char vendor_specific[20];
-	char reserved1[2];
-	char version_descriptor[16];
-	char reserved2[22];
-	char unique[158];
-};
-
-#define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
-
-static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
-{
-	struct inquiry_data *id = (struct inquiry_data *) data;
-	char system_id[256], path[256], buf[32];
-	int fd, err, partition_number;
-	unsigned int unit_address;
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
-	fd = open(path, O_RDONLY);
-	memset(system_id, 0, sizeof(system_id));
-	err = read(fd, system_id, sizeof(system_id));
-	close(fd);
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/partition_number",
-		 host_no);
-	fd = open(path, O_RDONLY);
-	err = read(fd, buf, sizeof(buf));
-	partition_number = strtoul(buf, NULL, 10);
-	close(fd);
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/unit_address",
-		 host_no);
-	fd = open(path, O_RDONLY);
-	err = read(fd, buf, sizeof(buf));
-	unit_address = strtoul(buf, NULL, 0);
-	close(fd);
-
-	dprintf("%d %s %d %x %" PRIx64 "\n",
-		host_no, system_id, partition_number, unit_address, lun);
-
-	id->qual_type = TYPE_DISK;
-	id->rmb_reserve = 0x00;
-	id->version = 0x84;	/* ISO/IE		  */
-	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
-	id->addl_len = sizeof(*id) - 4;
-	id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
-	id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
-	memcpy(id->vendor, "IBM	    ", 8);
-	/* Don't even ask about the next bit.  AIX uses
-	 * hardcoded device naming to recognize device types
-	 * and their client won't  work unless we use VOPTA and
-	 * VDASD.
-	 */
-	memcpy(id->product, "VDASD blkdev    ", 16);
-	memcpy(id->revision, "0001", 4);
-	snprintf(id->unique,sizeof(id->unique),
-		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
-		 system_id,
-		 partition_number,
-		 unit_address,
-		 GETBUS(lun),
-		 GETTARGET(lun),
-		 GETLUN(lun));
-
-	return sizeof(*id);
-}
-
 static int __inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
 		     uint8_t *scb, uint8_t *data, int *len)
 {
@@ -260,8 +178,6 @@
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
-		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
-#if 0
 		data[2] = 4;
 		data[3] = 0x42;
 		data[4] = 59;
@@ -280,7 +196,6 @@
 		data[62] = 0x03;
 		data[63] = 0x00;
 		*len = 64;
-#endif
 		result = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
@@ -344,15 +259,6 @@
 	return fn(dev, host_no, lun_buf, scb, data, len);
 }
 
-uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
-{
-	uint16_t result = (0x8000 |
-			   ((target & 0x003f) << 8) |
-			   ((bus & 0x0007) << 5) |
-			   (lun & 0x001f));
-	return ((uint64_t) result) << 48;
-}
-
 static int __report_luns(struct list_head *dev_list, uint8_t *lun_buf,
 			 uint8_t *scb, uint8_t *p, int *len)
 {
@@ -373,30 +279,16 @@
 	alen &= ~(8 - 1);
 	oalen = alen;
 
-	if ((*((uint64_t *) lun_buf))) {
-		dprintf("Another sick hack for ibmvstgt\n");
-		nr_luns = 1;
-		goto done;
-	}
-
 	alen -= 8;
 	rbuflen -= 8; /* FIXME */
 	idx = 1;
 	nr_luns = 0;
 
-	/* ibmvstgt hack */
-	idx = 2;
-	nr_luns = 1;
-
 	list_for_each_entry(dev, dev_list, dlist) {
 		lun = dev->lun;
 
-		/* ibmvstgt hack */
-/* 		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16); */
-		lun = make_lun(0, lun & 0x003f, 0);
-		dprintf("%" PRIx64 "\n", lun);
-/* 		data[idx++] = __cpu_to_be64(lun << 32); */
-		data[idx++] = __cpu_to_be64(lun);
+		lun = ((lun > 0xff) ? (0x1 << 30) : 0) | ((0x3ff & lun) << 16);
+		data[idx++] = __cpu_to_be64(lun << 32);
 		if (!(alen -= 8))
 			break;
 		if (!(rbuflen -= 8)) {
@@ -406,7 +298,6 @@
 		nr_luns++;
 	}
 
-done:
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
 	*len = min(oalen, nr_luns * 8 + 8);
 
@@ -568,15 +459,6 @@
 {
 	uint64_t lun = TGT_INVALID_DEV_ID;
 
-	/* ibmvstgt hack */
-	lun = *((uint64_t *) p);
-	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
-
-	if (GETBUS(lun) || GETLUN(lun))
-		return TGT_INVALID_DEV_ID;
-	else
-		return GETTARGET(lun);
-
 	switch (*p >> 6) {
 	case 0:
 		lun = p[1];

Modified: branches/use-scsi-ml/usr/tgtd.h
===================================================================
--- branches/use-scsi-ml/usr/tgtd.h	2006-03-13 22:34:21 UTC (rev 380)
+++ branches/use-scsi-ml/usr/tgtd.h	2006-03-13 23:12:45 UTC (rev 381)
@@ -48,4 +48,6 @@
 			    uint8_t *try_map, uint64_t *offset, uint8_t *lun,
 			    struct tgt_device *dev, struct list_head *dev_list);
 
+extern int sense_data_build(uint8_t *data, uint8_t res_code, uint8_t key,
+			    uint8_t ascode, uint8_t ascodeq);
 #endif



From tomo at berlios.de  Tue Mar 14 08:11:37 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 08:11:37 +0100
Subject: [Stgt-svn] r382 - branches/use-scsi-ml/kernel
Message-ID: <200603140711.k2E7BbFn014088@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 08:11:28 +0100 (Tue, 14 Mar 2006)
New Revision: 382

Modified:
   branches/use-scsi-ml/kernel/scsi_tgt_if.c
   branches/use-scsi-ml/kernel/scsi_tgt_lib.c
   branches/use-scsi-ml/kernel/scsi_tgt_priv.h
Log:
Add TMF support (not completed yet). Currently only ABORT_TASK request is supported.


Modified: branches/use-scsi-ml/kernel/scsi_tgt_if.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-03-13 23:12:45 UTC (rev 381)
+++ branches/use-scsi-ml/kernel/scsi_tgt_if.c	2006-03-14 07:11:28 UTC (rev 382)
@@ -86,9 +86,11 @@
 	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
 	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
 	ev->k.cmd_req.attribute = cmd->tag;
+	ev->k.cmd_req.tag = *((u64 *) (cmd->sense_buffer));
 
-	dprintk("%p %d %u %u %x\n", cmd, shost->host_no, ev->k.cmd_req.cid,
-		ev->k.cmd_req.data_len, cmd->tag);
+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev->k.cmd_req.cid,
+		ev->k.cmd_req.data_len, cmd->tag,
+		(unsigned long long) ev->k.cmd_req.tag);
 
 	err = netlink_unicast(nl_sk, skb, tgtd_pid, gfp_mask & GFP_ATOMIC);
 	if (err < 0)
@@ -109,6 +111,24 @@
 	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
 }
 
+int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+				  struct scsi_lun *scsilun, void *data)
+{
+	struct tgt_event ev;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.k.tsk_mgmt_req.host_no = host_no;
+	ev.k.tsk_mgmt_req.function = function;
+	ev.k.tsk_mgmt_req.tag = tag;
+	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
+	ev.k.tsk_mgmt_req.mid = (u64) data;
+
+	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
+		(unsigned long long) ev.k.tsk_mgmt_req.mid);
+
+	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev, GFP_KERNEL, tgtd_pid);
+}
+
 static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	struct tgt_event *ev = NLMSG_DATA(nlh);
@@ -130,6 +150,11 @@
 					   ev->u.cmd_rsp.uaddr,
 					   ev->u.cmd_rsp.rw);
 		break;
+	case TGT_UEVENT_TSK_MGMT_RSP:
+		err = scsi_tgt_kspace_tsk_mgmt(ev->u.tsk_mgmt_rsp.host_no,
+					       ev->u.tsk_mgmt_rsp.mid,
+					       ev->u.tsk_mgmt_rsp.result);
+		break;
 	default:
 		eprintk("unknown type %d\n", nlh->nlmsg_type);
 		err = -EINVAL;
@@ -143,6 +168,7 @@
 	int err;
 	uint32_t rlen;
 	struct nlmsghdr	*nlh;
+	struct tgt_event ev;
 
 	while (skb->len >= NLMSG_SPACE(0)) {
 		nlh = (struct nlmsghdr *) skb->data;
@@ -158,9 +184,11 @@
 		 * TODO for passthru commands the lower level should
 		 * probably handle the result or we should modify this
 		 */
-		if (nlh->nlmsg_type != TGT_UEVENT_CMD_RSP) {
-			struct tgt_event ev;
-
+		switch (nlh->nlmsg_type) {
+		case TGT_UEVENT_CMD_RSP:
+		case TGT_UEVENT_TSK_MGMT_RSP:
+			break;
+		default:
 			memset(&ev, 0, sizeof(ev));
 			ev.k.event_rsp.err = err;
 			send_event_rsp(TGT_KEVENT_RSP, &ev,

Modified: branches/use-scsi-ml/kernel/scsi_tgt_lib.c
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-13 23:12:45 UTC (rev 381)
+++ branches/use-scsi-ml/kernel/scsi_tgt_lib.c	2006-03-14 07:11:28 UTC (rev 382)
@@ -107,7 +107,6 @@
 		cmd->request->flags &= ~1UL;
 
 	scsi_unmap_user_pages(tcmd);
-	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
 	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
 }
@@ -270,13 +269,15 @@
  * @noblock:	set to nonzero if the command should be queued
  **/
 void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
-			    int noblock)
+			    u64 tag)
 {
 	struct request_queue *q = cmd->request->q;
 	struct scsi_tgt_queuedata *qdata = q->queuedata;
 	unsigned long flags;
 
 	cmd->request->end_io_data = scsilun;
+	/* FIXME */
+	*((u64 *) (cmd->sense_buffer)) = tag;
 
 	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
 	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
@@ -296,12 +297,7 @@
 
 	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 
-	/* don't we have to call this if result is set or not */
-	if (cmd->result) {
-		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
-		return;
-	}
-
+	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
 	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
 	queue_work(scsi_tgtd, &tcmd->work);
 }
@@ -498,6 +494,18 @@
 	return 0;
 }
 
+static int scsi_tgt_abort_cmd(struct Scsi_Host *host, struct scsi_cmnd *cmd)
+{
+	int err;
+
+	err = host->hostt->eh_abort_handler(cmd);
+	if (err)
+		eprintk("fail to abort %p\n", cmd);
+
+	scsi_tgt_cmd_destroy(cmd);
+	return err;
+}
+
 static struct request *tgt_cmd_hash_lookup(struct request_queue *q, u32 cid)
 {
 	struct scsi_tgt_queuedata *qdata = q->queuedata;
@@ -549,6 +557,10 @@
 	dprintk("cmd %p result %d len %d bufflen %u %lu %x\n", cmd,
 		result, len, cmd->request_bufflen, rq_data_dir(rq), cmd->cmnd[0]);
 
+	if (result == TASK_ABORTED) {
+		scsi_tgt_abort_cmd(shost, cmd);
+		goto done;
+	}
 	/*
 	 * store the userspace values here, the working values are
 	 * in the request_* values
@@ -588,6 +600,38 @@
 	return err;
 }
 
+int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *shost, int function, u64 tag,
+			      struct scsi_lun *scsilun, void *data)
+{
+	int err;
+
+	/* TODO: need to retry if this fails. */
+	err = scsi_tgt_uspace_send_tsk_mgmt(shost->host_no, function,
+					    tag, scsilun, data);
+	if (err < 0)
+		eprintk("The task management request lost!\n");
+	return err;
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_tsk_mgmt_request);
+
+int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result)
+{
+	struct Scsi_Host *shost;
+	int err;
+
+	dprintk("%d %d %llx\n", host_no, result, (unsigned long long) mid);
+
+	shost = scsi_host_lookup(host_no);
+	if (IS_ERR(shost)) {
+		printk(KERN_ERR "Could not find host no %d\n", host_no);
+		return -EINVAL;
+	}
+	err = shost->hostt->tsk_mgmt_response(mid, result);
+	scsi_host_put(shost);
+
+	return err;
+}
+
 static int __init scsi_tgt_init(void)
 {
 	int err;

Modified: branches/use-scsi-ml/kernel/scsi_tgt_priv.h
===================================================================
--- branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-03-13 23:12:45 UTC (rev 381)
+++ branches/use-scsi-ml/kernel/scsi_tgt_priv.h	2006-03-14 07:11:28 UTC (rev 382)
@@ -19,4 +19,6 @@
 extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				unsigned long uaddr, u8 rw);
-
+extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+					 struct scsi_lun *scsilun, void *data);
+extern int scsi_tgt_kspace_tsk_mgmt(int host_no, u64 mid, int result);



From tomo at berlios.de  Tue Mar 14 08:13:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 08:13:48 +0100
Subject: [Stgt-svn] r383 - branches/use-scsi-ml/usr
Message-ID: <200603140713.k2E7Dmkj014696@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 08:13:35 +0100 (Tue, 14 Mar 2006)
New Revision: 383

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Add TMF support (only ABORT_TASK).


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-14 07:11:28 UTC (rev 382)
+++ branches/use-scsi-ml/usr/target.c	2006-03-14 07:13:35 UTC (rev 383)
@@ -34,6 +34,7 @@
 #define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
 #include <linux/hash.h>
 #include <linux/netlink.h>
+#include <scsi/scsi.h>
 #include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
@@ -58,14 +59,23 @@
 	TGT_QUEUE_DELETED,
 };
 
+enum {
+	TGT_CMD_QUEUED,
+	TGT_CMD_PROCESSED,
+	TGT_CMD_MGMT,
+};
+
 struct cmd {
 	struct list_head hlist;
 	struct list_head qlist;
+	struct list_head clist;
 	uint32_t cid;
 	uint64_t uaddr;
 	uint32_t len;
 	int mmapped;
 	struct tgt_device *dev;
+	unsigned long state;
+	uint64_t mid;
 
 	/* Kill the followings when we use shared memory instead of netlink. */
 	int hostno;
@@ -73,6 +83,7 @@
 	uint8_t scb[16];
 	uint8_t lun[8];
 	int attribute;
+	uint64_t tag;
 };
 
 struct target {
@@ -84,6 +95,7 @@
 	struct list_head device_list;
 
 	struct list_head cmd_hash_list[1 << HASH_ORDER];
+	struct list_head cmd_list;
 	struct tgt_cmd_queue cmd_queue;
 };
 
@@ -112,6 +124,25 @@
 QUEUE_FNS(BLOCKED, blocked)
 QUEUE_FNS(DELETED, deleted)
 
+#define CMD_FNS(bit, name)						\
+static inline void set_cmd_##name(struct cmd *c)			\
+{									\
+	(c)->state |= (1UL << TGT_CMD_##bit);				\
+}									\
+static inline void clear_cmd_##name(struct cmd *c)			\
+{									\
+	(c)->state &= ~(1UL << TGT_CMD_##bit);				\
+}									\
+static inline int cmd_##name(const struct cmd *c)			\
+{									\
+	return ((c)->state & (1UL << TGT_CMD_##bit));			\
+}
+
+CMD_FNS(QUEUED, queued)
+CMD_FNS(PROCESSED, processed)
+CMD_FNS(MGMT, mgmt)
+
+
 static struct target *target_get(int tid)
 {
 	if (tid >= MAX_NR_TARGET) {
@@ -367,10 +398,12 @@
 	}
 
 	/* TODO: preallocate cmd */
-	cmd = malloc(sizeof(*cmd));
+	cmd = calloc(1, sizeof(*cmd));
 	cmd->hostno = ev_req->k.cmd_req.host_no;
  	cmd->cid = ev_req->k.cmd_req.cid;
 	cmd->attribute = ev_req->k.cmd_req.attribute;
+	cmd->tag = ev_req->k.cmd_req.tag;
+	list_add(&cmd->clist, &target->cmd_list);
 	list_add(&cmd->hlist, &target->cmd_hash_list[cmd_hashfn(cmd->cid)]);
 
 	dev_id = scsi_get_devid(target->lid, ev_req->k.cmd_req.lun);
@@ -400,8 +433,10 @@
 			cmd->cid, ev_req->k.cmd_req.scb[0], uaddr,
 			offset, result);
 
+		set_cmd_processed(cmd);
 		tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
 	} else {
+		set_cmd_queued(cmd);
 		dprintf("blocked %u %x %" PRIu64 " %d\n",
 			cmd->cid, ev_req->k.cmd_req.scb[0],
 			cmd->dev ? cmd->dev->lun : ~0ULL,
@@ -445,6 +480,7 @@
 						  cmd->dev,
 						  &target->device_list);
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
+			set_cmd_processed(cmd);
 			tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
 		} else
 			break;
@@ -481,25 +517,12 @@
 	return err;
 }
 
-static void cmd_done(struct tgt_event *ev, int nl_fd)
+static void __cmd_done(struct target *target, struct cmd *cmd, int nl_fd)
 {
-	struct target *target;
 	struct tgt_cmd_queue *q;
-	struct cmd *cmd;
-	int err, do_munmap, host_no = ev->k.cmd_done.host_no;
-	uint32_t cid = ev->k.cmd_done.cid;
+	int err, do_munmap;
 
-	target = host_to_target(host_no);
-	if (!target) {
-		eprintf("%d is not bind to any target\n", host_no);
-		return;
-	}
-
-	cmd = find_cmd(target, cid);
-	if (!cmd) {
-		eprintf("Cannot find cmd %d %u\n", host_no, cid);
-		return;
-	}
+	list_del(&cmd->clist);
 	list_del(&cmd->hlist);
 
 	do_munmap = cmd->mmapped;
@@ -534,6 +557,111 @@
 	post_cmd_done(nl_fd, q);
 }
 
+static int tgt_kspace_send_tsk_mgmt(int nl_fd, int host_no, uint64_t mid,
+				    int result)
+{
+	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
+	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+
+	ev_res->u.tsk_mgmt_rsp.host_no = host_no;
+	ev_res->u.tsk_mgmt_rsp.mid = mid;
+	ev_res->u.tsk_mgmt_rsp.result = result;
+
+	return __nl_write(nl_fd, TGT_UEVENT_TSK_MGMT_RSP, resbuf,
+			  NLMSG_SPACE(sizeof(*ev_res)));
+}
+
+static void cmd_done(struct tgt_event *ev, int nl_fd)
+{
+	struct target *target;
+	struct cmd *cmd;
+	int host_no = ev->k.cmd_done.host_no;
+	uint32_t cid = ev->k.cmd_done.cid;
+
+	target = host_to_target(host_no);
+	if (!target) {
+		eprintf("%d is not bind to any target\n", host_no);
+		return;
+	}
+
+	cmd = find_cmd(target, cid);
+	if (!cmd) {
+		eprintf("Cannot find cmd %d %u\n", host_no, cid);
+		return;
+	}
+
+	if (cmd_mgmt(cmd))
+		tgt_kspace_send_tsk_mgmt(nl_fd, cmd->hostno, cmd->mid, -EEXIST);
+	__cmd_done(target, cmd, nl_fd);
+}
+
+static int abort_task_by_tag(struct target* target, uint64_t tag, uint64_t mid,
+			     int nl_fd)
+{
+	struct cmd *cmd, *tmp;
+
+	eprintf("found %" PRIx64 " %" PRIx64 "\n", tag, mid);
+
+	list_for_each_entry_safe(cmd, tmp, &target->cmd_list, clist) {
+		if (cmd->tag == tag)
+			goto found;
+	}
+	return -EEXIST;
+
+found:
+	eprintf("found %" PRIx64 " %lx\n", cmd->tag, cmd->state);
+	if (cmd_processed(cmd)) {
+		/*
+		 * We've already sent this command to kernel space.
+		 * We'll send the tsk mgmt response when we get the
+		 * completion of this command.
+		 */
+		set_cmd_mgmt(cmd);
+		cmd->mid = mid;
+		return -EBUSY;
+	} else {
+		__cmd_done(target, cmd, nl_fd);
+		tgt_kspace_send_cmd(nl_fd, cmd, TASK_ABORTED, 0);
+	}
+
+	return 0;
+}
+
+static void tsk_mgmt_req(struct tgt_event *ev_req, int nl_fd)
+{
+	struct target *target;
+	int err = 0, send = 1;
+
+	target = host_to_target(ev_req->k.cmd_req.host_no);
+	if (!target) {
+		eprintf("%d is not bind to any target\n",
+			ev_req->k.cmd_req.host_no);
+		return;
+	}
+
+	switch (ev_req->k.tsk_mgmt_req.function) {
+	case ABORT_TASK:
+		err = abort_task_by_tag(target, ev_req->k.tsk_mgmt_req.tag,
+					ev_req->k.tsk_mgmt_req.mid, nl_fd);
+		if (err == -EBUSY)
+			send = 0;
+		break;
+	case ABORT_TASK_SET:
+	case CLEAR_ACA:
+	case CLEAR_TASK_SET:
+	case LOGICAL_UNIT_RESET:
+		eprintf("Not supported yet %x\n",
+			ev_req->k.tsk_mgmt_req.function);
+		break;
+	default:
+		eprintf("Unknown task management %x\n",
+			ev_req->k.tsk_mgmt_req.function);
+	}
+
+	tgt_kspace_send_tsk_mgmt(nl_fd, ev_req->k.cmd_req.host_no,
+				 ev_req->k.tsk_mgmt_req.mid, err);
+}
+
 void nl_event_handle(int nl_fd)
 {
 	struct nlmsghdr *nlh;
@@ -559,6 +687,9 @@
 	case TGT_KEVENT_CMD_DONE:
 		cmd_done(ev, nl_fd);
 		break;
+	case TGT_KEVENT_TSK_MGMT_REQ:
+		tsk_mgmt_req(ev, nl_fd);
+		break;
 	default:
 		eprintf("unknown event %u\n", nlh->nlmsg_type);
 		exit(1);
@@ -612,6 +743,7 @@
 	}
 
 	target->tid = tid;
+	INIT_LIST_HEAD(&target->cmd_list);
 	for (i = 0; i < ARRAY_SIZE(target->cmd_hash_list); i++)
 		INIT_LIST_HEAD(&target->cmd_hash_list[i]);
 



From tomo at berlios.de  Tue Mar 14 08:14:43 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 08:14:43 +0100
Subject: [Stgt-svn] r384 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200603140714.k2E7Eh1G015055@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 08:14:36 +0100 (Tue, 14 Mar 2006)
New Revision: 384

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Add TMF support to ibmvstgt LLD.


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-14 07:13:35 UTC (rev 383)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-14 07:14:36 UTC (rev 384)
@@ -75,6 +75,15 @@
 #define dprintk eprintk
 /* #define dprintk(fmt, args...) */
 
+/* TODO: use include/scsi/srp.h instead of drivers/scsi/ibmvscsi/srp.h */
+enum {
+	SRP_TSK_ABORT_TASK	= 0x01,
+	SRP_TSK_ABORT_TASK_SET	= 0x02,
+	SRP_TSK_CLEAR_TASK_SET	= 0x04,
+	SRP_TSK_LUN_RESET	= 0x08,
+	SRP_TSK_CLEAR_ACA	= 0x40
+};
+
 /*
  * an RPA command/response transport queue.  This is our structure
  * that points to the actual queue (not architected by firmware)
@@ -376,7 +385,8 @@
 	scmd->request_bufflen = len;
 	scmd->tag= tag;
 	iue->scmd = scmd;
-	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun, 0);
+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &iu->srp.cmd.lun,
+			       iu->srp.cmd.tag);
 
 	dprintk("%p %p %x %lx %d %d %d\n",
 		iue, scmd, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tag);
@@ -755,63 +765,41 @@
 	handle_cmd_queue(adapter);
 }
 
-/* TODO */
-static void process_device_reset(struct iu_entry *iue)
+static int process_tsk_mgmt(struct iu_entry *iue)
 {
-	send_rsp(iue, NO_SENSE, 0x00);
-}
+	union viosrp_iu *iu = vio_iu(iue);
+	int fn;
 
-static void process_abort(struct iu_entry *iue)
-{
-	union viosrp_iu *iu = vio_iu(iue), *tmp_iu = NULL;
-	struct iu_entry *tmp_iue;
-	unsigned char status = ABORTED_COMMAND;
-	uint64_t tag = iu->srp.tsk_mgmt.managed_task_tag;
-	unsigned long flags;
+	eprintk("%p %d\n", iue, iu->srp.tsk_mgmt.task_mgmt_flags);
 
-	eprintk("Not supported yet %p %llx\n", iue, (unsigned long long) tag);
-
-	spin_lock_irqsave(&iue->adapter->lock, flags);
-
-	list_for_each_entry(tmp_iue, &iue->adapter->cmd_queue, ilist) {
-		tmp_iu = vio_iu(tmp_iue);
-		if (tmp_iu->srp.cmd.tag != tag)
-			continue;
-
-		__set_bit(V_ABORTED, &tmp_iue->req.flags);
-		status = NO_SENSE;
+	switch (iu->srp.tsk_mgmt.task_mgmt_flags) {
+	case SRP_TSK_ABORT_TASK:
+		fn = ABORT_TASK;
 		break;
+	case SRP_TSK_ABORT_TASK_SET:
+		fn = ABORT_TASK_SET;
+		break;
+	case SRP_TSK_CLEAR_TASK_SET:
+		fn = CLEAR_TASK_SET;
+		break;
+	case SRP_TSK_LUN_RESET:
+		fn = LOGICAL_UNIT_RESET;
+		break;
+	case SRP_TSK_CLEAR_ACA:
+		fn = CLEAR_ACA;
+		break;
+	default:
+		fn = 0;
 	}
-
-	spin_unlock_irqrestore(&iue->adapter->lock, flags);
-
-	if (status == NO_SENSE) {
-		int len;
-		len = vscsis_data_length(&tmp_iu->srp.cmd,
-					 tmp_iu->srp.cmd.data_out_format);
-		dprintk("abort cmd: %p %p %lx %x %lx %d\n",
-			tmp_iue, tmp_iue->scmd,
-			tmp_iue->scmd->request->flags,
-			tmp_iu->srp.cmd.cdb[0],
-			tmp_iu->srp.cmd.lun, len);
-		BUG();
-	} else
-		dprintk("unable to abort cmd\n");
-
-	send_rsp(iue, status, 0x14);
-}
-
-static void process_tsk_mgmt(struct iu_entry *iue)
-{
-	union viosrp_iu *iu = vio_iu(iue);
-	uint8_t flags = iu->srp.tsk_mgmt.task_mgmt_flags;
-
-	if (flags == 0x01)
-		process_abort(iue);
-	else if (flags == 0x08)
-		process_device_reset(iue);
+	if (fn)
+		scsi_tgt_tsk_mgmt_request(iue->adapter->shost, fn,
+					  iu->srp.tsk_mgmt.managed_task_tag,
+					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
+					  iue);
 	else
 		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
+
+	return !fn;
 }
 
 static int process_mad_iu(struct iu_entry *iue)
@@ -863,7 +851,7 @@
 		process_login(iue);
 		break;
 	case SRP_TSK_MGMT_TYPE:
-		process_tsk_mgmt(iue);
+		done = process_tsk_mgmt(iue);
 		break;
 	case SRP_CMD_TYPE:
 		queue_cmd(iue);
@@ -1097,15 +1085,49 @@
 	handle_cmd_queue(adapter);
 }
 
-/*
- * TODO: just for cheating scsi_host_alloc now.
- */
-static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *cmd)
+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
 {
-	BUG();
+	unsigned long flags;
+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
+	struct server_adapter *adapter = iue->adapter;
+
+	dprintk("%p %p %x\n", iue, adapter, vio_iu(iue)->srp.cmd.cdb[0]);
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	list_del(&iue->ilist);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	put_iu(iue);
+
 	return 0;
 }
 
+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
+{
+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
+	union viosrp_iu *iu = vio_iu(iue);
+	unsigned char status, asc;
+
+	eprintk("%p %d\n", iue, result);
+	status = NO_SENSE;
+	asc = 0;
+
+	switch (iu->srp.tsk_mgmt.task_mgmt_flags) {
+	case SRP_TSK_ABORT_TASK:
+		asc = 0x14;
+		if (result)
+			status = ABORTED_COMMAND;
+		break;
+	default:
+		break;
+	}
+
+	send_rsp(iue, status, asc);
+	put_iu(iue);
+
+	return 0;
+}
+
 #define	host_to_adapter(x)	(((struct server_adapter *) x->hostdata))
 
 static ssize_t
@@ -1149,6 +1171,7 @@
 	.transfer_response	= ibmvstgt_cmd_done,
 	.transfer_data		= recv_cmd_data,
 	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
 	.shost_attrs		= ibmvstgt_attrs,
 	.proc_name		= TGT_NAME,
 };



From tomo at berlios.de  Tue Mar 14 08:30:37 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 08:30:37 +0100
Subject: [Stgt-svn] r385 - branches/use-scsi-ml/patchset
Message-ID: <200603140730.k2E7UbJg020764@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 08:30:33 +0100 (Tue, 14 Mar 2006)
New Revision: 385

Added:
   branches/use-scsi-ml/patchset/tmf.diff
Log:
I'm too lazy to update the whole patchset. Apply the patchset first
and then tmf.diff. After all, the patchset will be unnecessary because
we move to the scsi-target git tree.


Added: branches/use-scsi-ml/patchset/tmf.diff
===================================================================
--- branches/use-scsi-ml/patchset/tmf.diff	2006-03-14 07:14:36 UTC (rev 384)
+++ branches/use-scsi-ml/patchset/tmf.diff	2006-03-14 07:30:33 UTC (rev 385)
@@ -0,0 +1,60 @@
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8b799db..eca5721 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -153,6 +153,9 @@ struct scsi_host_template {
+ 	int (* transfer_data)(struct scsi_cmnd *,
+ 			      void (*done)(struct scsi_cmnd *));
+ 
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
+ 	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+index 91ad6bc..3d09a1a 100644
+--- a/include/scsi/scsi_tgt.h
++++ b/include/scsi/scsi_tgt.h
+@@ -8,4 +8,6 @@ struct scsi_lun;
+ 
+ extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
+ extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
+-extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+index ebca452..63b2e3a 100644
+--- a/include/scsi/scsi_tgt_if.h
++++ b/include/scsi/scsi_tgt_if.h
+@@ -52,7 +52,7 @@ struct tgt_event {
+ 		} cmd_rsp;
+ 		struct {
+ 			int host_no;
+-			int mid;
++			uint64_t mid;
+ 			int result;
+ 		} tsk_mgmt_rsp;
+ 	} u;
+@@ -69,6 +69,7 @@ struct tgt_event {
+ 			uint8_t scb[16];
+ 			uint8_t lun[8];
+ 			int attribute;
++			uint64_t tag;
+ 		} cmd_req;
+ 		struct {
+ 			int host_no;
+@@ -77,10 +78,10 @@ struct tgt_event {
+ 		} cmd_done;
+ 		struct {
+ 			int host_no;
+-			int mid;
++			int function;
+ 			uint64_t tag;
+ 			uint8_t lun[8];
+-			int function;
++			uint64_t mid;
+ 		} tsk_mgmt_req;
+ 	} k;
+ 



From tomo at berlios.de  Tue Mar 14 12:34:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 12:34:03 +0100
Subject: [Stgt-svn] r386 - branches/use-scsi-ml/patchset
Message-ID: <200603141134.k2EBY3Si011845@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 12:34:02 +0100 (Tue, 14 Mar 2006)
New Revision: 386

Added:
   branches/use-scsi-ml/patchset/tgt-2.6.16-rc5.diff
Log:
Add a patch against 2.6.16-rc5 (rc6 is ok too). This will modify scsi-ml and block layer code and create tgt header files.

Added: branches/use-scsi-ml/patchset/tgt-2.6.16-rc5.diff
===================================================================
--- branches/use-scsi-ml/patchset/tgt-2.6.16-rc5.diff	2006-03-14 07:30:33 UTC (rev 385)
+++ branches/use-scsi-ml/patchset/tgt-2.6.16-rc5.diff	2006-03-14 11:34:02 UTC (rev 386)
@@ -0,0 +1,573 @@
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 03d9c82..6849859 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2291,19 +2291,20 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+-	if (!IS_ERR(bio)) {
+-		rq->bio = rq->biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq->buffer = rq->data = NULL;
+-		rq->data_len = len;
+-		return 0;
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq->bio = rq->biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq->buffer = rq->data = NULL;
++	rq->data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2329,7 +2330,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2343,6 +2344,12 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq->bio = rq->biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq->buffer = rq->data = NULL;
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index 24f7af9..ef9900d 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
++					  hdr->dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index 5881079..64e687a 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
+ 
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index c551bb8..3cf02b1 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -236,6 +236,58 @@ static struct scsi_cmnd *__scsi_get_comm
+ }
+ 
+ /*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto put_dev;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
+  * Function:	scsi_get_command()
+  *
+  * Purpose:	Allocate and setup a scsi command block
+@@ -274,6 +326,45 @@ struct scsi_cmnd *scsi_get_command(struc
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+ /*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock(&shost->free_list_lock);
++
++	spin_lock(q->queue_lock);
++	if (blk_rq_tagged(rq))
++		blk_queue_end_tag(q, rq);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(&shost->shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++/*
+  * Function:	scsi_put_command()
+  *
+  * Purpose:	Free a scsi command block
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 4362dcd..7307705 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -804,7 +804,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -845,7 +845,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -855,6 +857,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1687,29 +1691,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/fs/bio.c b/fs/bio.c
+index 1f3bb50..f51a873 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+@@ -750,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
+ {
+ 	struct bio *bio;
+-	int len = 0, i;
+ 
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
+ 
+@@ -765,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
+ 
+-	for (i = 0; i < iov_count; i++)
+-		len += iov[i].iov_len;
+-
+-	if (bio->bi_size == len)
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio->bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
+ 
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index 860e7a4..619ef1d 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -611,7 +611,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index c256ebe..9422ae5 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 7529f43..51156c7 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
+ 
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -147,9 +150,14 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
+ extern void scsi_put_command(struct scsi_cmnd *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8279929..eca5721 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,39 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -572,6 +606,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -674,6 +714,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..3d09a1a
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,13 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..63b2e3a
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,89 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_REQ,
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
++
++	/* kernel -> user */
++	TGT_KEVENT_RSP,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int type;
++			int host_no;
++		} event_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint8_t rw;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			uint64_t mid;
++			int result;
++		} tsk_mgmt_rsp;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_rsp;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
++			uint64_t tag;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++		struct {
++			int host_no;
++			int function;
++			uint64_t tag;
++			uint8_t lun[8];
++			uint64_t mid;
++		} tsk_mgmt_req;
++	} k;
++
++} __attribute__ ((aligned (sizeof(uint64_t))));
++#endif



From tomo at berlios.de  Tue Mar 14 15:45:23 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 14 Mar 2006 15:45:23 +0100
Subject: [Stgt-svn] r387 - branches/use-scsi-ml/usr
Message-ID: <200603141445.k2EEjN6v021525@sheep.berlios.de>

Author: tomo
Date: 2006-03-14 15:45:22 +0100 (Tue, 14 Mar 2006)
New Revision: 387

Modified:
   branches/use-scsi-ml/usr/target.c
Log:
Add ABORT_TASK_SET and LOGICAL_UNIT_RESET TMF support (but not tested at all yet).


Modified: branches/use-scsi-ml/usr/target.c
===================================================================
--- branches/use-scsi-ml/usr/target.c	2006-03-14 11:34:02 UTC (rev 386)
+++ branches/use-scsi-ml/usr/target.c	2006-03-14 14:45:22 UTC (rev 387)
@@ -62,9 +62,14 @@
 enum {
 	TGT_CMD_QUEUED,
 	TGT_CMD_PROCESSED,
-	TGT_CMD_MGMT,
 };
 
+struct mgmt_req {
+	uint64_t mid;
+	int busy;
+	int function;
+};
+
 struct cmd {
 	struct list_head hlist;
 	struct list_head qlist;
@@ -75,7 +80,6 @@
 	int mmapped;
 	struct tgt_device *dev;
 	unsigned long state;
-	uint64_t mid;
 
 	/* Kill the followings when we use shared memory instead of netlink. */
 	int hostno;
@@ -84,6 +88,7 @@
 	uint8_t lun[8];
 	int attribute;
 	uint64_t tag;
+	struct mgmt_req *mreq;
 };
 
 struct target {
@@ -140,7 +145,6 @@
 
 CMD_FNS(QUEUED, queued)
 CMD_FNS(PROCESSED, processed)
-CMD_FNS(MGMT, mgmt)
 
 
 static struct target *target_get(int tid)
@@ -575,6 +579,7 @@
 {
 	struct target *target;
 	struct cmd *cmd;
+	struct mgmt_req *mreq;
 	int host_no = ev->k.cmd_done.host_no;
 	uint32_t cid = ev->k.cmd_done.cid;
 
@@ -590,76 +595,116 @@
 		return;
 	}
 
-	if (cmd_mgmt(cmd))
-		tgt_kspace_send_tsk_mgmt(nl_fd, cmd->hostno, cmd->mid, -EEXIST);
+	mreq = cmd->mreq;
+	if (mreq && !--mreq->busy) {
+		int err = mreq->function == ABORT_TASK ? -EEXIST : 0;
+		tgt_kspace_send_tsk_mgmt(nl_fd, cmd->hostno, mreq->mid, err);
+		free(mreq);
+	}
+
 	__cmd_done(target, cmd, nl_fd);
 }
 
-static int abort_task_by_tag(struct target* target, uint64_t tag, uint64_t mid,
-			     int nl_fd)
+static int abort_cmd(struct target* target, struct mgmt_req *mreq,
+		     struct cmd *cmd, int nl_fd)
 {
-	struct cmd *cmd, *tmp;
+	int err = 0;
 
-	eprintf("found %" PRIx64 " %" PRIx64 "\n", tag, mid);
+	eprintf("found %" PRIx64 " %lx\n", cmd->tag, cmd->state);
 
-	list_for_each_entry_safe(cmd, tmp, &target->cmd_list, clist) {
-		if (cmd->tag == tag)
-			goto found;
-	}
-	return -EEXIST;
-
-found:
-	eprintf("found %" PRIx64 " %lx\n", cmd->tag, cmd->state);
 	if (cmd_processed(cmd)) {
 		/*
 		 * We've already sent this command to kernel space.
 		 * We'll send the tsk mgmt response when we get the
 		 * completion of this command.
 		 */
-		set_cmd_mgmt(cmd);
-		cmd->mid = mid;
-		return -EBUSY;
+		cmd->mreq = mreq;
+		err = -EBUSY;
 	} else {
 		__cmd_done(target, cmd, nl_fd);
 		tgt_kspace_send_cmd(nl_fd, cmd, TASK_ABORTED, 0);
 	}
+	return err;
+}
 
-	return 0;
+static int abort_task_set(struct mgmt_req *mreq, struct target* target, int host_no,
+			  uint64_t tag, uint8_t *lun, int all, int nl_fd)
+{
+	struct cmd *cmd, *tmp;
+	int err, count = 0;
+
+	eprintf("found %" PRIx64 " %d\n", tag, all);
+
+	list_for_each_entry_safe(cmd, tmp, &target->cmd_list, clist) {
+		if ((all && cmd->hostno == host_no)||
+		    (cmd->tag == tag && cmd->hostno == host_no) ||
+		    (lun && !memcmp(cmd->lun, lun, sizeof(cmd->lun)))) {
+			err = abort_cmd(target, mreq, cmd, nl_fd);
+			if (err)
+				mreq->busy++;
+			count++;
+		}
+	}
+
+	return count;
 }
 
 static void tsk_mgmt_req(struct tgt_event *ev_req, int nl_fd)
 {
 	struct target *target;
-	int err = 0, send = 1;
+	struct mgmt_req *mreq;
+	int err = 0, count, send = 1;
+	int host_no = ev_req->k.cmd_req.host_no;
 
-	target = host_to_target(ev_req->k.cmd_req.host_no);
+	target = host_to_target(host_no);
 	if (!target) {
 		eprintf("%d is not bind to any target\n",
 			ev_req->k.cmd_req.host_no);
 		return;
 	}
 
-	switch (ev_req->k.tsk_mgmt_req.function) {
+	mreq = calloc(1, sizeof(*mreq));
+	mreq->mid = ev_req->k.tsk_mgmt_req.mid;
+	mreq->function = ev_req->k.tsk_mgmt_req.function;
+
+	switch (mreq->function) {
 	case ABORT_TASK:
-		err = abort_task_by_tag(target, ev_req->k.tsk_mgmt_req.tag,
-					ev_req->k.tsk_mgmt_req.mid, nl_fd);
-		if (err == -EBUSY)
+		count = abort_task_set(mreq, target, host_no,
+				       ev_req->k.tsk_mgmt_req.tag,
+				       NULL, 0, nl_fd);
+		if (mreq->busy)
 			send = 0;
+		if (!count)
+			err = -EEXIST;
 		break;
 	case ABORT_TASK_SET:
+		count = abort_task_set(mreq, target, host_no, 0, NULL, 1, nl_fd);
+		if (mreq->busy)
+			send = 0;
+		break;
 	case CLEAR_ACA:
 	case CLEAR_TASK_SET:
-	case LOGICAL_UNIT_RESET:
 		eprintf("Not supported yet %x\n",
 			ev_req->k.tsk_mgmt_req.function);
+		err = -EINVAL;
 		break;
+	case LOGICAL_UNIT_RESET:
+		count = abort_task_set(mreq, target, host_no, 0,
+				       ev_req->k.tsk_mgmt_req.lun, 0, nl_fd);
+		if (mreq->busy)
+			send = 0;
+		break;
 	default:
+		err = -EINVAL;
 		eprintf("Unknown task management %x\n",
 			ev_req->k.tsk_mgmt_req.function);
 	}
 
-	tgt_kspace_send_tsk_mgmt(nl_fd, ev_req->k.cmd_req.host_no,
-				 ev_req->k.tsk_mgmt_req.mid, err);
+	if (send) {
+		tgt_kspace_send_tsk_mgmt(nl_fd, ev_req->k.cmd_req.host_no,
+					 ev_req->k.tsk_mgmt_req.mid, err);
+		free(mreq);
+	}
 }
 
 void nl_event_handle(int nl_fd)



From tomo at berlios.de  Wed Mar 15 01:21:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 15 Mar 2006 01:21:42 +0100
Subject: [Stgt-svn] r388 - branches/use-scsi-ml/doc
Message-ID: <200603150021.k2F0LguR011942@sheep.berlios.de>

Author: tomo
Date: 2006-03-15 01:21:40 +0100 (Wed, 15 Mar 2006)
New Revision: 388

Modified:
   branches/use-scsi-ml/doc/index.html
Log:
Minor update.

Modified: branches/use-scsi-ml/doc/index.html
===================================================================
--- branches/use-scsi-ml/doc/index.html	2006-03-14 14:45:22 UTC (rev 387)
+++ branches/use-scsi-ml/doc/index.html	2006-03-15 00:21:40 UTC (rev 388)
@@ -40,7 +40,7 @@
 </p>
 
 <p>
-The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly.
+The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly. <a href="http://kernel.org/pub/linux/kernel/people/akpm/">The -mm tree</a> includes also tgt (since 2.6.16-rc6-mm1).
 </p>
 
 </div>
@@ -55,19 +55,19 @@
 
 <li>
 <p>
-Virtual SCSI target driver in IBM pSeries
+Virtual SCSI target driver for <a href="http://www.ibm.com/systems/p/">IBM pSeries</a>
 </p>
 </li>
 
 <li>
 <p>
-Qlogic qla2xxx FC target driver (not yet)
+<a href="http://www.qlogic.com/products/fc_san_hostadapers.asp">Qlogic qla2xxx</a> FC target driver (not yet)
 </p>
 </li>
 
 <li>
 <p>
-LSI logic fusion FC target driver (not yet)
+<a href="http://www.lsilogic.com">LSI logic</a> FC target driver (not yet)
 </p>
 </li>
 
@@ -79,7 +79,7 @@
 
 <li>
 <p>
-Qlogic qla4xxx iSCSI target driver (not yet)
+<a href="http://www.qlogic.com/products/iscsi_products_hba.asp">Qlogic qla4xxx</a> iSCSI target driver (not yet)
 </p>
 </li>
 
@@ -108,12 +108,6 @@
 
 <li>
 <p>
-Implement TMF (task management function)
-</p>
-</li>
-
-<li>
-<p>
 Implement Reserve/Release command support
 </p>
 </li>



From tomo at berlios.de  Wed Mar 15 01:24:16 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 15 Mar 2006 01:24:16 +0100
Subject: [Stgt-svn] r389 - branches/use-scsi-ml/doc
Message-ID: <200603150024.k2F0OGKI012424@sheep.berlios.de>

Author: tomo
Date: 2006-03-15 01:24:11 +0100 (Wed, 15 Mar 2006)
New Revision: 389

Modified:
   branches/use-scsi-ml/doc/index.html
Log:
Fix typo.

Modified: branches/use-scsi-ml/doc/index.html
===================================================================
--- branches/use-scsi-ml/doc/index.html	2006-03-15 00:21:40 UTC (rev 388)
+++ branches/use-scsi-ml/doc/index.html	2006-03-15 00:24:11 UTC (rev 389)
@@ -40,7 +40,7 @@
 </p>
 
 <p>
-The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly. <a href="http://kernel.org/pub/linux/kernel/people/akpm/">The -mm tree</a> includes also tgt (since 2.6.16-rc6-mm1).
+The tgt code (kernel-space and user-space) is available on <a href="http://developer.berlios.de/svn/?group_id=4492">the subversion repository</a>. We will move the kernel-space code to <a href="http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary">scsi-target git tree</a> shortly. <a href="http://kernel.org/pub/linux/kernel/people/akpm/">The -mm tree</a> also includes tgt (since 2.6.16-rc6-mm1).
 </p>
 
 </div>



From tomo at berlios.de  Wed Mar 15 01:52:02 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 15 Mar 2006 01:52:02 +0100
Subject: [Stgt-svn] r390 - branches/use-scsi-ml/doc
Message-ID: <200603150052.k2F0q2Hn020991@sheep.berlios.de>

Author: tomo
Date: 2006-03-15 01:51:57 +0100 (Wed, 15 Mar 2006)
New Revision: 390

Added:
   branches/use-scsi-ml/doc/tmf.txt
Log:
Add the TMF design doc.

Added: branches/use-scsi-ml/doc/tmf.txt
===================================================================
--- branches/use-scsi-ml/doc/tmf.txt	2006-03-15 00:24:11 UTC (rev 389)
+++ branches/use-scsi-ml/doc/tmf.txt	2006-03-15 00:51:57 UTC (rev 390)
@@ -0,0 +1,52 @@
+The tgt Task Management Functions (TMF) works in the followings:
+
+- When LLDs queue scsi commands to tgt (scsi_tgt_queue_command), they
+need to specify unique 'tag' for each command.
+
+- LLDs call 'int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *host, int,
+u64 tag, struct scsi_lun *lun, void *data)'.
+
+- int (* tsk_mgmt_response)(u64 data, int result) is added to
+scsi_host_template.
+
+The tag arg in scsi_tgt_queue_command is used only for ABORT_TASK to
+identify a single command. Initiators send a command with a unique
+tag so LLDs simply call scsi_tgt_queue_command() with it.
+
+With FCP and iSCSI, tag is 32-bit, however, unfortunately, SRP uses
+64-bit tag. So we need 64-bit for it.
+
+When an initiator sends a task management request, the LLD calls
+scsi_tgt_tsk_mgmt_request. the LLD can use whatever it wants for the
+data arg. The data arg is used later as the arg in the
+tsk_mgmt_response callback.
+
+tgt core just sends the task management request to user space
+(by using TGT_KEVENT_TSK_MGMT_REQ).
+
+In the case of ABORT_TASK, tgtd finds a single command to abort and
+sends TGT_UEVENT_CMD_RSP and TGT_UEVENT_TSK_MGMT_RSP events.
+
+tgt core calls eh_abort_handler for TGT_UEVENT_CMD_RSP and then
+tsk_mgmt_response for TGT_UEVENT_TSK_MGMT_RSP.
+
+If tgtd fails to find a command to abort, it sends only
+TGT_UEVENT_TSK_MGMT_RSP event (no TGT_UEVENT_CMD_RSP event).
+
+In the case of the rests task management functions (like
+ABORT_TASK_SET), tgt needs to abort multiple commands. Thus, tgtd
+finds multiple commands to abort and sends multiple TGT_UEVENT_CMD_RSP
+events and a single TGT_UEVENT_TSK_MGMT_RSP event. tgt core calls
+eh_abort_handler multiple times and tsk_mgmt_response once.
+
+eh_abort_handler enables LLDs to safely free resource related with a
+command to abort.
+
+Note that when tgtd finds that a TGT_KEVENT_TSK_MGMT_REQ event tries
+to abort commands between in TGT_UEVENT_CMD_RSP and
+TGT_KEVENT_CMD_DONE states (that is, tgt calls something like
+bio_map_user for the commands), tgtd gives up. After all, we cannot
+abort such commands. For example, possibly, The commands already touch
+page cache. In this case, tgtd waits for the completion of the commands
+(TGT_KEVENT_CMD_DONE) and sends TGT_UEVENT_TSK_MGMT_RSP event with an
+appropriate result value.



From tomo at berlios.de  Wed Mar 15 01:59:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 15 Mar 2006 01:59:33 +0100
Subject: [Stgt-svn] r391 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200603150059.k2F0xXNL023864@sheep.berlios.de>

Author: tomo
Date: 2006-03-15 01:59:30 +0100 (Wed, 15 Mar 2006)
New Revision: 391

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Remove unused flags.

Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-15 00:51:57 UTC (rev 390)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-15 00:59:30 UTC (rev 391)
@@ -118,9 +118,7 @@
 	V_DIOVER,
 	V_WRITE,
 	V_LINKED,
-	V_ABORTED,
 	V_FLYING,
-	V_DONE,
 };
 
 enum srp_task_attributes {



From tomo at berlios.de  Mon Mar 27 06:36:21 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Mon, 27 Mar 2006 06:36:21 +0200
Subject: [Stgt-svn] r392 - branches/use-scsi-ml/ibmvstgt/kernel
Message-ID: <200603270436.k2R4aLCv030790@sheep.berlios.de>

Author: tomo
Date: 2006-03-27 06:36:17 +0200 (Mon, 27 Mar 2006)
New Revision: 392

Modified:
   branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
Log:
Convert the ibmstgt driver to use include/scsi/srp.h. This needs the
following patch:

http://marc.theaimsgroup.com/?l=linux-scsi&m=114331321129541&w=2


Modified: branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c
===================================================================
--- branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-15 00:59:30 UTC (rev 391)
+++ branches/use-scsi-ml/ibmvstgt/kernel/ibmvstgt.c	2006-03-27 04:36:17 UTC (rev 392)
@@ -75,15 +75,6 @@
 #define dprintk eprintk
 /* #define dprintk(fmt, args...) */
 
-/* TODO: use include/scsi/srp.h instead of drivers/scsi/ibmvscsi/srp.h */
-enum {
-	SRP_TSK_ABORT_TASK	= 0x01,
-	SRP_TSK_ABORT_TASK_SET	= 0x02,
-	SRP_TSK_CLEAR_TASK_SET	= 0x04,
-	SRP_TSK_LUN_RESET	= 0x08,
-	SRP_TSK_CLEAR_ACA	= 0x40
-};
-
 /*
  * an RPA command/response transport queue.  This is our structure
  * that points to the actual queue (not architected by firmware)
@@ -181,7 +172,7 @@
 	crq.cooked.reserved = 0x00;
 	crq.cooked.timeout = 0x00;
 	crq.cooked.IU_length = length;
-	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.generic.tag;
+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
 
 	if (rc == 0)
 		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
@@ -199,12 +190,14 @@
 	return rc;
 }
 
+#define SRP_RSP_SENSE_DATA_LEN	18
+
 static int send_rsp(struct iu_entry *iue, unsigned char status,
 		    unsigned char asc)
 {
 	union viosrp_iu *iu = vio_iu(iue);
-	uint8_t *sense = iu->srp.rsp.sense_and_response_data;
-	uint64_t tag = iu->srp.generic.tag;
+	uint8_t *sense = iu->srp.rsp.data;
+	uint64_t tag = iu->srp.rsp.tag;
 	unsigned long flags;
 
 	/* If the linked bit is on and status is good */
@@ -212,26 +205,27 @@
 		status = 0x10;
 
 	memset(iu, 0, sizeof(struct srp_rsp));
-	iu->srp.rsp.type = SRP_RSP_TYPE;
+	iu->srp.rsp.opcode = SRP_RSP;
 	spin_lock_irqsave(&iue->adapter->lock, flags);
-	iu->srp.rsp.request_limit_delta = 1 + iue->adapter->next_rsp_delta;
+	iu->srp.rsp.req_lim_delta = 1 + iue->adapter->next_rsp_delta;
 	iue->adapter->next_rsp_delta = 0;
 	spin_unlock_irqrestore(&iue->adapter->lock, flags);
 	iu->srp.rsp.tag = tag;
 
-	iu->srp.rsp.diover = test_bit(V_DIOVER, &iue->req.flags) ? 1 : 0;
+	if (test_bit(V_DIOVER, &iue->req.flags))
+		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
 
-	iu->srp.rsp.data_in_residual_count = iue->req.data_in_residual_count;
-	iu->srp.rsp.data_out_residual_count = iue->req.data_out_residual_count;
+	iu->srp.rsp.data_in_res_cnt = iue->req.data_in_residual_count;
+	iu->srp.rsp.data_out_res_cnt = iue->req.data_out_residual_count;
 
-	iu->srp.rsp.rspvalid = 0;
+	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
 
-	iu->srp.rsp.response_data_list_length = 0;
+	iu->srp.rsp.resp_data_len = 0;
 
 	if (status && !iue->req.sense) {
 		iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-		iu->srp.rsp.snsvalid = 1;
-		iu->srp.rsp.sense_data_list_length = 18;
+		iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
+		iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
 
 		/* Valid bit and 'current errors' */
 		sense[0] = (0x1 << 7 | 0x70);
@@ -246,15 +240,15 @@
 		sense[12] = asc;
 	} else {
 		if (iue->req.sense) {
-			iu->srp.rsp.snsvalid = 1;
-			iu->srp.rsp.sense_data_list_length =
-							SCSI_SENSE_BUFFERSIZE;
+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
+			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
 			memcpy(sense, iue->req.sense, SCSI_SENSE_BUFFERSIZE);
 		}
 		iu->srp.rsp.status = status;
 	}
 
-	send_iu(iue, sizeof(iu->srp.rsp), VIOSRP_SRP_FORMAT);
+	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
+		VIOSRP_SRP_FORMAT);
 
 	return 0;
 }
@@ -262,52 +256,52 @@
 static int data_out_desc_size(struct srp_cmd *cmd)
 {
 	int size = 0;
-	switch (cmd->data_out_format) {
-	case SRP_NO_BUFFER:
+	u8 fmt = cmd->buf_fmt >> 4;
+
+	switch (fmt) {
+	case SRP_NO_DATA_DESC:
 		break;
-	case SRP_DIRECT_BUFFER:
-		size = sizeof(struct memory_descriptor);
+	case SRP_DATA_DESC_DIRECT:
+		size = sizeof(struct srp_direct_buf);
 		break;
-	case SRP_INDIRECT_BUFFER:
-		size = sizeof(struct indirect_descriptor) +
-			sizeof(struct memory_descriptor) * (cmd->data_out_count - 1);
+	case SRP_DATA_DESC_INDIRECT:
+		size = sizeof(struct srp_indirect_buf) +
+			sizeof(struct srp_direct_buf) * (cmd->data_out_desc_cnt - 1);
 		break;
 	default:
-		eprintk("client error. Invalid data_out_format %d\n",
-			cmd->data_out_format);
+		eprintk("client error. Invalid data_out_format %x\n", fmt);
 		break;
 	}
 	return size;
 }
 
-static int vscsis_data_length(struct srp_cmd *cmd, int out)
+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
 {
-	struct memory_descriptor *md;
-	struct indirect_descriptor *id;
-	int format, len = 0, offset = cmd->additional_cdb_len * 4;
+	struct srp_direct_buf *md;
+	struct srp_indirect_buf *id;
+	int len = 0, offset = cmd->add_cdb_len * 4;
+	u8 fmt;
 
-	if (out)
-		format = cmd->data_out_format;
+	if (dir == DMA_TO_DEVICE)
+		fmt = cmd->buf_fmt >> 4;
 	else {
-		format = cmd->data_in_format;
+		fmt = cmd->buf_fmt & ((1U << 4) - 1);
 		offset += data_out_desc_size(cmd);
 	}
 
-	switch (format) {
-	case SRP_NO_BUFFER:
+	switch (fmt) {
+	case SRP_NO_DATA_DESC:
 		break;
-	case SRP_DIRECT_BUFFER:
-		md = (struct memory_descriptor *)
-			(cmd->additional_data + offset);
-		len = md->length;
+	case SRP_DATA_DESC_DIRECT:
+		md = (struct srp_direct_buf *) (cmd->add_data + offset);
+		len = md->len;
 		break;
-	case SRP_INDIRECT_BUFFER:
-		id = (struct indirect_descriptor *)
-			(cmd->additional_data + offset);
-		len = id->total_length;
+	case SRP_DATA_DESC_INDIRECT:
+		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
+		len = id->len;
 		break;
 	default:
-		eprintk("invalid data format %d\n", format);
+		eprintk("invalid data format %x\n", fmt);
 		break;
 	}
 	return len;
@@ -338,7 +332,7 @@
 
 	tag = MSG_SIMPLE_TAG;
 
-	switch (iu->srp.cmd.task_attribute) {
+	switch (iu->srp.cmd.task_attr) {
 	case SRP_SIMPLE_TASK:
 		tag = MSG_SIMPLE_TAG;
 		break;
@@ -350,7 +344,7 @@
 		break;
 	default:
 		eprintk("Task attribute %d not supported, assuming barrier\n",
-			iu->srp.cmd.task_attribute);
+			iu->srp.cmd.task_attr);
 		tag = MSG_ORDERED_TAG;
 	}
 
@@ -363,13 +357,11 @@
 		__set_bit(V_WRITE, &iue->req.flags);
 	}
 
-	if (iu->srp.cmd.data_out_format) {
+	if (iu->srp.cmd.buf_fmt >> 4)
 		data_dir = DMA_TO_DEVICE;
-		len = vscsis_data_length(&iu->srp.cmd, 1);
-	} else {
+	else
 		data_dir = DMA_FROM_DEVICE;
-		len = vscsis_data_length(&iu->srp.cmd, 0);
-	}
+	len = vscsis_data_length(&iu->srp.cmd, data_dir);
 
 	dprintk("%p %x %lx %d %d %d %llx\n",
 		iue, iu->srp.cmd.cdb[0], iu->srp.cmd.lun, data_dir, len, tag,
@@ -411,11 +403,8 @@
 	spin_unlock_irqrestore(&adapter->lock, flags);
 }
 
-#define SEND	0
-#define RECV	1
-
-static int direct_data(struct scsi_cmnd *scmd, struct memory_descriptor *md,
-		       int op)
+static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
+		       enum dma_data_direction dir)
 {
 	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
@@ -426,7 +415,7 @@
 	dma_addr_t token;
 
 	dprintk("%p %u %u %u %d\n", iue, scmd->request_bufflen, scmd->bufflen,
-		md->length, scmd->use_sg);
+		md->len, scmd->use_sg);
 
 	nsg = dma_map_sg(adapter->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
 	if (!nsg) {
@@ -434,25 +423,25 @@
 		return 0;
 	}
 
-	rest = min(scmd->request_bufflen, md->length);
+	rest = min(scmd->request_bufflen, md->len);
 
 	for (i = 0, done = 0; i < nsg && rest; i++) {
 		token = sg_dma_address(sg + i);
 		len = min(sg_dma_len(sg + i), rest);
 
-		if (op == SEND)
-			err = h_copy_rdma(len, adapter->liobn,
-					  token,
-					  adapter->riobn,
-					  md->virtual_address + done);
-		else
+		if (dir == DMA_TO_DEVICE)
 			err = h_copy_rdma(len, adapter->riobn,
-					  md->virtual_address + done,
+					  md->va + done,
 					  adapter->liobn,
 					  token);
+		else
+			err = h_copy_rdma(len, adapter->liobn,
+					  token,
+					  adapter->riobn,
+					  md->va + done);
 
 		if (err != H_Success) {
-			eprintk("rdma error %d %d %ld\n", op, i, err);
+			eprintk("rdma error %d %d %ld\n", dir, i, err);
 			break;
 		}
 
@@ -465,41 +454,41 @@
 	return done;
 }
 
-static int indirect_data(struct scsi_cmnd *scmd, struct indirect_descriptor *id,
-			 int op)
+static int indirect_data(struct scsi_cmnd *scmd, struct srp_indirect_buf *id,
+			 enum dma_data_direction dir)
 {
 	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct server_adapter *adapter = iue->adapter;
 	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
-	struct memory_descriptor *mds;
+	struct srp_direct_buf *mds;
 	struct scatterlist *sg = scmd->request_buffer;
 	dma_addr_t token, itoken = 0;
 	long err;
 	unsigned int rest, done = 0;
 	int i, nmd, nsg, sidx, soff;
 
-	nmd = id->head.length / sizeof(struct memory_descriptor);
+	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
 
 	dprintk("%p %u %u %u %u %d %d %d\n",
 		iue, scmd->request_bufflen, scmd->bufflen,
-		id->total_length, scmd->offset, nmd,
-		cmd->data_in_count, cmd->data_out_count);
+		id->len, scmd->offset, nmd,
+		cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
 
-	if ((op == SEND && nmd == cmd->data_in_count) ||
-	    (op == RECV && nmd == cmd->data_out_count)) {
-		mds = &id->list[0];
+	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
+	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
+		mds = &id->desc_list[0];
 		goto rdma;
 	}
 
-	mds = dma_alloc_coherent(adapter->dev, id->head.length,
+	mds = dma_alloc_coherent(adapter->dev, id->table_desc.len,
 				 &itoken, GFP_KERNEL);
 	if (!mds) {
-		eprintk("Can't get dma memory %d\n", id->head.length);
+		eprintk("Can't get dma memory %u\n", id->table_desc.len);
 		return 0;
 	}
 
-	err = h_copy_rdma(id->head.length, adapter->riobn,
-			  id->head.virtual_address, adapter->liobn, itoken);
+	err = h_copy_rdma(id->table_desc.len, adapter->riobn,
+			  id->table_desc.va, adapter->liobn, itoken);
 	if (err != H_Success) {
 		eprintk("Error copying indirect table %ld\n", err);
 		goto free_mem;
@@ -514,29 +503,29 @@
 
 	sidx = soff = 0;
 	token = sg_dma_address(sg + sidx);
-	rest = min(scmd->request_bufflen, id->total_length);
+	rest = min(scmd->request_bufflen, id->len);
 	for (i = 0; i < nmd && rest; i++) {
 		unsigned int mdone, mlen;
 
-		mlen = min(rest, mds[i].length);
+		mlen = min(rest, mds[i].len);
 		for (mdone = 0; mlen;) {
 			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
 
-			if (op == SEND)
+			if (dir == DMA_TO_DEVICE)
 				err = h_copy_rdma(slen,
-						  adapter->liobn,
-						  token + soff,
 						  adapter->riobn,
-						  mds[i].virtual_address + mdone);
+						  mds[i].va + mdone,
+						  adapter->liobn,
+						  token + soff);
 			else
 				err = h_copy_rdma(slen,
-						  adapter->riobn,
-						  mds[i].virtual_address + mdone,
 						  adapter->liobn,
-						  token + soff);
+						  token + soff,
+						  adapter->riobn,
+						  mds[i].va + mdone);
 
 			if (err != H_Success) {
-				eprintk("rdma error %d %d\n", op, slen);
+				eprintk("rdma error %d %d\n", dir, slen);
 				goto unmap_sg;
 			}
 
@@ -566,41 +555,44 @@
 
 free_mem:
 	if (itoken)
-		dma_free_coherent(adapter->dev, id->head.length, mds, itoken);
+		dma_free_coherent(adapter->dev, id->table_desc.len, mds, itoken);
 
 	return done;
 }
 
-static int handle_cmd_data(struct scsi_cmnd *scmd, int op)
+static int handle_cmd_data(struct scsi_cmnd *scmd, enum dma_data_direction dir)
 {
 	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
 	struct srp_cmd *cmd = &vio_iu(iue)->srp.cmd;
-	struct memory_descriptor *md;
-	struct indirect_descriptor *id;
+	struct srp_direct_buf *md;
+	struct srp_indirect_buf *id;
 	int offset, err = 0;
-	uint8_t format;
+	u8 format;
 
-	offset = cmd->additional_cdb_len * 4;
-	if (op == SEND)
+	offset = cmd->add_cdb_len * 4;
+	if (dir == DMA_FROM_DEVICE)
 		offset += data_out_desc_size(cmd);
 
-	format = (op == SEND) ? cmd->data_in_format : cmd->data_out_format;
+	if (dir == DMA_TO_DEVICE)
+		format = cmd->buf_fmt >> 4;
+	else
+		format = cmd->buf_fmt & ((1U << 4) - 1);
 
 	switch (format) {
-	case SRP_NO_BUFFER:
+	case SRP_NO_DATA_DESC:
 		break;
-	case SRP_DIRECT_BUFFER:
-		md = (struct memory_descriptor *)
-			(cmd->additional_data + offset);
-		err = direct_data(scmd, md, op);
+	case SRP_DATA_DESC_DIRECT:
+		md = (struct srp_direct_buf *)
+			(cmd->add_data + offset);
+		err = direct_data(scmd, md, dir);
 		break;
-	case SRP_INDIRECT_BUFFER:
-		id = (struct indirect_descriptor *)
-			(cmd->additional_data + offset);
-		err = indirect_data(scmd, id, op);
+	case SRP_DATA_DESC_INDIRECT:
+		id = (struct srp_indirect_buf *)
+			(cmd->add_data + offset);
+		err = indirect_data(scmd, id, dir);
 		break;
 	default:
-		eprintk("Unknown format %d %d\n", op, format);
+		eprintk("Unknown format %d %x\n", dir, format);
 		break;
 	}
 
@@ -612,10 +604,13 @@
 			 void (*done)(struct scsi_cmnd *))
 {
 	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
-	int rw;
+	enum dma_data_direction dir;
 
-	rw = test_bit(V_WRITE, &iue->req.flags) ? RECV : SEND;
-	handle_cmd_data(scmd, rw);
+	if (test_bit(V_WRITE, &iue->req.flags))
+		dir = DMA_TO_DEVICE;
+	else
+		dir = DMA_FROM_DEVICE;
+	handle_cmd_data(scmd, dir);
 	done(scmd);
 	return 0;
 }
@@ -734,20 +729,19 @@
 	union viosrp_iu *iu = vio_iu(iue);
 	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
 
-	uint64_t tag = iu->srp.generic.tag;
+	uint64_t tag = iu->srp.rsp.tag;
 
 	/* TODO handle case that requested size is wrong and
 	 * buffer format is wrong
 	 */
 	memset(iu, 0, sizeof(struct srp_login_rsp));
-	rsp->type = SRP_LOGIN_RSP_TYPE;
-	rsp->request_limit_delta = INITIAL_SRP_LIMIT;
+	rsp->opcode = SRP_LOGIN_RSP;
+	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
 	rsp->tag = tag;
-	rsp->max_initiator_to_target_iulen = sizeof(union srp_iu);
-	rsp->max_target_to_initiator_iulen = sizeof(union srp_iu);
+	rsp->max_it_iu_len = sizeof(union srp_iu);
+	rsp->max_ti_iu_len = sizeof(union srp_iu);
 	/* direct and indirect */
-	rsp->supported_buffer_formats = 0x0006;
-	rsp->multi_channel_result = 0x00;
+	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
 
 	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
 }
@@ -768,9 +762,9 @@
 	union viosrp_iu *iu = vio_iu(iue);
 	int fn;
 
-	eprintk("%p %d\n", iue, iu->srp.tsk_mgmt.task_mgmt_flags);
+	eprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
 
-	switch (iu->srp.tsk_mgmt.task_mgmt_flags) {
+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
 	case SRP_TSK_ABORT_TASK:
 		fn = ABORT_TASK;
 		break;
@@ -791,7 +785,7 @@
 	}
 	if (fn)
 		scsi_tgt_tsk_mgmt_request(iue->adapter->shost, fn,
-					  iu->srp.tsk_mgmt.managed_task_tag,
+					  iu->srp.tsk_mgmt.task_tag,
 					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
 					  iue);
 	else
@@ -831,7 +825,7 @@
 		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
 		break;
 	default:
-		eprintk("Unknown type %d\n", iu->srp.generic.type);
+		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
 	}
 
 	return 1;
@@ -841,32 +835,33 @@
 {
 	union viosrp_iu *iu = vio_iu(iue);
 	int done = 1;
+	u8 opcode = iu->srp.rsp.opcode;
 
-	dprintk("%p %d\n", iue, iu->srp.generic.type);
+	dprintk("%p %u\n", iue, opcode);
 
-	switch (iu->srp.generic.type) {
-	case SRP_LOGIN_REQ_TYPE:
+	switch (opcode) {
+	case SRP_LOGIN_REQ:
 		process_login(iue);
 		break;
-	case SRP_TSK_MGMT_TYPE:
+	case SRP_TSK_MGMT:
 		done = process_tsk_mgmt(iue);
 		break;
-	case SRP_CMD_TYPE:
+	case SRP_CMD:
 		queue_cmd(iue);
 		done = 0;
 		break;
-	case SRP_LOGIN_RSP_TYPE:
-	case SRP_I_LOGOUT_TYPE:
-	case SRP_T_LOGOUT_TYPE:
-	case SRP_RSP_TYPE:
-	case SRP_CRED_REQ_TYPE:
-	case SRP_CRED_RSP_TYPE:
-	case SRP_AER_REQ_TYPE:
-	case SRP_AER_RSP_TYPE:
-		eprintk("Unsupported type %d\n", iu->srp.generic.type);
+	case SRP_LOGIN_RSP:
+	case SRP_I_LOGOUT:
+	case SRP_T_LOGOUT:
+	case SRP_RSP:
+	case SRP_CRED_REQ:
+	case SRP_CRED_RSP:
+	case SRP_AER_REQ:
+	case SRP_AER_RSP:
+		eprintk("Unsupported type %u\n", opcode);
 		break;
 	default:
-		eprintk("Unknown type %d\n", iu->srp.generic.type);
+		eprintk("Unknown type %u\n", opcode);
 	}
 
 	return done;
@@ -1110,7 +1105,7 @@
 	status = NO_SENSE;
 	asc = 0;
 
-	switch (iu->srp.tsk_mgmt.task_mgmt_flags) {
+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
 	case SRP_TSK_ABORT_TASK:
 		asc = 0x14;
 		if (result)



