<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Stgt-svn] r290 - in branches/use-scsi-ml: . patchset
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/stgt-svn/2006-February/index.html" >
   <LINK REL="made" HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r290%20-%20in%20branches/use-scsi-ml%3A%20.%20patchset&In-Reply-To=%3C200602101151.k1ABpWiK029153%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000276.html">
   <LINK REL="Next"  HREF="000278.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Stgt-svn] r290 - in branches/use-scsi-ml: . patchset</H1>
    <B>tomo at BerliOS</B> 
    <A HREF="mailto:stgt-svn%40lists.berlios.de?Subject=Re%3A%20%5BStgt-svn%5D%20r290%20-%20in%20branches/use-scsi-ml%3A%20.%20patchset&In-Reply-To=%3C200602101151.k1ABpWiK029153%40sheep.berlios.de%3E"
       TITLE="[Stgt-svn] r290 - in branches/use-scsi-ml: . patchset">tomo at berlios.de
       </A><BR>
    <I>Fri Feb 10 12:51:32 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000276.html">[Stgt-svn] r289 - branches/use-scsi-ml
</A></li>
        <LI>Next message: <A HREF="000278.html">[Stgt-svn] r291 - branches/use-scsi-ml/patchset
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#277">[ date ]</a>
              <a href="thread.html#277">[ thread ]</a>
              <a href="subject.html#277">[ subject ]</a>
              <a href="author.html#277">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tomo
Date: 2006-02-10 12:51:29 +0100 (Fri, 10 Feb 2006)
New Revision: 290

Added:
   branches/use-scsi-ml/patchset/
   branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
   branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
   branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
   branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
Log:
Add patcheset will be submitted to scsi-ml shortly. It would be better split the 4th patch (scsi_tgt.h and scsi_tgt_if.h, and the rest).


Added: branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0001-block-layer-kill-length-alignment-test-in-bin_map_user.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,27 @@
+Subject: [PATCH] block layer: kill length alignment test in bin_map_user
+
+---
+
+ fs/bio.c |    5 ++---
+ 1 files changed, 2 insertions(+), 3 deletions(-)
+
+de7a82b3681434b79baae0f2636d20bb1c4e004f
+diff --git a/fs/bio.c b/fs/bio.c
+index 1f3bb50..d8259d9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -620,10 +620,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr &amp; queue_dma_alignment(q)) || (len &amp; queue_dma_alignment(q)))
++		if (uaddr &amp; queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0002-Add-partial-mappings-support-to-bio_map_use.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,108 @@
+Subject: [PATCH] Add partial mappings support to bio_map_use
+
+---
+
+ block/ll_rw_blk.c   |    5 +++--
+ fs/bio.c            |   11 +++++++----
+ include/linux/bio.h |    5 +++--
+ 3 files changed, 13 insertions(+), 8 deletions(-)
+
+717736911a4e68d224e377d5d6b529c7a358336e
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index f9fc07e..65c56b6 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2293,7 +2293,7 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	 */
+ 	uaddr = (unsigned long) ubuf;
+ 	if (!(uaddr &amp; queue_dma_alignment(q)) &amp;&amp; !(len &amp; queue_dma_alignment(q)))
+-		bio = bio_map_user(q, NULL, uaddr, len, reading);
++		bio = bio_map_user(q, NULL, uaddr, len, reading, 0);
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+@@ -2345,7 +2345,8 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	/* we don't allow misaligned data like bio_map_user() does.  If the
+ 	 * user is using sg, they're expected to know the alignment constraints
+ 	 * and respect them accordingly */
+-	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ);
++	bio = bio_map_user_iov(q, NULL, iov, iov_count, rq_data_dir(rq)== READ,
++				0);
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
+diff --git a/fs/bio.c b/fs/bio.c
+index d8259d9..3e940c9 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -718,19 +718,21 @@ static struct bio *__bio_map_user_iov(re
+  *	@uaddr: start of user address
+  *	@len: length in bytes
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user(request_queue_t *q, struct block_device *bdev,
+-			 unsigned long uaddr, unsigned int len, int write_to_vm)
++			 unsigned long uaddr, unsigned int len, int write_to_vm,
++			 int support_partial)
+ {
+ 	struct sg_iovec iov;
+ 
+ 	iov.iov_base = (void __user *)uaddr;
+ 	iov.iov_len = len;
+ 
+-	return bio_map_user_iov(q, bdev, &amp;iov, 1, write_to_vm);
++	return bio_map_user_iov(q, bdev, &amp;iov, 1, write_to_vm, support_partial);
+ }
+ 
+ /**
+@@ -740,13 +742,14 @@ struct bio *bio_map_user(request_queue_t
+  *	@iov:	the iovec.
+  *	@iov_count: number of elements in the iovec
+  *	@write_to_vm: bool indicating writing to pages or not
++ *	@support_partial: support partial mappings
+  *
+  *	Map the user space address into a bio suitable for io to a block
+  *	device. Returns an error pointer in case of error.
+  */
+ struct bio *bio_map_user_iov(request_queue_t *q, struct block_device *bdev,
+ 			     struct sg_iovec *iov, int iov_count,
+-			     int write_to_vm)
++			     int write_to_vm, int support_partial)
+ {
+ 	struct bio *bio;
+ 	int len = 0, i;
+@@ -767,7 +770,7 @@ struct bio *bio_map_user_iov(request_que
+ 	for (i = 0; i &lt; iov_count; i++)
+ 		len += iov[i].iov_len;
+ 
+-	if (bio-&gt;bi_size == len)
++	if (bio-&gt;bi_size == len || support_partial)
+ 		return bio;
+ 
+ 	/*
+diff --git a/include/linux/bio.h b/include/linux/bio.h
+index b60ffe3..fc0906c 100644
+--- a/include/linux/bio.h
++++ b/include/linux/bio.h
+@@ -295,12 +295,13 @@ extern int bio_add_page(struct bio *, st
+ extern int bio_add_pc_page(struct request_queue *, struct bio *, struct page *,
+ 			   unsigned int, unsigned int);
+ extern int bio_get_nr_vecs(struct block_device *);
++extern int __bio_get_nr_vecs(struct request_queue *);
+ extern struct bio *bio_map_user(struct request_queue *, struct block_device *,
+-				unsigned long, unsigned int, int);
++				unsigned long, unsigned int, int, int);
+ struct sg_iovec;
+ extern struct bio *bio_map_user_iov(struct request_queue *,
+ 				    struct block_device *,
+-				    struct sg_iovec *, int, int);
++				    struct sg_iovec *, int, int, int);
+ extern void bio_unmap_user(struct bio *);
+ extern struct bio *bio_map_kern(struct request_queue *, void *, unsigned int,
+ 				gfp_t);
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt
===================================================================
--- branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0003-scsi-ml-export-scsi-ml-functions-needed-by-tgt_scsi_lib-and-its-LLDs.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,328 @@
+Subject: [PATCH] scsi-ml: export scsi-ml functions needed by tgt_scsi_lib and its LLDs
+
+---
+
+ drivers/scsi/hosts.c     |    5 +++
+ drivers/scsi/scsi.c      |   91 ++++++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_lib.c  |   33 ++++++++++++-----
+ include/scsi/scsi_cmnd.h |    8 ++++
+ include/scsi/scsi_host.h |   40 ++++++++++++++++++++
+ 5 files changed, 168 insertions(+), 9 deletions(-)
+
+c8d4fed9e1642f3fcfeb18cdde52aaaadabc55fd
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index ef57f25..a122624 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost-&gt;work_q)
+ 		destroy_workqueue(shost-&gt;work_q);
+ 
++	if (shost-&gt;uspace_req_q) {
++		kfree(shost-&gt;uspace_req_q-&gt;queuedata);
++		scsi_free_queue(shost-&gt;uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost-&gt;shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index d182bad..701973e 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -234,6 +234,58 @@ static struct scsi_cmnd *__scsi_get_comm
+ }
+ 
+ /*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&amp;shost-&gt;shost_gendev))
++		return NULL;
++
++	rq = blk_get_request(shost-&gt;uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto put_dev;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd-&gt;sc_data_direction = data_dir;
++	cmd-&gt;jiffies_at_alloc = jiffies;
++	cmd-&gt;request = rq;
++
++	rq-&gt;special = cmd;
++	rq-&gt;flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++put_dev:
++	put_device(&amp;shost-&gt;shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
+  * Function:	scsi_get_command()
+  *
+  * Purpose:	Allocate and setup a scsi command block
+@@ -272,6 +324,45 @@ struct scsi_cmnd *scsi_get_command(struc
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+ /*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost-&gt;uspace_req_q;
++	struct request *rq = cmd-&gt;request;
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&amp;shost-&gt;free_list_lock, flags);
++	if (unlikely(list_empty(&amp;shost-&gt;free_list))) {
++		list_add(&amp;cmd-&gt;list, &amp;shost-&gt;free_list);
++		cmd = NULL;
++	}
++	spin_unlock(&amp;shost-&gt;free_list_lock);
++
++	spin_lock(q-&gt;queue_lock);
++	if (blk_rq_tagged(rq))
++		blk_queue_end_tag(q, rq);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost-&gt;cmd_pool-&gt;slab, cmd);
++
++	put_device(&amp;shost-&gt;shost_gendev);
++}
++EXPORT_SYMBOL_GPL(scsi_host_put_command);
++
++/*
+  * Function:	scsi_put_command()
+  *
+  * Purpose:	Free a scsi command block
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index 5ac8749..2dcc500 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -802,7 +802,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -843,7 +843,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -853,6 +855,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp-&gt;pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1685,29 +1689,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev-&gt;host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost-&gt;sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost-&gt;max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost-&gt;dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost-&gt;use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &amp;q-&gt;queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev-&gt;host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 1ace1b9..8f64515 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
+ 
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -147,9 +150,14 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
+ extern void scsi_put_command(struct scsi_cmnd *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index 8279929..8b799db 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include &lt;linux/workqueue.h&gt;
+ #include &lt;linux/mutex.h&gt;
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,36 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd-&gt;request_bufflen
++	 * bytes of the cmd at cmd-&gt;offset in the cmd. The cmd-&gt;use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd-&gt;request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -572,6 +603,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -674,6 +711,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+-- 
+1.1.3

Added: branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt
===================================================================
--- branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-10 07:38:17 UTC (rev 289)
+++ branches/use-scsi-ml/patchset/0004-scsi-tgt-core-functions.txt	2006-02-10 11:51:29 UTC (rev 290)
@@ -0,0 +1,985 @@
+Subject: [PATCH] scsi tgt core functions
+
+---
+
+ drivers/scsi/Kconfig         |    7 +
+ drivers/scsi/Makefile        |    3 
+ drivers/scsi/scsi_tgt_if.c   |  214 +++++++++++++++++
+ drivers/scsi/scsi_tgt_lib.c  |  540 ++++++++++++++++++++++++++++++++++++++++++
+ drivers/scsi/scsi_tgt_priv.h |   25 ++
+ include/linux/netlink.h      |    1 
+ include/scsi/scsi_tgt.h      |   11 +
+ include/scsi/scsi_tgt_if.h   |   92 +++++++
+ 8 files changed, 893 insertions(+), 0 deletions(-)
+ create mode 100644 drivers/scsi/scsi_tgt_if.c
+ create mode 100644 drivers/scsi/scsi_tgt_lib.c
+ create mode 100644 drivers/scsi/scsi_tgt_priv.h
+ create mode 100644 include/scsi/scsi_tgt.h
+ create mode 100644 include/scsi/scsi_tgt_if.h
+
+f8f0430d4d268391f61d32745efbd464d861a37a
+diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
+index 3c606cf..d09c792 100644
+--- a/drivers/scsi/Kconfig
++++ b/drivers/scsi/Kconfig
+@@ -27,6 +27,13 @@ config SCSI
+ 	  However, do not compile this as a module if your root file system
+ 	  (the one containing the directory /) is located on a SCSI device.
+ 
++config SCSI_TGT
++	tristate &quot;SCSI target support&quot;
++	depends on SCSI &amp;&amp; EXPERIMENTAL
++	---help---
++	  If you want to use SCSI target mode drivers enable this option.
++	  If you choose M, the module will be called scsi_tgt.
++
+ config SCSI_PROC_FS
+ 	bool &quot;legacy /proc/scsi/ support&quot;
+ 	depends on SCSI &amp;&amp; PROC_FS
+diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
+index 320e765..3d81b8d 100644
+--- a/drivers/scsi/Makefile
++++ b/drivers/scsi/Makefile
+@@ -21,6 +21,7 @@ CFLAGS_seagate.o =   -DARBITRATE -DPARIT
+ subdir-$(CONFIG_PCMCIA)		+= pcmcia
+ 
+ obj-$(CONFIG_SCSI)		+= scsi_mod.o
++obj-$(CONFIG_SCSI_TGT)		+= scsi_tgt.o
+ 
+ obj-$(CONFIG_RAID_ATTRS)	+= raid_class.o
+ 
+@@ -155,6 +156,8 @@ scsi_mod-y			+= scsi.o hosts.o scsi_ioct
+ scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
+ scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
+ 
++scsi_tgt-y			+= scsi_tgt_lib.o scsi_tgt_if.o
++
+ sd_mod-objs	:= sd.o
+ sr_mod-objs	:= sr.o sr_ioctl.o sr_vendor.o
+ ncr53c8xx-flags-$(CONFIG_SCSI_ZALON) \
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+new file mode 100644
+index 0000000..38b35da
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -0,0 +1,214 @@
++/*
++ * SCSI target kernel/user interface functions
++ *
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include &lt;linux/blkdev.h&gt;
++#include &lt;linux/file.h&gt;
++#include &lt;linux/netlink.h&gt;
++#include &lt;net/tcp.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_device.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;scsi/scsi_tgt_if.h&gt;
++
++#include &quot;scsi_tgt_priv.h&quot;
++
++static int tgtd_pid;
++static struct sock *nl_sk;
++
++static int send_event_res(uint16_t type, struct tgt_event *p,
++			  void *data, int dlen, gfp_t flags, pid_t pid)
++{
++	struct tgt_event *ev;
++	struct nlmsghdr *nlh;
++	struct sk_buff *skb;
++	uint32_t len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + dlen);
++	skb = alloc_skb(len, flags);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	memcpy(ev, p, sizeof(*ev));
++	if (dlen)
++		memcpy(ev-&gt;data, data, dlen);
++
++	return netlink_unicast(nl_sk, skb, pid, 0);
++}
++
++int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct sk_buff *skb;
++	struct nlmsghdr *nlh;
++	struct tgt_event *ev;
++	struct tgt_cmd *tcmd;
++	int err, len;
++
++	len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct tgt_cmd));
++	/*
++	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
++	 */
++	skb = alloc_skb(NLMSG_SPACE(len), gfp_mask);
++	if (!skb)
++		return -ENOMEM;
++
++	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
++			  len - sizeof(*nlh), 0);
++
++	ev = NLMSG_DATA(nlh);
++	ev-&gt;k.cmd_req.host_no = shost-&gt;host_no;
++	ev-&gt;k.cmd_req.cid = cmd-&gt;request-&gt;tag;
++	ev-&gt;k.cmd_req.data_len = cmd-&gt;request_bufflen;
++
++	dprintk(&quot;%d %u %u\n&quot;, ev-&gt;k.cmd_req.host_no, ev-&gt;k.cmd_req.cid,
++		ev-&gt;k.cmd_req.data_len);
++
++	/* FIXME: we need scsi core to do that. */
++	memcpy(cmd-&gt;cmnd, cmd-&gt;data_cmnd, MAX_COMMAND_SIZE);
++
++	tcmd = (struct tgt_cmd *) ev-&gt;data;
++	memcpy(tcmd-&gt;scb, cmd-&gt;cmnd, sizeof(tcmd-&gt;scb));
++	memcpy(tcmd-&gt;lun, lun, sizeof(struct scsi_lun));
++
++	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
++	if (err &lt; 0)
++		printk(KERN_ERR &quot;scsi_tgt_uspace_send: could not send skb %d\n&quot;,
++		       err);
++	return err;
++}
++
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	struct tgt_event ev;
++	char dummy[sizeof(struct tgt_cmd)];
++
++	memset(&amp;ev, 0, sizeof(ev));
++	ev.k.cmd_done.host_no = shost-&gt;host_no;
++	ev.k.cmd_done.cid = cmd-&gt;request-&gt;tag;
++	ev.k.cmd_done.result = cmd-&gt;result;
++
++	return send_event_res(TGT_KEVENT_CMD_DONE, &amp;ev, dummy, sizeof(dummy),
++			      gfp_mask, tgtd_pid);
++}
++
++static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++{
++	struct tgt_event *ev = NLMSG_DATA(nlh);
++	int err = 0;
++
++	dprintk(&quot;%d %d %d\n&quot;, nlh-&gt;nlmsg_type,
++		nlh-&gt;nlmsg_pid, current-&gt;pid);
++
++	switch (nlh-&gt;nlmsg_type) {
++	case TGT_UEVENT_TGTD_BIND:
++		tgtd_pid = NETLINK_CREDS(skb)-&gt;pid;
++		break;
++	case TGT_UEVENT_CMD_RES:
++		/* TODO: handle multiple cmds in one event */
++		err = scsi_tgt_kspace_exec(ev-&gt;u.cmd_res.host_no,
++					   ev-&gt;u.cmd_res.cid,
++					   ev-&gt;u.cmd_res.result,
++					   ev-&gt;u.cmd_res.len,
++					   ev-&gt;u.cmd_res.offset,
++					   ev-&gt;u.cmd_res.uaddr,
++					   ev-&gt;u.cmd_res.rw,
++					   ev-&gt;u.cmd_res.try_map);
++		break;
++	default:
++		eprintk(&quot;unknown type %d\n&quot;, nlh-&gt;nlmsg_type);
++		err = -EINVAL;
++	}
++
++	return err;
++}
++
++static int event_recv_skb(struct sk_buff *skb)
++{
++	int err;
++	uint32_t rlen;
++	struct nlmsghdr	*nlh;
++
++	while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
++		nlh = (struct nlmsghdr *) skb-&gt;data;
++		if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)
++			return 0;
++		rlen = NLMSG_ALIGN(nlh-&gt;nlmsg_len);
++		if (rlen &gt; skb-&gt;len)
++			rlen = skb-&gt;len;
++		err = event_recv_msg(skb, nlh);
++
++		dprintk(&quot;%d %d\n&quot;, nlh-&gt;nlmsg_type, err);
++		/*
++		 * TODO for passthru commands the lower level should
++		 * probably handle the result or we should modify this
++		 */
++		if (nlh-&gt;nlmsg_type != TGT_UEVENT_CMD_RES) {
++			struct tgt_event ev;
++
++			memset(&amp;ev, 0, sizeof(ev));
++			ev.k.event_res.err = err;
++			send_event_res(TGT_KEVENT_RESPONSE, &amp;ev, NULL, 0,
++				       GFP_KERNEL | __GFP_NOFAIL,
++					nlh-&gt;nlmsg_pid);
++		}
++		skb_pull(skb, rlen);
++	}
++	return 0;
++}
++
++static void event_recv(struct sock *sk, int length)
++{
++	struct sk_buff *skb;
++
++	while ((skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue))) {
++		if (NETLINK_CREDS(skb)-&gt;uid) {
++			skb_pull(skb, skb-&gt;len);
++			kfree_skb(skb);
++			continue;
++		}
++
++		if (event_recv_skb(skb) &amp;&amp; skb-&gt;len)
++			skb_queue_head(&amp;sk-&gt;sk_receive_queue, skb);
++		else
++			kfree_skb(skb);
++	}
++}
++
++void __exit scsi_tgt_if_exit(void)
++{
++	sock_release(nl_sk-&gt;sk_socket);
++}
++
++int __init scsi_tgt_if_init(void)
++{
++	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
++				    THIS_MODULE);
++	if (!nl_sk)
++		return -ENOMEM;
++
++	return 0;
++}
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+new file mode 100644
+index 0000000..64fd3d7
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -0,0 +1,540 @@
++/*
++ * SCSI target lib functions
++ *
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#include &lt;linux/blkdev.h&gt;
++#include &lt;linux/elevator.h&gt;
++#include &lt;linux/module.h&gt;
++#include &lt;linux/pagemap.h&gt;
++#include &lt;scsi/scsi.h&gt;
++#include &lt;scsi/scsi_cmnd.h&gt;
++#include &lt;scsi/scsi_device.h&gt;
++#include &lt;scsi/scsi_host.h&gt;
++#include &lt;scsi/scsi_tgt.h&gt;
++#include &lt;../drivers/md/dm-bio-list.h&gt;
++
++#include &quot;scsi_tgt_priv.h&quot;
++
++static struct workqueue_struct *scsi_tgtd;
++static kmem_cache_t *scsi_tgt_cmd_cache;
++
++/*
++ * TODO: this struct will be killed when the block layer supports large bios
++ * and James's work struct code is in
++ */
++struct scsi_tgt_cmd {
++	/* TODO replace work with James b's code */
++	struct work_struct work;
++	/* TODO replace the lists with a large bio */
++	struct bio_list xfer_done_list;
++	struct bio_list xfer_list;
++	struct scsi_lun *lun;
++};
++
++static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
++{
++	struct bio *bio;
++
++	/* must call bio_endio in case bio was bounced */
++	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_done_list))) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++	}
++
++	while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list))) {
++		bio_endio(bio, bio-&gt;bi_size, 0);
++		bio_unmap_user(bio);
++	}
++}
++
++static void scsi_tgt_cmd_destroy(void *data)
++{
++	struct scsi_cmnd *cmd = data;
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	dprintk(&quot;cmd %p\n&quot;, cmd);
++
++	scsi_unmap_user_pages(tcmd);
++	scsi_tgt_uspace_send_status(cmd, GFP_KERNEL);
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
++}
++
++static void init_scsi_tgt_cmd(struct request *rq, struct scsi_tgt_cmd *tcmd)
++{
++	tcmd-&gt;lun = rq-&gt;end_io_data;
++	bio_list_init(&amp;tcmd-&gt;xfer_list);
++	bio_list_init(&amp;tcmd-&gt;xfer_done_list);
++}
++
++static int scsi_uspace_prep_fn(struct request_queue *q, struct request *rq)
++{
++	struct scsi_tgt_cmd *tcmd;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		return BLKPREP_DEFER;
++
++	init_scsi_tgt_cmd(rq, tcmd);
++	rq-&gt;end_io_data = tcmd;
++	rq-&gt;flags |= REQ_DONTPREP;
++	return BLKPREP_OK;
++}
++
++static void scsi_uspace_request_fn(struct request_queue *q)
++{
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/*
++	 * TODO: just send everthing in the queue to userspace in
++	 * one vector instead of multiple calls
++	 */
++	while ((rq = elv_next_request(q)) != NULL) {
++		cmd = rq-&gt;special;
++		tcmd = rq-&gt;end_io_data;
++
++		/* the completion code kicks us in case we hit this */
++		if (blk_queue_start_tag(q, rq))
++			break;
++
++		spin_unlock_irq(q-&gt;queue_lock);
++		if (scsi_tgt_uspace_send(cmd, tcmd-&gt;lun, GFP_ATOMIC) &lt; 0)
++			goto requeue;
++		spin_lock_irq(q-&gt;queue_lock);
++	}
++
++	return;
++requeue:
++	spin_lock_irq(q-&gt;queue_lock);
++	/* need to track cnts and plug */
++	blk_requeue_request(q, rq);
++	spin_lock_irq(q-&gt;queue_lock);
++}
++
++/**
++ * scsi_tgt_alloc_queue - setup queue used for message passing
++ * shost: scsi host
++ *
++ * This should be called by the LLD after host allocation.
++ * And will be released when the host is released.
++ **/
++int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
++{
++	struct scsi_tgt_queuedata *queuedata;
++	struct request_queue *q;
++	int err;
++
++	/*
++	 * Do we need to send a netlink event or should uspace
++	 * just respond to the hotplug event?
++	 */
++	q = __scsi_alloc_queue(shost, scsi_uspace_request_fn);
++	if (!q)
++		return -ENOMEM;
++
++	queuedata = kzalloc(sizeof(*queuedata), GFP_KERNEL);
++	if (!queuedata) {
++		err = -ENOMEM;
++		goto cleanup_queue;
++	}
++	queuedata-&gt;shost = shost;
++	q-&gt;queuedata = queuedata;
++
++	elevator_exit(q-&gt;elevator);
++	err = elevator_init(q, &quot;noop&quot;);
++	if (err)
++		goto free_data;
++
++	blk_queue_prep_rq(q, scsi_uspace_prep_fn);
++	/*
++	 * this is a silly hack. We should probably just queue as many
++	 * command as is recvd to userspace. uspace can then make
++	 * sure we do not overload the HBA
++	 */
++	q-&gt;nr_requests = shost-&gt;hostt-&gt;can_queue;
++	blk_queue_init_tags(q, shost-&gt;hostt-&gt;can_queue, NULL);
++	/*
++	 * We currently only support software LLDs so this does
++	 * not matter for now. Do we need this for the cards we support?
++	 * If so we should make it a host template value.
++	 */
++	blk_queue_dma_alignment(q, 0);
++	shost-&gt;uspace_req_q = q;
++
++	return 0;
++
++free_data:
++	kfree(queuedata);
++cleanup_queue:
++	blk_cleanup_queue(q);
++	return err;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_alloc_queue);
++
++struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_queuedata *queue = cmd-&gt;request-&gt;q-&gt;queuedata;
++	return queue-&gt;shost;
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
++
++/**
++ * scsi_tgt_queue_command - queue command for userspace processing
++ * @cmd:	scsi command
++ * @scsilun:	scsi lun
++ * @noblock:	set to nonzero if the command should be queued
++ **/
++void scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
++			    int noblock)
++{
++	/*
++	 * For now this just calls the request_fn from this context.
++	 * For HW llds though we do not want to execute from here so
++	 * the elevator code needs something like a REQ_TGT_CMD or
++	 * REQ_MSG_DONT_UNPLUG_IMMED_BECUASE_WE_WILL_HANDLE_IT
++	 */
++	cmd-&gt;request-&gt;end_io_data = scsilun;
++	elv_add_request(cmd-&gt;request-&gt;q, cmd-&gt;request, ELEVATOR_INSERT_BACK, 1);
++}
++EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
++
++/*
++ * This is run from a interrpt handler normally and the unmap
++ * needs process context so we must queue
++ */
++static void scsi_tgt_cmd_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++
++	dprintk(&quot;cmd %p\n&quot;, cmd);
++
++	/* don't we have to call this if result is set or not */
++	if (cmd-&gt;result) {
++		scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++		return;
++	}
++
++	INIT_WORK(&amp;tcmd-&gt;work, scsi_tgt_cmd_destroy, cmd);
++	queue_work(scsi_tgtd, &amp;tcmd-&gt;work);
++}
++
++static int __scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
++	int err;
++
++	dprintk(&quot;cmd %p\n&quot;, cmd);
++
++	err = shost-&gt;hostt-&gt;transfer_response(cmd, scsi_tgt_cmd_done);
++	switch (err) {
++	case SCSI_MLQUEUE_HOST_BUSY:
++	case SCSI_MLQUEUE_DEVICE_BUSY:
++		return -EAGAIN;
++	}
++
++	return 0;
++}
++
++static void scsi_tgt_transfer_response(struct scsi_cmnd *cmd)
++{
++	int err;
++
++	err = __scsi_tgt_transfer_response(cmd);
++	if (!err)
++		return;
++
++	cmd-&gt;result = DID_BUS_BUSY &lt;&lt; 16;
++	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
++		/* the eh will have to pick this up */
++		printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
++}
++
++static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++{
++	struct request *rq = cmd-&gt;request;
++	int count;
++
++	cmd-&gt;use_sg = rq-&gt;nr_phys_segments;
++	cmd-&gt;request_buffer = scsi_alloc_sgtable(cmd, gfp_mask);
++	if (!cmd-&gt;request_buffer)
++		return -ENOMEM;
++
++	cmd-&gt;request_bufflen = rq-&gt;data_len;
++
++	dprintk(&quot;cmd %p addr %p cnt %d\n&quot;, cmd, cmd-&gt;buffer, cmd-&gt;use_sg);
++	count = blk_rq_map_sg(rq-&gt;q, rq, cmd-&gt;request_buffer);
++	if (likely(count &lt;= cmd-&gt;use_sg)) {
++		cmd-&gt;use_sg = count;
++		return 0;
++	}
++
++	eprintk(&quot;cmd %p addr %p cnt %d\n&quot;, cmd, cmd-&gt;buffer, cmd-&gt;use_sg);
++	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
++	return -EINVAL;
++}
++
++/* TODO: test this crap and replace bio_map_user with new interface maybe */
++static int scsi_map_user_pages(struct scsi_tgt_cmd *tcmd, struct scsi_cmnd *cmd,
++			       int rw)
++{
++	struct request_queue *q = cmd-&gt;request-&gt;q;
++	struct request *rq = cmd-&gt;request;
++	void *uaddr = cmd-&gt;buffer;
++	unsigned int len = cmd-&gt;bufflen;
++	struct bio *bio;
++	int err;
++
++	while (len &gt; 0) {
++		dprintk(&quot;%lx %u\n&quot;, (unsigned long) uaddr, len);
++		bio = bio_map_user(q, NULL, (unsigned long) uaddr, len, rw, 1);
++		if (IS_ERR(bio)) {
++			err = PTR_ERR(bio);
++			dprintk(&quot;fail to map %lx %u\n&quot;,
++				(unsigned long) uaddr, len);
++			goto unmap_bios;
++		}
++
++		uaddr += bio-&gt;bi_size;
++		len -= bio-&gt;bi_size;
++
++		/*
++		 * The first bio is added and merged. We could probably
++		 * try to add others using scsi_merge_bio() but for now
++		 * we keep it simple. The first bio should be pretty large
++		 * (either hitting the 1 MB bio pages limit or a queue limit)
++		 * already but for really large IO we may want to try and
++		 * merge these.
++		 */
++		if (!rq-&gt;bio) {
++			blk_rq_bio_prep(q, rq, bio);
++			rq-&gt;data_len = bio-&gt;bi_size;
++		} else
++			/* put list of bios to transfer in next go around */
++			bio_list_add(&amp;tcmd-&gt;xfer_list, bio);
++	}
++
++	cmd-&gt;offset = 0;
++	err = scsi_tgt_init_cmd(cmd, GFP_KERNEL);
++	if (err)
++		goto unmap_bios;
++
++	return 0;
++
++unmap_bios:
++	if (rq-&gt;bio) {
++		bio_unmap_user(rq-&gt;bio);
++		while ((bio = bio_list_pop(&amp;tcmd-&gt;xfer_list)))
++			bio_unmap_user(bio);
++	}
++
++	return err;
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *);
++
++static void scsi_tgt_data_transfer_done(struct scsi_cmnd *cmd)
++{
++	struct scsi_tgt_cmd *tcmd = cmd-&gt;request-&gt;end_io_data;
++	struct bio *bio;
++	int err;
++
++	/* should we free resources here on error ? */
++	if (cmd-&gt;result) {
++send_uspace_err:
++		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) &lt;= 0)
++			/* the tgt uspace eh will have to pick this up */
++			printk(KERN_ERR &quot;Could not send cmd %p status\n&quot;, cmd);
++		return;
++	}
++
++	dprintk(&quot;cmd %p request_bufflen %u bufflen %u\n&quot;,
++		cmd, cmd-&gt;request_bufflen, cmd-&gt;bufflen);
++
++	scsi_free_sgtable(cmd-&gt;request_buffer, cmd-&gt;sglist_len);
++	bio_list_add(&amp;tcmd-&gt;xfer_done_list, cmd-&gt;request-&gt;bio);
++
++	cmd-&gt;buffer += cmd-&gt;request_bufflen;
++	cmd-&gt;offset += cmd-&gt;request_bufflen;
++
++	if (!tcmd-&gt;xfer_list.head) {
++		scsi_tgt_transfer_response(cmd);
++		return;
++	}
++
++	dprintk(&quot;cmd2 %p request_bufflen %u bufflen %u\n&quot;,
++		cmd, cmd-&gt;request_bufflen, cmd-&gt;bufflen);
++
++	bio = bio_list_pop(&amp;tcmd-&gt;xfer_list);
++	BUG_ON(!bio);
++
++	blk_rq_bio_prep(cmd-&gt;request-&gt;q, cmd-&gt;request, bio);
++	cmd-&gt;request-&gt;data_len = bio-&gt;bi_size;
++	err = scsi_tgt_init_cmd(cmd, GFP_ATOMIC);
++	if (err) {
++		cmd-&gt;result = DID_ERROR &lt;&lt; 16;
++		goto send_uspace_err;
++	}
++
++	if (scsi_tgt_transfer_data(cmd)) {
++		cmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
++		goto send_uspace_err;
++	}
++}
++
++static int scsi_tgt_transfer_data(struct scsi_cmnd *cmd)
++{
++	int err;
++	struct Scsi_Host *host = scsi_tgt_cmd_to_host(cmd);
++
++	err = host-&gt;hostt-&gt;transfer_data(cmd, scsi_tgt_data_transfer_done);
++	switch (err) {
++		case SCSI_MLQUEUE_HOST_BUSY:
++		case SCSI_MLQUEUE_DEVICE_BUSY:
++			return -EAGAIN;
++	default:
++		return 0;
++	}
++}
++
++static int scsi_tgt_copy_sense(struct scsi_cmnd *cmd, unsigned long uaddr,
++				unsigned len)
++{
++	char __user *p = (char __user *) uaddr;
++
++	if (copy_from_user(cmd-&gt;sense_buffer, p,
++			   min_t(unsigned, SCSI_SENSE_BUFFERSIZE, len))) {
++		printk(KERN_ERR &quot;Could not copy the sense buffer\n&quot;);
++		return -EIO;
++	}
++	return 0;
++}
++
++int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len, u64 offset,
++			 unsigned long uaddr, u8 rw, u8 try_map)
++{
++	struct Scsi_Host *shost;
++	struct scsi_cmnd *cmd;
++	struct request *rq;
++	int err = 0;
++
++	dprintk(&quot;%d %u %d %u %llu %lx %u %u\n&quot;, host_no, cid, result,
++		len, (unsigned long long) offset, uaddr, rw, try_map);
++
++	/* TODO: replace with a O(1) alg */
++	shost = scsi_host_lookup(host_no);
++	if (IS_ERR(shost)) {
++		printk(KERN_ERR &quot;Could not find host no %d\n&quot;, host_no);
++		return -EINVAL;
++	}
++
++	rq = blk_queue_find_tag(shost-&gt;uspace_req_q, cid);
++	if (!rq) {
++		printk(KERN_ERR &quot;Could not find cid %u\n&quot;, cid);
++		err = -EINVAL;
++		goto done;
++	}
++	cmd = rq-&gt;special;
++
++	dprintk(&quot;cmd %p result %d len %d bufflen %u\n&quot;, cmd,
++		result, len, cmd-&gt;request_bufflen);
++
++	/*
++	 * store the userspace values here, the working values are
++	 * in the request_* values
++	 */
++	cmd-&gt;buffer = (void *)uaddr;
++	if (len)
++		cmd-&gt;bufflen = len;
++	cmd-&gt;result = result;
++
++	if (!cmd-&gt;bufflen) {
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++
++	/*
++	 * TODO: Do we need to handle case where request does not
++	 * align with LLD.
++	 */
++	err = scsi_map_user_pages(rq-&gt;end_io_data, cmd, rw);
++	if (err) {
++		eprintk(&quot;%p %d\n&quot;, cmd, err);
++		err = -EAGAIN;
++		goto done;
++	}
++
++	/* userspace failure */
++	if (cmd-&gt;result) {
++		if (status_byte(cmd-&gt;result) == CHECK_CONDITION)
++			scsi_tgt_copy_sense(cmd, uaddr, len);
++		err = __scsi_tgt_transfer_response(cmd);
++		goto done;
++	}
++	/* ask the target LLD to transfer the data to the buffer */
++	err = scsi_tgt_transfer_data(cmd);
++
++done:
++	scsi_host_put(shost);
++	return err;
++}
++
++static int __init scsi_tgt_init(void)
++{
++	int err;
++
++	scsi_tgt_cmd_cache = kmem_cache_create(&quot;scsi_tgt_cmd&quot;,
++					       sizeof(struct scsi_tgt_cmd),
++					       0, 0, NULL, NULL);
++	if (!scsi_tgt_cmd_cache)
++		return -ENOMEM;
++
++	scsi_tgtd = create_workqueue(&quot;scsi_tgtd&quot;);
++	if (!scsi_tgtd) {
++		err = -ENOMEM;
++		goto free_kmemcache;
++	}
++
++	err = scsi_tgt_if_init();
++	if (err)
++		goto destroy_wq;
++
++	return 0;
++
++destroy_wq:
++	destroy_workqueue(scsi_tgtd);
++free_kmemcache:
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++	return err;
++}
++
++static void __exit scsi_tgt_exit(void)
++{
++	destroy_workqueue(scsi_tgtd);
++	scsi_tgt_if_exit();
++	kmem_cache_destroy(scsi_tgt_cmd_cache);
++}
++
++module_init(scsi_tgt_init);
++module_exit(scsi_tgt_exit);
++
++MODULE_DESCRIPTION(&quot;SCSI target core&quot;);
++MODULE_LICENSE(&quot;GPL&quot;);
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+new file mode 100644
+index 0000000..4236e50
+--- /dev/null
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -0,0 +1,25 @@
++struct scsi_cmnd;
++struct scsi_lun;
++struct Scsi_Host;
++struct task_struct;
++
++/* tmp - will replace with SCSI logging stuff */
++#define dprintk(fmt, args...)					\
++do {								\
++	printk(&quot;%s(%d) &quot; fmt, __FUNCTION__, __LINE__, ##args);	\
++} while (0)
++
++#define eprintk dprintk
++
++struct scsi_tgt_queuedata {
++	struct Scsi_Host *shost;
++};
++
++extern void scsi_tgt_if_exit(void);
++extern int scsi_tgt_if_init(void);
++
++extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, gfp_t flags);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
++				u64 offset, unsigned long uaddr, u8 rw,
++				u8 try_map);
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 6a2ccf7..580fb42 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..91ad6bc
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,11 @@
++/*
++ * SCSI target definitions
++ */
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *cmd);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern void scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, int);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..04be52d
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,92 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">tomof at acm.org</A>&gt;
++ * Copyright (C) 2005 Mike Christie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/stgt-svn">michaelc at cs.wisc.edu</A>&gt;
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -&gt; kernel */
++	TGT_UEVENT_TGTD_BIND,
++	TGT_UEVENT_TARGET_SETUP,
++	TGT_UEVENT_CMD_RES,
++
++	/* kernel -&gt; user */
++	TGT_KEVENT_RESPONSE,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++};
++
++struct tgt_event {
++	/* user-&gt; kernel */
++	union {
++		struct {
++			int pk_fd;
++		} tgtd_bind;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint64_t offset;
++			uint8_t rw;
++			uint8_t try_map;
++		} cmd_res;
++	} u;
++
++	/* kernel -&gt; user */
++	union {
++		struct {
++			int err;
++		} event_res;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint64_t dev_id;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++	} k;
++
++	/*
++	 * I think a pointer is a unsigned long but this struct
++	 * gets passed around from the kernel to userspace and
++	 * back again so to handle some ppc64 setups where userspace is
++	 * 32 bits but the kernel is 64 we do this odd thing
++	 */
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#ifndef __KERNEL__
++#define MAX_COMMAND_SIZE	16
++#endif
++
++struct tgt_cmd {
++	uint8_t scb[MAX_COMMAND_SIZE];
++	uint8_t lun[8];
++	int tags;
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
++#endif
+-- 
+1.1.3


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000276.html">[Stgt-svn] r289 - branches/use-scsi-ml
</A></li>
	<LI>Next message: <A HREF="000278.html">[Stgt-svn] r291 - branches/use-scsi-ml/patchset
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#277">[ date ]</a>
              <a href="thread.html#277">[ thread ]</a>
              <a href="subject.html#277">[ subject ]</a>
              <a href="author.html#277">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/stgt-svn">More information about the Stgt-svn
mailing list</a><br>
</body></html>
