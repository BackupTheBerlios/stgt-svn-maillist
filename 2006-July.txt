From tomo at berlios.de  Sat Jul  8 14:09:29 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 8 Jul 2006 14:09:29 +0200
Subject: [Stgt-svn] r499 - in trunk: istgt/kernel usr
Message-ID: <200607081209.k68C9T6F023858@sheep.berlios.de>

Author: tomo
Date: 2006-07-08 14:09:06 +0200 (Sat, 08 Jul 2006)
New Revision: 499

Modified:
   trunk/istgt/kernel/iscsi_tcp_target.c
   trunk/usr/tgtd.c
Log:
Update for cmnd field removal again.

Modified: trunk/istgt/kernel/iscsi_tcp_target.c
===================================================================
--- trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-08 11:36:28 UTC (rev 498)
+++ trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-08 12:09:06 UTC (rev 499)
@@ -445,12 +445,12 @@
 	if (left <= ctask->conn->max_xmit_dlength) {
 		hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
 
-		if (sc->bufflen < exp_datalen) {
+		if (sc->request_bufflen < exp_datalen) {
 			hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - sc->bufflen;
-		} else if (sc->bufflen > exp_datalen) {
+			residual = exp_datalen - sc->request_bufflen;
+		} else if (sc->request_bufflen > exp_datalen) {
 			hdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = sc->bufflen - exp_datalen;
+			residual = sc->request_bufflen - exp_datalen;
 		} else
 			residual = 0;
 		hdr->residual_count = cpu_to_be32(residual);
@@ -459,7 +459,7 @@
 		size = ctask->conn->max_xmit_dlength;
 
 	dprintk("%d %d %d %d %d\n", size, left, ctask->conn->max_xmit_dlength,
-		exp_datalen, sc->bufflen);
+		exp_datalen, sc->request_bufflen);
 
 	hton24(hdr->dlength, size);
 	ctask->data_count = ctask->unsol_count = size;
@@ -541,11 +541,10 @@
 {
 	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
 
-	dprintk("%p %x %x %u %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], scmd->request_bufflen,
-		scmd->bufflen, scmd->sc_data_direction);
+	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
+		ctask->hdr->cdb[0], scmd->request_bufflen, scmd->sc_data_direction);
 
-	if (scmd->sc_data_direction == DMA_FROM_DEVICE && scmd->bufflen) {
+	if (scmd->sc_data_direction == DMA_FROM_DEVICE && scmd->request_bufflen) {
 		/* We've already sent data in transfer_data. */
 		iscsi_tcp_tgt_ctask_cleanup(ctask);
 		done(scmd);
@@ -577,6 +576,9 @@
 	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
 		ctask->hdr->cdb[0], sc->request_bufflen, sc->sc_data_direction);
 
+	/* We cannot handle this. */
+	BUG_ON(sc->offset);
+
 	sc->done = done;
 	if (sc->sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
@@ -590,7 +592,7 @@
 	} else {
 		tcp_ctask->sg_count = 0;
 		tcp_ctask->data_offset = 0;
-		ctask->unsol_count = sc->bufflen;
+		ctask->unsol_count = sc->request_bufflen;
 		tcp_ctask->sg = sc->request_buffer;
 		tcp_ctask->xmstate = XMSTATE_UNS_INIT | XMSTATE_UNS_HDR;
 		iscsi_tcp_tgt_ctask_xmitqueue(ctask);

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-08 11:36:28 UTC (rev 498)
+++ trunk/usr/tgtd.c	2006-07-08 12:09:06 UTC (rev 499)
@@ -234,7 +234,7 @@
 		exit(1);
 
 	nr = dl_init(dlinfo);
-	if (nr < nr)
+	if (nr < 0)
 		exit(1);
 
 	pfd = poll_init(nr, nl_fd, ud_fd);



From tomo at berlios.de  Sat Jul  8 09:00:28 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 8 Jul 2006 09:00:28 +0200
Subject: [Stgt-svn] r497 - trunk
Message-ID: <200607080700.k6870SNA015034@sheep.berlios.de>

Author: tomo
Date: 2006-07-08 09:00:06 +0200 (Sat, 08 Jul 2006)
New Revision: 497

Modified:
   trunk/initd
Log:
Update the init script.

Modified: trunk/initd
===================================================================
--- trunk/initd	2006-06-27 05:49:03 UTC (rev 496)
+++ trunk/initd	2006-07-08 07:00:06 UTC (rev 497)
@@ -1,31 +1,85 @@
 #!/bin/bash
 #
-# Temporary script to start tgt and istgt
+# Temporary script to start tgt
 #
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 MEM_SIZE=1048576
 export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${PWD}/ibmvstgt/usr:${LD_LIBRARY_PATH}
 
-if [ -f ${PWD}/istgt/kernel/iscsi_tcp_tgt.ko ] ; then
-	TARGET=istgt
-fi
+#
+# Need to select one
+#
+#TARGET=ibmvio
+TARGET=iscsi_tcp
 
+#
+# IBM pSeries VIO server
+#
+start_ibmvio()
+{
+	insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
+	insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
+}
+
+stop_ibmvio()
+{
+	rmmod libsrp
+	rmmod ibmvstgt
+}
+
+
+#
+# iSCSI stuff
+#
+start_iscsi_core()
+{
+	insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
+	insmod ${PWD}/istgt/kernel/libiscsi.ko
+}
+
+stop_iscsi_core()
+{
+	rmmod libiscsi
+	rmmod scsi_transport_iscsi
+}
+
+start_iscsi_tcp()
+{
+	modprobe -q crc32c
+
+	start_iscsi_core
+
+	insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
+	insmod ${PWD}/istgt/kernel/iscsi_tcp_target.ko
+	${PWD}/istgt/usr/istgtd
+}
+
+stop_iscsi_tcp()
+{
+	rmmod iscsi_tcp_target
+	rmmod iscsi_tcp
+}
+
+start_iscsi_iser()
+{
+    	start_iscsi_core
+}
+
 start_server()
 {
 	insmod ${PWD}/kernel/scsi_tgt.ko
 
-	if [ "$TARGET" = "istgt" ] ; then
-		modprobe -q crc32c
-		insmod ${PWD}/istgt/kernel/scsi_transport_iscsi.ko
-		insmod ${PWD}/istgt/kernel/libiscsi.ko
-		insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
-		insmod ${PWD}/istgt/kernel/iscsi_tcp_tgt.ko
-		${PWD}/istgt/usr/istgtd
-	else
-		insmod ${PWD}/ibmvstgt/kernel/libsrp.ko
-		insmod ${PWD}/ibmvstgt/kernel/ibmvstgt.ko
-	fi
+	case "$TARGET" in
+	    iscsi_tcp)
+		start_iscsi_tcp
+		;;
+	    ibmvio)
+		start_ibmvio
+		;;
+	    *)
+		;;
+	esac
 
 	${PWD}/usr/tgtd -d0
 
@@ -34,26 +88,32 @@
 	
 stop_server()
 {
-	if [ "$TARGET" = "istgt" ] ; then
+	case "$TARGET" in
+	    iscsi_tcp)
 		${PWD}/usr/tgtadm --driver istgt --op delete
 		killall -9 istgtd
-	else
+		;;
+	    ibmvio)
 		${PWD}/usr/tgtadm --driver ibmvstgt --op delete
-	fi
+		;;
+	    *)
+		;;
+	esac
 
 	killall -9 tgtd
 
 	sleep 1
 
-	if [ "$TARGET" = "istgt" ] ; then
-		rmmod iscsi_tcp_tgt
-		rmmod iscsi_tcp
-		rmmod libiscsi
-		rmmod scsi_transport_iscsi
-	else
-		rmmod libsrp
-		rmmod ibmvstgt
-	fi
+	case "$TARGET" in
+	    iscsi_tcp)
+		stop_iscsi_tcp
+		;;
+	    ibmvio)
+		stop_ibmvio
+		;;
+	    *)
+		;;
+	esac
 
 	rmmod scsi_tgt
 }



From tomo at berlios.de  Sun Jul  9 08:56:44 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 9 Jul 2006 08:56:44 +0200
Subject: [Stgt-svn] r501 - trunk/istgt/kernel
Message-ID: <200607090656.k696uiSg010733@sheep.berlios.de>

Author: tomo
Date: 2006-07-09 08:56:41 +0200 (Sun, 09 Jul 2006)
New Revision: 501

Modified:
   trunk/istgt/kernel/iscsi_tcp_target.c
Log:
Fix invalid memory access bug.

Modified: trunk/istgt/kernel/iscsi_tcp_target.c
===================================================================
--- trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-09 04:54:45 UTC (rev 500)
+++ trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-09 06:56:41 UTC (rev 501)
@@ -151,7 +151,7 @@
 	hdr->itt = ctask->itt;
 	hdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
 	hdr->data_offset = cpu_to_be32(tcp_ctask->data_offset);
-	hdr->ttt = (unsigned long) ctask; /* FIXME */
+	hdr->ttt = (unsigned long) ctask;
 	length = min(tcp_ctask->r2t_data_count, session->max_burst);
 	hdr->data_length = cpu_to_be32(length);
 	tcp_ctask->r2t_data_count -= length;
@@ -310,7 +310,7 @@
 	case ISCSI_OP_SCSI_DATA_OUT:
 		ctask = hashlist_find(cls_session, hdr->itt);
 		if (!ctask) {
-			eprintk("Cannot find %x\n", ctask->hdr->itt);
+			eprintk("Cannot find %x\n", hdr->itt);
 			rc = ISCSI_ERR_NO_SCSI_CMD;
 			break;
 		}



From tomo at berlios.de  Sun Jul  9 06:54:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sun, 9 Jul 2006 06:54:48 +0200
Subject: [Stgt-svn] r500 - trunk/istgt/kernel
Message-ID: <200607090454.k694smYU003888@sheep.berlios.de>

Author: tomo
Date: 2006-07-09 06:54:45 +0200 (Sun, 09 Jul 2006)
New Revision: 500

Modified:
   trunk/istgt/kernel/iscsi_tcp.c
   trunk/istgt/kernel/iscsi_tcp_target.c
Log:
Fix locking issue and invalid memory access.

Modified: trunk/istgt/kernel/iscsi_tcp.c
===================================================================
--- trunk/istgt/kernel/iscsi_tcp.c	2006-07-08 12:09:06 UTC (rev 499)
+++ trunk/istgt/kernel/iscsi_tcp.c	2006-07-09 04:54:45 UTC (rev 500)
@@ -53,12 +53,17 @@
 /* #define DEBUG_TCP */
 #define DEBUG_ASSERT
 
-#ifdef DEBUG_TCP
-#define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt)
-#else
-#define debug_tcp(fmt...)
-#endif
+/* #ifdef DEBUG_TCP */
+/* #define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt) */
+/* #else */
+/* #define debug_tcp(fmt...) */
+/* #endif */
 
+#define debug_tcp(fmt, args...)					\
+do {								\
+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
+} while (0)
+
 #ifndef DEBUG_ASSERT
 #ifdef BUG_ON
 #undef BUG_ON

Modified: trunk/istgt/kernel/iscsi_tcp_target.c
===================================================================
--- trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-08 12:09:06 UTC (rev 499)
+++ trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-09 04:54:45 UTC (rev 500)
@@ -356,22 +356,23 @@
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_hdr *hdr = (struct iscsi_hdr *) ctask->hdr;
 
 	BUG_ON(ctask->data_count);
-	tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
+	tcp_ctask->data_offset += ntoh24(hdr->dlength);
 
-	dprintk("%p %x %u %u %u %u %u\n", ctask, tcp_conn->in.hdr->flags,
+	dprintk("%p %x %u %u %u %u %u\n", ctask, hdr->flags,
 		tcp_ctask->r2t_data_count, ctask->unsol_count,
 		ctask->total_length, ctask->imm_count, tcp_ctask->data_offset);
 
-	if (tcp_conn->in.hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		tcp_ctask->r2t_data_count -= ntoh24(tcp_conn->in.hdr->dlength);
-		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
+	if (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		tcp_ctask->r2t_data_count -= ntoh24(hdr->dlength);
+		if (hdr->flags & ISCSI_FLAG_CMD_FINAL) {
 			ctask->unsol_count = 0;
 			iscsi_cmd_data_done(ctask);
 		}
 	} else {
-		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL)
+		if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
 			iscsi_cmd_data_done(ctask);
 	}
 }
@@ -380,9 +381,10 @@
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+	struct iscsi_cmd *hdr = ctask->hdr;
 	int rc = 0, opcode;
 
-	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
+	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
 	dprintk("opcode 0x%x offset %d copy %d datalen %d\n",
 		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
 		tcp_conn->in.datalen);
@@ -394,7 +396,7 @@
 			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 
 			dprintk("%p %x %u %u %u %u %u\n", ctask,
-				tcp_conn->in.hdr->flags,
+				hdr->flags,
 				tcp_ctask->r2t_data_count,
 				ctask->unsol_count,
 				ctask->total_length,
@@ -562,9 +564,9 @@
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct sock *sk = tcp_conn->sock->sk;
 
-	bh_lock_sock(sk);
+	lock_sock(sk);
 	sk->sk_data_ready(sk, 0);
-	bh_unlock_sock(sk);
+	release_sock(sk);
 }
 
 static int iscsi_tgt_transfer_data(struct scsi_cmnd *sc,



From tomo at berlios.de  Sat Jul  8 13:36:31 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Sat, 8 Jul 2006 13:36:31 +0200
Subject: [Stgt-svn] r498 - trunk/istgt/kernel
Message-ID: <200607081136.k68BaV3r014375@sheep.berlios.de>

Author: tomo
Date: 2006-07-08 13:36:28 +0200 (Sat, 08 Jul 2006)
New Revision: 498

Modified:
   trunk/istgt/kernel/iscsi_tcp_target.c
Log:
Update for cmnd field removal.

Modified: trunk/istgt/kernel/iscsi_tcp_target.c
===================================================================
--- trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-08 07:00:06 UTC (rev 497)
+++ trunk/istgt/kernel/iscsi_tcp_target.c	2006-07-08 11:36:28 UTC (rev 498)
@@ -111,7 +111,7 @@
 	scmd = scsi_host_get_command(shost, dir, GFP_ATOMIC);
 	BUG_ON(!scmd);
 	ctask->sc = scmd;
-	memcpy(scmd->data_cmnd, hdr->cdb, MAX_COMMAND_SIZE);
+	memcpy(scmd->cmnd, hdr->cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = be32_to_cpu(hdr->data_length);
 	scmd->SCp.ptr = (void *) ctask;
 	scmd->done = NULL;



From tomo at berlios.de  Wed Jul 12 19:14:04 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 12 Jul 2006 19:14:04 +0200
Subject: [Stgt-svn] r502 - in trunk: . istgt usr usr/iscsi
Message-ID: <200607121714.k6CHE4WR010764@sheep.berlios.de>

Author: tomo
Date: 2006-07-12 19:13:53 +0200 (Wed, 12 Jul 2006)
New Revision: 502

Added:
   trunk/usr/driver.c
   trunk/usr/driver.h
   trunk/usr/iscsi/
   trunk/usr/iscsi/iscsi.h
Removed:
   trunk/istgt/usr/
   trunk/usr/dl.c
   trunk/usr/dl.h
   trunk/usr/iscsi/libistgt.c
   trunk/usr/iscsi/log.c
   trunk/usr/iscsi/log.h
   trunk/usr/tgt_sysfs.c
   trunk/usr/tgt_sysfs.h
Modified:
   trunk/Makefile
   trunk/initd
   trunk/iscsi
   trunk/istgt/Makefile
   trunk/usr/Makefile
   trunk/usr/iscsi/Makefile
   trunk/usr/iscsi/iscsid.h
   trunk/usr/iscsi/istgt.c
   trunk/usr/iscsi/netlink.c
   trunk/usr/iscsi/session.c
   trunk/usr/iscsi/target.c
   trunk/usr/mgmt.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Go back to the old design, which tgt daemon handles everything. iSCSI
code works as library. Right now tgt code and iSCSI code are linked to a
single image. Later on, I work on something like dll.


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/Makefile	2006-07-12 17:13:53 UTC (rev 502)
@@ -9,8 +9,8 @@
 all:
 ifeq ($(ARCH), powerpc)
 	make -C ibmvstgt
-#else
-#	make -C istgt
+else
+	make -C istgt
 endif
 	make -C usr
 	make -C kernel

Modified: trunk/initd
===================================================================
--- trunk/initd	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/initd	2006-07-12 17:13:53 UTC (rev 502)
@@ -5,7 +5,6 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 MEM_SIZE=1048576
-export LD_LIBRARY_PATH=${PWD}/usr:${PWD}/istgt/usr:${PWD}/ibmvstgt/usr:${LD_LIBRARY_PATH}
 
 #
 # Need to select one
@@ -52,7 +51,6 @@
 
 	insmod ${PWD}/istgt/kernel/iscsi_tcp.ko
 	insmod ${PWD}/istgt/kernel/iscsi_tcp_target.ko
-	${PWD}/istgt/usr/istgtd
 }
 
 stop_iscsi_tcp()
@@ -81,7 +79,7 @@
 		;;
 	esac
 
-	${PWD}/usr/tgtd -d0
+	${PWD}/usr/tgtd -d8 --drivers iscsi
 
 	sleep 1
 }

Modified: trunk/iscsi
===================================================================
--- trunk/iscsi	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/iscsi	2006-07-12 17:13:53 UTC (rev 502)
@@ -5,5 +5,5 @@
 
 PATH=/sbin:/bin:/usr/sbin:/usr/bin
 
-${PWD}/usr/tgtadm --driver istgt --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
-${PWD}/usr/tgtadm --driver istgt --op new --tid 1 --lun 0 --params Path=/dev/hdc1
+${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --params iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
+${PWD}/usr/tgtadm --driver iscsi --op new --tid 1 --lun 0 --params Path=/dev/hdc1

Modified: trunk/istgt/Makefile
===================================================================
--- trunk/istgt/Makefile	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/istgt/Makefile	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,17 +1,7 @@
 SUBDIRS := $(shell pwd)
 
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-all: libs mods
-
 mods:
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
 
-libs:
-	$(MAKE) -C usr
-
 clean:
-	$(MAKE) -C usr clean
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/Makefile	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,13 +1,17 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -D_LARGEFILE64_SOURCE
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE -DISCSI
 PROGRAMS = tgtd tgtadm
+TGTD_OBJS = tgtd.o netlink.o mgmt.o target.o scsi.o log.o driver.o
+TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
+LIBS = -lcrypto
 
 all: $(PROGRAMS)
 
-tgtd: tgtd.o netlink.o dl.o mgmt.o target.o scsi.o log.o tgt_sysfs.o
-	$(CC) -rdynamic -ldl $^ -o $@
+tgtd: $(TGTD_OBJS)
+	$(CC) $^ -g -o $@ $(LIBS)
 
 tgtadm: tgtadm.o
-	$(CC) -rdynamic -ldl $^ -o $@
+	$(CC) $^ -o $@
 
 clean:
 	rm -f *.o $(PROGRAMS)
+	$(MAKE) -C iscsi clean

Deleted: trunk/usr/dl.c
===================================================================
--- trunk/usr/dl.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/dl.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,99 +0,0 @@
-/*
- * SCSI target dynamic library
- *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <string.h>
-#include <fcntl.h>
-#include <dlfcn.h>
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <errno.h>
-#include <sys/stat.h>
-#include <sys/poll.h>
-
-#include "log.h"
-#include "dl.h"
-#include "util.h"
-#include "tgt_sysfs.h"
-
-/*
- * Software LLDs needs to set up a target (that means tgtd must load
- * thier libraries) before a scsi_host is created in kernel space. In
- * short, tgtd needs to load LLD libraries before it knows what
- * libraries are avilable (through sysfs). I chose the easiest way.
- */
-
-struct driver_info dlinfo[] = {
-	{"istgt", }, {"ibmvstgt",},
-};
-
-/* Bah, any better way? */
-static char *dl_fn_table[] = {
-	"poll_init",
-	"poll_event",
-	"ipc_mgmt",
-	"scsi_inquiry",
-	"scsi_report_luns",
-	"scsi_lun_to_int",
-};
-
-int dl_init(struct driver_info *dinfo)
-{
-	int i, j, fd, err;
-	char path[PATH_MAX];
-
-	system("rm -rf " TGT_LLD_SYSFSDIR);
-	err = mkdir(TGT_LLD_SYSFSDIR, DEFDMODE);
-	if (err < 0) {
-		perror("Cannot create " TGT_LLD_SYSFSDIR);
-		return err;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(dlinfo); i++) {
-		snprintf(path, sizeof(path), "lib%s.so", dlinfo[i].name);
-		dlinfo[i].dl = dlopen(path, RTLD_LAZY);
-		if (dlinfo[i].dl) {
-			eprintf("%s library was loaded.\n", dlinfo[i].name);
-			for (j = 0; j < ARRAY_SIZE(dl_fn_table); j++)
-				dlinfo[i].fn[j] =
-					dlsym(dlinfo[i].dl, dl_fn_table[j]);
-		} else
-			eprintf("%s library is not loaded.\n", dlinfo[i].name);
-
-		snprintf(path, sizeof(path), TGT_LLD_SYSFSDIR "/%d-%s",
-			 i, dlinfo[i].name);
-
-		fd = open(path, O_RDWR|O_CREAT|O_EXCL, DEFFMODE);
-		if (fd < 0) {
-			eprintf("Cannot create %s.\n", path);
-			exit(1);
-		}
-	}
-
-	return ARRAY_SIZE(dlinfo);
-}
-
-void *dl_fn(struct driver_info *dinfo, int idx, int function)
-{
-	return dinfo[idx].fn[function];
-}

Deleted: trunk/usr/dl.h
===================================================================
--- trunk/usr/dl.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/dl.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,24 +0,0 @@
-#ifndef __DL_H
-#define __DL_H
-
-#define	MAX_DL_HANDLES	16
-
-#define	DL_FN_POLL_INIT		0
-#define	DL_FN_POLL_EVENT	1
-#define	DL_FN_IPC_MGMT		2
-#define	DL_FN_SCSI_INQUIRY	3
-#define	DL_FN_SCSI_REPORT_LUNS	4
-#define	DL_FN_SCSI_LUN_TO_INT	5
-#define	DL_FN_END		6
-
-struct driver_info {
-	char *name;
-	void *dl;
-	void *fn[DL_FN_END];
-};
-
-extern struct driver_info dlinfo[];
-
-extern int dl_init(struct driver_info *);
-extern void *dl_fn(struct driver_info *, int, int);
-#endif

Added: trunk/usr/driver.c
===================================================================
--- trunk/usr/driver.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/driver.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -0,0 +1,51 @@
+#include <errno.h>
+#include <string.h>
+#include <poll.h>
+#include <inttypes.h>
+
+#include "tgtd.h"
+#include "driver.h"
+
+#ifdef ISCSI
+#include "iscsi/iscsi.h"
+#endif
+
+#ifdef IBMVIO
+struct tgt_driver ibmvio = {
+	.name	= "ibmvio",
+};
+#endif
+
+#ifdef ISCSI
+struct tgt_driver iscsi = {
+	.name		= "iscsi",
+	.init		= iscsi_init,
+	.poll_init	= iscsi_poll_init,
+	.event_handle	= iscsi_event_handle,
+	.target_create	= iscsi_target_create,
+	.target_destroy	= iscsi_target_destroy,
+	.target_bind	= iscsi_target_bind,
+};
+#endif
+
+struct tgt_driver *tgt_drivers[] = {
+#ifdef IBMVIO
+	&ibmvio,
+#endif
+#ifdef ISCSI
+	&iscsi,
+#endif
+	NULL,
+};
+
+int get_driver_index(char *name)
+{
+	int i;
+
+	for (i = 0; tgt_drivers[i]; i++) {
+		if (!strcmp(name, tgt_drivers[i]->name))
+			return i;
+	}
+
+	return -ENOENT;
+}

Added: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/driver.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -0,0 +1,27 @@
+#include <poll.h>
+
+struct tgt_driver {
+	const char *name;
+
+	int (*init) (int *);
+	int (*poll_init) (struct pollfd *);
+	int (*event_handle) (struct pollfd *);
+
+	int (*target_create) (int, char *);
+	int (*target_destroy) (int);
+	int (*target_bind)(int);
+
+	uint64_t (*scsi_get_lun)(uint8_t *);
+	int (*scsi_report_luns)(struct list_head *, uint8_t *, uint8_t *,
+				uint8_t *, int *);
+	int (*scsi_inquiry)(struct tgt_device *, int, uint8_t *, uint8_t *,
+			    uint8_t *, int *);
+
+	int npfd;
+	int enable;
+	int pfd_index;
+};
+
+extern struct tgt_driver *tgt_drivers[];
+extern int get_driver_index(char *name);
+

Copied: trunk/usr/iscsi (from rev 501, trunk/istgt/usr)

Modified: trunk/usr/iscsi/Makefile
===================================================================
--- trunk/istgt/usr/Makefile	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/Makefile	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,16 +1,9 @@
-CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../include -I../../include -I../../usr
+CFLAGS += -O2 -fno-inline -Wall -fPIC -Wstrict-prototypes -I$(KERNELSRC)/include -I../../istgt/include -I../../include -I../../usr
 LIBS = -lcrypto
-OBJS = libistgt.o
-SHAREDLIB = libistgt.so
-DAEMON = istgtd
+DAEMON = iscsi.o
 
-all: $(DAEMON) $(SHAREDLIB)
+$(DAEMON): istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
+	$(CC) -o $@ $^ $(LIBS)
 
-$(DAEMON): log.o istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o
-	$(CC) $^ -o $@ $(LIBS)
-
-$(SHAREDLIB): $(OBJS)
-	$(CC) -shared -o $@ $(OBJS)
-
 clean:
 	rm -f *.o istgtd $(SHAREDLIB)

Added: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/istgt/usr/iscsi.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/iscsi.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -0,0 +1,6 @@
+extern int iscsi_init(int *);
+extern int iscsi_poll_init(struct pollfd *);
+extern int iscsi_event_handle(struct pollfd *);
+extern int iscsi_target_create(int, char *);
+extern int iscsi_target_destroy(int);
+extern int iscsi_target_bind(int);

Modified: trunk/usr/iscsi/iscsid.h
===================================================================
--- trunk/istgt/usr/iscsid.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/iscsid.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -27,7 +27,7 @@
 #define DIGEST_CRC32C           (1 << 1)
 
 extern uint64_t thandle;
-extern int nl_fd, ipc_fd;
+extern int nl_fd;
 
 #define sid64(isid, tsih)					\
 ({								\
@@ -51,6 +51,7 @@
 
 struct session {
 	struct qelem slist;
+	struct qelem hlist;
 
 	char *initiator;
 	struct target *target;
@@ -187,6 +188,7 @@
 /* session.c */
 extern struct session *session_find_name(int tid, const char *iname, uint8_t *isid);
 extern struct session *session_find_id(int tid, uint64_t sid);
+extern struct session *session_find_hostno(int hostno);
 extern void session_create(struct connection *conn);
 extern void session_remove(struct session *session);
 
@@ -225,7 +227,7 @@
 			  uint32_t cid, int flag);
 };
 
-extern int nl_init(void);
+extern int iscsi_nl_init(void);
 
 extern struct iscsi_kernel_interface *ki;
 

Modified: trunk/usr/iscsi/istgt.c
===================================================================
--- trunk/istgt/usr/istgt.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/istgt.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -41,17 +41,14 @@
 
 enum {
 	POLL_LISTEN,
-	POLL_IPC = POLL_LISTEN + LISTEN_MAX,
-	POLL_NL,
+	POLL_NL = POLL_LISTEN + LISTEN_MAX,
 	POLL_INCOMING,
 	POLL_MAX = POLL_INCOMING + INCOMING_MAX,
 };
 
-static struct pollfd pfd[POLL_MAX];
 static struct connection *incoming[INCOMING_MAX];
-static char program_name[] = "istgt";
 uint64_t thandle;
-int nl_fd, ipc_fd;
+int nl_fd;
 
 static void set_non_blocking(int fd)
 {
@@ -169,7 +166,7 @@
 	return;
 }
 
-static void poll_event(struct pollfd *pfds)
+void iscsi_event_handle(struct pollfd *pfds)
 {
 	struct connection *conn;
 	struct pollfd *pfd;
@@ -180,12 +177,6 @@
 			accept_connection(pfds, pfds[POLL_LISTEN + i].fd);
 	}
 
-/* 	if (pfd[POLL_NL].revents) */
-/* 		handle_iscsi_events(nl_fd); */
-
-	if (pfds[POLL_IPC].revents)
-		ipc_event();
-
 	for (i = 0; i < INCOMING_MAX; i++) {
 		conn = incoming[i];
 		pfd = &pfds[POLL_INCOMING + i];
@@ -318,14 +309,12 @@
 	}
 }
 
-static void event_loop(void)
+int iscsi_poll_init(struct pollfd *pfd)
 {
-	int i, err;
+	int i;
 
 	pfd[POLL_NL].fd = nl_fd;
 	pfd[POLL_NL].events = POLLIN;
-	pfd[POLL_IPC].fd = ipc_fd;
-	pfd[POLL_IPC].events = POLLIN;
 
 	listen_socket_create(pfd + POLL_LISTEN);
 
@@ -335,59 +324,13 @@
 		incoming[i] = NULL;
 	}
 
-retry:
-	err = poll(pfd, POLL_MAX, -1);
-	if (err < 0) {
-		if (errno != EINTR) {
-			eprintf("%d %d\n", err, errno);
-			exit(1);
-		} else
-			goto retry;
-	}
-
-	poll_event(pfd);
-	goto retry;
-}
-
-static int daemon_init(void)
-{
-	pid_t pid;
-
-	pid = fork();
-	if (pid < 0)
-		return -ENOMEM;
-	else if (pid)
-		exit(0);
-
-	setsid();
-	chdir("/");
-	close(0);
-	open("/dev/null", O_RDWR);
-	dup2(0, 1);
-	dup2(0, 2);
-
 	return 0;
 }
 
-int main(int argc, char **argv)
+int iscsi_init(int *npfd)
 {
-	int err, is_daemon = 1, is_debug = 1;
+	iscsi_nl_init();
+	*npfd = POLL_MAX;
 
-	if (is_daemon && daemon_init())
-		exit(1);
-
-	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
-		exit(1);
-
-	err = nl_init();
-	if (err)
-		exit(1);
-
-	err = ipc_init();
-	if (err)
-		exit(1);
-
-	event_loop();
-
 	return 0;
 }

Deleted: trunk/usr/iscsi/libistgt.c
===================================================================
--- trunk/istgt/usr/libistgt.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/libistgt.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-#include "tgtadm.h"
-
-static int ipc_connect(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, ISTGT_NAMESPACE, strlen(ISTGT_NAMESPACE));
-
-	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		fd = err;
-
-	return fd;
-}
-
-int ipc_mgmt(char *sbuf, char *rbuf)
-{
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct tgtadm_req *req;
-	int err = -EINVAL, fd;
-	char *params;
-
-	req = NLMSG_DATA(nlh);
-	params = (char *) req + sizeof(*req);
-
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
-
-	fd = ipc_connect();
-	if (fd < 0) {
-		eprintf("cannot connect istgtd\n");
-		return fd;
-	}
-
-	err = write(fd, sbuf, nlh->nlmsg_len);
-	if (err < 0) {
-		eprintf("cannot connect istgtd\n");
-		goto out;
-	}
-
-out:
-	close(fd);
-
-	return err;
-}

Deleted: trunk/usr/iscsi/log.c
===================================================================
--- trunk/istgt/usr/log.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/log.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,345 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <ctype.h>
-#include <string.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <syslog.h>
-#include <signal.h>
-#include <sys/shm.h>
-#include <sys/ipc.h>
-#include <sys/types.h>
-
-#include "log.h"
-
-#define SEMKEY	0xA7L
-#define LOGDBG 0
-
-#if LOGDBG
-#define logdbg(file, fmt, args...) fprintf(file, fmt, ##args)
-#else
-#define logdbg(file, fmt, args...) do {} while (0)
-#endif
-
-static char *log_name;
-static int is_daemon, is_debug;
-
-static int logarea_init (int size)
-{
-	int shmid;
-
-	logdbg(stderr,"enter logarea_init\n");
-
-	if ((shmid = shmget(IPC_PRIVATE, sizeof(struct logarea),
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1)
-		return 1;
-
-	la = shmat(shmid, NULL, 0);
-	if (!la)
-		return 1;
-
-	if (size < MAX_MSG_SIZE)
-		size = LOG_SPACE_SIZE;
-
-	if ((shmid = shmget(IPC_PRIVATE, size,
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
-		shmdt(la);
-		return 1;
-	}
-
-	la->start = shmat(shmid, NULL, 0);
-	if (!la->start) {
-		shmdt(la);
-		return 1;
-	}
-	memset(la->start, 0, size);
-
-	la->empty = 1;
-	la->end = la->start + size;
-	la->head = la->start;
-	la->tail = la->start;
-
-	if ((shmid = shmget(IPC_PRIVATE, MAX_MSG_SIZE + sizeof(struct logmsg),
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-	la->buff = shmat(shmid, NULL, 0);
-	if (!la->buff) {
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	if ((la->semid = semget(SEMKEY, 1, 0666 | IPC_CREAT)) < 0) {
-		shmdt(la->buff);
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	la->semarg.val=1;
-	if (semctl(la->semid, 0, SETVAL, la->semarg) < 0) {
-		shmdt(la->buff);
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	la->ops[0].sem_num = 0;
-	la->ops[0].sem_flg = 0;
-
-	return 0;
-
-}
-
-static void free_logarea (void)
-{
-	semctl(la->semid, 0, IPC_RMID, la->semarg);
-	shmdt(la->buff);
-	shmdt(la->start);
-	shmdt(la);
-	return;
-}
-
-#if LOGDBG
-static void dump_logarea (void)
-{
-	struct logmsg * msg;
-
-	logdbg(stderr, "\n==== area: start addr = %p, end addr = %p ====\n",
-		la->start, la->end);
-	logdbg(stderr, "|addr     |next     |prio|msg\n");
-
-	for (msg = (struct logmsg *)la->head; (void *)msg != la->tail;
-	     msg = msg->next)
-		logdbg(stderr, "|%p |%p |%i   |%s\n", (void *)msg, msg->next,
-				msg->prio, (char *)&msg->str);
-
-	logdbg(stderr, "|%p |%p |%i   |%s\n", (void *)msg, msg->next,
-			msg->prio, (char *)&msg->str);
-
-	logdbg(stderr, "\n\n");
-}
-#endif
-
-int log_enqueue (int prio, const char * fmt, va_list ap)
-{
-	int len, fwd;
-	char buff[MAX_MSG_SIZE];
-	struct logmsg * msg;
-	struct logmsg * lastmsg;
-
-	lastmsg = (struct logmsg *)la->tail;
-
-	if (!la->empty) {
-		fwd = sizeof(struct logmsg) +
-		      strlen((char *)&lastmsg->str) * sizeof(char) + 1;
-		la->tail += fwd;
-	}
-	vsnprintf(buff, MAX_MSG_SIZE, fmt, ap);
-	len = strlen(buff) * sizeof(char) + 1;
-
-	/* not enough space on tail : rewind */
-	if (la->head <= la->tail &&
-	    (len + sizeof(struct logmsg)) > (la->end - la->tail)) {
-		logdbg(stderr, "enqueue: rewind tail to %p\n", la->tail);
-			la->tail = la->start;
-	}
-
-	/* not enough space on head : drop msg */
-	if (la->head > la->tail &&
-	    (len + sizeof(struct logmsg)) > (la->head - la->tail)) {
-		logdbg(stderr, "enqueue: log area overrun, drop msg\n");
-
-		if (!la->empty)
-			la->tail = lastmsg;
-
-		return 1;
-	}
-
-	/* ok, we can stage the msg in the area */
-	la->empty = 0;
-	msg = (struct logmsg *)la->tail;
-	msg->prio = prio;
-	memcpy((void *)&msg->str, buff, len);
-	lastmsg->next = la->tail;
-	msg->next = la->head;
-
-	logdbg(stderr, "enqueue: %p, %p, %i, %s\n", (void *)msg, msg->next,
-		msg->prio, (char *)&msg->str);
-
-#if LOGDBG
-	dump_logarea();
-#endif
-	return 0;
-}
-
-int log_dequeue (void * buff)
-{
-	struct logmsg * src = (struct logmsg *)la->head;
-	struct logmsg * dst = (struct logmsg *)buff;
-	struct logmsg * lst = (struct logmsg *)la->tail;
-
-	if (la->empty)
-		return 1;
-
-	int len = strlen((char *)&src->str) * sizeof(char) +
-		  sizeof(struct logmsg) + 1;
-
-	dst->prio = src->prio;
-	memcpy(dst, src,  len);
-
-	if (la->tail == la->head)
-		la->empty = 1; /* we purge the last logmsg */
-	else {
-		la->head = src->next;
-		lst->next = la->head;
-	}
-	logdbg(stderr, "dequeue: %p, %p, %i, %s\n",
-		(void *)src, src->next, src->prio, (char *)&src->str);
-
-	memset((void *)src, 0,  len);
-
-	return la->empty;
-}
-
-/*
- * this one can block under memory pressure
- */
-static void log_syslog (void * buff)
-{
-	struct logmsg * msg = (struct logmsg *)buff;
-
-	syslog(msg->prio, "%s", (char *)&msg->str);
-}
-
-static void dolog(int prio, const char *fmt, va_list ap)
-{
-	if (is_daemon) {
-		la->ops[0].sem_op = -1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop up failed");
-			return;
-		}
-
-		log_enqueue(prio, fmt, ap);
-
-		la->ops[0].sem_op = 1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop down failed");
-			return;
-		}
-	} else {
-		fprintf(stderr, "%s: ", log_name);
-		vfprintf(stderr, fmt, ap);
-		fflush(stderr);
-	}
-}
-
-void log_warning(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_WARNING, fmt, ap);
-	va_end(ap);
-}
-
-void log_error(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_ERR, fmt, ap);
-	va_end(ap);
-}
-
-void log_debug(const char *fmt, ...)
-{
-	if (!is_debug)
-		return;
-
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_DEBUG, fmt, ap);
-	va_end(ap);
-}
-
-static void log_flush(void)
-{
-	while (!la->empty) {
-		la->ops[0].sem_op = -1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop up failed");
-			exit(1);
-		}
-		log_dequeue(la->buff);
-		la->ops[0].sem_op = 1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop down failed");
-			exit(1);
-		}
-		log_syslog(la->buff);
-	}
-}
-
-int log_init(char *program_name, int size, int daemon, int debug)
-{
-	is_daemon = daemon;
-	is_debug = debug;
-
-	logdbg(stderr,"enter log_init\n");
-	log_name = program_name;
-	if (is_daemon) {
-		struct sigaction sa_old;
-		struct sigaction sa_new;
-		pid_t pid;
-
-		openlog(log_name, 0, LOG_DAEMON);
-		setlogmask (LOG_UPTO (LOG_DEBUG));
-
-		if (logarea_init(size)) {
-			syslog(LOG_ERR, "failed to initialize the logger\n");
-			return 1;
-		}
-
-		pid = fork();
-		if (pid < 0) {
-			syslog(LOG_ERR, "fail to fork the logger\n");
-			return 1;
-		} else if (pid) {
-			syslog(LOG_WARNING,
-			       "Target daemon logger with pid=%d started!\n", pid);
-			return 0;
-		}
-
-		/* flush on daemon's crash */
-		sa_new.sa_handler = (void*)log_flush;
-		sigemptyset(&sa_new.sa_mask);
-		sa_new.sa_flags = 0;
-		sigaction(SIGSEGV, &sa_new, &sa_old );
-
-		while(1) {
-			log_flush();
-			sleep(1);
-		}
-		exit(0);
-	}
-
-	return 0;
-}
-
-void log_close (void)
-{
-	if (is_daemon) {
-		closelog();
-		free_logarea();
-	}
-	return;
-}

Deleted: trunk/usr/iscsi/log.h
===================================================================
--- trunk/istgt/usr/log.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/log.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,84 +0,0 @@
-/*
- * iSCSI Safe Logging and Tracing Library
- *
- * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * circular buffer code based on log.c from dm-multipath project
- *
- * heavily based on code from log.c:
- *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
- *   licensed under the terms of the GNU GPL v2.0,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#ifndef LOG_H
-#define LOG_H
-
-#include <sys/sem.h>
-
-union semun {
-	int val;
-	struct semid_ds *buf;
-	unsigned short int *array;
-	struct seminfo *__buf;
-};
-
-#define LOG_SPACE_SIZE 16384
-#define MAX_MSG_SIZE 256
-
-extern int log_daemon;
-extern int log_level;
-
-struct logmsg {
-	short int prio;
-	void *next;
-	char *str;
-};
-
-struct logarea {
-	int empty;
-	void *head;
-	void *tail;
-	void *start;
-	void *end;
-	char *buff;
-	struct sembuf ops[1];
-	int semid;
-	union semun semarg;
-};
-
-struct logarea *la;
-
-extern int log_init (char * progname, int size, int daemon, int debug);
-extern void log_close (void);
-extern void dump_logmsg (void *);
-extern void log_warning(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_error(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_debug(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-
-#define eprintf(fmt, args...)						\
-do {									\
-	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#define dprintf(fmt, args...)						\
-do {									\
-	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#endif	/* LOG_H */

Modified: trunk/usr/iscsi/netlink.c
===================================================================
--- trunk/istgt/usr/netlink.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/netlink.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -41,33 +41,6 @@
 
 static struct sockaddr_nl saddr, daddr;
 
-#if 0
-void async_event(char *data)
-{
-	struct tgt_event *ev = (struct tgt_event *) data;
-	struct iet_msg *msg = (struct iet_msg *) ev->data;
-	struct session *session;
-
-	eprintf("%u %u\n", msg->msg_type, msg->result);
-
-	switch (msg->k.conn_state_change.state) {
-	case E_CONN_CLOSE:
-		if (!(session = session_find_id(msg->k.conn_state_change.tid,
-						msg->k.conn_state_change.sid))) {
-			eprintf("session %#" PRIx64 " not found?",
-				msg->k.conn_state_change.sid);
-		}
-
-		if (!--session->conn_cnt)
-			session_remove(session);
-		break;
-	default:
-		eprintf("%u\n", msg->k.conn_state_change.state);
-		break;
-	}
-}
-#endif
-
 static int __nl_read(int fd, void *data, int size, int flags)
 {
 	struct sockaddr_nl saddr;
@@ -344,7 +317,7 @@
 	return err;
 }
 
-int nl_init(void)
+int iscsi_nl_init(void)
 {
 	int err, rsize = 256 * 1024;
 
@@ -357,6 +330,7 @@
 		eprintf("Fail to create the netlink socket %d\n", errno);
 		return err;
 	}
+	eprintf("create the netlink socket %d\n", nl_fd);
 
 	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
 	if (err) {
@@ -368,17 +342,18 @@
 	saddr.nl_family = AF_NETLINK;
 	saddr.nl_pid = getpid();
 	saddr.nl_groups = 0; /* not in mcast groups */
-	err = bind(nl_fd, (struct sockaddr *) &saddr, sizeof(saddr));
-	if (err) {
-		eprintf("can not bind NETLINK_ISCSI socket %d\n", errno);
-		close(nl_fd);
-		return err;
-	}
+/* 	err = bind(nl_fd, (struct sockaddr *) &saddr, sizeof(saddr)); */
+/* 	if (err) { */
+/* 		eprintf("can not bind NETLINK_ISCSI socket %d\n", errno); */
+/* 		close(nl_fd); */
+/* 		return err; */
+/* 	} */
 
 	memset(&daddr, 0, sizeof(daddr));
 	daddr.nl_family = AF_NETLINK;
 	daddr.nl_pid = 0; /* kernel */
 	daddr.nl_groups = 0; /* unicast */
+	eprintf("create the netlink socket %d %d\n", nl_fd, err);
 
 	return err;
 }

Modified: trunk/usr/iscsi/session.c
===================================================================
--- trunk/istgt/usr/session.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/session.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -16,6 +16,8 @@
 
 #include "iscsid.h"
 
+struct qelem sessions_list = LIST_HEAD_INIT(sessions_list);
+
 static struct session *session_alloc(int tid)
 {
 	struct session *session;
@@ -36,6 +38,18 @@
 	return session;
 }
 
+int iscsi_target_bind(int hostno)
+{
+	struct session *session;
+
+	list_for_each_entry(session, &sessions_list, hlist) {
+		if (session->hostno == hostno)
+			return session->target->tid;
+	}
+
+	return -ENOENT;
+}
+
 struct session *session_find_name(int tid, const char *iname, uint8_t *isid)
 {
 	struct session *session;
@@ -101,7 +115,7 @@
 	ki->create_session(thandle, conn->exp_cmd_sn, &session->ksid,
 			   &session->hostno);
 
-	target_bind(session->target->tid, session->hostno);
+	insque(&session->hlist, &sessions_list);
 }
 
 void session_remove(struct session *session)
@@ -121,6 +135,8 @@
 /* 		session->target->nr_sessions--; */
 	}
 
+	remque(&session->hlist);
+
 	free(session->initiator);
 	free(session);
 }

Modified: trunk/usr/iscsi/target.c
===================================================================
--- trunk/istgt/usr/target.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/iscsi/target.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -18,7 +18,6 @@
 
 #include "iscsid.h"
 #include "tgtadm.h"
-#include "tgt_sysfs.h"
 
 struct qelem targets_list = LIST_HEAD_INIT(targets_list);
 
@@ -63,7 +62,7 @@
 	return NULL;
 }
 
-static int destroy_target(int tid)
+int iscsi_target_destroy(int tid)
 {
 	struct target* target;
 
@@ -85,7 +84,7 @@
 	return 0;
 }
 
-static int create_target(int tid, char *name)
+int iscsi_target_create(int tid, char *name)
 {
 	struct target *target;
 
@@ -107,223 +106,3 @@
 
 	return 0;
 }
-
-static int istgt_target_mgmt(struct tgtadm_req *req, char *params)
-{
-	int err = -EINVAL, tid = req->tid;
-
-	switch (req->op) {
-	case OP_NEW:
-		err = create_target(tid, params);
-		break;
-	case OP_DELETE:
-		err = destroy_target(tid);
-		break;
-	default:
-		break;
-	}
-
-	return err;
-}
-
-static int ipc_accept(int afd)
-{
-	struct sockaddr addr;
-	socklen_t len;
-
-	len = sizeof(addr);
-	return accept(afd, (struct sockaddr *) &addr, &len);
-}
-
-static int ipc_perm(int fd)
-{
-	struct ucred cred;
-	socklen_t len;
-	int err;
-
-	len = sizeof(cred);
-	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
-	if (err < 0)
-		goto out;
-
-	if (cred.uid || cred.gid) {
-		err = -EPERM;
-		goto out;
-	}
-out:
-	return err;
-}
-
-void ipc_event(void)
-{
-	int fd, err;
-	char sbuf[4096], rbuf[4096];
-	struct nlmsghdr *nlh;
-	struct iovec iov;
-	struct msghdr msg;
-	struct tgtadm_req *req;
-
-	dprintf("ipc\n");
-
-	fd = ipc_accept(ipc_fd);
-	if (fd < 0) {
-		eprintf("%d\n", fd);
-		return;
-	}
-
-	err = ipc_perm(fd);
-	if (err < 0)
-		goto fail;
-
-	memset(sbuf, 0, sizeof(sbuf));
-	memset(rbuf, 0, sizeof(rbuf));
-
-	nlh = (struct nlmsghdr *) sbuf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_PEEK);
-	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
-		err = -EIO;
-		goto fail;
-	}
-
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err < 0)
-		goto fail;
-
-	req = NLMSG_DATA(nlh);
-	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
-
-	if (req->mode == MODE_TARGET)
-		err = istgt_target_mgmt(req, (char *) req + sizeof(*req));
-
-fail:
-	if (fd > 0)
-		close(fd);
-
-	return;
-}
-
-/* should be moved somewhere */
-int ipc_init(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, ISTGT_NAMESPACE,
-	       strlen(ISTGT_NAMESPACE));
-
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		return err;
-
-	if ((err = listen(fd, 32)) < 0)
-		return err;
-
-	ipc_fd = fd;
-
-	return 0;
-}
-
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static int lldname_to_id(char *name)
-{
-	struct dirent **namelist;
-	int i, nr, id = -EINVAL;
-	char *p;
-
-	nr = scandir(TGT_LLD_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -EINVAL;
-
-	for (i = 0; i < nr; i++) {
-		p = strchr(namelist[i]->d_name, '-');
-		if (p && !strcmp(name, p + 1)) {
-			*p='\0';
-			id = atoi(namelist[i]->d_name);
-			break;
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return id;
-}
-
-static int ipc_mgmt_connect(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE, strlen(TGT_IPC_NAMESPACE));
-
-	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0)
-		return err;
-
-	return fd;
-}
-
-int target_bind(int tid, int hostno)
-{
-	struct tgtadm_req *req;
-	struct nlmsghdr *nlh;
-	char buf[1024];
-	int fd, err;
-
-	nlh = (struct nlmsghdr *) buf;
-	req = NLMSG_DATA(nlh);
-
-	req->mode = MODE_TARGET;
-	req->op = OP_BIND;
-	req->tid = tid;
-	req->host_no = hostno;
-	req->typeid = lldname_to_id("istgt");
-
-	nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*req));
-	nlh->nlmsg_type = 0;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
-
-	fd = ipc_mgmt_connect();
-	if (fd < 0) {
-		eprintf("Cannot connect tgtd\n");
-		return fd;
-	}
-
-	err = write(fd, buf, nlh->nlmsg_len);
-	if (err < 0)
-		eprintf("Cannot send to tgtd %d\n", err);
-
-	err = read(fd, buf, sizeof(buf));
-
-	close(fd);
-	return 0;
-}

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/mgmt.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -40,6 +40,7 @@
 #include "tgtd.h"
 #include "log.h"
 #include "tgtadm.h"
+#include "driver.h"
 
 static void device_create_parser(char *args, char **path, char **devtype)
 {
@@ -65,7 +66,7 @@
 	}
 }
 
-static int target_mgmt(struct tgtadm_req *req, char *params,
+static int target_mgmt(int lld_no, struct tgtadm_req *req, char *params,
 		       char *rbuf, int *rlen)
 {
 	int err = -EINVAL;
@@ -73,12 +74,16 @@
 	switch (req->op) {
 	case OP_NEW:
 		err = tgt_target_create(req->tid);
+		if (!err)
+			tgt_drivers[lld_no]->target_create(req->tid, params);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);
+		if (!err)
+			tgt_drivers[lld_no]->target_destroy(req->tid);
 		break;
 	case OP_BIND:
-		err = tgt_target_bind(req->tid, req->host_no, req->typeid);
+		err = tgt_target_bind(req->tid, req->host_no, lld_no);
 		break;
 	default:
 		break;
@@ -87,7 +92,7 @@
 	return err;
 }
 
-static int device_mgmt(struct tgtadm_req *req, char *params,
+static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
 		       char *rbuf, int *rlen)
 {
 	int err = -EINVAL;
@@ -112,7 +117,7 @@
 	return err;
 }
 
-int tgt_mgmt(char *sbuf, char *rbuf)
+int tgt_mgmt(int lld_no, char *sbuf, char *rbuf)
 {
 	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
 	struct tgtadm_req *req;
@@ -124,15 +129,15 @@
 	params = (char *) req + sizeof(*req);
 
 	dprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
-		nlh->nlmsg_len,	req->typeid, req->mode, req->op,
+		nlh->nlmsg_len, lld_no, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
 
 	switch (req->mode) {
 	case MODE_TARGET:
-		err = target_mgmt(req, params, rbuf, &rlen);
+		err = target_mgmt(lld_no, req, params, rbuf, &rlen);
 		break;
 	case MODE_DEVICE:
-		err = device_mgmt(req, params, rbuf, &rlen);
+		err = device_mgmt(lld_no, req, params, rbuf, &rlen);
 		break;
 	default:
 		break;
@@ -174,7 +179,7 @@
 	return err;
 }
 
-void ipc_event_handle(struct driver_info *dinfo, int accept_fd)
+void ipc_event_handle(int accept_fd)
 {
 	int fd, err;
 	char sbuf[4096], rbuf[4096];
@@ -183,7 +188,7 @@
 	struct msghdr msg;
 	struct tgtadm_res *res;
 	struct tgtadm_req *req;
-	int (*fn) (char *, char *);
+	int lld_no;
 
 	fd = ipc_accept(accept_fd);
 	if (fd < 0) {
@@ -222,16 +227,17 @@
 		goto fail;
 
 	req = NLMSG_DATA(nlh);
-	dprintf("%d %d %d %d %d\n", req->mode, req->typeid, err, nlh->nlmsg_len, fd);
+	dprintf("%d %s %d %d %d\n", req->mode, req->lld, err, nlh->nlmsg_len, fd);
+	lld_no = get_driver_index(req->lld);
+	if (lld_no < 0) {
+		err = -ENOENT;
+		goto fail;
+	}
 
-	err = tgt_mgmt((char *) nlh, rbuf);
+	err = tgt_mgmt(lld_no, (char *) nlh, rbuf);
 	if (err)
 		eprintf("%d %d %d %d %d\n",
-			req->mode, req->typeid, err, nlh->nlmsg_len, fd);
-	fn = dl_fn(dinfo, req->typeid, DL_FN_IPC_MGMT);
-	if (fn)
-		err = fn((char *) nlh, rbuf);
-
+			req->mode, lld_no, err, nlh->nlmsg_len, fd);
 send:
 	err = write(fd, nlh, nlh->nlmsg_len);
 	if (err < 0)

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/scsi.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -24,8 +24,10 @@
 #include <scsi/scsi.h>
 #include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
+#include <poll.h>
 
 #include "tgtd.h"
+#include "driver.h"
 
 #define BLK_SHIFT	9
 
@@ -255,7 +257,8 @@
 		   uint8_t *lun_buf, uint8_t *scb, uint8_t *data, int *len)
 {
 	typeof(__inquiry) *fn;
-	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_INQUIRY) ? : __inquiry;
+
+	fn = tgt_drivers[lid]->scsi_inquiry ? : __inquiry;
 	return fn(dev, host_no, lun_buf, scb, data, len);
 }
 
@@ -308,7 +311,7 @@
 		       uint8_t *scb, uint8_t *p, int *len)
 {
 	typeof(__report_luns) *fn;
-	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_REPORT_LUNS) ? : __report_luns;
+	fn = tgt_drivers[lid]->scsi_report_luns ? : __report_luns;
 	return fn(dev_list, lun_buf, scb, p, len);
 }
 
@@ -478,7 +481,7 @@
 uint64_t scsi_get_devid(int lid, uint8_t *p)
 {
 	typeof(__scsi_get_devid) *fn;
-	fn = dl_fn(dlinfo, lid, DL_FN_SCSI_LUN_TO_INT) ? : __scsi_get_devid;
+	fn = tgt_drivers[lid]->scsi_get_lun ? : __scsi_get_devid;
 	return fn(p);
 }
 

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/target.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -26,6 +26,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <poll.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
 #include <sys/socket.h>
@@ -39,7 +40,7 @@
 
 #include "tgtd.h"
 #include "tgtadm.h"
-#include "tgt_sysfs.h"
+#include "driver.h"
 
 /* better if we can include the followings in kernel header files. */
 #define	MSG_SIMPLE_TAG	0x20
@@ -251,10 +252,6 @@
 		return err;
 	}
 
-	err = tgt_device_dir_create(tid, dev_id);
-	if (err < 0)
-		goto close_dev_fd;
-
 	if (dev_id >= target->max_device)
 		resize_device_table(target, dev_id);
 
@@ -312,8 +309,6 @@
 
 	close(device->fd);
 
-	tgt_device_dir_delete(tid, dev_id);
-
 	list_del(&device->dlist);
 
 	free(device);
@@ -393,12 +388,25 @@
 	uint64_t offset, dev_id;
 	uint8_t rw = 0, mmapped = 0;
 	unsigned long uaddr = 0;
+	int hostno = ev_req->k.cmd_req.host_no;
 
-	target = host_to_target(ev_req->k.cmd_req.host_no);
+	target = host_to_target(hostno);
 	if (!target) {
-		eprintf("%d is not bind to any target\n",
-			ev_req->k.cmd_req.host_no);
-		return;
+		int tid, lid = 0, err = -1;
+		if (tgt_drivers[lid]->target_bind) {
+			tid = tgt_drivers[0]->target_bind(hostno);
+			if (tid >= 0) {
+				err = tgt_target_bind(tid, hostno, lid);
+				if (!err)
+					target = host_to_target(hostno);
+			}
+		}
+
+		if (!target) {
+			eprintf("%d is not bind to any target\n",
+				ev_req->k.cmd_req.host_no);
+			return;
+		}
 	}
 
 	/* TODO: preallocate cmd */
@@ -743,8 +751,6 @@
 
 int tgt_target_bind(int tid, int host_no, int lid)
 {
-	int err;
-
 	if (!tgtt[tid]) {
 		eprintf("target is not found %d\n", tid);
 		return -EINVAL;
@@ -756,10 +762,6 @@
 		return -EINVAL;
 	}
 
-	err = tgt_target_dir_attr_create(tid, "hostno", "%d\n", host_no);
-	if (err < 0)
-		return -EINVAL;
-
 	eprintf("Succeed to bind the target %d to the scsi host %d\n",
 		tid, host_no);
 	hostt[host_no] = tgtt[tid];
@@ -802,18 +804,12 @@
 	}
 	target->max_device = DEFAULT_NR_DEVICE;
 
-	err = tgt_target_dir_create(tid);
-	if (err < 0)
-		goto free_device_table;
-
 	tgt_cmd_queue_init(&target->cmd_queue);
 
 	eprintf("Succeed to create a new target %d\n", tid);
 	tgtt[tid] = target;
 	return 0;
 
-free_device_table:
-	free(target->devt);
 free_target:
 	free(target);
 	return err;
@@ -836,9 +832,6 @@
 
 	free(target->devt);
 
-	tgt_target_dir_attr_delete(tid, "hostno");
-	tgt_target_dir_delete(tid);
-
 	tgtt[tid] = NULL;
 	free(target);
 

Deleted: trunk/usr/tgt_sysfs.c
===================================================================
--- trunk/usr/tgt_sysfs.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgt_sysfs.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,167 +0,0 @@
-/*
- * SCSI file and directory handling functions
- *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of the
- * License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <linux/limits.h>
-
-#include "tgt_sysfs.h"
-#include "tgtd.h"
-
-enum tgt_fs_op {
-	CREATE = 0,
-	DELETE,
-};
-
-static int tgt_set_string(char *buf, int size, const char *fmt, va_list ap)
-{
-	int err;
-
-	err = vsnprintf(buf, size, fmt, ap);
-	if (err > size)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int tgt_dir(int op, const char *fmt, ...)
-{
-	int err;
-	char path[PATH_MAX];
-
-	va_list ap;
-	va_start(ap, fmt);
-
-	err = tgt_set_string(path, sizeof(path), fmt, ap);
-	if (err)
-		goto out;
-
-	if (op)
-		err = unlink(path);
-	else
-		err = mkdir(path, DEFDMODE);
-
-	if (err < 0)
-		eprintf("fail to create %s %s\n",
-			op ? "delete" : "create", path);
-out:
-	va_end(ap);
-	return err;
-}
-
-static int tgt_file(int op, const char *fmt, ...)
-{
-	int err;
-	char path[PATH_MAX];
-
-	va_list ap;
-	va_start(ap, fmt);
-
-	err = tgt_set_string(path, sizeof(path), fmt, ap);
-	if (err)
-		goto out;
-
-	if (op)
-		err = unlink(path);
-	else
-		err = open(path, O_RDWR|O_CREAT|O_EXCL, DEFFMODE);
-
-	if (err < 0)
-		eprintf("fail to %s %s\n", op ? "delete" : "create", path);
-out:
-	va_end(ap);
-	return err;
-}
-
-int tgt_target_dir_create(int tid)
-{
-	return tgt_dir(CREATE, TGT_TARGET_SYSFSDIR "/target%d", tid);
-}
-
-int tgt_target_dir_delete(int tid)
-{
-	return tgt_dir(DELETE, TGT_TARGET_SYSFSDIR "/target%d", tid);
-}
-
-int tgt_device_dir_create(int tid, uint64_t dev_id)
-{
-	return tgt_dir(CREATE, TGT_TARGET_SYSFSDIR
-		       "/target%d/device%" PRIu64, tid, dev_id);
-}
-
-int tgt_device_dir_delete(int tid, uint64_t dev_id)
-{
-	return tgt_dir(DELETE, TGT_TARGET_SYSFSDIR
-		       "/target%d/device%" PRIu64, tid, dev_id);
-}
-
-int tgt_sysfs_init(void)
-{
-	int err;
-
-	system("rm -rf " TGT_TARGET_SYSFSDIR);
-
-	err = mkdir(TGT_TARGET_SYSFSDIR, DEFDMODE);
-	if (err < 0)
-		perror("Cannot create " TGT_TARGET_SYSFSDIR);
-
-	return err;
-}
-
-int tgt_target_dir_attr_create(int tid, const char *name, const char *fmt, ...)
-{
-	int err, fd = 0;
-	char buf[PATH_MAX];
-	va_list ap;
-
-	va_start(ap, fmt);
-
-	err = tgt_set_string(buf, sizeof(buf), fmt, ap);
-	if (err)
-		goto out;
-
-	fd = tgt_file(CREATE, TGT_TARGET_SYSFSDIR "/target%d/%s", tid, name);
-	if (fd < 0) {
-		err = -errno;
-		goto out;
-	}
-	err = write(fd, buf, strlen(buf));
-	if (err < 0)
-		eprintf("fail to write %s\n", buf);
-out:
-	if (fd > 0)
-		close(fd);
-	va_end(ap);
-	return err;
-}
-
-int tgt_target_dir_attr_delete(int tid, char *name)
-{
-	return tgt_file(DELETE, TGT_TARGET_SYSFSDIR "/target%d/%s", tid, name);
-}

Deleted: trunk/usr/tgt_sysfs.h
===================================================================
--- trunk/usr/tgt_sysfs.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgt_sysfs.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,19 +0,0 @@
-#include <stdint.h>
-
-#ifndef	__TGT_SYSFS_H
-#define	__TGT_SYSFS_H
-
-#define	TGT_LLD_SYSFSDIR	"/var/run/tgt_lld"
-#define	TGT_TARGET_SYSFSDIR	"/var/run/tgt_target"
-
-
-extern int tgt_target_dir_create(int tid);
-extern int tgt_target_dir_delete(int tid);
-
-extern int tgt_device_dir_create(int tid, uint64_t dev_id);
-extern int tgt_device_dir_delete(int tid, uint64_t dev_id);
-
-extern int tgt_target_dir_attr_create(int tid, const char *name, const char *fmt, ...);
-extern int tgt_target_dir_attr_delete(int tid, char *name);
-
-#endif

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgtadm.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -38,18 +38,22 @@
 #include <linux/types.h>
 #include <linux/netlink.h>
 
+#include "tgtd.h"
 #include "tgtadm.h"
-#include "tgt_sysfs.h"
+#include "driver.h"
 
+#undef eprintf
 #define eprintf(fmt, args...)						\
 do {									\
 	fprintf(stderr, "%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
 } while (0)
 
+#undef dprintf
 #define dprintf eprintf
 
+#define BUFSIZE 4096
+
 static char program_name[] = "tgtadm";
-static char *driver;
 
 static struct option const long_options[] =
 {
@@ -62,7 +66,6 @@
 	{"params", required_argument, NULL, 'p'},
 	{"user", no_argument, NULL, 'u'},
 	{"hostno", required_argument, NULL, 'i'},
-	{"bus", required_argument, NULL, 'b'},
 	{"version", no_argument, NULL, 'v'},
 	{"help", no_argument, NULL, 'h'},
 	{NULL, 0, NULL, 0},
@@ -119,119 +122,6 @@
 	exit(status == 0 ? 0 : -1);
 }
 
-static int filter(const struct dirent *dir)
-{
-	return strcmp(dir->d_name, ".") && strcmp(dir->d_name, "..");
-}
-
-static void all_devices_destroy(int tid)
-{
-	struct dirent **namelist;
-	char path[PATH_MAX], key[] = "device";
-	int i, nr, err;
-	uint64_t dev_id;
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d", tid);
-	nr = scandir(path, &namelist, filter, alphasort);
-	if (!nr)
-		return;
-
-	for (i = 0; i < nr; i++) {
-		if (strncmp(namelist[i]->d_name, key, strlen(key)))
-			continue;
-		dev_id = strtoull(namelist[i]->d_name + strlen(key), NULL, 10);
-		snprintf(path, sizeof(path),
-			 "./usr/tgtadm --driver %s --op delete --tid %d --lun %"
-			 PRIu64, driver, tid, dev_id);
-		err = system(path);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-}
-
-static int tid_to_hostno(int tid)
-{
-	int fd, hostno, err;
-	char path[PATH_MAX], buf[32];
-
-	snprintf(path, sizeof(path), TGT_TARGET_SYSFSDIR "/target%d/hostno", tid);
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		eprintf("Cannot open %s\n", path);
-		return -EINVAL;
-	}
-	err = read(fd, buf, sizeof(buf));
-	close(fd);
-	if (err < 0) {
-		eprintf("Cannot read\n");
-		return -EINVAL;
-	}
-
-	sscanf(buf, "%d\n", &hostno);
-
-	return hostno;
-}
-
-static int hostno_to_name(int hostno, char *buf, int len)
-{
-	int fd, err;
-	char path[PATH_MAX];
-
-	snprintf(path, sizeof(path), "/sys/class/scsi_host/host%d/proc_name",
-		 hostno);
-
-	fd = open(path, O_RDONLY);
-	if (fd < 0) {
-		eprintf("Cannot open %s\n", path);
-		return -EINVAL;
-	}
-	err = read(fd, buf, len);
-	close(fd);
-
-	return strlen(buf);
-}
-
-static int system_mgmt(struct tgtadm_req *req, char *lld)
-{
-	int err = -EINVAL, i, nr, hostno;
-	struct dirent **namelist;
-	char cmd[PATH_MAX], buf[64], *p;
-
-	if (req->op != OP_DELETE)
-		return err;
-
-	nr = scandir(TGT_TARGET_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		int tid;
-		for (p = namelist[i]->d_name; !isdigit((int) *p); p++)
-			;
-		tid = atoi(p);
-		hostno = tid_to_hostno(tid);
-		if (hostno < 0)
-			continue;
-		hostno_to_name(hostno, buf, sizeof(buf));
-		if (strcmp(buf, lld))
-			continue;
-
-		all_devices_destroy(tid);
-		snprintf(cmd, sizeof(cmd),
-			 "./usr/tgtadm --driver %s --op delete --tid %d",
-			 lld, tid);
-		err = system(cmd);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return 0;
-}
-
 static int ipc_mgmt_connect(void)
 {
 	int fd, err;
@@ -350,109 +240,23 @@
 	return op;
 }
 
-static int lldname_to_id(char *name)
-{
-	struct dirent **namelist;
-	int i, nr, id = -EINVAL;
-	char *p;
-
-	nr = scandir(TGT_LLD_SYSFSDIR, &namelist, filter, alphasort);
-	if (!nr)
-		return -EINVAL;
-
-	for (i = 0; i < nr; i++) {
-		p = strchr(namelist[i]->d_name, '-');
-		if (p && !strcmp(name, p + 1)) {
-			*p='\0';
-			id = atoi(namelist[i]->d_name);
-			break;
-		}
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return id;
-}
-
-static int bus_to_host(char *bus)
-{
-	int i, nr, host = -1;
-	char path[PATH_MAX], *p;
-	char key[] = "host";
-	struct dirent **namelist;
-
-	p = strchr(bus, ',');
-	if (!p)
-		return -EINVAL;
-	*(p++) = '\0';
-
-	snprintf(path, sizeof(path), "/sys/bus/%s/devices/%s", bus, p);
-	nr = scandir(path, &namelist, filter, alphasort);
-	if (!nr)
-		return -ENOENT;
-
-	for (i = 0; i < nr; i++) {
-		if (strncmp(namelist[i]->d_name, key, strlen(key)))
-			continue;
-		p = namelist[i]->d_name + strlen(key);
-		host = strtoull(p, NULL, 10);
-	}
-
-	for (i = 0; i < nr; i++)
-		free(namelist[i]);
-	free(namelist);
-
-	return host;
-}
-
-static int lld_id_get(int argc, char **argv)
-{
-	int ch, longindex, id = -EINVAL;
-	char *name = NULL;
-
-	while ((ch = getopt_long(argc, argv, "n:", long_options,
-				 &longindex)) >= 0) {
-		switch (ch) {
-		case 'n':
-			name = optarg;
-			break;
-		}
-	}
-
-	if (name)
-		id = lldname_to_id(name);
-
-	if (id < 0) {
-		eprintf("You must specify the driver name\n");
-		exit(-1);
-	}
-
-	return id;
-}
-
 int main(int argc, char **argv)
 {
 	int ch, longindex;
 	int err = -EINVAL, op = -1, len;
 	int tid = -1;
-	uint32_t cid = 0, set = 0, hostno = 0, lld_id;
+	uint32_t cid = 0, set = 0, hostno = 0;
 	uint64_t sid = 0, lun = 0;
-	char *params = NULL, *lld_name = NULL;
+	char *params = NULL, *lldname = NULL;
 	struct tgtadm_req *req;
-	char sbuf[8192], rbuf[8912];
+	char sbuf[BUFSIZE], rbuf[BUFSIZE];
 
-	lld_id = lld_id_get(argc, argv);
-	if (lld_id < 0)
-		goto out;
-
 	optind = 1;
-	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:b:p:uvh",
+	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvh",
 				 long_options, &longindex)) >= 0) {
 		switch (ch) {
 		case 'n':
-			lld_name = optarg;
+			lldname = optarg;
 			break;
 		case 'o':
 			op = str_to_op(optarg);
@@ -477,7 +281,6 @@
 			hostno = strtol(optarg, NULL, 10);
 			break;
 		case 'b':
-			hostno = bus_to_host(optarg);
 			break;
 		case 'p':
 			params = optarg;
@@ -513,7 +316,7 @@
 	memset(rbuf, 0, sizeof(rbuf));
 
 	req = (struct tgtadm_req *) sbuf;
-	req->typeid = lld_id;
+	strncpy(req->lld, lldname, sizeof(req->lld));
 	req->mode = set_to_mode(set);
 	req->op = op;
 	req->tid = tid;
@@ -527,12 +330,8 @@
 		len += strlen(params);
 	}
 
-	if (req->mode == MODE_SYSTEM)
-		err = system_mgmt(req, lld_name);
-	else {
-		err = ipc_mgmt_call(sbuf, len, rbuf);
-		ipc_mgmt_result(rbuf);
-	}
+	err = ipc_mgmt_call(sbuf, len, rbuf);
+	ipc_mgmt_result(rbuf);
 out:
 	return err;
 }

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgtadm.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -1,7 +1,8 @@
 #ifndef TGTADM_H
 #define TGTADM_H
 
-#define TGT_IPC_NAMESPACE "TGT_IPC_ABSTRACT_NAMESPACE"
+#define TGT_IPC_NAMESPACE	"TGT_IPC_ABSTRACT_NAMESPACE"
+#define TGT_LLD_NAME_LEN	64
 
 enum tgtadm_op {
 	OP_NEW,
@@ -28,7 +29,7 @@
 	uint64_t sid;
 	int cid;
 	uint64_t lun;
-	int typeid;
+	char lld[TGT_LLD_NAME_LEN];
 	int host_no;
 	unsigned long addr;
 };
@@ -38,6 +39,4 @@
 	unsigned long addr;
 };
 
-extern int tgt_mgmt(char *sbuf, char *rbuf);
-
 #endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgtd.c	2006-07-12 17:13:53 UTC (rev 502)
@@ -36,16 +36,19 @@
 #include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
+#include "driver.h"
 
-extern int tgt_sysfs_init(void);
-
 enum {
 	POLL_NL, /* netlink socket between kernel and user space */
 	POLL_UD, /* unix domain socket for tgtdadm */
+	POLL_END,
 };
 
+static char program_name[] = "tgtd";
+
 static struct option const long_options[] =
 {
+	{"drivers", required_argument, 0, 'p'},
 	{"foreground", no_argument, 0, 'f'},
 	{"debug", required_argument, 0, 'd'},
 	{"version", no_argument, 0, 'v'},
@@ -53,8 +56,6 @@
 	{0, 0, 0, 0},
 };
 
-static char program_name[] = "tgtd";
-
 static int daemon_init(void)
 {
 	pid_t pid;
@@ -123,79 +124,124 @@
 	close(fd);
 }
 
-/* TODO: rewrite makeshift poll code */
-
-static void event_loop(struct driver_info *dlinfo, struct pollfd *pfd, int nr_dls)
+static void event_loop(struct pollfd *pfd, int npfd, int timeout)
 {
-	int err, i, poll_max = (nr_dls + 1) * POLLS_PER_DRV;
-	void (* fn)(struct pollfd *, int);
+	int nevent, i;
+	struct tgt_driver *d;
 
-	while (1) {
-		if ((err = poll(pfd, poll_max, -1)) < 0) {
-			if (errno != EINTR) {
-				eprintf("%d %d\n", err, errno);
-				exit(1);
-			}
-			continue;
+retry:
+	/*
+	 * TODO: replace something efficient than poll.
+	 */
+	nevent = poll(pfd, npfd, timeout);
+	if (nevent < 0) {
+		if (errno != EINTR) {
+			eprintf("%s\n", strerror(errno));
+			exit(1);
 		}
+		goto retry;
+	} else if (nevent == 0) {
+		/*
+		 * TODO: need kinda scheduling stuff like open-iscsi here.
+		 */
+		goto retry;
+	}
 
-		if (pfd[POLL_NL].revents) {
-			nl_event_handle(pfd[POLL_NL].fd);
-			err--;
-		}
+	if (pfd[POLL_NL].revents) {
+		dprintf("nl event\n");
+		nl_event_handle(pfd[POLL_NL].fd);
+		nevent--;
+	}
 
-		if (pfd[POLL_UD].revents) {
-			ipc_event_handle(dlinfo, pfd[POLL_UD].fd);
-			err--;
-		}
+	if (pfd[POLL_UD].revents) {
+		dprintf("ipc event\n");
+		ipc_event_handle(pfd[POLL_UD].fd);
+		nevent--;
+	}
 
-		if (!err)
-			continue;
+	if (!nevent)
+		goto retry;
 
-		for (i = 0; i < nr_dls; i++) {
-			fn = dl_fn(dlinfo, i, DL_FN_POLL_EVENT);
-			if (fn)
-				fn(pfd + ((i + 1) * POLLS_PER_DRV), POLLS_PER_DRV);
-		}
+	for (i = 0; tgt_drivers[i]; i++) {
+		dprintf("lld event\n");
+		d = tgt_drivers[i];
+		d->event_handle(pfd + d->pfd_index);
 	}
+
+	goto retry;
 }
 
-static struct pollfd * poll_init(int nr, int nl_fd, int ud_fd)
+static struct pollfd *poll_init(int npfd, int nl_fd, int ud_fd)
 {
+	struct tgt_driver *d;
 	struct pollfd *pfd;
-	void (* fn)(struct pollfd *, int);
-	int i;
+	int i, idx = POLL_END;
 
-	pfd = calloc((nr + 1) * POLLS_PER_DRV, sizeof(struct pollfd));
-	if (!pfd) {
-		eprintf("Out of memory\n");
-		exit(1);
-	}
+	pfd = calloc(npfd, sizeof(struct pollfd));
+	if (!pfd)
+		return NULL;
 
 	pfd[POLL_NL].fd = nl_fd;
 	pfd[POLL_NL].events = POLLIN;
 	pfd[POLL_UD].fd = ud_fd;
 	pfd[POLL_UD].events = POLLIN;
 
-	for (i = 0; i < nr; i++) {
-		fn = dl_fn(dlinfo, i, DL_FN_POLL_INIT);
-		if (fn)
-			fn(pfd + (i + 1) * POLLS_PER_DRV, POLLS_PER_DRV);
+	for (i = 0; tgt_drivers[i]; i++) {
+		d = tgt_drivers[i];
+		if (d->enable && d->npfd) {
+			d->pfd_index = idx;
+			d->poll_init(pfd + idx);
+			idx += d->npfd;
+		}
 	}
 
 	return pfd;
 }
 
+static int enable_drivers(char *data, int *npfd)
+{
+	char *list, *p;
+	int index, err, np, ndriver = 0;
+
+	list = strdup(data);
+	if (!list)
+		return 0;
+
+	p = strtok(list, ",");
+	while (p) {
+		index = get_driver_index(p);
+		if (index >= 0) {
+			np = 0;
+			if (tgt_drivers[index]->init) {
+				err = tgt_drivers[index]->init(&np);
+				if (err)
+					continue;
+			}
+			tgt_drivers[index]->enable = 1;
+			tgt_drivers[index]->npfd = np;
+			ndriver++;
+			*npfd += np;
+		}
+		p = strtok(NULL, ",");
+	}
+	free(list);
+
+	return ndriver;
+}
+
 int main(int argc, char **argv)
 {
 	struct pollfd *pfd;
-	int ch, longindex, nr;
+	int err, ch, longindex, ndriver = 0, npfd = POLL_END;
 	int is_daemon = 1, is_debug = 1;
-	int nl_fd, ud_fd;
+	int nl_fd, ud_fd, timeout = -1;
 
-	while ((ch = getopt_long(argc, argv, "fd:vh", long_options,
+	while ((ch = getopt_long(argc, argv, "s:d:fd:vh", long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
+		case 'p':
+			ndriver = enable_drivers(optarg, &npfd);
+			break;
 		case 'f':
 			is_daemon = 0;
 			break;
@@ -214,17 +260,20 @@
 		}
 	}
 
+	if (!ndriver) {
+		printf("No driver!\n");
+		exit(1);
+	}
+
 	if (is_daemon && daemon_init())
 		exit(1);
 
 	tgtd_init();
 
-	if (log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug))
+	err = log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug);
+	if (err)
 		exit(1);
 
-	if (tgt_sysfs_init())
-		exit(1);
-
 	nl_fd = nl_init();
 	if (nl_fd < 0)
 		exit(1);
@@ -233,13 +282,9 @@
 	if (ud_fd < 0)
 		exit(1);
 
-	nr = dl_init(dlinfo);
-	if (nr < 0)
-		exit(1);
+	pfd = poll_init(npfd, nl_fd, ud_fd);
 
-	pfd = poll_init(nr, nl_fd, ud_fd);
+	event_loop(pfd, npfd, timeout);
 
-	event_loop(dlinfo, pfd, nr);
-
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-07-09 06:56:41 UTC (rev 501)
+++ trunk/usr/tgtd.h	2006-07-12 17:13:53 UTC (rev 502)
@@ -2,7 +2,6 @@
 #define __TARGET_DAEMON_H
 
 #include "log.h"
-#include "dl.h"
 #include "util.h"
 
 #define	SCSI_ID_LEN	24
@@ -24,18 +23,14 @@
 	struct tgt_cmd_queue cmd_queue;
 };
 
-/* makeshift */
-#define	POLLS_PER_DRV	32
-
 extern int nl_init(void);
 extern int __nl_write(int fd, int type, char *data, int len);
 extern int __nl_read(int fd, void *data, int size, int flags);
 void nl_event_handle(int nl_fd);
 
 extern int ipc_open(void);
-extern void ipc_event_handle(struct driver_info *, int fd);
+extern void ipc_event_handle(int accept_fd);
 
-extern int tgt_device_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_target_create(int tid);



From tomo at berlios.de  Wed Jul 12 19:25:23 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 12 Jul 2006 19:25:23 +0200
Subject: [Stgt-svn] r503 - in trunk: ibmvstgt usr
Message-ID: <200607121725.k6CHPNFC014046@sheep.berlios.de>

Author: tomo
Date: 2006-07-12 19:25:03 +0200 (Wed, 12 Jul 2006)
New Revision: 503

Added:
   trunk/usr/ibmvio/
Removed:
   trunk/ibmvstgt/usr/
Log:
Just move ibmvstgt user-space code.

Copied: trunk/usr/ibmvio (from rev 502, trunk/ibmvstgt/usr)



From tomo at mail.berlios.de  Thu Jul 13 12:27:53 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 13 Jul 2006 12:27:53 +0200
Subject: [Stgt-svn] r504 - in trunk: . ibmvstgt usr usr/ibmvio usr/iscsi
Message-ID: <200607131027.k6DARrkO004171@sheep.berlios.de>

Author: tomo
Date: 2006-07-13 12:27:53 +0200 (Thu, 13 Jul 2006)
New Revision: 504

Added:
   trunk/usr/ibmvio/ibmvio.c
   trunk/usr/ibmvio/ibmvio.h
Removed:
   trunk/usr/ibmvio/libibmvstgt.c
Modified:
   trunk/Makefile
   trunk/ibmvstgt/Makefile
   trunk/usr/Makefile
   trunk/usr/driver.c
   trunk/usr/driver.h
   trunk/usr/iscsi/iscsi.h
Log:
ibmvstgt is back.

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/Makefile	2006-07-13 10:27:53 UTC (rev 504)
@@ -1,9 +1,16 @@
-#KERNELSRC := /usr/src/linux
+#
+# Need to use some magic to select what target drivers will be complied
+#
 
+IBMVIO=1
+ISCSI=1
+
 ifeq ($(KERNELSRC),)
 	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
 endif
 
+export IBMVIO
+export ISCSI
 export KERNELSRC
 
 all:

Modified: trunk/ibmvstgt/Makefile
===================================================================
--- trunk/ibmvstgt/Makefile	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/ibmvstgt/Makefile	2006-07-13 10:27:53 UTC (rev 504)
@@ -1,17 +1,7 @@
 SUBDIRS := $(shell pwd)
 
-ifeq ($(KERNELSRC),)
-	KERNELSRC ?= /lib/modules/$(shell uname -r)/build
-endif
-
-all: mods libs
-
 mods:
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel modules
 
-libs:
-	$(MAKE) -C usr
-
 clean:
-	$(MAKE) -C usr clean
 	$(MAKE) -C $(KERNELSRC) SUBDIRS=$(shell pwd)/kernel clean

Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/Makefile	2006-07-13 10:27:53 UTC (rev 504)
@@ -1,8 +1,17 @@
-CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE -DISCSI
+CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
 TGTD_OBJS = tgtd.o netlink.o mgmt.o target.o scsi.o log.o driver.o
+
+ifneq ($(IBMVIO),)
+CFLAGS += -DIBMVIO
+TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
+endif
+
+ifneq ($(ISCSI),)
+CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, istgt.o conn.o param.o session.o iscsid.o target.o chap.o netlink.o)
 LIBS = -lcrypto
+endif
 
 all: $(PROGRAMS)
 

Modified: trunk/usr/driver.c
===================================================================
--- trunk/usr/driver.c	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/driver.c	2006-07-13 10:27:53 UTC (rev 504)
@@ -6,26 +6,12 @@
 #include "tgtd.h"
 #include "driver.h"
 
-#ifdef ISCSI
-#include "iscsi/iscsi.h"
-#endif
-
 #ifdef IBMVIO
-struct tgt_driver ibmvio = {
-	.name	= "ibmvio",
-};
+#include "ibmvio/ibmvio.h"
 #endif
 
 #ifdef ISCSI
-struct tgt_driver iscsi = {
-	.name		= "iscsi",
-	.init		= iscsi_init,
-	.poll_init	= iscsi_poll_init,
-	.event_handle	= iscsi_event_handle,
-	.target_create	= iscsi_target_create,
-	.target_destroy	= iscsi_target_destroy,
-	.target_bind	= iscsi_target_bind,
-};
+#include "iscsi/iscsi.h"
 #endif
 
 struct tgt_driver *tgt_drivers[] = {

Modified: trunk/usr/driver.h
===================================================================
--- trunk/usr/driver.h	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/driver.h	2006-07-13 10:27:53 UTC (rev 504)
@@ -16,7 +16,6 @@
 				uint8_t *, int *);
 	int (*scsi_inquiry)(struct tgt_device *, int, uint8_t *, uint8_t *,
 			    uint8_t *, int *);
-
 	int npfd;
 	int enable;
 	int pfd_index;

Copied: trunk/usr/ibmvio/ibmvio.c (from rev 503, trunk/usr/ibmvio/libibmvstgt.c)
===================================================================
--- trunk/usr/ibmvio/libibmvstgt.c	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/ibmvio/ibmvio.c	2006-07-13 10:27:53 UTC (rev 504)
@@ -0,0 +1,266 @@
+/*
+ * SCSI command processing specific to IBM Virtual SCSI target Driver
+ *
+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
+ *
+ * Based on:
+ *
+ * IBM eServer i/pSeries Virtual SCSI Target Driver
+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+ * USA
+ */
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <syscall.h>
+#include <unistd.h>
+#include <asm/byteorder.h>
+#include <linux/fs.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tgt_if.h>
+#include <sys/mman.h>
+
+#include "tgtd.h"
+
+#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
+#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
+#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
+
+struct inquiry_data {
+	uint8_t qual_type;
+	uint8_t rmb_reserve;
+	uint8_t version;
+	uint8_t aerc_naca_hisup_format;
+	uint8_t addl_len;
+	uint8_t sccs_reserved;
+	uint8_t bque_encserv_vs_multip_mchngr_reserved;
+	uint8_t reladr_reserved_linked_cmdqueue_vs;
+	char vendor[8];
+	char product[16];
+	char revision[4];
+	char vendor_specific[20];
+	char reserved1[2];
+	char version_descriptor[16];
+	char reserved2[22];
+	char unique[158];
+};
+
+#define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
+
+static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
+{
+	struct inquiry_data *id = (struct inquiry_data *) data;
+	char system_id[256], path[256], buf[32];
+	int fd, err, partition_number;
+	unsigned int unit_address;
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
+	fd = open(path, O_RDONLY);
+	memset(system_id, 0, sizeof(system_id));
+	err = read(fd, system_id, sizeof(system_id));
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/partition_number",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	partition_number = strtoul(buf, NULL, 10);
+	close(fd);
+
+	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/unit_address",
+		 host_no);
+	fd = open(path, O_RDONLY);
+	err = read(fd, buf, sizeof(buf));
+	unit_address = strtoul(buf, NULL, 0);
+	close(fd);
+
+	dprintf("%d %s %d %x %" PRIx64 "\n",
+		host_no, system_id, partition_number, unit_address, lun);
+
+	id->qual_type = TYPE_DISK;
+	id->rmb_reserve = 0x00;
+	id->version = 0x84;	/* ISO/IE		  */
+	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
+	id->addl_len = sizeof(*id) - 4;
+	id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
+	id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
+	memcpy(id->vendor, "IBM	    ", 8);
+	/* Don't even ask about the next bit.  AIX uses
+	 * hardcoded device naming to recognize device types
+	 * and their client won't  work unless we use VOPTA and
+	 * VDASD.
+	 */
+	memcpy(id->product, "VDASD blkdev    ", 16);
+	memcpy(id->revision, "0001", 4);
+	snprintf(id->unique,sizeof(id->unique),
+		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
+		 system_id,
+		 partition_number,
+		 unit_address,
+		 GETBUS(lun),
+		 GETTARGET(lun),
+		 GETLUN(lun));
+
+	return sizeof(*id);
+}
+
+int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
+		 uint8_t *scb, uint8_t *data, int *len)
+{
+	int result = SAM_STAT_CHECK_CONDITION;
+
+	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
+		goto err;
+
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (!(scb[1] & 0x3)) {
+		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
+		result = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x2) {
+		/* CmdDt bit is set */
+		/* We do not support it now. */
+		data[1] = 0x1;
+		data[5] = 0;
+		*len = 6;
+		result = SAM_STAT_GOOD;
+	} else if (scb[1] & 0x1) {
+		/* EVPD bit set */
+		if (scb[2] == 0x0) {
+			data[1] = 0x0;
+			data[3] = 3;
+			data[4] = 0x0;
+			data[5] = 0x80;
+			data[6] = 0x83;
+			*len = 7;
+			result = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x80) {
+			data[1] = 0x80;
+			data[3] = 4;
+			memset(data + 4, 0x20, 4);
+			*len = 8;
+			result = SAM_STAT_GOOD;
+		} else if (scb[2] == 0x83) {
+			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
+
+			data[1] = 0x83;
+			data[3] = tmp + 4;
+			data[4] = 0x1;
+			data[5] = 0x1;
+			data[7] = tmp;
+			if (dev)
+				strncpy(data + 8, dev->scsi_id, SCSI_ID_LEN);
+			*len = tmp + 8;
+			result = SAM_STAT_GOOD;
+		}
+	}
+
+	if (result != SAM_STAT_GOOD)
+		goto err;
+
+	*len = min_t(int, *len, scb[4]);
+
+	if (!dev)
+		data[0] = TYPE_NO_LUN;
+
+	return SAM_STAT_GOOD;
+
+err:
+	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
+				0x24, 0);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
+{
+	uint16_t result = (0x8000 |
+			   ((target & 0x003f) << 8) |
+			   ((bus & 0x0007) << 5) |
+			   (lun & 0x001f));
+	return ((uint64_t) result) << 48;
+}
+
+int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
+		     uint8_t *scb, uint8_t *p, int *len)
+{
+	struct tgt_device *dev;
+	uint64_t lun, *data = (uint64_t *) p;
+	int idx, alen, oalen, nr_luns, rbuflen = 4096;
+	int result = SAM_STAT_GOOD;
+
+	memset(data, 0, rbuflen);
+
+	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
+	if (alen < 16) {
+		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
+					0x24, 0);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	alen &= ~(8 - 1);
+	oalen = alen;
+
+	if ((*((uint64_t *) lun_buf))) {
+		nr_luns = 1;
+		goto done;
+	}
+
+	alen -= 8;
+	rbuflen -= 8; /* FIXME */
+	idx = 2;
+	nr_luns = 1;
+
+	list_for_each_entry(dev, dev_list, dlist) {
+		lun = dev->lun;
+		lun = make_lun(0, lun & 0x003f, 0);
+		data[idx++] = __cpu_to_be64(lun);
+		if (!(alen -= 8))
+			break;
+		if (!(rbuflen -= 8)) {
+			fprintf(stderr, "FIXME: too many luns\n");
+			exit(-1);
+		}
+		nr_luns++;
+	}
+
+done:
+	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
+	*len = min(oalen, nr_luns * 8 + 8);
+
+	return result;
+}
+
+#define        TGT_INVALID_DEV_ID      ~0ULL
+
+uint64_t scsi_lun_to_int(uint8_t *p)
+{
+	uint64_t lun = TGT_INVALID_DEV_ID;
+
+	lun = *((uint64_t *) p);
+	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
+
+	if (GETBUS(lun) || GETLUN(lun))
+		return TGT_INVALID_DEV_ID;
+	else
+		return GETTARGET(lun);
+}

Added: trunk/usr/ibmvio/ibmvio.h
===================================================================
--- trunk/usr/ibmvio/ibmvio.h	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/ibmvio/ibmvio.h	2006-07-13 10:27:53 UTC (rev 504)
@@ -0,0 +1,13 @@
+extern int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
+			uint8_t *scb, uint8_t *data, int *len);
+extern int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
+			    uint8_t *scb, uint8_t *p, int *len);
+
+extern uint64_t scsi_lun_to_int(uint8_t *p);
+
+struct tgt_driver ibmvio = {
+	.name			= "ibmvio",
+	.scsi_get_lun		= scsi_lun_to_int,
+	.scsi_report_luns	= scsi_report_luns,
+	.scsi_inquiry		= scsi_inquiry,
+};

Deleted: trunk/usr/ibmvio/libibmvstgt.c
===================================================================
--- trunk/usr/ibmvio/libibmvstgt.c	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/ibmvio/libibmvstgt.c	2006-07-13 10:27:53 UTC (rev 504)
@@ -1,267 +0,0 @@
-/*
- * SCSI command processing specific to IBM Virtual SCSI target Driver
- *
- * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
- *
- * Based on:
- *
- * IBM eServer i/pSeries Virtual SCSI Target Driver
- * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
- *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
- *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
- * USA
- */
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#include <syscall.h>
-#include <unistd.h>
-#include <asm/byteorder.h>
-#include <linux/fs.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_tgt_if.h>
-#include <sys/mman.h>
-
-#include "tgtd.h"
-
-#define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
-#define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
-#define GETLUN(x) ((int)((((uint64_t)(x)) >> 48) & 0x001f))
-
-struct inquiry_data {
-	uint8_t qual_type;
-	uint8_t rmb_reserve;
-	uint8_t version;
-	uint8_t aerc_naca_hisup_format;
-	uint8_t addl_len;
-	uint8_t sccs_reserved;
-	uint8_t bque_encserv_vs_multip_mchngr_reserved;
-	uint8_t reladr_reserved_linked_cmdqueue_vs;
-	char vendor[8];
-	char product[16];
-	char revision[4];
-	char vendor_specific[20];
-	char reserved1[2];
-	char version_descriptor[16];
-	char reserved2[22];
-	char unique[158];
-};
-
-#define	IBMVSTGT_HOSTDIR	"/sys/class/scsi_host/host"
-
-static int ibmvstgt_inquiry(int host_no, uint64_t lun, uint8_t *data)
-{
-	struct inquiry_data *id = (struct inquiry_data *) data;
-	char system_id[256], path[256], buf[32];
-	int fd, err, partition_number;
-	unsigned int unit_address;
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
-	fd = open(path, O_RDONLY);
-	memset(system_id, 0, sizeof(system_id));
-	err = read(fd, system_id, sizeof(system_id));
-	close(fd);
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/partition_number",
-		 host_no);
-	fd = open(path, O_RDONLY);
-	err = read(fd, buf, sizeof(buf));
-	partition_number = strtoul(buf, NULL, 10);
-	close(fd);
-
-	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/unit_address",
-		 host_no);
-	fd = open(path, O_RDONLY);
-	err = read(fd, buf, sizeof(buf));
-	unit_address = strtoul(buf, NULL, 0);
-	close(fd);
-
-	dprintf("%d %s %d %x %" PRIx64 "\n",
-		host_no, system_id, partition_number, unit_address, lun);
-
-	id->qual_type = TYPE_DISK;
-	id->rmb_reserve = 0x00;
-	id->version = 0x84;	/* ISO/IE		  */
-	id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
-	id->addl_len = sizeof(*id) - 4;
-	id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
-	id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
-	memcpy(id->vendor, "IBM	    ", 8);
-	/* Don't even ask about the next bit.  AIX uses
-	 * hardcoded device naming to recognize device types
-	 * and their client won't  work unless we use VOPTA and
-	 * VDASD.
-	 */
-	memcpy(id->product, "VDASD blkdev    ", 16);
-	memcpy(id->revision, "0001", 4);
-	snprintf(id->unique,sizeof(id->unique),
-		 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
-		 system_id,
-		 partition_number,
-		 unit_address,
-		 GETBUS(lun),
-		 GETTARGET(lun),
-		 GETLUN(lun));
-
-	return sizeof(*id);
-}
-
-int scsi_inquiry(struct tgt_device *dev, int host_no, uint8_t *lun_buf,
-		 uint8_t *scb, uint8_t *data, int *len)
-{
-	int result = SAM_STAT_CHECK_CONDITION;
-
-	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
-		goto err;
-
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		*len = ibmvstgt_inquiry(host_no, *((uint64_t *) lun_buf), data);
-		result = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x2) {
-		/* CmdDt bit is set */
-		/* We do not support it now. */
-		data[1] = 0x1;
-		data[5] = 0;
-		*len = 6;
-		result = SAM_STAT_GOOD;
-	} else if (scb[1] & 0x1) {
-		/* EVPD bit set */
-		if (scb[2] == 0x0) {
-			data[1] = 0x0;
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			*len = 7;
-			result = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			data[1] = 0x80;
-			data[3] = 4;
-			memset(data + 4, 0x20, 4);
-			*len = 8;
-			result = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x83) {
-			uint32_t tmp = SCSI_ID_LEN * sizeof(uint8_t);
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			if (dev)
-				strncpy(data + 8, dev->scsi_id, SCSI_ID_LEN);
-			*len = tmp + 8;
-			result = SAM_STAT_GOOD;
-		}
-	}
-
-	if (result != SAM_STAT_GOOD)
-		goto err;
-
-	*len = min_t(int, *len, scb[4]);
-
-	if (!dev)
-		data[0] = TYPE_NO_LUN;
-
-	return SAM_STAT_GOOD;
-
-err:
-	*len = sense_data_build(data, 0x70, ILLEGAL_REQUEST,
-				0x24, 0);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static uint64_t make_lun(unsigned int bus, unsigned int target, unsigned int lun)
-{
-	uint16_t result = (0x8000 |
-			   ((target & 0x003f) << 8) |
-			   ((bus & 0x0007) << 5) |
-			   (lun & 0x001f));
-	return ((uint64_t) result) << 48;
-}
-
-int scsi_report_luns(struct list_head *dev_list, uint8_t *lun_buf,
-		     uint8_t *scb, uint8_t *p, int *len)
-{
-	struct tgt_device *dev;
-	uint64_t lun, *data = (uint64_t *) p;
-	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	int result = SAM_STAT_GOOD;
-
-	memset(data, 0, rbuflen);
-
-	alen = __be32_to_cpu(*(uint32_t *)&scb[6]);
-	if (alen < 16) {
-		*len = sense_data_build(p, 0x70, ILLEGAL_REQUEST,
-					0x24, 0);
-		return SAM_STAT_CHECK_CONDITION;
-	}
-
-	alen &= ~(8 - 1);
-	oalen = alen;
-
-	if ((*((uint64_t *) lun_buf))) {
-		nr_luns = 1;
-		goto done;
-	}
-
-	alen -= 8;
-	rbuflen -= 8; /* FIXME */
-	idx = 2;
-	nr_luns = 1;
-
-	list_for_each_entry(dev, dev_list, dlist) {
-		lun = dev->lun;
-		lun = make_lun(0, lun & 0x003f, 0);
-		data[idx++] = __cpu_to_be64(lun);
-		if (!(alen -= 8))
-			break;
-		if (!(rbuflen -= 8)) {
-			fprintf(stderr, "FIXME: too many luns\n");
-			exit(-1);
-		}
-		nr_luns++;
-	}
-
-done:
-	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
-
-	return result;
-}
-
-#define        TGT_INVALID_DEV_ID      ~0ULL
-
-uint64_t scsi_lun_to_int(uint8_t *p)
-{
-	uint64_t lun = TGT_INVALID_DEV_ID;
-
-	lun = *((uint64_t *) p);
-	dprintf("%" PRIx64 " %u %u %u\n", lun, GETTARGET(lun), GETBUS(lun), GETLUN(lun));
-
-	if (GETBUS(lun) || GETLUN(lun))
-		return TGT_INVALID_DEV_ID;
-	else
-		return GETTARGET(lun);
-}
-

Modified: trunk/usr/iscsi/iscsi.h
===================================================================
--- trunk/usr/iscsi/iscsi.h	2006-07-12 17:25:03 UTC (rev 503)
+++ trunk/usr/iscsi/iscsi.h	2006-07-13 10:27:53 UTC (rev 504)
@@ -4,3 +4,13 @@
 extern int iscsi_target_create(int, char *);
 extern int iscsi_target_destroy(int);
 extern int iscsi_target_bind(int);
+
+struct tgt_driver iscsi = {
+	.name		= "iscsi",
+	.init		= iscsi_init,
+	.poll_init	= iscsi_poll_init,
+	.event_handle	= iscsi_event_handle,
+	.target_create	= iscsi_target_create,
+	.target_destroy	= iscsi_target_destroy,
+	.target_bind	= iscsi_target_bind,
+};



From tomo at mail.berlios.de  Wed Jul 26 06:56:39 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 06:56:39 +0200
Subject: [Stgt-svn] r505 - trunk/patchset
Message-ID: <200607260456.k6Q4udxe026106@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 06:56:18 +0200 (Wed, 26 Jul 2006)
New Revision: 505

Removed:
   trunk/patchset/tgt-2.6.17.patch
Log:
Remove old patch for 2.6.17.

Deleted: trunk/patchset/tgt-2.6.17.patch
===================================================================
--- trunk/patchset/tgt-2.6.17.patch	2006-07-13 10:27:53 UTC (rev 504)
+++ trunk/patchset/tgt-2.6.17.patch	2006-07-26 04:56:18 UTC (rev 505)
@@ -1,602 +0,0 @@
-Subject: [PATCH] scsi tgt: tgt headers and mainline changes.
-
----
-
- block/ll_rw_blk.c          |   40 ++++++++++----------
- block/scsi_ioctl.c         |    3 +
- drivers/scsi/hosts.c       |    5 ++
- drivers/scsi/scsi.c        |   43 +++++++++++++--------
- drivers/scsi/scsi_lib.c    |   33 ++++++++++++----
- fs/bio.c                   |   19 +--------
- include/linux/blkdev.h     |    3 +
- include/linux/netlink.h    |    1 
- include/scsi/scsi_cmnd.h   |    8 ++++
- include/scsi/scsi_host.h   |   43 +++++++++++++++++++++
- include/scsi/scsi_tgt.h    |   17 ++++++++
- include/scsi/scsi_tgt_if.h |   89 ++++++++++++++++++++++++++++++++++++++++++++
- 12 files changed, 240 insertions(+), 64 deletions(-)
- create mode 100644 include/scsi/scsi_tgt.h
- create mode 100644 include/scsi/scsi_tgt_if.h
-
-92f10cdafc264d0c336ea82f3ddb38dd8d9ab622
-diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
-index 7eb36c5..4fe85d7 100644
---- a/block/ll_rw_blk.c
-+++ b/block/ll_rw_blk.c
-@@ -2351,19 +2351,20 @@ int blk_rq_map_user(request_queue_t *q, 
- 	else
- 		bio = bio_copy_user(q, uaddr, len, reading);
- 
--	if (!IS_ERR(bio)) {
--		rq->bio = rq->biotail = bio;
--		blk_rq_bio_prep(q, rq, bio);
-+	if (IS_ERR(bio))
-+		return PTR_ERR(bio);
- 
--		rq->buffer = rq->data = NULL;
--		rq->data_len = len;
--		return 0;
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
- 	}
- 
--	/*
--	 * bio is the err-ptr
--	 */
--	return PTR_ERR(bio);
-+	rq->bio = rq->biotail = bio;
-+	blk_rq_bio_prep(q, rq, bio);
-+	rq->buffer = rq->data = NULL;
-+	rq->data_len = len;
-+	return 0;
- }
- 
- EXPORT_SYMBOL(blk_rq_map_user);
-@@ -2389,7 +2390,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
-  *    unmapping.
-  */
- int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
--			struct sg_iovec *iov, int iov_count)
-+			struct sg_iovec *iov, int iov_count, unsigned int len)
- {
- 	struct bio *bio;
- 
-@@ -2403,6 +2404,12 @@ int blk_rq_map_user_iov(request_queue_t 
- 	if (IS_ERR(bio))
- 		return PTR_ERR(bio);
- 
-+	if (bio->bi_size != len) {
-+		bio_endio(bio, bio->bi_size, 0);
-+		bio_unmap_user(bio);
-+		return -EINVAL;
-+	}
-+
- 	rq->bio = rq->biotail = bio;
- 	blk_rq_bio_prep(q, rq, bio);
- 	rq->buffer = rq->data = NULL;
-@@ -2826,16 +2833,12 @@ static void init_request_from_bio(struct
- 
- 	req->errors = 0;
- 	req->hard_sector = req->sector = bio->bi_sector;
--	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
--	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
--	req->nr_phys_segments = bio_phys_segments(req->q, bio);
--	req->nr_hw_segments = bio_hw_segments(req->q, bio);
--	req->buffer = bio_data(bio);	/* see ->buffer comment above */
- 	req->waiting = NULL;
--	req->bio = req->biotail = bio;
- 	req->ioprio = bio_prio(bio);
- 	req->rq_disk = bio->bi_bdev->bd_disk;
- 	req->start_time = jiffies;
-+
-+	blk_rq_bio_prep(req->q, req, bio);
- }
- 
- static int __make_request(request_queue_t *q, struct bio *bio)
-@@ -3487,9 +3490,6 @@ EXPORT_SYMBOL(end_request);
- 
- void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
- {
--	/* first three bits are identical in rq->flags and bio->bi_rw */
--	rq->flags |= (bio->bi_rw & 7);
--
- 	rq->nr_phys_segments = bio_phys_segments(q, bio);
- 	rq->nr_hw_segments = bio_hw_segments(q, bio);
- 	rq->current_nr_sectors = bio_cur_sectors(bio);
-diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
-index b33eda2..b77e185 100644
---- a/block/scsi_ioctl.c
-+++ b/block/scsi_ioctl.c
-@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
- 			goto out;
- 		}
- 
--		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
-+		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
-+					  hdr->dxfer_len);
- 		kfree(iov);
- 	} else if (hdr->dxfer_len)
- 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
-diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
-index dfcb96f..f8cce09 100644
---- a/drivers/scsi/hosts.c
-+++ b/drivers/scsi/hosts.c
-@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
- 	if (shost->work_q)
- 		destroy_workqueue(shost->work_q);
- 
-+	if (shost->uspace_req_q) {
-+		kfree(shost->uspace_req_q->queuedata);
-+		scsi_free_queue(shost->uspace_req_q);
-+	}
-+
- 	scsi_destroy_command_freelist(shost);
- 	kfree(shost->shost_data);
- 
-diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
-index 73994e2..0591b93 100644
---- a/drivers/scsi/scsi.c
-+++ b/drivers/scsi/scsi.c
-@@ -210,8 +210,7 @@ static struct scsi_host_cmd_pool scsi_cm
- 
- static DEFINE_MUTEX(host_cmd_pool_mutex);
- 
--static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
--					    gfp_t gfp_mask)
-+struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
- {
- 	struct scsi_cmnd *cmd;
- 
-@@ -232,6 +231,7 @@ static struct scsi_cmnd *__scsi_get_comm
- 
- 	return cmd;
- }
-+EXPORT_SYMBOL_GPL(__scsi_get_command);
- 
- /*
-  * Function:	scsi_get_command()
-@@ -268,9 +268,29 @@ struct scsi_cmnd *scsi_get_command(struc
- 		put_device(&dev->sdev_gendev);
- 
- 	return cmd;
--}				
-+}
- EXPORT_SYMBOL(scsi_get_command);
- 
-+void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
-+			struct device *dev)
-+{
-+	unsigned long flags;
-+
-+	/* changing locks here, don't need to restore the irq state */
-+	spin_lock_irqsave(&shost->free_list_lock, flags);
-+	if (unlikely(list_empty(&shost->free_list))) {
-+		list_add(&cmd->list, &shost->free_list);
-+		cmd = NULL;
-+	}
-+	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+
-+	if (likely(cmd != NULL))
-+		kmem_cache_free(shost->cmd_pool->slab, cmd);
-+
-+	put_device(dev);
-+}
-+EXPORT_SYMBOL(__scsi_put_command);
-+
- /*
-  * Function:	scsi_put_command()
-  *
-@@ -285,26 +305,15 @@ EXPORT_SYMBOL(scsi_get_command);
- void scsi_put_command(struct scsi_cmnd *cmd)
- {
- 	struct scsi_device *sdev = cmd->device;
--	struct Scsi_Host *shost = sdev->host;
- 	unsigned long flags;
--	
-+
- 	/* serious error if the command hasn't come from a device list */
- 	spin_lock_irqsave(&cmd->device->list_lock, flags);
- 	BUG_ON(list_empty(&cmd->list));
- 	list_del_init(&cmd->list);
--	spin_unlock(&cmd->device->list_lock);
--	/* changing locks here, don't need to restore the irq state */
--	spin_lock(&shost->free_list_lock);
--	if (unlikely(list_empty(&shost->free_list))) {
--		list_add(&cmd->list, &shost->free_list);
--		cmd = NULL;
--	}
--	spin_unlock_irqrestore(&shost->free_list_lock, flags);
-+	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
- 
--	if (likely(cmd != NULL))
--		kmem_cache_free(shost->cmd_pool->slab, cmd);
--
--	put_device(&sdev->sdev_gendev);
-+	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
- }
- EXPORT_SYMBOL(scsi_put_command);
- 
-diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
-index faee475..f8ac3d5 100644
---- a/drivers/scsi/scsi_lib.c
-+++ b/drivers/scsi/scsi_lib.c
-@@ -803,7 +803,7 @@ static struct scsi_cmnd *scsi_end_reques
- 	return NULL;
- }
- 
--static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
-+struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
- {
- 	struct scsi_host_sg_pool *sgp;
- 	struct scatterlist *sgl;
-@@ -844,7 +844,9 @@ static struct scatterlist *scsi_alloc_sg
- 	return sgl;
- }
- 
--static void scsi_free_sgtable(struct scatterlist *sgl, int index)
-+EXPORT_SYMBOL(scsi_alloc_sgtable);
-+
-+void scsi_free_sgtable(struct scatterlist *sgl, int index)
- {
- 	struct scsi_host_sg_pool *sgp;
- 
-@@ -854,6 +856,8 @@ static void scsi_free_sgtable(struct sca
- 	mempool_free(sgl, sgp->pool);
- }
- 
-+EXPORT_SYMBOL(scsi_free_sgtable);
-+
- /*
-  * Function:    scsi_release_buffers()
-  *
-@@ -1714,29 +1718,40 @@ u64 scsi_calculate_bounce_limit(struct S
- }
- EXPORT_SYMBOL(scsi_calculate_bounce_limit);
- 
--struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					 request_fn_proc *request_fn)
- {
--	struct Scsi_Host *shost = sdev->host;
- 	struct request_queue *q;
- 
--	q = blk_init_queue(scsi_request_fn, NULL);
-+	q = blk_init_queue(request_fn, NULL);
- 	if (!q)
- 		return NULL;
- 
--	blk_queue_prep_rq(q, scsi_prep_fn);
--
- 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
- 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
- 	blk_queue_max_sectors(q, shost->max_sectors);
- 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
- 	blk_queue_segment_boundary(q, shost->dma_boundary);
--	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
--	blk_queue_softirq_done(q, scsi_softirq_done);
- 
- 	if (!shost->use_clustering)
- 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
- 	return q;
- }
-+EXPORT_SYMBOL(__scsi_alloc_queue);
-+
-+struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
-+{
-+	struct request_queue *q;
-+
-+	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
-+	if (!q)
-+		return NULL;
-+
-+	blk_queue_prep_rq(q, scsi_prep_fn);
-+	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
-+	blk_queue_softirq_done(q, scsi_softirq_done);
-+	return q;
-+}
- 
- void scsi_free_queue(struct request_queue *q)
- {
-diff --git a/fs/bio.c b/fs/bio.c
-index 6a0b9ad..ade77bf 100644
---- a/fs/bio.c
-+++ b/fs/bio.c
-@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
- 
- 		nr_pages += end - start;
- 		/*
--		 * transfer and buffer must be aligned to at least hardsector
--		 * size for now, in the future we can relax this restriction
-+		 * buffer must be aligned to at least hardsector size for now
- 		 */
--		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
-+		if (uaddr & queue_dma_alignment(q))
- 			return ERR_PTR(-EINVAL);
- 	}
- 
-@@ -750,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
- 			     int write_to_vm)
- {
- 	struct bio *bio;
--	int len = 0, i;
- 
- 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
- 
-@@ -765,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
- 	 */
- 	bio_get(bio);
- 
--	for (i = 0; i < iov_count; i++)
--		len += iov[i].iov_len;
--
--	if (bio->bi_size == len)
--		return bio;
--
--	/*
--	 * don't support partial mappings
--	 */
--	bio_endio(bio, bio->bi_size, 0);
--	bio_unmap_user(bio);
--	return ERR_PTR(-EINVAL);
-+	return bio;
- }
- 
- static void __bio_unmap_user(struct bio *bio)
-diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
-index 59e1259..cec7ccf 100644
---- a/include/linux/blkdev.h
-+++ b/include/linux/blkdev.h
-@@ -624,7 +624,8 @@ extern void blk_queue_activity_fn(reques
- extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
- extern int blk_rq_unmap_user(struct bio *, unsigned int);
- extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
--extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
-+extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
-+			       struct sg_iovec *, int, unsigned int);
- extern int blk_execute_rq(request_queue_t *, struct gendisk *,
- 			  struct request *, int);
- extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
-diff --git a/include/linux/netlink.h b/include/linux/netlink.h
-index 87b8a57..cfac287 100644
---- a/include/linux/netlink.h
-+++ b/include/linux/netlink.h
-@@ -21,6 +21,7 @@
- #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
- #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
- #define NETLINK_GENERIC		16
-+#define NETLINK_TGT		17	/* SCSI target */
- 
- #define MAX_LINKS 32		
- 
-diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
-index 1ace1b9..d69dbf5 100644
---- a/include/scsi/scsi_cmnd.h
-+++ b/include/scsi/scsi_cmnd.h
-@@ -8,6 +8,7 @@
- 
- struct request;
- struct scatterlist;
-+struct Scsi_Host;
- struct scsi_device;
- struct scsi_request;
- 
-@@ -84,6 +85,8 @@ struct scsi_cmnd {
- 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
- 	unsigned bufflen;	/* Size of data buffer */
- 	void *buffer;		/* Data buffer */
-+	/* offset in cmd we are at (for multi-transfer tgt cmds) */
-+	unsigned offset;
- 
- 	unsigned underflow;	/* Return error if less than
- 				   this amount is transferred */
-@@ -148,8 +151,13 @@ struct scsi_cmnd {
- 
- 
- extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
-+extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
- extern void scsi_put_command(struct scsi_cmnd *);
-+extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
-+			       struct device *);
- extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
- extern void scsi_finish_command(struct scsi_cmnd *cmd);
-+extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
-+extern void scsi_free_sgtable(struct scatterlist *, int);
- 
- #endif /* _SCSI_SCSI_CMND_H */
-diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
-index de6ce54..353abe5 100644
---- a/include/scsi/scsi_host.h
-+++ b/include/scsi/scsi_host.h
-@@ -7,6 +7,7 @@
- #include <linux/workqueue.h>
- #include <linux/mutex.h>
- 
-+struct request_queue;
- struct block_device;
- struct completion;
- struct module;
-@@ -123,6 +124,39 @@ struct scsi_host_template {
- 			     void (*done)(struct scsi_cmnd *));
- 
- 	/*
-+	 * The transfer functions are used to queue a scsi command to
-+	 * the LLD. When the driver is finished processing the command
-+	 * the done callback is invoked.
-+	 *
-+	 * return values: see queuecommand
-+	 *
-+	 * If the LLD accepts the cmd, it should set the result to an
-+	 * appropriate value when completed before calling the done function.
-+	 *
-+	 * STATUS: REQUIRED FOR TARGET DRIVERS
-+	 */
-+	/* TODO: rename */
-+	int (* transfer_response)(struct scsi_cmnd *,
-+				  void (*done)(struct scsi_cmnd *));
-+	/*
-+	 * This is called to inform the LLD to transfer cmd->request_bufflen
-+	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
-+	 * speciefies the number of scatterlist entried in the command
-+	 * and cmd->request_buffer contains the scatterlist.
-+	 *
-+	 * If the command cannot be processed in one transfer_data call
-+	 * becuase a scatterlist within the LLD's limits cannot be
-+	 * created then transfer_data will be called multiple times.
-+	 * It is initially called from process context, and later
-+	 * calls are from the interrup context.
-+	 */
-+	int (* transfer_data)(struct scsi_cmnd *,
-+			      void (*done)(struct scsi_cmnd *));
-+
-+	/* Used as callback for the completion of task management request. */
-+	int (* tsk_mgmt_response)(u64 mid, int result);
-+
-+	/*
- 	 * This is an error handling strategy routine.  You don't need to
- 	 * define one of these if you don't want to - there is a default
- 	 * routine that is present that should work in most cases.  For those
-@@ -557,6 +591,12 @@ struct Scsi_Host {
- 	 */
- 	unsigned int max_host_blocked;
- 
-+	/*
-+	 * q used for scsi_tgt msgs, async events or any other requests that
-+	 * need to be processed in userspace
-+ 	 */
-+	struct request_queue *uspace_req_q;
-+
- 	/* legacy crap */
- 	unsigned long base;
- 	unsigned long io_port;
-@@ -659,6 +699,9 @@ extern void scsi_unblock_requests(struct
- extern void scsi_block_requests(struct Scsi_Host *);
- 
- struct class_container;
-+
-+extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
-+					     void (*) (struct request_queue *));
- /*
-  * These two functions are used to allocate and free a pseudo device
-  * which will connect to the host adapter itself rather than any
-diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
-new file mode 100644
-index 0000000..61e8ee9
---- /dev/null
-+++ b/include/scsi/scsi_tgt.h
-@@ -0,0 +1,17 @@
-+/*
-+ * SCSI target definitions
-+ */
-+
-+#include <linux/dma-mapping.h>
-+
-+struct Scsi_Host;
-+struct scsi_cmnd;
-+struct scsi_lun;
-+
-+extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
-+extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
-+extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
-+extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
-+				     void *);
-+extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
-+					       enum dma_data_direction,	gfp_t);
-diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
-new file mode 100644
-index 0000000..63b2e3a
---- /dev/null
-+++ b/include/scsi/scsi_tgt_if.h
-@@ -0,0 +1,89 @@
-+/*
-+ * SCSI target kernel/user interface
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#ifndef __SCSI_TARGET_IF_H
-+#define __SCSI_TARGET_IF_H
-+
-+enum tgt_event_type {
-+	/* user -> kernel */
-+	TGT_UEVENT_REQ,
-+	TGT_UEVENT_CMD_RSP,
-+	TGT_UEVENT_TSK_MGMT_RSP,
-+
-+	/* kernel -> user */
-+	TGT_KEVENT_RSP,
-+	TGT_KEVENT_CMD_REQ,
-+	TGT_KEVENT_CMD_DONE,
-+	TGT_KEVENT_TSK_MGMT_REQ,
-+};
-+
-+struct tgt_event {
-+	/* user-> kernel */
-+	union {
-+		struct {
-+			int type;
-+			int host_no;
-+		} event_req;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t len;
-+			int result;
-+			uint64_t uaddr;
-+			uint8_t rw;
-+		} cmd_rsp;
-+		struct {
-+			int host_no;
-+			uint64_t mid;
-+			int result;
-+		} tsk_mgmt_rsp;
-+	} u;
-+
-+	/* kernel -> user */
-+	union {
-+		struct {
-+			int err;
-+		} event_rsp;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			uint32_t data_len;
-+			uint8_t scb[16];
-+			uint8_t lun[8];
-+			int attribute;
-+			uint64_t tag;
-+		} cmd_req;
-+		struct {
-+			int host_no;
-+			uint32_t cid;
-+			int result;
-+		} cmd_done;
-+		struct {
-+			int host_no;
-+			int function;
-+			uint64_t tag;
-+			uint8_t lun[8];
-+			uint64_t mid;
-+		} tsk_mgmt_req;
-+	} k;
-+
-+} __attribute__ ((aligned (sizeof(uint64_t))));
-+#endif
--- 
-1.1.3



From tomo at mail.berlios.de  Wed Jul 26 06:58:12 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 06:58:12 +0200
Subject: [Stgt-svn] r506 - trunk/patchset
Message-ID: <200607260458.k6Q4wCgT026844@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 06:57:44 +0200 (Wed, 26 Jul 2006)
New Revision: 506

Removed:
   trunk/patchset/broken-out/
Log:
Kill old broken-out patchset.



From tomo at mail.berlios.de  Wed Jul 26 07:05:20 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 07:05:20 +0200
Subject: [Stgt-svn] r507 - trunk/patchset
Message-ID: <200607260505.k6Q55K58029755@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 07:05:04 +0200 (Wed, 26 Jul 2006)
New Revision: 507

Added:
   trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
   trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
   trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
   trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
   trunk/patchset/0005-scsi-target-kill-target-command-list.txt
Log:
Add the latest patchset.

Added: trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt
===================================================================
--- trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0001-ibmvscsi-convert-the-ibmvscsi-driver-to-use-include-scsi-srp.h.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,583 @@
+Subject: [PATCH] ibmvscsi: convert the ibmvscsi driver to use include/scsi/srp.h
+From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
+Date: 1143376921 +0900
+
+---
+
+ drivers/scsi/ibmvscsi/ibmvscsi.c  |  247 +++++++++++++++++++------------------
+ drivers/scsi/ibmvscsi/ibmvscsi.h  |    2 
+ drivers/scsi/ibmvscsi/rpa_vscsi.c |    1 
+ drivers/scsi/ibmvscsi/viosrp.h    |   17 ++-
+ 4 files changed, 142 insertions(+), 125 deletions(-)
+
+74aa6fe8367e04be9cc7d0e7d16cc790754a73f3
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
+index eaefedd..e7bd028 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.c
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
+@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
+ 			++in_use;
+ 		if (pool->events[i].ext_list) {
+ 			dma_free_coherent(hostdata->dev,
+-				  SG_ALL * sizeof(struct memory_descriptor),
++				  SG_ALL * sizeof(struct srp_direct_buf),
+ 				  pool->events[i].ext_list,
+ 				  pool->events[i].ext_list_token);
+ 		}
+@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
+ 			      struct srp_cmd *srp_cmd, 
+ 			      int numbuf)
+ {
++	u8 fmt;
++
+ 	if (numbuf == 0)
+ 		return;
+ 	
+-	if (numbuf == 1) {
++	if (numbuf == 1)
++		fmt = SRP_DATA_DESC_DIRECT;
++	else {
++		fmt = SRP_DATA_DESC_INDIRECT;
++		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
++
+ 		if (cmd->sc_data_direction == DMA_TO_DEVICE)
+-			srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
+-		else 
+-			srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
+-	} else {
+-		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
+-			srp_cmd->data_out_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd->data_out_count =
+-				numbuf < MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		} else {
+-			srp_cmd->data_in_format = SRP_INDIRECT_BUFFER;
+-			srp_cmd->data_in_count =
+-				numbuf < MAX_INDIRECT_BUFS ?
+-					numbuf: MAX_INDIRECT_BUFS;
+-		}
++			srp_cmd->data_out_desc_cnt = numbuf;
++		else
++			srp_cmd->data_in_desc_cnt = numbuf;
+ 	}
++
++	if (cmd->sc_data_direction == DMA_TO_DEVICE)
++		srp_cmd->buf_fmt = fmt << 4;
++	else
++		srp_cmd->buf_fmt = fmt;
+ }
+ 
+-static void unmap_sg_list(int num_entries, 
++static void unmap_sg_list(int num_entries,
+ 		struct device *dev,
+-		struct memory_descriptor *md)
+-{ 
++		struct srp_direct_buf *md)
++{
+ 	int i;
+ 
+-	for (i = 0; i < num_entries; ++i) {
+-		dma_unmap_single(dev,
+-			md[i].virtual_address,
+-			md[i].length, DMA_BIDIRECTIONAL);
+-	}
++	for (i = 0; i < num_entries; ++i)
++		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
+ }
+ 
+ /**
+@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
+ 			   struct srp_event_struct *evt_struct,
+ 			   struct device *dev)
+ {
+-	if ((cmd->data_out_format == SRP_NO_BUFFER) &&
+-	    (cmd->data_in_format == SRP_NO_BUFFER))
++	u8 out_fmt, in_fmt;
++
++	out_fmt = cmd->buf_fmt >> 4;
++	in_fmt = cmd->buf_fmt & ((1U << 4) - 1);
++
++	if (out_fmt == SRP_NO_DATA_DESC && in_fmt == SRP_NO_DATA_DESC)
+ 		return;
+-	else if ((cmd->data_out_format == SRP_DIRECT_BUFFER) ||
+-		 (cmd->data_in_format == SRP_DIRECT_BUFFER)) {
+-		struct memory_descriptor *data =
+-			(struct memory_descriptor *)cmd->additional_data;
+-		dma_unmap_single(dev, data->virtual_address, data->length,
+-				 DMA_BIDIRECTIONAL);
++	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
++		 in_fmt == SRP_DATA_DESC_DIRECT) {
++		struct srp_direct_buf *data =
++			(struct srp_direct_buf *) cmd->add_data;
++		dma_unmap_single(dev, data->va, data->len, DMA_BIDIRECTIONAL);
+ 	} else {
+-		struct indirect_descriptor *indirect =
+-			(struct indirect_descriptor *)cmd->additional_data;
+-		int num_mapped = indirect->head.length / 
+-			sizeof(indirect->list[0]);
++		struct srp_indirect_buf *indirect =
++			(struct srp_indirect_buf *) cmd->add_data;
++		int num_mapped = indirect->table_desc.len /
++			sizeof(struct srp_direct_buf);
+ 
+ 		if (num_mapped <= MAX_INDIRECT_BUFS) {
+-			unmap_sg_list(num_mapped, dev, &indirect->list[0]);
++			unmap_sg_list(num_mapped, dev, &indirect->desc_list[0]);
+ 			return;
+ 		}
+ 
+@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
+ 
+ static int map_sg_list(int num_entries, 
+ 		       struct scatterlist *sg,
+-		       struct memory_descriptor *md)
++		       struct srp_direct_buf *md)
+ {
+ 	int i;
+ 	u64 total_length = 0;
+ 
+ 	for (i = 0; i < num_entries; ++i) {
+-		struct memory_descriptor *descr = md + i;
++		struct srp_direct_buf *descr = md + i;
+ 		struct scatterlist *sg_entry = &sg[i];
+-		descr->virtual_address = sg_dma_address(sg_entry);
+-		descr->length = sg_dma_len(sg_entry);
+-		descr->memory_handle = 0;
++		descr->va = sg_dma_address(sg_entry);
++		descr->len = sg_dma_len(sg_entry);
++		descr->key = 0;
+ 		total_length += sg_dma_len(sg_entry);
+  	}
+ 	return total_length;
+@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
+ 	int sg_mapped;
+ 	u64 total_length = 0;
+ 	struct scatterlist *sg = cmd->request_buffer;
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd->additional_data;
+-	struct indirect_descriptor *indirect =
+-	    (struct indirect_descriptor *)data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd->add_data;
++	struct srp_indirect_buf *indirect =
++		(struct srp_indirect_buf *) data;
+ 
+ 	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
+ 
+@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	/* special case; we can use a single direct descriptor */
+ 	if (sg_mapped == 1) {
+-		data->virtual_address = sg_dma_address(&sg[0]);
+-		data->length = sg_dma_len(&sg[0]);
+-		data->memory_handle = 0;
++		data->va = sg_dma_address(&sg[0]);
++		data->len = sg_dma_len(&sg[0]);
++		data->key = 0;
+ 		return 1;
+ 	}
+ 
+@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
+ 		return 0;
+ 	}
+ 
+-	indirect->head.virtual_address = 0;
+-	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
+-	indirect->head.memory_handle = 0;
++	indirect->table_desc.va = 0;
++	indirect->table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
++	indirect->table_desc.key = 0;
+ 
+ 	if (sg_mapped <= MAX_INDIRECT_BUFS) {
+-		total_length = map_sg_list(sg_mapped, sg, &indirect->list[0]);
+-		indirect->total_length = total_length;
++		total_length = map_sg_list(sg_mapped, sg,
++					   &indirect->desc_list[0]);
++		indirect->len = total_length;
+ 		return 1;
+ 	}
+ 
+ 	/* get indirect table */
+ 	if (!evt_struct->ext_list) {
+-		evt_struct->ext_list =(struct memory_descriptor*)
++		evt_struct->ext_list = (struct srp_direct_buf *)
+ 			dma_alloc_coherent(dev, 
+-				SG_ALL * sizeof(struct memory_descriptor),
+-				&evt_struct->ext_list_token, 0);
++					   SG_ALL * sizeof(struct srp_direct_buf),
++					   &evt_struct->ext_list_token, 0);
+ 		if (!evt_struct->ext_list) {
+-		    printk(KERN_ERR
+-		   	"ibmvscsi: Can't allocate memory for indirect table\n");
++			printk(KERN_ERR
++			       "ibmvscsi: Can't allocate memory for indirect table\n");
+ 			return 0;
+ 			
+ 		}
+@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
+ 
+ 	total_length = map_sg_list(sg_mapped, sg, evt_struct->ext_list);	
+ 
+-	indirect->total_length = total_length;
+-	indirect->head.virtual_address = evt_struct->ext_list_token;
+-	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
+-	memcpy(indirect->list, evt_struct->ext_list,
+-		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
++	indirect->len = total_length;
++	indirect->table_desc.va = evt_struct->ext_list_token;
++	indirect->table_desc.len = sg_mapped * sizeof(indirect->desc_list[0]);
++	memcpy(indirect->desc_list, evt_struct->ext_list,
++	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
+ 	
+  	return 1;
+ }
+@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
+ static int map_single_data(struct scsi_cmnd *cmd,
+ 			   struct srp_cmd *srp_cmd, struct device *dev)
+ {
+-	struct memory_descriptor *data =
+-	    (struct memory_descriptor *)srp_cmd->additional_data;
++	struct srp_direct_buf *data =
++		(struct srp_direct_buf *) srp_cmd->add_data;
+ 
+-	data->virtual_address =
++	data->va =
+ 		dma_map_single(dev, cmd->request_buffer,
+ 			       cmd->request_bufflen,
+ 			       DMA_BIDIRECTIONAL);
+-	if (dma_mapping_error(data->virtual_address)) {
++	if (dma_mapping_error(data->va)) {
+ 		printk(KERN_ERR
+ 		       "ibmvscsi: Unable to map request_buffer for command!\n");
+ 		return 0;
+ 	}
+-	data->length = cmd->request_bufflen;
+-	data->memory_handle = 0;
++	data->len = cmd->request_bufflen;
++	data->key = 0;
+ 
+ 	set_srp_direction(cmd, srp_cmd, 1);
+ 
+@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
+ 
+ 	/* Copy the IU into the transfer area */
+ 	*evt_struct->xfer_iu = evt_struct->iu;
+-	evt_struct->xfer_iu->srp.generic.tag = (u64)evt_struct;
++	evt_struct->xfer_iu->srp.rsp.tag = (u64)evt_struct;
+ 
+ 	/* Add this to the sent list.  We need to do this 
+ 	 * before we actually send 
+@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
+ 	struct srp_rsp *rsp = &evt_struct->xfer_iu->srp.rsp;
+ 	struct scsi_cmnd *cmnd = evt_struct->cmnd;
+ 
+-	if (unlikely(rsp->type != SRP_RSP_TYPE)) {
++	if (unlikely(rsp->opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       "ibmvscsi: bad SRP RSP type %d\n",
+-			       rsp->type);
++			       rsp->opcode);
+ 	}
+ 	
+ 	if (cmnd) {
+ 		cmnd->result = rsp->status;
+ 		if (((cmnd->result >> 1) & 0x1f) == CHECK_CONDITION)
+ 			memcpy(cmnd->sense_buffer,
+-			       rsp->sense_and_response_data,
+-			       rsp->sense_data_list_length);
++			       rsp->data,
++			       rsp->sense_data_len);
+ 		unmap_cmd_data(&evt_struct->iu.srp.cmd, 
+ 			       evt_struct, 
+ 			       evt_struct->hostdata->dev);
+ 
+-		if (rsp->doover)
+-			cmnd->resid = rsp->data_out_residual_count;
+-		else if (rsp->diover)
+-			cmnd->resid = rsp->data_in_residual_count;
++		if (rsp->flags & SRP_RSP_FLAG_DOOVER)
++			cmnd->resid = rsp->data_out_res_cnt;
++		else if (rsp->flags & SRP_RSP_FLAG_DIOVER)
++			cmnd->resid = rsp->data_in_res_cnt;
+ 	}
+ 
+ 	if (evt_struct->cmnd_done)
+@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
+ {
+ 	struct srp_cmd *srp_cmd;
+ 	struct srp_event_struct *evt_struct;
+-	struct indirect_descriptor *indirect;
++	struct srp_indirect_buf *indirect;
+ 	struct ibmvscsi_host_data *hostdata =
+ 		(struct ibmvscsi_host_data *)&cmnd->device->host->hostdata;
+ 	u16 lun = lun_from_dev(cmnd->device);
++	u8 out_fmt, in_fmt;
+ 
+ 	evt_struct = get_event_struct(&hostdata->pool);
+ 	if (!evt_struct)
+@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
+ 
+ 	/* Set up the actual SRP IU */
+ 	srp_cmd = &evt_struct->iu.srp.cmd;
+-	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
+-	srp_cmd->type = SRP_CMD_TYPE;
++	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
++	srp_cmd->opcode = SRP_CMD;
+ 	memcpy(srp_cmd->cdb, cmnd->cmnd, sizeof(cmnd->cmnd));
+ 	srp_cmd->lun = ((u64) lun) << 48;
+ 
+@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
+ 	evt_struct->cmnd_done = done;
+ 
+ 	/* Fix up dma address of the buffer itself */
+-	indirect = (struct indirect_descriptor *)srp_cmd->additional_data;
+-	if (((srp_cmd->data_out_format == SRP_INDIRECT_BUFFER) ||
+-	    (srp_cmd->data_in_format == SRP_INDIRECT_BUFFER)) &&
+-	    (indirect->head.virtual_address == 0)) {
+-		indirect->head.virtual_address = evt_struct->crq.IU_data_ptr +
+-		    offsetof(struct srp_cmd, additional_data) +
+-		    offsetof(struct indirect_descriptor, list);
++	indirect = (struct srp_indirect_buf *) srp_cmd->add_data;
++	out_fmt = srp_cmd->buf_fmt >> 4;
++	in_fmt = srp_cmd->buf_fmt & ((1U << 4) - 1);
++	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
++	     out_fmt == SRP_DATA_DESC_INDIRECT) &&
++	    indirect->table_desc.va == 0) {
++		indirect->table_desc.va = evt_struct->crq.IU_data_ptr +
++			offsetof(struct srp_cmd, add_data) +
++			offsetof(struct srp_indirect_buf, desc_list);
+ 	}
+ 
+ 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
+@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
+ static void login_rsp(struct srp_event_struct *evt_struct)
+ {
+ 	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
+-	switch (evt_struct->xfer_iu->srp.generic.type) {
+-	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
++	switch (evt_struct->xfer_iu->srp.login_rsp.opcode) {
++	case SRP_LOGIN_RSP:	/* it worked! */
+ 		break;
+-	case SRP_LOGIN_REJ_TYPE:	/* refused! */
++	case SRP_LOGIN_REJ:	/* refused! */
+ 		printk(KERN_INFO "ibmvscsi: SRP_LOGIN_REJ reason %u\n",
+ 		       evt_struct->xfer_iu->srp.login_rej.reason);
+ 		/* Login failed.  */
+@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
+ 	default:
+ 		printk(KERN_ERR
+ 		       "ibmvscsi: Invalid login response typecode 0x%02x!\n",
+-		       evt_struct->xfer_iu->srp.generic.type);
++		       evt_struct->xfer_iu->srp.login_rsp.opcode);
+ 		/* Login failed.  */
+ 		atomic_set(&hostdata->request_limit, -1);
+ 		return;
+@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
+ 
+ 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
+ 
+-	if (evt_struct->xfer_iu->srp.login_rsp.request_limit_delta >
++	if (evt_struct->xfer_iu->srp.login_rsp.req_lim_delta >
+ 	    (max_requests - 2))
+-		evt_struct->xfer_iu->srp.login_rsp.request_limit_delta =
++		evt_struct->xfer_iu->srp.login_rsp.req_lim_delta =
+ 		    max_requests - 2;
+ 
+ 	/* Now we know what the real request-limit is */
+ 	atomic_set(&hostdata->request_limit,
+-		   evt_struct->xfer_iu->srp.login_rsp.request_limit_delta);
++		   evt_struct->xfer_iu->srp.login_rsp.req_lim_delta);
+ 
+ 	hostdata->host->can_queue =
+-	    evt_struct->xfer_iu->srp.login_rsp.request_limit_delta - 2;
++	    evt_struct->xfer_iu->srp.login_rsp.req_lim_delta - 2;
+ 
+ 	if (hostdata->host->can_queue < 1) {
+ 		printk(KERN_ERR "ibmvscsi: Invalid request_limit_delta\n");
+@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
+ 
+ 	login = &evt_struct->iu.srp.login_req;
+ 	memset(login, 0x00, sizeof(struct srp_login_req));
+-	login->type = SRP_LOGIN_REQ_TYPE;
+-	login->max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
+-	login->required_buffer_formats = 0x0006;
++	login->opcode = SRP_LOGIN_REQ;
++	login->req_it_iu_len = sizeof(union srp_iu);
++	login->req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
+ 	
+ 	/* Start out with a request limit of 1, since this is negotiated in
+ 	 * the login request we are just sending
+@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 	
+ 	/* Set up an abort SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt->opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt->lun = ((u64) lun) << 48;
+-	tsk_mgmt->task_mgmt_flags = 0x01;	/* ABORT TASK */
+-	tsk_mgmt->managed_task_tag = (u64) found_evt;
++	tsk_mgmt->tsk_mgmt_func = SRP_TSK_ABORT_TASK;
++	tsk_mgmt->task_tag = (u64) found_evt;
+ 
+ 	printk(KERN_INFO "ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n",
+-	       tsk_mgmt->lun, tsk_mgmt->managed_task_tag);
++	       tsk_mgmt->lun, tsk_mgmt->task_tag);
+ 
+ 	evt->sync_srp = &srp_rsp;
+ 	init_completion(&evt->comp);
+@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
+ 	wait_for_completion(&evt->comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       "ibmvscsi: abort bad SRP RSP type %d\n",
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+ 	if (rsp_rc) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+-		       "ibmvscsi: abort code %d for task tag 0x%lx\n",
++			       "ibmvscsi: abort code %d for task tag 0x%lx\n",
+ 			       rsp_rc,
+-			       tsk_mgmt->managed_task_tag);
++			       tsk_mgmt->task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
+ 		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
+ 		printk(KERN_INFO
+ 		       "ibmvscsi: aborted task tag 0x%lx completed\n",
+-		       tsk_mgmt->managed_task_tag);
++		       tsk_mgmt->task_tag);
+ 		return SUCCESS;
+ 	}
+ 
+ 	printk(KERN_INFO
+ 	       "ibmvscsi: successfully aborted task tag 0x%lx\n",
+-	       tsk_mgmt->managed_task_tag);
++	       tsk_mgmt->task_tag);
+ 
+ 	cmd->result = (DID_ABORT << 16);
+ 	list_del(&found_evt->list);
+@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
+ 
+ 	/* Set up a lun reset SRP command */
+ 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
+-	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
++	tsk_mgmt->opcode = SRP_TSK_MGMT;
+ 	tsk_mgmt->lun = ((u64) lun) << 48;
+-	tsk_mgmt->task_mgmt_flags = 0x08;	/* LUN RESET */
++	tsk_mgmt->tsk_mgmt_func = SRP_TSK_LUN_RESET;
+ 
+ 	printk(KERN_INFO "ibmvscsi: resetting device. lun 0x%lx\n",
+ 	       tsk_mgmt->lun);
+@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
+ 	wait_for_completion(&evt->comp);
+ 
+ 	/* make sure we got a good response */
+-	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
++	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       "ibmvscsi: reset bad SRP RSP type %d\n",
+-			       srp_rsp.srp.generic.type);
++			       srp_rsp.srp.rsp.opcode);
+ 		return FAILED;
+ 	}
+ 
+-	if (srp_rsp.srp.rsp.rspvalid)
+-		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
++	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
++		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
+ 	else
+ 		rsp_rc = srp_rsp.srp.rsp.status;
+ 
+@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
+ 		if (printk_ratelimit())
+ 			printk(KERN_WARNING 
+ 			       "ibmvscsi: reset code %d for task tag 0x%lx\n",
+-		       rsp_rc,
+-			       tsk_mgmt->managed_task_tag);
++			       rsp_rc, tsk_mgmt->task_tag);
+ 		return FAILED;
+ 	}
+ 
+@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
+ 	}
+ 
+ 	if (crq->format == VIOSRP_SRP_FORMAT)
+-		atomic_add(evt_struct->xfer_iu->srp.rsp.request_limit_delta,
++		atomic_add(evt_struct->xfer_iu->srp.rsp.req_lim_delta,
+ 			   &hostdata->request_limit);
+ 
+ 	if (evt_struct->done)
+diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
+index 4550d71..5c6d935 100644
+--- a/drivers/scsi/ibmvscsi/ibmvscsi.h
++++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
+@@ -68,7 +68,7 @@ struct srp_event_struct {
+ 	void (*cmnd_done) (struct scsi_cmnd *);
+ 	struct completion comp;
+ 	union viosrp_iu *sync_srp;
+-	struct memory_descriptor *ext_list;
++	struct srp_direct_buf *ext_list;
+ 	dma_addr_t ext_list_token;
+ };
+ 
+diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+index f47dd87..58aa530 100644
+--- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
++++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
+@@ -34,7 +34,6 @@
+ #include <linux/dma-mapping.h>
+ #include <linux/interrupt.h>
+ #include "ibmvscsi.h"
+-#include "srp.h"
+ 
+ static char partition_name[97] = "UNKNOWN";
+ static unsigned int partition_number = -1;
+diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
+index 6a6bba8..90f1a61 100644
+--- a/drivers/scsi/ibmvscsi/viosrp.h
++++ b/drivers/scsi/ibmvscsi/viosrp.h
+@@ -33,7 +33,22 @@
+ /*****************************************************************************/
+ #ifndef VIOSRP_H
+ #define VIOSRP_H
+-#include "srp.h"
++#include <scsi/srp.h>
++
++#define SRP_VERSION "16.a"
++#define SRP_MAX_IU_LEN	256
++
++union srp_iu {
++	struct srp_login_req login_req;
++	struct srp_login_rsp login_rsp;
++	struct srp_login_rej login_rej;
++	struct srp_i_logout i_logout;
++	struct srp_t_logout t_logout;
++	struct srp_tsk_mgmt tsk_mgmt;
++	struct srp_cmd cmd;
++	struct srp_rsp rsp;
++	u8 reserved[SRP_MAX_IU_LEN];
++};
+ 
+ enum viosrp_crq_formats {
+ 	VIOSRP_SRP_FORMAT = 0x01,
+-- 
+1.1.3

Added: trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt
===================================================================
--- trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0002-ibmvscsi-remove-drivers-scsi-ibmvscsi-srp.h.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,246 @@
+Subject: [PATCH] ibmvscsi: remove drivers/scsi/ibmvscsi/srp.h
+From: FUJITA <fujita.tomonori at lab.ntt.co.jp>
+Date: 1143377151 +0900
+
+---
+
+ drivers/scsi/ibmvscsi/srp.h |  227 -------------------------------------------
+ 1 files changed, 0 insertions(+), 227 deletions(-)
+ delete mode 100644 drivers/scsi/ibmvscsi/srp.h
+
+acbd74e89dc7bcf4e2596800e46a19378db44641
+diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
+deleted file mode 100644
+index 7d8e4c4..0000000
+--- a/drivers/scsi/ibmvscsi/srp.h
++++ /dev/null
+@@ -1,227 +0,0 @@
+-/*****************************************************************************/
+-/* srp.h -- SCSI RDMA Protocol definitions                                   */
+-/*                                                                           */
+-/* Written By: Colin Devilbis, IBM Corporation                               */
+-/*                                                                           */
+-/* Copyright (C) 2003 IBM Corporation                                        */
+-/*                                                                           */
+-/* This program is free software; you can redistribute it and/or modify      */
+-/* it under the terms of the GNU General Public License as published by      */
+-/* the Free Software Foundation; either version 2 of the License, or         */
+-/* (at your option) any later version.                                       */
+-/*                                                                           */
+-/* This program is distributed in the hope that it will be useful,           */
+-/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
+-/* GNU General Public License for more details.                              */
+-/*                                                                           */
+-/* You should have received a copy of the GNU General Public License         */
+-/* along with this program; if not, write to the Free Software               */
+-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+-/*                                                                           */
+-/*                                                                           */
+-/* This file contains structures and definitions for the SCSI RDMA Protocol  */
+-/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
+-/* file was based on the 16a version of the standard                         */
+-/*                                                                           */
+-/*****************************************************************************/
+-#ifndef SRP_H
+-#define SRP_H
+-
+-#define SRP_VERSION "16.a"
+-
+-#define PACKED __attribute__((packed))
+-
+-enum srp_types {
+-	SRP_LOGIN_REQ_TYPE = 0x00,
+-	SRP_LOGIN_RSP_TYPE = 0xC0,
+-	SRP_LOGIN_REJ_TYPE = 0xC2,
+-	SRP_I_LOGOUT_TYPE = 0x03,
+-	SRP_T_LOGOUT_TYPE = 0x80,
+-	SRP_TSK_MGMT_TYPE = 0x01,
+-	SRP_CMD_TYPE = 0x02,
+-	SRP_RSP_TYPE = 0xC1,
+-	SRP_CRED_REQ_TYPE = 0x81,
+-	SRP_CRED_RSP_TYPE = 0x41,
+-	SRP_AER_REQ_TYPE = 0x82,
+-	SRP_AER_RSP_TYPE = 0x42
+-};
+-
+-enum srp_descriptor_formats {
+-	SRP_NO_BUFFER = 0x00,
+-	SRP_DIRECT_BUFFER = 0x01,
+-	SRP_INDIRECT_BUFFER = 0x02
+-};
+-
+-struct memory_descriptor {
+-	u64 virtual_address;
+-	u32 memory_handle;
+-	u32 length;
+-};
+-
+-struct indirect_descriptor {
+-	struct memory_descriptor head;
+-	u32 total_length;
+-	struct memory_descriptor list[1] PACKED;
+-};
+-
+-struct srp_generic {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_login_req {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 max_requested_initiator_to_target_iulen;
+-	u32 reserved2;
+-	u16 required_buffer_formats;
+-	u8 reserved3:6;
+-	u8 multi_channel_action:2;
+-	u8 reserved4;
+-	u32 reserved5;
+-	u8 initiator_port_identifier[16];
+-	u8 target_port_identifier[16];
+-};
+-
+-struct srp_login_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 max_initiator_to_target_iulen;
+-	u32 max_target_to_initiator_iulen;
+-	u16 supported_buffer_formats;
+-	u8 reserved2:6;
+-	u8 multi_channel_result:2;
+-	u8 reserved3;
+-	u8 reserved4[24];
+-};
+-
+-struct srp_login_rej {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-	u64 reserved2;
+-	u16 supported_buffer_formats;
+-	u8 reserved3[6];
+-};
+-
+-struct srp_i_logout {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_t_logout {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 reason;
+-	u64 tag;
+-};
+-
+-struct srp_tsk_mgmt {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4;
+-	u8 task_mgmt_flags;
+-	u8 reserved5;
+-	u64 managed_task_tag;
+-	u64 reserved6;
+-};
+-
+-struct srp_cmd {
+-	u8 type;
+-	u32 reserved1 PACKED;
+-	u8 data_out_format:4;
+-	u8 data_in_format:4;
+-	u8 data_out_count;
+-	u8 data_in_count;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun PACKED;
+-	u8 reserved3;
+-	u8 reserved4:5;
+-	u8 task_attribute:3;
+-	u8 reserved5;
+-	u8 additional_cdb_len;
+-	u8 cdb[16];
+-	u8 additional_data[0x100 - 0x30];
+-};
+-
+-struct srp_rsp {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u16 reserved2;
+-	u8 reserved3:2;
+-	u8 diunder:1;
+-	u8 diover:1;
+-	u8 dounder:1;
+-	u8 doover:1;
+-	u8 snsvalid:1;
+-	u8 rspvalid:1;
+-	u8 status;
+-	u32 data_in_residual_count;
+-	u32 data_out_residual_count;
+-	u32 sense_data_list_length;
+-	u32 response_data_list_length;
+-	u8 sense_and_response_data[18];
+-};
+-
+-struct srp_cred_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-};
+-
+-struct srp_cred_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-struct srp_aer_req {
+-	u8 type;
+-	u8 reserved1[3];
+-	u32 request_limit_delta;
+-	u64 tag;
+-	u32 reserved2;
+-	u64 lun;
+-	u32 sense_data_list_length;
+-	u32 reserved3;
+-	u8 sense_data[20];
+-};
+-
+-struct srp_aer_rsp {
+-	u8 type;
+-	u8 reserved1[7];
+-	u64 tag;
+-};
+-
+-union srp_iu {
+-	struct srp_generic generic;
+-	struct srp_login_req login_req;
+-	struct srp_login_rsp login_rsp;
+-	struct srp_login_rej login_rej;
+-	struct srp_i_logout i_logout;
+-	struct srp_t_logout t_logout;
+-	struct srp_tsk_mgmt tsk_mgmt;
+-	struct srp_cmd cmd;
+-	struct srp_rsp rsp;
+-	struct srp_cred_req cred_req;
+-	struct srp_cred_rsp cred_rsp;
+-	struct srp_aer_req aer_req;
+-	struct srp_aer_rsp aer_rsp;
+-};
+-
+-#endif
+-- 
+1.1.3

Added: trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt
===================================================================
--- trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0003-scsi-tgt-move-scsi_host_get-put_command.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,375 @@
+Subject: [PATCH] scsi tgt: move scsi_host_get/put_command
+
+This patch moves scsi_host_get_command and scsi_host_put_command to
+scsi_tgt_lib.c from scsi.c
+
+A target driver allocates scsi_cmnd structure via
+scsi_host_get_command, then pass it to tgt core via
+scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
+needs to allocate scsi_tgt_cmd structure (for tgt specific data).
+Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
+target drivers.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+
+---
+
+ drivers/scsi/scsi.c         |  102 ++++------------------------------------
+ drivers/scsi/scsi_tgt_lib.c |  109 +++++++++++++++++++++++++++++++++++++------
+ include/scsi/scsi_cmnd.h    |    6 +-
+ include/scsi/scsi_tgt.h     |    4 ++
+ 4 files changed, 112 insertions(+), 109 deletions(-)
+
+b8f2574dbd844ac43602d9fa74e6196027528c63
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index 9c22465..1d2fbe0 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -212,8 +212,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -234,58 +233,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
+-
+-/*
+- * Function:	scsi_host_get_command()
+- *
+- * Purpose:	Allocate and setup a scsi command block and blk request
+- *
+- * Arguments:	shost	- scsi host
+- *		data_dir - dma data dir
+- *		gfp_mask- allocator flags
+- *
+- * Returns:	The allocated scsi command structure.
+- *
+- * This should be called by target LLDs to get a command.
+- */
+-struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
+-					enum dma_data_direction data_dir,
+-					gfp_t gfp_mask)
+-{
+-	int write = (data_dir == DMA_TO_DEVICE);
+-	struct request *rq;
+-	struct scsi_cmnd *cmd;
+-
+-	/* Bail if we can't get a reference to the device */
+-	if (!get_device(&shost->shost_gendev))
+-		return NULL;
+-
+-	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
+-	if (!rq)
+-		goto put_dev;
+-
+-	cmd = __scsi_get_command(shost, gfp_mask);
+-	if (!cmd)
+-		goto release_rq;
+-
+-	memset(cmd, 0, sizeof(*cmd));
+-	cmd->sc_data_direction = data_dir;
+-	cmd->jiffies_at_alloc = jiffies;
+-	cmd->request = rq;
+-
+-	rq->special = cmd;
+-	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
+-
+-	return cmd;
+-
+-release_rq:
+-	blk_put_request(rq);
+-put_dev:
+-	put_device(&shost->shost_gendev);
+-	return NULL;
+-
+-}
+-EXPORT_SYMBOL_GPL(scsi_host_get_command);
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -322,25 +270,12 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&dev->sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
+-/*
+- * Function:	scsi_host_put_command()
+- *
+- * Purpose:	Free a scsi command block
+- *
+- * Arguments:	shost	- scsi host
+- * 		cmd	- command block to free
+- *
+- * Returns:	Nothing.
+- *
+- * Notes:	The command must not belong to any lists.
+- */
+-void scsi_host_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd)
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
+ {
+-	struct request_queue *q = shost->uspace_req_q;
+-	struct request *rq = cmd->request;
+ 	unsigned long flags;
+ 
+ 	/* changing locks here, don't need to restore the irq state */
+@@ -349,18 +284,14 @@ void scsi_host_put_command(struct Scsi_H
+ 		list_add(&cmd->list, &shost->free_list);
+ 		cmd = NULL;
+ 	}
+-	spin_unlock(&shost->free_list_lock);
+-
+-	spin_lock(q->queue_lock);
+-	__blk_put_request(q, rq);
+-	spin_unlock_irqrestore(q->queue_lock, flags);
++	spin_unlock_irqrestore(&shost->free_list_lock, flags);
+ 
+ 	if (likely(cmd != NULL))
+ 		kmem_cache_free(shost->cmd_pool->slab, cmd);
+ 
+-	put_device(&shost->shost_gendev);
++	put_device(dev);
+ }
+-EXPORT_SYMBOL_GPL(scsi_host_put_command);
++EXPORT_SYMBOL(__scsi_put_command);
+ 
+ /*
+  * Function:	scsi_put_command()
+@@ -376,26 +307,15 @@ EXPORT_SYMBOL_GPL(scsi_host_put_command)
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd->device;
+-	struct Scsi_Host *shost = sdev->host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&cmd->device->list_lock, flags);
+ 	BUG_ON(list_empty(&cmd->list));
+ 	list_del_init(&cmd->list);
+-	spin_unlock(&cmd->device->list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&shost->free_list_lock);
+-	if (unlikely(list_empty(&shost->free_list))) {
+-		list_add(&cmd->list, &shost->free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&shost->free_list_lock, flags);
+-
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost->cmd_pool->slab, cmd);
++	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
+ 
+-	put_device(&sdev->sdev_gendev);
++	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index aea3e4d..e82340c 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -70,6 +70,95 @@ struct scsi_tgt_queuedata {
+ 	struct list_head cmd_req;
+ };
+ 
++/*
++ * Function:	scsi_host_get_command()
++ *
++ * Purpose:	Allocate and setup a scsi command block and blk request
++ *
++ * Arguments:	shost	- scsi host
++ *		data_dir - dma data dir
++ *		gfp_mask- allocator flags
++ *
++ * Returns:	The allocated scsi command structure.
++ *
++ * This should be called by target LLDs to get a command.
++ */
++struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
++					enum dma_data_direction data_dir,
++					gfp_t gfp_mask)
++{
++	int write = (data_dir == DMA_TO_DEVICE);
++	struct request *rq;
++	struct scsi_cmnd *cmd;
++	struct scsi_tgt_cmd *tcmd;
++
++	/* Bail if we can't get a reference to the device */
++	if (!get_device(&shost->shost_gendev))
++		return NULL;
++
++	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
++	if (!tcmd)
++		goto put_dev;
++
++	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
++	if (!rq)
++		goto free_tcmd;
++
++	cmd = __scsi_get_command(shost, gfp_mask);
++	if (!cmd)
++		goto release_rq;
++
++	memset(cmd, 0, sizeof(*cmd));
++	cmd->sc_data_direction = data_dir;
++	cmd->jiffies_at_alloc = jiffies;
++	cmd->request = rq;
++
++	rq->special = cmd;
++	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
++	rq->end_io_data = tcmd;
++
++	return cmd;
++
++release_rq:
++	blk_put_request(rq);
++free_tcmd:
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++put_dev:
++	put_device(&shost->shost_gendev);
++	return NULL;
++
++}
++EXPORT_SYMBOL_GPL(scsi_host_get_command);
++
++/*
++ * Function:	scsi_host_put_command()
++ *
++ * Purpose:	Free a scsi command block
++ *
++ * Arguments:	shost	- scsi host
++ * 		cmd	- command block to free
++ *
++ * Returns:	Nothing.
++ *
++ * Notes:	The command must not belong to any lists.
++ */
++static void scsi_host_put_command(struct Scsi_Host *shost,
++				  struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = shost->uspace_req_q;
++	struct request *rq = cmd->request;
++	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
++	unsigned long flags;
++
++	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
++
++	spin_lock_irqsave(q->queue_lock, flags);
++	__blk_put_request(q, rq);
++	spin_unlock_irqrestore(q->queue_lock, flags);
++
++	__scsi_put_command(shost, cmd, &shost->shost_gendev);
++}
++
+ static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
+ {
+ 	struct bio *bio;
+@@ -110,7 +199,6 @@ static void scsi_tgt_cmd_destroy(void *d
+ 		cmd->request->flags &= ~1UL;
+ 
+ 	scsi_unmap_user_pages(tcmd);
+-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+ 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
+ }
+ 
+@@ -177,13 +265,13 @@ out:
+ 		goto retry;
+ }
+ 
+-/**
++/*
+  * scsi_tgt_alloc_queue - setup queue used for message passing
+  * shost: scsi host
+  *
+  * This should be called by the LLD after host allocation.
+  * And will be released when the host is released.
+- **/
++ */
+ int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
+ {
+ 	struct scsi_tgt_queuedata *queuedata;
+@@ -244,28 +332,19 @@ struct Scsi_Host *scsi_tgt_cmd_to_host(s
+ }
+ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+ 
+-/**
++/*
+  * scsi_tgt_queue_command - queue command for userspace processing
+  * @cmd:	scsi command
+  * @scsilun:	scsi lun
+  * @noblock:	set to nonzero if the command should be queued
+- **/
++ */
+ int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+ 			   u64 tag)
+ {
+ 	struct request_queue *q = cmd->request->q;
+ 	struct scsi_tgt_queuedata *qdata = q->queuedata;
+ 	unsigned long flags;
+-	struct scsi_tgt_cmd *tcmd;
+-
+-	/*
+-	 * It would be better to allocate scsi_tgt_cmd structure in
+-	 * scsi_host_get_command and not to fail due to OOM.
+-	 */
+-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+-	if (!tcmd)
+-		return -ENOMEM;
+-	cmd->request->end_io_data = tcmd;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+ 
+ 	bio_list_init(&tcmd->xfer_list);
+ 	bio_list_init(&tcmd->xfer_done_list);
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 51156c7..c822bc2 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -150,11 +150,11 @@ struct scsi_cmnd {
+ #define SCSI_STATE_MLQUEUE         0x100b
+ 
+ 
+-extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
+-					       enum dma_data_direction, gfp_t);
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
+-extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
+ extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+index 2d65be7..61e8ee9 100644
+--- a/include/scsi/scsi_tgt.h
++++ b/include/scsi/scsi_tgt.h
+@@ -2,6 +2,8 @@
+  * SCSI target definitions
+  */
+ 
++#include <linux/dma-mapping.h>
++
+ struct Scsi_Host;
+ struct scsi_cmnd;
+ struct scsi_lun;
+@@ -11,3 +13,5 @@ extern int scsi_tgt_alloc_queue(struct S
+ extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
+ extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
+ 				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
+-- 
+1.1.3

Added: trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt
===================================================================
--- trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0004-scsi-target-replace-netlink-with-shared-memory-between-kernel-and-user-spaces.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,554 @@
+Subject: [PATCH] scsi target: replace netlink with shared memory between kernel and user spaces
+
+The user-space damoen and tgt kernel module need to exhange mmapped
+addresses. netlink cannot do that. We need two-way kernel/user
+high-performance interface, however, mainline kernel provides no
+standard interface like that.
+
+This patch replaces netlink shared memory between kernel and user
+spaces. The user-space damoen and tgt kernel module creates shared
+memory via mmap and use it like ring buffer. poll (kernel to user) and
+write (user to kernel) system calls are used for notification.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+
+---
+
+ drivers/scsi/scsi_tgt_if.c   |  311 +++++++++++++++++++++++++++---------------
+ drivers/scsi/scsi_tgt_lib.c  |   10 +
+ drivers/scsi/scsi_tgt_priv.h |    6 -
+ include/linux/netlink.h      |    1 
+ include/scsi/scsi_tgt_if.h   |   19 +--
+ 5 files changed, 216 insertions(+), 131 deletions(-)
+
+cd29acfca7cdeb8c351db14af357207e9dcb17f3
+diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c
+index 37e0feb..c4c5bdb 100644
+--- a/drivers/scsi/scsi_tgt_if.c
++++ b/drivers/scsi/scsi_tgt_if.c
+@@ -21,7 +21,6 @@
+  */
+ #include <linux/blkdev.h>
+ #include <linux/file.h>
+-#include <linux/netlink.h>
+ #include <net/tcp.h>
+ #include <scsi/scsi.h>
+ #include <scsi/scsi_cmnd.h>
+@@ -32,87 +31,129 @@
+ 
+ #include "scsi_tgt_priv.h"
+ 
+-static int tgtd_pid;
+-static struct sock *nl_sk;
++struct rbuf {
++	u32 idx;
++	u32 nr_entry;
++	int entry_size;
++	char *buf;
++	int buf_size;
++	spinlock_t lock;
++};
++
++static int chrdev;
++static struct rbuf txbuf, rxbuf;
++static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
+ 
+-static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
+-			  pid_t pid)
++static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
++{
++	u32 offset = (idx & (rbuf->nr_entry - 1)) * rbuf->entry_size;
++	return (struct rbuf_hdr *) (rbuf->buf + offset);
++}
++
++static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
++{
++	int i;
++
++	esize += sizeof(struct rbuf_hdr);
++	rbuf->idx = 0;
++	rbuf->entry_size = esize;
++	rbuf->buf = buf;
++	spin_lock_init(&rbuf->lock);
++
++	bsize /= esize;
++	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
++		;
++	rbuf->nr_entry = 1 << i;
++}
++
++static int send_event_rsp(u32 type, struct tgt_event *p)
+ {
+ 	struct tgt_event *ev;
+-	struct nlmsghdr *nlh;
+-	struct sk_buff *skb;
+-	uint32_t len;
+-
+-	len = NLMSG_SPACE(sizeof(*ev));
+-	skb = alloc_skb(len, flags);
+-	if (!skb)
+-		return -ENOMEM;
++	struct rbuf_hdr *hdr;
++	struct page *sp, *ep;
++	unsigned long flags;
++	int err = 0;
++
++	spin_lock_irqsave(&txbuf.lock, flags);
++
++	hdr = head_rbuf_hdr(&txbuf, txbuf.idx);
++	if (hdr->status)
++		err = 1;
++	else
++		txbuf.idx++;
+ 
+-	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
++	spin_unlock_irqrestore(&txbuf.lock, flags);
+ 
+-	ev = NLMSG_DATA(nlh);
++	if (err)
++		return err;
++
++	ev = (struct tgt_event *) hdr->data;
+ 	memcpy(ev, p, sizeof(*ev));
++	ev->type = type;
++	hdr->status = 1;
++	mb();
++
++	sp = virt_to_page(hdr);
++	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
++	for (;sp <= ep; sp++)
++		flush_dcache_page(sp);
++
++	wake_up_interruptible(&tgt_poll_wait);
+ 
+-	return netlink_unicast(nl_sk, skb, pid, 0);
++	return 0;
+ }
+ 
+-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
+-			 gfp_t flags)
++int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
+ {
+ 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
+-	struct sk_buff *skb;
+-	struct nlmsghdr *nlh;
+-	struct tgt_event *ev;
+-	int err, len;
++	struct tgt_event ev;
++	int err;
+ 
+-	len = NLMSG_SPACE(sizeof(*ev));
+-	/*
+-	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
+-	 */
+-	skb = alloc_skb(NLMSG_SPACE(len), flags);
+-	if (!skb)
+-		return -ENOMEM;
+-
+-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
+-			  len - sizeof(*nlh), 0);
+-
+-	ev = NLMSG_DATA(nlh);
+-	ev->k.cmd_req.host_no = shost->host_no;
+-	ev->k.cmd_req.cid = cmd->request->tag;
+-	ev->k.cmd_req.data_len = cmd->request_bufflen;
+-	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
+-	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
+-	ev->k.cmd_req.attribute = cmd->tag;
+-	ev->k.cmd_req.tag = tag;
+-
+-	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev->k.cmd_req.cid,
+-		ev->k.cmd_req.data_len, cmd->tag,
+-		(unsigned long long) ev->k.cmd_req.tag);
+-
+-	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
+-	if (err < 0)
+-		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
+-		       err);
++	memset(&ev, 0, sizeof(ev));
++	ev.k.cmd_req.host_no = shost->host_no;
++	ev.k.cmd_req.cid = cmd->request->tag;
++	ev.k.cmd_req.data_len = cmd->request_bufflen;
++	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
++	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
++	ev.k.cmd_req.attribute = cmd->tag;
++	ev.k.cmd_req.tag = tag;
++
++	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
++		ev.k.cmd_req.data_len, cmd->tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
+ 	return err;
+ }
+ 
+-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
+ {
+ 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
+ 	struct tgt_event ev;
++	int err;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	ev.k.cmd_done.host_no = shost->host_no;
+ 	ev.k.cmd_done.cid = cmd->request->tag;
+ 	ev.k.cmd_done.result = cmd->result;
+ 
+-	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
++	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
++		ev.k.cmd_req.data_len, cmd->tag,
++		(unsigned long long) ev.k.cmd_req.tag);
++
++	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++	return err;
+ }
+ 
+ int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+ 				  struct scsi_lun *scsilun, void *data)
+ {
+ 	struct tgt_event ev;
++	int err;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	ev.k.tsk_mgmt_req.host_no = host_no;
+@@ -124,23 +165,18 @@ int scsi_tgt_uspace_send_tsk_mgmt(int ho
+ 	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
+ 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
+ 
+-	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev, GFP_KERNEL, tgtd_pid);
++	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev);
++	if (err)
++		eprintk("tx buf is full, could not send\n");
++	return err;
+ }
+ 
+-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
++static int event_recv_msg(struct tgt_event *ev)
+ {
+-	struct tgt_event *ev = NLMSG_DATA(nlh);
+ 	int err = 0;
+ 
+-	dprintk("%d %d %d\n", nlh->nlmsg_type,
+-		nlh->nlmsg_pid, current->pid);
+-
+-	switch (nlh->nlmsg_type) {
+-	case TGT_UEVENT_REQ:
+-		tgtd_pid = NETLINK_CREDS(skb)->pid;
+-		break;
++	switch (ev->type) {
+ 	case TGT_UEVENT_CMD_RSP:
+-		/* TODO: handle multiple cmds in one event */
+ 		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
+ 					   ev->u.cmd_rsp.cid,
+ 					   ev->u.cmd_rsp.result,
+@@ -154,79 +190,126 @@ static int event_recv_msg(struct sk_buff
+ 					       ev->u.tsk_mgmt_rsp.result);
+ 		break;
+ 	default:
+-		eprintk("unknown type %d\n", nlh->nlmsg_type);
++		eprintk("unknown type %d\n", ev->type);
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err;
+ }
+ 
+-static int event_recv_skb(struct sk_buff *skb)
++static ssize_t tgt_write(struct file *file, const char __user * buffer,
++			 size_t count, loff_t * ppos)
+ {
+-	int err;
+-	uint32_t rlen;
+-	struct nlmsghdr	*nlh;
+-	struct tgt_event ev;
++	struct rbuf_hdr *hdr;
++	struct tgt_event *ev;
++	struct page *sp, *ep;
+ 
+-	while (skb->len >= NLMSG_SPACE(0)) {
+-		nlh = (struct nlmsghdr *) skb->data;
+-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
+-			return 0;
+-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
+-		if (rlen > skb->len)
+-			rlen = skb->len;
+-		err = event_recv_msg(skb, nlh);
+-
+-		dprintk("%d %d\n", nlh->nlmsg_type, err);
+-		/*
+-		 * TODO for passthru commands the lower level should
+-		 * probably handle the result or we should modify this
+-		 */
+-		switch (nlh->nlmsg_type) {
+-		case TGT_UEVENT_CMD_RSP:
+-		case TGT_UEVENT_TSK_MGMT_RSP:
+-			break;
+-		default:
+-			memset(&ev, 0, sizeof(ev));
+-			ev.k.event_rsp.err = err;
+-			send_event_rsp(TGT_KEVENT_RSP, &ev,
+-				       GFP_KERNEL | __GFP_NOFAIL,
+-					nlh->nlmsg_pid);
+-		}
+-		skb_pull(skb, rlen);
+-	}
+-	return 0;
++retry:
++	hdr = head_rbuf_hdr(&rxbuf, rxbuf.idx);
++
++	sp = virt_to_page(hdr);
++	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
++	for (;sp <= ep; sp++)
++		flush_dcache_page(sp);
++
++	if (!hdr->status)
++		return count;
++
++	rxbuf.idx++;
++	ev = (struct tgt_event *) hdr->data;
++	event_recv_msg(ev);
++	hdr->status = 0;
++
++	goto retry;
+ }
+ 
+-static void event_recv(struct sock *sk, int length)
++static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
+ {
+-	struct sk_buff *skb;
++	struct rbuf_hdr *hdr;
++	unsigned long flags;
++	unsigned int mask = 0;
+ 
+-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
+-		if (NETLINK_CREDS(skb)->uid) {
+-			skb_pull(skb, skb->len);
+-			kfree_skb(skb);
+-			continue;
+-		}
++	poll_wait(file, &tgt_poll_wait, wait);
++
++	spin_lock_irqsave(&txbuf.lock, flags);
+ 
+-		if (event_recv_skb(skb) && skb->len)
+-			skb_queue_head(&sk->sk_receive_queue, skb);
+-		else
+-			kfree_skb(skb);
++	hdr = head_rbuf_hdr(&txbuf, txbuf.idx - 1);
++	if (hdr->status)
++		mask |= POLLIN | POLLRDNORM;
++
++	spin_unlock_irqrestore(&txbuf.lock, flags);
++
++	return mask;
++}
++
++static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
++{
++	unsigned long size, addr;
++	struct page *page;
++	int err, i;
++
++	if (vma->vm_pgoff) {
++		eprintk("bug\n");
++		return -EINVAL;
++	}
++
++	size = vma->vm_end - vma->vm_start;
++	if (size != TGT_RINGBUF_SIZE * 2) {
++		eprintk("%lu\n", size);
++		return -EINVAL;
++	}
++	addr = vma->vm_start;
++	page = virt_to_page(txbuf.buf);
++	for (i = 0; i < size >> PAGE_SHIFT; i++) {
++		err = vm_insert_page(vma, addr, page);
++		if (err) {
++			eprintk("%d %d %lu\n", err, i, addr);
++			return -EINVAL;
++		}
++		addr += PAGE_SIZE;
++		page++;
+ 	}
++
++	return 0;
+ }
+ 
++static struct file_operations tgt_fops = {
++	.owner	= THIS_MODULE,
++	.poll	= tgt_poll,
++	.write	= tgt_write,
++	.mmap	= tgt_mmap,
++};
++
+ void __exit scsi_tgt_if_exit(void)
+ {
+-	sock_release(nl_sk->sk_socket);
++	int order = long_log2(TGT_RINGBUF_SIZE * 2);
++
++	unregister_chrdev(chrdev, "tgt");
++	free_pages((unsigned long) txbuf.buf, order);
+ }
+ 
+ int __init scsi_tgt_if_init(void)
+ {
+-	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
+-				    THIS_MODULE);
+-	if (!nl_sk)
+-		return -ENOMEM;
++	u32 bsize = TGT_RINGBUF_SIZE;
++	int order;
++	char *buf;
++
++	chrdev = register_chrdev(0, "tgt", &tgt_fops);
++	if (chrdev < 0)
++		return chrdev;
++
++	order = long_log2((bsize * 2) >> PAGE_SHIFT);
++	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
++					order);
++	if (!buf)
++		goto free_dev;
++	rbuf_init(&txbuf, buf, bsize, sizeof(struct tgt_event));
++	rbuf_init(&rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
+ 
+ 	return 0;
++
++free_dev:
++	unregister_chrdev(chrdev, "tgt");
++
++	return -ENOMEM;
+ }
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index e82340c..7ebfbc0 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -246,7 +246,7 @@ retry:
+ 	tcmd = rq->end_io_data;
+ 	init_scsi_tgt_cmd(rq, tcmd);
+ 	cmd = rq->special;
+-	err = scsi_tgt_uspace_send(cmd, tcmd->lun, tcmd->tag, GFP_ATOMIC);
++	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
+ 	if (err < 0) {
+ 		eprintk("failed to send: %p %d\n", cmd, err);
+ 
+@@ -371,7 +371,7 @@ static void scsi_tgt_cmd_done(struct scs
+ 
+ 	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
+ 
+-	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
++	scsi_tgt_uspace_send_status(cmd);
+ 	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
+ 	queue_work(scsi_tgtd, &tcmd->work);
+ }
+@@ -402,7 +402,8 @@ static void scsi_tgt_transfer_response(s
+ 		return;
+ 
+ 	cmd->result = DID_BUS_BUSY << 16;
+-	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++	err = scsi_tgt_uspace_send_status(cmd);
++	if (err <= 0)
+ 		/* the eh will have to pick this up */
+ 		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
+ }
+@@ -501,7 +502,8 @@ static void scsi_tgt_data_transfer_done(
+ 	/* should we free resources here on error ? */
+ 	if (cmd->result) {
+ send_uspace_err:
+-		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
++		err = scsi_tgt_uspace_send_status(cmd);
++		if (err <= 0)
+ 			/* the tgt uspace eh will have to pick this up */
+ 			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
+ 		return;
+diff --git a/drivers/scsi/scsi_tgt_priv.h b/drivers/scsi/scsi_tgt_priv.h
+index 77a1d06..bd16a2c 100644
+--- a/drivers/scsi/scsi_tgt_priv.h
++++ b/drivers/scsi/scsi_tgt_priv.h
+@@ -14,9 +14,9 @@ do {								\
+ extern void scsi_tgt_if_exit(void);
+ extern int scsi_tgt_if_init(void);
+ 
+-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
+-				u64 tag, gfp_t flags);
+-extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
++extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
++				    u64 tag);
++extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
+ extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
+ 				unsigned long uaddr, u8 rw);
+ extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 9422ae5..c256ebe 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,7 +21,6 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
+-#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+index 63b2e3a..74392a9 100644
+--- a/include/scsi/scsi_tgt_if.h
++++ b/include/scsi/scsi_tgt_if.h
+@@ -24,25 +24,20 @@
+ 
+ enum tgt_event_type {
+ 	/* user -> kernel */
+-	TGT_UEVENT_REQ,
+ 	TGT_UEVENT_CMD_RSP,
+ 	TGT_UEVENT_TSK_MGMT_RSP,
+ 
+ 	/* kernel -> user */
+-	TGT_KEVENT_RSP,
+ 	TGT_KEVENT_CMD_REQ,
+ 	TGT_KEVENT_CMD_DONE,
+ 	TGT_KEVENT_TSK_MGMT_REQ,
+ };
+ 
+ struct tgt_event {
++	uint32_t type;
+ 	/* user-> kernel */
+ 	union {
+ 		struct {
+-			int type;
+-			int host_no;
+-		} event_req;
+-		struct {
+ 			int host_no;
+ 			uint32_t cid;
+ 			uint32_t len;
+@@ -60,9 +55,6 @@ struct tgt_event {
+ 	/* kernel -> user */
+ 	union {
+ 		struct {
+-			int err;
+-		} event_rsp;
+-		struct {
+ 			int host_no;
+ 			uint32_t cid;
+ 			uint32_t data_len;
+@@ -86,4 +78,13 @@ struct tgt_event {
+ 	} k;
+ 
+ } __attribute__ ((aligned (sizeof(uint64_t))));
++
++#define TGT_RINGBUF_SIZE (1UL << 16)
++
++struct rbuf_hdr {
++	uint32_t status;
++	uint32_t len;
++	uint64_t data[0];
++} __attribute__ ((aligned (sizeof(uint64_t))));
++
+ #endif
+-- 
+1.1.3

Added: trunk/patchset/0005-scsi-target-kill-target-command-list.txt
===================================================================
--- trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-07-26 04:57:44 UTC (rev 506)
+++ trunk/patchset/0005-scsi-target-kill-target-command-list.txt	2006-07-26 05:05:04 UTC (rev 507)
@@ -0,0 +1,197 @@
+Subject: [PATCH] scsi target: kill target command list
+
+scsi_tgt_queue_command just adds a command to the list and then kernel
+thread sends it to user space because scsi_tgt_queue_command cannot
+use netlink (LLDs might call scsi_tgt_queue_command in hardware context).
+
+Now we don't use netlink any more. So we can kill the list and
+scsi_tgt_queue_command just sends a command to user space.
+
+Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
+Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
+
+---
+
+ drivers/scsi/scsi_tgt_lib.c |  106 ++++++++++---------------------------------
+ 1 files changed, 24 insertions(+), 82 deletions(-)
+
+0cfeaa966f9a35068aaa2a72cd8a6a5ca7c8eec1
+diff --git a/drivers/scsi/scsi_tgt_lib.c b/drivers/scsi/scsi_tgt_lib.c
+index 7ebfbc0..5c66f10 100644
+--- a/drivers/scsi/scsi_tgt_lib.c
++++ b/drivers/scsi/scsi_tgt_lib.c
+@@ -45,11 +45,9 @@ struct scsi_tgt_cmd {
+ 	/* TODO replace the lists with a large bio */
+ 	struct bio_list xfer_done_list;
+ 	struct bio_list xfer_list;
+-	struct scsi_lun *lun;
+ 
+ 	struct list_head hash_list;
+ 	struct request *rq;
+-	u64 tag;
+ 
+ 	void *buffer;
+ 	unsigned bufflen;
+@@ -62,12 +60,6 @@ struct scsi_tgt_queuedata {
+ 	struct Scsi_Host *shost;
+ 	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
+ 	spinlock_t cmd_hash_lock;
+-
+-	struct work_struct uspace_send_work;
+-
+-	spinlock_t cmd_req_lock;
+-	struct mutex cmd_req_mutex;
+-	struct list_head cmd_req;
+ };
+ 
+ /*
+@@ -117,6 +109,10 @@ struct scsi_cmnd *scsi_host_get_command(
+ 	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
+ 	rq->end_io_data = tcmd;
+ 
++	bio_list_init(&tcmd->xfer_list);
++	bio_list_init(&tcmd->xfer_done_list);
++	tcmd->rq = rq;
++
+ 	return cmd;
+ 
+ release_rq:
+@@ -175,19 +171,27 @@ static void scsi_unmap_user_pages(struct
+ 	}
+ }
+ 
++static void cmd_hashlist_del(struct scsi_cmnd *cmd)
++{
++	struct request_queue *q = cmd->request->q;
++	struct scsi_tgt_queuedata *qdata = q->queuedata;
++	unsigned long flags;
++	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++
++	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
++	list_del(&tcmd->hash_list);
++	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++}
++
+ static void scsi_tgt_cmd_destroy(void *data)
+ {
+ 	struct scsi_cmnd *cmd = data;
+ 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+-	struct scsi_tgt_queuedata *qdata = cmd->request->q->queuedata;
+-	unsigned long flags;
+ 
+ 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
+ 		rq_data_dir(cmd->request));
+ 
+-	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+-	list_del(&tcmd->hash_list);
+-	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
++	cmd_hashlist_del(cmd);
+ 
+ 	/*
+ 	 * We must set rq->flags here because bio_map_user and
+@@ -216,55 +220,6 @@ static void init_scsi_tgt_cmd(struct req
+ 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+ }
+ 
+-static void scsi_tgt_uspace_send_fn(void *data)
+-{
+-	struct request_queue *q = data;
+-	struct scsi_tgt_queuedata *qdata = q->queuedata;
+-	struct request *rq;
+-	struct scsi_cmnd *cmd;
+-	struct scsi_tgt_cmd *tcmd;
+-	unsigned long flags;
+-	int err;
+-
+-retry:
+-	err = 0;
+-	if (list_empty(&qdata->cmd_req))
+-		return;
+-
+-	mutex_lock(&qdata->cmd_req_mutex);
+-
+-	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+-	if (list_empty(&qdata->cmd_req)) {
+-		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+-		mutex_unlock(&qdata->cmd_req_mutex);
+-		goto out;
+-	}
+-	rq = list_entry_rq(qdata->cmd_req.next);
+-	list_del_init(&rq->queuelist);
+-	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+-
+-	tcmd = rq->end_io_data;
+-	init_scsi_tgt_cmd(rq, tcmd);
+-	cmd = rq->special;
+-	err = scsi_tgt_uspace_send_cmd(cmd, tcmd->lun, tcmd->tag);
+-	if (err < 0) {
+-		eprintk("failed to send: %p %d\n", cmd, err);
+-
+-		spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+-		list_add(&rq->queuelist, &qdata->cmd_req);
+-		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
+-	}
+-
+-	mutex_unlock(&qdata->cmd_req_mutex);
+-out:
+-	/* TODO: proper error handling */
+-	if (err < 0)
+-		queue_delayed_work(scsi_tgtd, &qdata->uspace_send_work,
+-				   HZ / 10);
+-	else
+-		goto retry;
+-}
+-
+ /*
+  * scsi_tgt_alloc_queue - setup queue used for message passing
+  * shost: scsi host
+@@ -312,11 +267,6 @@ int scsi_tgt_alloc_queue(struct Scsi_Hos
+ 		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
+ 	spin_lock_init(&queuedata->cmd_hash_lock);
+ 
+-	INIT_LIST_HEAD(&queuedata->cmd_req);
+-	spin_lock_init(&queuedata->cmd_req_lock);
+-	INIT_WORK(&queuedata->uspace_send_work, scsi_tgt_uspace_send_fn, q);
+-	mutex_init(&queuedata->cmd_req_mutex);
+-
+ 	return 0;
+ 
+ cleanup_queue:
+@@ -336,28 +286,20 @@ EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
+  * scsi_tgt_queue_command - queue command for userspace processing
+  * @cmd:	scsi command
+  * @scsilun:	scsi lun
+- * @noblock:	set to nonzero if the command should be queued
++ * @tag:	unique value to identify this command for tmf
+  */
+ int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
+ 			   u64 tag)
+ {
+-	struct request_queue *q = cmd->request->q;
+-	struct scsi_tgt_queuedata *qdata = q->queuedata;
+-	unsigned long flags;
+ 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
++	int err;
+ 
+-	bio_list_init(&tcmd->xfer_list);
+-	bio_list_init(&tcmd->xfer_done_list);
+-	tcmd->lun = scsilun;
+-	tcmd->tag = tag;
+-	tcmd->rq = cmd->request;
+-
+-	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
+-	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
+-	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
++	init_scsi_tgt_cmd(cmd->request, tcmd);
++	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
++	if (err)
++		cmd_hashlist_del(cmd);
+ 
+-	queue_work(scsi_tgtd, &qdata->uspace_send_work);
+-	return 0;
++	return err;
+ }
+ EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
+ 
+-- 
+1.1.3



From tomo at mail.berlios.de  Wed Jul 26 07:06:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 07:06:17 +0200
Subject: [Stgt-svn] r508 - trunk/patchset
Message-ID: <200607260506.k6Q56HbT030240@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 07:06:00 +0200 (Wed, 26 Jul 2006)
New Revision: 508

Added:
   trunk/patchset/README
Log:
Add description about the patchset.


Added: trunk/patchset/README
===================================================================
--- trunk/patchset/README	2006-07-26 05:05:04 UTC (rev 507)
+++ trunk/patchset/README	2006-07-26 05:06:00 UTC (rev 508)
@@ -0,0 +1,7 @@
+This patchset for scsi-target git tree:
+
+http://www.kernel.org/git/?p=linux/kernel/git/jejb/scsi-target-2.6.git;a=summary
+
+
+Get the tree and apply all the patches. Sorry for the
+inconvenience. We will create our own git tree shortly.



From tomo at mail.berlios.de  Wed Jul 26 07:38:56 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 07:38:56 +0200
Subject: [Stgt-svn] r509 - trunk/kernel
Message-ID: <200607260538.k6Q5cuhK005862@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 07:38:50 +0200 (Wed, 26 Jul 2006)
New Revision: 509

Modified:
   trunk/kernel/scsi_tgt_if.c
   trunk/kernel/scsi_tgt_lib.c
   trunk/kernel/scsi_tgt_priv.h
Log:
Sigh, sync with patchset.


Modified: trunk/kernel/scsi_tgt_if.c
===================================================================
--- trunk/kernel/scsi_tgt_if.c	2006-07-26 05:06:00 UTC (rev 508)
+++ trunk/kernel/scsi_tgt_if.c	2006-07-26 05:38:50 UTC (rev 509)
@@ -21,7 +21,6 @@
  */
 #include <linux/blkdev.h>
 #include <linux/file.h>
-#include <linux/netlink.h>
 #include <net/tcp.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -32,87 +31,129 @@
 
 #include "scsi_tgt_priv.h"
 
-static int tgtd_pid;
-static struct sock *nl_sk;
+struct rbuf {
+	u32 idx;
+	u32 nr_entry;
+	int entry_size;
+	char *buf;
+	int buf_size;
+	spinlock_t lock;
+};
 
-static int send_event_rsp(uint16_t type, struct tgt_event *p, gfp_t flags,
-			  pid_t pid)
+static int chrdev;
+static struct rbuf txbuf, rxbuf;
+static DECLARE_WAIT_QUEUE_HEAD(tgt_poll_wait);
+
+static inline struct rbuf_hdr *head_rbuf_hdr(struct rbuf *rbuf, u32 idx)
 {
+	u32 offset = (idx & (rbuf->nr_entry - 1)) * rbuf->entry_size;
+	return (struct rbuf_hdr *) (rbuf->buf + offset);
+}
+
+static void rbuf_init(struct rbuf *rbuf, char *buf, int bsize, int esize)
+{
+	int i;
+
+	esize += sizeof(struct rbuf_hdr);
+	rbuf->idx = 0;
+	rbuf->entry_size = esize;
+	rbuf->buf = buf;
+	spin_lock_init(&rbuf->lock);
+
+	bsize /= esize;
+	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
+		;
+	rbuf->nr_entry = 1 << i;
+}
+
+static int send_event_rsp(u32 type, struct tgt_event *p)
+{
 	struct tgt_event *ev;
-	struct nlmsghdr *nlh;
-	struct sk_buff *skb;
-	uint32_t len;
+	struct rbuf_hdr *hdr;
+	struct page *sp, *ep;
+	unsigned long flags;
+	int err = 0;
 
-	len = NLMSG_SPACE(sizeof(*ev));
-	skb = alloc_skb(len, flags);
-	if (!skb)
-		return -ENOMEM;
+	spin_lock_irqsave(&txbuf.lock, flags);
 
-	nlh = __nlmsg_put(skb, pid, 0, type, len - sizeof(*nlh), 0);
+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx);
+	if (hdr->status)
+		err = 1;
+	else
+		txbuf.idx++;
 
-	ev = NLMSG_DATA(nlh);
+	spin_unlock_irqrestore(&txbuf.lock, flags);
+
+	if (err)
+		return err;
+
+	ev = (struct tgt_event *) hdr->data;
 	memcpy(ev, p, sizeof(*ev));
+	ev->type = type;
+	hdr->status = 1;
+	mb();
 
-	return netlink_unicast(nl_sk, skb, pid, 0);
+	sp = virt_to_page(hdr);
+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
+	for (;sp <= ep; sp++)
+		flush_dcache_page(sp);
+
+	wake_up_interruptible(&tgt_poll_wait);
+
+	return 0;
 }
 
-int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag,
-			 gfp_t flags)
+int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun, u64 tag)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
-	struct sk_buff *skb;
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	int err, len;
+	struct tgt_event ev;
+	int err;
 
-	len = NLMSG_SPACE(sizeof(*ev));
-	/*
-	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
-	 */
-	skb = alloc_skb(NLMSG_SPACE(len), flags);
-	if (!skb)
-		return -ENOMEM;
+	memset(&ev, 0, sizeof(ev));
+	ev.k.cmd_req.host_no = shost->host_no;
+	ev.k.cmd_req.cid = cmd->request->tag;
+	ev.k.cmd_req.data_len = cmd->request_bufflen;
+	memcpy(ev.k.cmd_req.scb, cmd->cmnd, sizeof(ev.k.cmd_req.scb));
+	memcpy(ev.k.cmd_req.lun, lun, sizeof(ev.k.cmd_req.lun));
+	ev.k.cmd_req.attribute = cmd->tag;
+	ev.k.cmd_req.tag = tag;
 
-	nlh = __nlmsg_put(skb, tgtd_pid, 0, TGT_KEVENT_CMD_REQ,
-			  len - sizeof(*nlh), 0);
+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
+		ev.k.cmd_req.data_len, cmd->tag,
+		(unsigned long long) ev.k.cmd_req.tag);
 
-	ev = NLMSG_DATA(nlh);
-	ev->k.cmd_req.host_no = shost->host_no;
-	ev->k.cmd_req.cid = cmd->request->tag;
-	ev->k.cmd_req.data_len = cmd->request_bufflen;
-	memcpy(ev->k.cmd_req.scb, cmd->cmnd, sizeof(ev->k.cmd_req.scb));
-	memcpy(ev->k.cmd_req.lun, lun, sizeof(ev->k.cmd_req.lun));
-	ev->k.cmd_req.attribute = cmd->tag;
-	ev->k.cmd_req.tag = tag;
-
-	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev->k.cmd_req.cid,
-		ev->k.cmd_req.data_len, cmd->tag,
-		(unsigned long long) ev->k.cmd_req.tag);
-
-	err = netlink_unicast(nl_sk, skb, tgtd_pid, 0);
-	if (err < 0)
-		printk(KERN_ERR "scsi_tgt_uspace_send: could not send skb %d\n",
-		       err);
+	err = send_event_rsp(TGT_KEVENT_CMD_REQ, &ev);
+	if (err)
+		eprintk("tx buf is full, could not send\n");
 	return err;
 }
 
-int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd)
 {
 	struct Scsi_Host *shost = scsi_tgt_cmd_to_host(cmd);
 	struct tgt_event ev;
+	int err;
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.cmd_done.host_no = shost->host_no;
 	ev.k.cmd_done.cid = cmd->request->tag;
 	ev.k.cmd_done.result = cmd->result;
 
-	return send_event_rsp(TGT_KEVENT_CMD_DONE, &ev, gfp_mask, tgtd_pid);
+	dprintk("%p %d %u %u %x %llx\n", cmd, shost->host_no, ev.k.cmd_req.cid,
+		ev.k.cmd_req.data_len, cmd->tag,
+		(unsigned long long) ev.k.cmd_req.tag);
+
+	err = send_event_rsp(TGT_KEVENT_CMD_DONE, &ev);
+	if (err)
+		eprintk("tx buf is full, could not send\n");
+	return err;
 }
 
 int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,
 				  struct scsi_lun *scsilun, void *data)
 {
 	struct tgt_event ev;
+	int err;
 
 	memset(&ev, 0, sizeof(ev));
 	ev.k.tsk_mgmt_req.host_no = host_no;
@@ -124,23 +165,18 @@
 	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
 		(unsigned long long) ev.k.tsk_mgmt_req.mid);
 
-	return send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev, GFP_KERNEL, tgtd_pid);
+	err = send_event_rsp(TGT_KEVENT_TSK_MGMT_REQ, &ev);
+	if (err)
+		eprintk("tx buf is full, could not send\n");
+	return err;
 }
 
-static int event_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
+static int event_recv_msg(struct tgt_event *ev)
 {
-	struct tgt_event *ev = NLMSG_DATA(nlh);
 	int err = 0;
 
-	dprintk("%d %d %d\n", nlh->nlmsg_type,
-		nlh->nlmsg_pid, current->pid);
-
-	switch (nlh->nlmsg_type) {
-	case TGT_UEVENT_REQ:
-		tgtd_pid = NETLINK_CREDS(skb)->pid;
-		break;
+	switch (ev->type) {
 	case TGT_UEVENT_CMD_RSP:
-		/* TODO: handle multiple cmds in one event */
 		err = scsi_tgt_kspace_exec(ev->u.cmd_rsp.host_no,
 					   ev->u.cmd_rsp.cid,
 					   ev->u.cmd_rsp.result,
@@ -154,79 +190,126 @@
 					       ev->u.tsk_mgmt_rsp.result);
 		break;
 	default:
-		eprintk("unknown type %d\n", nlh->nlmsg_type);
+		eprintk("unknown type %d\n", ev->type);
 		err = -EINVAL;
 	}
 
 	return err;
 }
 
-static int event_recv_skb(struct sk_buff *skb)
+static ssize_t tgt_write(struct file *file, const char __user * buffer,
+			 size_t count, loff_t * ppos)
 {
-	int err;
-	uint32_t rlen;
-	struct nlmsghdr	*nlh;
-	struct tgt_event ev;
+	struct rbuf_hdr *hdr;
+	struct tgt_event *ev;
+	struct page *sp, *ep;
 
-	while (skb->len >= NLMSG_SPACE(0)) {
-		nlh = (struct nlmsghdr *) skb->data;
-		if (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)
-			return 0;
-		rlen = NLMSG_ALIGN(nlh->nlmsg_len);
-		if (rlen > skb->len)
-			rlen = skb->len;
-		err = event_recv_msg(skb, nlh);
+retry:
+	hdr = head_rbuf_hdr(&rxbuf, rxbuf.idx);
 
-		dprintk("%d %d\n", nlh->nlmsg_type, err);
-		/*
-		 * TODO for passthru commands the lower level should
-		 * probably handle the result or we should modify this
-		 */
-		switch (nlh->nlmsg_type) {
-		case TGT_UEVENT_CMD_RSP:
-		case TGT_UEVENT_TSK_MGMT_RSP:
-			break;
-		default:
-			memset(&ev, 0, sizeof(ev));
-			ev.k.event_rsp.err = err;
-			send_event_rsp(TGT_KEVENT_RSP, &ev,
-				       GFP_KERNEL | __GFP_NOFAIL,
-					nlh->nlmsg_pid);
-		}
-		skb_pull(skb, rlen);
-	}
-	return 0;
+	sp = virt_to_page(hdr);
+	ep = virt_to_page((char *) hdr->data + sizeof(*ev));
+	for (;sp <= ep; sp++)
+		flush_dcache_page(sp);
+
+	if (!hdr->status)
+		return count;
+
+	rxbuf.idx++;
+	ev = (struct tgt_event *) hdr->data;
+	event_recv_msg(ev);
+	hdr->status = 0;
+
+	goto retry;
 }
 
-static void event_recv(struct sock *sk, int length)
+static unsigned int tgt_poll(struct file * file, struct poll_table_struct *wait)
 {
-	struct sk_buff *skb;
+	struct rbuf_hdr *hdr;
+	unsigned long flags;
+	unsigned int mask = 0;
 
-	while ((skb = skb_dequeue(&sk->sk_receive_queue))) {
-		if (NETLINK_CREDS(skb)->uid) {
-			skb_pull(skb, skb->len);
-			kfree_skb(skb);
-			continue;
+	poll_wait(file, &tgt_poll_wait, wait);
+
+	spin_lock_irqsave(&txbuf.lock, flags);
+
+	hdr = head_rbuf_hdr(&txbuf, txbuf.idx - 1);
+	if (hdr->status)
+		mask |= POLLIN | POLLRDNORM;
+
+	spin_unlock_irqrestore(&txbuf.lock, flags);
+
+	return mask;
+}
+
+static int tgt_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long size, addr;
+	struct page *page;
+	int err, i;
+
+	if (vma->vm_pgoff) {
+		eprintk("bug\n");
+		return -EINVAL;
+	}
+
+	size = vma->vm_end - vma->vm_start;
+	if (size != TGT_RINGBUF_SIZE * 2) {
+		eprintk("%lu\n", size);
+		return -EINVAL;
+	}
+	addr = vma->vm_start;
+	page = virt_to_page(txbuf.buf);
+	for (i = 0; i < size >> PAGE_SHIFT; i++) {
+		err = vm_insert_page(vma, addr, page);
+		if (err) {
+			eprintk("%d %d %lu\n", err, i, addr);
+			return -EINVAL;
 		}
+		addr += PAGE_SIZE;
+		page++;
+	}
 
-		if (event_recv_skb(skb) && skb->len)
-			skb_queue_head(&sk->sk_receive_queue, skb);
-		else
-			kfree_skb(skb);
-	}
+	return 0;
 }
 
+static struct file_operations tgt_fops = {
+	.owner	= THIS_MODULE,
+	.poll	= tgt_poll,
+	.write	= tgt_write,
+	.mmap	= tgt_mmap,
+};
+
 void __exit scsi_tgt_if_exit(void)
 {
-	sock_release(nl_sk->sk_socket);
+	int order = long_log2(TGT_RINGBUF_SIZE * 2);
+
+	unregister_chrdev(chrdev, "tgt");
+	free_pages((unsigned long) txbuf.buf, order);
 }
 
 int __init scsi_tgt_if_init(void)
 {
-	nl_sk = netlink_kernel_create(NETLINK_TGT, 1, event_recv,
-				    THIS_MODULE);
-	if (!nl_sk)
-		return -ENOMEM;
+	u32 bsize = TGT_RINGBUF_SIZE;
+	int order;
+	char *buf;
 
+	chrdev = register_chrdev(0, "tgt", &tgt_fops);
+	if (chrdev < 0)
+		return chrdev;
+
+	order = long_log2((bsize * 2) >> PAGE_SHIFT);
+	buf = (char *) __get_free_pages(GFP_KERNEL | __GFP_COMP | __GFP_ZERO,
+					order);
+	if (!buf)
+		goto free_dev;
+	rbuf_init(&txbuf, buf, bsize, sizeof(struct tgt_event));
+	rbuf_init(&rxbuf, buf + bsize, bsize, sizeof(struct tgt_event));
+
 	return 0;
+
+free_dev:
+	unregister_chrdev(chrdev, "tgt");
+
+	return -ENOMEM;
 }

Modified: trunk/kernel/scsi_tgt_lib.c
===================================================================
--- trunk/kernel/scsi_tgt_lib.c	2006-07-26 05:06:00 UTC (rev 508)
+++ trunk/kernel/scsi_tgt_lib.c	2006-07-26 05:38:50 UTC (rev 509)
@@ -45,11 +45,9 @@
 	/* TODO replace the lists with a large bio */
 	struct bio_list xfer_done_list;
 	struct bio_list xfer_list;
-	struct scsi_lun *lun;
 
 	struct list_head hash_list;
 	struct request *rq;
-	u64 tag;
 
 	void *buffer;
 	unsigned bufflen;
@@ -62,12 +60,6 @@
 	struct Scsi_Host *shost;
 	struct list_head cmd_hash[1 << TGT_HASH_ORDER];
 	spinlock_t cmd_hash_lock;
-
-	struct work_struct uspace_send_work;
-
-	spinlock_t cmd_req_lock;
-	struct mutex cmd_req_mutex;
-	struct list_head cmd_req;
 };
 
 /*
@@ -117,6 +109,10 @@
 	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
 	rq->end_io_data = tcmd;
 
+	bio_list_init(&tcmd->xfer_list);
+	bio_list_init(&tcmd->xfer_done_list);
+	tcmd->rq = rq;
+
 	return cmd;
 
 release_rq:
@@ -175,19 +171,27 @@
 	}
 }
 
+static void cmd_hashlist_del(struct scsi_cmnd *cmd)
+{
+	struct request_queue *q = cmd->request->q;
+	struct scsi_tgt_queuedata *qdata = q->queuedata;
+	unsigned long flags;
+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+
+	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
+	list_del(&tcmd->hash_list);
+	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+}
+
 static void scsi_tgt_cmd_destroy(void *data)
 {
 	struct scsi_cmnd *cmd = data;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
-	struct scsi_tgt_queuedata *qdata = cmd->request->q->queuedata;
-	unsigned long flags;
 
 	dprintk("cmd %p %d %lu\n", cmd, cmd->sc_data_direction,
 		rq_data_dir(cmd->request));
 
-	spin_lock_irqsave(&qdata->cmd_hash_lock, flags);
-	list_del(&tcmd->hash_list);
-	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
+	cmd_hashlist_del(cmd);
 
 	/*
 	 * We must set rq->flags here because bio_map_user and
@@ -216,55 +220,6 @@
 	spin_unlock_irqrestore(&qdata->cmd_hash_lock, flags);
 }
 
-static void scsi_tgt_uspace_send_fn(void *data)
-{
-	struct request_queue *q = data;
-	struct scsi_tgt_queuedata *qdata = q->queuedata;
-	struct request *rq;
-	struct scsi_cmnd *cmd;
-	struct scsi_tgt_cmd *tcmd;
-	unsigned long flags;
-	int err;
-
-retry:
-	err = 0;
-	if (list_empty(&qdata->cmd_req))
-		return;
-
-	mutex_lock(&qdata->cmd_req_mutex);
-
-	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
-	if (list_empty(&qdata->cmd_req)) {
-		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-		mutex_unlock(&qdata->cmd_req_mutex);
-		goto out;
-	}
-	rq = list_entry_rq(qdata->cmd_req.next);
-	list_del_init(&rq->queuelist);
-	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-
-	tcmd = rq->end_io_data;
-	init_scsi_tgt_cmd(rq, tcmd);
-	cmd = rq->special;
-	err = scsi_tgt_uspace_send(cmd, tcmd->lun, tcmd->tag, GFP_ATOMIC);
-	if (err < 0) {
-		eprintk("failed to send: %p %d\n", cmd, err);
-
-		spin_lock_irqsave(&qdata->cmd_req_lock, flags);
-		list_add(&rq->queuelist, &qdata->cmd_req);
-		spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-	}
-
-	mutex_unlock(&qdata->cmd_req_mutex);
-out:
-	/* TODO: proper error handling */
-	if (err < 0)
-		queue_delayed_work(scsi_tgtd, &qdata->uspace_send_work,
-				   HZ / 10);
-	else
-		goto retry;
-}
-
 /*
  * scsi_tgt_alloc_queue - setup queue used for message passing
  * shost: scsi host
@@ -312,11 +267,6 @@
 		INIT_LIST_HEAD(&queuedata->cmd_hash[i]);
 	spin_lock_init(&queuedata->cmd_hash_lock);
 
-	INIT_LIST_HEAD(&queuedata->cmd_req);
-	spin_lock_init(&queuedata->cmd_req_lock);
-	INIT_WORK(&queuedata->uspace_send_work, scsi_tgt_uspace_send_fn, q);
-	mutex_init(&queuedata->cmd_req_mutex);
-
 	return 0;
 
 cleanup_queue:
@@ -336,28 +286,20 @@
  * scsi_tgt_queue_command - queue command for userspace processing
  * @cmd:	scsi command
  * @scsilun:	scsi lun
- * @noblock:	set to nonzero if the command should be queued
+ * @tag:	unique value to identify this command for tmf
  */
 int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
 			   u64 tag)
 {
-	struct request_queue *q = cmd->request->q;
-	struct scsi_tgt_queuedata *qdata = q->queuedata;
-	unsigned long flags;
 	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
+	int err;
 
-	bio_list_init(&tcmd->xfer_list);
-	bio_list_init(&tcmd->xfer_done_list);
-	tcmd->lun = scsilun;
-	tcmd->tag = tag;
-	tcmd->rq = cmd->request;
+	init_scsi_tgt_cmd(cmd->request, tcmd);
+	err = scsi_tgt_uspace_send_cmd(cmd, scsilun, tag);
+	if (err)
+		cmd_hashlist_del(cmd);
 
-	spin_lock_irqsave(&qdata->cmd_req_lock, flags);
-	list_add_tail(&cmd->request->queuelist, &qdata->cmd_req);
-	spin_unlock_irqrestore(&qdata->cmd_req_lock, flags);
-
-	queue_work(scsi_tgtd, &qdata->uspace_send_work);
-	return 0;
+	return err;
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_queue_command);
 
@@ -371,7 +313,7 @@
 
 	dprintk("cmd %p %lu\n", cmd, rq_data_dir(cmd->request));
 
-	scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC);
+	scsi_tgt_uspace_send_status(cmd);
 	INIT_WORK(&tcmd->work, scsi_tgt_cmd_destroy, cmd);
 	queue_work(scsi_tgtd, &tcmd->work);
 }
@@ -402,7 +344,8 @@
 		return;
 
 	cmd->result = DID_BUS_BUSY << 16;
-	if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
+	err = scsi_tgt_uspace_send_status(cmd);
+	if (err <= 0)
 		/* the eh will have to pick this up */
 		printk(KERN_ERR "Could not send cmd %p status\n", cmd);
 }
@@ -501,7 +444,8 @@
 	/* should we free resources here on error ? */
 	if (cmd->result) {
 send_uspace_err:
-		if (scsi_tgt_uspace_send_status(cmd, GFP_ATOMIC) <= 0)
+		err = scsi_tgt_uspace_send_status(cmd);
+		if (err <= 0)
 			/* the tgt uspace eh will have to pick this up */
 			printk(KERN_ERR "Could not send cmd %p status\n", cmd);
 		return;

Modified: trunk/kernel/scsi_tgt_priv.h
===================================================================
--- trunk/kernel/scsi_tgt_priv.h	2006-07-26 05:06:00 UTC (rev 508)
+++ trunk/kernel/scsi_tgt_priv.h	2006-07-26 05:38:50 UTC (rev 509)
@@ -10,14 +10,13 @@
 } while (0)
 
 #define dprintk eprintk
-/* #define dprintk(fmt, args...) */
 
 extern void scsi_tgt_if_exit(void);
 extern int scsi_tgt_if_init(void);
 
-extern int scsi_tgt_uspace_send(struct scsi_cmnd *cmd, struct scsi_lun *lun,
-				u64 tag, gfp_t flags);
-extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd, gfp_t flags);
+extern int scsi_tgt_uspace_send_cmd(struct scsi_cmnd *cmd, struct scsi_lun *lun,
+				    u64 tag);
+extern int scsi_tgt_uspace_send_status(struct scsi_cmnd *cmd);
 extern int scsi_tgt_kspace_exec(int host_no, u32 cid, int result, u32 len,
 				unsigned long uaddr, u8 rw);
 extern int scsi_tgt_uspace_send_tsk_mgmt(int host_no, int function, u64 tag,



From tomo at mail.berlios.de  Wed Jul 26 07:41:17 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 07:41:17 +0200
Subject: [Stgt-svn] r510 - trunk/usr
Message-ID: <200607260541.k6Q5fHns006324@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 07:41:04 +0200 (Wed, 26 Jul 2006)
New Revision: 510

Added:
   trunk/usr/tgtif.c
Removed:
   trunk/usr/netlink.c
Modified:
   trunk/usr/Makefile
   trunk/usr/mgmt.c
   trunk/usr/target.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Updates for shared memory interface, still needs cleanup.


Modified: trunk/usr/Makefile
===================================================================
--- trunk/usr/Makefile	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/Makefile	2006-07-26 05:41:04 UTC (rev 510)
@@ -1,6 +1,6 @@
 CFLAGS += -O2 -fno-inline -Wall -Wstrict-prototypes -fPIC -I$(KERNELSRC)/include -I../istgt/include -I../include -I. -D_LARGEFILE64_SOURCE
 PROGRAMS = tgtd tgtadm
-TGTD_OBJS = tgtd.o netlink.o mgmt.o target.o scsi.o log.o driver.o
+TGTD_OBJS = tgtd.o tgtif.o mgmt.o target.o scsi.o log.o driver.o
 
 ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/mgmt.c	2006-07-26 05:41:04 UTC (rev 510)
@@ -74,12 +74,12 @@
 	switch (req->op) {
 	case OP_NEW:
 		err = tgt_target_create(req->tid);
-		if (!err)
+		if (!err && tgt_drivers[lld_no]->target_create)
 			tgt_drivers[lld_no]->target_create(req->tid, params);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);
-		if (!err)
+		if (!err && tgt_drivers[lld_no]->target_destroy)
 			tgt_drivers[lld_no]->target_destroy(req->tid);
 		break;
 	case OP_BIND:

Deleted: trunk/usr/netlink.c
===================================================================
--- trunk/usr/netlink.c	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/netlink.c	2006-07-26 05:41:04 UTC (rev 510)
@@ -1,162 +0,0 @@
-/*
- * (C) 2005 FUJITA Tomonori <tomof at acm.org>
- * (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
- *
- * Netlink functions are based on open-iscsi code
- * written by Dmitry Yusupov and Alex Aizman.
- *
- * This code is licenced under the GPL.
- */
-
-#include <errno.h>
-#include <inttypes.h>
-#include <signal.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <asm/types.h>
-#include <sys/mman.h>
-#include <sys/poll.h>
-#include <sys/signal.h>
-#include <sys/socket.h>
-#include <scsi/scsi_tgt_if.h>
-#include <linux/netlink.h>
-
-#include "tgtd.h"
-
-#define	NL_BUFSIZE	1024
-
-int __nl_write(int fd, int type, char *data, int len)
-{
-	struct nlmsghdr *nlh = (struct nlmsghdr *) data;
-	struct sockaddr_nl daddr;
-
-	memset(nlh, 0, sizeof(*nlh));
-	nlh->nlmsg_len = len;
-	nlh->nlmsg_type = type;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
-
-	memset(&daddr, 0, sizeof(daddr));
-	daddr.nl_family = AF_NETLINK;
-	daddr.nl_pid = 0;
-	daddr.nl_groups = 0;
-
-	return sendto(fd, data, len, 0, (struct sockaddr *) &daddr,
-		      sizeof(daddr));
-}
-
-int __nl_read(int fd, void *data, int size, int flags)
-{
-	struct sockaddr_nl saddr;
-	socklen_t slen = sizeof(saddr);
-
-	memset(&saddr, 0, sizeof(saddr));
-	saddr.nl_family = AF_NETLINK;
-	saddr.nl_pid = getpid();
-	saddr.nl_groups = 0; /* not in mcast groups */
-
-	return recvfrom(fd, data, size, flags, (struct sockaddr *) &saddr, &slen);
-}
-
-static int nl_read(int fd, char *buf)
-{
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	int err;
-
-peek_again:
-	err = __nl_read(fd, buf, NLMSG_SPACE(sizeof(*ev)), MSG_PEEK);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto peek_again;
-		return err;
-	}
-
-	nlh = (struct nlmsghdr *) buf;
-	ev = (struct tgt_event *) NLMSG_DATA(nlh);
-
-	dprintf("%d %d %d\n", nlh->nlmsg_type, nlh->nlmsg_len, getpid());
-
-read_again:
-	err = __nl_read(fd, buf, nlh->nlmsg_len, 0);
-	if (err < 0) {
-		eprintf("%d\n", err);
-		if (errno == EAGAIN || errno == EINTR)
-			goto read_again;
-		return err;
-	}
-
-	return err;
-}
-
-int nl_cmd_call(int fd, int type, char *sbuf, int slen, char *rbuf, int rlen)
-{
-	int err;
-	struct nlmsghdr *nlh;
-	char buf[NL_BUFSIZE];
-
-	err = __nl_write(fd, type, sbuf, slen);
-	if (err < 0)
-		return err;
-
-	err = nl_read(fd, buf);
-
-	if (rbuf) {
-		nlh = (struct nlmsghdr *) buf;
-		if (rlen < nlh->nlmsg_len)
-			eprintf("Too small rbuf %d %d\n", rlen, nlh->nlmsg_len);
-		else
-			rlen = nlh->nlmsg_len;
-
-		memcpy(rbuf, nlh, rlen);
-	}
-
-	return err;
-}
-
-static int tgtd_bind(int nl_fd)
-{
-	int err;
-	struct tgt_event *ev;
-	char sbuf[NL_BUFSIZE], rbuf[NL_BUFSIZE];
-
-	ev = (struct tgt_event *) NLMSG_DATA(sbuf);
-	err = nl_cmd_call(nl_fd, TGT_UEVENT_REQ, sbuf,
-			  NLMSG_SPACE(sizeof(struct tgt_event)),
-			  rbuf, NL_BUFSIZE);
-
-	ev = (struct tgt_event *) NLMSG_DATA(rbuf);
-	if (err < 0 || ev->k.event_rsp.err < 0) {
-		eprintf("%d %d\n", err, ev->k.event_rsp.err);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-int nl_init(void)
-{
-	int err, nl_fd, rsize = 256 * 1024;
-
-	nl_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_TGT);
-	if (nl_fd < 0) {
-		eprintf("Fail to create the netlink socket %d\n", errno);
-		exit(1);
-	}
-
-	err = setsockopt(nl_fd, SOL_SOCKET, SO_RCVBUF, &rsize, sizeof(rsize));
-	if (err) {
-		eprintf("fail to setsockopt %d\n", errno);
-		exit(1);
-	}
-
-	err = tgtd_bind(nl_fd);
-	if (err)
-		exit(1);
-
-	return nl_fd;
-}

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/target.c	2006-07-26 05:41:04 UTC (rev 510)
@@ -36,7 +36,6 @@
 #include <linux/hash.h>
 #include <linux/netlink.h>
 #include <scsi/scsi.h>
-#include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
 #include "tgtadm.h"
@@ -315,20 +314,19 @@
 	return 0;
 }
 
-static int tgt_kspace_send_cmd(int nl_fd, struct cmd *cmd, int result, int rw)
+static int tgt_kspace_send_cmd(struct cmd *cmd, int result, int rw)
 {
-	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
-	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+	struct tgt_event ev;
 
-	ev_res->u.cmd_rsp.host_no = cmd->hostno;
-	ev_res->u.cmd_rsp.cid = cmd->cid;
-	ev_res->u.cmd_rsp.len = cmd->len;
-	ev_res->u.cmd_rsp.result = result;
-	ev_res->u.cmd_rsp.uaddr = cmd->uaddr;
-	ev_res->u.cmd_rsp.rw = rw;
+	ev.type = TGT_UEVENT_CMD_RSP;
+	ev.u.cmd_rsp.host_no = cmd->hostno;
+	ev.u.cmd_rsp.cid = cmd->cid;
+	ev.u.cmd_rsp.len = cmd->len;
+	ev.u.cmd_rsp.result = result;
+	ev.u.cmd_rsp.uaddr = cmd->uaddr;
+	ev.u.cmd_rsp.rw = rw;
 
-	return __nl_write(nl_fd, TGT_UEVENT_CMD_RSP, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
+	return kreq_send(&ev);
 }
 
 static int cmd_pre_perform(struct tgt_cmd_queue *q, struct cmd *cmd)
@@ -379,7 +377,7 @@
 	}
 }
 
-static void cmd_queue(struct tgt_event *ev_req, int nl_fd)
+static void cmd_queue(struct tgt_event *ev_req)
 {
 	struct target *target;
 	struct tgt_cmd_queue *q;
@@ -446,7 +444,7 @@
 			offset, result);
 
 		set_cmd_processed(cmd);
-		tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
+		tgt_kspace_send_cmd(cmd, result, rw);
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %u %x %" PRIu64 " %d\n",
@@ -461,7 +459,7 @@
 	}
 }
 
-static void post_cmd_done(int nl_fd, struct tgt_cmd_queue *q)
+static void post_cmd_done(struct tgt_cmd_queue *q)
 {
 	struct cmd *cmd, *tmp;
 	int enabled, result, len = 0;
@@ -493,7 +491,7 @@
 						  &target->device_list);
 			cmd_post_perform(q, cmd, uaddr, len, mmapped);
 			set_cmd_processed(cmd);
-			tgt_kspace_send_cmd(nl_fd, cmd, result, rw);
+			tgt_kspace_send_cmd(cmd, result, rw);
 		} else
 			break;
 	}
@@ -529,7 +527,7 @@
 	return err;
 }
 
-static void __cmd_done(struct target *target, struct cmd *cmd, int nl_fd)
+static void __cmd_done(struct target *target, struct cmd *cmd)
 {
 	struct tgt_cmd_queue *q;
 	int err, do_munmap;
@@ -566,24 +564,21 @@
 
 	free(cmd);
 
-	post_cmd_done(nl_fd, q);
+	post_cmd_done(q);
 }
 
-static int tgt_kspace_send_tsk_mgmt(int nl_fd, int host_no, uint64_t mid,
-				    int result)
+static int tgt_kspace_send_tsk_mgmt(int host_no, uint64_t mid, int result)
 {
-	char resbuf[NLMSG_SPACE(sizeof(struct tgt_event))];
-	struct tgt_event *ev_res = NLMSG_DATA(resbuf);
+	struct tgt_event ev;
 
-	ev_res->u.tsk_mgmt_rsp.host_no = host_no;
-	ev_res->u.tsk_mgmt_rsp.mid = mid;
-	ev_res->u.tsk_mgmt_rsp.result = result;
+	ev.u.tsk_mgmt_rsp.host_no = host_no;
+	ev.u.tsk_mgmt_rsp.mid = mid;
+	ev.u.tsk_mgmt_rsp.result = result;
 
-	return __nl_write(nl_fd, TGT_UEVENT_TSK_MGMT_RSP, resbuf,
-			  NLMSG_SPACE(sizeof(*ev_res)));
+	return kreq_send(&ev);
 }
 
-static void cmd_done(struct tgt_event *ev, int nl_fd)
+static void cmd_done(struct tgt_event *ev)
 {
 	struct target *target;
 	struct cmd *cmd;
@@ -606,15 +601,15 @@
 	mreq = cmd->mreq;
 	if (mreq && !--mreq->busy) {
 		int err = mreq->function == ABORT_TASK ? -EEXIST : 0;
-		tgt_kspace_send_tsk_mgmt(nl_fd, cmd->hostno, mreq->mid, err);
+		tgt_kspace_send_tsk_mgmt(cmd->hostno, mreq->mid, err);
 		free(mreq);
 	}
 
-	__cmd_done(target, cmd, nl_fd);
+	__cmd_done(target, cmd);
 }
 
 static int abort_cmd(struct target* target, struct mgmt_req *mreq,
-		     struct cmd *cmd, int nl_fd)
+		     struct cmd *cmd)
 {
 	int err = 0;
 
@@ -629,14 +624,14 @@
 		cmd->mreq = mreq;
 		err = -EBUSY;
 	} else {
-		__cmd_done(target, cmd, nl_fd);
-		tgt_kspace_send_cmd(nl_fd, cmd, TASK_ABORTED, 0);
+		__cmd_done(target, cmd);
+		tgt_kspace_send_cmd(cmd, TASK_ABORTED, 0);
 	}
 	return err;
 }
 
 static int abort_task_set(struct mgmt_req *mreq, struct target* target, int host_no,
-			  uint64_t tag, uint8_t *lun, int all, int nl_fd)
+			  uint64_t tag, uint8_t *lun, int all)
 {
 	struct cmd *cmd, *tmp;
 	int err, count = 0;
@@ -647,7 +642,7 @@
 		if ((all && cmd->hostno == host_no)||
 		    (cmd->tag == tag && cmd->hostno == host_no) ||
 		    (lun && !memcmp(cmd->lun, lun, sizeof(cmd->lun)))) {
-			err = abort_cmd(target, mreq, cmd, nl_fd);
+			err = abort_cmd(target, mreq, cmd);
 			if (err)
 				mreq->busy++;
 			count++;
@@ -657,7 +652,7 @@
 	return count;
 }
 
-static void tsk_mgmt_req(struct tgt_event *ev_req, int nl_fd)
+static void tsk_mgmt_req(struct tgt_event *ev_req)
 {
 	struct target *target;
 	struct mgmt_req *mreq;
@@ -679,14 +674,14 @@
 	case ABORT_TASK:
 		count = abort_task_set(mreq, target, host_no,
 				       ev_req->k.tsk_mgmt_req.tag,
-				       NULL, 0, nl_fd);
+				       NULL, 0);
 		if (mreq->busy)
 			send = 0;
 		if (!count)
 			err = -EEXIST;
 		break;
 	case ABORT_TASK_SET:
-		count = abort_task_set(mreq, target, host_no, 0, NULL, 1, nl_fd);
+		count = abort_task_set(mreq, target, host_no, 0, NULL, 1);
 		if (mreq->busy)
 			send = 0;
 		break;
@@ -698,7 +693,7 @@
 		break;
 	case LOGICAL_UNIT_RESET:
 		count = abort_task_set(mreq, target, host_no, 0,
-				       ev_req->k.tsk_mgmt_req.lun, 0, nl_fd);
+				       ev_req->k.tsk_mgmt_req.lun, 0);
 		if (mreq->busy)
 			send = 0;
 		break;
@@ -709,42 +704,28 @@
 	}
 
 	if (send) {
-		tgt_kspace_send_tsk_mgmt(nl_fd, ev_req->k.cmd_req.host_no,
+		tgt_kspace_send_tsk_mgmt(ev_req->k.cmd_req.host_no,
 					 ev_req->k.tsk_mgmt_req.mid, err);
 		free(mreq);
 	}
 }
 
-void nl_event_handle(int nl_fd)
+void kreq_exec(struct tgt_event *ev)
 {
-	struct nlmsghdr *nlh;
-	struct tgt_event *ev;
-	char buf[NLMSG_SPACE(sizeof(struct tgt_event))];
-	int err;
+	dprintf("event %u\n", ev->type);
 
-	err = __nl_read(nl_fd, buf, sizeof(buf), MSG_WAITALL);
-
-	nlh = (struct nlmsghdr *) buf;
-	ev = (struct tgt_event *) NLMSG_DATA(nlh);
-
-	if (nlh->nlmsg_len != err) {
-		eprintf("unexpected len %d %d %d %d\n",
-			nlh->nlmsg_len, sizeof(*ev), sizeof(buf), err);
-		exit(1);
-	}
-
-	switch (nlh->nlmsg_type) {
+	switch (ev->type) {
 	case TGT_KEVENT_CMD_REQ:
-		cmd_queue(ev, nl_fd);
+		cmd_queue(ev);
 		break;
 	case TGT_KEVENT_CMD_DONE:
-		cmd_done(ev, nl_fd);
+		cmd_done(ev);
 		break;
 	case TGT_KEVENT_TSK_MGMT_REQ:
-		tsk_mgmt_req(ev, nl_fd);
+		tsk_mgmt_req(ev);
 		break;
 	default:
-		eprintf("unknown event %u\n", nlh->nlmsg_type);
+		eprintf("unknown event %u\n", ev->type);
 		exit(1);
 	}
 }

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/tgtd.c	2006-07-26 05:41:04 UTC (rev 510)
@@ -39,7 +39,7 @@
 #include "driver.h"
 
 enum {
-	POLL_NL, /* netlink socket between kernel and user space */
+	POLL_IF, /* netlink socket between kernel and user space */
 	POLL_UD, /* unix domain socket for tgtdadm */
 	POLL_END,
 };
@@ -147,9 +147,8 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_NL].revents) {
-		dprintf("nl event\n");
-		nl_event_handle(pfd[POLL_NL].fd);
+	if (pfd[POLL_IF].revents) {
+		kreq_recv();
 		nevent--;
 	}
 
@@ -181,8 +180,8 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_NL].fd = nl_fd;
-	pfd[POLL_NL].events = POLLIN;
+	pfd[POLL_IF].fd = nl_fd;
+	pfd[POLL_IF].events = POLLIN;
 	pfd[POLL_UD].fd = ud_fd;
 	pfd[POLL_UD].events = POLLIN;
 
@@ -234,7 +233,7 @@
 	struct pollfd *pfd;
 	int err, ch, longindex, ndriver = 0, npfd = POLL_END;
 	int is_daemon = 1, is_debug = 1;
-	int nl_fd, ud_fd, timeout = -1;
+	int if_fd, ud_fd, timeout = -1;
 
 	while ((ch = getopt_long(argc, argv, "s:d:fd:vh", long_options,
 				 &longindex)) >= 0) {
@@ -274,15 +273,15 @@
 	if (err)
 		exit(1);
 
-	nl_fd = nl_init();
-	if (nl_fd < 0)
+	if_fd = kreq_init();
+	if (if_fd < 0)
 		exit(1);
 
 	ud_fd = ipc_open();
 	if (ud_fd < 0)
 		exit(1);
 
-	pfd = poll_init(npfd, nl_fd, ud_fd);
+	pfd = poll_init(npfd, if_fd, ud_fd);
 
 	event_loop(pfd, npfd, timeout);
 

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/tgtd.h	2006-07-26 05:41:04 UTC (rev 510)
@@ -3,6 +3,7 @@
 
 #include "log.h"
 #include "util.h"
+#include <scsi/scsi_tgt_if.h>
 
 #define	SCSI_ID_LEN	24
 
@@ -23,14 +24,14 @@
 	struct tgt_cmd_queue cmd_queue;
 };
 
-extern int nl_init(void);
-extern int __nl_write(int fd, int type, char *data, int len);
-extern int __nl_read(int fd, void *data, int size, int flags);
-void nl_event_handle(int nl_fd);
+extern int kreq_init(void);
+extern int kreq_recv(void);
+extern int kreq_send(struct tgt_event *ev);
 
 extern int ipc_open(void);
 extern void ipc_event_handle(int accept_fd);
 
+extern void kreq_exec(struct tgt_event *ev);
 extern int tgt_device_create(int tid, uint64_t lun, char *path);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_target_create(int tid);

Added: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-07-26 05:38:50 UTC (rev 509)
+++ trunk/usr/tgtif.c	2006-07-26 05:41:04 UTC (rev 510)
@@ -0,0 +1,181 @@
+/*
+ * SCSI kernel and user interface
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <inttypes.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <asm/types.h>
+#include <sys/mman.h>
+#include <sys/poll.h>
+#include <sys/stat.h>
+#include <scsi/scsi_tgt_if.h>
+
+#include "tgtd.h"
+
+struct uring {
+	uint32_t idx;
+	uint32_t nr_entry;
+	int entry_size;
+	char *buf;
+	int buf_size;
+};
+
+static struct uring kuring, ukring;
+static int chrfd;
+
+static inline struct rbuf_hdr *head_ring_hdr(struct uring *r)
+{
+	uint32_t offset = (r->idx & (r->nr_entry - 1)) * r->entry_size;
+	return (struct rbuf_hdr *) (r->buf + offset);
+}
+
+static void ring_init(struct uring *r, char *buf, int bsize, int esize)
+{
+	int i;
+
+	esize += sizeof(struct rbuf_hdr);
+	r->idx = 0;
+	r->buf = buf;
+	r->buf_size = bsize;
+	r->entry_size = esize;
+
+	bsize /= esize;
+	for (i = 0; (1 << i) < bsize && (1 << (i + 1)) <= bsize; i++)
+		;
+	r->nr_entry = 1 << i;
+
+	dprintf("%u %u\n", r->entry_size, r->nr_entry);
+}
+
+int kreq_send(struct tgt_event *ev)
+{
+	struct rbuf_hdr *hdr;
+	hdr = head_ring_hdr(&ukring);
+	if (hdr->status)
+		return -ENOMEM;
+
+	memcpy(hdr->data, ev, sizeof(*ev));
+	ukring.idx++;
+	hdr->status = 1;
+
+	write(chrfd, ev, 1);
+
+	return 0;
+}
+
+int kreq_recv(void)
+{
+	struct rbuf_hdr *hdr;
+
+	dprintf("nl event %u\n", kuring.idx);
+
+retry:
+	hdr = head_ring_hdr(&kuring);
+	if (!hdr->status)
+		return 0;
+
+	kreq_exec((struct tgt_event *) (hdr->data));
+	hdr->status = 0;
+	kuring.idx++;
+
+	goto retry;
+}
+
+static int ctrdev_open(char *devpath)
+{
+	FILE *f;
+	char devname[256];
+	char buf[256];
+	int devn;
+	int ctlfd;
+
+	if (!(f = fopen("/proc/devices", "r"))) {
+		eprintf("Cannot open control path to the driver\n");
+		return -1;
+	}
+
+	devn = 0;
+	while (!feof(f)) {
+		if (!fgets(buf, sizeof (buf), f)) {
+			break;
+		}
+		if (sscanf(buf, "%d %s", &devn, devname) != 2) {
+			continue;
+		}
+		if (!strcmp(devname, "tgt")) {
+			break;
+		}
+		devn = 0;
+	}
+
+	fclose(f);
+	if (!devn) {
+		eprintf("cannot find iscsictl in /proc/devices - "
+			"make sure the module is loaded\n");
+		return -1;
+	}
+
+	unlink(devpath);
+	if (mknod(devpath, (S_IFCHR | 0600), (devn << 8))) {
+		eprintf("cannot create %s %s\n", devpath, strerror(errno));
+		return -1;
+	}
+
+	ctlfd = open(devpath, O_RDWR);
+	if (ctlfd < 0) {
+		eprintf("cannot open %s %s\n", devpath, strerror(errno));
+		return -1;
+	}
+
+	return ctlfd;
+}
+
+#define CHRDEV_PATH "/dev/tgt"
+
+int kreq_init(void)
+{
+	int fd, size = TGT_RINGBUF_SIZE;
+	char *buf;
+
+	fd = ctrdev_open(CHRDEV_PATH);
+	if (fd < 0)
+		return fd;
+
+	buf = mmap(NULL, size * 2, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (buf == MAP_FAILED) {
+		eprintf("fail to mmap %s\n", strerror(errno));
+		close(fd);
+		return -EINVAL;
+	}
+
+	ring_init(&kuring, buf, size, sizeof(struct tgt_event));
+	ring_init(&ukring, buf + size, size, sizeof(struct tgt_event));
+
+	chrfd = fd;
+	return fd;
+}



From tomo at mail.berlios.de  Wed Jul 26 13:38:49 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 13:38:49 +0200
Subject: [Stgt-svn] r511 - trunk/usr
Message-ID: <200607261138.k6QBcnWf010995@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 13:38:00 +0200 (Wed, 26 Jul 2006)
New Revision: 511

Modified:
   trunk/usr/tgtd.c
Log:
Fix a bug that enable_drivers cannot handle one driver. The
initialization of drivers needs to be rewritten.


Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-26 05:41:04 UTC (rev 510)
+++ trunk/usr/tgtd.c	2006-07-26 11:38:00 UTC (rev 511)
@@ -199,16 +199,19 @@
 
 static int enable_drivers(char *data, int *npfd)
 {
-	char *list, *p;
+	char *list, *p, *q;
 	int index, err, np, ndriver = 0;
 
-	list = strdup(data);
-	if (!list)
+	p = list = strdup(data);
+	if (!p)
 		return 0;
 
-	p = strtok(list, ",");
 	while (p) {
+		q = strchr(p, ',');
+		if (q)
+			*q++ = '\0';
 		index = get_driver_index(p);
+		p = q;
 		if (index >= 0) {
 			np = 0;
 			if (tgt_drivers[index]->init) {
@@ -221,7 +224,6 @@
 			ndriver++;
 			*npfd += np;
 		}
-		p = strtok(NULL, ",");
 	}
 	free(list);
 



From tomo at mail.berlios.de  Wed Jul 26 15:18:04 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Wed, 26 Jul 2006 15:18:04 +0200
Subject: [Stgt-svn] r512 - trunk/usr
Message-ID: <200607261318.k6QDI4vD022647@sheep.berlios.de>

Author: tomo
Date: 2006-07-26 15:18:02 +0200 (Wed, 26 Jul 2006)
New Revision: 512

Modified:
   trunk/usr/tgtd.c
Log:
Just renaming

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-26 11:38:00 UTC (rev 511)
+++ trunk/usr/tgtd.c	2006-07-26 13:18:02 UTC (rev 512)
@@ -39,8 +39,8 @@
 #include "driver.h"
 
 enum {
-	POLL_IF, /* netlink socket between kernel and user space */
-	POLL_UD, /* unix domain socket for tgtdadm */
+	POLL_KI, /* kernel interface */
+	POLL_IPC, /* unix domain socket for tgtdadm */
 	POLL_END,
 };
 
@@ -147,14 +147,14 @@
 		goto retry;
 	}
 
-	if (pfd[POLL_IF].revents) {
+	if (pfd[POLL_KI].revents) {
 		kreq_recv();
 		nevent--;
 	}
 
-	if (pfd[POLL_UD].revents) {
+	if (pfd[POLL_IPC].revents) {
 		dprintf("ipc event\n");
-		ipc_event_handle(pfd[POLL_UD].fd);
+		ipc_event_handle(pfd[POLL_IPC].fd);
 		nevent--;
 	}
 
@@ -180,10 +180,10 @@
 	if (!pfd)
 		return NULL;
 
-	pfd[POLL_IF].fd = nl_fd;
-	pfd[POLL_IF].events = POLLIN;
-	pfd[POLL_UD].fd = ud_fd;
-	pfd[POLL_UD].events = POLLIN;
+	pfd[POLL_KI].fd = nl_fd;
+	pfd[POLL_KI].events = POLLIN;
+	pfd[POLL_IPC].fd = ud_fd;
+	pfd[POLL_IPC].events = POLLIN;
 
 	for (i = 0; tgt_drivers[i]; i++) {
 		d = tgt_drivers[i];
@@ -235,7 +235,7 @@
 	struct pollfd *pfd;
 	int err, ch, longindex, ndriver = 0, npfd = POLL_END;
 	int is_daemon = 1, is_debug = 1;
-	int if_fd, ud_fd, timeout = -1;
+	int ki_fd, ipc_fd, timeout = -1;
 
 	while ((ch = getopt_long(argc, argv, "s:d:fd:vh", long_options,
 				 &longindex)) >= 0) {
@@ -275,15 +275,15 @@
 	if (err)
 		exit(1);
 
-	if_fd = kreq_init();
-	if (if_fd < 0)
+	ki_fd = kreq_init();
+	if (ki_fd < 0)
 		exit(1);
 
-	ud_fd = ipc_open();
-	if (ud_fd < 0)
+	ipc_fd = ipc_open();
+	if (ipc_fd < 0)
 		exit(1);
 
-	pfd = poll_init(npfd, if_fd, ud_fd);
+	pfd = poll_init(npfd, ki_fd, ipc_fd);
 
 	event_loop(pfd, npfd, timeout);
 



From tomo at mail.berlios.de  Thu Jul 27 06:28:18 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 27 Jul 2006 06:28:18 +0200
Subject: [Stgt-svn] r513 - trunk/usr
Message-ID: <200607270428.k6R4SIkm022701@sheep.berlios.de>

Author: tomo
Date: 2006-07-27 06:28:12 +0200 (Thu, 27 Jul 2006)
New Revision: 513

Modified:
   trunk/usr/mgmt.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtadm.h
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
   trunk/usr/tgtif.c
Log:
Kill netlink in management code.


Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/mgmt.c	2006-07-27 04:28:12 UTC (rev 513)
@@ -33,8 +33,6 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
-#include <linux/netlink.h>
-#include <linux/types.h>
 #include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
@@ -42,6 +40,8 @@
 #include "tgtadm.h"
 #include "driver.h"
 
+#define BUFSIZE 4096
+
 static void device_create_parser(char *args, char **path, char **devtype)
 {
 	char *p, *q;
@@ -67,7 +67,7 @@
 }
 
 static int target_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       char *rbuf, int *rlen)
+		       struct tgtadm_res *res, int *rlen)
 {
 	int err = -EINVAL;
 
@@ -89,11 +89,14 @@
 		break;
 	}
 
+	res->err = err;
+	res->len = (char *) res->data - (char *) res;
+
 	return err;
 }
 
 static int device_mgmt(int lld_no, struct tgtadm_req *req, char *params,
-		       char *rbuf, int *rlen)
+		       struct tgtadm_res *res, int *rlen)
 {
 	int err = -EINVAL;
 	char *path, *devtype;
@@ -114,50 +117,47 @@
 		break;
 	}
 
+	res->err = err;
+	res->len = (char *) res->data - (char *) res;
+
 	return err;
 }
 
-int tgt_mgmt(int lld_no, char *sbuf, char *rbuf)
+int tgt_mgmt(int lld_no, struct tgtadm_req *req, struct tgtadm_res *res,
+	     int len)
 {
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct tgtadm_req *req;
-	struct tgtadm_res *res;
-	int err = -EINVAL, rlen = 0;
-	char *params;
+	int err = -EINVAL;
+	char *params = (char *) req->data;
 
-	req = NLMSG_DATA(nlh);
-	params = (char *) req + sizeof(*req);
-
 	dprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s %d\n",
-		nlh->nlmsg_len, lld_no, req->mode, req->op,
+		req->len, lld_no, req->mode, req->op,
 		req->tid, req->sid, req->lun, params, getpid());
 
 	switch (req->mode) {
 	case MODE_TARGET:
-		err = target_mgmt(lld_no, req, params, rbuf, &rlen);
+		err = target_mgmt(lld_no, req, params, res, &len);
 		break;
 	case MODE_DEVICE:
-		err = device_mgmt(lld_no, req, params, rbuf, &rlen);
+		err = device_mgmt(lld_no, req, params, res, &len);
 		break;
 	default:
 		break;
 	}
 
-	nlh = (struct nlmsghdr *) rbuf;
-	nlh->nlmsg_len = NLMSG_LENGTH(sizeof(*res) + rlen);
-	res = NLMSG_DATA(nlh);
-	res->err = err;
-
 	return err;
 }
 
-static int ipc_accept(int afd)
+static int ipc_accept(int accept_fd)
 {
 	struct sockaddr addr;
 	socklen_t len;
+	int fd;
 
 	len = sizeof(addr);
-	return accept(afd, (struct sockaddr *) &addr, &len);
+	fd = accept(accept_fd, (struct sockaddr *) &addr, &len);
+	if (fd < 0)
+		eprintf("can't accept a new connection %s\n", strerror(errno));
+	return fd;
 }
 
 static int ipc_perm(int fd)
@@ -168,112 +168,142 @@
 
 	len = sizeof(cred);
 	err = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, (void *) &cred, &len);
-	if (err < 0)
-		goto out;
+	if (err) {
+		eprintf("can't get sockopt %s\n", strerror(errno));
+		return -1;
+	}
 
-	if (cred.uid || cred.gid) {
-		err = -EPERM;
-		goto out;
-	}
-out:
-	return err;
+	if (cred.uid || cred.gid)
+		return -EPERM;
+
+	return 0;
 }
 
+static void ipc_send_res(int fd, struct tgtadm_res *res)
+{
+	struct iovec iov;
+	struct msghdr msg;
+	int err;
+
+	iov.iov_base = res;
+	iov.iov_len = res->len;
+	memset(&msg, 0, sizeof(msg));
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+
+	err = sendmsg(fd, &msg, MSG_DONTWAIT);
+	if (err != res->len)
+		eprintf("can't write %s\n", strerror(errno));
+}
+
 void ipc_event_handle(int accept_fd)
 {
 	int fd, err;
-	char sbuf[4096], rbuf[4096];
-	struct nlmsghdr *nlh;
+	char sbuf[BUFSIZE], rbuf[BUFSIZE];
 	struct iovec iov;
 	struct msghdr msg;
+	struct tgtadm_req *req;
 	struct tgtadm_res *res;
-	struct tgtadm_req *req;
-	int lld_no;
+	int lld_no, len;
 
+	req = (struct tgtadm_req *) sbuf;
+	memset(sbuf, 0, sizeof(sbuf));
+
 	fd = ipc_accept(accept_fd);
-	if (fd < 0) {
-		eprintf("%d\n", fd);
+	if (fd < 0)
 		return;
-	}
 
 	err = ipc_perm(fd);
 	if (err < 0)
-		goto fail;
+		goto out;
 
-	memset(sbuf, 0, sizeof(sbuf));
-	memset(rbuf, 0, sizeof(rbuf));
-
-	nlh = (struct nlmsghdr *) sbuf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(sizeof(struct nlmsghdr));
+	len = (char *) req->data - (char *) req;
+	iov.iov_base = req;
+	iov.iov_len = len;
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 
-	err = recvmsg(fd, &msg, MSG_PEEK);
-	if (err != NLMSG_ALIGN(sizeof(struct nlmsghdr))) {
-		err = -EIO;
-		goto fail;
+	err = recvmsg(fd, &msg, MSG_PEEK | MSG_DONTWAIT);
+	if (err != len) {
+		eprintf("can't read %s\n", strerror(errno));
+		goto out;
 	}
 
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
+	if (req->len > sizeof(sbuf) - len) {
+		eprintf("too long data %d\n", req->len);
+		goto out;
+	}
+
+	iov.iov_base = req;
+	iov.iov_len = req->len;
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 
 	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err < 0)
-		goto fail;
+	if (err != req->len) {
+		eprintf("can't read %s\n", strerror(errno));
+		err = -EIO;
+		goto out;
+	}
 
-	req = NLMSG_DATA(nlh);
-	dprintf("%d %s %d %d %d\n", req->mode, req->lld, err, nlh->nlmsg_len, fd);
+	dprintf("%d %s %d %d %d\n", req->mode, req->lld, err, req->len, fd);
+	res = (struct tgtadm_res *) rbuf;
+	memset(rbuf, 0, sizeof(rbuf));
+
 	lld_no = get_driver_index(req->lld);
 	if (lld_no < 0) {
-		err = -ENOENT;
-		goto fail;
+		eprintf("can't find the driver\n");
+		res->err = ENOENT;
+		res->len = (char *) res->data - (char *) res;
+		goto send;
 	}
 
-	err = tgt_mgmt(lld_no, (char *) nlh, rbuf);
+	err = tgt_mgmt(lld_no, req, res, sizeof(rbuf));
 	if (err)
-		eprintf("%d %d %d %d %d\n",
-			req->mode, lld_no, err, nlh->nlmsg_len, fd);
+		eprintf("%d %d %d %d\n", req->mode, lld_no, err, res->len);
+
 send:
-	err = write(fd, nlh, nlh->nlmsg_len);
-	if (err < 0)
-		eprintf("%d\n", err);
-
+	ipc_send_res(fd, res);
+out:
 	if (fd > 0)
 		close(fd);
 
 	return;
-fail:
-	nlh = (struct nlmsghdr *) rbuf;
-	res = NLMSG_DATA(nlh);
-	res->err = err;
-	nlh->nlmsg_len = NLMSG_LENGTH(0);
-	goto send;
 }
 
-int ipc_open(void)
+int ipc_open(int *ipc_fd)
 {
 	int fd, err;
 	struct sockaddr_un addr;
 
 	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
+	if (fd < 0) {
+		eprintf("can't open a socket %s\n", strerror(errno));
+		return -1;
+	}
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
 	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE,
 	       strlen(TGT_IPC_NAMESPACE));
 
-	if ((err = bind(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		return err;
+	err = bind(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err) {
+		eprintf("can't bind a socket %s\n", strerror(errno));
+		goto out;
+	}
 
-	if ((err = listen(fd, 32)) < 0)
-		return err;
+	err = listen(fd, 32);
+	if (err < 0) {
+		eprintf("can't listen a socket %s\n", strerror(errno));
+		goto out;
+	}
 
-	return fd;
+	*ipc_fd = fd;
+	return 0;
+out:
+	close(fd);
+	return -1;
 }

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/tgtadm.c	2006-07-27 04:28:12 UTC (rev 513)
@@ -35,8 +35,6 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/un.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
 
 #include "tgtd.h"
 #include "tgtadm.h"
@@ -122,85 +120,90 @@
 	exit(status == 0 ? 0 : -1);
 }
 
-static int ipc_mgmt_connect(void)
+static int ipc_mgmt_connect(int *fd)
 {
-	int fd, err;
+	int err;
 	struct sockaddr_un addr;
 
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
+	*fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+	if (*fd < 0) {
+		eprintf("Cannot create a socket %s\n", strerror(errno));
+		return -1;
+	}
 
 	memset(&addr, 0, sizeof(addr));
 	addr.sun_family = AF_LOCAL;
 	memcpy((char *) &addr.sun_path + 1, TGT_IPC_NAMESPACE, strlen(TGT_IPC_NAMESPACE));
 
-	err = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
-	if (err < 0)
-		return err;
+	err = connect(*fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (err < 0) {
+		eprintf("Cannot connect to tgtd %s\n", strerror(errno));
+		return -1;
+	}
 
-	return fd;
+	return 0;
 }
 
-static void ipc_mgmt_result(char *rbuf)
+static int ipc_mgmt_res(int fd)
 {
-	struct nlmsghdr *nlh = (struct nlmsghdr *) rbuf;
-	struct tgtadm_res *res = NLMSG_DATA(nlh);
+	struct tgtadm_res *res;
+	char buf[BUFSIZE];
+	int err, len = (void *) res->data - (void *) res;
 
-	if (res->err < 0)
-		fprintf(stderr, "%d\n", res->err);
+	err = read(fd, buf, len);
+	if (err < 0) {
+		eprintf("Cannot read from tgtd %s\n", strerror(errno));
+		return -1;
+	}
 
-	if (nlh->nlmsg_len > NLMSG_LENGTH(0))
-		fprintf(stderr, "%s\n", (char *) res + sizeof(*res));
-}
+	res = (struct tgtadm_res *) buf;
+	if (res->err) {
+		eprintf("Error %d\n", res->err);
+		return -1;
+	}
 
-static int ipc_mgmt_call(char *data, int len, char *rbuf)
-{
-	int fd, err;
-	char sbuf[8192];
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct iovec iov;
-	struct msghdr msg;
+	dprintf("got the response %d %d\n", res->err, res->len);
 
-	memset(sbuf, 0, sizeof(sbuf));
-	memcpy(NLMSG_DATA(nlh), data, len);
+	len = res->len - len;
+	if (!len)
+		return 0;
 
-	nlh->nlmsg_len = NLMSG_LENGTH(len);
-	nlh->nlmsg_type = 0;
-	nlh->nlmsg_flags = 0;
-	nlh->nlmsg_pid = getpid();
+	while (len) {
+		int t;
+		memset(buf, 0, sizeof(buf));
+		t = min_t(int, sizeof(buf), len);
+		err = read(fd, buf, t);
+		if (err < 0) {
+			eprintf("Cannot read from tgtd %s\n", strerror(errno));
+			return -1;
+		}
+		printf("%s", buf);
+		len -= t;
+	}
 
-	fd = ipc_mgmt_connect();
-	if (fd < 0)
-		return fd;
+	return 0;
+}
 
-	err = write(fd, sbuf, nlh->nlmsg_len);
+static int ipc_mgmt_req(struct tgtadm_req *req)
+{
+	int err, fd = 0;
+
+	err = ipc_mgmt_connect(&fd);
 	if (err < 0)
 		goto out;
 
-	nlh = (struct nlmsghdr *) rbuf;
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
+	err = write(fd, (char *) req, req->len);
+	if (err < 0) {
+		eprintf("Cannot send to tgtd %s\n", strerror(errno));
+		goto out;
+	}
 
-	err = recvmsg(fd, &msg, MSG_PEEK);
-	if (err < 0)
-		return err;
+	dprintf("sent to tgtd %d\n", err);
 
-	iov.iov_base = nlh;
-	iov.iov_len = NLMSG_ALIGN(nlh->nlmsg_len);
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-
-	err = recvmsg(fd, &msg, MSG_DONTWAIT);
-	if (err < 0)
-		return err;
-
+	err = ipc_mgmt_res(fd);
 out:
-	close(fd);
+	if (fd > 0)
+		close(fd);
 	return err;
 }
 
@@ -243,13 +246,13 @@
 int main(int argc, char **argv)
 {
 	int ch, longindex;
-	int err = -EINVAL, op = -1, len;
+	int err = -EINVAL, op = -1, len = 0;
 	int tid = -1;
 	uint32_t cid = 0, set = 0, hostno = 0;
 	uint64_t sid = 0, lun = 0;
 	char *params = NULL, *lldname = NULL;
 	struct tgtadm_req *req;
-	char sbuf[BUFSIZE], rbuf[BUFSIZE];
+	char buf[BUFSIZE];
 
 	optind = 1;
 	while ((ch = getopt_long(argc, argv, "n:o:t:s:c:l:p:uvh",
@@ -312,10 +315,9 @@
 		usage(-1);
 	}
 
-	memset(sbuf, 0, sizeof(sbuf));
-	memset(rbuf, 0, sizeof(rbuf));
+	memset(buf, 0, sizeof(buf));
 
-	req = (struct tgtadm_req *) sbuf;
+	req = (struct tgtadm_req *) buf;
 	strncpy(req->lld, lldname, sizeof(req->lld));
 	req->mode = set_to_mode(set);
 	req->op = op;
@@ -324,14 +326,13 @@
 	req->lun = lun;
 	req->host_no = hostno;
 
-	len = sizeof(struct tgtadm_req);
 	if (params) {
-		memcpy(sbuf + sizeof(struct tgtadm_req), params, strlen(params));
-		len += strlen(params);
+		len = min(strlen(params), sizeof(buf) - len);
+		strncpy((char *) req->data, params, len);
 	}
+	req->len = ((char *) req->data - (char *) req) + len;
 
-	err = ipc_mgmt_call(sbuf, len, rbuf);
-	ipc_mgmt_result(rbuf);
+	err = ipc_mgmt_req(req);
 out:
 	return err;
 }

Modified: trunk/usr/tgtadm.h
===================================================================
--- trunk/usr/tgtadm.h	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/tgtadm.h	2006-07-27 04:28:12 UTC (rev 513)
@@ -24,19 +24,21 @@
 struct tgtadm_req {
 	enum tgtadm_mode mode;
 	enum tgtadm_op op;
+	uint32_t len;
 
-	int tid;
+	uint32_t tid;
 	uint64_t sid;
-	int cid;
+	uint32_t cid;
 	uint64_t lun;
 	char lld[TGT_LLD_NAME_LEN];
-	int host_no;
-	unsigned long addr;
-};
+	uint32_t host_no;
+	uint64_t data[0];
+} __attribute__ ((aligned (sizeof(uint64_t))));
 
 struct tgtadm_res {
-	int err;
-	unsigned long addr;
-};
+	uint32_t err;
+	uint32_t len;
+	uint64_t data[0];
+} __attribute__ ((aligned (sizeof(uint64_t))));;
 
 #endif

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/tgtd.c	2006-07-27 04:28:12 UTC (rev 513)
@@ -275,12 +275,12 @@
 	if (err)
 		exit(1);
 
-	ki_fd = kreq_init();
-	if (ki_fd < 0)
+	err = kreq_init(&ki_fd);
+	if (err)
 		exit(1);
 
-	ipc_fd = ipc_open();
-	if (ipc_fd < 0)
+	err = ipc_open(&ipc_fd);
+	if (err)
 		exit(1);
 
 	pfd = poll_init(npfd, ki_fd, ipc_fd);

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/tgtd.h	2006-07-27 04:28:12 UTC (rev 513)
@@ -24,11 +24,11 @@
 	struct tgt_cmd_queue cmd_queue;
 };
 
-extern int kreq_init(void);
+extern int kreq_init(int *fd);
 extern int kreq_recv(void);
 extern int kreq_send(struct tgt_event *ev);
 
-extern int ipc_open(void);
+extern int ipc_open(int *fd);
 extern void ipc_event_handle(int accept_fd);
 
 extern void kreq_exec(struct tgt_event *ev);

Modified: trunk/usr/tgtif.c
===================================================================
--- trunk/usr/tgtif.c	2006-07-26 13:18:02 UTC (rev 512)
+++ trunk/usr/tgtif.c	2006-07-27 04:28:12 UTC (rev 513)
@@ -114,22 +114,23 @@
 	int devn;
 	int ctlfd;
 
-	if (!(f = fopen("/proc/devices", "r"))) {
+	f = fopen("/proc/devices", "r");
+	if (!f) {
 		eprintf("Cannot open control path to the driver\n");
 		return -1;
 	}
 
 	devn = 0;
 	while (!feof(f)) {
-		if (!fgets(buf, sizeof (buf), f)) {
+		if (!fgets(buf, sizeof (buf), f))
 			break;
-		}
-		if (sscanf(buf, "%d %s", &devn, devname) != 2) {
+
+		if (sscanf(buf, "%d %s", &devn, devname) != 2)
 			continue;
-		}
-		if (!strcmp(devname, "tgt")) {
+
+		if (!strcmp(devname, "tgt"))
 			break;
-		}
+
 		devn = 0;
 	}
 
@@ -157,7 +158,7 @@
 
 #define CHRDEV_PATH "/dev/tgt"
 
-int kreq_init(void)
+int kreq_init(int *ki_fd)
 {
 	int fd, size = TGT_RINGBUF_SIZE;
 	char *buf;
@@ -176,6 +177,7 @@
 	ring_init(&kuring, buf, size, sizeof(struct tgt_event));
 	ring_init(&ukring, buf + size, size, sizeof(struct tgt_event));
 
-	chrfd = fd;
-	return fd;
+	*ki_fd = chrfd = fd;
+
+	return 0;
 }



From tomo at mail.berlios.de  Thu Jul 27 14:43:43 2006
From: tomo at mail.berlios.de (tomo at BerliOS)
Date: Thu, 27 Jul 2006 14:43:43 +0200
Subject: [Stgt-svn] r514 - trunk/usr
Message-ID: <200607271243.k6RChh21006234@sheep.berlios.de>

Author: tomo
Date: 2006-07-27 14:43:39 +0200 (Thu, 27 Jul 2006)
New Revision: 514

Modified:
   trunk/usr/mgmt.c
   trunk/usr/scsi.c
   trunk/usr/target.c
   trunk/usr/tgtadm.c
   trunk/usr/tgtd.c
   trunk/usr/tgtd.h
Log:
Just cleanups.

Modified: trunk/usr/mgmt.c
===================================================================
--- trunk/usr/mgmt.c	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/mgmt.c	2006-07-27 12:43:39 UTC (rev 514)
@@ -24,7 +24,6 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <poll.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -273,7 +272,7 @@
 	return;
 }
 
-int ipc_open(int *ipc_fd)
+int ipc_init(int *ipc_fd)
 {
 	int fd, err;
 	struct sockaddr_un addr;

Modified: trunk/usr/scsi.c
===================================================================
--- trunk/usr/scsi.c	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/scsi.c	2006-07-27 12:43:39 UTC (rev 514)
@@ -22,9 +22,7 @@
 #include <asm/byteorder.h>
 #include <linux/fs.h>
 #include <scsi/scsi.h>
-#include <scsi/scsi_tgt_if.h>
 #include <sys/mman.h>
-#include <poll.h>
 
 #include "tgtd.h"
 #include "driver.h"

Modified: trunk/usr/target.c
===================================================================
--- trunk/usr/target.c	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/target.c	2006-07-27 12:43:39 UTC (rev 514)
@@ -34,7 +34,6 @@
 #include <linux/fs.h>
 #define BITS_PER_LONG (ULONG_MAX == 0xFFFFFFFFUL ? 32 : 64)
 #include <linux/hash.h>
-#include <linux/netlink.h>
 #include <scsi/scsi.h>
 
 #include "tgtd.h"

Modified: trunk/usr/tgtadm.c
===================================================================
--- trunk/usr/tgtadm.c	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/tgtadm.c	2006-07-27 12:43:39 UTC (rev 514)
@@ -55,7 +55,7 @@
 
 static struct option const long_options[] =
 {
-	{"driver", required_argument, NULL, 'n'},
+	{"lld", required_argument, NULL, 'n'},
 	{"op", required_argument, NULL, 'o'},
 	{"tid", required_argument, NULL, 't'},
 	{"sid", required_argument, NULL, 's'},

Modified: trunk/usr/tgtd.c
===================================================================
--- trunk/usr/tgtd.c	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/tgtd.c	2006-07-27 12:43:39 UTC (rev 514)
@@ -23,6 +23,7 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
+#include <poll.h>
 #include <signal.h>
 #include <string.h>
 #include <stdint.h>
@@ -30,10 +31,8 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <asm/types.h>
-#include <sys/poll.h>
 #include <sys/signal.h>
 #include <sys/stat.h>
-#include <scsi/scsi_tgt_if.h>
 
 #include "tgtd.h"
 #include "driver.h"
@@ -48,7 +47,7 @@
 
 static struct option const long_options[] =
 {
-	{"drivers", required_argument, 0, 'p'},
+	{"lld", required_argument, 0, 'l'},
 	{"foreground", no_argument, 0, 'f'},
 	{"debug", required_argument, 0, 'd'},
 	{"version", no_argument, 0, 'v'},
@@ -56,8 +55,28 @@
 	{0, 0, 0, 0},
 };
 
-static int daemon_init(void)
+static void usage(int status)
 {
+	if (status)
+		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
+	else {
+		printf("Usage: %s [OPTION]\n", program_name);
+		printf("\
+Target framework daemon.\n\
+  -l, --lld               specify low level drivers to run\n\
+  -f, --foreground        make the program run in the foreground\n\
+  -d, --debug debuglevel  print debugging information\n\
+  -h, --help              display this help and exit\n\
+");
+	}
+	exit(1);
+}
+
+static void signal_catch(int signo) {
+}
+
+static int daemonize(void)
+{
 	pid_t pid;
 
 	pid = fork();
@@ -76,40 +95,11 @@
 	return 0;
 }
 
-static void usage(int status)
+static void oom_adjust(void)
 {
-	if (status != 0)
-		fprintf(stderr, "Try `%s --help' for more information.\n", program_name);
-	else {
-		printf("Usage: %s [OPTION]\n", program_name);
-		printf("\
-Target framework daemon.\n\
-  -f, --foreground        make the program run in the foreground\n\
-  -d, --debug debuglevel  print debugging information\n\
-  -h, --help              display this help and exit\n\
-");
-	}
-	exit(1);
-}
-
-static void signal_catch(int signo) {
-}
-
-static void tgtd_init(void)
-{
 	int fd;
 	char path[64];
-	struct sigaction sa_old;
-	struct sigaction sa_new;
 
-	/* do not allow ctrl-c for now... */
-	sa_new.sa_handler = signal_catch;
-	sigemptyset(&sa_new.sa_mask);
-	sa_new.sa_flags = 0;
-	sigaction(SIGINT, &sa_new, &sa_old );
-	sigaction(SIGPIPE, &sa_new, &sa_old );
-	sigaction(SIGTERM, &sa_new, &sa_old );
-
 	/* Should we use RT stuff? */
 	nice(-20);
 
@@ -170,7 +160,7 @@
 	goto retry;
 }
 
-static struct pollfd *poll_init(int npfd, int nl_fd, int ud_fd)
+static struct pollfd *pfd_init(int npfd, int nl_fd, int ud_fd)
 {
 	struct tgt_driver *d;
 	struct pollfd *pfd;
@@ -197,7 +187,7 @@
 	return pfd;
 }
 
-static int enable_drivers(char *data, int *npfd)
+static int lld_init(char *data, int *npfd)
 {
 	char *list, *p, *q;
 	int index, err, np, ndriver = 0;
@@ -233,15 +223,25 @@
 int main(int argc, char **argv)
 {
 	struct pollfd *pfd;
-	int err, ch, longindex, ndriver = 0, npfd = POLL_END;
+	struct sigaction sa_old;
+	struct sigaction sa_new;
+	int err, ch, longindex, nr_lld = 0, nr_pfd = POLL_END;
 	int is_daemon = 1, is_debug = 1;
 	int ki_fd, ipc_fd, timeout = -1;
 
-	while ((ch = getopt_long(argc, argv, "s:d:fd:vh", long_options,
+	/* do not allow ctrl-c for now... */
+	sa_new.sa_handler = signal_catch;
+	sigemptyset(&sa_new.sa_mask);
+	sa_new.sa_flags = 0;
+	sigaction(SIGINT, &sa_new, &sa_old );
+	sigaction(SIGPIPE, &sa_new, &sa_old );
+	sigaction(SIGTERM, &sa_new, &sa_old );
+
+	while ((ch = getopt_long(argc, argv, "l:fd:vh", long_options,
 				 &longindex)) >= 0) {
 		switch (ch) {
 		case 'p':
-			ndriver = enable_drivers(optarg, &npfd);
+			nr_lld = lld_init(optarg, &nr_pfd);
 			break;
 		case 'f':
 			is_daemon = 0;
@@ -261,15 +261,15 @@
 		}
 	}
 
-	if (!ndriver) {
-		printf("No driver!\n");
+	if (!nr_lld) {
+		printf("No available low level driver!\n");
 		exit(1);
 	}
 
-	if (is_daemon && daemon_init())
+	if (is_daemon && daemonize())
 		exit(1);
 
-	tgtd_init();
+	oom_adjust();
 
 	err = log_init(program_name, LOG_SPACE_SIZE, is_daemon, is_debug);
 	if (err)
@@ -279,13 +279,13 @@
 	if (err)
 		exit(1);
 
-	err = ipc_open(&ipc_fd);
+	err = ipc_init(&ipc_fd);
 	if (err)
 		exit(1);
 
-	pfd = poll_init(npfd, ki_fd, ipc_fd);
+	pfd = pfd_init(nr_pfd, ki_fd, ipc_fd);
 
-	event_loop(pfd, npfd, timeout);
+	event_loop(pfd, nr_pfd, timeout);
 
 	return 0;
 }

Modified: trunk/usr/tgtd.h
===================================================================
--- trunk/usr/tgtd.h	2006-07-27 04:28:12 UTC (rev 513)
+++ trunk/usr/tgtd.h	2006-07-27 12:43:39 UTC (rev 514)
@@ -28,7 +28,7 @@
 extern int kreq_recv(void);
 extern int kreq_send(struct tgt_event *ev);
 
-extern int ipc_open(int *fd);
+extern int ipc_init(int *fd);
 extern void ipc_event_handle(int accept_fd);
 
 extern void kreq_exec(struct tgt_event *ev);



