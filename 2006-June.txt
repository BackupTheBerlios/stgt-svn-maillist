From tomo at berlios.de  Thu Jun  1 16:01:06 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 1 Jun 2006 16:01:06 +0200
Subject: [Stgt-svn] r484 - in branches/use-scsi-ml/istgt: include kernel
Message-ID: <200606011401.k51E16HS031586@sheep.berlios.de>

Author: tomo
Date: 2006-06-01 16:01:04 +0200 (Thu, 01 Jun 2006)
New Revision: 484

Modified:
   branches/use-scsi-ml/istgt/include/iscsi_if.h
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.c
   branches/use-scsi-ml/istgt/kernel/libiscsi.h
   branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
Log:
Sync with the latest open-iscsi code (r596).


Modified: branches/use-scsi-ml/istgt/include/iscsi_if.h
===================================================================
--- branches/use-scsi-ml/istgt/include/iscsi_if.h	2006-05-22 16:19:14 UTC (rev 483)
+++ branches/use-scsi-ml/istgt/include/iscsi_if.h	2006-06-01 14:01:04 UTC (rev 484)
@@ -253,7 +253,6 @@
  * These flags describes reason of stop_conn() call
  */
 #define STOP_CONN_TERM		0x1
-#define STOP_CONN_SUSPEND	0x2
 #define STOP_CONN_RECOVER	0x3
 
 #define ISCSI_STATS_CUSTOM_MAX		32

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-05-22 16:19:14 UTC (rev 483)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-06-01 14:01:04 UTC (rev 484)
@@ -43,11 +43,13 @@
 
 #include "iscsi_tcp.h"
 
+#define ISCSI_TCP_VERSION "1.0-595"
+
 MODULE_AUTHOR("Dmitry Yusupov <dmitry_yus at yahoo.com>, "
 	      "Alex Aizman <itn780 at yahoo.com>");
 MODULE_DESCRIPTION("iSCSI/TCP data-path");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("0:4.445");
+MODULE_VERSION(ISCSI_TCP_VERSION);
 /* #define DEBUG_TCP */
 #define DEBUG_ASSERT
 
@@ -764,8 +766,8 @@
 	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
 
 	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
-		debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-			   (long)cask->sc, ctask->sc->result, ctask->itt);
+		debug_scsi("done [sc %p res %d itt 0x%x]\n", ctask->sc,
+			   (struct scsi_cmnd *) (ctask->sc)->result, ctask->itt);
 		spin_lock(&conn->session->lock);
 		__iscsi_ctask_cleanup(conn, ctask);
 		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);
@@ -862,7 +864,7 @@
 		       if (rc == -EAGAIN)
 				goto nomore;
 		       else {
-				iscsi_conn_failure(conn, rc);
+				iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 				return 0;
 		       }
 		}
@@ -879,7 +881,7 @@
 			}
 			tcp_conn->in_progress = IN_PROGRESS_DATA_RECV;
 		} else if (rc) {
-			iscsi_conn_failure(conn, rc);
+			iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 			return 0;
 		}
 	}
@@ -922,7 +924,7 @@
 		if (rc) {
 			if (rc == -EAGAIN)
 				goto again;
-			iscsi_conn_failure(conn, rc);
+			iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 			return 0;
 		}
 		tcp_conn->in.copy -= tcp_conn->in.padding;
@@ -1031,7 +1033,6 @@
 
 	tcp_conn->old_write_space(sk);
 	debug_tcp("iscsi_write_space: cid %d\n", conn->id);
-	clear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
 	scsi_queue_work(conn->session->host, &conn->xmitwork);
 }
 
@@ -1081,7 +1082,7 @@
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct socket *sk = tcp_conn->sock;
-	int offset = buf->sg.offset + buf->sent;
+	int offset = buf->sg.offset + buf->sent, res;
 
 	/*
 	 * if we got use_sg=0 or are sending something we kmallocd
@@ -1092,10 +1093,22 @@
 	 * slab case.
 	 */
 	if (buf->use_sendmsg)
-		return sock_no_sendpage(sk, buf->sg.page, offset, size, flags);
+		res = sock_no_sendpage(sk, buf->sg.page, offset, size, flags);
 	else
-		return tcp_conn->sendpage(sk, buf->sg.page, offset, size,
-					  flags);
+		res = tcp_conn->sendpage(sk, buf->sg.page, offset, size, flags);
+
+	if (res >= 0) {
+		conn->txdata_octets += res;
+		buf->sent += res;
+		return res;
+	}
+
+	tcp_conn->sendpage_failures_cnt++;
+	if (res == -EAGAIN)
+		res = -ENOBUFS;
+	else
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	return res;
 }
 
 /**
@@ -1110,7 +1123,6 @@
 static inline int
 iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 {
-	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1122,17 +1134,10 @@
 	res = iscsi_send(conn, buf, size, flags);
 	debug_tcp("sendhdr %d bytes, sent %d res %d\n", size, buf->sent, res);
 	if (res >= 0) {
-		conn->txdata_octets += res;
-		buf->sent += res;
 		if (size != res)
 			return -EAGAIN;
 		return 0;
-	} else if (res == -EAGAIN) {
-		tcp_conn = conn->dd_data;
-		tcp_conn->sendpage_failures_cnt++;
-		set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
-	} else if (res == -EPIPE)
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	}
 
 	return res;
 }
@@ -1151,7 +1156,6 @@
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent)
 {
-	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1166,19 +1170,12 @@
 	debug_tcp("sendpage: %d bytes, sent %d left %d sent %d res %d\n",
 		  size, buf->sent, *count, *sent, res);
 	if (res >= 0) {
-		conn->txdata_octets += res;
-		buf->sent += res;
 		*count -= res;
 		*sent += res;
 		if (size != res)
 			return -EAGAIN;
 		return 0;
-	} else if (res == -EAGAIN) {
-		tcp_conn = conn->dd_data;
-		tcp_conn->sendpage_failures_cnt++;
-		set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
-	} else if (res == -EPIPE)
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	}
 
 	return res;
 }
@@ -1367,6 +1364,7 @@
 iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 {
 	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
+	int rc;
 
 	debug_scsi("mtask deq [cid %d state %x itt 0x%x]\n",
 		conn->id, tcp_mtask->xmstate, mtask->itt);
@@ -1380,12 +1378,13 @@
 		    conn->hdrdgst_en)
 			iscsi_hdr_digest(conn, &tcp_mtask->headbuf,
 					(u8*)tcp_mtask->hdrext);
-		if (iscsi_sendhdr(conn, &tcp_mtask->headbuf,
-				  mtask->data_count)) {
+		rc = iscsi_sendhdr(conn, &tcp_mtask->headbuf,
+				   mtask->data_count);
+		if (rc) {
 			tcp_mtask->xmstate |= XMSTATE_IMM_HDR;
 			if (mtask->data_count)
 				tcp_mtask->xmstate &= ~XMSTATE_IMM_DATA;
-			return -EAGAIN;
+			return rc;
 		}
 	}
 
@@ -1396,10 +1395,13 @@
 		 * Virtual buffer could be spreaded across multiple pages...
 		 */
 		do {
-			if (iscsi_sendpage(conn, &tcp_mtask->sendbuf,
-				   &mtask->data_count, &tcp_mtask->sent)) {
+			int rc;
+
+			rc = iscsi_sendpage(conn, &tcp_mtask->sendbuf,
+					&mtask->data_count, &tcp_mtask->sent);
+			if (rc) {
 				tcp_mtask->xmstate |= XMSTATE_IMM_DATA;
-				return -EAGAIN;
+				return rc;
 			}
 		} while (mtask->data_count);
 	}
@@ -1421,16 +1423,19 @@
 handle_xmstate_r_hdr(struct iscsi_conn *conn,
 		     struct iscsi_tcp_cmd_task *tcp_ctask)
 {
+	int rc;
+
 	tcp_ctask->xmstate &= ~XMSTATE_R_HDR;
 	if (conn->hdrdgst_en)
 		iscsi_hdr_digest(conn, &tcp_ctask->headbuf,
 				 (u8*)tcp_ctask->hdrext);
-	if (!iscsi_sendhdr(conn, &tcp_ctask->headbuf, 0)) {
+	rc = iscsi_sendhdr(conn, &tcp_ctask->headbuf, 0);
+	if (!rc) {
 		BUG_ON(tcp_ctask->xmstate != XMSTATE_IDLE);
 		return 0; /* wait for Data-In */
 	}
 	tcp_ctask->xmstate |= XMSTATE_R_HDR;
-	return -EAGAIN;
+	return rc;
 }
 
 static inline int
@@ -1438,16 +1443,16 @@
 		     struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	int rc;
 
 	tcp_ctask->xmstate &= ~XMSTATE_W_HDR;
 	if (conn->hdrdgst_en)
 		iscsi_hdr_digest(conn, &tcp_ctask->headbuf,
 				 (u8*)tcp_ctask->hdrext);
-	if (iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->imm_count)) {
+	rc = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->imm_count);
+	if (rc)
 		tcp_ctask->xmstate |= XMSTATE_W_HDR;
-		return -EAGAIN;
-	}
-	return 0;
+	return rc;
 }
 
 static inline int
@@ -1455,17 +1460,19 @@
 			   struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	int rc;
 
 	tcp_ctask->xmstate &= ~XMSTATE_DATA_DIGEST;
 	debug_tcp("resent data digest 0x%x\n", tcp_ctask->datadigest);
-	if (iscsi_digest_final_send(conn, ctask, &tcp_ctask->immbuf,
-				    &tcp_ctask->datadigest, 0)) {
+	rc = iscsi_digest_final_send(conn, ctask, &tcp_ctask->immbuf,
+				    &tcp_ctask->datadigest, 0);
+	if (rc) {
 		tcp_ctask->xmstate |= XMSTATE_DATA_DIGEST;
 		debug_tcp("resent data digest 0x%x fail!\n",
 			  tcp_ctask->datadigest);
-		return -EAGAIN;
 	}
-	return 0;
+
+	return rc;
 }
 
 static inline int
@@ -1473,6 +1480,7 @@
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	int rc;
 
 	BUG_ON(!ctask->imm_count);
 	tcp_ctask->xmstate &= ~XMSTATE_IMM_DATA;
@@ -1483,8 +1491,9 @@
 	}
 
 	for (;;) {
-		if (iscsi_sendpage(conn, &tcp_ctask->sendbuf, &ctask->imm_count,
-				   &tcp_ctask->sent)) {
+		rc = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
+				   &ctask->imm_count, &tcp_ctask->sent);
+		if (rc) {
 			tcp_ctask->xmstate |= XMSTATE_IMM_DATA;
 			if (conn->datadgst_en) {
 				crypto_digest_final(tcp_conn->data_tx_tfm,
@@ -1492,7 +1501,7 @@
 				debug_tcp("tx imm sendpage fail 0x%x\n",
 					  tcp_ctask->datadigest);
 			}
-			return -EAGAIN;
+			return rc;
 		}
 		if (conn->datadgst_en)
 			crypto_digest_update(tcp_conn->data_tx_tfm,
@@ -1505,11 +1514,12 @@
 	}
 
 	if (conn->datadgst_en && !(tcp_ctask->xmstate & XMSTATE_W_PAD)) {
-		if (iscsi_digest_final_send(conn, ctask, &tcp_ctask->immbuf,
-				            &tcp_ctask->immdigest, 1)) {
+		rc = iscsi_digest_final_send(conn, ctask, &tcp_ctask->immbuf,
+				            &tcp_ctask->immdigest, 1);
+		if (rc) {
 			debug_tcp("sending imm digest 0x%x fail!\n",
 				  tcp_ctask->immdigest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("sending imm digest 0x%x\n", tcp_ctask->immdigest);
 	}
@@ -1521,8 +1531,9 @@
 handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+ 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_data_task *dtask;
+	int rc;
 
 	tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
 	if (tcp_ctask->xmstate & XMSTATE_UNS_INIT) {
@@ -1533,10 +1544,12 @@
 					(u8*)dtask->hdrext);
 		tcp_ctask->xmstate &= ~XMSTATE_UNS_INIT;
 	}
-	if (iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count)) {
+
+	rc = iscsi_sendhdr(conn, &tcp_ctask->headbuf, ctask->data_count);
+	if (rc) {
 		tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
 		tcp_ctask->xmstate |= XMSTATE_UNS_HDR;
-		return -EAGAIN;
+		return rc;
 	}
 
 	debug_scsi("uns dout [itt 0x%x dlen %d sent %d]\n",
@@ -1550,6 +1563,7 @@
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_data_task *dtask = tcp_ctask->dtask;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	int rc;
 
 	BUG_ON(!ctask->data_count);
 	tcp_ctask->xmstate &= ~XMSTATE_UNS_DATA;
@@ -1562,8 +1576,9 @@
 	for (;;) {
 		int start = tcp_ctask->sent;
 
-		if (iscsi_sendpage(conn, &tcp_ctask->sendbuf,
-				   &ctask->data_count, &tcp_ctask->sent)) {
+		rc = iscsi_sendpage(conn, &tcp_ctask->sendbuf,
+				   &ctask->data_count, &tcp_ctask->sent);
+		if (rc) {
 			ctask->unsol_count -= tcp_ctask->sent - start;
 			tcp_ctask->xmstate |= XMSTATE_UNS_DATA;
 			/* will continue with this ctask later.. */
@@ -1573,7 +1588,7 @@
 				debug_tcp("tx uns data fail 0x%x\n",
 					  dtask->digest);
 			}
-			return -EAGAIN;
+			return rc;
 		}
 
 		BUG_ON(tcp_ctask->sent > ctask->total_length);
@@ -1600,12 +1615,13 @@
 	 */
 	if (ctask->unsol_count) {
 		if (conn->datadgst_en) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &dtask->digestbuf,
-						    &dtask->digest, 1)) {
+						    &dtask->digest, 1);
+			if (rc) {
 				debug_tcp("send uns digest 0x%x fail\n",
 					  dtask->digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("sending uns digest 0x%x, more uns\n",
 				  dtask->digest);
@@ -1615,12 +1631,13 @@
 	}
 
 	if (conn->datadgst_en && !(tcp_ctask->xmstate & XMSTATE_W_PAD)) {
-		if (iscsi_digest_final_send(conn, ctask,
+		rc = iscsi_digest_final_send(conn, ctask,
 					    &dtask->digestbuf,
-					    &dtask->digest, 1)) {
+					    &dtask->digest, 1);
+		if (rc) {
 			debug_tcp("send last uns digest 0x%x fail\n",
 				   dtask->digest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("sending uns digest 0x%x\n",dtask->digest);
 	}
@@ -1636,7 +1653,7 @@
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_r2t_info *r2t = tcp_ctask->r2t;
 	struct iscsi_data_task *dtask = &r2t->dtask;
-	int left;
+	int left, rc;
 
 	tcp_ctask->xmstate &= ~XMSTATE_SOL_DATA;
 	tcp_ctask->dtask = dtask;
@@ -1652,7 +1669,8 @@
 	if (!r2t->data_count)
 		goto data_out_done;
 
-	if (iscsi_sendpage(conn, &r2t->sendbuf, &r2t->data_count, &r2t->sent)) {
+	rc = iscsi_sendpage(conn, &r2t->sendbuf, &r2t->data_count, &r2t->sent);
+	if (rc) {
 		tcp_ctask->xmstate |= XMSTATE_SOL_DATA;
 		/* will continue with this ctask later.. */
 		if (conn->datadgst_en) {
@@ -1660,7 +1678,7 @@
 					  (u8 *)&dtask->digest);
 			debug_tcp("r2t data send fail 0x%x\n", dtask->digest);
 		}
-		return -EAGAIN;
+		return rc;
 	}
 
 	BUG_ON(r2t->data_count < 0);
@@ -1687,12 +1705,13 @@
 	left = r2t->data_length - r2t->sent;
 	if (left) {
 		if (conn->datadgst_en) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &dtask->digestbuf,
-						    &dtask->digest, 1)) {
+						    &dtask->digest, 1);
+			if (rc) {
 				debug_tcp("send r2t data digest 0x%x"
 					  "fail\n", dtask->digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("r2t data send digest 0x%x\n",
 				  dtask->digest);
@@ -1709,11 +1728,12 @@
 	 */
 	BUG_ON(tcp_ctask->r2t_data_count - r2t->data_length < 0);
 	if (conn->datadgst_en) {
-		if (iscsi_digest_final_send(conn, ctask, &dtask->digestbuf,
-					    &dtask->digest, 1)) {
+		rc = iscsi_digest_final_send(conn, ctask, &dtask->digestbuf,
+					    &dtask->digest, 1);
+		if (rc) {
 			debug_tcp("send last r2t data digest 0x%x"
 				  "fail\n", dtask->digest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("r2t done dout digest 0x%x\n", dtask->digest);
 	}
@@ -1739,15 +1759,16 @@
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 	struct iscsi_data_task *dtask = tcp_ctask->dtask;
-	int sent;
+	int sent, rc;
 
 	tcp_ctask->xmstate &= ~XMSTATE_W_PAD;
 	iscsi_buf_init_iov(&tcp_ctask->sendbuf, (char*)&tcp_ctask->pad,
 			    tcp_ctask->pad_count);
-	if (iscsi_sendpage(conn, &tcp_ctask->sendbuf, &tcp_ctask->pad_count,
-			   &sent)) {
+	rc = iscsi_sendpage(conn, &tcp_ctask->sendbuf, &tcp_ctask->pad_count,
+			   &sent);
+	if (rc) {
 		tcp_ctask->xmstate |= XMSTATE_W_PAD;
-		return -EAGAIN;
+		return rc;
 	}
 
 	if (conn->datadgst_en) {
@@ -1755,22 +1776,24 @@
 				     &tcp_ctask->sendbuf.sg, 1);
 		/* imm data? */
 		if (!dtask) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &tcp_ctask->immbuf,
-						    &tcp_ctask->immdigest, 1)) {
+						    &tcp_ctask->immdigest, 1);
+			if (rc) {
 				debug_tcp("send padding digest 0x%x"
 					  "fail!\n", tcp_ctask->immdigest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("done with padding, digest 0x%x\n",
 				  tcp_ctask->datadigest);
 		} else {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &dtask->digestbuf,
-						    &dtask->digest, 1)) {
+						    &dtask->digest, 1);
+			if (rc) {
 				debug_tcp("send padding digest 0x%x"
 				          "fail\n", dtask->digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("done with padding, digest 0x%x\n",
 				  dtask->digest);
@@ -1794,10 +1817,8 @@
 	if (ctask->mtask)
 		return rc;
 
-	if (tcp_ctask->xmstate & XMSTATE_R_HDR) {
-		rc = handle_xmstate_r_hdr(conn, tcp_ctask);
-		return rc;
-	}
+	if (tcp_ctask->xmstate & XMSTATE_R_HDR)
+		return handle_xmstate_r_hdr(conn, tcp_ctask);
 
 	if (tcp_ctask->xmstate & XMSTATE_W_HDR) {
 		rc = handle_xmstate_w_hdr(conn, ctask);
@@ -1849,10 +1870,11 @@
 		if (conn->hdrdgst_en)
 			iscsi_hdr_digest(conn, &r2t->headbuf,
 					(u8*)r2t->dtask.hdrext);
-		if (iscsi_sendhdr(conn, &r2t->headbuf, r2t->data_count)) {
+		rc = iscsi_sendhdr(conn, &r2t->headbuf, r2t->data_count);
+		if (rc) {
 			tcp_ctask->xmstate &= ~XMSTATE_SOL_DATA;
 			tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
-			return -EAGAIN;
+			return rc;
 		}
 
 		debug_scsi("sol dout [dsn %d itt 0x%x dlen %d sent %d]\n",
@@ -1999,30 +2021,28 @@
 	if (err)
 		return err;
 
-	if (conn->stop_stage != STOP_CONN_SUSPEND) {
-		/* bind iSCSI connection and socket */
-		tcp_conn->sock = sock;
+	/* bind iSCSI connection and socket */
+	tcp_conn->sock = sock;
 
-		/* setup Socket parameters */
-		sk = sock->sk;
-		sk->sk_reuse = 1;
-		sk->sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
-		sk->sk_allocation = GFP_ATOMIC;
+	/* setup Socket parameters */
+	sk = sock->sk;
+	sk->sk_reuse = 1;
+	sk->sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
+	sk->sk_allocation = GFP_ATOMIC;
 
-		/* FIXME: disable Nagle's algorithm */
+	/* FIXME: disable Nagle's algorithm */
 
-		/*
-		 * Intercept TCP callbacks for sendfile like receive
-		 * processing.
-		 */
-		conn->recv_lock = &sk->sk_callback_lock;
-		iscsi_conn_set_callbacks(conn);
-		tcp_conn->sendpage = tcp_conn->sock->ops->sendpage;
-		/*
-		 * set receive state machine into initial state
-		 */
-		tcp_conn->in_progress = IN_PROGRESS_WAIT_HEADER;
-	}
+	/*
+	 * Intercept TCP callbacks for sendfile like receive
+	 * processing.
+	 */
+	conn->recv_lock = &sk->sk_callback_lock;
+	iscsi_conn_set_callbacks(conn);
+	tcp_conn->sendpage = tcp_conn->sock->ops->sendpage;
+	/*
+	 * set receive state machine into initial state
+	 */
+	tcp_conn->in_progress = IN_PROGRESS_WAIT_HEADER;
 
 	return 0;
 }
@@ -2497,8 +2517,8 @@
 EXPORT_SYMBOL_GPL(iscsi_tcp_session_destroy);
 
 static struct scsi_host_template iscsi_sht = {
-	.name			= "iSCSI Initiator over TCP/IP, v."
-				  ISCSI_VERSION_STR,
+	.name			= "iSCSI Initiator over TCP/IP, v"
+				  ISCSI_TCP_VERSION,
 	.queuecommand           = iscsi_queuecommand,
 	.change_queue_depth	= iscsi_change_queue_depth,
 	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-05-22 16:19:14 UTC (rev 483)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.c	2006-06-01 14:01:04 UTC (rev 484)
@@ -487,7 +487,12 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&session->lock, flags);
-	if (session->conn_cnt == 1 || session->leadconn == conn)
+	if (session->state == ISCSI_STATE_FAILED) {
+		spin_unlock_irqrestore(&session->lock, flags);
+		return;
+	}
+
+	if (conn->stop_stage == 0)
 		session->state = ISCSI_STATE_FAILED;
 	spin_unlock_irqrestore(&session->lock, flags);
 	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
@@ -508,10 +513,11 @@
 static int iscsi_data_xmit(struct iscsi_conn *conn)
 {
 	struct iscsi_transport *tt;
+	int rc = 0;
 
 	if (unlikely(conn->suspend_tx)) {
 		debug_scsi("conn %d Tx suspended!\n", conn->id);
-		return 0;
+		return -ENODATA;
 	}
 	tt = conn->session->tt;
 
@@ -531,13 +537,15 @@
 	BUG_ON(conn->ctask && conn->mtask);
 
 	if (conn->ctask) {
-		if (tt->xmit_cmd_task(conn, conn->ctask))
+		rc = tt->xmit_cmd_task(conn, conn->ctask);
+		if (rc)
 			goto again;
 		/* done with this in-progress ctask */
 		conn->ctask = NULL;
 	}
 	if (conn->mtask) {
-	        if (tt->xmit_mgmt_task(conn, conn->mtask))
+		rc = tt->xmit_mgmt_task(conn, conn->mtask);
+	        if (rc)
 		        goto again;
 		/* done with this in-progress mtask */
 		conn->mtask = NULL;
@@ -547,9 +555,12 @@
         if (unlikely(__kfifo_len(conn->immqueue))) {
 	        while (__kfifo_get(conn->immqueue, (void*)&conn->mtask,
 			           sizeof(void*))) {
+			spin_lock_bh(&conn->session->lock);
 			list_add_tail(&conn->mtask->running,
 				      &conn->mgmt_run_list);
-		        if (tt->xmit_mgmt_task(conn, conn->mtask))
+			spin_unlock_bh(&conn->session->lock);
+			rc = tt->xmit_mgmt_task(conn, conn->mtask);
+		        if (rc)
 			        goto again;
 	        }
 		/* done with this mtask */
@@ -563,11 +574,15 @@
 		 * iscsi tcp may readd the task to the xmitqueue to send
 		 * write data
 		 */
+		spin_lock_bh(&conn->session->lock);
 		if (list_empty(&conn->ctask->running))
 			list_add_tail(&conn->ctask->running, &conn->run_list);
-		if (tt->xmit_cmd_task(conn, conn->ctask))
+		spin_unlock_bh(&conn->session->lock);
+		rc = tt->xmit_cmd_task(conn, conn->ctask);
+		if (rc)
 			goto again;
 	}
+
 	/* done with this ctask */
 	conn->ctask = NULL;
 
@@ -575,34 +590,38 @@
         if (unlikely(__kfifo_len(conn->mgmtqueue))) {
 	        while (__kfifo_get(conn->mgmtqueue, (void*)&conn->mtask,
 			           sizeof(void*))) {
+			spin_lock_bh(&conn->session->lock);
 			list_add_tail(&conn->mtask->running,
 				      &conn->mgmt_run_list);
-		        if (tt->xmit_mgmt_task(conn, conn->mtask))
+			spin_unlock_bh(&conn->session->lock);
+		        rc = tt->xmit_mgmt_task(conn, conn->mtask);
+			if (rc)
 			        goto again;
 	        }
 		/* done with this mtask */
 		conn->mtask = NULL;
 	}
 
-	return 0;
+	return -ENODATA;
 
 again:
 	if (unlikely(conn->suspend_tx))
-		return 0;
+		return -ENODATA;
 
-	return -EAGAIN;
+	return rc;
 }
 
 static void iscsi_xmitworker(void *data)
 {
 	struct iscsi_conn *conn = data;
-
+	int rc;
 	/*
 	 * serialize Xmit worker on a per-connection basis.
 	 */
 	mutex_lock(&conn->xmitmutex);
-	if (iscsi_data_xmit(conn))
-		scsi_queue_work(conn->session->host, &conn->xmitwork);
+	do {
+		rc = iscsi_data_xmit(conn);
+	} while (rc >= 0 || rc == -EAGAIN);
 	mutex_unlock(&conn->xmitmutex);
 }
 
@@ -612,6 +631,7 @@
 	FAILURE_SESSION_FREED,
 	FAILURE_WINDOW_CLOSED,
 	FAILURE_SESSION_TERMINATE,
+	FAILURE_SESSION_IN_RECOVERY,
 	FAILURE_SESSION_RECOVERY_TIMEOUT,
 };
 
@@ -631,18 +651,30 @@
 
 	spin_lock(&session->lock);
 
-	if (session->state != ISCSI_STATE_LOGGED_IN) {
-		if (session->recovery_failed) {
-			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
-			goto fault;
-		} else if (session->state == ISCSI_STATE_FAILED) {
-			reason = FAILURE_SESSION_FAILED;
+	/*
+	 * ISCSI_STATE_FAILED is a temp. state. The recovery
+	 * code will decide what is best to do with command queued
+	 * during this time
+	 */
+	if (session->state != ISCSI_STATE_LOGGED_IN &&
+	    session->state != ISCSI_STATE_FAILED) {
+		/*
+		 * to handle the race between when we set the recovery state
+		 * and block the session we requeue here (commands could
+		 * be entering our queuecommand while a block is starting
+		 * up because the block code is not locked)
+		 */
+		if (session->state == ISCSI_STATE_IN_RECOVERY) {
+			reason = FAILURE_SESSION_IN_RECOVERY;
 			goto reject;
-		} else if (session->state == ISCSI_STATE_TERMINATE) {
-			reason = FAILURE_SESSION_TERMINATE;
-			goto fault;
 		}
-		reason = FAILURE_SESSION_FREED;
+
+		if (session->state == ISCSI_STATE_RECOVERY_FAILED)
+			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
+		else if (session->state == ISCSI_STATE_TERMINATE)
+			reason = FAILURE_SESSION_TERMINATE;
+		else
+			reason = FAILURE_SESSION_FREED;
 		goto fault;
 	}
 
@@ -728,8 +760,8 @@
 		 */
 		mtask = conn->login_mtask;
 	else {
-	        BUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);
-	        BUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);
+		BUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);
+		BUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);
 
 		nop->exp_statsn = cpu_to_be32(conn->exp_statsn);
 		if (!__kfifo_get(session->mgmtpool.queue,
@@ -803,7 +835,7 @@
 
 	spin_lock_bh(&session->lock);
 	if (session->state != ISCSI_STATE_LOGGED_IN) {
-		session->recovery_failed = 1;
+		session->state = ISCSI_STATE_RECOVERY_FAILED;
 		if (conn)
 			wake_up(&conn->ehwait);
 	}
@@ -838,20 +870,14 @@
 	 * we drop the lock here but the leadconn cannot be destoyed while
 	 * we are in the scsi eh
 	 */
-	if (fail_session) {
+	if (fail_session)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		/*
-		 * if userspace cannot respond then we must kick this off
-		 * here for it
-		 */
-		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
-	}
 
 	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
 	wait_event_interruptible(conn->ehwait,
 				 session->state == ISCSI_STATE_TERMINATE ||
 				 session->state == ISCSI_STATE_LOGGED_IN ||
-				 session->recovery_failed);
+				 session->state == ISCSI_STATE_RECOVERY_FAILED);
 	if (signal_pending(current))
 		flush_signals(current);
 
@@ -940,8 +966,7 @@
 	wait_event_interruptible(conn->ehwait,
 				 sc->SCp.phase != session->age ||
 				 session->state != ISCSI_STATE_LOGGED_IN ||
-				 conn->tmabort_state != TMABORT_INITIAL ||
-				 session->recovery_failed);
+				 conn->tmabort_state != TMABORT_INITIAL);
 	if (signal_pending(current))
 		flush_signals(current);
 	del_timer_sync(&conn->tmabort_timer);
@@ -968,7 +993,7 @@
 									\
 		if (task->itt == itt) {					\
 			debug_scsi("matched task\n");			\
-			break;						\
+			return task;					\
 		}							\
 									\
 		__kfifo_put(fifo, (void*)&task, sizeof(void*));		\
@@ -1400,8 +1425,8 @@
 	struct iscsi_session *session = conn->session;
 	unsigned long flags;
 
-	mutex_lock(&conn->xmitmutex);
 	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
+	mutex_lock(&conn->xmitmutex);
 	if (conn->c_stage == ISCSI_CONN_INITIAL_STAGE) {
 		if (session->tt->suspend_conn_recv)
 			session->tt->suspend_conn_recv(conn);
@@ -1487,25 +1512,17 @@
 		 * unblock eh_abort() if it is blocked. re-try all
 		 * commands after successful recovery
 		 */
-		session->conn_cnt++;
 		conn->stop_stage = 0;
 		conn->tmabort_state = TMABORT_INITIAL;
 		session->age++;
-		session->recovery_failed = 0;
 		spin_unlock_bh(&session->lock);
 
 		iscsi_unblock_session(session_to_cls(session));
 		wake_up(&conn->ehwait);
 		return 0;
 	case STOP_CONN_TERM:
-		session->conn_cnt++;
 		conn->stop_stage = 0;
 		break;
-	case STOP_CONN_SUSPEND:
-		conn->stop_stage = 0;
-		clear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
-		clear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
-		break;
 	default:
 		break;
 	}
@@ -1566,8 +1583,8 @@
 	conn->ctask = NULL;
 }
 
-void iscsi_start_session_recovery(struct iscsi_session *session,
-				  struct iscsi_conn *conn, int flag)
+static void iscsi_start_session_recovery(struct iscsi_session *session,
+					 struct iscsi_conn *conn, int flag)
 {
 	int old_stop_stage;
 
@@ -1579,38 +1596,25 @@
 
 	/*
 	 * When this is called for the in_login state, we only want to clean
-	 * up the login task and connection.
+	 * up the login task and connection. We do not need to block and set
+	 * the recovery state again
 	 */
-	if (conn->stop_stage != STOP_CONN_RECOVER)
-		session->conn_cnt--;
+	if (flag == STOP_CONN_TERM)
+		session->state = ISCSI_STATE_TERMINATE;
+	else if (conn->stop_stage != STOP_CONN_RECOVER)
+		session->state = ISCSI_STATE_IN_RECOVERY;
 
 	old_stop_stage = conn->stop_stage;
 	conn->stop_stage = flag;
+	conn->c_stage = ISCSI_CONN_STOPPED;
+	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
 	spin_unlock_bh(&session->lock);
 
 	if (session->tt->suspend_conn_recv)
 		session->tt->suspend_conn_recv(conn);
 
 	mutex_lock(&conn->xmitmutex);
-	spin_lock_bh(&session->lock);
-	conn->c_stage = ISCSI_CONN_STOPPED;
-	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
-
-	if (session->conn_cnt == 0 || session->leadconn == conn)
-		session->state = ISCSI_STATE_FAILED;
-
-	spin_unlock_bh(&session->lock);
-
-	session->tt->terminate_conn(conn);
 	/*
-	 * flush queues.
-	 */
-	spin_lock_bh(&session->lock);
-	fail_all_commands(conn);
-	flush_control_queues(session, conn);
-	spin_unlock_bh(&session->lock);
-
-	/*
 	 * for connection level recovery we should not calculate
 	 * header digest. conn->hdr_size used for optimization
 	 * in hdr_extract() and will be re-negotiated at
@@ -1619,18 +1623,24 @@
 	if (flag == STOP_CONN_RECOVER) {
 		conn->hdrdgst_en = 0;
 		conn->datadgst_en = 0;
-
-		/*
-		 * if this is called from the eh and and from userspace
-		 * then we only need to block once.
-		 */
-		if (session->state == ISCSI_STATE_FAILED &&
-		    old_stop_stage != STOP_CONN_RECOVER)
+		if (session->state == ISCSI_STATE_IN_RECOVERY &&
+		    old_stop_stage != STOP_CONN_RECOVER) {
+			debug_scsi("blocking session\n");
 			iscsi_block_session(session_to_cls(session));
+		}
 	}
+
+	session->tt->terminate_conn(conn);
+	/*
+	 * flush queues.
+	 */
+	spin_lock_bh(&session->lock);
+	fail_all_commands(conn);
+	flush_control_queues(session, conn);
+	spin_unlock_bh(&session->lock);
+
 	mutex_unlock(&conn->xmitmutex);
 }
-EXPORT_SYMBOL_GPL(iscsi_start_session_recovery);
 
 void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 {
@@ -1642,20 +1652,6 @@
 	case STOP_CONN_TERM:
 		iscsi_start_session_recovery(session, conn, flag);
 		break;
-	case STOP_CONN_SUSPEND:
-		if (session->tt->suspend_conn_recv)
-			session->tt->suspend_conn_recv(conn);
-
-		mutex_lock(&conn->xmitmutex);
-		spin_lock_bh(&session->lock);
-
-		conn->stop_stage = flag;
-		conn->c_stage = ISCSI_CONN_STOPPED;
-		set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);
-
-		spin_unlock_bh(&session->lock);
-		mutex_unlock(&conn->xmitmutex);
-		break;
 	default:
 		printk(KERN_ERR "iscsi: invalid stop flag %d\n", flag);
 	}

Modified: branches/use-scsi-ml/istgt/kernel/libiscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-05-22 16:19:14 UTC (rev 483)
+++ branches/use-scsi-ml/istgt/kernel/libiscsi.h	2006-06-01 14:01:04 UTC (rev 484)
@@ -212,9 +212,7 @@
 						 * - mgmtpool,		   *
 						 * - r2tpool		   */
 	int			state;		/* session state           */
-	int			recovery_failed;
 	struct list_head	item;
-	int			conn_cnt;
 	int			age;		/* counts session re-opens */
 
 	struct list_head	connections;	/* list of connections */
@@ -243,8 +241,6 @@
 		    int, int, uint32_t, uint32_t *);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
-extern void iscsi_start_session_recovery(struct iscsi_session *,
-					struct iscsi_conn *, int);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 
 #define session_to_cls(_sess) \

Modified: branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-05-22 16:19:14 UTC (rev 483)
+++ branches/use-scsi-ml/istgt/kernel/scsi_transport_iscsi.h	2006-06-01 14:01:04 UTC (rev 484)
@@ -57,8 +57,12 @@
  *			Called from queuecommand with session lock held.
  * @init_mgmt_task:	Initialize a iscsi_mgmt_task and any internal structs.
  *			Called from iscsi_conn_send_generic with xmitmutex.
- * @xmit_cmd_task:	requests LLD to transfer cmd task
- * @xmit_mgmt_task:	requests LLD to transfer mgmt task
+ * @xmit_cmd_task:	Requests LLD to transfer cmd task. Returns 0 or the
+ *			the number of bytes transferred on success, and -Exyz
+ *			value on error.
+ * @xmit_mgmt_task:	Requests LLD to transfer mgmt task. Returns 0 or the
+ *			the number of bytes transferred on success, and -Exyz
+ *			value on error.
  * @cleanup_cmd_task:	requests LLD to fail cmd task. Called with xmitmutex
  *			and session->lock after the connection has been
  *			suspended and terminated during recovery. If called
@@ -173,6 +177,8 @@
 #define ISCSI_STATE_LOGGED_IN		2
 #define ISCSI_STATE_FAILED		3
 #define ISCSI_STATE_TERMINATE		4
+#define ISCSI_STATE_IN_RECOVERY		5
+#define ISCSI_STATE_RECOVERY_FAILED	6
 
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */



From tomo at berlios.de  Fri Jun  2 10:43:48 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 2 Jun 2006 10:43:48 +0200
Subject: [Stgt-svn] r485 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200606020843.k528hmVc007508@sheep.berlios.de>

Author: tomo
Date: 2006-06-02 10:43:46 +0200 (Fri, 02 Jun 2006)
New Revision: 485

Modified:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Log:
Fix copyright.

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-06-01 14:01:04 UTC (rev 484)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-06-02 08:43:46 UTC (rev 485)
@@ -2,7 +2,7 @@
  * iSCSI Target over TCP/IP
  *
  * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie
+ * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published



From tomo at berlios.de  Fri Jun  2 12:00:07 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 2 Jun 2006 12:00:07 +0200
Subject: [Stgt-svn] r486 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200606021000.k52A07UX001311@sheep.berlios.de>

Author: tomo
Date: 2006-06-02 12:00:06 +0200 (Fri, 02 Jun 2006)
New Revision: 486

Added:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_initiator.c
Modified:
   branches/use-scsi-ml/istgt/kernel/Makefile
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
Log:
Split iscsi_tcp.c.


Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-06-02 08:43:46 UTC (rev 485)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-06-02 10:00:06 UTC (rev 486)
@@ -13,6 +13,7 @@
 obj-m				+= scsi_transport_iscsi.o
 obj-m				+= libiscsi.o
 obj-m				+= iscsi_tcp.o
+obj-m				+= iscsi_tcp_initiator.o
 obj-m				+= iscsi_tcp_tgt.o
 else
 

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-06-02 08:43:46 UTC (rev 485)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-06-02 10:00:06 UTC (rev 486)
@@ -1,5 +1,5 @@
 /*
- * iSCSI Initiator over TCP/IP Data-Path
+ * iSCSI TCP/IP lib functions
  *
  * Copyright (C) 2004 Dmitry Yusupov
  * Copyright (C) 2004 Alex Aizman
@@ -47,7 +47,7 @@
 
 MODULE_AUTHOR("Dmitry Yusupov <dmitry_yus at yahoo.com>, "
 	      "Alex Aizman <itn780 at yahoo.com>");
-MODULE_DESCRIPTION("iSCSI/TCP data-path");
+MODULE_DESCRIPTION("iSCSI/TCP library functions");
 MODULE_LICENSE("GPL");
 MODULE_VERSION(ISCSI_TCP_VERSION);
 /* #define DEBUG_TCP */
@@ -66,9 +66,6 @@
 #define BUG_ON(expr)
 #endif
 
-static unsigned int iscsi_max_lun = 512;
-module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
-
 inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -80,7 +77,7 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_buf_init_iov);
 
-static inline void
+inline void
 iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
 {
 	ibuf->sg.page = sg->page;
@@ -95,6 +92,7 @@
 		ibuf->use_sendmsg = 1;
 	ibuf->sent = 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_buf_init_sg);
 
 static inline int
 iscsi_buf_left(struct iscsi_buf *ibuf)
@@ -106,15 +104,15 @@
 	return rc;
 }
 
-static inline void
-iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
-		 u8* crc)
+inline void iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			     u8* crc)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
 
 	crypto_digest_digest(tcp_conn->tx_tfm, &buf->sg, 1, crc);
 	buf->sg.length += sizeof(uint32_t);
 }
+EXPORT_SYMBOL_GPL(iscsi_hdr_digest);
 
 static inline int
 iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn)
@@ -182,233 +180,6 @@
 	return 0;
 }
 
-/*
- * must be called with session lock
- */
-static void
-__iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct scsi_cmnd *sc;
-
-	sc = ctask->sc;
-	if (unlikely(!sc))
-		return;
-
-	tcp_ctask->xmstate = XMSTATE_IDLE;
-	tcp_ctask->r2t = NULL;
-}
-
-/**
- * iscsi_data_rsp - SCSI Data-In Response processing
- * @conn: iscsi connection
- * @ctask: scsi command task
- **/
-static int
-iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	int rc;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn->in.hdr;
-	struct iscsi_session *session = conn->session;
-	int datasn = be32_to_cpu(rhdr->datasn);
-
-	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
-	if (rc)
-		return rc;
-	/*
-	 * setup Data-In byte counter (gets decremented..)
-	 */
-	ctask->data_count = tcp_conn->in.datalen;
-
-	if (tcp_conn->in.datalen == 0)
-		return 0;
-
-	if (ctask->datasn != datasn)
-		return ISCSI_ERR_DATASN;
-
-	ctask->datasn++;
-
-	tcp_ctask->data_offset = be32_to_cpu(rhdr->offset);
-	if (tcp_ctask->data_offset + tcp_conn->in.datalen > ctask->total_length)
-		return ISCSI_ERR_DATA_OFFSET;
-
-	if (rhdr->flags & ISCSI_FLAG_DATA_STATUS) {
-		struct scsi_cmnd *sc = ctask->sc;
-
-		conn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;
-		if (rhdr->flags & ISCSI_FLAG_DATA_UNDERFLOW) {
-			int res_count = be32_to_cpu(rhdr->residual_count);
-
-			if (res_count > 0 &&
-			    res_count <= sc->request_bufflen) {
-				sc->resid = res_count;
-				sc->result = (DID_OK << 16) | rhdr->cmd_status;
-			} else
-				sc->result = (DID_BAD_TARGET << 16) |
-					rhdr->cmd_status;
-		} else if (rhdr->flags & ISCSI_FLAG_DATA_OVERFLOW) {
-			sc->resid = be32_to_cpu(rhdr->residual_count);
-			sc->result = (DID_OK << 16) | rhdr->cmd_status;
-		} else
-			sc->result = (DID_OK << 16) | rhdr->cmd_status;
-	}
-
-	conn->datain_pdus_cnt++;
-	return 0;
-}
-
-/**
- * iscsi_solicit_data_init - initialize first Data-Out
- * @conn: iscsi connection
- * @ctask: scsi command task
- * @r2t: R2T info
- *
- * Notes:
- *	Initialize first Data-Out within this R2T sequence and finds
- *	proper data_offset within this SCSI command.
- *
- *	This function is called with connection lock taken.
- **/
-static void
-iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
-			struct iscsi_r2t_info *r2t)
-{
-	struct iscsi_data *hdr;
-	struct scsi_cmnd *sc = ctask->sc;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-	hdr = &r2t->dtask.hdr;
-	memset(hdr, 0, sizeof(struct iscsi_data));
-	hdr->ttt = r2t->ttt;
-	hdr->datasn = cpu_to_be32(r2t->solicit_datasn);
-	r2t->solicit_datasn++;
-	hdr->opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr->lun, ctask->hdr->lun, sizeof(hdr->lun));
-	hdr->itt = ctask->hdr->itt;
-	hdr->exp_statsn = r2t->exp_statsn;
-	hdr->offset = cpu_to_be32(r2t->data_offset);
-	if (r2t->data_length > conn->max_xmit_dlength) {
-		hton24(hdr->dlength, conn->max_xmit_dlength);
-		r2t->data_count = conn->max_xmit_dlength;
-		hdr->flags = 0;
-	} else {
-		hton24(hdr->dlength, r2t->data_length);
-		r2t->data_count = r2t->data_length;
-		hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	}
-	conn->dataout_pdus_cnt++;
-
-	r2t->sent = 0;
-
-	iscsi_buf_init_iov(&r2t->headbuf, (char*)hdr,
-			   sizeof(struct iscsi_hdr));
-
-	if (sc->use_sg) {
-		int i, sg_count = 0;
-		struct scatterlist *sg = sc->request_buffer;
-
-		r2t->sg = NULL;
-		for (i = 0; i < sc->use_sg; i++, sg += 1) {
-			/* FIXME: prefetch ? */
-			if (sg_count + sg->length > r2t->data_offset) {
-				int page_offset;
-
-				/* sg page found! */
-
-				/* offset within this page */
-				page_offset = r2t->data_offset - sg_count;
-
-				/* fill in this buffer */
-				iscsi_buf_init_sg(&r2t->sendbuf, sg);
-				r2t->sendbuf.sg.offset += page_offset;
-				r2t->sendbuf.sg.length -= page_offset;
-
-				/* xmit logic will continue with next one */
-				r2t->sg = sg + 1;
-				break;
-			}
-			sg_count += sg->length;
-		}
-		BUG_ON(r2t->sg == NULL);
-	} else
-		iscsi_buf_init_iov(&tcp_ctask->sendbuf,
-			    (char*)sc->request_buffer + r2t->data_offset,
-			    r2t->data_count);
-}
-
-/**
- * iscsi_r2t_rsp - iSCSI R2T Response processing
- * @conn: iscsi connection
- * @ctask: scsi command task
- **/
-static int
-iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_r2t_info *r2t;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn->in.hdr;
-	int r2tsn = be32_to_cpu(rhdr->r2tsn);
-	int rc;
-
-	if (tcp_conn->in.datalen)
-		return ISCSI_ERR_DATALEN;
-
-	if (tcp_ctask->exp_r2tsn && tcp_ctask->exp_r2tsn != r2tsn)
-		return ISCSI_ERR_R2TSN;
-
-	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
-	if (rc)
-		return rc;
-
-	/* FIXME: use R2TSN to detect missing R2T */
-
-	/* fill-in new R2T associated with the task */
-	spin_lock(&session->lock);
-	if (!ctask->sc || ctask->mtask ||
-	     session->state != ISCSI_STATE_LOGGED_IN) {
-		printk(KERN_INFO "iscsi_tcp: dropping R2T itt %d in "
-		       "recovery...\n", ctask->itt);
-		spin_unlock(&session->lock);
-		return 0;
-	}
-	rc = __kfifo_get(tcp_ctask->r2tpool.queue, (void*)&r2t, sizeof(void*));
-	BUG_ON(!rc);
-
-	r2t->exp_statsn = rhdr->statsn;
-	r2t->data_length = be32_to_cpu(rhdr->data_length);
-	if (r2t->data_length == 0 ||
-	    r2t->data_length > session->max_burst) {
-		spin_unlock(&session->lock);
-		return ISCSI_ERR_DATALEN;
-	}
-
-	r2t->data_offset = be32_to_cpu(rhdr->data_offset);
-	if (r2t->data_offset + r2t->data_length > ctask->total_length) {
-		spin_unlock(&session->lock);
-		return ISCSI_ERR_DATALEN;
-	}
-
-	r2t->ttt = rhdr->ttt; /* no flip */
-	r2t->solicit_datasn = 0;
-
-	iscsi_solicit_data_init(conn, ctask, r2t);
-
-	tcp_ctask->exp_r2tsn = r2tsn + 1;
-	tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
-	__kfifo_put(tcp_ctask->r2tqueue, (void*)&r2t, sizeof(void*));
-	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-
-	scsi_queue_work(session->host, &conn->xmitwork);
-	conn->r2t_pdus_cnt++;
-	spin_unlock(&session->lock);
-
-	return 0;
-}
-
 int iscsi_tcp_hdr_recv(struct iscsi_conn *conn)
 {
 	int ahslen;
@@ -463,94 +234,6 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_hdr_recv);
 
-static int iscsi_tcp_initiator_hdr_recv(struct iscsi_conn *conn)
-{
-	struct iscsi_session *session = conn->session;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_hdr *hdr = tcp_conn->in.hdr;
-	int rc, opcode, ahslen = hdr->hlength << 2;
-	uint32_t itt;
-
-	rc = iscsi_tcp_hdr_recv(conn);
-	if (rc)
-		return rc;
-
-	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
-	/* verify itt (itt encoding: age+cid+itt) */
-	rc = iscsi_verify_itt(conn, hdr, &itt);
-	if (rc == ISCSI_ERR_NO_SCSI_CMD) {
-		tcp_conn->in.datalen = 0; /* force drop */
-		return 0;
-	} else if (rc)
-		return rc;
-
-	debug_tcp("opcode 0x%x offset %d copy %d ahslen %d datalen %d\n",
-		  opcode, tcp_conn->in.offset, tcp_conn->in.copy,
-		  ahslen, tcp_conn->in.datalen);
-
-	switch(opcode) {
-	case ISCSI_OP_SCSI_DATA_IN:
-		tcp_conn->in.ctask = session->cmds[itt];
-		rc = iscsi_data_rsp(conn, tcp_conn->in.ctask);
-		/* fall through */
-	case ISCSI_OP_SCSI_CMD_RSP:
-		tcp_conn->in.ctask = session->cmds[itt];
-		if (tcp_conn->in.datalen)
-			goto copy_hdr;
-
-		spin_lock(&session->lock);
-		__iscsi_ctask_cleanup(conn, tcp_conn->in.ctask);
-		rc = __iscsi_complete_pdu(conn, hdr, NULL, 0);
-		spin_unlock(&session->lock);
-		break;
-	case ISCSI_OP_R2T:
-		tcp_conn->in.ctask = session->cmds[itt];
-		if (ahslen)
-			rc = ISCSI_ERR_AHSLEN;
-		else if (tcp_conn->in.ctask->sc->sc_data_direction ==
-								DMA_TO_DEVICE)
-			rc = iscsi_r2t_rsp(conn, tcp_conn->in.ctask);
-		else
-			rc = ISCSI_ERR_PROTO;
-		break;
-	case ISCSI_OP_LOGIN_RSP:
-	case ISCSI_OP_TEXT_RSP:
-	case ISCSI_OP_LOGOUT_RSP:
-	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_REJECT:
-	case ISCSI_OP_ASYNC_EVENT:
-		if (tcp_conn->in.datalen)
-			goto copy_hdr;
-	/* fall through */
-	case ISCSI_OP_SCSI_TMFUNC_RSP:
-		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
-		break;
-	default:
-		rc = ISCSI_ERR_BAD_OPCODE;
-		break;
-	}
-
-	return rc;
-
-copy_hdr:
-	/*
-	 * if we did zero copy for the header but we will need multiple
-	 * skbs to complete the command then we have to copy the header
-	 * for later use
-	 */
-	if (tcp_conn->in.zero_copy_hdr && tcp_conn->in.copy <
-	   (tcp_conn->in.datalen + tcp_conn->in.padding +
-	    (conn->datadgst_en ? 4 : 0))) {
-		debug_tcp("Copying header for later use. in.copy %d in.datalen"
-			  " %d\n", tcp_conn->in.copy, tcp_conn->in.datalen);
-		memcpy(&tcp_conn->hdr, tcp_conn->in.hdr,
-		       sizeof(struct iscsi_hdr));
-		tcp_conn->in.hdr = &tcp_conn->hdr;
-		tcp_conn->in.zero_copy_hdr = 0;
-	}
-	return 0;
-}
-
 /**
  * iscsi_ctask_copy - copy skb bits to the destanation cmd task
  * @conn: iscsi tcp connection
@@ -628,8 +311,7 @@
  *	The function calls skb_copy_bits() and updates per-connection
  *	byte counters.
  **/
-static inline int
-iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn)
+inline int iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn)
 {
 	void *buf = tcp_conn->data;
 	int buf_size = tcp_conn->in.datalen;
@@ -655,6 +337,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_tcp_copy);
 
 static inline void
 partial_sg_digest_update(struct iscsi_tcp_conn *tcp_conn,
@@ -668,14 +351,14 @@
 	crypto_digest_update(tcp_conn->data_rx_tfm, &temp, 1);
 }
 
-static void
-iscsi_recv_digest_update(struct iscsi_tcp_conn *tcp_conn, char* buf, int len)
+void iscsi_recv_digest_update(struct iscsi_tcp_conn *tcp_conn, char* buf, int len)
 {
 	struct scatterlist tmp;
 
 	sg_init_one(&tmp, buf, len);
 	crypto_digest_update(tcp_conn->data_rx_tfm, &tmp, 1);
 }
+EXPORT_SYMBOL_GPL(iscsi_recv_digest_update);
 
 int iscsi_scsi_data_in(struct iscsi_conn *conn)
 {
@@ -760,65 +443,6 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_scsi_data_in);
 
-static void iscsi_scsi_data_in_done(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
-
-	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
-		debug_scsi("done [sc %p res %d itt 0x%x]\n", ctask->sc,
-			   (struct scsi_cmnd *) (ctask->sc)->result, ctask->itt);
-		spin_lock(&conn->session->lock);
-		__iscsi_ctask_cleanup(conn, ctask);
-		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);
-		spin_unlock(&conn->session->lock);
-	}
-}
-
-static int
-iscsi_tcp_initiator_data_recv(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	int rc = 0, opcode;
-
-	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
-	switch (opcode) {
-	case ISCSI_OP_SCSI_DATA_IN:
-		rc = iscsi_scsi_data_in(conn);
-		if (!rc)
-			iscsi_scsi_data_in_done(conn);
-		break;
-	case ISCSI_OP_SCSI_CMD_RSP:
-		spin_lock(&conn->session->lock);
-		__iscsi_ctask_cleanup(conn, tcp_conn->in.ctask);
-		spin_unlock(&conn->session->lock);
-	case ISCSI_OP_TEXT_RSP:
-	case ISCSI_OP_LOGIN_RSP:
-	case ISCSI_OP_NOOP_IN:
-	case ISCSI_OP_ASYNC_EVENT:
-	case ISCSI_OP_REJECT:
-		/*
-		 * Collect data segment to the connection's data
-		 * placeholder
-		 */
-		if (iscsi_tcp_copy(tcp_conn)) {
-			rc = -EAGAIN;
-			goto exit;
-		}
-
-		rc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, tcp_conn->data,
-					tcp_conn->in.datalen);
-		if (!rc && conn->datadgst_en && opcode != ISCSI_OP_LOGIN_RSP)
-			iscsi_recv_digest_update(tcp_conn, tcp_conn->data,
-			  			tcp_conn->in.datalen);
-		break;
-	default:
-		BUG_ON(1);
-	}
-exit:
-	return rc;
-}
-
 /**
  * iscsi_tcp_data_recv - TCP receive in sendfile fashion
  * @rd_desc: read descriptor
@@ -1120,8 +744,8 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-static inline int
-iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
+inline int iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			 int datalen)
 {
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
@@ -1141,6 +765,7 @@
 
 	return res;
 }
+EXPORT_SYMBOL_GPL(iscsi_sendhdr);
 
 /**
  * iscsi_sendpage - send one page of iSCSI Data-Out.
@@ -1152,9 +777,8 @@
  * Notes:
  *	(Tx, Fast Path)
  **/
-static inline int
-iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
-	       int *count, int *sent)
+inline int iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			  int *count, int *sent)
 {
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
@@ -1179,6 +803,7 @@
 
 	return res;
 }
+EXPORT_SYMBOL_GPL(iscsi_sendpage);
 
 static inline void
 iscsi_data_digest_init(struct iscsi_tcp_conn *tcp_conn,
@@ -1269,156 +894,6 @@
 			    r2t->data_count);
 }
 
-static void
-iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_data_task *dtask;
-
-	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
-	iscsi_prep_unsolicit_data_pdu(ctask, &dtask->hdr,
-				      tcp_ctask->r2t_data_count);
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
-			   sizeof(struct iscsi_hdr));
-}
-
-/**
- * iscsi_tcp_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
- * @conn: iscsi connection
- * @ctask: scsi command task
- * @sc: scsi command
- **/
-static void
-iscsi_tcp_cmd_init(struct iscsi_cmd_task *ctask)
-{
-	struct scsi_cmnd *sc = ctask->sc;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-	BUG_ON(__kfifo_len(tcp_ctask->r2tqueue));
-
-	tcp_ctask->sent = 0;
-	tcp_ctask->sg_count = 0;
-
-	if (sc->sc_data_direction == DMA_TO_DEVICE) {
-		tcp_ctask->xmstate = XMSTATE_W_HDR;
-		tcp_ctask->exp_r2tsn = 0;
-		BUG_ON(ctask->total_length == 0);
-
-		if (sc->use_sg) {
-			struct scatterlist *sg = sc->request_buffer;
-
-			iscsi_buf_init_sg(&tcp_ctask->sendbuf,
-					  &sg[tcp_ctask->sg_count++]);
-			tcp_ctask->sg = sg;
-			tcp_ctask->bad_sg = sg + sc->use_sg;
-		} else
-			iscsi_buf_init_iov(&tcp_ctask->sendbuf,
-					   sc->request_buffer,
-					   sc->request_bufflen);
-
-		if (ctask->imm_count)
-			tcp_ctask->xmstate |= XMSTATE_IMM_DATA;
-
-		tcp_ctask->pad_count = ctask->total_length & (ISCSI_PAD_LEN-1);
-		if (tcp_ctask->pad_count) {
-			tcp_ctask->pad_count = ISCSI_PAD_LEN -
-							tcp_ctask->pad_count;
-			debug_scsi("write padding %d bytes\n",
-				   tcp_ctask->pad_count);
-			tcp_ctask->xmstate |= XMSTATE_W_PAD;
-		}
-
-		if (ctask->unsol_count)
-			tcp_ctask->xmstate |= XMSTATE_UNS_HDR |
-						XMSTATE_UNS_INIT;
-		tcp_ctask->r2t_data_count = ctask->total_length -
-				    ctask->imm_count -
-				    ctask->unsol_count;
-
-		debug_scsi("cmd [itt %x total %d imm %d imm_data %d "
-			   "r2t_data %d]\n",
-			   ctask->itt, ctask->total_length, ctask->imm_count,
-			   ctask->unsol_count, tcp_ctask->r2t_data_count);
-	} else
-		tcp_ctask->xmstate = XMSTATE_R_HDR;
-
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)ctask->hdr,
-			    sizeof(struct iscsi_hdr));
-}
-
-/**
- * iscsi_tcp_mtask_xmit - xmit management(immediate) task
- * @conn: iscsi connection
- * @mtask: task management task
- *
- * Notes:
- *	The function can return -EAGAIN in which case caller must
- *	call it again later, or recover. '0' return code means successful
- *	xmit.
- *
- *	Management xmit state machine consists of two states:
- *		IN_PROGRESS_IMM_HEAD - PDU Header xmit in progress
- *		IN_PROGRESS_IMM_DATA - PDU Data xmit in progress
- **/
-static int
-iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
-{
-	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
-	int rc;
-
-	debug_scsi("mtask deq [cid %d state %x itt 0x%x]\n",
-		conn->id, tcp_mtask->xmstate, mtask->itt);
-
-	if (tcp_mtask->xmstate & XMSTATE_IMM_HDR) {
-		tcp_mtask->xmstate &= ~XMSTATE_IMM_HDR;
-		if (mtask->data_count)
-			tcp_mtask->xmstate |= XMSTATE_IMM_DATA;
-		if (conn->c_stage != ISCSI_CONN_INITIAL_STAGE &&
-		    conn->stop_stage != STOP_CONN_RECOVER &&
-		    conn->hdrdgst_en)
-			iscsi_hdr_digest(conn, &tcp_mtask->headbuf,
-					(u8*)tcp_mtask->hdrext);
-		rc = iscsi_sendhdr(conn, &tcp_mtask->headbuf,
-				   mtask->data_count);
-		if (rc) {
-			tcp_mtask->xmstate |= XMSTATE_IMM_HDR;
-			if (mtask->data_count)
-				tcp_mtask->xmstate &= ~XMSTATE_IMM_DATA;
-			return rc;
-		}
-	}
-
-	if (tcp_mtask->xmstate & XMSTATE_IMM_DATA) {
-		BUG_ON(!mtask->data_count);
-		tcp_mtask->xmstate &= ~XMSTATE_IMM_DATA;
-		/* FIXME: implement.
-		 * Virtual buffer could be spreaded across multiple pages...
-		 */
-		do {
-			int rc;
-
-			rc = iscsi_sendpage(conn, &tcp_mtask->sendbuf,
-					&mtask->data_count, &tcp_mtask->sent);
-			if (rc) {
-				tcp_mtask->xmstate |= XMSTATE_IMM_DATA;
-				return rc;
-			}
-		} while (mtask->data_count);
-	}
-
-	BUG_ON(tcp_mtask->xmstate != XMSTATE_IDLE);
-	if (mtask->hdr->itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		struct iscsi_session *session = conn->session;
-
-		spin_lock_bh(&session->lock);
-		list_del(&conn->mtask->running);
-		__kfifo_put(session->mgmtpool.queue, (void*)&conn->mtask,
-			    sizeof(void*));
-		spin_unlock_bh(&session->lock);
-	}
-	return 0;
-}
-
 static inline int
 handle_xmstate_r_hdr(struct iscsi_conn *conn,
 		     struct iscsi_tcp_cmd_task *tcp_ctask)
@@ -1952,20 +1427,6 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_conn_create);
 
-static struct iscsi_tcp_operations iscsi_tcp_initiator_ops = {
-	.hdr_recv		=	iscsi_tcp_initiator_hdr_recv,
-	.data_recv		=	iscsi_tcp_initiator_data_recv,
-	.unsolicit_data_init	=	iscsi_unsolicit_data_init,
-};
-
-static struct iscsi_cls_conn *
-iscsi_tcp_initiator_conn_create(struct iscsi_cls_session *cls_session,
-				uint32_t conn_idx)
-{
-	return iscsi_tcp_conn_create(cls_session, conn_idx,
-				     &iscsi_tcp_initiator_ops);
-}
-
 void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
@@ -2048,35 +1509,6 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_conn_bind);
 
-static void
-iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_r2t_info *r2t;
-
-	/* flush ctask's r2t queues */
-	while (__kfifo_get(tcp_ctask->r2tqueue, (void*)&r2t, sizeof(void*)))
-		__kfifo_put(tcp_ctask->r2tpool.queue, (void*)&r2t,
-			    sizeof(void*));
-
-	__iscsi_ctask_cleanup(conn, ctask);
-}
-
-static void
-iscsi_tcp_suspend_conn_rx(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct sock *sk;
-
-	if (!tcp_conn->sock)
-		return;
-
-	sk = tcp_conn->sock->sk;
-	write_lock_bh(&sk->sk_callback_lock);
-	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
-	write_unlock_bh(&sk->sk_callback_lock);
-}
-
 void iscsi_tcp_terminate_conn(struct iscsi_conn *conn)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2094,22 +1526,6 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_terminate_conn);
 
-/* called with host lock */
-static void
-iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
-		    char *data, uint32_t data_size)
-{
-	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
-
-	iscsi_buf_init_iov(&tcp_mtask->headbuf, (char*)mtask->hdr,
-			   sizeof(struct iscsi_hdr));
-	tcp_mtask->xmstate = XMSTATE_IMM_HDR;
-
-	if (mtask->data_count)
-		iscsi_buf_init_iov(&tcp_mtask->sendbuf, (char*)mtask->data,
-				    mtask->data_count);
-}
-
 static int
 iscsi_r2tpool_alloc(struct iscsi_session *session)
 {
@@ -2316,9 +1732,8 @@
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_set_param);
 
-static int
-iscsi_session_get_param(struct iscsi_cls_session *cls_session,
-			enum iscsi_param param, uint32_t *value)
+int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+			    enum iscsi_param param, uint32_t *value)
 {
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost->hostdata);
@@ -2360,10 +1775,10 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_session_get_param);
 
-static int
-iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
-		     enum iscsi_param param, uint32_t *value)
+int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+			 enum iscsi_param param, uint32_t *value)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2401,10 +1816,10 @@
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(iscsi_conn_get_param);
 
-static int
-iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
-			 enum iscsi_param param, char *buf)
+int iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
+			     enum iscsi_param param, char *buf)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2440,9 +1855,10 @@
 
 	return len;
 }
+EXPORT_SYMBOL_GPL(iscsi_conn_get_str_param);
 
-static void
-iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
+void iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,
+			  struct iscsi_stats *stats)
 {
 	struct iscsi_conn *conn = cls_conn->dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
@@ -2464,6 +1880,7 @@
 	strcpy(stats->custom[2].desc, "eh_abort_cnt");
 	stats->custom[2].value = conn->eh_abort_cnt;
 }
+EXPORT_SYMBOL_GPL(iscsi_conn_get_stats);
 
 struct iscsi_cls_session *
 iscsi_tcp_session_create(struct iscsi_transport *iscsit,
@@ -2515,95 +1932,3 @@
 	iscsi_session_teardown(cls_session);
 }
 EXPORT_SYMBOL_GPL(iscsi_tcp_session_destroy);
-
-static struct scsi_host_template iscsi_sht = {
-	.name			= "iSCSI Initiator over TCP/IP, v"
-				  ISCSI_TCP_VERSION,
-	.queuecommand           = iscsi_queuecommand,
-	.change_queue_depth	= iscsi_change_queue_depth,
-	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
-	.sg_tablesize		= ISCSI_SG_TABLESIZE,
-	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
-	.eh_abort_handler       = iscsi_eh_abort,
-	.eh_host_reset_handler	= iscsi_eh_host_reset,
-	.use_clustering         = DISABLE_CLUSTERING,
-	.proc_name		= "iscsi_tcp",
-	.this_id		= -1,
-};
-
-static struct iscsi_transport iscsi_tcp_transport = {
-	.owner			= THIS_MODULE,
-	.name			= "tcp",
-	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
-				  | CAP_DATADGST,
-	.param_mask		= ISCSI_MAX_RECV_DLENGTH |
-				  ISCSI_MAX_XMIT_DLENGTH |
-				  ISCSI_HDRDGST_EN |
-				  ISCSI_DATADGST_EN |
-				  ISCSI_INITIAL_R2T_EN |
-				  ISCSI_MAX_R2T |
-				  ISCSI_IMM_DATA_EN |
-				  ISCSI_FIRST_BURST |
-				  ISCSI_MAX_BURST |
-				  ISCSI_PDU_INORDER_EN |
-				  ISCSI_DATASEQ_INORDER_EN |
-				  ISCSI_ERL |
-				  ISCSI_CONN_PORT |
-				  ISCSI_CONN_ADDRESS |
-				  ISCSI_EXP_STATSN,
-	.host_template		= &iscsi_sht,
-	.conndata_size		= sizeof(struct iscsi_conn),
-	.max_conn		= 1,
-	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
-	/* session management */
-	.create_session		= iscsi_tcp_session_create,
-	.destroy_session	= iscsi_tcp_session_destroy,
-	/* connection management */
-	.create_conn		= iscsi_tcp_initiator_conn_create,
-	.bind_conn		= iscsi_tcp_conn_bind,
-	.destroy_conn		= iscsi_tcp_conn_destroy,
-	.set_param		= iscsi_conn_set_param,
-	.get_conn_param		= iscsi_conn_get_param,
-	.get_conn_str_param	= iscsi_conn_get_str_param,
-	.get_session_param	= iscsi_session_get_param,
-	.start_conn		= iscsi_conn_start,
-	.stop_conn		= iscsi_conn_stop,
-	/* these are called as part of conn recovery */
-	.suspend_conn_recv	= iscsi_tcp_suspend_conn_rx,
-	.terminate_conn		= iscsi_tcp_terminate_conn,
-	/* IO */
-	.send_pdu		= iscsi_conn_send_pdu,
-	.get_stats		= iscsi_conn_get_stats,
-	.init_cmd_task		= iscsi_tcp_cmd_init,
-	.init_mgmt_task		= iscsi_tcp_mgmt_init,
-	.xmit_cmd_task		= iscsi_tcp_ctask_xmit,
-	.xmit_mgmt_task		= iscsi_tcp_mtask_xmit,
-	.cleanup_cmd_task	= iscsi_tcp_cleanup_ctask,
-	/* recovery */
-	.session_recovery_timedout = iscsi_session_recovery_timedout,
-};
-
-static int __init
-iscsi_tcp_init(void)
-{
-	if (iscsi_max_lun < 1) {
-		printk(KERN_ERR "iscsi_tcp: Invalid max_lun value of %u\n",
-		       iscsi_max_lun);
-		return -EINVAL;
-	}
-	iscsi_tcp_transport.max_lun = iscsi_max_lun;
-
-	if (!iscsi_register_transport(&iscsi_tcp_transport))
-		return -ENODEV;
-
-	return 0;
-}
-
-static void __exit
-iscsi_tcp_exit(void)
-{
-	iscsi_unregister_transport(&iscsi_tcp_transport);
-}
-
-/* module_init(iscsi_tcp_init); */
-/* module_exit(iscsi_tcp_exit); */

Modified: branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-06-02 08:43:46 UTC (rev 485)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp.h	2006-06-02 10:00:06 UTC (rev 486)
@@ -189,25 +189,41 @@
 			 struct scsi_transport_template *scsit,
 			 uint32_t initial_cmdsn, uint32_t *hostno);
 extern void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session);
+extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+				   enum iscsi_param param, uint32_t *value);
 
 extern struct iscsi_cls_conn *
 iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx,
 		      struct iscsi_tcp_operations *ops);
 extern void iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn);
-
 extern int iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 			       struct iscsi_cls_conn *cls_conn,
 			       uint64_t transport_eph, int is_leading);
 extern int iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, uint32_t value);
+extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+				enum iscsi_param param, uint32_t *value);
+extern int iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
+				    enum iscsi_param param, char *buf);
+extern void iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn,
+				 struct iscsi_stats *stats);
 extern void iscsi_tcp_terminate_conn(struct iscsi_conn *conn);
 
 extern int iscsi_tcp_ctask_xmit(struct iscsi_conn *conn,
 				struct iscsi_cmd_task *ctask);
 extern int iscsi_tcp_hdr_recv(struct iscsi_conn *conn);
+extern int iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			 int datalen);
+extern int iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			  int *count, int *sent);
 
 extern int iscsi_scsi_data_in(struct iscsi_conn *conn);
-extern void
-iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size);
+extern void iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size);
+extern void iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg);
+extern int iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn);
+extern void iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
+			     u8* crc);
+extern void iscsi_recv_digest_update(struct iscsi_tcp_conn *tcp_conn, char* buf,
+				     int len);
 
 #endif /* ISCSI_H */

Copied: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_initiator.c (from rev 484, branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c)
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp.c	2006-06-01 14:01:04 UTC (rev 484)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_initiator.c	2006-06-02 10:00:06 UTC (rev 486)
@@ -0,0 +1,745 @@
+/*
+ * iSCSI Initiator over TCP/IP Data-Path
+ *
+ * Copyright (C) 2004 Dmitry Yusupov
+ * Copyright (C) 2004 Alex Aizman
+ * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * maintained by open-iscsi at googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ *
+ * Credits:
+ *	Christoph Hellwig
+ *	FUJITA Tomonori
+ *	Arne Redlich
+ *	Zhenyu Wang
+ */
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/inet.h>
+#include <linux/blkdev.h>
+#include <linux/crypto.h>
+#include <linux/delay.h>
+#include <linux/kfifo.h>
+#include <linux/scatterlist.h>
+#include <linux/mutex.h>
+#include <net/tcp.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi.h>
+#include "scsi_transport_iscsi.h"
+
+#include "iscsi_tcp.h"
+
+#define ISCSI_TCP_VERSION "1.0-595"
+
+MODULE_AUTHOR("Dmitry Yusupov <dmitry_yus at yahoo.com>, "
+	      "Alex Aizman <itn780 at yahoo.com>");
+MODULE_DESCRIPTION("iSCSI/TCP data-path");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(ISCSI_TCP_VERSION);
+/* #define DEBUG_TCP */
+#define DEBUG_ASSERT
+
+#ifdef DEBUG_TCP
+#define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt)
+#else
+#define debug_tcp(fmt...)
+#endif
+
+#ifndef DEBUG_ASSERT
+#ifdef BUG_ON
+#undef BUG_ON
+#endif
+#define BUG_ON(expr)
+#endif
+
+static unsigned int iscsi_max_lun = 512;
+module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
+
+/*
+ * must be called with session lock
+ */
+static void
+__iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct scsi_cmnd *sc;
+
+	sc = ctask->sc;
+	if (unlikely(!sc))
+		return;
+
+	tcp_ctask->xmstate = XMSTATE_IDLE;
+	tcp_ctask->r2t = NULL;
+}
+
+/**
+ * iscsi_data_rsp - SCSI Data-In Response processing
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ **/
+static int
+iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	int rc;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn->in.hdr;
+	struct iscsi_session *session = conn->session;
+	int datasn = be32_to_cpu(rhdr->datasn);
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc)
+		return rc;
+	/*
+	 * setup Data-In byte counter (gets decremented..)
+	 */
+	ctask->data_count = tcp_conn->in.datalen;
+
+	if (tcp_conn->in.datalen == 0)
+		return 0;
+
+	if (ctask->datasn != datasn)
+		return ISCSI_ERR_DATASN;
+
+	ctask->datasn++;
+
+	tcp_ctask->data_offset = be32_to_cpu(rhdr->offset);
+	if (tcp_ctask->data_offset + tcp_conn->in.datalen > ctask->total_length)
+		return ISCSI_ERR_DATA_OFFSET;
+
+	if (rhdr->flags & ISCSI_FLAG_DATA_STATUS) {
+		struct scsi_cmnd *sc = ctask->sc;
+
+		conn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;
+		if (rhdr->flags & ISCSI_FLAG_DATA_UNDERFLOW) {
+			int res_count = be32_to_cpu(rhdr->residual_count);
+
+			if (res_count > 0 &&
+			    res_count <= sc->request_bufflen) {
+				sc->resid = res_count;
+				sc->result = (DID_OK << 16) | rhdr->cmd_status;
+			} else
+				sc->result = (DID_BAD_TARGET << 16) |
+					rhdr->cmd_status;
+		} else if (rhdr->flags & ISCSI_FLAG_DATA_OVERFLOW) {
+			sc->resid = be32_to_cpu(rhdr->residual_count);
+			sc->result = (DID_OK << 16) | rhdr->cmd_status;
+		} else
+			sc->result = (DID_OK << 16) | rhdr->cmd_status;
+	}
+
+	conn->datain_pdus_cnt++;
+	return 0;
+}
+
+/**
+ * iscsi_solicit_data_init - initialize first Data-Out
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ * @r2t: R2T info
+ *
+ * Notes:
+ *	Initialize first Data-Out within this R2T sequence and finds
+ *	proper data_offset within this SCSI command.
+ *
+ *	This function is called with connection lock taken.
+ **/
+static void
+iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			struct iscsi_r2t_info *r2t)
+{
+	struct iscsi_data *hdr;
+	struct scsi_cmnd *sc = ctask->sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+
+	hdr = &r2t->dtask.hdr;
+	memset(hdr, 0, sizeof(struct iscsi_data));
+	hdr->ttt = r2t->ttt;
+	hdr->datasn = cpu_to_be32(r2t->solicit_datasn);
+	r2t->solicit_datasn++;
+	hdr->opcode = ISCSI_OP_SCSI_DATA_OUT;
+	memcpy(hdr->lun, ctask->hdr->lun, sizeof(hdr->lun));
+	hdr->itt = ctask->hdr->itt;
+	hdr->exp_statsn = r2t->exp_statsn;
+	hdr->offset = cpu_to_be32(r2t->data_offset);
+	if (r2t->data_length > conn->max_xmit_dlength) {
+		hton24(hdr->dlength, conn->max_xmit_dlength);
+		r2t->data_count = conn->max_xmit_dlength;
+		hdr->flags = 0;
+	} else {
+		hton24(hdr->dlength, r2t->data_length);
+		r2t->data_count = r2t->data_length;
+		hdr->flags = ISCSI_FLAG_CMD_FINAL;
+	}
+	conn->dataout_pdus_cnt++;
+
+	r2t->sent = 0;
+
+	iscsi_buf_init_iov(&r2t->headbuf, (char*)hdr,
+			   sizeof(struct iscsi_hdr));
+
+	if (sc->use_sg) {
+		int i, sg_count = 0;
+		struct scatterlist *sg = sc->request_buffer;
+
+		r2t->sg = NULL;
+		for (i = 0; i < sc->use_sg; i++, sg += 1) {
+			/* FIXME: prefetch ? */
+			if (sg_count + sg->length > r2t->data_offset) {
+				int page_offset;
+
+				/* sg page found! */
+
+				/* offset within this page */
+				page_offset = r2t->data_offset - sg_count;
+
+				/* fill in this buffer */
+				iscsi_buf_init_sg(&r2t->sendbuf, sg);
+				r2t->sendbuf.sg.offset += page_offset;
+				r2t->sendbuf.sg.length -= page_offset;
+
+				/* xmit logic will continue with next one */
+				r2t->sg = sg + 1;
+				break;
+			}
+			sg_count += sg->length;
+		}
+		BUG_ON(r2t->sg == NULL);
+	} else
+		iscsi_buf_init_iov(&tcp_ctask->sendbuf,
+			    (char*)sc->request_buffer + r2t->data_offset,
+			    r2t->data_count);
+}
+
+/**
+ * iscsi_r2t_rsp - iSCSI R2T Response processing
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ **/
+static int
+iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_r2t_info *r2t;
+	struct iscsi_session *session = conn->session;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn->in.hdr;
+	int r2tsn = be32_to_cpu(rhdr->r2tsn);
+	int rc;
+
+	if (tcp_conn->in.datalen)
+		return ISCSI_ERR_DATALEN;
+
+	if (tcp_ctask->exp_r2tsn && tcp_ctask->exp_r2tsn != r2tsn)
+		return ISCSI_ERR_R2TSN;
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc)
+		return rc;
+
+	/* FIXME: use R2TSN to detect missing R2T */
+
+	/* fill-in new R2T associated with the task */
+	spin_lock(&session->lock);
+	if (!ctask->sc || ctask->mtask ||
+	     session->state != ISCSI_STATE_LOGGED_IN) {
+		printk(KERN_INFO "iscsi_tcp: dropping R2T itt %d in "
+		       "recovery...\n", ctask->itt);
+		spin_unlock(&session->lock);
+		return 0;
+	}
+	rc = __kfifo_get(tcp_ctask->r2tpool.queue, (void*)&r2t, sizeof(void*));
+	BUG_ON(!rc);
+
+	r2t->exp_statsn = rhdr->statsn;
+	r2t->data_length = be32_to_cpu(rhdr->data_length);
+	if (r2t->data_length == 0 ||
+	    r2t->data_length > session->max_burst) {
+		spin_unlock(&session->lock);
+		return ISCSI_ERR_DATALEN;
+	}
+
+	r2t->data_offset = be32_to_cpu(rhdr->data_offset);
+	if (r2t->data_offset + r2t->data_length > ctask->total_length) {
+		spin_unlock(&session->lock);
+		return ISCSI_ERR_DATALEN;
+	}
+
+	r2t->ttt = rhdr->ttt; /* no flip */
+	r2t->solicit_datasn = 0;
+
+	iscsi_solicit_data_init(conn, ctask, r2t);
+
+	tcp_ctask->exp_r2tsn = r2tsn + 1;
+	tcp_ctask->xmstate |= XMSTATE_SOL_HDR;
+	__kfifo_put(tcp_ctask->r2tqueue, (void*)&r2t, sizeof(void*));
+	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
+
+	scsi_queue_work(session->host, &conn->xmitwork);
+	conn->r2t_pdus_cnt++;
+	spin_unlock(&session->lock);
+
+	return 0;
+}
+
+static int iscsi_tcp_initiator_hdr_recv(struct iscsi_conn *conn)
+{
+	struct iscsi_session *session = conn->session;
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_hdr *hdr = tcp_conn->in.hdr;
+	int rc, opcode, ahslen = hdr->hlength << 2;
+	uint32_t itt;
+
+	rc = iscsi_tcp_hdr_recv(conn);
+	if (rc)
+		return rc;
+
+	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
+	/* verify itt (itt encoding: age+cid+itt) */
+	rc = iscsi_verify_itt(conn, hdr, &itt);
+	if (rc == ISCSI_ERR_NO_SCSI_CMD) {
+		tcp_conn->in.datalen = 0; /* force drop */
+		return 0;
+	} else if (rc)
+		return rc;
+
+	debug_tcp("opcode 0x%x offset %d copy %d ahslen %d datalen %d\n",
+		  opcode, tcp_conn->in.offset, tcp_conn->in.copy,
+		  ahslen, tcp_conn->in.datalen);
+
+	switch(opcode) {
+	case ISCSI_OP_SCSI_DATA_IN:
+		tcp_conn->in.ctask = session->cmds[itt];
+		rc = iscsi_data_rsp(conn, tcp_conn->in.ctask);
+		/* fall through */
+	case ISCSI_OP_SCSI_CMD_RSP:
+		tcp_conn->in.ctask = session->cmds[itt];
+		if (tcp_conn->in.datalen)
+			goto copy_hdr;
+
+		spin_lock(&session->lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn->in.ctask);
+		rc = __iscsi_complete_pdu(conn, hdr, NULL, 0);
+		spin_unlock(&session->lock);
+		break;
+	case ISCSI_OP_R2T:
+		tcp_conn->in.ctask = session->cmds[itt];
+		if (ahslen)
+			rc = ISCSI_ERR_AHSLEN;
+		else if (tcp_conn->in.ctask->sc->sc_data_direction ==
+								DMA_TO_DEVICE)
+			rc = iscsi_r2t_rsp(conn, tcp_conn->in.ctask);
+		else
+			rc = ISCSI_ERR_PROTO;
+		break;
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_LOGOUT_RSP:
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_REJECT:
+	case ISCSI_OP_ASYNC_EVENT:
+		if (tcp_conn->in.datalen)
+			goto copy_hdr;
+	/* fall through */
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
+		break;
+	default:
+		rc = ISCSI_ERR_BAD_OPCODE;
+		break;
+	}
+
+	return rc;
+
+copy_hdr:
+	/*
+	 * if we did zero copy for the header but we will need multiple
+	 * skbs to complete the command then we have to copy the header
+	 * for later use
+	 */
+	if (tcp_conn->in.zero_copy_hdr && tcp_conn->in.copy <
+	   (tcp_conn->in.datalen + tcp_conn->in.padding +
+	    (conn->datadgst_en ? 4 : 0))) {
+		debug_tcp("Copying header for later use. in.copy %d in.datalen"
+			  " %d\n", tcp_conn->in.copy, tcp_conn->in.datalen);
+		memcpy(&tcp_conn->hdr, tcp_conn->in.hdr,
+		       sizeof(struct iscsi_hdr));
+		tcp_conn->in.hdr = &tcp_conn->hdr;
+		tcp_conn->in.zero_copy_hdr = 0;
+	}
+	return 0;
+}
+
+static void iscsi_scsi_data_in_done(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
+
+	if (tcp_conn->in.hdr->flags & ISCSI_FLAG_DATA_STATUS) {
+		debug_scsi("done [sc %p res %d itt 0x%x]\n", ctask->sc,
+			   (struct scsi_cmnd *) (ctask->sc)->result, ctask->itt);
+		spin_lock(&conn->session->lock);
+		__iscsi_ctask_cleanup(conn, ctask);
+		__iscsi_complete_pdu(conn, tcp_conn->in.hdr, NULL, 0);
+		spin_unlock(&conn->session->lock);
+	}
+}
+
+static int
+iscsi_tcp_initiator_data_recv(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	int rc = 0, opcode;
+
+	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
+	switch (opcode) {
+	case ISCSI_OP_SCSI_DATA_IN:
+		rc = iscsi_scsi_data_in(conn);
+		if (!rc)
+			iscsi_scsi_data_in_done(conn);
+		break;
+	case ISCSI_OP_SCSI_CMD_RSP:
+		spin_lock(&conn->session->lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn->in.ctask);
+		spin_unlock(&conn->session->lock);
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
+		/*
+		 * Collect data segment to the connection's data
+		 * placeholder
+		 */
+		if (iscsi_tcp_copy(tcp_conn)) {
+			rc = -EAGAIN;
+			goto exit;
+		}
+
+		rc = iscsi_complete_pdu(conn, tcp_conn->in.hdr, tcp_conn->data,
+					tcp_conn->in.datalen);
+		if (!rc && conn->datadgst_en && opcode != ISCSI_OP_LOGIN_RSP)
+			iscsi_recv_digest_update(tcp_conn, tcp_conn->data,
+			  			tcp_conn->in.datalen);
+		break;
+	default:
+		BUG_ON(1);
+	}
+exit:
+	return rc;
+}
+
+static void
+iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_data_task *dtask;
+
+	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
+	iscsi_prep_unsolicit_data_pdu(ctask, &dtask->hdr,
+				      tcp_ctask->r2t_data_count);
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
+			   sizeof(struct iscsi_hdr));
+}
+
+/**
+ * iscsi_tcp_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
+ * @conn: iscsi connection
+ * @ctask: scsi command task
+ * @sc: scsi command
+ **/
+static void
+iscsi_tcp_cmd_init(struct iscsi_cmd_task *ctask)
+{
+	struct scsi_cmnd *sc = ctask->sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+
+	BUG_ON(__kfifo_len(tcp_ctask->r2tqueue));
+
+	tcp_ctask->sent = 0;
+	tcp_ctask->sg_count = 0;
+
+	if (sc->sc_data_direction == DMA_TO_DEVICE) {
+		tcp_ctask->xmstate = XMSTATE_W_HDR;
+		tcp_ctask->exp_r2tsn = 0;
+		BUG_ON(ctask->total_length == 0);
+
+		if (sc->use_sg) {
+			struct scatterlist *sg = sc->request_buffer;
+
+			iscsi_buf_init_sg(&tcp_ctask->sendbuf,
+					  &sg[tcp_ctask->sg_count++]);
+			tcp_ctask->sg = sg;
+			tcp_ctask->bad_sg = sg + sc->use_sg;
+		} else
+			iscsi_buf_init_iov(&tcp_ctask->sendbuf,
+					   sc->request_buffer,
+					   sc->request_bufflen);
+
+		if (ctask->imm_count)
+			tcp_ctask->xmstate |= XMSTATE_IMM_DATA;
+
+		tcp_ctask->pad_count = ctask->total_length & (ISCSI_PAD_LEN-1);
+		if (tcp_ctask->pad_count) {
+			tcp_ctask->pad_count = ISCSI_PAD_LEN -
+							tcp_ctask->pad_count;
+			debug_scsi("write padding %d bytes\n",
+				   tcp_ctask->pad_count);
+			tcp_ctask->xmstate |= XMSTATE_W_PAD;
+		}
+
+		if (ctask->unsol_count)
+			tcp_ctask->xmstate |= XMSTATE_UNS_HDR |
+						XMSTATE_UNS_INIT;
+		tcp_ctask->r2t_data_count = ctask->total_length -
+				    ctask->imm_count -
+				    ctask->unsol_count;
+
+		debug_scsi("cmd [itt %x total %d imm %d imm_data %d "
+			   "r2t_data %d]\n",
+			   ctask->itt, ctask->total_length, ctask->imm_count,
+			   ctask->unsol_count, tcp_ctask->r2t_data_count);
+	} else
+		tcp_ctask->xmstate = XMSTATE_R_HDR;
+
+	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)ctask->hdr,
+			    sizeof(struct iscsi_hdr));
+}
+
+static struct iscsi_tcp_operations iscsi_tcp_initiator_ops = {
+	.hdr_recv		=	iscsi_tcp_initiator_hdr_recv,
+	.data_recv		=	iscsi_tcp_initiator_data_recv,
+	.unsolicit_data_init	=	iscsi_unsolicit_data_init,
+};
+
+static struct iscsi_cls_conn *
+iscsi_tcp_initiator_conn_create(struct iscsi_cls_session *cls_session,
+				uint32_t conn_idx)
+{
+	return iscsi_tcp_conn_create(cls_session, conn_idx,
+				     &iscsi_tcp_initiator_ops);
+}
+
+static void
+iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
+	struct iscsi_r2t_info *r2t;
+
+	/* flush ctask's r2t queues */
+	while (__kfifo_get(tcp_ctask->r2tqueue, (void*)&r2t, sizeof(void*)))
+		__kfifo_put(tcp_ctask->r2tpool.queue, (void*)&r2t,
+			    sizeof(void*));
+
+	__iscsi_ctask_cleanup(conn, ctask);
+}
+
+static void
+iscsi_tcp_suspend_conn_rx(struct iscsi_conn *conn)
+{
+	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
+	struct sock *sk;
+
+	if (!tcp_conn->sock)
+		return;
+
+	sk = tcp_conn->sock->sk;
+	write_lock_bh(&sk->sk_callback_lock);
+	set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
+	write_unlock_bh(&sk->sk_callback_lock);
+}
+
+/* called with host lock */
+static void
+iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
+		    char *data, uint32_t data_size)
+{
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
+
+	iscsi_buf_init_iov(&tcp_mtask->headbuf, (char*)mtask->hdr,
+			   sizeof(struct iscsi_hdr));
+	tcp_mtask->xmstate = XMSTATE_IMM_HDR;
+
+	if (mtask->data_count)
+		iscsi_buf_init_iov(&tcp_mtask->sendbuf, (char*)mtask->data,
+				    mtask->data_count);
+}
+
+/**
+ * iscsi_tcp_mtask_xmit - xmit management(immediate) task
+ * @conn: iscsi connection
+ * @mtask: task management task
+ *
+ * Notes:
+ *	The function can return -EAGAIN in which case caller must
+ *	call it again later, or recover. '0' return code means successful
+ *	xmit.
+ *
+ *	Management xmit state machine consists of two states:
+ *		IN_PROGRESS_IMM_HEAD - PDU Header xmit in progress
+ *		IN_PROGRESS_IMM_DATA - PDU Data xmit in progress
+ **/
+static int
+iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
+{
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask->dd_data;
+	int rc;
+
+	debug_scsi("mtask deq [cid %d state %x itt 0x%x]\n",
+		conn->id, tcp_mtask->xmstate, mtask->itt);
+
+	if (tcp_mtask->xmstate & XMSTATE_IMM_HDR) {
+		tcp_mtask->xmstate &= ~XMSTATE_IMM_HDR;
+		if (mtask->data_count)
+			tcp_mtask->xmstate |= XMSTATE_IMM_DATA;
+		if (conn->c_stage != ISCSI_CONN_INITIAL_STAGE &&
+		    conn->stop_stage != STOP_CONN_RECOVER &&
+		    conn->hdrdgst_en)
+			iscsi_hdr_digest(conn, &tcp_mtask->headbuf,
+					(u8*)tcp_mtask->hdrext);
+		rc = iscsi_sendhdr(conn, &tcp_mtask->headbuf,
+				   mtask->data_count);
+		if (rc) {
+			tcp_mtask->xmstate |= XMSTATE_IMM_HDR;
+			if (mtask->data_count)
+				tcp_mtask->xmstate &= ~XMSTATE_IMM_DATA;
+			return rc;
+		}
+	}
+
+	if (tcp_mtask->xmstate & XMSTATE_IMM_DATA) {
+		BUG_ON(!mtask->data_count);
+		tcp_mtask->xmstate &= ~XMSTATE_IMM_DATA;
+		/* FIXME: implement.
+		 * Virtual buffer could be spreaded across multiple pages...
+		 */
+		do {
+			int rc;
+
+			rc = iscsi_sendpage(conn, &tcp_mtask->sendbuf,
+					&mtask->data_count, &tcp_mtask->sent);
+			if (rc) {
+				tcp_mtask->xmstate |= XMSTATE_IMM_DATA;
+				return rc;
+			}
+		} while (mtask->data_count);
+	}
+
+	BUG_ON(tcp_mtask->xmstate != XMSTATE_IDLE);
+	if (mtask->hdr->itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		struct iscsi_session *session = conn->session;
+
+		spin_lock_bh(&session->lock);
+		list_del(&conn->mtask->running);
+		__kfifo_put(session->mgmtpool.queue, (void*)&conn->mtask,
+			    sizeof(void*));
+		spin_unlock_bh(&session->lock);
+	}
+	return 0;
+}
+
+static struct scsi_host_template iscsi_sht = {
+	.name			= "iSCSI Initiator over TCP/IP, v"
+				  ISCSI_TCP_VERSION,
+	.queuecommand           = iscsi_queuecommand,
+	.change_queue_depth	= iscsi_change_queue_depth,
+	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
+	.sg_tablesize		= ISCSI_SG_TABLESIZE,
+	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
+	.eh_abort_handler       = iscsi_eh_abort,
+	.eh_host_reset_handler	= iscsi_eh_host_reset,
+	.use_clustering         = DISABLE_CLUSTERING,
+	.proc_name		= "iscsi_tcp",
+	.this_id		= -1,
+};
+
+static struct iscsi_transport iscsi_tcp_transport = {
+	.owner			= THIS_MODULE,
+	.name			= "tcp",
+	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
+				  | CAP_DATADGST,
+	.param_mask		= ISCSI_MAX_RECV_DLENGTH |
+				  ISCSI_MAX_XMIT_DLENGTH |
+				  ISCSI_HDRDGST_EN |
+				  ISCSI_DATADGST_EN |
+				  ISCSI_INITIAL_R2T_EN |
+				  ISCSI_MAX_R2T |
+				  ISCSI_IMM_DATA_EN |
+				  ISCSI_FIRST_BURST |
+				  ISCSI_MAX_BURST |
+				  ISCSI_PDU_INORDER_EN |
+				  ISCSI_DATASEQ_INORDER_EN |
+				  ISCSI_ERL |
+				  ISCSI_CONN_PORT |
+				  ISCSI_CONN_ADDRESS |
+				  ISCSI_EXP_STATSN,
+	.host_template		= &iscsi_sht,
+	.conndata_size		= sizeof(struct iscsi_conn),
+	.max_conn		= 1,
+	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
+	/* session management */
+	.create_session		= iscsi_tcp_session_create,
+	.destroy_session	= iscsi_tcp_session_destroy,
+	/* connection management */
+	.create_conn		= iscsi_tcp_initiator_conn_create,
+	.bind_conn		= iscsi_tcp_conn_bind,
+	.destroy_conn		= iscsi_tcp_conn_destroy,
+	.set_param		= iscsi_conn_set_param,
+	.get_conn_param		= iscsi_conn_get_param,
+	.get_conn_str_param	= iscsi_conn_get_str_param,
+	.get_session_param	= iscsi_session_get_param,
+	.start_conn		= iscsi_conn_start,
+	.stop_conn		= iscsi_conn_stop,
+	/* these are called as part of conn recovery */
+	.suspend_conn_recv	= iscsi_tcp_suspend_conn_rx,
+	.terminate_conn		= iscsi_tcp_terminate_conn,
+	/* IO */
+	.send_pdu		= iscsi_conn_send_pdu,
+	.get_stats		= iscsi_conn_get_stats,
+	.init_cmd_task		= iscsi_tcp_cmd_init,
+	.init_mgmt_task		= iscsi_tcp_mgmt_init,
+	.xmit_cmd_task		= iscsi_tcp_ctask_xmit,
+	.xmit_mgmt_task		= iscsi_tcp_mtask_xmit,
+	.cleanup_cmd_task	= iscsi_tcp_cleanup_ctask,
+	/* recovery */
+	.session_recovery_timedout = iscsi_session_recovery_timedout,
+};
+
+static int __init
+iscsi_tcp_init(void)
+{
+	if (iscsi_max_lun < 1) {
+		printk(KERN_ERR "iscsi_tcp: Invalid max_lun value of %u\n",
+		       iscsi_max_lun);
+		return -EINVAL;
+	}
+	iscsi_tcp_transport.max_lun = iscsi_max_lun;
+
+	if (!iscsi_register_transport(&iscsi_tcp_transport))
+		return -ENODEV;
+
+	return 0;
+}
+
+static void __exit
+iscsi_tcp_exit(void)
+{
+	iscsi_unregister_transport(&iscsi_tcp_transport);
+}
+
+module_init(iscsi_tcp_init);
+module_exit(iscsi_tcp_exit);



From tomo at berlios.de  Fri Jun  2 12:31:14 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 2 Jun 2006 12:31:14 +0200
Subject: [Stgt-svn] r487 - branches/use-scsi-ml/istgt/kernel
Message-ID: <200606021031.k52AVEjE009309@sheep.berlios.de>

Author: tomo
Date: 2006-06-02 12:31:02 +0200 (Fri, 02 Jun 2006)
New Revision: 487

Added:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_target.c
Removed:
   branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
Modified:
   branches/use-scsi-ml/istgt/kernel/Makefile
Log:
Rename iscsi_tcp_tgt iscsi_tcp_target.

Modified: branches/use-scsi-ml/istgt/kernel/Makefile
===================================================================
--- branches/use-scsi-ml/istgt/kernel/Makefile	2006-06-02 10:00:06 UTC (rev 486)
+++ branches/use-scsi-ml/istgt/kernel/Makefile	2006-06-02 10:31:02 UTC (rev 487)
@@ -14,7 +14,7 @@
 obj-m				+= libiscsi.o
 obj-m				+= iscsi_tcp.o
 obj-m				+= iscsi_tcp_initiator.o
-obj-m				+= iscsi_tcp_tgt.o
+obj-m				+= iscsi_tcp_target.o
 else
 
 ifeq ($(KERNELSRC),)

Copied: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_target.c (from rev 485, branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c)

Deleted: branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c
===================================================================
--- branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-06-02 10:00:06 UTC (rev 486)
+++ branches/use-scsi-ml/istgt/kernel/iscsi_tcp_tgt.c	2006-06-02 10:31:02 UTC (rev 487)
@@ -1,770 +0,0 @@
-/*
- * iSCSI Target over TCP/IP
- *
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie <michaelc at cs.wisc.edu>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include <linux/list.h>
-#include <linux/inet.h>
-#include <linux/kfifo.h>
-#include <net/tcp.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi.h>
-#include <scsi/scsi_tgt.h>
-#include <scsi/scsi_tcq.h>
-#include "iscsi_tcp.h"
-#include "libiscsi.h"
-#include "scsi_transport_iscsi.h"
-#include "iscsi_tcp.h"
-
-/* tmp - will replace with SCSI logging stuff */
-#define eprintk(fmt, args...)					\
-do {								\
-	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#define dprintk eprintk
-
-struct istgt_session {
-	struct list_head cmd_pending;
-	struct list_head cmd_hash;
-};
-
-static struct workqueue_struct *recvwq;
-
-static void hashlist_add(struct iscsi_cls_session *cls_session,
-			 struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_session *session = class_to_transport_session(cls_session);
-	struct istgt_session *istgt_session = cls_session->dd_data;
-
-	spin_lock_bh(&session->lock);
-	list_add(&ctask->hash, &istgt_session->cmd_hash);
-	spin_unlock_bh(&session->lock);
-}
-
-static struct iscsi_cmd_task *hashlist_find(struct iscsi_cls_session *cls_session, u32 itt)
-{
-	struct iscsi_cmd_task *ctask = NULL;
-	struct iscsi_session *session = class_to_transport_session(cls_session);
-	struct istgt_session *istgt_session = cls_session->dd_data;
-
-	spin_lock_bh(&session->lock);
-	list_for_each_entry(ctask, &istgt_session->cmd_hash, hash) {
-		if (ctask->hdr->itt == itt)
-			goto found;
-	}
-	ctask = NULL;
-found:
-	spin_unlock_bh(&session->lock);
-	return ctask;
-}
-
-static void iscsi_tcp_tgt_ctask_xmitqueue(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_conn *conn = ctask->conn;
-	struct iscsi_cls_session *cls_session = session_to_cls(conn->session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-
-	spin_lock_bh(&conn->session->lock);
-	__kfifo_put(conn->xmitqueue, (void*)&ctask, sizeof(void*));
-	spin_unlock_bh(&conn->session->lock);
-	scsi_queue_work(shost, &conn->xmitwork);
-}
-
-static void iscsi_tcp_tgt_ctask_cleanup(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_conn *conn = ctask->conn;
-
-	dprintk("%p %p\n", ctask, conn->session);
-	spin_lock_bh(&conn->session->lock);
-	list_del(&ctask->hash);
-	list_del_init(&ctask->running);
-	__kfifo_put(conn->session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-	spin_unlock_bh(&conn->session->lock);
-}
-
-static void iscsi_tcp_tgt_sc_queue(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_cmd *hdr = ctask->hdr;
-	struct scsi_cmnd *scmd;
-	enum dma_data_direction dir = (hdr->flags & ISCSI_FLAG_CMD_WRITE) ?
-		DMA_TO_DEVICE : DMA_FROM_DEVICE;
-
-	scmd = scsi_host_get_command(shost, dir, GFP_ATOMIC);
-	BUG_ON(!scmd);
-	ctask->sc = scmd;
-	memcpy(scmd->data_cmnd, hdr->cdb, MAX_COMMAND_SIZE);
-	scmd->request_bufflen = be32_to_cpu(hdr->data_length);
-	scmd->SCp.ptr = (void *) ctask;
-	scmd->done = NULL;
-
-	switch (hdr->flags & ISCSI_FLAG_CMD_ATTR_MASK) {
-	case ISCSI_ATTR_UNTAGGED:
-	case ISCSI_ATTR_SIMPLE:
-		scmd->tag = MSG_SIMPLE_TAG;
-		break;
-	case ISCSI_ATTR_HEAD_OF_QUEUE:
-		scmd->tag = MSG_HEAD_TAG;
-		break;
-	case ISCSI_ATTR_ORDERED:
-	default:
-		scmd->tag = MSG_ORDERED_TAG;
-	}
-	scsi_tgt_queue_command(scmd, (struct scsi_lun *) hdr->lun, hdr->itt);
-}
-
-/* TODO: we cannot handle multiple outstanding r2t. */
-static void iscsi_r2t_build(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_session *session = ctask->conn->session;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_r2t_rsp *hdr =
-		(struct iscsi_r2t_rsp *) &tcp_ctask->unsol_dtask.hdr;
-	int length;
-
-	tcp_ctask->xmstate = XMSTATE_R_HDR;
-	memset(hdr, 0, sizeof(struct iscsi_hdr));
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char *)hdr,
-			   sizeof(struct iscsi_hdr));
-
-	hdr->opcode = ISCSI_OP_R2T;
-	hdr->flags = ISCSI_FLAG_CMD_FINAL;
-	memcpy(hdr->lun, ctask->hdr->lun, sizeof(hdr->lun));
-	hdr->itt = ctask->itt;
-	hdr->r2tsn = cpu_to_be32(tcp_ctask->exp_r2tsn++);
-	hdr->data_offset = cpu_to_be32(tcp_ctask->data_offset);
-	hdr->ttt = (unsigned long) ctask; /* FIXME */
-	length = min(tcp_ctask->r2t_data_count, session->max_burst);
-	hdr->data_length = cpu_to_be32(length);
-	tcp_ctask->r2t_data_count -= length;
-
-	dprintk("%p %u %u %u %u\n", ctask, length, tcp_ctask->r2t_data_count,
-		tcp_ctask->data_offset,	session->max_burst);
-}
-
-static void __iscsi_tgt_cmd_exec(struct iscsi_cmd_task *ctask)
-{
-	u8 opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
-
-	dprintk("%p,%x,%u\n", ctask, opcode, ctask->hdr->cmdsn);
-	switch (opcode) {
-	case ISCSI_OP_SCSI_CMD:
-		if (ctask->sc)
-			ctask->sc->done(ctask->sc);
-		else
-			iscsi_tcp_tgt_sc_queue(ctask);
-		break;
-	case ISCSI_OP_LOGOUT:
-		/* TODO: move to user-space */
-		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
-		break;
-	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_SCSI_TMFUNC:
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-		BUG_ON(1);
-		break;
-	default:
-		eprintk("unexpected cmnd op %x\n", ctask->hdr->opcode);
-		break;
-	}
-}
-
-static void iscsi_tgt_cmd_exec(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_cmd_task *pos;
-	struct iscsi_conn *conn = ctask->conn;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
-	struct istgt_session *istgt_session = cls_session->dd_data;
-
-	if (ctask->hdr->opcode & ISCSI_OP_IMMEDIATE) {
-		__iscsi_tgt_cmd_exec(ctask);
-		return;
-	}
-
-	spin_lock_bh(&session->lock);
-
-	list_for_each_entry(pos, &istgt_session->cmd_pending, pending)
-		if (before(ctask->hdr->cmdsn, pos->hdr->cmdsn))
-			break;
-	list_add_tail(&ctask->pending, &pos->pending);
-
-retry:
-	while (!list_empty(&istgt_session->cmd_pending)) {
-		ctask = list_entry(istgt_session->cmd_pending.next,
-				   struct iscsi_cmd_task, pending);
-
-		dprintk("%p %x %x\n", ctask, ctask->hdr->cmdsn, session->exp_cmdsn);
-		if (be32_to_cpu(ctask->hdr->cmdsn) != session->exp_cmdsn)
-			break;
-
-		list_del_init(&ctask->pending);
-
-		spin_unlock_bh(&session->lock);
-		session->exp_cmdsn++;
-		__iscsi_tgt_cmd_exec(ctask);
-		spin_lock_bh(&session->lock);
-		goto retry;
-	}
-	spin_unlock_bh(&session->lock);
-}
-
-static struct iscsi_cmd_task *iscsi_tcp_tgt_cmd_init(struct iscsi_conn *conn)
-{
-	struct iscsi_cmd_task *ctask;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_tcp_cmd_task *tcp_ctask;
-	struct iscsi_hdr *hdr = tcp_conn->in.hdr;
-
-	__kfifo_get(session->cmdpool.queue, (void*)&ctask, sizeof(void*));
-	BUG_ON(!ctask);
-
-	ctask->conn = conn;
-	ctask->data_count = 0;
-	ctask->sc = NULL;
-	ctask->datasn = 0;
-	ctask->itt = hdr->itt;
-	INIT_LIST_HEAD(&ctask->running);
-	INIT_LIST_HEAD(&ctask->hash);
-	INIT_LIST_HEAD(&ctask->pending);
-	memcpy(ctask->hdr, hdr, sizeof(*hdr));
-	ctask->total_length = be32_to_cpu(ctask->hdr->data_length);
-
-	tcp_ctask = ctask->dd_data;
-	tcp_ctask->sg = NULL;
-	tcp_ctask->sent = 0;
-	tcp_ctask->data_offset = 0;
-
-	if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
-		tcp_ctask->exp_r2tsn = 0;
-		tcp_ctask->r2t_data_count = be32_to_cpu(ctask->hdr->data_length)
-			- tcp_conn->in.datalen;
-		if (hdr->flags & ISCSI_FLAG_CMD_FINAL)
-			ctask->unsol_count = 0;
-		else
-			ctask->unsol_count = 1;
-
-		ctask->data_count = ctask->imm_count = tcp_conn->in.datalen;
-		dprintk("%p %x %u %u %u %u\n", ctask, hdr->flags,
-			tcp_ctask->r2t_data_count,
-			ctask->unsol_count,
-			ctask->total_length,
-			ctask->imm_count);
-
-		hashlist_add(session_to_cls(session), ctask);
-
-		/* we stop reading here. */
-		set_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);
-		iscsi_tcp_tgt_sc_queue(ctask);
-	} else
-		iscsi_tgt_cmd_exec(ctask);
-
-	return ctask;
-}
-
-static int iscsi_tcp_tgt_hdr_recv(struct iscsi_conn *conn)
-{
-	int rc, opcode;
-	struct iscsi_hdr *hdr;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_cmd_task *ctask = NULL;
-	struct iscsi_session *session = conn->session;
-	struct iscsi_cls_session *cls_session = session_to_cls(session);
-
-	rc = iscsi_tcp_hdr_recv(conn);
-	if (rc)
-		return rc;
-
-	hdr = tcp_conn->in.hdr;
-	opcode = hdr->opcode & ISCSI_OPCODE_MASK;
-	dprintk("opcode 0x%x offset %d copy %d ahslen %d datalen %d\n",
-		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
-		hdr->hlength << 2, tcp_conn->in.datalen);
-
-	switch (opcode) {
-	case ISCSI_OP_LOGOUT:
-	case ISCSI_OP_SCSI_CMD:
-		ctask = iscsi_tcp_tgt_cmd_init(conn);
-		dprintk("%p\n", ctask);
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		ctask = hashlist_find(cls_session, hdr->itt);
-		if (!ctask) {
-			eprintk("Cannot find %x\n", ctask->hdr->itt);
-			rc = ISCSI_ERR_NO_SCSI_CMD;
-			break;
-		}
-		ctask->data_count = tcp_conn->in.datalen;
-		{
-			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-			struct iscsi_data *hdr = (struct iscsi_data *) hdr;
-			dprintk("%p %u %u %u %u %u %x\n", ctask,
-				ctask->total_length,
-				be32_to_cpu(hdr->offset),
-				tcp_ctask->data_offset,
-				tcp_ctask->r2t_data_count, ctask->data_count,
-				tcp_conn->in.hdr->flags);
-		}
-		break;
-	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_SCSI_TMFUNC:
-		eprintk("Cannot handle yet %x\n", opcode);
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_SNACK:
-	default:
-		rc = ISCSI_ERR_BAD_OPCODE;
-	}
-	tcp_conn->in.ctask = ctask;
-
-	return rc;
-}
-
-static void iscsi_cmd_data_done(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-	if (tcp_ctask->r2t_data_count) {
-		iscsi_r2t_build(ctask);
-		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
-	} else
-		iscsi_tgt_cmd_exec(ctask);
-}
-
-static void iscsi_handle_data_out_cmd(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-	BUG_ON(ctask->data_count);
-	tcp_ctask->data_offset += ntoh24(tcp_conn->in.hdr->dlength);
-
-	dprintk("%p %x %u %u %u %u %u\n", ctask, tcp_conn->in.hdr->flags,
-		tcp_ctask->r2t_data_count, ctask->unsol_count,
-		ctask->total_length, ctask->imm_count, tcp_ctask->data_offset);
-
-	if (tcp_conn->in.hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		tcp_ctask->r2t_data_count -= ntoh24(tcp_conn->in.hdr->dlength);
-		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-			ctask->unsol_count = 0;
-			iscsi_cmd_data_done(ctask);
-		}
-	} else {
-		if (tcp_conn->in.hdr->flags & ISCSI_FLAG_CMD_FINAL)
-			iscsi_cmd_data_done(ctask);
-	}
-}
-
-static int iscsi_tcp_tgt_data_recv(struct iscsi_conn *conn)
-{
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct iscsi_cmd_task *ctask = tcp_conn->in.ctask;
-	int rc = 0, opcode;
-
-	opcode = tcp_conn->in.hdr->opcode & ISCSI_OPCODE_MASK;
-	dprintk("opcode 0x%x offset %d copy %d datalen %d\n",
-		opcode, tcp_conn->in.offset, tcp_conn->in.copy,
-		tcp_conn->in.datalen);
-
-	switch (opcode) {
-	case ISCSI_OP_SCSI_CMD:
-		rc = iscsi_scsi_data_in(conn);
-		if (!rc) {
-			struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-			dprintk("%p %x %u %u %u %u %u\n", ctask,
-				tcp_conn->in.hdr->flags,
-				tcp_ctask->r2t_data_count,
-				ctask->unsol_count,
-				ctask->total_length,
-				ctask->imm_count, tcp_ctask->data_offset);
-
-			tcp_ctask->data_offset += ctask->imm_count;
-			ctask->imm_count = 0;
-			if (!ctask->unsol_count)
-				iscsi_cmd_data_done(ctask);
-		}
-		break;
-	case ISCSI_OP_SCSI_DATA_OUT:
-		rc = iscsi_scsi_data_in(conn);
-		if (!rc)
-			iscsi_handle_data_out_cmd(conn);
-		break;
-	case ISCSI_OP_TEXT:
-	case ISCSI_OP_LOGOUT:
-	case ISCSI_OP_NOOP_OUT:
-	case ISCSI_OP_ASYNC_EVENT:
-	default:
-		BUG_ON(1);
-	}
-
-	return rc;
-}
-
-static void __iscsi_data_rsp_build(struct iscsi_cmd_task *ctask,
-				   struct iscsi_data_rsp *hdr)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct scsi_cmnd *sc = ctask->sc;
-	struct iscsi_session *session = ctask->conn->session;
-	u32 left, residual, exp_datalen, size;
-
-	exp_datalen = be32_to_cpu(ctask->hdr->data_length);
-	left = min_t(int, ctask->unsol_count, exp_datalen);
-
-	hdr->opcode = ISCSI_OP_SCSI_DATA_IN;
-	hdr->itt = ctask->itt;
-	hdr->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	hdr->offset = cpu_to_be32(sc->offset + tcp_ctask->data_offset);
-	hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
-	hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
-	hdr->max_cmdsn = cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
-	hdr->datasn = cpu_to_be32(ctask->datasn++);
-
-	if (left <= ctask->conn->max_xmit_dlength) {
-		hdr->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-
-		if (sc->bufflen < exp_datalen) {
-			hdr->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - sc->bufflen;
-		} else if (sc->bufflen > exp_datalen) {
-			hdr->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = sc->bufflen - exp_datalen;
-		} else
-			residual = 0;
-		hdr->residual_count = cpu_to_be32(residual);
-		size = left;
-	} else
-		size = ctask->conn->max_xmit_dlength;
-
-	dprintk("%d %d %d %d %d\n", size, left, ctask->conn->max_xmit_dlength,
-		exp_datalen, sc->bufflen);
-
-	hton24(hdr->dlength, size);
-	ctask->data_count = ctask->unsol_count = size;
-	tcp_ctask->data_offset += size;
-}
-
-static void __iscsi_rsp_build(struct iscsi_cmd_task *ctask,
-			      struct iscsi_hdr *p)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_session *session = ctask->conn->session;
-	u8 opcode = ctask->hdr->opcode & ISCSI_OPCODE_MASK;
-
-	dprintk("%p %x\n", ctask, opcode);
-	ctask->data_count = 0;
-	tcp_ctask->xmstate = XMSTATE_R_HDR;
-
-	switch (opcode) {
-	case ISCSI_OP_SCSI_CMD:
-	{
-		struct iscsi_cmd_rsp *hdr = (struct iscsi_cmd_rsp *) p;
-
-		hdr->opcode = ISCSI_OP_SCSI_CMD_RSP;
-		hdr->itt = ctask->itt;
-		hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		hdr->response = ISCSI_STATUS_CMD_COMPLETED;
-		hdr->cmd_status = SAM_STAT_GOOD;
-		hdr->statsn = cpu_to_be32(ctask->conn->exp_statsn++);
-		hdr->exp_cmdsn = cpu_to_be32(session->exp_cmdsn);
-		hdr->max_cmdsn =
-			cpu_to_be32(session->exp_cmdsn + session->cmds_max / 2);
-		break;
-	}
-	case ISCSI_OP_LOGOUT:
-	{
-		struct iscsi_logout_rsp *hdr = (struct iscsi_logout_rsp *) p;
-		hdr->opcode = ISCSI_OP_LOGOUT_RSP;
-		hdr->flags = ISCSI_FLAG_CMD_FINAL;
-		hdr->itt = ctask->itt;
-		break;
-	}
-	default:
-		BUG_ON(1);
-		break;
-	}
-	dprintk("%p %x\n", ctask, opcode);
-}
-
-static void iscsi_data_rsp_build(struct iscsi_conn *conn,
-				 struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_data_task *dtask;
-
-	dprintk("%p\n", ctask);
-	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
-	memset(&dtask->hdr, 0, sizeof(struct iscsi_hdr));
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
-			   sizeof(struct iscsi_hdr));
-	__iscsi_data_rsp_build(ctask, (struct iscsi_data_rsp *) &dtask->hdr);
-}
-
-static void iscsi_rsp_build(struct iscsi_conn *conn,
-			    struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct iscsi_data_task *dtask;
-
-	dprintk("%p\n", ctask);
-	dtask = tcp_ctask->dtask = &tcp_ctask->unsol_dtask;
-	memset(&dtask->hdr, 0, sizeof(struct iscsi_hdr));
-	iscsi_buf_init_iov(&tcp_ctask->headbuf, (char*)&dtask->hdr,
-			   sizeof(struct iscsi_hdr));
-	__iscsi_rsp_build(ctask, (struct iscsi_hdr *) &dtask->hdr);
-}
-
-static int iscsi_tgt_transfer_response(struct scsi_cmnd *scmd,
-				       void (*done)(struct scsi_cmnd *))
-{
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) scmd->SCp.ptr;
-
-	dprintk("%p %x %x %u %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], scmd->request_bufflen,
-		scmd->bufflen, scmd->sc_data_direction);
-
-	if (scmd->sc_data_direction == DMA_FROM_DEVICE && scmd->bufflen) {
-		/* We've already sent data in transfer_data. */
-		iscsi_tcp_tgt_ctask_cleanup(ctask);
-		done(scmd);
-	} else {
-		scmd->done = done;
-		iscsi_rsp_build(ctask->conn, ctask);
-		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
-	}
-	return 0;
-}
-
-static void recvworker(void *data)
-{
-	struct iscsi_conn *conn = data;
-	struct iscsi_tcp_conn *tcp_conn = conn->dd_data;
-	struct sock *sk = tcp_conn->sock->sk;
-
-	bh_lock_sock(sk);
-	sk->sk_data_ready(sk, 0);
-	bh_unlock_sock(sk);
-}
-
-static int iscsi_tgt_transfer_data(struct scsi_cmnd *sc,
-				   void (*done)(struct scsi_cmnd *))
-{
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *) sc->SCp.ptr;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-
-	dprintk("%p %x %x %u %u\n", ctask, ctask->hdr->opcode & ISCSI_OPCODE_MASK,
-		ctask->hdr->cdb[0], sc->request_bufflen, sc->sc_data_direction);
-
-	sc->done = done;
-	if (sc->sc_data_direction == DMA_TO_DEVICE) {
-		struct iscsi_tcp_conn *tcp_conn = ctask->conn->dd_data;
-
-		if (!ctask->unsol_count && !ctask->imm_count)
-			iscsi_cmd_data_done(ctask);
-
-		clear_bit(ISCSI_SUSPEND_BIT, &ctask->conn->suspend_rx);
-		INIT_WORK(&tcp_conn->recvwork, recvworker, ctask->conn);
-		queue_work(recvwq, &tcp_conn->recvwork);
-	} else {
-		tcp_ctask->sg_count = 0;
-		tcp_ctask->data_offset = 0;
-		ctask->unsol_count = sc->bufflen;
-		tcp_ctask->sg = sc->request_buffer;
-		tcp_ctask->xmstate = XMSTATE_UNS_INIT | XMSTATE_UNS_HDR;
-		iscsi_tcp_tgt_ctask_xmitqueue(ctask);
-	}
-	return 0;
-}
-
-static int iscsi_tgt_eh_abort_handler(struct scsi_cmnd *scmd)
-{
-	BUG_ON(1);
-	return 0;
-}
-
-static int iscsi_tcp_tgt_ctask_xmit(struct iscsi_conn *conn,
-				    struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask->dd_data;
-	struct scsi_cmnd *sc = ctask->sc;
-	int err;
-
-	dprintk("%p\n", ctask);
-
-	err = iscsi_tcp_ctask_xmit(conn, ctask);
-	if (err)
-		return err;
-
-	dprintk("%p %d\n", ctask, err);
-
-	switch (ctask->hdr->opcode & ISCSI_OPCODE_MASK) {
-	case ISCSI_OP_LOGOUT:
-		iscsi_tcp_tgt_ctask_cleanup(ctask);
-		break;
-	case ISCSI_OP_SCSI_CMD:
-	{
-		struct iscsi_hdr *hdr =
-			(struct iscsi_hdr *) &tcp_ctask->unsol_dtask.hdr;
-		u8 opcode = hdr->opcode & ISCSI_OPCODE_MASK;
-
-		switch (opcode) {
-		case ISCSI_OP_SCSI_CMD_RSP:
-			iscsi_tcp_tgt_ctask_cleanup(ctask);
-			sc->done(sc);
-			break;
-		case ISCSI_OP_SCSI_DATA_IN:
-			sc->done(sc);
-			break;
-		}
-	}
-	default:
-		break;
-	}
-
-	dprintk("%p %d\n", ctask, err);
-
-	return err;
-}
-
-static struct iscsi_cls_session *
-iscsi_tcp_tgt_session_create(struct iscsi_transport *iscsit,
-			     struct scsi_transport_template *scsit,
-			     uint32_t initial_cmdsn, uint32_t *hostno)
-{
-	struct Scsi_Host *shost;
-	struct iscsi_cls_session *cls_session;
-	struct iscsi_session *session;
-	struct istgt_session *istgt_session;
-	int i, err;
-
-	dprintk("%u %u\n", initial_cmdsn, *hostno);
-	cls_session = iscsi_tcp_session_create(iscsit, scsit, initial_cmdsn, hostno);
-	if (!cls_session)
-		return NULL;
-	shost = iscsi_session_to_shost(cls_session);
-	err = scsi_tgt_alloc_queue(shost);
-	if (err)
-		goto session_free;
-
-	session = class_to_transport_session(cls_session);
-	for (i = 0; i < initial_cmdsn; i++) {
-		struct iscsi_cmd_task *ctask = session->cmds[i];
-		INIT_LIST_HEAD(&ctask->hash);
-		INIT_LIST_HEAD(&ctask->pending);
-	}
-	session->exp_cmdsn = initial_cmdsn;
-
-	istgt_session =	(struct istgt_session *) cls_session->dd_data;
-	INIT_LIST_HEAD(&istgt_session->cmd_hash);
-	INIT_LIST_HEAD(&istgt_session->cmd_pending);
-
-	dprintk("%u %u\n", initial_cmdsn, *hostno);
-
-	return cls_session;
-session_free:
-	iscsi_session_teardown(cls_session);
-	return NULL;
-}
-
-static struct iscsi_tcp_operations iscsi_tcp_tgt_ops = {
-	.hdr_recv		= iscsi_tcp_tgt_hdr_recv,
-	.data_recv		= iscsi_tcp_tgt_data_recv,
-	.unsolicit_data_init	= iscsi_data_rsp_build,
-};
-
-static struct iscsi_cls_conn *
-iscsi_tcp_tgt_conn_create(struct iscsi_cls_session *cls_session,
-			  uint32_t conn_idx)
-{
-	struct iscsi_cls_conn *cls_conn;
-	dprintk("%u\n", conn_idx);
-	cls_conn = iscsi_tcp_conn_create(cls_session, conn_idx,
-					 &iscsi_tcp_tgt_ops);
-	dprintk("%u %p\n", conn_idx, cls_conn->dd_data);
-	return cls_conn;
-}
-
-#define	DEFAULT_NR_QUEUED_CMNDS	32
-#define TGT_NAME "iscsi_tcp_tgt"
-
-static struct scsi_host_template iscsi_tcp_tgt_sht = {
-	.name			= TGT_NAME,
-	.module			= THIS_MODULE,
-	.can_queue		= DEFAULT_NR_QUEUED_CMNDS,
-	.sg_tablesize		= SG_ALL,
-	.max_sectors		= 65535,
-	.use_clustering		= DISABLE_CLUSTERING,
-	.transfer_response	= iscsi_tgt_transfer_response,
-	.transfer_data		= iscsi_tgt_transfer_data,
-	.eh_abort_handler	= iscsi_tgt_eh_abort_handler,
-};
-
-static struct iscsi_transport iscsi_tcp_tgt_transport = {
-	.owner			= THIS_MODULE,
-	.name			= TGT_NAME,
-	.host_template		= &iscsi_tcp_tgt_sht,
-	.conndata_size		= sizeof(struct iscsi_conn),
-	.sessiondata_size	= sizeof(struct istgt_session),
-	.max_conn		= 1,
-	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
-	.create_session		= iscsi_tcp_tgt_session_create,
-	.destroy_session	= iscsi_tcp_session_destroy,
-	.create_conn		= iscsi_tcp_tgt_conn_create,
-	.destroy_conn		= iscsi_tcp_conn_destroy,
-	.bind_conn		= iscsi_tcp_conn_bind,
-	.start_conn		= iscsi_conn_start,
-	.set_param		= iscsi_conn_set_param,
-	.terminate_conn		= iscsi_tcp_terminate_conn,
-	.xmit_cmd_task		= iscsi_tcp_tgt_ctask_xmit,
-};
-
-static int __init iscsi_tcp_tgt_init(void)
-{
-	printk("iSCSI Target over TCP\n");
-
-	recvwq = create_workqueue("iscsi_recvwork");
-	if (!recvwq)
-		return -ENOMEM;
-
-	if (!iscsi_register_transport(&iscsi_tcp_tgt_transport))
-		goto destroy_wq;
-
-	return 0;
-destroy_wq:
-	destroy_workqueue(recvwq);
-	return -ENODEV;
-}
-
-static void __exit iscsi_tcp_tgt_exit(void)
-{
-	destroy_workqueue(recvwq);
-	iscsi_unregister_transport(&iscsi_tcp_tgt_transport);
-}
-
-module_init(iscsi_tcp_tgt_init);
-module_exit(iscsi_tcp_tgt_exit);
-
-MODULE_DESCRIPTION("iSCSI/TCP target");
-MODULE_LICENSE("GPL");



From tomo at berlios.de  Wed Jun 21 14:32:33 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Wed, 21 Jun 2006 14:32:33 +0200
Subject: [Stgt-svn] r488 - branches/use-scsi-ml/usr
Message-ID: <200606211232.k5LCWXvP013378@sheep.berlios.de>

Author: tomo
Date: 2006-06-21 14:32:30 +0200 (Wed, 21 Jun 2006)
New Revision: 488

Modified:
   branches/use-scsi-ml/usr/tgtadm.c
Log:
Restore hostno option for bind operation.

Modified: branches/use-scsi-ml/usr/tgtadm.c
===================================================================
--- branches/use-scsi-ml/usr/tgtadm.c	2006-06-02 10:31:02 UTC (rev 487)
+++ branches/use-scsi-ml/usr/tgtadm.c	2006-06-21 12:32:30 UTC (rev 488)
@@ -61,6 +61,7 @@
 	{"lun", required_argument, NULL, 'l'},
 	{"params", required_argument, NULL, 'p'},
 	{"user", no_argument, NULL, 'u'},
+	{"hostno", required_argument, NULL, 'i'},
 	{"bus", required_argument, NULL, 'b'},
 	{"version", no_argument, NULL, 'v'},
 	{"help", no_argument, NULL, 'h'},
@@ -472,6 +473,9 @@
 			lun = strtoull(optarg, NULL, 10);
 			set |= (1 << MODE_DEVICE);
 			break;
+		case 'i':
+			hostno = strtol(optarg, NULL, 10);
+			break;
 		case 'b':
 			hostno = bus_to_host(optarg);
 			break;



From tomo at berlios.de  Thu Jun 22 13:52:52 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Thu, 22 Jun 2006 13:52:52 +0200
Subject: [Stgt-svn] r489 - branches/use-scsi-ml/patchset
Message-ID: <200606221152.k5MBqqD1004323@sheep.berlios.de>

Author: tomo
Date: 2006-06-22 13:52:47 +0200 (Thu, 22 Jun 2006)
New Revision: 489

Removed:
   branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt
   branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt
   branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff
Log:
Remove old patches.

Deleted: branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt
===================================================================
--- branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/0001-scsi-tgt-add-libsrp.txt	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,593 +0,0 @@
-Subject: [PATCH 1/2] scsi tgt: add libsrp
-
-There's a fair chance that we'll get several SRP target drivers (for
-IBM iSeries and OpenIB at least). They will have lots of duplicated
-code. libsrp tries to provide helper functions for them to avoid the
-duplicated code.
-
-The next step would be to add initiator support to merge the two SRP
-initiator drivers in mainline.
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/Kconfig  |    9 +
- drivers/scsi/Makefile |    1 
- drivers/scsi/libsrp.c |  448 +++++++++++++++++++++++++++++++++++++++++++++++++
- include/scsi/libsrp.h |   75 ++++++++
- 4 files changed, 533 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/libsrp.c
- create mode 100644 include/scsi/libsrp.h
-
-04bec8adfeeee4a0b0a04627d5f8b7d6261f0c4a
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 5b5eeb4..cf3558b 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -1834,6 +1834,15 @@ config ZFCP
-           called zfcp. If you want to compile it as a module, say M here
-           and read <file:Documentation/modules.txt>.
- 
-+config SCSI_SRP
-+	tristate "SCSI RDMA Protocol helper library"
-+	depends on SCSI
-+	help
-+	  If you wish to use SRP target drivers, say Y.
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called libsrp.
-+
- endmenu
- 
- source "drivers/scsi/pcmcia/Kconfig"
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index 3d81b8d..0779523 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -123,6 +123,7 @@ obj-$(CONFIG_SCSI_FCAL)		+= fcal.o
- obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o lasi700.o
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
-+obj-$(CONFIG_SCSI_SRP)		+= libsrp.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
-diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
-new file mode 100644
-index 0000000..2a2cfd6
---- /dev/null
-+++ b/drivers/scsi/libsrp.c
-@@ -0,0 +1,448 @@
-+/*
-+ * SCSI RDAM Protocol lib functions
-+ *
-+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of the
-+ * License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful, but
-+ * WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-+ * General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
-+ * 02110-1301 USA
-+ */
-+#include <linux/err.h>
-+#include <linux/kfifo.h>
-+#include <linux/scatterlist.h>
-+#include <linux/dma-mapping.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_tcq.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/srp.h>
-+#include <scsi/libsrp.h>
-+
-+enum srp_task_attributes {
-+	SRP_SIMPLE_TASK = 0,
-+	SRP_HEAD_TASK = 1,
-+	SRP_ORDERED_TASK = 2,
-+	SRP_ACA_TASK = 4
-+};
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+static int srp_iu_pool_alloc(struct srp_queue *q, size_t max,
-+			     struct srp_buf **ring)
-+{
-+	int i;
-+	struct iu_entry *iue;
-+
-+	q->pool = kcalloc(max, sizeof(struct iu_entry *), GFP_KERNEL);
-+	if (!q->pool)
-+		return -ENOMEM;
-+	q->items = kcalloc(max, sizeof(struct iu_entry), GFP_KERNEL);
-+	if (!q->items)
-+		goto free_pool;
-+
-+	spin_lock_init(&q->lock);
-+	q->queue = kfifo_init((void *) q->pool, max * sizeof(void *),
-+			      GFP_KERNEL, &q->lock);
-+	if (IS_ERR(q->queue))
-+		goto free_item;
-+
-+	for (i = 0, iue = q->items; i < max; i++) {
-+		__kfifo_put(q->queue, (void *) &iue, sizeof(void *));
-+		iue->sbuf = ring[i];
-+		iue++;
-+	}
-+	return 0;
-+
-+free_item:
-+	kfree(q->items);
-+free_pool:
-+	kfree(q->pool);
-+	return -ENOMEM;
-+}
-+
-+static void srp_iu_pool_free(struct srp_queue *q)
-+{
-+	kfree(q->items);
-+	kfree(q->pool);
-+}
-+
-+static struct srp_buf ** srp_ring_alloc(struct device *dev,
-+					size_t max, size_t size)
-+{
-+	int i;
-+	struct srp_buf **ring;
-+
-+	ring = kcalloc(max, sizeof(struct srp_buf *), GFP_KERNEL);
-+	if (!ring)
-+		return NULL;
-+
-+	for (i = 0; i < max; i++) {
-+		ring[i] = kzalloc(sizeof(struct srp_buf), GFP_KERNEL);
-+		if (!ring[i])
-+			goto out;
-+		ring[i]->buf = dma_alloc_coherent(dev, size, &ring[i]->dma,
-+						  GFP_KERNEL);
-+		if (!ring[i]->buf)
-+			goto out;
-+	}
-+	return ring;
-+
-+out:
-+	for (i = 0; i < max && ring[i]; i++) {
-+		if (ring[i]->buf)
-+			dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+	kfree(ring);
-+
-+	return NULL;
-+}
-+
-+static void srp_ring_free(struct device *dev, struct srp_buf **ring, size_t max,
-+			  size_t size)
-+{
-+	int i;
-+
-+	for (i = 0; i < max; i++) {
-+		dma_free_coherent(dev, size, ring[i]->buf, ring[i]->dma);
-+		kfree(ring[i]);
-+	}
-+}
-+
-+int srp_target_alloc(struct srp_target *target, struct device *dev,
-+		     size_t nr, size_t iu_size)
-+{
-+	int err;
-+
-+	spin_lock_init(&target->lock);
-+	INIT_LIST_HEAD(&target->cmd_queue);
-+
-+	target->dev = dev;
-+	target->dev->driver_data = target;
-+
-+	target->srp_iu_size = iu_size;
-+	target->rx_ring_size = nr;
-+	target->rx_ring = srp_ring_alloc(target->dev, nr, iu_size);
-+	if (!target->rx_ring)
-+		return -ENOMEM;
-+	err = srp_iu_pool_alloc(&target->iu_queue, nr, target->rx_ring);
-+	if (err)
-+		goto free_ring;
-+
-+	return 0;
-+
-+free_ring:
-+	srp_ring_free(target->dev, target->rx_ring, nr, iu_size);
-+	return -ENOMEM;
-+}
-+EXPORT_SYMBOL_GPL(srp_target_alloc);
-+
-+void srp_target_free(struct srp_target *target)
-+{
-+	srp_ring_free(target->dev, target->rx_ring, target->rx_ring_size,
-+		      target->srp_iu_size);
-+	srp_iu_pool_free(&target->iu_queue);
-+}
-+EXPORT_SYMBOL_GPL(srp_target_free);
-+
-+struct iu_entry *srp_iu_get(struct srp_target *target)
-+{
-+	struct iu_entry *iue = NULL;
-+
-+	kfifo_get(target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+	BUG_ON(!iue);
-+
-+	iue->target = target;
-+	iue->scmd = NULL;
-+	INIT_LIST_HEAD(&iue->ilist);
-+	iue->flags = 0;
-+	return iue;
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_get);
-+
-+void srp_iu_put(struct iu_entry *iue)
-+{
-+	kfifo_put(iue->target->iu_queue.queue, (void *) &iue, sizeof(void *));
-+}
-+EXPORT_SYMBOL_GPL(srp_iu_put);
-+
-+static int direct_data(struct scsi_cmnd *scmd, struct srp_direct_buf *md,
-+		       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct scatterlist *sg = scmd->request_buffer;
-+	int nsg, err;
-+
-+	dprintk("%p %u %u %u %d\n", iue, scmd->request_bufflen, scmd->bufflen,
-+		md->len, scmd->use_sg);
-+
-+	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		printk("fail to map %p %d\n", iue, scmd->use_sg);
-+		return 0;
-+	}
-+	err = rdma_io(iue, sg, nsg, md, 1, dir,
-+		      min(scmd->request_bufflen, md->len));
-+
-+	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+	return err;
-+}
-+
-+static int indirect_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			 struct srp_indirect_buf *id,
-+			 enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+	struct srp_direct_buf *md;
-+	struct scatterlist dummy, *sg = scmd->request_buffer;
-+	dma_addr_t token = 0;
-+	long err;
-+	unsigned int done = 0;
-+	int nmd, nsg;
-+
-+	nmd = id->table_desc.len / sizeof(struct srp_direct_buf);
-+
-+	dprintk("%p %u %u %u %u %d %d %d\n",
-+		iue, scmd->request_bufflen, scmd->bufflen,
-+		id->len, scmd->offset, nmd,
-+		cmd->data_in_desc_cnt, cmd->data_out_desc_cnt);
-+
-+	if ((dir == DMA_FROM_DEVICE && nmd == cmd->data_in_desc_cnt) ||
-+	    (dir == DMA_TO_DEVICE && nmd == cmd->data_out_desc_cnt)) {
-+		md = &id->desc_list[0];
-+		goto rdma;
-+	}
-+
-+	md = dma_alloc_coherent(target->dev, id->table_desc.len,
-+				 &token, GFP_KERNEL);
-+	if (!md) {
-+		eprintk("Can't get dma memory %u\n", id->table_desc.len);
-+		return 0;
-+	}
-+
-+	sg_init_one(&dummy, md, id->table_desc.len);
-+	sg_dma_address(&dummy) = token;
-+	err = rdma_io(iue, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
-+		      id->table_desc.len);
-+	if (err < 0) {
-+		eprintk("Error copying indirect table %ld\n", err);
-+		goto free_mem;
-+	}
-+
-+rdma:
-+	nsg = dma_map_sg(target->dev, sg, scmd->use_sg, DMA_BIDIRECTIONAL);
-+	if (!nsg) {
-+		eprintk("fail to map %p %d\n", iue, scmd->use_sg);
-+		goto free_mem;
-+	}
-+
-+	err = rdma_io(iue, sg, nsg, md, nmd, dir,
-+		      min(scmd->request_bufflen, id->len));
-+	dma_unmap_sg(target->dev, sg, nsg, DMA_BIDIRECTIONAL);
-+
-+free_mem:
-+	if (token)
-+		dma_free_coherent(target->dev, id->table_desc.len, md, token);
-+
-+	return done;
-+}
-+
-+static int data_out_desc_size(struct srp_cmd *cmd)
-+{
-+	int size = 0;
-+	u8 fmt = cmd->buf_fmt >> 4;
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		size = sizeof(struct srp_direct_buf);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		size = sizeof(struct srp_indirect_buf) +
-+			sizeof(struct srp_direct_buf) * cmd->data_out_desc_cnt;
-+		break;
-+	default:
-+		eprintk("client error. Invalid data_out_format %x\n", fmt);
-+		break;
-+	}
-+	return size;
-+}
-+
-+static int __srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			       enum dma_data_direction dir, rdma_io_t rdma_io)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int offset, err = 0;
-+	u8 format;
-+
-+	offset = cmd->add_cdb_len * 4;
-+	if (dir == DMA_FROM_DEVICE)
-+		offset += data_out_desc_size(cmd);
-+
-+	if (dir == DMA_TO_DEVICE)
-+		format = cmd->buf_fmt >> 4;
-+	else
-+		format = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	switch (format) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *)
-+			(cmd->add_data + offset);
-+		err = direct_data(scmd, md, dir, rdma_io);
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *)
-+			(cmd->add_data + offset);
-+		err = indirect_data(scmd, cmd, id, dir, rdma_io);
-+		break;
-+	default:
-+		eprintk("Unknown format %d %x\n", dir, format);
-+		break;
-+	}
-+
-+	return err;
-+}
-+
-+/* TODO: this can be called multiple times for a single command. */
-+int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+		      rdma_io_t rdma_io)
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
-+	enum dma_data_direction dir;
-+
-+	if (test_bit(V_WRITE, &iue->flags))
-+		dir = DMA_TO_DEVICE;
-+	else
-+		dir = DMA_FROM_DEVICE;
-+	__srp_transfer_data(scmd, cmd, dir, rdma_io);
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_transfer_data);
-+
-+static int vscsis_data_length(struct srp_cmd *cmd, enum dma_data_direction dir)
-+{
-+	struct srp_direct_buf *md;
-+	struct srp_indirect_buf *id;
-+	int len = 0, offset = cmd->add_cdb_len * 4;
-+	u8 fmt;
-+
-+	if (dir == DMA_TO_DEVICE)
-+		fmt = cmd->buf_fmt >> 4;
-+	else {
-+		fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+		offset += data_out_desc_size(cmd);
-+	}
-+
-+	switch (fmt) {
-+	case SRP_NO_DATA_DESC:
-+		break;
-+	case SRP_DATA_DESC_DIRECT:
-+		md = (struct srp_direct_buf *) (cmd->add_data + offset);
-+		len = md->len;
-+		break;
-+	case SRP_DATA_DESC_INDIRECT:
-+		id = (struct srp_indirect_buf *) (cmd->add_data + offset);
-+		len = id->len;
-+		break;
-+	default:
-+		eprintk("invalid data format %x\n", fmt);
-+		break;
-+	}
-+	return len;
-+}
-+
-+static uint8_t getcontrolbyte(u8 *cdb)
-+{
-+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
-+}
-+
-+static inline uint8_t getlink(struct srp_cmd *cmd)
-+{
-+	return (getcontrolbyte(cmd->cdb) & 0x01);
-+}
-+
-+int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd)
-+{
-+	struct Scsi_host *shost = iue->target->shost;
-+	enum dma_data_direction data_dir;
-+	struct scsi_cmnd *scmd;
-+	int tag, len;
-+
-+	if (getlink(cmd))
-+		__set_bit(V_LINKED, &iue->flags);
-+
-+	tag = MSG_SIMPLE_TAG;
-+
-+	switch (cmd->task_attr) {
-+	case SRP_SIMPLE_TASK:
-+		tag = MSG_SIMPLE_TAG;
-+		break;
-+	case SRP_ORDERED_TASK:
-+		tag = MSG_ORDERED_TAG;
-+		break;
-+	case SRP_HEAD_TASK:
-+		tag = MSG_HEAD_TAG;
-+		break;
-+	default:
-+		eprintk("Task attribute %d not supported\n", cmd->task_attr);
-+		tag = MSG_ORDERED_TAG;
-+	}
-+
-+	switch (cmd->cdb[0]) {
-+	case WRITE_6:
-+	case WRITE_10:
-+	case WRITE_VERIFY:
-+	case WRITE_12:
-+	case WRITE_VERIFY_12:
-+		__set_bit(V_WRITE, &iue->flags);
-+	}
-+
-+	if (cmd->buf_fmt >> 4)
-+		data_dir = DMA_TO_DEVICE;
-+	else
-+		data_dir = DMA_FROM_DEVICE;
-+	len = vscsis_data_length(cmd, data_dir);
-+
-+	dprintk("%p %x %lx %d %d %d %llx\n", iue, cmd->cdb[0],
-+		cmd->lun, data_dir, len, tag, (unsigned long long) cmd->tag);
-+
-+	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
-+	BUG_ON(!scmd);
-+	scmd->SCp.ptr = (char *) iue;
-+	memcpy(scmd->data_cmnd, cmd->cdb, MAX_COMMAND_SIZE);
-+	scmd->request_bufflen = len;
-+	scmd->tag = tag;
-+	iue->scmd = scmd;
-+	scsi_tgt_queue_command(scmd, (struct scsi_lun *) &cmd->lun, cmd->tag);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL_GPL(srp_cmd_perform);
-+
-+MODULE_DESCRIPTION("SCSI RDAM Protocol lib functions");
-+MODULE_AUTHOR("FUJITA Tomonori");
-+MODULE_LICENSE("GPL");
-diff --git a/include/scsi/libsrp.h b/include/scsi/libsrp.h
-new file mode 100644
-index 0000000..9dd10ff
---- /dev/null
-+++ b/include/scsi/libsrp.h
-@@ -0,0 +1,75 @@
-+#ifndef __LIBSRP_H__
-+#define __LIBSRP_H__
-+
-+#include <linux/list.h>
-+#include <scsi/scsi_cmnd.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/srp.h>
-+
-+enum iue_flags {
-+	V_DIOVER,
-+	V_WRITE,
-+	V_LINKED,
-+	V_FLYING,
-+};
-+
-+struct srp_buf {
-+	dma_addr_t dma;
-+	void *buf;
-+};
-+
-+struct srp_queue {
-+	void *pool;
-+	void *items;
-+	struct kfifo *queue;
-+	spinlock_t lock;
-+};
-+
-+struct srp_target {
-+	struct Scsi_Host *shost;
-+	struct device *dev;
-+
-+	spinlock_t lock;
-+	struct list_head cmd_queue;
-+
-+	size_t srp_iu_size;
-+	struct srp_queue iu_queue;
-+	size_t rx_ring_size;
-+	struct srp_buf **rx_ring;
-+
-+	/* IB needs tx_ring too */
-+
-+	void *ldata;
-+};
-+
-+struct iu_entry {
-+	struct srp_target *target;
-+	struct scsi_cmnd *scmd;
-+
-+	struct list_head ilist;
-+	dma_addr_t remote_token;
-+	unsigned long flags;
-+
-+	struct srp_buf *sbuf;
-+};
-+
-+typedef int (rdma_io_t) (struct iu_entry *, struct scatterlist *, int,
-+			 struct srp_direct_buf *, int,
-+			 enum dma_data_direction, unsigned int);
-+
-+static inline struct srp_target *host_to_target(struct Scsi_Host *host)
-+{
-+	return (struct srp_target *) host->hostdata;
-+}
-+
-+extern int srp_target_alloc(struct srp_target *, struct device *, size_t, size_t);
-+extern void srp_target_free(struct srp_target *);
-+
-+extern struct iu_entry *srp_iu_get(struct srp_target *);
-+extern void srp_iu_put(struct iu_entry *);
-+
-+extern int srp_cmd_perform(struct iu_entry *iue, struct srp_cmd *cmd);
-+extern int srp_transfer_data(struct scsi_cmnd *scmd, struct srp_cmd *cmd,
-+			     rdma_io_t rdma_io);
-+
-+#endif
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt
===================================================================
--- branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/0002-scsi-tgt-ibmvstgt-driver.txt	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,1021 +0,0 @@
-Subject: [PATCH 2/2] scsi tgt: ibmvstgt driver
-
-This tgt driver provides SCSI RDMA target support for IBM Power5
-systems.
-
-tgt and libsrp allow large simplifications in the original ibmvscsis
-driver:
-
-http://lkml.org/lkml/2005/10/17/99
-
-Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
-Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
-
----
-
- drivers/scsi/Kconfig             |   14 +
- drivers/scsi/Makefile            |    1 
- drivers/scsi/ibmvscsi/Makefile   |    2 
- drivers/scsi/ibmvscsi/ibmvstgt.c |  943 ++++++++++++++++++++++++++++++++++++++
- 4 files changed, 960 insertions(+), 0 deletions(-)
- create mode 100644 drivers/scsi/ibmvscsi/ibmvstgt.c
-
-756cba9c44e2cccbabfa9abc2e96bdbcea92e25a
-diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
-index 5b5eeb4..0ad0a5b 100644
---- a/drivers/scsi/Kconfig
-+++ b/drivers/scsi/Kconfig
-@@ -897,6 +897,20 @@ config SCSI_IBMVSCSI
- 	  To compile this driver as a module, choose M here: the
- 	  module will be called ibmvscsic.
- 
-+config SCSI_IBMVSCSIS
-+	tristate "IBM Virtual SCSI Server support"
-+	depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
-+	help
-+	  This is the SRP target driver for IBM pSeries virtual environments.
-+
-+	  The userspace component needed to initialize the driver and
-+	  documentation can be found:
-+
-+	  http://stgt.berlios.de/
-+
-+	  To compile this driver as a module, choose M here: the
-+	  module will be called ibmvstgt.
-+
- config SCSI_INITIO
- 	tristate "Initio 9100U(W) support"
- 	depends on PCI && SCSI
-diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
-index 3d81b8d..c951da1 100644
---- a/drivers/scsi/Makefile
-+++ b/drivers/scsi/Makefile
-@@ -124,6 +124,7 @@ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o l
- obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
- obj-$(CONFIG_SCSI_IPR)		+= ipr.o
- obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
- obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
- obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
- obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
-diff --git a/drivers/scsi/ibmvscsi/Makefile b/drivers/scsi/ibmvscsi/Makefile
-index 4e247b6..6ac0633 100644
---- a/drivers/scsi/ibmvscsi/Makefile
-+++ b/drivers/scsi/ibmvscsi/Makefile
-@@ -3,3 +3,5 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
- ibmvscsic-y			+= ibmvscsi.o
- ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
- ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
-+
-+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvstgt.o
-diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
-new file mode 100644
-index 0000000..a4891f6
---- /dev/null
-+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
-@@ -0,0 +1,943 @@
-+/*
-+ * IBM eServer i/pSeries Virtual SCSI Target Driver
-+ * Copyright (C) 2003-2005 Dave Boutcher (boutcher at us.ibm.com) IBM Corp.
-+ *			   Santiago Leon (santil at us.ibm.com) IBM Corp.
-+ *			   Linda Xie (lxie at us.ibm.com) IBM Corp.
-+ *
-+ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
-+ * USA
-+ */
-+#include <linux/interrupt.h>
-+#include <linux/module.h>
-+#include <scsi/scsi.h>
-+#include <scsi/scsi_host.h>
-+#include <scsi/scsi_tgt.h>
-+#include <scsi/libsrp.h>
-+#include <asm/hvcall.h>
-+#include <asm/iommu.h>
-+#include <asm/prom.h>
-+#include <asm/vio.h>
-+
-+#include "ibmvscsi.h"
-+
-+#define	INITIAL_SRP_LIMIT	16
-+#define	DEFAULT_MAX_SECTORS	512
-+
-+#define	TGT_NAME	"ibmvstgt"
-+
-+/*
-+ * Hypervisor calls.
-+ */
-+#define h_copy_rdma(l, sa, sb, da, db) \
-+			plpar_hcall_norets(H_COPY_RDMA, l, sa, sb, da, db)
-+#define h_send_crq(ua, l, h) \
-+			plpar_hcall_norets(H_SEND_CRQ, ua, l, h)
-+#define h_reg_crq(ua, tok, sz)\
-+			plpar_hcall_norets(H_REG_CRQ, ua, tok, sz);
-+#define h_free_crq(ua) \
-+			plpar_hcall_norets(H_FREE_CRQ, ua);
-+
-+/* tmp - will replace with SCSI logging stuff */
-+#define eprintk(fmt, args...)					\
-+do {								\
-+	printk("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-+} while (0)
-+/* #define dprintk eprintk */
-+#define dprintk(fmt, args...)
-+
-+struct vio_port {
-+	struct vio_dev *dma_dev;
-+
-+	struct crq_queue crq_queue;
-+	struct work_struct crq_work;
-+
-+	unsigned long liobn;
-+	unsigned long riobn;
-+};
-+
-+static struct workqueue_struct *vtgtd;
-+
-+/*
-+ * These are fixed for the system and come from the Open Firmware device tree.
-+ * We just store them here to save getting them every time.
-+ */
-+static char system_id[64] = "";
-+static char partition_name[97] = "UNKNOWN";
-+static unsigned int partition_number = -1;
-+
-+static struct vio_port *target_to_port(struct srp_target *target)
-+{
-+	return (struct vio_port *) target->ldata;
-+}
-+
-+static inline union viosrp_iu *vio_iu(struct iu_entry *iue)
-+{
-+	return (union viosrp_iu *) (iue->sbuf->buf);
-+}
-+
-+static int send_iu(struct iu_entry *iue, uint64_t length, uint8_t format)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	long rc, rc1;
-+	union {
-+		struct viosrp_crq cooked;
-+		uint64_t raw[2];
-+	} crq;
-+
-+	/* First copy the SRP */
-+	rc = h_copy_rdma(length, vport->liobn, iue->sbuf->dma,
-+			 vport->riobn, iue->remote_token);
-+
-+	if (rc)
-+		eprintk("Error %ld transferring data\n", rc);
-+
-+	crq.cooked.valid = 0x80;
-+	crq.cooked.format = format;
-+	crq.cooked.reserved = 0x00;
-+	crq.cooked.timeout = 0x00;
-+	crq.cooked.IU_length = length;
-+	crq.cooked.IU_data_ptr = vio_iu(iue)->srp.rsp.tag;
-+
-+	if (rc == 0)
-+		crq.cooked.status = 0x99;	/* Just needs to be non-zero */
-+	else
-+		crq.cooked.status = 0x00;
-+
-+	rc1 = h_send_crq(vport->dma_dev->unit_address, crq.raw[0], crq.raw[1]);
-+
-+	if (rc1) {
-+		eprintk("%ld sending response\n", rc1);
-+		return rc1;
-+	}
-+
-+	return rc;
-+}
-+
-+#define SRP_RSP_SENSE_DATA_LEN	18
-+
-+static int send_rsp(struct iu_entry *iue, unsigned char status,
-+		    unsigned char asc)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* If the linked bit is on and status is good */
-+	if (test_bit(V_LINKED, &iue->flags) && (status == NO_SENSE))
-+		status = 0x10;
-+
-+	memset(iu, 0, sizeof(struct srp_rsp));
-+	iu->srp.rsp.opcode = SRP_RSP;
-+	iu->srp.rsp.req_lim_delta = 1;
-+	iu->srp.rsp.tag = tag;
-+
-+	if (test_bit(V_DIOVER, &iue->flags))
-+		iu->srp.rsp.flags |= SRP_RSP_FLAG_DIOVER;
-+
-+	iu->srp.rsp.data_in_res_cnt = 0;
-+	iu->srp.rsp.data_out_res_cnt = 0;
-+
-+	iu->srp.rsp.flags &= ~SRP_RSP_FLAG_RSPVALID;
-+
-+	iu->srp.rsp.resp_data_len = 0;
-+	iu->srp.rsp.status = status;
-+	if (status) {
-+		uint8_t *sense = iu->srp.rsp.data;
-+
-+		if (iue->scmd) {
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SCSI_SENSE_BUFFERSIZE;
-+			memcpy(sense, iue->scmd->sense_buffer,
-+			       SCSI_SENSE_BUFFERSIZE);
-+		} else {
-+			iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
-+			iu->srp.rsp.flags |= SRP_RSP_FLAG_SNSVALID;
-+			iu->srp.rsp.sense_data_len = SRP_RSP_SENSE_DATA_LEN;
-+
-+			/* Valid bit and 'current errors' */
-+			sense[0] = (0x1 << 7 | 0x70);
-+			/* Sense key */
-+			sense[2] = status;
-+			/* Additional sense length */
-+			sense[7] = 0xa;	/* 10 bytes */
-+			/* Additional sense code */
-+			sense[12] = asc;
-+		}
-+	}
-+
-+	send_iu(iue, sizeof(iu->srp.rsp) + SRP_RSP_SENSE_DATA_LEN,
-+		VIOSRP_SRP_FORMAT);
-+
-+	return 0;
-+}
-+
-+static void handle_cmd_queue(struct srp_target *target)
-+{
-+	struct iu_entry *iue;
-+	unsigned long flags;
-+
-+retry:
-+	spin_lock_irqsave(&target->lock, flags);
-+
-+	list_for_each_entry(iue, &target->cmd_queue, ilist) {
-+		if (!test_and_set_bit(V_FLYING, &iue->flags)) {
-+			spin_unlock_irqrestore(&target->lock, flags);
-+			srp_cmd_perform(iue, (struct srp_cmd *) iue->sbuf->buf);
-+			goto retry;
-+		}
-+	}
-+
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int ibmvstgt_rdma(struct iu_entry *iue, struct scatterlist *sg, int nsg,
-+			 struct srp_direct_buf *md, int nmd,
-+			 enum dma_data_direction dir, unsigned int rest)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	dma_addr_t token;
-+	long err;
-+	unsigned int done = 0;
-+	int i, sidx, soff;
-+
-+	sidx = soff = 0;
-+	token = sg_dma_address(sg + sidx);
-+
-+	for (i = 0; i < nmd && rest; i++) {
-+		unsigned int mdone, mlen;
-+
-+		mlen = min(rest, md[i].len);
-+		for (mdone = 0; mlen;) {
-+			int slen = min(sg_dma_len(sg + sidx) - soff, mlen);
-+
-+			if (dir == DMA_TO_DEVICE)
-+				err = h_copy_rdma(slen,
-+						  vport->riobn,
-+						  md[i].va + mdone,
-+						  vport->liobn,
-+						  token + soff);
-+			else
-+				err = h_copy_rdma(slen,
-+						  vport->liobn,
-+						  token + soff,
-+						  vport->riobn,
-+						  md[i].va + mdone);
-+
-+			if (err != H_Success) {
-+				eprintk("rdma error %d %d\n", dir, slen);
-+				goto out;
-+			}
-+
-+			mlen -= slen;
-+			mdone += slen;
-+			soff += slen;
-+			done += slen;
-+
-+			if (soff == sg_dma_len(sg + sidx)) {
-+				sidx++;
-+				soff = 0;
-+				token = sg_dma_address(sg + sidx);
-+
-+				if (sidx > nsg) {
-+					eprintk("out of sg %p %d %d\n",
-+						iue, sidx, nsg);
-+					goto out;
-+				}
-+			}
-+		};
-+
-+		rest -= mlen;
-+	}
-+out:
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_transfer_data(struct scsi_cmnd *scmd,
-+				  void (*done)(struct scsi_cmnd *))
-+{
-+	struct iu_entry	*iue = (struct iu_entry *) scmd->SCp.ptr;
-+	int err;
-+
-+	err = srp_transfer_data(scmd, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma);
-+	done(scmd);
-+
-+	return err;
-+}
-+
-+static int ibmvstgt_cmd_done(struct scsi_cmnd *scmd,
-+			     void (*done)(struct scsi_cmnd *))
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	if (scmd->result != SAM_STAT_GOOD) {
-+		eprintk("operation failed %p %d %x\n",
-+			iue, scmd->result, vio_iu(iue)->srp.cmd.cdb[0]);
-+		send_rsp(iue, HARDWARE_ERROR, 0x00);
-+	} else
-+		send_rsp(iue, NO_SENSE, 0x00);
-+
-+	done(scmd);
-+	srp_iu_put(iue);
-+	return 0;
-+}
-+
-+int send_adapter_info(struct iu_entry *iue,
-+		      dma_addr_t remote_buffer, uint16_t length)
-+{
-+	struct srp_target *target = iue->target;
-+	struct vio_port *vport = target_to_port(target);
-+	struct Scsi_Host *shost = target->shost;
-+	dma_addr_t data_token;
-+	struct mad_adapter_info_data *info;
-+	int err;
-+
-+	info = dma_alloc_coherent(target->dev, sizeof(*info), &data_token,
-+				  GFP_KERNEL);
-+	if (!info) {
-+		eprintk("bad dma_alloc_coherent %p\n", target);
-+		return 1;
-+	}
-+
-+	/* Get remote info */
-+	err = h_copy_rdma(sizeof(*info), vport->riobn, remote_buffer,
-+			  vport->liobn, data_token);
-+	if (err == H_Success) {
-+		dprintk("Client connect: %s (%d)\n",
-+			info->partition_name, info->partition_number);
-+	}
-+
-+	memset(info, 0, sizeof(*info));
-+
-+	strcpy(info->srp_version, "16.a");
-+	strncpy(info->partition_name, partition_name,
-+		sizeof(info->partition_name));
-+	info->partition_number = partition_number;
-+	info->mad_version = 1;
-+	info->os_type = 2;
-+	info->port_max_txu[0] = shost->hostt->max_sectors << 9;
-+
-+	/* Send our info to remote */
-+	err = h_copy_rdma(sizeof(*info), vport->liobn, data_token,
-+			  vport->riobn, remote_buffer);
-+
-+	dma_free_coherent(target->dev, sizeof(*info), info, data_token);
-+
-+	if (err != H_Success) {
-+		eprintk("Error sending adapter info %d\n", err);
-+		return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+static void process_login(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct srp_login_rsp *rsp = &iu->srp.login_rsp;
-+	uint64_t tag = iu->srp.rsp.tag;
-+
-+	/* TODO handle case that requested size is wrong and
-+	 * buffer format is wrong
-+	 */
-+	memset(iu, 0, sizeof(struct srp_login_rsp));
-+	rsp->opcode = SRP_LOGIN_RSP;
-+	rsp->req_lim_delta = INITIAL_SRP_LIMIT;
-+	rsp->tag = tag;
-+	rsp->max_it_iu_len = sizeof(union srp_iu);
-+	rsp->max_ti_iu_len = sizeof(union srp_iu);
-+	/* direct and indirect */
-+	rsp->buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
-+
-+	send_iu(iue, sizeof(*rsp), VIOSRP_SRP_FORMAT);
-+}
-+
-+static inline void queue_cmd(struct iu_entry *iue)
-+{
-+	struct srp_target *target = iue->target;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_add_tail(&iue->ilist, &target->cmd_queue);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+}
-+
-+static int process_tsk_mgmt(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int fn;
-+
-+	dprintk("%p %u\n", iue, iu->srp.tsk_mgmt.tsk_mgmt_func);
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		fn = ABORT_TASK;
-+		break;
-+	case SRP_TSK_ABORT_TASK_SET:
-+		fn = ABORT_TASK_SET;
-+		break;
-+	case SRP_TSK_CLEAR_TASK_SET:
-+		fn = CLEAR_TASK_SET;
-+		break;
-+	case SRP_TSK_LUN_RESET:
-+		fn = LOGICAL_UNIT_RESET;
-+		break;
-+	case SRP_TSK_CLEAR_ACA:
-+		fn = CLEAR_ACA;
-+		break;
-+	default:
-+		fn = 0;
-+	}
-+	if (fn)
-+		scsi_tgt_tsk_mgmt_request(iue->target->shost, fn,
-+					  iu->srp.tsk_mgmt.task_tag,
-+					  (struct scsi_lun *) &iu->srp.tsk_mgmt.lun,
-+					  iue);
-+	else
-+		send_rsp(iue, ILLEGAL_REQUEST, 0x20);
-+
-+	return !fn;
-+}
-+
-+static int process_mad_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	struct viosrp_adapter_info *info;
-+	struct viosrp_host_config *conf;
-+
-+	switch (iu->mad.empty_iu.common.type) {
-+	case VIOSRP_EMPTY_IU_TYPE:
-+		eprintk("%s\n", "Unsupported EMPTY MAD IU");
-+		break;
-+	case VIOSRP_ERROR_LOG_TYPE:
-+		eprintk("%s\n", "Unsupported ERROR LOG MAD IU");
-+		iu->mad.error_log.common.status = 1;
-+		send_iu(iue, sizeof(iu->mad.error_log),	VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_ADAPTER_INFO_TYPE:
-+		info = &iu->mad.adapter_info;
-+		info->common.status = send_adapter_info(iue, info->buffer,
-+							info->common.length);
-+		send_iu(iue, sizeof(*info), VIOSRP_MAD_FORMAT);
-+		break;
-+	case VIOSRP_HOST_CONFIG_TYPE:
-+		conf = &iu->mad.host_config;
-+		conf->common.status = 1;
-+		send_iu(iue, sizeof(*conf), VIOSRP_MAD_FORMAT);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", iu->srp.rsp.opcode);
-+	}
-+
-+	return 1;
-+}
-+
-+static int process_srp_iu(struct iu_entry *iue)
-+{
-+	union viosrp_iu *iu = vio_iu(iue);
-+	int done = 1;
-+	u8 opcode = iu->srp.rsp.opcode;
-+
-+	switch (opcode) {
-+	case SRP_LOGIN_REQ:
-+		process_login(iue);
-+		break;
-+	case SRP_TSK_MGMT:
-+		done = process_tsk_mgmt(iue);
-+		break;
-+	case SRP_CMD:
-+		queue_cmd(iue);
-+		done = 0;
-+		break;
-+	case SRP_LOGIN_RSP:
-+	case SRP_I_LOGOUT:
-+	case SRP_T_LOGOUT:
-+	case SRP_RSP:
-+	case SRP_CRED_REQ:
-+	case SRP_CRED_RSP:
-+	case SRP_AER_REQ:
-+	case SRP_AER_RSP:
-+		eprintk("Unsupported type %u\n", opcode);
-+		break;
-+	default:
-+		eprintk("Unknown type %u\n", opcode);
-+	}
-+
-+	return done;
-+}
-+
-+static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct iu_entry *iue;
-+	long err, done;
-+
-+	iue = srp_iu_get(target);
-+	if (!iue) {
-+		eprintk("Error getting IU from pool, %p\n", target);
-+		return;
-+	}
-+
-+	iue->remote_token = crq->IU_data_ptr;
-+
-+	err = h_copy_rdma(crq->IU_length, vport->riobn,
-+			  iue->remote_token, vport->liobn, iue->sbuf->dma);
-+
-+	if (err != H_Success)
-+		eprintk("%ld transferring data error %p\n", err, iue);
-+
-+	if (crq->format == VIOSRP_MAD_FORMAT)
-+		done = process_mad_iu(iue);
-+	else
-+		done = process_srp_iu(iue);
-+
-+	if (done)
-+		srp_iu_put(iue);
-+}
-+
-+static irqreturn_t ibmvstgt_interrupt(int irq, void *data, struct pt_regs *regs)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	vio_disable_interrupts(vport->dma_dev);
-+	queue_work(vtgtd, &vport->crq_work);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int crq_queue_create(struct crq_queue *queue, struct srp_target *target)
-+{
-+	int err;
-+	struct vio_port *vport = target_to_port(target);
-+
-+	queue->msgs = (struct viosrp_crq *) get_zeroed_page(GFP_KERNEL);
-+	if (!queue->msgs)
-+		goto malloc_failed;
-+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
-+
-+	queue->msg_token = dma_map_single(target->dev, queue->msgs,
-+					  queue->size * sizeof(*queue->msgs),
-+					  DMA_BIDIRECTIONAL);
-+
-+	if (dma_mapping_error(queue->msg_token))
-+		goto map_failed;
-+
-+	err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			PAGE_SIZE);
-+
-+	/* If the adapter was left active for some reason (like kexec)
-+	 * try freeing and re-registering
-+	 */
-+	if (err == H_Resource) {
-+	    do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	    } while (err == H_Busy || H_isLongBusy(err));
-+
-+	    err = h_reg_crq(vport->dma_dev->unit_address, queue->msg_token,
-+			    PAGE_SIZE);
-+	}
-+
-+	if (err != H_Success && err != 2) {
-+		eprintk("Error 0x%x opening virtual adapter\n", err);
-+		goto reg_crq_failed;
-+	}
-+
-+	err = request_irq(vport->dma_dev->irq, &ibmvstgt_interrupt,
-+			  SA_INTERRUPT, "ibmvstgt", target);
-+	if (err)
-+		goto req_irq_failed;
-+
-+	vio_enable_interrupts(vport->dma_dev);
-+
-+	h_send_crq(vport->dma_dev->unit_address, 0xC001000000000000, 0);
-+
-+	queue->cur = 0;
-+	spin_lock_init(&queue->lock);
-+
-+	return 0;
-+
-+req_irq_failed:
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_Busy || H_isLongBusy(err));
-+
-+reg_crq_failed:
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+map_failed:
-+	free_page((unsigned long) queue->msgs);
-+
-+malloc_failed:
-+	return -ENOMEM;
-+}
-+
-+static void crq_queue_destroy(struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	struct crq_queue *queue = &vport->crq_queue;
-+	int err;
-+
-+	free_irq(vport->dma_dev->irq, target);
-+	do {
-+		err = h_free_crq(vport->dma_dev->unit_address);
-+	} while (err == H_Busy || H_isLongBusy(err));
-+
-+	dma_unmap_single(target->dev, queue->msg_token,
-+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
-+
-+	free_page((unsigned long) queue->msgs);
-+}
-+
-+static void process_crq(struct viosrp_crq *crq,	struct srp_target *target)
-+{
-+	struct vio_port *vport = target_to_port(target);
-+	dprintk("%x %x\n", crq->valid, crq->format);
-+
-+	switch (crq->valid) {
-+	case 0xC0:
-+		/* initialization */
-+		switch (crq->format) {
-+		case 0x01:
-+			h_send_crq(vport->dma_dev->unit_address,
-+				   0xC002000000000000, 0);
-+			break;
-+		case 0x02:
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	case 0xFF:
-+		/* transport event */
-+		break;
-+	case 0x80:
-+		/* real payload */
-+		switch (crq->format) {
-+		case VIOSRP_SRP_FORMAT:
-+		case VIOSRP_MAD_FORMAT:
-+			process_iu(crq, target);
-+			break;
-+		case VIOSRP_OS400_FORMAT:
-+		case VIOSRP_AIX_FORMAT:
-+		case VIOSRP_LINUX_FORMAT:
-+		case VIOSRP_INLINE_FORMAT:
-+			eprintk("Unsupported format %u\n", crq->format);
-+			break;
-+		default:
-+			eprintk("Unknown format %u\n", crq->format);
-+		}
-+		break;
-+	default:
-+		eprintk("unknown message type 0x%02x!?\n", crq->valid);
-+	}
-+}
-+
-+static inline struct viosrp_crq *next_crq(struct crq_queue *queue)
-+{
-+	struct viosrp_crq *crq;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&queue->lock, flags);
-+	crq = &queue->msgs[queue->cur];
-+	if (crq->valid & 0x80) {
-+		if (++queue->cur == queue->size)
-+			queue->cur = 0;
-+	} else
-+		crq = NULL;
-+	spin_unlock_irqrestore(&queue->lock, flags);
-+
-+	return crq;
-+}
-+
-+static void handle_crq(void *data)
-+{
-+	struct srp_target *target = (struct srp_target *) data;
-+	struct vio_port *vport = target_to_port(target);
-+	struct viosrp_crq *crq;
-+	int done = 0;
-+
-+	while (!done) {
-+		while ((crq = next_crq(&vport->crq_queue)) != NULL) {
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		}
-+
-+		vio_enable_interrupts(vport->dma_dev);
-+
-+		crq = next_crq(&vport->crq_queue);
-+		if (crq) {
-+			vio_disable_interrupts(vport->dma_dev);
-+			process_crq(crq, target);
-+			crq->valid = 0x00;
-+		} else
-+			done = 1;
-+	}
-+
-+	handle_cmd_queue(target);
-+}
-+
-+
-+static int ibmvstgt_eh_abort_handler(struct scsi_cmnd *scmd)
-+{
-+	unsigned long flags;
-+	struct iu_entry *iue = (struct iu_entry *) scmd->SCp.ptr;
-+	struct srp_target *target = iue->target;
-+
-+	dprintk("%p %p %x\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0]);
-+
-+	spin_lock_irqsave(&target->lock, flags);
-+	list_del(&iue->ilist);
-+	spin_unlock_irqrestore(&target->lock, flags);
-+
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_tsk_mgmt_response(u64 mid, int result)
-+{
-+	struct iu_entry *iue = (struct iu_entry *) ((void *) mid);
-+	union viosrp_iu *iu = vio_iu(iue);
-+	unsigned char status, asc;
-+
-+	eprintk("%p %d\n", iue, result);
-+	status = NO_SENSE;
-+	asc = 0;
-+
-+	switch (iu->srp.tsk_mgmt.tsk_mgmt_func) {
-+	case SRP_TSK_ABORT_TASK:
-+		asc = 0x14;
-+		if (result)
-+			status = ABORTED_COMMAND;
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	send_rsp(iue, status, asc);
-+	srp_iu_put(iue);
-+
-+	return 0;
-+}
-+
-+static ssize_t system_id_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%s\n", system_id);
-+}
-+
-+static ssize_t partition_number_show(struct class_device *cdev, char *buf)
-+{
-+	return snprintf(buf, PAGE_SIZE, "%x\n", partition_number);
-+}
-+
-+static ssize_t unit_address_show(struct class_device *cdev, char *buf)
-+{
-+	struct Scsi_Host *shost = class_to_shost(cdev);
-+	struct srp_target *target = host_to_target(shost);
-+	struct vio_port *vport = target_to_port(target);
-+	return snprintf(buf, PAGE_SIZE, "%x\n", vport->dma_dev->unit_address);
-+}
-+
-+static CLASS_DEVICE_ATTR(system_id, S_IRUGO, system_id_show, NULL);
-+static CLASS_DEVICE_ATTR(partition_number, S_IRUGO, partition_number_show, NULL);
-+static CLASS_DEVICE_ATTR(unit_address, S_IRUGO, unit_address_show, NULL);
-+
-+static struct class_device_attribute *ibmvstgt_attrs[] = {
-+	&class_device_attr_system_id,
-+	&class_device_attr_partition_number,
-+	&class_device_attr_unit_address,
-+	NULL,
-+};
-+
-+static struct scsi_host_template ibmvstgt_sht = {
-+	.name			= TGT_NAME,
-+	.module			= THIS_MODULE,
-+	.can_queue		= INITIAL_SRP_LIMIT,
-+	.sg_tablesize		= SG_ALL,
-+	.use_clustering		= DISABLE_CLUSTERING,
-+	.max_sectors		= DEFAULT_MAX_SECTORS,
-+	.transfer_response	= ibmvstgt_cmd_done,
-+	.transfer_data		= ibmvstgt_transfer_data,
-+	.eh_abort_handler	= ibmvstgt_eh_abort_handler,
-+	.tsk_mgmt_response	= ibmvstgt_tsk_mgmt_response,
-+	.shost_attrs		= ibmvstgt_attrs,
-+	.proc_name		= TGT_NAME,
-+};
-+
-+static int ibmvstgt_probe(struct vio_dev *dev, const struct vio_device_id *id)
-+{
-+	struct Scsi_Host *shost;
-+	struct srp_target *target;
-+	struct vio_port *vport;
-+	unsigned int *dma, dma_size;
-+	int err = -ENOMEM;
-+
-+	vport = kzalloc(sizeof(struct vio_port), GFP_KERNEL);
-+	if (!vport)
-+		return err;
-+	shost = scsi_host_alloc(&ibmvstgt_sht, sizeof(struct srp_target));
-+	if (!shost)
-+		goto free_vport;
-+	err = scsi_tgt_alloc_queue(shost);
-+	if (err)
-+		goto put_host;
-+
-+	target = host_to_target(shost);
-+	target->shost = shost;
-+	vport->dma_dev = dev;
-+	target->ldata = vport;
-+	err = srp_target_alloc(target, &dev->dev, INITIAL_SRP_LIMIT,
-+			       SRP_MAX_IU_LEN);
-+	if (err)
-+		goto put_host;
-+
-+	dma = (unsigned int *) vio_get_attribute(dev, "ibm,my-dma-window",
-+						 &dma_size);
-+	if (!dma || dma_size != 40) {
-+		eprintk("Couldn't get window property %d\n", dma_size);
-+		err = -EIO;
-+		goto free_srp_target;
-+	}
-+	vport->liobn = dma[0];
-+	vport->riobn = dma[5];
-+
-+	INIT_WORK(&vport->crq_work, handle_crq, target);
-+
-+	err = crq_queue_create(&vport->crq_queue, target);
-+	if (err)
-+		goto free_srp_target;
-+
-+	err = scsi_add_host(shost, target->dev);
-+	if (err)
-+		goto destroy_queue;
-+	return 0;
-+
-+destroy_queue:
-+	crq_queue_destroy(target);
-+free_srp_target:
-+	srp_target_free(target);
-+put_host:
-+	scsi_host_put(shost);
-+free_vport:
-+	kfree(vport);
-+	return err;
-+}
-+
-+static int ibmvstgt_remove(struct vio_dev *dev)
-+{
-+	struct srp_target *target = (struct srp_target *) dev->dev.driver_data;
-+	struct Scsi_Host *shost = target->shost;
-+
-+	srp_target_free(target);
-+	crq_queue_destroy(target);
-+	scsi_remove_host(shost);
-+	scsi_host_put(shost);
-+	return 0;
-+}
-+
-+static struct vio_device_id ibmvstgt_device_table[] __devinitdata = {
-+	{"v-scsi-host", "IBM,v-scsi-host"},
-+	{"",""}
-+};
-+
-+MODULE_DEVICE_TABLE(vio, ibmvstgt_device_table);
-+
-+static struct vio_driver ibmvstgt_driver = {
-+	.id_table = ibmvstgt_device_table,
-+	.probe = ibmvstgt_probe,
-+	.remove = ibmvstgt_remove,
-+	.driver = {
-+		.name = "ibmvscsi",
-+		.owner = THIS_MODULE,
-+	}
-+};
-+
-+static int get_system_info(void)
-+{
-+	struct device_node *rootdn;
-+	char *id, *model, *name;
-+	unsigned int *num;
-+
-+	rootdn = find_path_device("/");
-+	if (!rootdn)
-+		return -ENOENT;
-+
-+	model = get_property(rootdn, "model", NULL);
-+	id = get_property(rootdn, "system-id", NULL);
-+	if (model && id)
-+		snprintf(system_id, sizeof(system_id), "%s-%s", model, id);
-+
-+	name = get_property(rootdn, "ibm,partition-name", NULL);
-+	if (name)
-+		strncpy(partition_name, name, sizeof(partition_name));
-+
-+	num = (unsigned int *) get_property(rootdn, "ibm,partition-no", NULL);
-+	if (num)
-+		partition_number = *num;
-+
-+	return 0;
-+}
-+
-+static int ibmvstgt_init(void)
-+{
-+	int err = -ENOMEM;
-+
-+	printk("IBM eServer i/pSeries Virtual SCSI Target Driver\n");
-+
-+	vtgtd = create_workqueue("ibmvtgtd");
-+	if (!vtgtd)
-+		return err;
-+
-+	err = get_system_info();
-+	if (err)
-+		goto destroy_wq;
-+
-+	err = vio_register_driver(&ibmvstgt_driver);
-+	if (err)
-+		goto destroy_wq;
-+
-+	return 0;
-+
-+destroy_wq:
-+	destroy_workqueue(vtgtd);
-+	return err;
-+}
-+
-+static void ibmvstgt_exit(void)
-+{
-+	printk("Unregister IBM virtual SCSI driver\n");
-+
-+	destroy_workqueue(vtgtd);
-+	vio_unregister_driver(&ibmvstgt_driver);
-+}
-+
-+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
-+MODULE_AUTHOR("Dave Boutcher");
-+MODULE_LICENSE("GPL");
-+
-+module_init(ibmvstgt_init);
-+module_exit(ibmvstgt_exit);
--- 
-1.1.3

Deleted: branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff
===================================================================
--- branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff	2006-06-21 12:32:30 UTC (rev 488)
+++ branches/use-scsi-ml/patchset/scsi-target-2.6-tree.diff	2006-06-22 11:52:47 UTC (rev 489)
@@ -1,801 +0,0 @@
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.c b/drivers/scsi/ibmvscsi/ibmvscsi.c
-index eaefedd..e7bd028 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.c
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.c
-@@ -168,7 +168,7 @@ static void release_event_pool(struct ev
- 			++in_use;
- 		if (pool->events[i].ext_list) {
- 			dma_free_coherent(hostdata->dev,
--				  SG_ALL * sizeof(struct memory_descriptor),
-+				  SG_ALL * sizeof(struct srp_direct_buf),
- 				  pool->events[i].ext_list,
- 				  pool->events[i].ext_list_token);
- 		}
-@@ -284,40 +284,37 @@ static void set_srp_direction(struct scs
- 			      struct srp_cmd *srp_cmd, 
- 			      int numbuf)
- {
-+	u8 fmt;
-+
- 	if (numbuf == 0)
- 		return;
- 	
--	if (numbuf == 1) {
-+	if (numbuf == 1)
-+		fmt = SRP_DATA_DESC_DIRECT;
-+	else {
-+		fmt = SRP_DATA_DESC_INDIRECT;
-+		numbuf = min(numbuf, MAX_INDIRECT_BUFS);
-+
- 		if (cmd->sc_data_direction == DMA_TO_DEVICE)
--			srp_cmd->data_out_format = SRP_DIRECT_BUFFER;
--		else 
--			srp_cmd->data_in_format = SRP_DIRECT_BUFFER;
--	} else {
--		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
--			srp_cmd->data_out_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_out_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		} else {
--			srp_cmd->data_in_format = SRP_INDIRECT_BUFFER;
--			srp_cmd->data_in_count =
--				numbuf < MAX_INDIRECT_BUFS ?
--					numbuf: MAX_INDIRECT_BUFS;
--		}
-+			srp_cmd->data_out_desc_cnt = numbuf;
-+		else
-+			srp_cmd->data_in_desc_cnt = numbuf;
- 	}
-+
-+	if (cmd->sc_data_direction == DMA_TO_DEVICE)
-+		srp_cmd->buf_fmt = fmt << 4;
-+	else
-+		srp_cmd->buf_fmt = fmt;
- }
- 
--static void unmap_sg_list(int num_entries, 
-+static void unmap_sg_list(int num_entries,
- 		struct device *dev,
--		struct memory_descriptor *md)
--{ 
-+		struct srp_direct_buf *md)
-+{
- 	int i;
- 
--	for (i = 0; i < num_entries; ++i) {
--		dma_unmap_single(dev,
--			md[i].virtual_address,
--			md[i].length, DMA_BIDIRECTIONAL);
--	}
-+	for (i = 0; i < num_entries; ++i)
-+		dma_unmap_single(dev, md[i].va, md[i].len, DMA_BIDIRECTIONAL);
- }
- 
- /**
-@@ -330,23 +327,26 @@ static void unmap_cmd_data(struct srp_cm
- 			   struct srp_event_struct *evt_struct,
- 			   struct device *dev)
- {
--	if ((cmd->data_out_format == SRP_NO_BUFFER) &&
--	    (cmd->data_in_format == SRP_NO_BUFFER))
-+	u8 out_fmt, in_fmt;
-+
-+	out_fmt = cmd->buf_fmt >> 4;
-+	in_fmt = cmd->buf_fmt & ((1U << 4) - 1);
-+
-+	if (out_fmt == SRP_NO_DATA_DESC && in_fmt == SRP_NO_DATA_DESC)
- 		return;
--	else if ((cmd->data_out_format == SRP_DIRECT_BUFFER) ||
--		 (cmd->data_in_format == SRP_DIRECT_BUFFER)) {
--		struct memory_descriptor *data =
--			(struct memory_descriptor *)cmd->additional_data;
--		dma_unmap_single(dev, data->virtual_address, data->length,
--				 DMA_BIDIRECTIONAL);
-+	else if (out_fmt == SRP_DATA_DESC_DIRECT ||
-+		 in_fmt == SRP_DATA_DESC_DIRECT) {
-+		struct srp_direct_buf *data =
-+			(struct srp_direct_buf *) cmd->add_data;
-+		dma_unmap_single(dev, data->va, data->len, DMA_BIDIRECTIONAL);
- 	} else {
--		struct indirect_descriptor *indirect =
--			(struct indirect_descriptor *)cmd->additional_data;
--		int num_mapped = indirect->head.length / 
--			sizeof(indirect->list[0]);
-+		struct srp_indirect_buf *indirect =
-+			(struct srp_indirect_buf *) cmd->add_data;
-+		int num_mapped = indirect->table_desc.len /
-+			sizeof(struct srp_direct_buf);
- 
- 		if (num_mapped <= MAX_INDIRECT_BUFS) {
--			unmap_sg_list(num_mapped, dev, &indirect->list[0]);
-+			unmap_sg_list(num_mapped, dev, &indirect->desc_list[0]);
- 			return;
- 		}
- 
-@@ -356,17 +356,17 @@ static void unmap_cmd_data(struct srp_cm
- 
- static int map_sg_list(int num_entries, 
- 		       struct scatterlist *sg,
--		       struct memory_descriptor *md)
-+		       struct srp_direct_buf *md)
- {
- 	int i;
- 	u64 total_length = 0;
- 
- 	for (i = 0; i < num_entries; ++i) {
--		struct memory_descriptor *descr = md + i;
-+		struct srp_direct_buf *descr = md + i;
- 		struct scatterlist *sg_entry = &sg[i];
--		descr->virtual_address = sg_dma_address(sg_entry);
--		descr->length = sg_dma_len(sg_entry);
--		descr->memory_handle = 0;
-+		descr->va = sg_dma_address(sg_entry);
-+		descr->len = sg_dma_len(sg_entry);
-+		descr->key = 0;
- 		total_length += sg_dma_len(sg_entry);
-  	}
- 	return total_length;
-@@ -389,10 +389,10 @@ static int map_sg_data(struct scsi_cmnd 
- 	int sg_mapped;
- 	u64 total_length = 0;
- 	struct scatterlist *sg = cmd->request_buffer;
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
--	struct indirect_descriptor *indirect =
--	    (struct indirect_descriptor *)data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
-+	struct srp_indirect_buf *indirect =
-+		(struct srp_indirect_buf *) data;
- 
- 	sg_mapped = dma_map_sg(dev, sg, cmd->use_sg, DMA_BIDIRECTIONAL);
- 
-@@ -403,9 +403,9 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	/* special case; we can use a single direct descriptor */
- 	if (sg_mapped == 1) {
--		data->virtual_address = sg_dma_address(&sg[0]);
--		data->length = sg_dma_len(&sg[0]);
--		data->memory_handle = 0;
-+		data->va = sg_dma_address(&sg[0]);
-+		data->len = sg_dma_len(&sg[0]);
-+		data->key = 0;
- 		return 1;
- 	}
- 
-@@ -416,25 +416,26 @@ static int map_sg_data(struct scsi_cmnd 
- 		return 0;
- 	}
- 
--	indirect->head.virtual_address = 0;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	indirect->head.memory_handle = 0;
-+	indirect->table_desc.va = 0;
-+	indirect->table_desc.len = sg_mapped * sizeof(struct srp_direct_buf);
-+	indirect->table_desc.key = 0;
- 
- 	if (sg_mapped <= MAX_INDIRECT_BUFS) {
--		total_length = map_sg_list(sg_mapped, sg, &indirect->list[0]);
--		indirect->total_length = total_length;
-+		total_length = map_sg_list(sg_mapped, sg,
-+					   &indirect->desc_list[0]);
-+		indirect->len = total_length;
- 		return 1;
- 	}
- 
- 	/* get indirect table */
- 	if (!evt_struct->ext_list) {
--		evt_struct->ext_list =(struct memory_descriptor*)
-+		evt_struct->ext_list = (struct srp_direct_buf *)
- 			dma_alloc_coherent(dev, 
--				SG_ALL * sizeof(struct memory_descriptor),
--				&evt_struct->ext_list_token, 0);
-+					   SG_ALL * sizeof(struct srp_direct_buf),
-+					   &evt_struct->ext_list_token, 0);
- 		if (!evt_struct->ext_list) {
--		    printk(KERN_ERR
--		   	"ibmvscsi: Can't allocate memory for indirect table\n");
-+			printk(KERN_ERR
-+			       "ibmvscsi: Can't allocate memory for indirect table\n");
- 			return 0;
- 			
- 		}
-@@ -442,11 +443,11 @@ static int map_sg_data(struct scsi_cmnd 
- 
- 	total_length = map_sg_list(sg_mapped, sg, evt_struct->ext_list);	
- 
--	indirect->total_length = total_length;
--	indirect->head.virtual_address = evt_struct->ext_list_token;
--	indirect->head.length = sg_mapped * sizeof(indirect->list[0]);
--	memcpy(indirect->list, evt_struct->ext_list,
--		MAX_INDIRECT_BUFS * sizeof(struct memory_descriptor));
-+	indirect->len = total_length;
-+	indirect->table_desc.va = evt_struct->ext_list_token;
-+	indirect->table_desc.len = sg_mapped * sizeof(indirect->desc_list[0]);
-+	memcpy(indirect->desc_list, evt_struct->ext_list,
-+	       MAX_INDIRECT_BUFS * sizeof(struct srp_direct_buf));
- 	
-  	return 1;
- }
-@@ -463,20 +464,20 @@ static int map_sg_data(struct scsi_cmnd 
- static int map_single_data(struct scsi_cmnd *cmd,
- 			   struct srp_cmd *srp_cmd, struct device *dev)
- {
--	struct memory_descriptor *data =
--	    (struct memory_descriptor *)srp_cmd->additional_data;
-+	struct srp_direct_buf *data =
-+		(struct srp_direct_buf *) srp_cmd->add_data;
- 
--	data->virtual_address =
-+	data->va =
- 		dma_map_single(dev, cmd->request_buffer,
- 			       cmd->request_bufflen,
- 			       DMA_BIDIRECTIONAL);
--	if (dma_mapping_error(data->virtual_address)) {
-+	if (dma_mapping_error(data->va)) {
- 		printk(KERN_ERR
- 		       "ibmvscsi: Unable to map request_buffer for command!\n");
- 		return 0;
- 	}
--	data->length = cmd->request_bufflen;
--	data->memory_handle = 0;
-+	data->len = cmd->request_bufflen;
-+	data->key = 0;
- 
- 	set_srp_direction(cmd, srp_cmd, 1);
- 
-@@ -548,7 +549,7 @@ static int ibmvscsi_send_srp_event(struc
- 
- 	/* Copy the IU into the transfer area */
- 	*evt_struct->xfer_iu = evt_struct->iu;
--	evt_struct->xfer_iu->srp.generic.tag = (u64)evt_struct;
-+	evt_struct->xfer_iu->srp.rsp.tag = (u64)evt_struct;
- 
- 	/* Add this to the sent list.  We need to do this 
- 	 * before we actually send 
-@@ -586,27 +587,27 @@ static void handle_cmd_rsp(struct srp_ev
- 	struct srp_rsp *rsp = &evt_struct->xfer_iu->srp.rsp;
- 	struct scsi_cmnd *cmnd = evt_struct->cmnd;
- 
--	if (unlikely(rsp->type != SRP_RSP_TYPE)) {
-+	if (unlikely(rsp->opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: bad SRP RSP type %d\n",
--			       rsp->type);
-+			       rsp->opcode);
- 	}
- 	
- 	if (cmnd) {
- 		cmnd->result = rsp->status;
- 		if (((cmnd->result >> 1) & 0x1f) == CHECK_CONDITION)
- 			memcpy(cmnd->sense_buffer,
--			       rsp->sense_and_response_data,
--			       rsp->sense_data_list_length);
-+			       rsp->data,
-+			       rsp->sense_data_len);
- 		unmap_cmd_data(&evt_struct->iu.srp.cmd, 
- 			       evt_struct, 
- 			       evt_struct->hostdata->dev);
- 
--		if (rsp->doover)
--			cmnd->resid = rsp->data_out_residual_count;
--		else if (rsp->diover)
--			cmnd->resid = rsp->data_in_residual_count;
-+		if (rsp->flags & SRP_RSP_FLAG_DOOVER)
-+			cmnd->resid = rsp->data_out_res_cnt;
-+		else if (rsp->flags & SRP_RSP_FLAG_DIOVER)
-+			cmnd->resid = rsp->data_in_res_cnt;
- 	}
- 
- 	if (evt_struct->cmnd_done)
-@@ -633,10 +634,11 @@ static int ibmvscsi_queuecommand(struct 
- {
- 	struct srp_cmd *srp_cmd;
- 	struct srp_event_struct *evt_struct;
--	struct indirect_descriptor *indirect;
-+	struct srp_indirect_buf *indirect;
- 	struct ibmvscsi_host_data *hostdata =
- 		(struct ibmvscsi_host_data *)&cmnd->device->host->hostdata;
- 	u16 lun = lun_from_dev(cmnd->device);
-+	u8 out_fmt, in_fmt;
- 
- 	evt_struct = get_event_struct(&hostdata->pool);
- 	if (!evt_struct)
-@@ -644,8 +646,8 @@ static int ibmvscsi_queuecommand(struct 
- 
- 	/* Set up the actual SRP IU */
- 	srp_cmd = &evt_struct->iu.srp.cmd;
--	memset(srp_cmd, 0x00, sizeof(*srp_cmd));
--	srp_cmd->type = SRP_CMD_TYPE;
-+	memset(srp_cmd, 0x00, SRP_MAX_IU_LEN);
-+	srp_cmd->opcode = SRP_CMD;
- 	memcpy(srp_cmd->cdb, cmnd->cmnd, sizeof(cmnd->cmnd));
- 	srp_cmd->lun = ((u64) lun) << 48;
- 
-@@ -664,13 +666,15 @@ static int ibmvscsi_queuecommand(struct 
- 	evt_struct->cmnd_done = done;
- 
- 	/* Fix up dma address of the buffer itself */
--	indirect = (struct indirect_descriptor *)srp_cmd->additional_data;
--	if (((srp_cmd->data_out_format == SRP_INDIRECT_BUFFER) ||
--	    (srp_cmd->data_in_format == SRP_INDIRECT_BUFFER)) &&
--	    (indirect->head.virtual_address == 0)) {
--		indirect->head.virtual_address = evt_struct->crq.IU_data_ptr +
--		    offsetof(struct srp_cmd, additional_data) +
--		    offsetof(struct indirect_descriptor, list);
-+	indirect = (struct srp_indirect_buf *) srp_cmd->add_data;
-+	out_fmt = srp_cmd->buf_fmt >> 4;
-+	in_fmt = srp_cmd->buf_fmt & ((1U << 4) - 1);
-+	if ((in_fmt == SRP_DATA_DESC_INDIRECT ||
-+	     out_fmt == SRP_DATA_DESC_INDIRECT) &&
-+	    indirect->table_desc.va == 0) {
-+		indirect->table_desc.va = evt_struct->crq.IU_data_ptr +
-+			offsetof(struct srp_cmd, add_data) +
-+			offsetof(struct srp_indirect_buf, desc_list);
- 	}
- 
- 	return ibmvscsi_send_srp_event(evt_struct, hostdata);
-@@ -780,10 +784,10 @@ static void send_mad_adapter_info(struct
- static void login_rsp(struct srp_event_struct *evt_struct)
- {
- 	struct ibmvscsi_host_data *hostdata = evt_struct->hostdata;
--	switch (evt_struct->xfer_iu->srp.generic.type) {
--	case SRP_LOGIN_RSP_TYPE:	/* it worked! */
-+	switch (evt_struct->xfer_iu->srp.login_rsp.opcode) {
-+	case SRP_LOGIN_RSP:	/* it worked! */
- 		break;
--	case SRP_LOGIN_REJ_TYPE:	/* refused! */
-+	case SRP_LOGIN_REJ:	/* refused! */
- 		printk(KERN_INFO "ibmvscsi: SRP_LOGIN_REJ reason %u\n",
- 		       evt_struct->xfer_iu->srp.login_rej.reason);
- 		/* Login failed.  */
-@@ -792,7 +796,7 @@ static void login_rsp(struct srp_event_s
- 	default:
- 		printk(KERN_ERR
- 		       "ibmvscsi: Invalid login response typecode 0x%02x!\n",
--		       evt_struct->xfer_iu->srp.generic.type);
-+		       evt_struct->xfer_iu->srp.login_rsp.opcode);
- 		/* Login failed.  */
- 		atomic_set(&hostdata->request_limit, -1);
- 		return;
-@@ -800,17 +804,17 @@ static void login_rsp(struct srp_event_s
- 
- 	printk(KERN_INFO "ibmvscsi: SRP_LOGIN succeeded\n");
- 
--	if (evt_struct->xfer_iu->srp.login_rsp.request_limit_delta >
-+	if (evt_struct->xfer_iu->srp.login_rsp.req_lim_delta >
- 	    (max_requests - 2))
--		evt_struct->xfer_iu->srp.login_rsp.request_limit_delta =
-+		evt_struct->xfer_iu->srp.login_rsp.req_lim_delta =
- 		    max_requests - 2;
- 
- 	/* Now we know what the real request-limit is */
- 	atomic_set(&hostdata->request_limit,
--		   evt_struct->xfer_iu->srp.login_rsp.request_limit_delta);
-+		   evt_struct->xfer_iu->srp.login_rsp.req_lim_delta);
- 
- 	hostdata->host->can_queue =
--	    evt_struct->xfer_iu->srp.login_rsp.request_limit_delta - 2;
-+	    evt_struct->xfer_iu->srp.login_rsp.req_lim_delta - 2;
- 
- 	if (hostdata->host->can_queue < 1) {
- 		printk(KERN_ERR "ibmvscsi: Invalid request_limit_delta\n");
-@@ -849,9 +853,9 @@ static int send_srp_login(struct ibmvscs
- 
- 	login = &evt_struct->iu.srp.login_req;
- 	memset(login, 0x00, sizeof(struct srp_login_req));
--	login->type = SRP_LOGIN_REQ_TYPE;
--	login->max_requested_initiator_to_target_iulen = sizeof(union srp_iu);
--	login->required_buffer_formats = 0x0006;
-+	login->opcode = SRP_LOGIN_REQ;
-+	login->req_it_iu_len = sizeof(union srp_iu);
-+	login->req_buf_fmt = SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT;
- 	
- 	/* Start out with a request limit of 1, since this is negotiated in
- 	 * the login request we are just sending
-@@ -928,13 +932,13 @@ static int ibmvscsi_eh_abort_handler(str
- 	
- 	/* Set up an abort SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x01;	/* ABORT TASK */
--	tsk_mgmt->managed_task_tag = (u64) found_evt;
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_ABORT_TASK;
-+	tsk_mgmt->task_tag = (u64) found_evt;
- 
- 	printk(KERN_INFO "ibmvscsi: aborting command. lun 0x%lx, tag 0x%lx\n",
--	       tsk_mgmt->lun, tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->lun, tsk_mgmt->task_tag);
- 
- 	evt->sync_srp = &srp_rsp;
- 	init_completion(&evt->comp);
-@@ -948,25 +952,25 @@ static int ibmvscsi_eh_abort_handler(str
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: abort bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
- 	if (rsp_rc) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
--		       "ibmvscsi: abort code %d for task tag 0x%lx\n",
-+			       "ibmvscsi: abort code %d for task tag 0x%lx\n",
- 			       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -987,13 +991,13 @@ static int ibmvscsi_eh_abort_handler(str
- 		spin_unlock_irqrestore(hostdata->host->host_lock, flags);
- 		printk(KERN_INFO
- 		       "ibmvscsi: aborted task tag 0x%lx completed\n",
--		       tsk_mgmt->managed_task_tag);
-+		       tsk_mgmt->task_tag);
- 		return SUCCESS;
- 	}
- 
- 	printk(KERN_INFO
- 	       "ibmvscsi: successfully aborted task tag 0x%lx\n",
--	       tsk_mgmt->managed_task_tag);
-+	       tsk_mgmt->task_tag);
- 
- 	cmd->result = (DID_ABORT << 16);
- 	list_del(&found_evt->list);
-@@ -1040,9 +1044,9 @@ static int ibmvscsi_eh_device_reset_hand
- 
- 	/* Set up a lun reset SRP command */
- 	memset(tsk_mgmt, 0x00, sizeof(*tsk_mgmt));
--	tsk_mgmt->type = SRP_TSK_MGMT_TYPE;
-+	tsk_mgmt->opcode = SRP_TSK_MGMT;
- 	tsk_mgmt->lun = ((u64) lun) << 48;
--	tsk_mgmt->task_mgmt_flags = 0x08;	/* LUN RESET */
-+	tsk_mgmt->tsk_mgmt_func = SRP_TSK_LUN_RESET;
- 
- 	printk(KERN_INFO "ibmvscsi: resetting device. lun 0x%lx\n",
- 	       tsk_mgmt->lun);
-@@ -1059,16 +1063,16 @@ static int ibmvscsi_eh_device_reset_hand
- 	wait_for_completion(&evt->comp);
- 
- 	/* make sure we got a good response */
--	if (unlikely(srp_rsp.srp.generic.type != SRP_RSP_TYPE)) {
-+	if (unlikely(srp_rsp.srp.rsp.opcode != SRP_RSP)) {
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset bad SRP RSP type %d\n",
--			       srp_rsp.srp.generic.type);
-+			       srp_rsp.srp.rsp.opcode);
- 		return FAILED;
- 	}
- 
--	if (srp_rsp.srp.rsp.rspvalid)
--		rsp_rc = *((int *)srp_rsp.srp.rsp.sense_and_response_data);
-+	if (srp_rsp.srp.rsp.flags & SRP_RSP_FLAG_RSPVALID)
-+		rsp_rc = *((int *)srp_rsp.srp.rsp.data);
- 	else
- 		rsp_rc = srp_rsp.srp.rsp.status;
- 
-@@ -1076,8 +1080,7 @@ static int ibmvscsi_eh_device_reset_hand
- 		if (printk_ratelimit())
- 			printk(KERN_WARNING 
- 			       "ibmvscsi: reset code %d for task tag 0x%lx\n",
--		       rsp_rc,
--			       tsk_mgmt->managed_task_tag);
-+			       rsp_rc, tsk_mgmt->task_tag);
- 		return FAILED;
- 	}
- 
-@@ -1226,7 +1229,7 @@ void ibmvscsi_handle_crq(struct viosrp_c
- 	}
- 
- 	if (crq->format == VIOSRP_SRP_FORMAT)
--		atomic_add(evt_struct->xfer_iu->srp.rsp.request_limit_delta,
-+		atomic_add(evt_struct->xfer_iu->srp.rsp.req_lim_delta,
- 			   &hostdata->request_limit);
- 
- 	if (evt_struct->done)
-diff --git a/drivers/scsi/ibmvscsi/ibmvscsi.h b/drivers/scsi/ibmvscsi/ibmvscsi.h
-index 4550d71..5c6d935 100644
---- a/drivers/scsi/ibmvscsi/ibmvscsi.h
-+++ b/drivers/scsi/ibmvscsi/ibmvscsi.h
-@@ -68,7 +68,7 @@ struct srp_event_struct {
- 	void (*cmnd_done) (struct scsi_cmnd *);
- 	struct completion comp;
- 	union viosrp_iu *sync_srp;
--	struct memory_descriptor *ext_list;
-+	struct srp_direct_buf *ext_list;
- 	dma_addr_t ext_list_token;
- };
- 
-diff --git a/drivers/scsi/ibmvscsi/rpa_vscsi.c b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-index f47dd87..58aa530 100644
---- a/drivers/scsi/ibmvscsi/rpa_vscsi.c
-+++ b/drivers/scsi/ibmvscsi/rpa_vscsi.c
-@@ -34,7 +34,6 @@
- #include <linux/dma-mapping.h>
- #include <linux/interrupt.h>
- #include "ibmvscsi.h"
--#include "srp.h"
- 
- static char partition_name[97] = "UNKNOWN";
- static unsigned int partition_number = -1;
-diff --git a/drivers/scsi/ibmvscsi/srp.h b/drivers/scsi/ibmvscsi/srp.h
-deleted file mode 100644
-index 7d8e4c4..0000000
---- a/drivers/scsi/ibmvscsi/srp.h
-+++ /dev/null
-@@ -1,227 +0,0 @@
--/*****************************************************************************/
--/* srp.h -- SCSI RDMA Protocol definitions                                   */
--/*                                                                           */
--/* Written By: Colin Devilbis, IBM Corporation                               */
--/*                                                                           */
--/* Copyright (C) 2003 IBM Corporation                                        */
--/*                                                                           */
--/* This program is free software; you can redistribute it and/or modify      */
--/* it under the terms of the GNU General Public License as published by      */
--/* the Free Software Foundation; either version 2 of the License, or         */
--/* (at your option) any later version.                                       */
--/*                                                                           */
--/* This program is distributed in the hope that it will be useful,           */
--/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
--/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             */
--/* GNU General Public License for more details.                              */
--/*                                                                           */
--/* You should have received a copy of the GNU General Public License         */
--/* along with this program; if not, write to the Free Software               */
--/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
--/*                                                                           */
--/*                                                                           */
--/* This file contains structures and definitions for the SCSI RDMA Protocol  */
--/* (SRP) as defined in the T10 standard available at www.t10.org.  This      */
--/* file was based on the 16a version of the standard                         */
--/*                                                                           */
--/*****************************************************************************/
--#ifndef SRP_H
--#define SRP_H
--
--#define SRP_VERSION "16.a"
--
--#define PACKED __attribute__((packed))
--
--enum srp_types {
--	SRP_LOGIN_REQ_TYPE = 0x00,
--	SRP_LOGIN_RSP_TYPE = 0xC0,
--	SRP_LOGIN_REJ_TYPE = 0xC2,
--	SRP_I_LOGOUT_TYPE = 0x03,
--	SRP_T_LOGOUT_TYPE = 0x80,
--	SRP_TSK_MGMT_TYPE = 0x01,
--	SRP_CMD_TYPE = 0x02,
--	SRP_RSP_TYPE = 0xC1,
--	SRP_CRED_REQ_TYPE = 0x81,
--	SRP_CRED_RSP_TYPE = 0x41,
--	SRP_AER_REQ_TYPE = 0x82,
--	SRP_AER_RSP_TYPE = 0x42
--};
--
--enum srp_descriptor_formats {
--	SRP_NO_BUFFER = 0x00,
--	SRP_DIRECT_BUFFER = 0x01,
--	SRP_INDIRECT_BUFFER = 0x02
--};
--
--struct memory_descriptor {
--	u64 virtual_address;
--	u32 memory_handle;
--	u32 length;
--};
--
--struct indirect_descriptor {
--	struct memory_descriptor head;
--	u32 total_length;
--	struct memory_descriptor list[1] PACKED;
--};
--
--struct srp_generic {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_login_req {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 max_requested_initiator_to_target_iulen;
--	u32 reserved2;
--	u16 required_buffer_formats;
--	u8 reserved3:6;
--	u8 multi_channel_action:2;
--	u8 reserved4;
--	u32 reserved5;
--	u8 initiator_port_identifier[16];
--	u8 target_port_identifier[16];
--};
--
--struct srp_login_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 max_initiator_to_target_iulen;
--	u32 max_target_to_initiator_iulen;
--	u16 supported_buffer_formats;
--	u8 reserved2:6;
--	u8 multi_channel_result:2;
--	u8 reserved3;
--	u8 reserved4[24];
--};
--
--struct srp_login_rej {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--	u64 reserved2;
--	u16 supported_buffer_formats;
--	u8 reserved3[6];
--};
--
--struct srp_i_logout {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_t_logout {
--	u8 type;
--	u8 reserved1[3];
--	u32 reason;
--	u64 tag;
--};
--
--struct srp_tsk_mgmt {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4;
--	u8 task_mgmt_flags;
--	u8 reserved5;
--	u64 managed_task_tag;
--	u64 reserved6;
--};
--
--struct srp_cmd {
--	u8 type;
--	u32 reserved1 PACKED;
--	u8 data_out_format:4;
--	u8 data_in_format:4;
--	u8 data_out_count;
--	u8 data_in_count;
--	u64 tag;
--	u32 reserved2;
--	u64 lun PACKED;
--	u8 reserved3;
--	u8 reserved4:5;
--	u8 task_attribute:3;
--	u8 reserved5;
--	u8 additional_cdb_len;
--	u8 cdb[16];
--	u8 additional_data[0x100 - 0x30];
--};
--
--struct srp_rsp {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u16 reserved2;
--	u8 reserved3:2;
--	u8 diunder:1;
--	u8 diover:1;
--	u8 dounder:1;
--	u8 doover:1;
--	u8 snsvalid:1;
--	u8 rspvalid:1;
--	u8 status;
--	u32 data_in_residual_count;
--	u32 data_out_residual_count;
--	u32 sense_data_list_length;
--	u32 response_data_list_length;
--	u8 sense_and_response_data[18];
--};
--
--struct srp_cred_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--};
--
--struct srp_cred_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--struct srp_aer_req {
--	u8 type;
--	u8 reserved1[3];
--	u32 request_limit_delta;
--	u64 tag;
--	u32 reserved2;
--	u64 lun;
--	u32 sense_data_list_length;
--	u32 reserved3;
--	u8 sense_data[20];
--};
--
--struct srp_aer_rsp {
--	u8 type;
--	u8 reserved1[7];
--	u64 tag;
--};
--
--union srp_iu {
--	struct srp_generic generic;
--	struct srp_login_req login_req;
--	struct srp_login_rsp login_rsp;
--	struct srp_login_rej login_rej;
--	struct srp_i_logout i_logout;
--	struct srp_t_logout t_logout;
--	struct srp_tsk_mgmt tsk_mgmt;
--	struct srp_cmd cmd;
--	struct srp_rsp rsp;
--	struct srp_cred_req cred_req;
--	struct srp_cred_rsp cred_rsp;
--	struct srp_aer_req aer_req;
--	struct srp_aer_rsp aer_rsp;
--};
--
--#endif
-diff --git a/drivers/scsi/ibmvscsi/viosrp.h b/drivers/scsi/ibmvscsi/viosrp.h
-index 6a6bba8..90f1a61 100644
---- a/drivers/scsi/ibmvscsi/viosrp.h
-+++ b/drivers/scsi/ibmvscsi/viosrp.h
-@@ -33,7 +33,22 @@
- /*****************************************************************************/
- #ifndef VIOSRP_H
- #define VIOSRP_H
--#include "srp.h"
-+#include <scsi/srp.h>
-+
-+#define SRP_VERSION "16.a"
-+#define SRP_MAX_IU_LEN	256
-+
-+union srp_iu {
-+	struct srp_login_req login_req;
-+	struct srp_login_rsp login_rsp;
-+	struct srp_login_rej login_rej;
-+	struct srp_i_logout i_logout;
-+	struct srp_t_logout t_logout;
-+	struct srp_tsk_mgmt tsk_mgmt;
-+	struct srp_cmd cmd;
-+	struct srp_rsp rsp;
-+	u8 reserved[SRP_MAX_IU_LEN];
-+};
- 
- enum viosrp_crq_formats {
- 	VIOSRP_SRP_FORMAT = 0x01,



From tomo at berlios.de  Fri Jun 23 13:33:03 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Jun 2006 13:33:03 +0200
Subject: [Stgt-svn] r490 - / branches
Message-ID: <200606231133.k5NBX3S1020454@sheep.berlios.de>

Author: tomo
Date: 2006-06-23 13:32:51 +0200 (Fri, 23 Jun 2006)
New Revision: 490

Added:
   branches/independent/
Removed:
   trunk/
Log:
Move the main trunk including protocol independent code to the branches directory.


Copied: branches/independent (from rev 489, trunk)



From tomo at berlios.de  Fri Jun 23 13:36:38 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Jun 2006 13:36:38 +0200
Subject: [Stgt-svn] r491 - / branches
Message-ID: <200606231136.k5NBacfn022053@sheep.berlios.de>

Author: tomo
Date: 2006-06-23 13:36:36 +0200 (Fri, 23 Jun 2006)
New Revision: 491

Added:
   trunk/
Removed:
   branches/use-scsi-ml/
Log:
Promote the use-scsi-ml branch to the main trunk.


Copied: trunk (from rev 489, branches/use-scsi-ml)



From tomo at berlios.de  Fri Jun 23 15:13:34 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Jun 2006 15:13:34 +0200
Subject: [Stgt-svn] r493 - trunk
Message-ID: <200606231313.k5NDDYGg024293@sheep.berlios.de>

Author: tomo
Date: 2006-06-23 15:13:33 +0200 (Fri, 23 Jun 2006)
New Revision: 493

Modified:
   trunk/initd
Log:
Fix the initd file for the previous commit.


Modified: trunk/initd
===================================================================
--- trunk/initd	2006-06-23 13:12:12 UTC (rev 492)
+++ trunk/initd	2006-06-23 13:13:33 UTC (rev 493)
@@ -13,7 +13,7 @@
 
 start_server()
 {
-	insmod ${PWD}/kernel/scsi_tgt_core.ko
+	insmod ${PWD}/kernel/scsi_tgt.ko
 
 	if [ "$TARGET" = "istgt" ] ; then
 		modprobe -q crc32c
@@ -55,7 +55,7 @@
 		rmmod ibmvstgt
 	fi
 
-	rmmod scsi_tgt_core
+	rmmod scsi_tgt
 }
 
 case "$1" in



From tomo at berlios.de  Fri Jun 23 15:12:18 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Fri, 23 Jun 2006 15:12:18 +0200
Subject: [Stgt-svn] r492 - trunk/kernel
Message-ID: <200606231312.k5NDCIQ4023432@sheep.berlios.de>

Author: tomo
Date: 2006-06-23 15:12:12 +0200 (Fri, 23 Jun 2006)
New Revision: 492

Modified:
   trunk/kernel/Makefile
Log:
Rename scsi_tgt_core.ko scsi_tgt.ko because of the scsi-target git tree.


Modified: trunk/kernel/Makefile
===================================================================
--- trunk/kernel/Makefile	2006-06-23 11:36:36 UTC (rev 491)
+++ trunk/kernel/Makefile	2006-06-23 13:12:12 UTC (rev 492)
@@ -5,8 +5,8 @@
 EXTRA_CFLAGS += -I$(obj) -I$(obj)/../include -DNETLINK_TGT=17
 
 ifneq ($(KERNELRELEASE),)
-obj-m			+= scsi_tgt_core.o
-scsi_tgt_core-objs	:= scsi_tgt_lib.o scsi_tgt_if.o
+obj-m			+= scsi_tgt.o
+scsi_tgt-objs		:= scsi_tgt_lib.o scsi_tgt_if.o
 
 else
 



From tomo at berlios.de  Tue Jun 27 05:54:47 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 27 Jun 2006 05:54:47 +0200
Subject: [Stgt-svn] r494 - in trunk: ibmvstgt/kernel kernel
Message-ID: <200606270354.k5R3sl74019390@sheep.berlios.de>

Author: tomo
Date: 2006-06-27 05:54:46 +0200 (Tue, 27 Jun 2006)
New Revision: 494

Modified:
   trunk/ibmvstgt/kernel/libsrp.c
   trunk/kernel/scsi_tgt_if.c
   trunk/kernel/scsi_tgt_lib.c
Log:
update for cmnd field removal.


Modified: trunk/ibmvstgt/kernel/libsrp.c
===================================================================
--- trunk/ibmvstgt/kernel/libsrp.c	2006-06-23 13:13:33 UTC (rev 493)
+++ trunk/ibmvstgt/kernel/libsrp.c	2006-06-27 03:54:46 UTC (rev 494)
@@ -433,7 +433,7 @@
 	scmd = scsi_host_get_command(shost, data_dir, GFP_KERNEL);
 	BUG_ON(!scmd);
 	scmd->SCp.ptr = (char *) iue;
-	memcpy(scmd->data_cmnd, cmd->cdb, MAX_COMMAND_SIZE);
+	memcpy(scmd->cmnd, cmd->cdb, MAX_COMMAND_SIZE);
 	scmd->request_bufflen = len;
 	scmd->tag = tag;
 	iue->scmd = scmd;

Modified: trunk/kernel/scsi_tgt_if.c
===================================================================
--- trunk/kernel/scsi_tgt_if.c	2006-06-23 13:13:33 UTC (rev 493)
+++ trunk/kernel/scsi_tgt_if.c	2006-06-27 03:54:46 UTC (rev 494)
@@ -65,9 +65,6 @@
 	struct tgt_event *ev;
 	int err, len;
 
-	/* FIXME: we need scsi core to do that. */
-	memcpy(cmd->cmnd, cmd->data_cmnd, MAX_COMMAND_SIZE);
-
 	len = NLMSG_SPACE(sizeof(*ev));
 	/*
 	 * TODO: add MAX_COMMAND_SIZE to ev and add mempool
@@ -122,7 +119,7 @@
 	ev.k.tsk_mgmt_req.function = function;
 	ev.k.tsk_mgmt_req.tag = tag;
 	memcpy(ev.k.tsk_mgmt_req.lun, scsilun, sizeof(ev.k.tsk_mgmt_req.lun));
-	ev.k.tsk_mgmt_req.mid = (u64) data;
+	ev.k.tsk_mgmt_req.mid = (u64) (unsigned long) data;
 
 	dprintk("%d %x %llx %llx\n", host_no, function, (unsigned long long) tag,
 		(unsigned long long) ev.k.tsk_mgmt_req.mid);

Modified: trunk/kernel/scsi_tgt_lib.c
===================================================================
--- trunk/kernel/scsi_tgt_lib.c	2006-06-23 13:13:33 UTC (rev 493)
+++ trunk/kernel/scsi_tgt_lib.c	2006-06-27 03:54:46 UTC (rev 494)
@@ -50,6 +50,9 @@
 	struct list_head hash_list;
 	struct request *rq;
 	u64 tag;
+
+	void *buffer;
+	unsigned bufflen;
 };
 
 #define TGT_HASH_ORDER	4
@@ -328,6 +331,7 @@
 static int scsi_tgt_init_cmd(struct scsi_cmnd *cmd, gfp_t gfp_mask)
 {
 	struct request *rq = cmd->request;
+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
 	int count;
 
 	cmd->use_sg = rq->nr_phys_segments;
@@ -337,7 +341,7 @@
 
 	cmd->request_bufflen = rq->data_len;
 
-	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, cmd->buffer, cmd->use_sg,
+	dprintk("cmd %p addr %p cnt %d %lu\n", cmd, tcmd->buffer, cmd->use_sg,
 		rq_data_dir(rq));
 	count = blk_rq_map_sg(rq->q, rq, cmd->request_buffer);
 	if (likely(count <= cmd->use_sg)) {
@@ -345,7 +349,7 @@
 		return 0;
 	}
 
-	eprintk("cmd %p addr %p cnt %d\n", cmd, cmd->buffer, cmd->use_sg);
+	eprintk("cmd %p addr %p cnt %d\n", cmd, tcmd->buffer, cmd->use_sg);
 	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
 	return -EINVAL;
 }
@@ -356,8 +360,8 @@
 {
 	struct request_queue *q = cmd->request->q;
 	struct request *rq = cmd->request;
-	void *uaddr = cmd->buffer;
-	unsigned int len = cmd->bufflen;
+	void *uaddr = tcmd->buffer;
+	unsigned int len = tcmd->bufflen;
 	struct bio *bio;
 	int err;
 
@@ -425,12 +429,12 @@
 	}
 
 	dprintk("cmd %p request_bufflen %u bufflen %u\n",
-		cmd, cmd->request_bufflen, cmd->bufflen);
+		cmd, cmd->request_bufflen, tcmd->bufflen);
 
 	scsi_free_sgtable(cmd->request_buffer, cmd->sglist_len);
 	bio_list_add(&tcmd->xfer_done_list, cmd->request->bio);
 
-	cmd->buffer += cmd->request_bufflen;
+	tcmd->buffer += cmd->request_bufflen;
 	cmd->offset += cmd->request_bufflen;
 
 	if (!tcmd->xfer_list.head) {
@@ -439,7 +443,7 @@
 	}
 
 	dprintk("cmd2 %p request_bufflen %u bufflen %u\n",
-		cmd, cmd->request_bufflen, cmd->bufflen);
+		cmd, cmd->request_bufflen, tcmd->bufflen);
 
 	bio = bio_list_pop(&tcmd->xfer_list);
 	BUG_ON(!bio);
@@ -525,6 +529,7 @@
 	struct Scsi_Host *shost;
 	struct scsi_cmnd *cmd;
 	struct request *rq;
+	struct scsi_tgt_cmd *tcmd;
 	int err = 0;
 
 	dprintk("%d %u %d %u %lx %u\n", host_no, cid, result,
@@ -556,12 +561,12 @@
 	 * store the userspace values here, the working values are
 	 * in the request_* values
 	 */
-	cmd->buffer = (void *)uaddr;
-	if (len)
-		cmd->bufflen = len;
+	tcmd = cmd->request->end_io_data;
+	tcmd->buffer = (void *)uaddr;
+	tcmd->bufflen = len;
 	cmd->result = result;
 
-	if (!cmd->bufflen) {
+	if (!tcmd->bufflen) {
 		err = __scsi_tgt_transfer_response(cmd);
 		goto done;
 	}



From tomo at berlios.de  Tue Jun 27 06:27:42 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 27 Jun 2006 06:27:42 +0200
Subject: [Stgt-svn] r495 - trunk/kernel
Message-ID: <200606270427.k5R4RgPP021122@sheep.berlios.de>

Author: tomo
Date: 2006-06-27 06:27:41 +0200 (Tue, 27 Jun 2006)
New Revision: 495

Modified:
   trunk/kernel/scsi_tgt_lib.c
Log:
Move scsi_get_host_command and scsi_put_host_command to scsi_tgt_lib.c
from scsi.c

A target driver allocates scsi_cmnd structure via
scsi_get_host_command, then pass it to tgt core via
scsi_tgt_queue_command. scsi_tgt_queue_command could fail because it
needs to allocate scsi_tgt_cmd structure (for tgt specific data).
Allocating scsi_tgt_cmd structure in scsi_host_get_command simplifies
target drivers.


Modified: trunk/kernel/scsi_tgt_lib.c
===================================================================
--- trunk/kernel/scsi_tgt_lib.c	2006-06-27 03:54:46 UTC (rev 494)
+++ trunk/kernel/scsi_tgt_lib.c	2006-06-27 04:27:41 UTC (rev 495)
@@ -70,6 +70,95 @@
 	struct list_head cmd_req;
 };
 
+/*
+ * Function:	scsi_host_get_command()
+ *
+ * Purpose:	Allocate and setup a scsi command block and blk request
+ *
+ * Arguments:	shost	- scsi host
+ *		data_dir - dma data dir
+ *		gfp_mask- allocator flags
+ *
+ * Returns:	The allocated scsi command structure.
+ *
+ * This should be called by target LLDs to get a command.
+ */
+struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *shost,
+					enum dma_data_direction data_dir,
+					gfp_t gfp_mask)
+{
+	int write = (data_dir == DMA_TO_DEVICE);
+	struct request *rq;
+	struct scsi_cmnd *cmd;
+	struct scsi_tgt_cmd *tcmd;
+
+	/* Bail if we can't get a reference to the device */
+	if (!get_device(&shost->shost_gendev))
+		return NULL;
+
+	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
+	if (!tcmd)
+		goto put_dev;
+
+	rq = blk_get_request(shost->uspace_req_q, write, gfp_mask);
+	if (!rq)
+		goto free_tcmd;
+
+	cmd = __scsi_get_command(shost, gfp_mask);
+	if (!cmd)
+		goto release_rq;
+
+	memset(cmd, 0, sizeof(*cmd));
+	cmd->sc_data_direction = data_dir;
+	cmd->jiffies_at_alloc = jiffies;
+	cmd->request = rq;
+
+	rq->special = cmd;
+	rq->flags |= REQ_SPECIAL | REQ_BLOCK_PC;
+	rq->end_io_data = tcmd;
+
+	return cmd;
+
+release_rq:
+	blk_put_request(rq);
+free_tcmd:
+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+put_dev:
+	put_device(&shost->shost_gendev);
+	return NULL;
+
+}
+EXPORT_SYMBOL_GPL(scsi_host_get_command);
+
+/*
+ * Function:	scsi_host_put_command()
+ *
+ * Purpose:	Free a scsi command block
+ *
+ * Arguments:	shost	- scsi host
+ * 		cmd	- command block to free
+ *
+ * Returns:	Nothing.
+ *
+ * Notes:	The command must not belong to any lists.
+ */
+static void scsi_host_put_command(struct Scsi_Host *shost,
+				  struct scsi_cmnd *cmd)
+{
+	struct request_queue *q = shost->uspace_req_q;
+	struct request *rq = cmd->request;
+	struct scsi_tgt_cmd *tcmd = rq->end_io_data;
+	unsigned long flags;
+
+	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
+
+	spin_lock_irqsave(q->queue_lock, flags);
+	__blk_put_request(q, rq);
+	spin_unlock_irqrestore(q->queue_lock, flags);
+
+	__scsi_put_command(shost, cmd, &shost->shost_gendev);
+}
+
 static void scsi_unmap_user_pages(struct scsi_tgt_cmd *tcmd)
 {
 	struct bio *bio;
@@ -110,7 +199,6 @@
 		cmd->request->flags &= ~1UL;
 
 	scsi_unmap_user_pages(tcmd);
-	kmem_cache_free(scsi_tgt_cmd_cache, tcmd);
 	scsi_host_put_command(scsi_tgt_cmd_to_host(cmd), cmd);
 }
 
@@ -177,13 +265,13 @@
 		goto retry;
 }
 
-/**
+/*
  * scsi_tgt_alloc_queue - setup queue used for message passing
  * shost: scsi host
  *
  * This should be called by the LLD after host allocation.
  * And will be released when the host is released.
- **/
+ */
 int scsi_tgt_alloc_queue(struct Scsi_Host *shost)
 {
 	struct scsi_tgt_queuedata *queuedata;
@@ -244,29 +332,20 @@
 }
 EXPORT_SYMBOL_GPL(scsi_tgt_cmd_to_host);
 
-/**
+/*
  * scsi_tgt_queue_command - queue command for userspace processing
  * @cmd:	scsi command
  * @scsilun:	scsi lun
  * @noblock:	set to nonzero if the command should be queued
- **/
+ */
 int scsi_tgt_queue_command(struct scsi_cmnd *cmd, struct scsi_lun *scsilun,
 			   u64 tag)
 {
 	struct request_queue *q = cmd->request->q;
 	struct scsi_tgt_queuedata *qdata = q->queuedata;
 	unsigned long flags;
-	struct scsi_tgt_cmd *tcmd;
+	struct scsi_tgt_cmd *tcmd = cmd->request->end_io_data;
 
-	/*
-	 * It would be better to allocate scsi_tgt_cmd structure in
-	 * scsi_host_get_command and not to fail due to OOM.
-	 */
-	tcmd = kmem_cache_alloc(scsi_tgt_cmd_cache, GFP_ATOMIC);
-	if (!tcmd)
-		return -ENOMEM;
-	cmd->request->end_io_data = tcmd;
-
 	bio_list_init(&tcmd->xfer_list);
 	bio_list_init(&tcmd->xfer_done_list);
 	tcmd->lun = scsilun;



From tomo at berlios.de  Tue Jun 27 07:49:53 2006
From: tomo at berlios.de (tomo at BerliOS)
Date: Tue, 27 Jun 2006 07:49:53 +0200
Subject: [Stgt-svn] r496 - trunk/patchset
Message-ID: <200606270549.k5R5nrRl008298@sheep.berlios.de>

Author: tomo
Date: 2006-06-27 07:49:03 +0200 (Tue, 27 Jun 2006)
New Revision: 496

Added:
   trunk/patchset/tgt-2.6.17.patch
Log:
tgt headers and mainline changes for 2.6.17. This patch enables you to compile the tgt code in the svn repository for 2.6.17.


Added: trunk/patchset/tgt-2.6.17.patch
===================================================================
--- trunk/patchset/tgt-2.6.17.patch	2006-06-27 04:27:41 UTC (rev 495)
+++ trunk/patchset/tgt-2.6.17.patch	2006-06-27 05:49:03 UTC (rev 496)
@@ -0,0 +1,602 @@
+Subject: [PATCH] scsi tgt: tgt headers and mainline changes.
+
+---
+
+ block/ll_rw_blk.c          |   40 ++++++++++----------
+ block/scsi_ioctl.c         |    3 +
+ drivers/scsi/hosts.c       |    5 ++
+ drivers/scsi/scsi.c        |   43 +++++++++++++--------
+ drivers/scsi/scsi_lib.c    |   33 ++++++++++++----
+ fs/bio.c                   |   19 +--------
+ include/linux/blkdev.h     |    3 +
+ include/linux/netlink.h    |    1 
+ include/scsi/scsi_cmnd.h   |    8 ++++
+ include/scsi/scsi_host.h   |   43 +++++++++++++++++++++
+ include/scsi/scsi_tgt.h    |   17 ++++++++
+ include/scsi/scsi_tgt_if.h |   89 ++++++++++++++++++++++++++++++++++++++++++++
+ 12 files changed, 240 insertions(+), 64 deletions(-)
+ create mode 100644 include/scsi/scsi_tgt.h
+ create mode 100644 include/scsi/scsi_tgt_if.h
+
+92f10cdafc264d0c336ea82f3ddb38dd8d9ab622
+diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
+index 7eb36c5..4fe85d7 100644
+--- a/block/ll_rw_blk.c
++++ b/block/ll_rw_blk.c
+@@ -2351,19 +2351,20 @@ int blk_rq_map_user(request_queue_t *q, 
+ 	else
+ 		bio = bio_copy_user(q, uaddr, len, reading);
+ 
+-	if (!IS_ERR(bio)) {
+-		rq->bio = rq->biotail = bio;
+-		blk_rq_bio_prep(q, rq, bio);
++	if (IS_ERR(bio))
++		return PTR_ERR(bio);
+ 
+-		rq->buffer = rq->data = NULL;
+-		rq->data_len = len;
+-		return 0;
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
+ 	}
+ 
+-	/*
+-	 * bio is the err-ptr
+-	 */
+-	return PTR_ERR(bio);
++	rq->bio = rq->biotail = bio;
++	blk_rq_bio_prep(q, rq, bio);
++	rq->buffer = rq->data = NULL;
++	rq->data_len = len;
++	return 0;
+ }
+ 
+ EXPORT_SYMBOL(blk_rq_map_user);
+@@ -2389,7 +2390,7 @@ EXPORT_SYMBOL(blk_rq_map_user);
+  *    unmapping.
+  */
+ int blk_rq_map_user_iov(request_queue_t *q, struct request *rq,
+-			struct sg_iovec *iov, int iov_count)
++			struct sg_iovec *iov, int iov_count, unsigned int len)
+ {
+ 	struct bio *bio;
+ 
+@@ -2403,6 +2404,12 @@ int blk_rq_map_user_iov(request_queue_t 
+ 	if (IS_ERR(bio))
+ 		return PTR_ERR(bio);
+ 
++	if (bio->bi_size != len) {
++		bio_endio(bio, bio->bi_size, 0);
++		bio_unmap_user(bio);
++		return -EINVAL;
++	}
++
+ 	rq->bio = rq->biotail = bio;
+ 	blk_rq_bio_prep(q, rq, bio);
+ 	rq->buffer = rq->data = NULL;
+@@ -2826,16 +2833,12 @@ static void init_request_from_bio(struct
+ 
+ 	req->errors = 0;
+ 	req->hard_sector = req->sector = bio->bi_sector;
+-	req->hard_nr_sectors = req->nr_sectors = bio_sectors(bio);
+-	req->current_nr_sectors = req->hard_cur_sectors = bio_cur_sectors(bio);
+-	req->nr_phys_segments = bio_phys_segments(req->q, bio);
+-	req->nr_hw_segments = bio_hw_segments(req->q, bio);
+-	req->buffer = bio_data(bio);	/* see ->buffer comment above */
+ 	req->waiting = NULL;
+-	req->bio = req->biotail = bio;
+ 	req->ioprio = bio_prio(bio);
+ 	req->rq_disk = bio->bi_bdev->bd_disk;
+ 	req->start_time = jiffies;
++
++	blk_rq_bio_prep(req->q, req, bio);
+ }
+ 
+ static int __make_request(request_queue_t *q, struct bio *bio)
+@@ -3487,9 +3490,6 @@ EXPORT_SYMBOL(end_request);
+ 
+ void blk_rq_bio_prep(request_queue_t *q, struct request *rq, struct bio *bio)
+ {
+-	/* first three bits are identical in rq->flags and bio->bi_rw */
+-	rq->flags |= (bio->bi_rw & 7);
+-
+ 	rq->nr_phys_segments = bio_phys_segments(q, bio);
+ 	rq->nr_hw_segments = bio_hw_segments(q, bio);
+ 	rq->current_nr_sectors = bio_cur_sectors(bio);
+diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
+index b33eda2..b77e185 100644
+--- a/block/scsi_ioctl.c
++++ b/block/scsi_ioctl.c
+@@ -274,7 +274,8 @@ static int sg_io(struct file *file, requ
+ 			goto out;
+ 		}
+ 
+-		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count);
++		ret = blk_rq_map_user_iov(q, rq, iov, hdr->iovec_count,
++					  hdr->dxfer_len);
+ 		kfree(iov);
+ 	} else if (hdr->dxfer_len)
+ 		ret = blk_rq_map_user(q, rq, hdr->dxferp, hdr->dxfer_len);
+diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
+index dfcb96f..f8cce09 100644
+--- a/drivers/scsi/hosts.c
++++ b/drivers/scsi/hosts.c
+@@ -264,6 +264,11 @@ static void scsi_host_dev_release(struct
+ 	if (shost->work_q)
+ 		destroy_workqueue(shost->work_q);
+ 
++	if (shost->uspace_req_q) {
++		kfree(shost->uspace_req_q->queuedata);
++		scsi_free_queue(shost->uspace_req_q);
++	}
++
+ 	scsi_destroy_command_freelist(shost);
+ 	kfree(shost->shost_data);
+ 
+diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
+index 73994e2..0591b93 100644
+--- a/drivers/scsi/scsi.c
++++ b/drivers/scsi/scsi.c
+@@ -210,8 +210,7 @@ static struct scsi_host_cmd_pool scsi_cm
+ 
+ static DEFINE_MUTEX(host_cmd_pool_mutex);
+ 
+-static struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost,
+-					    gfp_t gfp_mask)
++struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *shost, gfp_t gfp_mask)
+ {
+ 	struct scsi_cmnd *cmd;
+ 
+@@ -232,6 +231,7 @@ static struct scsi_cmnd *__scsi_get_comm
+ 
+ 	return cmd;
+ }
++EXPORT_SYMBOL_GPL(__scsi_get_command);
+ 
+ /*
+  * Function:	scsi_get_command()
+@@ -268,9 +268,29 @@ struct scsi_cmnd *scsi_get_command(struc
+ 		put_device(&dev->sdev_gendev);
+ 
+ 	return cmd;
+-}				
++}
+ EXPORT_SYMBOL(scsi_get_command);
+ 
++void __scsi_put_command(struct Scsi_Host *shost, struct scsi_cmnd *cmd,
++			struct device *dev)
++{
++	unsigned long flags;
++
++	/* changing locks here, don't need to restore the irq state */
++	spin_lock_irqsave(&shost->free_list_lock, flags);
++	if (unlikely(list_empty(&shost->free_list))) {
++		list_add(&cmd->list, &shost->free_list);
++		cmd = NULL;
++	}
++	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++
++	if (likely(cmd != NULL))
++		kmem_cache_free(shost->cmd_pool->slab, cmd);
++
++	put_device(dev);
++}
++EXPORT_SYMBOL(__scsi_put_command);
++
+ /*
+  * Function:	scsi_put_command()
+  *
+@@ -285,26 +305,15 @@ EXPORT_SYMBOL(scsi_get_command);
+ void scsi_put_command(struct scsi_cmnd *cmd)
+ {
+ 	struct scsi_device *sdev = cmd->device;
+-	struct Scsi_Host *shost = sdev->host;
+ 	unsigned long flags;
+-	
++
+ 	/* serious error if the command hasn't come from a device list */
+ 	spin_lock_irqsave(&cmd->device->list_lock, flags);
+ 	BUG_ON(list_empty(&cmd->list));
+ 	list_del_init(&cmd->list);
+-	spin_unlock(&cmd->device->list_lock);
+-	/* changing locks here, don't need to restore the irq state */
+-	spin_lock(&shost->free_list_lock);
+-	if (unlikely(list_empty(&shost->free_list))) {
+-		list_add(&cmd->list, &shost->free_list);
+-		cmd = NULL;
+-	}
+-	spin_unlock_irqrestore(&shost->free_list_lock, flags);
++	spin_unlock_irqrestore(&cmd->device->list_lock, flags);
+ 
+-	if (likely(cmd != NULL))
+-		kmem_cache_free(shost->cmd_pool->slab, cmd);
+-
+-	put_device(&sdev->sdev_gendev);
++	__scsi_put_command(cmd->device->host, cmd, &sdev->sdev_gendev);
+ }
+ EXPORT_SYMBOL(scsi_put_command);
+ 
+diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
+index faee475..f8ac3d5 100644
+--- a/drivers/scsi/scsi_lib.c
++++ b/drivers/scsi/scsi_lib.c
+@@ -803,7 +803,7 @@ static struct scsi_cmnd *scsi_end_reques
+ 	return NULL;
+ }
+ 
+-static struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
++struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *cmd, gfp_t gfp_mask)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 	struct scatterlist *sgl;
+@@ -844,7 +844,9 @@ static struct scatterlist *scsi_alloc_sg
+ 	return sgl;
+ }
+ 
+-static void scsi_free_sgtable(struct scatterlist *sgl, int index)
++EXPORT_SYMBOL(scsi_alloc_sgtable);
++
++void scsi_free_sgtable(struct scatterlist *sgl, int index)
+ {
+ 	struct scsi_host_sg_pool *sgp;
+ 
+@@ -854,6 +856,8 @@ static void scsi_free_sgtable(struct sca
+ 	mempool_free(sgl, sgp->pool);
+ }
+ 
++EXPORT_SYMBOL(scsi_free_sgtable);
++
+ /*
+  * Function:    scsi_release_buffers()
+  *
+@@ -1714,29 +1718,40 @@ u64 scsi_calculate_bounce_limit(struct S
+ }
+ EXPORT_SYMBOL(scsi_calculate_bounce_limit);
+ 
+-struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					 request_fn_proc *request_fn)
+ {
+-	struct Scsi_Host *shost = sdev->host;
+ 	struct request_queue *q;
+ 
+-	q = blk_init_queue(scsi_request_fn, NULL);
++	q = blk_init_queue(request_fn, NULL);
+ 	if (!q)
+ 		return NULL;
+ 
+-	blk_queue_prep_rq(q, scsi_prep_fn);
+-
+ 	blk_queue_max_hw_segments(q, shost->sg_tablesize);
+ 	blk_queue_max_phys_segments(q, SCSI_MAX_PHYS_SEGMENTS);
+ 	blk_queue_max_sectors(q, shost->max_sectors);
+ 	blk_queue_bounce_limit(q, scsi_calculate_bounce_limit(shost));
+ 	blk_queue_segment_boundary(q, shost->dma_boundary);
+-	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
+-	blk_queue_softirq_done(q, scsi_softirq_done);
+ 
+ 	if (!shost->use_clustering)
+ 		clear_bit(QUEUE_FLAG_CLUSTER, &q->queue_flags);
+ 	return q;
+ }
++EXPORT_SYMBOL(__scsi_alloc_queue);
++
++struct request_queue *scsi_alloc_queue(struct scsi_device *sdev)
++{
++	struct request_queue *q;
++
++	q = __scsi_alloc_queue(sdev->host, scsi_request_fn);
++	if (!q)
++		return NULL;
++
++	blk_queue_prep_rq(q, scsi_prep_fn);
++	blk_queue_issue_flush_fn(q, scsi_issue_flush_fn);
++	blk_queue_softirq_done(q, scsi_softirq_done);
++	return q;
++}
+ 
+ void scsi_free_queue(struct request_queue *q)
+ {
+diff --git a/fs/bio.c b/fs/bio.c
+index 6a0b9ad..ade77bf 100644
+--- a/fs/bio.c
++++ b/fs/bio.c
+@@ -621,10 +621,9 @@ static struct bio *__bio_map_user_iov(re
+ 
+ 		nr_pages += end - start;
+ 		/*
+-		 * transfer and buffer must be aligned to at least hardsector
+-		 * size for now, in the future we can relax this restriction
++		 * buffer must be aligned to at least hardsector size for now
+ 		 */
+-		if ((uaddr & queue_dma_alignment(q)) || (len & queue_dma_alignment(q)))
++		if (uaddr & queue_dma_alignment(q))
+ 			return ERR_PTR(-EINVAL);
+ 	}
+ 
+@@ -750,7 +749,6 @@ struct bio *bio_map_user_iov(request_que
+ 			     int write_to_vm)
+ {
+ 	struct bio *bio;
+-	int len = 0, i;
+ 
+ 	bio = __bio_map_user_iov(q, bdev, iov, iov_count, write_to_vm);
+ 
+@@ -765,18 +763,7 @@ struct bio *bio_map_user_iov(request_que
+ 	 */
+ 	bio_get(bio);
+ 
+-	for (i = 0; i < iov_count; i++)
+-		len += iov[i].iov_len;
+-
+-	if (bio->bi_size == len)
+-		return bio;
+-
+-	/*
+-	 * don't support partial mappings
+-	 */
+-	bio_endio(bio, bio->bi_size, 0);
+-	bio_unmap_user(bio);
+-	return ERR_PTR(-EINVAL);
++	return bio;
+ }
+ 
+ static void __bio_unmap_user(struct bio *bio)
+diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
+index 59e1259..cec7ccf 100644
+--- a/include/linux/blkdev.h
++++ b/include/linux/blkdev.h
+@@ -624,7 +624,8 @@ extern void blk_queue_activity_fn(reques
+ extern int blk_rq_map_user(request_queue_t *, struct request *, void __user *, unsigned int);
+ extern int blk_rq_unmap_user(struct bio *, unsigned int);
+ extern int blk_rq_map_kern(request_queue_t *, struct request *, void *, unsigned int, gfp_t);
+-extern int blk_rq_map_user_iov(request_queue_t *, struct request *, struct sg_iovec *, int);
++extern int blk_rq_map_user_iov(request_queue_t *, struct request *,
++			       struct sg_iovec *, int, unsigned int);
+ extern int blk_execute_rq(request_queue_t *, struct gendisk *,
+ 			  struct request *, int);
+ extern void blk_execute_rq_nowait(request_queue_t *, struct gendisk *,
+diff --git a/include/linux/netlink.h b/include/linux/netlink.h
+index 87b8a57..cfac287 100644
+--- a/include/linux/netlink.h
++++ b/include/linux/netlink.h
+@@ -21,6 +21,7 @@
+ #define NETLINK_DNRTMSG		14	/* DECnet routing messages */
+ #define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
+ #define NETLINK_GENERIC		16
++#define NETLINK_TGT		17	/* SCSI target */
+ 
+ #define MAX_LINKS 32		
+ 
+diff --git a/include/scsi/scsi_cmnd.h b/include/scsi/scsi_cmnd.h
+index 1ace1b9..d69dbf5 100644
+--- a/include/scsi/scsi_cmnd.h
++++ b/include/scsi/scsi_cmnd.h
+@@ -8,6 +8,7 @@
+ 
+ struct request;
+ struct scatterlist;
++struct Scsi_Host;
+ struct scsi_device;
+ struct scsi_request;
+ 
+@@ -84,6 +85,8 @@ struct scsi_cmnd {
+ 	unsigned short sglist_len;	/* size of malloc'd scatter-gather list */
+ 	unsigned bufflen;	/* Size of data buffer */
+ 	void *buffer;		/* Data buffer */
++	/* offset in cmd we are at (for multi-transfer tgt cmds) */
++	unsigned offset;
+ 
+ 	unsigned underflow;	/* Return error if less than
+ 				   this amount is transferred */
+@@ -148,8 +151,13 @@ struct scsi_cmnd {
+ 
+ 
+ extern struct scsi_cmnd *scsi_get_command(struct scsi_device *, gfp_t);
++extern struct scsi_cmnd *__scsi_get_command(struct Scsi_Host *, gfp_t);
+ extern void scsi_put_command(struct scsi_cmnd *);
++extern void __scsi_put_command(struct Scsi_Host *, struct scsi_cmnd *,
++			       struct device *);
+ extern void scsi_io_completion(struct scsi_cmnd *, unsigned int, unsigned int);
+ extern void scsi_finish_command(struct scsi_cmnd *cmd);
++extern struct scatterlist *scsi_alloc_sgtable(struct scsi_cmnd *, gfp_t);
++extern void scsi_free_sgtable(struct scatterlist *, int);
+ 
+ #endif /* _SCSI_SCSI_CMND_H */
+diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
+index de6ce54..353abe5 100644
+--- a/include/scsi/scsi_host.h
++++ b/include/scsi/scsi_host.h
+@@ -7,6 +7,7 @@
+ #include <linux/workqueue.h>
+ #include <linux/mutex.h>
+ 
++struct request_queue;
+ struct block_device;
+ struct completion;
+ struct module;
+@@ -123,6 +124,39 @@ struct scsi_host_template {
+ 			     void (*done)(struct scsi_cmnd *));
+ 
+ 	/*
++	 * The transfer functions are used to queue a scsi command to
++	 * the LLD. When the driver is finished processing the command
++	 * the done callback is invoked.
++	 *
++	 * return values: see queuecommand
++	 *
++	 * If the LLD accepts the cmd, it should set the result to an
++	 * appropriate value when completed before calling the done function.
++	 *
++	 * STATUS: REQUIRED FOR TARGET DRIVERS
++	 */
++	/* TODO: rename */
++	int (* transfer_response)(struct scsi_cmnd *,
++				  void (*done)(struct scsi_cmnd *));
++	/*
++	 * This is called to inform the LLD to transfer cmd->request_bufflen
++	 * bytes of the cmd at cmd->offset in the cmd. The cmd->use_sg
++	 * speciefies the number of scatterlist entried in the command
++	 * and cmd->request_buffer contains the scatterlist.
++	 *
++	 * If the command cannot be processed in one transfer_data call
++	 * becuase a scatterlist within the LLD's limits cannot be
++	 * created then transfer_data will be called multiple times.
++	 * It is initially called from process context, and later
++	 * calls are from the interrup context.
++	 */
++	int (* transfer_data)(struct scsi_cmnd *,
++			      void (*done)(struct scsi_cmnd *));
++
++	/* Used as callback for the completion of task management request. */
++	int (* tsk_mgmt_response)(u64 mid, int result);
++
++	/*
+ 	 * This is an error handling strategy routine.  You don't need to
+ 	 * define one of these if you don't want to - there is a default
+ 	 * routine that is present that should work in most cases.  For those
+@@ -557,6 +591,12 @@ struct Scsi_Host {
+ 	 */
+ 	unsigned int max_host_blocked;
+ 
++	/*
++	 * q used for scsi_tgt msgs, async events or any other requests that
++	 * need to be processed in userspace
++ 	 */
++	struct request_queue *uspace_req_q;
++
+ 	/* legacy crap */
+ 	unsigned long base;
+ 	unsigned long io_port;
+@@ -659,6 +699,9 @@ extern void scsi_unblock_requests(struct
+ extern void scsi_block_requests(struct Scsi_Host *);
+ 
+ struct class_container;
++
++extern struct request_queue *__scsi_alloc_queue(struct Scsi_Host *shost,
++					     void (*) (struct request_queue *));
+ /*
+  * These two functions are used to allocate and free a pseudo device
+  * which will connect to the host adapter itself rather than any
+diff --git a/include/scsi/scsi_tgt.h b/include/scsi/scsi_tgt.h
+new file mode 100644
+index 0000000..61e8ee9
+--- /dev/null
++++ b/include/scsi/scsi_tgt.h
+@@ -0,0 +1,17 @@
++/*
++ * SCSI target definitions
++ */
++
++#include <linux/dma-mapping.h>
++
++struct Scsi_Host;
++struct scsi_cmnd;
++struct scsi_lun;
++
++extern struct Scsi_Host *scsi_tgt_cmd_to_host(struct scsi_cmnd *);
++extern int scsi_tgt_alloc_queue(struct Scsi_Host *);
++extern int scsi_tgt_queue_command(struct scsi_cmnd *, struct scsi_lun *, u64);
++extern int scsi_tgt_tsk_mgmt_request(struct Scsi_Host *, int, u64, struct scsi_lun *,
++				     void *);
++extern struct scsi_cmnd *scsi_host_get_command(struct Scsi_Host *,
++					       enum dma_data_direction,	gfp_t);
+diff --git a/include/scsi/scsi_tgt_if.h b/include/scsi/scsi_tgt_if.h
+new file mode 100644
+index 0000000..63b2e3a
+--- /dev/null
++++ b/include/scsi/scsi_tgt_if.h
+@@ -0,0 +1,89 @@
++/*
++ * SCSI target kernel/user interface
++ *
++ * Copyright (C) 2005 FUJITA Tomonori <tomof at acm.org>
++ * Copyright (C) 2005 Mike Christie <michaelc at cs.wisc.edu>
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License as
++ * published by the Free Software Foundation; either version 2 of the
++ * License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful, but
++ * WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * General Public License for more details.
++ *
++ * You should have received a copy of the GNU General Public License
++ * along with this program; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
++ * 02110-1301 USA
++ */
++#ifndef __SCSI_TARGET_IF_H
++#define __SCSI_TARGET_IF_H
++
++enum tgt_event_type {
++	/* user -> kernel */
++	TGT_UEVENT_REQ,
++	TGT_UEVENT_CMD_RSP,
++	TGT_UEVENT_TSK_MGMT_RSP,
++
++	/* kernel -> user */
++	TGT_KEVENT_RSP,
++	TGT_KEVENT_CMD_REQ,
++	TGT_KEVENT_CMD_DONE,
++	TGT_KEVENT_TSK_MGMT_REQ,
++};
++
++struct tgt_event {
++	/* user-> kernel */
++	union {
++		struct {
++			int type;
++			int host_no;
++		} event_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t len;
++			int result;
++			uint64_t uaddr;
++			uint8_t rw;
++		} cmd_rsp;
++		struct {
++			int host_no;
++			uint64_t mid;
++			int result;
++		} tsk_mgmt_rsp;
++	} u;
++
++	/* kernel -> user */
++	union {
++		struct {
++			int err;
++		} event_rsp;
++		struct {
++			int host_no;
++			uint32_t cid;
++			uint32_t data_len;
++			uint8_t scb[16];
++			uint8_t lun[8];
++			int attribute;
++			uint64_t tag;
++		} cmd_req;
++		struct {
++			int host_no;
++			uint32_t cid;
++			int result;
++		} cmd_done;
++		struct {
++			int host_no;
++			int function;
++			uint64_t tag;
++			uint8_t lun[8];
++			uint64_t mid;
++		} tsk_mgmt_req;
++	} k;
++
++} __attribute__ ((aligned (sizeof(uint64_t))));
++#endif
+-- 
+1.1.3



